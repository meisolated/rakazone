/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["pages/Watch/[videoId]"],{

/***/ "./node_modules/hls.js/dist/hls.js":
/*!*****************************************!*\
  !*** ./node_modules/hls.js/dist/hls.js ***!
  \*****************************************/
/***/ (function(module) {

eval("typeof window !== \"undefined\" &&\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory();\n\telse {}\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __nested_webpack_require_562__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_562__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__nested_webpack_require_562__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__nested_webpack_require_562__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__nested_webpack_require_562__.d = function(exports, name, getter) {\n/******/ \t\tif(!__nested_webpack_require_562__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// define __esModule on exports\n/******/ \t__nested_webpack_require_562__.r = function(exports) {\n/******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t}\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t};\n/******/\n/******/ \t// create a fake namespace object\n/******/ \t// mode & 1: value is a module id, require it\n/******/ \t// mode & 2: merge all properties of value into the ns\n/******/ \t// mode & 4: return value when already ns object\n/******/ \t// mode & 8|1: behave like require\n/******/ \t__nested_webpack_require_562__.t = function(value, mode) {\n/******/ \t\tif(mode & 1) value = __nested_webpack_require_562__(value);\n/******/ \t\tif(mode & 8) return value;\n/******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n/******/ \t\tvar ns = Object.create(null);\n/******/ \t\t__nested_webpack_require_562__.r(ns);\n/******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n/******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __nested_webpack_require_562__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n/******/ \t\treturn ns;\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__nested_webpack_require_562__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__nested_webpack_require_562__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__nested_webpack_require_562__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__nested_webpack_require_562__.p = \"/dist/\";\n/******/\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __nested_webpack_require_562__(__nested_webpack_require_562__.s = \"./src/hls.ts\");\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ \"./node_modules/eventemitter3/index.js\":\n/*!*********************************************!*\\\n  !*** ./node_modules/eventemitter3/index.js ***!\n  \\*********************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar has = Object.prototype.hasOwnProperty\n  , prefix = '~';\n\n/**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @private\n */\nfunction Events() {}\n\n//\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\nif (Object.create) {\n  Events.prototype = Object.create(null);\n\n  //\n  // This hack is needed because the `__proto__` property is still inherited in\n  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n  //\n  if (!new Events().__proto__) prefix = false;\n}\n\n/**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Add a listener for a given event.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} once Specify if the listener is a one-time listener.\n * @returns {EventEmitter}\n * @private\n */\nfunction addListener(emitter, event, fn, context, once) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('The listener must be a function');\n  }\n\n  var listener = new EE(fn, context || emitter, once)\n    , evt = prefix ? prefix + event : event;\n\n  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n  else emitter._events[evt] = [emitter._events[evt], listener];\n\n  return emitter;\n}\n\n/**\n * Clear event by name.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} evt The Event name.\n * @private\n */\nfunction clearEvent(emitter, evt) {\n  if (--emitter._eventsCount === 0) emitter._events = new Events();\n  else delete emitter._events[evt];\n}\n\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @public\n */\nfunction EventEmitter() {\n  this._events = new Events();\n  this._eventsCount = 0;\n}\n\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @public\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  var names = []\n    , events\n    , name;\n\n  if (this._eventsCount === 0) return names;\n\n  for (name in (events = this._events)) {\n    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    return names.concat(Object.getOwnPropertySymbols(events));\n  }\n\n  return names;\n};\n\n/**\n * Return the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Array} The registered listeners.\n * @public\n */\nEventEmitter.prototype.listeners = function listeners(event) {\n  var evt = prefix ? prefix + event : event\n    , handlers = this._events[evt];\n\n  if (!handlers) return [];\n  if (handlers.fn) return [handlers.fn];\n\n  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n    ee[i] = handlers[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Return the number of listeners listening to a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Number} The number of listeners.\n * @public\n */\nEventEmitter.prototype.listenerCount = function listenerCount(event) {\n  var evt = prefix ? prefix + event : event\n    , listeners = this._events[evt];\n\n  if (!listeners) return 0;\n  if (listeners.fn) return 1;\n  return listeners.length;\n};\n\n/**\n * Calls each of the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if (listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Add a listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  return addListener(this, event, fn, context, false);\n};\n\n/**\n * Add a one-time listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  return addListener(this, event, fn, context, true);\n};\n\n/**\n * Remove the listeners of a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {*} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return this;\n  if (!fn) {\n    clearEvent(this, evt);\n    return this;\n  }\n\n  var listeners = this._events[evt];\n\n  if (listeners.fn) {\n    if (\n      listeners.fn === fn &&\n      (!once || listeners.once) &&\n      (!context || listeners.context === context)\n    ) {\n      clearEvent(this, evt);\n    }\n  } else {\n    for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n      if (\n        listeners[i].fn !== fn ||\n        (once && !listeners[i].once) ||\n        (context && listeners[i].context !== context)\n      ) {\n        events.push(listeners[i]);\n      }\n    }\n\n    //\n    // Reset the array, or remove it completely if we have no more listeners.\n    //\n    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n    else clearEvent(this, evt);\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners, or those of the specified event.\n *\n * @param {(String|Symbol)} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  var evt;\n\n  if (event) {\n    evt = prefix ? prefix + event : event;\n    if (this._events[evt]) clearEvent(this, evt);\n  } else {\n    this._events = new Events();\n    this._eventsCount = 0;\n  }\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Allow `EventEmitter` to be imported as module namespace.\n//\nEventEmitter.EventEmitter = EventEmitter;\n\n//\n// Expose the module.\n//\nif (true) {\n  module.exports = EventEmitter;\n}\n\n\n/***/ }),\n\n/***/ \"./node_modules/url-toolkit/src/url-toolkit.js\":\n/*!*****************************************************!*\\\n  !*** ./node_modules/url-toolkit/src/url-toolkit.js ***!\n  \\*****************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n// see https://tools.ietf.org/html/rfc1808\n\n(function (root) {\n  var URL_REGEX =\n    /^((?:[a-zA-Z0-9+\\-.]+:)?)(\\/\\/[^\\/?#]*)?((?:[^\\/?#]*\\/)*[^;?#]*)?(;[^?#]*)?(\\?[^#]*)?(#[^]*)?$/;\n  var FIRST_SEGMENT_REGEX = /^([^\\/?#]*)([^]*)$/;\n  var SLASH_DOT_REGEX = /(?:\\/|^)\\.(?=\\/)/g;\n  var SLASH_DOT_DOT_REGEX = /(?:\\/|^)\\.\\.\\/(?!\\.\\.\\/)[^\\/]*(?=\\/)/g;\n\n  var URLToolkit = {\n    // If opts.alwaysNormalize is true then the path will always be normalized even when it starts with / or //\n    // E.g\n    // With opts.alwaysNormalize = false (default, spec compliant)\n    // http://a.com/b/cd + /e/f/../g => http://a.com/e/f/../g\n    // With opts.alwaysNormalize = true (not spec compliant)\n    // http://a.com/b/cd + /e/f/../g => http://a.com/e/g\n    buildAbsoluteURL: function (baseURL, relativeURL, opts) {\n      opts = opts || {};\n      // remove any remaining space and CRLF\n      baseURL = baseURL.trim();\n      relativeURL = relativeURL.trim();\n      if (!relativeURL) {\n        // 2a) If the embedded URL is entirely empty, it inherits the\n        // entire base URL (i.e., is set equal to the base URL)\n        // and we are done.\n        if (!opts.alwaysNormalize) {\n          return baseURL;\n        }\n        var basePartsForNormalise = URLToolkit.parseURL(baseURL);\n        if (!basePartsForNormalise) {\n          throw new Error('Error trying to parse base URL.');\n        }\n        basePartsForNormalise.path = URLToolkit.normalizePath(\n          basePartsForNormalise.path\n        );\n        return URLToolkit.buildURLFromParts(basePartsForNormalise);\n      }\n      var relativeParts = URLToolkit.parseURL(relativeURL);\n      if (!relativeParts) {\n        throw new Error('Error trying to parse relative URL.');\n      }\n      if (relativeParts.scheme) {\n        // 2b) If the embedded URL starts with a scheme name, it is\n        // interpreted as an absolute URL and we are done.\n        if (!opts.alwaysNormalize) {\n          return relativeURL;\n        }\n        relativeParts.path = URLToolkit.normalizePath(relativeParts.path);\n        return URLToolkit.buildURLFromParts(relativeParts);\n      }\n      var baseParts = URLToolkit.parseURL(baseURL);\n      if (!baseParts) {\n        throw new Error('Error trying to parse base URL.');\n      }\n      if (!baseParts.netLoc && baseParts.path && baseParts.path[0] !== '/') {\n        // If netLoc missing and path doesn't start with '/', assume everthing before the first '/' is the netLoc\n        // This causes 'example.com/a' to be handled as '//example.com/a' instead of '/example.com/a'\n        var pathParts = FIRST_SEGMENT_REGEX.exec(baseParts.path);\n        baseParts.netLoc = pathParts[1];\n        baseParts.path = pathParts[2];\n      }\n      if (baseParts.netLoc && !baseParts.path) {\n        baseParts.path = '/';\n      }\n      var builtParts = {\n        // 2c) Otherwise, the embedded URL inherits the scheme of\n        // the base URL.\n        scheme: baseParts.scheme,\n        netLoc: relativeParts.netLoc,\n        path: null,\n        params: relativeParts.params,\n        query: relativeParts.query,\n        fragment: relativeParts.fragment,\n      };\n      if (!relativeParts.netLoc) {\n        // 3) If the embedded URL's <net_loc> is non-empty, we skip to\n        // Step 7.  Otherwise, the embedded URL inherits the <net_loc>\n        // (if any) of the base URL.\n        builtParts.netLoc = baseParts.netLoc;\n        // 4) If the embedded URL path is preceded by a slash \"/\", the\n        // path is not relative and we skip to Step 7.\n        if (relativeParts.path[0] !== '/') {\n          if (!relativeParts.path) {\n            // 5) If the embedded URL path is empty (and not preceded by a\n            // slash), then the embedded URL inherits the base URL path\n            builtParts.path = baseParts.path;\n            // 5a) if the embedded URL's <params> is non-empty, we skip to\n            // step 7; otherwise, it inherits the <params> of the base\n            // URL (if any) and\n            if (!relativeParts.params) {\n              builtParts.params = baseParts.params;\n              // 5b) if the embedded URL's <query> is non-empty, we skip to\n              // step 7; otherwise, it inherits the <query> of the base\n              // URL (if any) and we skip to step 7.\n              if (!relativeParts.query) {\n                builtParts.query = baseParts.query;\n              }\n            }\n          } else {\n            // 6) The last segment of the base URL's path (anything\n            // following the rightmost slash \"/\", or the entire path if no\n            // slash is present) is removed and the embedded URL's path is\n            // appended in its place.\n            var baseURLPath = baseParts.path;\n            var newPath =\n              baseURLPath.substring(0, baseURLPath.lastIndexOf('/') + 1) +\n              relativeParts.path;\n            builtParts.path = URLToolkit.normalizePath(newPath);\n          }\n        }\n      }\n      if (builtParts.path === null) {\n        builtParts.path = opts.alwaysNormalize\n          ? URLToolkit.normalizePath(relativeParts.path)\n          : relativeParts.path;\n      }\n      return URLToolkit.buildURLFromParts(builtParts);\n    },\n    parseURL: function (url) {\n      var parts = URL_REGEX.exec(url);\n      if (!parts) {\n        return null;\n      }\n      return {\n        scheme: parts[1] || '',\n        netLoc: parts[2] || '',\n        path: parts[3] || '',\n        params: parts[4] || '',\n        query: parts[5] || '',\n        fragment: parts[6] || '',\n      };\n    },\n    normalizePath: function (path) {\n      // The following operations are\n      // then applied, in order, to the new path:\n      // 6a) All occurrences of \"./\", where \".\" is a complete path\n      // segment, are removed.\n      // 6b) If the path ends with \".\" as a complete path segment,\n      // that \".\" is removed.\n      path = path.split('').reverse().join('').replace(SLASH_DOT_REGEX, '');\n      // 6c) All occurrences of \"<segment>/../\", where <segment> is a\n      // complete path segment not equal to \"..\", are removed.\n      // Removal of these path segments is performed iteratively,\n      // removing the leftmost matching pattern on each iteration,\n      // until no matching pattern remains.\n      // 6d) If the path ends with \"<segment>/..\", where <segment> is a\n      // complete path segment not equal to \"..\", that\n      // \"<segment>/..\" is removed.\n      while (\n        path.length !== (path = path.replace(SLASH_DOT_DOT_REGEX, '')).length\n      ) {}\n      return path.split('').reverse().join('');\n    },\n    buildURLFromParts: function (parts) {\n      return (\n        parts.scheme +\n        parts.netLoc +\n        parts.path +\n        parts.params +\n        parts.query +\n        parts.fragment\n      );\n    },\n  };\n\n  if (true)\n    module.exports = URLToolkit;\n  else {}\n})(this);\n\n\n/***/ }),\n\n/***/ \"./node_modules/webworkify-webpack/index.js\":\n/*!**************************************************!*\\\n  !*** ./node_modules/webworkify-webpack/index.js ***!\n  \\**************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __nested_webpack_require_20857__) {\n\nfunction webpackBootstrapFunc (modules) {\n/******/  // The module cache\n/******/  var installedModules = {};\n\n/******/  // The require function\n/******/  function __nested_webpack_require_21035__(moduleId) {\n\n/******/    // Check if module is in cache\n/******/    if(installedModules[moduleId])\n/******/      return installedModules[moduleId].exports;\n\n/******/    // Create a new module (and put it into the cache)\n/******/    var module = installedModules[moduleId] = {\n/******/      i: moduleId,\n/******/      l: false,\n/******/      exports: {}\n/******/    };\n\n/******/    // Execute the module function\n/******/    modules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_21035__);\n\n/******/    // Flag the module as loaded\n/******/    module.l = true;\n\n/******/    // Return the exports of the module\n/******/    return module.exports;\n/******/  }\n\n/******/  // expose the modules object (__webpack_modules__)\n/******/  __nested_webpack_require_21035__.m = modules;\n\n/******/  // expose the module cache\n/******/  __nested_webpack_require_21035__.c = installedModules;\n\n/******/  // identity function for calling harmony imports with the correct context\n/******/  __nested_webpack_require_21035__.i = function(value) { return value; };\n\n/******/  // define getter function for harmony exports\n/******/  __nested_webpack_require_21035__.d = function(exports, name, getter) {\n/******/    if(!__nested_webpack_require_21035__.o(exports, name)) {\n/******/      Object.defineProperty(exports, name, {\n/******/        configurable: false,\n/******/        enumerable: true,\n/******/        get: getter\n/******/      });\n/******/    }\n/******/  };\n\n/******/  // define __esModule on exports\n/******/  __nested_webpack_require_21035__.r = function(exports) {\n/******/    Object.defineProperty(exports, '__esModule', { value: true });\n/******/  };\n\n/******/  // getDefaultExport function for compatibility with non-harmony modules\n/******/  __nested_webpack_require_21035__.n = function(module) {\n/******/    var getter = module && module.__esModule ?\n/******/      function getDefault() { return module['default']; } :\n/******/      function getModuleExports() { return module; };\n/******/    __nested_webpack_require_21035__.d(getter, 'a', getter);\n/******/    return getter;\n/******/  };\n\n/******/  // Object.prototype.hasOwnProperty.call\n/******/  __nested_webpack_require_21035__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n/******/  // __webpack_public_path__\n/******/  __nested_webpack_require_21035__.p = \"/\";\n\n/******/  // on error function for async loading\n/******/  __nested_webpack_require_21035__.oe = function(err) { console.error(err); throw err; };\n\n  var f = __nested_webpack_require_21035__(__nested_webpack_require_21035__.s = ENTRY_MODULE)\n  return f.default || f // try to call default if defined to also support babel esmodule exports\n}\n\nvar moduleNameReqExp = '[\\\\.|\\\\-|\\\\+|\\\\w|\\/|@]+'\nvar dependencyRegExp = '\\\\(\\\\s*(\\/\\\\*.*?\\\\*\\/)?\\\\s*.*?(' + moduleNameReqExp + ').*?\\\\)' // additional chars when output.pathinfo is true\n\n// http://stackoverflow.com/a/2593661/130442\nfunction quoteRegExp (str) {\n  return (str + '').replace(/[.?*+^$[\\]\\\\(){}|-]/g, '\\\\$&')\n}\n\nfunction isNumeric(n) {\n  return !isNaN(1 * n); // 1 * n converts integers, integers as string (\"123\"), 1e3 and \"1e3\" to integers and strings to NaN\n}\n\nfunction getModuleDependencies (sources, module, queueName) {\n  var retval = {}\n  retval[queueName] = []\n\n  var fnString = module.toString()\n  var wrapperSignature = fnString.match(/^function\\s?\\w*\\(\\w+,\\s*\\w+,\\s*(\\w+)\\)/)\n  if (!wrapperSignature) return retval\n  var webpackRequireName = wrapperSignature[1]\n\n  // main bundle deps\n  var re = new RegExp('(\\\\\\\\n|\\\\W)' + quoteRegExp(webpackRequireName) + dependencyRegExp, 'g')\n  var match\n  while ((match = re.exec(fnString))) {\n    if (match[3] === 'dll-reference') continue\n    retval[queueName].push(match[3])\n  }\n\n  // dll deps\n  re = new RegExp('\\\\(' + quoteRegExp(webpackRequireName) + '\\\\(\"(dll-reference\\\\s(' + moduleNameReqExp + '))\"\\\\)\\\\)' + dependencyRegExp, 'g')\n  while ((match = re.exec(fnString))) {\n    if (!sources[match[2]]) {\n      retval[queueName].push(match[1])\n      sources[match[2]] = __nested_webpack_require_20857__(match[1]).m\n    }\n    retval[match[2]] = retval[match[2]] || []\n    retval[match[2]].push(match[4])\n  }\n\n  // convert 1e3 back to 1000 - this can be important after uglify-js converted 1000 to 1e3\n  var keys = Object.keys(retval);\n  for (var i = 0; i < keys.length; i++) {\n    for (var j = 0; j < retval[keys[i]].length; j++) {\n      if (isNumeric(retval[keys[i]][j])) {\n        retval[keys[i]][j] = 1 * retval[keys[i]][j];\n      }\n    }\n  }\n\n  return retval\n}\n\nfunction hasValuesInQueues (queues) {\n  var keys = Object.keys(queues)\n  return keys.reduce(function (hasValues, key) {\n    return hasValues || queues[key].length > 0\n  }, false)\n}\n\nfunction getRequiredModules (sources, moduleId) {\n  var modulesQueue = {\n    main: [moduleId]\n  }\n  var requiredModules = {\n    main: []\n  }\n  var seenModules = {\n    main: {}\n  }\n\n  while (hasValuesInQueues(modulesQueue)) {\n    var queues = Object.keys(modulesQueue)\n    for (var i = 0; i < queues.length; i++) {\n      var queueName = queues[i]\n      var queue = modulesQueue[queueName]\n      var moduleToCheck = queue.pop()\n      seenModules[queueName] = seenModules[queueName] || {}\n      if (seenModules[queueName][moduleToCheck] || !sources[queueName][moduleToCheck]) continue\n      seenModules[queueName][moduleToCheck] = true\n      requiredModules[queueName] = requiredModules[queueName] || []\n      requiredModules[queueName].push(moduleToCheck)\n      var newModules = getModuleDependencies(sources, sources[queueName][moduleToCheck], queueName)\n      var newModulesKeys = Object.keys(newModules)\n      for (var j = 0; j < newModulesKeys.length; j++) {\n        modulesQueue[newModulesKeys[j]] = modulesQueue[newModulesKeys[j]] || []\n        modulesQueue[newModulesKeys[j]] = modulesQueue[newModulesKeys[j]].concat(newModules[newModulesKeys[j]])\n      }\n    }\n  }\n\n  return requiredModules\n}\n\nmodule.exports = function (moduleId, options) {\n  options = options || {}\n  var sources = {\n    main: __nested_webpack_require_20857__.m\n  }\n\n  var requiredModules = options.all ? { main: Object.keys(sources.main) } : getRequiredModules(sources, moduleId)\n\n  var src = ''\n\n  Object.keys(requiredModules).filter(function (m) { return m !== 'main' }).forEach(function (module) {\n    var entryModule = 0\n    while (requiredModules[module][entryModule]) {\n      entryModule++\n    }\n    requiredModules[module].push(entryModule)\n    sources[module][entryModule] = '(function(module, exports, __webpack_require__) { module.exports = __webpack_require__; })'\n    src = src + 'var ' + module + ' = (' + webpackBootstrapFunc.toString().replace('ENTRY_MODULE', JSON.stringify(entryModule)) + ')({' + requiredModules[module].map(function (id) { return '' + JSON.stringify(id) + ': ' + sources[module][id].toString() }).join(',') + '});\\n'\n  })\n\n  src = src + 'new ((' + webpackBootstrapFunc.toString().replace('ENTRY_MODULE', JSON.stringify(moduleId)) + ')({' + requiredModules.main.map(function (id) { return '' + JSON.stringify(id) + ': ' + sources.main[id].toString() }).join(',') + '}))(self);'\n\n  var blob = new window.Blob([src], { type: 'text/javascript' })\n  if (options.bare) { return blob }\n\n  var URL = window.URL || window.webkitURL || window.mozURL || window.msURL\n\n  var workerUrl = URL.createObjectURL(blob)\n  var worker = new window.Worker(workerUrl)\n  worker.objectURL = workerUrl\n\n  return worker\n}\n\n\n/***/ }),\n\n/***/ \"./src/config.ts\":\n/*!***********************!*\\\n  !*** ./src/config.ts ***!\n  \\***********************/\n/*! exports provided: hlsDefaultConfig, mergeConfig, enableStreamingMode */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_28568__) {\n\n\"use strict\";\n__nested_webpack_require_28568__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_28568__.d(__webpack_exports__, \"hlsDefaultConfig\", function() { return hlsDefaultConfig; });\n/* harmony export (binding) */ __nested_webpack_require_28568__.d(__webpack_exports__, \"mergeConfig\", function() { return mergeConfig; });\n/* harmony export (binding) */ __nested_webpack_require_28568__.d(__webpack_exports__, \"enableStreamingMode\", function() { return enableStreamingMode; });\n/* harmony import */ var _controller_abr_controller__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_28568__(/*! ./controller/abr-controller */ \"./src/controller/abr-controller.ts\");\n/* harmony import */ var _controller_audio_stream_controller__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_28568__(/*! ./controller/audio-stream-controller */ \"./src/controller/audio-stream-controller.ts\");\n/* harmony import */ var _controller_audio_track_controller__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_28568__(/*! ./controller/audio-track-controller */ \"./src/controller/audio-track-controller.ts\");\n/* harmony import */ var _controller_subtitle_stream_controller__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_28568__(/*! ./controller/subtitle-stream-controller */ \"./src/controller/subtitle-stream-controller.ts\");\n/* harmony import */ var _controller_subtitle_track_controller__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_28568__(/*! ./controller/subtitle-track-controller */ \"./src/controller/subtitle-track-controller.ts\");\n/* harmony import */ var _controller_buffer_controller__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_28568__(/*! ./controller/buffer-controller */ \"./src/controller/buffer-controller.ts\");\n/* harmony import */ var _controller_timeline_controller__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_28568__(/*! ./controller/timeline-controller */ \"./src/controller/timeline-controller.ts\");\n/* harmony import */ var _controller_cap_level_controller__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_28568__(/*! ./controller/cap-level-controller */ \"./src/controller/cap-level-controller.ts\");\n/* harmony import */ var _controller_fps_controller__WEBPACK_IMPORTED_MODULE_8__ = __nested_webpack_require_28568__(/*! ./controller/fps-controller */ \"./src/controller/fps-controller.ts\");\n/* harmony import */ var _controller_eme_controller__WEBPACK_IMPORTED_MODULE_9__ = __nested_webpack_require_28568__(/*! ./controller/eme-controller */ \"./src/controller/eme-controller.ts\");\n/* harmony import */ var _controller_cmcd_controller__WEBPACK_IMPORTED_MODULE_10__ = __nested_webpack_require_28568__(/*! ./controller/cmcd-controller */ \"./src/controller/cmcd-controller.ts\");\n/* harmony import */ var _utils_xhr_loader__WEBPACK_IMPORTED_MODULE_11__ = __nested_webpack_require_28568__(/*! ./utils/xhr-loader */ \"./src/utils/xhr-loader.ts\");\n/* harmony import */ var _utils_fetch_loader__WEBPACK_IMPORTED_MODULE_12__ = __nested_webpack_require_28568__(/*! ./utils/fetch-loader */ \"./src/utils/fetch-loader.ts\");\n/* harmony import */ var _utils_cues__WEBPACK_IMPORTED_MODULE_13__ = __nested_webpack_require_28568__(/*! ./utils/cues */ \"./src/utils/cues.ts\");\n/* harmony import */ var _utils_mediakeys_helper__WEBPACK_IMPORTED_MODULE_14__ = __nested_webpack_require_28568__(/*! ./utils/mediakeys-helper */ \"./src/utils/mediakeys-helper.ts\");\n/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_15__ = __nested_webpack_require_28568__(/*! ./utils/logger */ \"./src/utils/logger.ts\");\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// If possible, keep hlsDefaultConfig shallow\n// It is cloned whenever a new Hls instance is created, by keeping the config\n// shallow the properties are cloned, and we don't end up manipulating the default\nvar hlsDefaultConfig = _objectSpread(_objectSpread({\n  autoStartLoad: true,\n  // used by stream-controller\n  startPosition: -1,\n  // used by stream-controller\n  defaultAudioCodec: undefined,\n  // used by stream-controller\n  debug: false,\n  // used by logger\n  capLevelOnFPSDrop: false,\n  // used by fps-controller\n  capLevelToPlayerSize: false,\n  // used by cap-level-controller\n  initialLiveManifestSize: 1,\n  // used by stream-controller\n  maxBufferLength: 30,\n  // used by stream-controller\n  backBufferLength: Infinity,\n  // used by buffer-controller\n  maxBufferSize: 60 * 1000 * 1000,\n  // used by stream-controller\n  maxBufferHole: 0.1,\n  // used by stream-controller\n  highBufferWatchdogPeriod: 2,\n  // used by stream-controller\n  nudgeOffset: 0.1,\n  // used by stream-controller\n  nudgeMaxRetry: 3,\n  // used by stream-controller\n  maxFragLookUpTolerance: 0.25,\n  // used by stream-controller\n  liveSyncDurationCount: 3,\n  // used by latency-controller\n  liveMaxLatencyDurationCount: Infinity,\n  // used by latency-controller\n  liveSyncDuration: undefined,\n  // used by latency-controller\n  liveMaxLatencyDuration: undefined,\n  // used by latency-controller\n  maxLiveSyncPlaybackRate: 1,\n  // used by latency-controller\n  liveDurationInfinity: false,\n  // used by buffer-controller\n  liveBackBufferLength: null,\n  // used by buffer-controller\n  maxMaxBufferLength: 600,\n  // used by stream-controller\n  enableWorker: true,\n  // used by demuxer\n  enableSoftwareAES: true,\n  // used by decrypter\n  manifestLoadingTimeOut: 10000,\n  // used by playlist-loader\n  manifestLoadingMaxRetry: 1,\n  // used by playlist-loader\n  manifestLoadingRetryDelay: 1000,\n  // used by playlist-loader\n  manifestLoadingMaxRetryTimeout: 64000,\n  // used by playlist-loader\n  startLevel: undefined,\n  // used by level-controller\n  levelLoadingTimeOut: 10000,\n  // used by playlist-loader\n  levelLoadingMaxRetry: 4,\n  // used by playlist-loader\n  levelLoadingRetryDelay: 1000,\n  // used by playlist-loader\n  levelLoadingMaxRetryTimeout: 64000,\n  // used by playlist-loader\n  fragLoadingTimeOut: 20000,\n  // used by fragment-loader\n  fragLoadingMaxRetry: 6,\n  // used by fragment-loader\n  fragLoadingRetryDelay: 1000,\n  // used by fragment-loader\n  fragLoadingMaxRetryTimeout: 64000,\n  // used by fragment-loader\n  startFragPrefetch: false,\n  // used by stream-controller\n  fpsDroppedMonitoringPeriod: 5000,\n  // used by fps-controller\n  fpsDroppedMonitoringThreshold: 0.2,\n  // used by fps-controller\n  appendErrorMaxRetry: 3,\n  // used by buffer-controller\n  loader: _utils_xhr_loader__WEBPACK_IMPORTED_MODULE_11__[\"default\"],\n  // loader: FetchLoader,\n  fLoader: undefined,\n  // used by fragment-loader\n  pLoader: undefined,\n  // used by playlist-loader\n  xhrSetup: undefined,\n  // used by xhr-loader\n  licenseXhrSetup: undefined,\n  // used by eme-controller\n  licenseResponseCallback: undefined,\n  // used by eme-controller\n  abrController: _controller_abr_controller__WEBPACK_IMPORTED_MODULE_0__[\"default\"],\n  bufferController: _controller_buffer_controller__WEBPACK_IMPORTED_MODULE_5__[\"default\"],\n  capLevelController: _controller_cap_level_controller__WEBPACK_IMPORTED_MODULE_7__[\"default\"],\n  fpsController: _controller_fps_controller__WEBPACK_IMPORTED_MODULE_8__[\"default\"],\n  stretchShortVideoTrack: false,\n  // used by mp4-remuxer\n  maxAudioFramesDrift: 1,\n  // used by mp4-remuxer\n  forceKeyFrameOnDiscontinuity: true,\n  // used by ts-demuxer\n  abrEwmaFastLive: 3,\n  // used by abr-controller\n  abrEwmaSlowLive: 9,\n  // used by abr-controller\n  abrEwmaFastVoD: 3,\n  // used by abr-controller\n  abrEwmaSlowVoD: 9,\n  // used by abr-controller\n  abrEwmaDefaultEstimate: 5e5,\n  // 500 kbps  // used by abr-controller\n  abrBandWidthFactor: 0.95,\n  // used by abr-controller\n  abrBandWidthUpFactor: 0.7,\n  // used by abr-controller\n  abrMaxWithRealBitrate: false,\n  // used by abr-controller\n  maxStarvationDelay: 4,\n  // used by abr-controller\n  maxLoadingDelay: 4,\n  // used by abr-controller\n  minAutoBitrate: 0,\n  // used by hls\n  emeEnabled: false,\n  // used by eme-controller\n  widevineLicenseUrl: undefined,\n  // used by eme-controller\n  drmSystemOptions: {},\n  // used by eme-controller\n  requestMediaKeySystemAccessFunc: _utils_mediakeys_helper__WEBPACK_IMPORTED_MODULE_14__[\"requestMediaKeySystemAccess\"],\n  // used by eme-controller\n  testBandwidth: true,\n  progressive: false,\n  lowLatencyMode: true,\n  cmcd: undefined\n}, timelineConfig()), {}, {\n  subtitleStreamController:   true ? _controller_subtitle_stream_controller__WEBPACK_IMPORTED_MODULE_3__[\"SubtitleStreamController\"] : 0,\n  subtitleTrackController:   true ? _controller_subtitle_track_controller__WEBPACK_IMPORTED_MODULE_4__[\"default\"] : 0,\n  timelineController:   true ? _controller_timeline_controller__WEBPACK_IMPORTED_MODULE_6__[\"TimelineController\"] : 0,\n  audioStreamController:   true ? _controller_audio_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"default\"] : 0,\n  audioTrackController:   true ? _controller_audio_track_controller__WEBPACK_IMPORTED_MODULE_2__[\"default\"] : 0,\n  emeController:   true ? _controller_eme_controller__WEBPACK_IMPORTED_MODULE_9__[\"default\"] : 0,\n  cmcdController:   true ? _controller_cmcd_controller__WEBPACK_IMPORTED_MODULE_10__[\"default\"] : 0\n});\n\nfunction timelineConfig() {\n  return {\n    cueHandler: _utils_cues__WEBPACK_IMPORTED_MODULE_13__[\"default\"],\n    // used by timeline-controller\n    enableCEA708Captions: true,\n    // used by timeline-controller\n    enableWebVTT: true,\n    // used by timeline-controller\n    enableIMSC1: true,\n    // used by timeline-controller\n    captionsTextTrack1Label: 'English',\n    // used by timeline-controller\n    captionsTextTrack1LanguageCode: 'en',\n    // used by timeline-controller\n    captionsTextTrack2Label: 'Spanish',\n    // used by timeline-controller\n    captionsTextTrack2LanguageCode: 'es',\n    // used by timeline-controller\n    captionsTextTrack3Label: 'Unknown CC',\n    // used by timeline-controller\n    captionsTextTrack3LanguageCode: '',\n    // used by timeline-controller\n    captionsTextTrack4Label: 'Unknown CC',\n    // used by timeline-controller\n    captionsTextTrack4LanguageCode: '',\n    // used by timeline-controller\n    renderTextTracksNatively: true\n  };\n}\n\nfunction mergeConfig(defaultConfig, userConfig) {\n  if ((userConfig.liveSyncDurationCount || userConfig.liveMaxLatencyDurationCount) && (userConfig.liveSyncDuration || userConfig.liveMaxLatencyDuration)) {\n    throw new Error(\"Illegal hls.js config: don't mix up liveSyncDurationCount/liveMaxLatencyDurationCount and liveSyncDuration/liveMaxLatencyDuration\");\n  }\n\n  if (userConfig.liveMaxLatencyDurationCount !== undefined && (userConfig.liveSyncDurationCount === undefined || userConfig.liveMaxLatencyDurationCount <= userConfig.liveSyncDurationCount)) {\n    throw new Error('Illegal hls.js config: \"liveMaxLatencyDurationCount\" must be greater than \"liveSyncDurationCount\"');\n  }\n\n  if (userConfig.liveMaxLatencyDuration !== undefined && (userConfig.liveSyncDuration === undefined || userConfig.liveMaxLatencyDuration <= userConfig.liveSyncDuration)) {\n    throw new Error('Illegal hls.js config: \"liveMaxLatencyDuration\" must be greater than \"liveSyncDuration\"');\n  }\n\n  return _extends({}, defaultConfig, userConfig);\n}\nfunction enableStreamingMode(config) {\n  var currentLoader = config.loader;\n\n  if (currentLoader !== _utils_fetch_loader__WEBPACK_IMPORTED_MODULE_12__[\"default\"] && currentLoader !== _utils_xhr_loader__WEBPACK_IMPORTED_MODULE_11__[\"default\"]) {\n    // If a developer has configured their own loader, respect that choice\n    _utils_logger__WEBPACK_IMPORTED_MODULE_15__[\"logger\"].log('[config]: Custom loader detected, cannot enable progressive streaming');\n    config.progressive = false;\n  } else {\n    var canStreamProgressively = Object(_utils_fetch_loader__WEBPACK_IMPORTED_MODULE_12__[\"fetchSupported\"])();\n\n    if (canStreamProgressively) {\n      config.loader = _utils_fetch_loader__WEBPACK_IMPORTED_MODULE_12__[\"default\"];\n      config.progressive = true;\n      config.enableSoftwareAES = true;\n      _utils_logger__WEBPACK_IMPORTED_MODULE_15__[\"logger\"].log('[config]: Progressive streaming enabled, using FetchLoader');\n    }\n  }\n}\n\n/***/ }),\n\n/***/ \"./src/controller/abr-controller.ts\":\n/*!******************************************!*\\\n  !*** ./src/controller/abr-controller.ts ***!\n  \\******************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_42079__) {\n\n\"use strict\";\n__nested_webpack_require_42079__.r(__webpack_exports__);\n/* harmony import */ var _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_42079__(/*! ./src/polyfills/number */ \"./src/polyfills/number.ts\");\n/* harmony import */ var _utils_ewma_bandwidth_estimator__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_42079__(/*! ../utils/ewma-bandwidth-estimator */ \"./src/utils/ewma-bandwidth-estimator.ts\");\n/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_42079__(/*! ../events */ \"./src/events.ts\");\n/* harmony import */ var _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_42079__(/*! ../utils/buffer-helper */ \"./src/utils/buffer-helper.ts\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_42079__(/*! ../errors */ \"./src/errors.ts\");\n/* harmony import */ var _types_loader__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_42079__(/*! ../types/loader */ \"./src/types/loader.ts\");\n/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_42079__(/*! ../utils/logger */ \"./src/utils/logger.ts\");\n\n\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\n\n\n\n\n\nvar AbrController = /*#__PURE__*/function () {\n  function AbrController(hls) {\n    this.hls = void 0;\n    this.lastLoadedFragLevel = 0;\n    this._nextAutoLevel = -1;\n    this.timer = void 0;\n    this.onCheck = this._abandonRulesCheck.bind(this);\n    this.fragCurrent = null;\n    this.partCurrent = null;\n    this.bitrateTestDelay = 0;\n    this.bwEstimator = void 0;\n    this.hls = hls;\n    var config = hls.config;\n    this.bwEstimator = new _utils_ewma_bandwidth_estimator__WEBPACK_IMPORTED_MODULE_1__[\"default\"](config.abrEwmaSlowVoD, config.abrEwmaFastVoD, config.abrEwmaDefaultEstimate);\n    this.registerListeners();\n  }\n\n  var _proto = AbrController.prototype;\n\n  _proto.registerListeners = function registerListeners() {\n    var hls = this.hls;\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_2__[\"Events\"].FRAG_LOADING, this.onFragLoading, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_2__[\"Events\"].FRAG_LOADED, this.onFragLoaded, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_2__[\"Events\"].FRAG_BUFFERED, this.onFragBuffered, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_2__[\"Events\"].LEVEL_LOADED, this.onLevelLoaded, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_2__[\"Events\"].ERROR, this.onError, this);\n  };\n\n  _proto.unregisterListeners = function unregisterListeners() {\n    var hls = this.hls;\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_2__[\"Events\"].FRAG_LOADING, this.onFragLoading, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_2__[\"Events\"].FRAG_LOADED, this.onFragLoaded, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_2__[\"Events\"].FRAG_BUFFERED, this.onFragBuffered, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_2__[\"Events\"].LEVEL_LOADED, this.onLevelLoaded, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_2__[\"Events\"].ERROR, this.onError, this);\n  };\n\n  _proto.destroy = function destroy() {\n    this.unregisterListeners();\n    this.clearTimer(); // @ts-ignore\n\n    this.hls = this.onCheck = null;\n    this.fragCurrent = this.partCurrent = null;\n  };\n\n  _proto.onFragLoading = function onFragLoading(event, data) {\n    var frag = data.frag;\n\n    if (frag.type === _types_loader__WEBPACK_IMPORTED_MODULE_5__[\"PlaylistLevelType\"].MAIN) {\n      if (!this.timer) {\n        var _data$part;\n\n        this.fragCurrent = frag;\n        this.partCurrent = (_data$part = data.part) != null ? _data$part : null;\n        this.timer = self.setInterval(this.onCheck, 100);\n      }\n    }\n  };\n\n  _proto.onLevelLoaded = function onLevelLoaded(event, data) {\n    var config = this.hls.config;\n\n    if (data.details.live) {\n      this.bwEstimator.update(config.abrEwmaSlowLive, config.abrEwmaFastLive);\n    } else {\n      this.bwEstimator.update(config.abrEwmaSlowVoD, config.abrEwmaFastVoD);\n    }\n  }\n  /*\n      This method monitors the download rate of the current fragment, and will downswitch if that fragment will not load\n      quickly enough to prevent underbuffering\n    */\n  ;\n\n  _proto._abandonRulesCheck = function _abandonRulesCheck() {\n    var frag = this.fragCurrent,\n        part = this.partCurrent,\n        hls = this.hls;\n    var autoLevelEnabled = hls.autoLevelEnabled,\n        config = hls.config,\n        media = hls.media;\n\n    if (!frag || !media) {\n      return;\n    }\n\n    var stats = part ? part.stats : frag.stats;\n    var duration = part ? part.duration : frag.duration; // If loading has been aborted and not in lowLatencyMode, stop timer and return\n\n    if (stats.aborted) {\n      _utils_logger__WEBPACK_IMPORTED_MODULE_6__[\"logger\"].warn('frag loader destroy or aborted, disarm abandonRules');\n      this.clearTimer(); // reset forced auto level value so that next level will be selected\n\n      this._nextAutoLevel = -1;\n      return;\n    } // This check only runs if we're in ABR mode and actually playing\n\n\n    if (!autoLevelEnabled || media.paused || !media.playbackRate || !media.readyState) {\n      return;\n    }\n\n    var requestDelay = performance.now() - stats.loading.start;\n    var playbackRate = Math.abs(media.playbackRate); // In order to work with a stable bandwidth, only begin monitoring bandwidth after half of the fragment has been loaded\n\n    if (requestDelay <= 500 * duration / playbackRate) {\n      return;\n    }\n\n    var levels = hls.levels,\n        minAutoLevel = hls.minAutoLevel;\n    var level = levels[frag.level];\n    var expectedLen = stats.total || Math.max(stats.loaded, Math.round(duration * level.maxBitrate / 8));\n    var loadRate = Math.max(1, stats.bwEstimate ? stats.bwEstimate / 8 : stats.loaded * 1000 / requestDelay); // fragLoadDelay is an estimate of the time (in seconds) it will take to buffer the entire fragment\n\n    var fragLoadedDelay = (expectedLen - stats.loaded) / loadRate;\n    var pos = media.currentTime; // bufferStarvationDelay is an estimate of the amount time (in seconds) it will take to exhaust the buffer\n\n    var bufferStarvationDelay = (_utils_buffer_helper__WEBPACK_IMPORTED_MODULE_3__[\"BufferHelper\"].bufferInfo(media, pos, config.maxBufferHole).end - pos) / playbackRate; // Attempt an emergency downswitch only if less than 2 fragment lengths are buffered, and the time to finish loading\n    // the current fragment is greater than the amount of buffer we have left\n\n    if (bufferStarvationDelay >= 2 * duration / playbackRate || fragLoadedDelay <= bufferStarvationDelay) {\n      return;\n    }\n\n    var fragLevelNextLoadedDelay = Number.POSITIVE_INFINITY;\n    var nextLoadLevel; // Iterate through lower level and try to find the largest one that avoids rebuffering\n\n    for (nextLoadLevel = frag.level - 1; nextLoadLevel > minAutoLevel; nextLoadLevel--) {\n      // compute time to load next fragment at lower level\n      // 0.8 : consider only 80% of current bw to be conservative\n      // 8 = bits per byte (bps/Bps)\n      var levelNextBitrate = levels[nextLoadLevel].maxBitrate;\n      fragLevelNextLoadedDelay = duration * levelNextBitrate / (8 * 0.8 * loadRate);\n\n      if (fragLevelNextLoadedDelay < bufferStarvationDelay) {\n        break;\n      }\n    } // Only emergency switch down if it takes less time to load a new fragment at lowest level instead of continuing\n    // to load the current one\n\n\n    if (fragLevelNextLoadedDelay >= fragLoadedDelay) {\n      return;\n    }\n\n    var bwEstimate = this.bwEstimator.getEstimate();\n    _utils_logger__WEBPACK_IMPORTED_MODULE_6__[\"logger\"].warn(\"Fragment \" + frag.sn + (part ? ' part ' + part.index : '') + \" of level \" + frag.level + \" is loading too slowly and will cause an underbuffer; aborting and switching to level \" + nextLoadLevel + \"\\n      Current BW estimate: \" + (Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__[\"isFiniteNumber\"])(bwEstimate) ? (bwEstimate / 1024).toFixed(3) : 'Unknown') + \" Kb/s\\n      Estimated load time for current fragment: \" + fragLoadedDelay.toFixed(3) + \" s\\n      Estimated load time for the next fragment: \" + fragLevelNextLoadedDelay.toFixed(3) + \" s\\n      Time to underbuffer: \" + bufferStarvationDelay.toFixed(3) + \" s\");\n    hls.nextLoadLevel = nextLoadLevel;\n    this.bwEstimator.sample(requestDelay, stats.loaded);\n    this.clearTimer();\n\n    if (frag.loader) {\n      this.fragCurrent = this.partCurrent = null;\n      frag.loader.abort();\n    }\n\n    hls.trigger(_events__WEBPACK_IMPORTED_MODULE_2__[\"Events\"].FRAG_LOAD_EMERGENCY_ABORTED, {\n      frag: frag,\n      part: part,\n      stats: stats\n    });\n  };\n\n  _proto.onFragLoaded = function onFragLoaded(event, _ref) {\n    var frag = _ref.frag,\n        part = _ref.part;\n\n    if (frag.type === _types_loader__WEBPACK_IMPORTED_MODULE_5__[\"PlaylistLevelType\"].MAIN && Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__[\"isFiniteNumber\"])(frag.sn)) {\n      var stats = part ? part.stats : frag.stats;\n      var duration = part ? part.duration : frag.duration; // stop monitoring bw once frag loaded\n\n      this.clearTimer(); // store level id after successful fragment load\n\n      this.lastLoadedFragLevel = frag.level; // reset forced auto level value so that next level will be selected\n\n      this._nextAutoLevel = -1; // compute level average bitrate\n\n      if (this.hls.config.abrMaxWithRealBitrate) {\n        var level = this.hls.levels[frag.level];\n        var loadedBytes = (level.loaded ? level.loaded.bytes : 0) + stats.loaded;\n        var loadedDuration = (level.loaded ? level.loaded.duration : 0) + duration;\n        level.loaded = {\n          bytes: loadedBytes,\n          duration: loadedDuration\n        };\n        level.realBitrate = Math.round(8 * loadedBytes / loadedDuration);\n      }\n\n      if (frag.bitrateTest) {\n        var fragBufferedData = {\n          stats: stats,\n          frag: frag,\n          part: part,\n          id: frag.type\n        };\n        this.onFragBuffered(_events__WEBPACK_IMPORTED_MODULE_2__[\"Events\"].FRAG_BUFFERED, fragBufferedData);\n        frag.bitrateTest = false;\n      }\n    }\n  };\n\n  _proto.onFragBuffered = function onFragBuffered(event, data) {\n    var frag = data.frag,\n        part = data.part;\n    var stats = part ? part.stats : frag.stats;\n\n    if (stats.aborted) {\n      return;\n    } // Only count non-alt-audio frags which were actually buffered in our BW calculations\n\n\n    if (frag.type !== _types_loader__WEBPACK_IMPORTED_MODULE_5__[\"PlaylistLevelType\"].MAIN || frag.sn === 'initSegment') {\n      return;\n    } // Use the difference between parsing and request instead of buffering and request to compute fragLoadingProcessing;\n    // rationale is that buffer appending only happens once media is attached. This can happen when config.startFragPrefetch\n    // is used. If we used buffering in that case, our BW estimate sample will be very large.\n\n\n    var processingMs = stats.parsing.end - stats.loading.start;\n    this.bwEstimator.sample(processingMs, stats.loaded);\n    stats.bwEstimate = this.bwEstimator.getEstimate();\n\n    if (frag.bitrateTest) {\n      this.bitrateTestDelay = processingMs / 1000;\n    } else {\n      this.bitrateTestDelay = 0;\n    }\n  };\n\n  _proto.onError = function onError(event, data) {\n    // stop timer in case of frag loading error\n    switch (data.details) {\n      case _errors__WEBPACK_IMPORTED_MODULE_4__[\"ErrorDetails\"].FRAG_LOAD_ERROR:\n      case _errors__WEBPACK_IMPORTED_MODULE_4__[\"ErrorDetails\"].FRAG_LOAD_TIMEOUT:\n        this.clearTimer();\n        break;\n\n      default:\n        break;\n    }\n  };\n\n  _proto.clearTimer = function clearTimer() {\n    self.clearInterval(this.timer);\n    this.timer = undefined;\n  } // return next auto level\n  ;\n\n  _proto.getNextABRAutoLevel = function getNextABRAutoLevel() {\n    var fragCurrent = this.fragCurrent,\n        partCurrent = this.partCurrent,\n        hls = this.hls;\n    var maxAutoLevel = hls.maxAutoLevel,\n        config = hls.config,\n        minAutoLevel = hls.minAutoLevel,\n        media = hls.media;\n    var currentFragDuration = partCurrent ? partCurrent.duration : fragCurrent ? fragCurrent.duration : 0;\n    var pos = media ? media.currentTime : 0; // playbackRate is the absolute value of the playback rate; if media.playbackRate is 0, we use 1 to load as\n    // if we're playing back at the normal rate.\n\n    var playbackRate = media && media.playbackRate !== 0 ? Math.abs(media.playbackRate) : 1.0;\n    var avgbw = this.bwEstimator ? this.bwEstimator.getEstimate() : config.abrEwmaDefaultEstimate; // bufferStarvationDelay is the wall-clock time left until the playback buffer is exhausted.\n\n    var bufferStarvationDelay = (_utils_buffer_helper__WEBPACK_IMPORTED_MODULE_3__[\"BufferHelper\"].bufferInfo(media, pos, config.maxBufferHole).end - pos) / playbackRate; // First, look to see if we can find a level matching with our avg bandwidth AND that could also guarantee no rebuffering at all\n\n    var bestLevel = this.findBestLevel(avgbw, minAutoLevel, maxAutoLevel, bufferStarvationDelay, config.abrBandWidthFactor, config.abrBandWidthUpFactor);\n\n    if (bestLevel >= 0) {\n      return bestLevel;\n    }\n\n    _utils_logger__WEBPACK_IMPORTED_MODULE_6__[\"logger\"].trace((bufferStarvationDelay ? 'rebuffering expected' : 'buffer is empty') + \", finding optimal quality level\"); // not possible to get rid of rebuffering ... let's try to find level that will guarantee less than maxStarvationDelay of rebuffering\n    // if no matching level found, logic will return 0\n\n    var maxStarvationDelay = currentFragDuration ? Math.min(currentFragDuration, config.maxStarvationDelay) : config.maxStarvationDelay;\n    var bwFactor = config.abrBandWidthFactor;\n    var bwUpFactor = config.abrBandWidthUpFactor;\n\n    if (!bufferStarvationDelay) {\n      // in case buffer is empty, let's check if previous fragment was loaded to perform a bitrate test\n      var bitrateTestDelay = this.bitrateTestDelay;\n\n      if (bitrateTestDelay) {\n        // if it is the case, then we need to adjust our max starvation delay using maxLoadingDelay config value\n        // max video loading delay used in  automatic start level selection :\n        // in that mode ABR controller will ensure that video loading time (ie the time to fetch the first fragment at lowest quality level +\n        // the time to fetch the fragment at the appropriate quality level is less than ```maxLoadingDelay``` )\n        // cap maxLoadingDelay and ensure it is not bigger 'than bitrate test' frag duration\n        var maxLoadingDelay = currentFragDuration ? Math.min(currentFragDuration, config.maxLoadingDelay) : config.maxLoadingDelay;\n        maxStarvationDelay = maxLoadingDelay - bitrateTestDelay;\n        _utils_logger__WEBPACK_IMPORTED_MODULE_6__[\"logger\"].trace(\"bitrate test took \" + Math.round(1000 * bitrateTestDelay) + \"ms, set first fragment max fetchDuration to \" + Math.round(1000 * maxStarvationDelay) + \" ms\"); // don't use conservative factor on bitrate test\n\n        bwFactor = bwUpFactor = 1;\n      }\n    }\n\n    bestLevel = this.findBestLevel(avgbw, minAutoLevel, maxAutoLevel, bufferStarvationDelay + maxStarvationDelay, bwFactor, bwUpFactor);\n    return Math.max(bestLevel, 0);\n  };\n\n  _proto.findBestLevel = function findBestLevel(currentBw, minAutoLevel, maxAutoLevel, maxFetchDuration, bwFactor, bwUpFactor) {\n    var _level$details;\n\n    var fragCurrent = this.fragCurrent,\n        partCurrent = this.partCurrent,\n        currentLevel = this.lastLoadedFragLevel;\n    var levels = this.hls.levels;\n    var level = levels[currentLevel];\n    var live = !!(level !== null && level !== void 0 && (_level$details = level.details) !== null && _level$details !== void 0 && _level$details.live);\n    var currentCodecSet = level === null || level === void 0 ? void 0 : level.codecSet;\n    var currentFragDuration = partCurrent ? partCurrent.duration : fragCurrent ? fragCurrent.duration : 0;\n\n    for (var i = maxAutoLevel; i >= minAutoLevel; i--) {\n      var levelInfo = levels[i];\n\n      if (!levelInfo || currentCodecSet && levelInfo.codecSet !== currentCodecSet) {\n        continue;\n      }\n\n      var levelDetails = levelInfo.details;\n      var avgDuration = (partCurrent ? levelDetails === null || levelDetails === void 0 ? void 0 : levelDetails.partTarget : levelDetails === null || levelDetails === void 0 ? void 0 : levelDetails.averagetargetduration) || currentFragDuration;\n      var adjustedbw = void 0; // follow algorithm captured from stagefright :\n      // https://android.googlesource.com/platform/frameworks/av/+/master/media/libstagefright/httplive/LiveSession.cpp\n      // Pick the highest bandwidth stream below or equal to estimated bandwidth.\n      // consider only 80% of the available bandwidth, but if we are switching up,\n      // be even more conservative (70%) to avoid overestimating and immediately\n      // switching back.\n\n      if (i <= currentLevel) {\n        adjustedbw = bwFactor * currentBw;\n      } else {\n        adjustedbw = bwUpFactor * currentBw;\n      }\n\n      var bitrate = levels[i].maxBitrate;\n      var fetchDuration = bitrate * avgDuration / adjustedbw;\n      _utils_logger__WEBPACK_IMPORTED_MODULE_6__[\"logger\"].trace(\"level/adjustedbw/bitrate/avgDuration/maxFetchDuration/fetchDuration: \" + i + \"/\" + Math.round(adjustedbw) + \"/\" + bitrate + \"/\" + avgDuration + \"/\" + maxFetchDuration + \"/\" + fetchDuration); // if adjusted bw is greater than level bitrate AND\n\n      if (adjustedbw > bitrate && ( // fragment fetchDuration unknown OR live stream OR fragment fetchDuration less than max allowed fetch duration, then this level matches\n      // we don't account for max Fetch Duration for live streams, this is to avoid switching down when near the edge of live sliding window ...\n      // special case to support startLevel = -1 (bitrateTest) on live streams : in that case we should not exit loop so that findBestLevel will return -1\n      !fetchDuration || live && !this.bitrateTestDelay || fetchDuration < maxFetchDuration)) {\n        // as we are looping from highest to lowest, this will return the best achievable quality level\n        return i;\n      }\n    } // not enough time budget even with quality level 0 ... rebuffering might happen\n\n\n    return -1;\n  };\n\n  _createClass(AbrController, [{\n    key: \"nextAutoLevel\",\n    get: function get() {\n      var forcedAutoLevel = this._nextAutoLevel;\n      var bwEstimator = this.bwEstimator; // in case next auto level has been forced, and bw not available or not reliable, return forced value\n\n      if (forcedAutoLevel !== -1 && (!bwEstimator || !bwEstimator.canEstimate())) {\n        return forcedAutoLevel;\n      } // compute next level using ABR logic\n\n\n      var nextABRAutoLevel = this.getNextABRAutoLevel(); // if forced auto level has been defined, use it to cap ABR computed quality level\n\n      if (forcedAutoLevel !== -1) {\n        nextABRAutoLevel = Math.min(forcedAutoLevel, nextABRAutoLevel);\n      }\n\n      return nextABRAutoLevel;\n    },\n    set: function set(nextLevel) {\n      this._nextAutoLevel = nextLevel;\n    }\n  }]);\n\n  return AbrController;\n}();\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (AbrController);\n\n/***/ }),\n\n/***/ \"./src/controller/audio-stream-controller.ts\":\n/*!***************************************************!*\\\n  !*** ./src/controller/audio-stream-controller.ts ***!\n  \\***************************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_62043__) {\n\n\"use strict\";\n__nested_webpack_require_62043__.r(__webpack_exports__);\n/* harmony import */ var _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_62043__(/*! ./src/polyfills/number */ \"./src/polyfills/number.ts\");\n/* harmony import */ var _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_62043__(/*! ./base-stream-controller */ \"./src/controller/base-stream-controller.ts\");\n/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_62043__(/*! ../events */ \"./src/events.ts\");\n/* harmony import */ var _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_62043__(/*! ../utils/buffer-helper */ \"./src/utils/buffer-helper.ts\");\n/* harmony import */ var _fragment_tracker__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_62043__(/*! ./fragment-tracker */ \"./src/controller/fragment-tracker.ts\");\n/* harmony import */ var _types_level__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_62043__(/*! ../types/level */ \"./src/types/level.ts\");\n/* harmony import */ var _types_loader__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_62043__(/*! ../types/loader */ \"./src/types/loader.ts\");\n/* harmony import */ var _loader_fragment__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_62043__(/*! ../loader/fragment */ \"./src/loader/fragment.ts\");\n/* harmony import */ var _demux_chunk_cache__WEBPACK_IMPORTED_MODULE_8__ = __nested_webpack_require_62043__(/*! ../demux/chunk-cache */ \"./src/demux/chunk-cache.ts\");\n/* harmony import */ var _demux_transmuxer_interface__WEBPACK_IMPORTED_MODULE_9__ = __nested_webpack_require_62043__(/*! ../demux/transmuxer-interface */ \"./src/demux/transmuxer-interface.ts\");\n/* harmony import */ var _types_transmuxer__WEBPACK_IMPORTED_MODULE_10__ = __nested_webpack_require_62043__(/*! ../types/transmuxer */ \"./src/types/transmuxer.ts\");\n/* harmony import */ var _fragment_finders__WEBPACK_IMPORTED_MODULE_11__ = __nested_webpack_require_62043__(/*! ./fragment-finders */ \"./src/controller/fragment-finders.ts\");\n/* harmony import */ var _utils_discontinuities__WEBPACK_IMPORTED_MODULE_12__ = __nested_webpack_require_62043__(/*! ../utils/discontinuities */ \"./src/utils/discontinuities.ts\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_13__ = __nested_webpack_require_62043__(/*! ../errors */ \"./src/errors.ts\");\n/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_14__ = __nested_webpack_require_62043__(/*! ../utils/logger */ \"./src/utils/logger.ts\");\n\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar TICK_INTERVAL = 100; // how often to tick in ms\n\nvar AudioStreamController = /*#__PURE__*/function (_BaseStreamController) {\n  _inheritsLoose(AudioStreamController, _BaseStreamController);\n\n  function AudioStreamController(hls, fragmentTracker) {\n    var _this;\n\n    _this = _BaseStreamController.call(this, hls, fragmentTracker, '[audio-stream-controller]') || this;\n    _this.videoBuffer = null;\n    _this.videoTrackCC = -1;\n    _this.waitingVideoCC = -1;\n    _this.audioSwitch = false;\n    _this.trackId = -1;\n    _this.waitingData = null;\n    _this.mainDetails = null;\n    _this.bufferFlushed = false;\n\n    _this._registerListeners();\n\n    return _this;\n  }\n\n  var _proto = AudioStreamController.prototype;\n\n  _proto.onHandlerDestroying = function onHandlerDestroying() {\n    this._unregisterListeners();\n\n    this.mainDetails = null;\n  };\n\n  _proto._registerListeners = function _registerListeners() {\n    var hls = this.hls;\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_2__[\"Events\"].MEDIA_ATTACHED, this.onMediaAttached, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_2__[\"Events\"].MEDIA_DETACHING, this.onMediaDetaching, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_2__[\"Events\"].MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_2__[\"Events\"].LEVEL_LOADED, this.onLevelLoaded, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_2__[\"Events\"].AUDIO_TRACKS_UPDATED, this.onAudioTracksUpdated, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_2__[\"Events\"].AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_2__[\"Events\"].AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_2__[\"Events\"].ERROR, this.onError, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_2__[\"Events\"].BUFFER_RESET, this.onBufferReset, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_2__[\"Events\"].BUFFER_CREATED, this.onBufferCreated, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_2__[\"Events\"].BUFFER_FLUSHED, this.onBufferFlushed, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_2__[\"Events\"].INIT_PTS_FOUND, this.onInitPtsFound, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_2__[\"Events\"].FRAG_BUFFERED, this.onFragBuffered, this);\n  };\n\n  _proto._unregisterListeners = function _unregisterListeners() {\n    var hls = this.hls;\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_2__[\"Events\"].MEDIA_ATTACHED, this.onMediaAttached, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_2__[\"Events\"].MEDIA_DETACHING, this.onMediaDetaching, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_2__[\"Events\"].MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_2__[\"Events\"].LEVEL_LOADED, this.onLevelLoaded, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_2__[\"Events\"].AUDIO_TRACKS_UPDATED, this.onAudioTracksUpdated, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_2__[\"Events\"].AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_2__[\"Events\"].AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_2__[\"Events\"].ERROR, this.onError, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_2__[\"Events\"].BUFFER_RESET, this.onBufferReset, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_2__[\"Events\"].BUFFER_CREATED, this.onBufferCreated, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_2__[\"Events\"].BUFFER_FLUSHED, this.onBufferFlushed, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_2__[\"Events\"].INIT_PTS_FOUND, this.onInitPtsFound, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_2__[\"Events\"].FRAG_BUFFERED, this.onFragBuffered, this);\n  } // INIT_PTS_FOUND is triggered when the video track parsed in the stream-controller has a new PTS value\n  ;\n\n  _proto.onInitPtsFound = function onInitPtsFound(event, _ref) {\n    var frag = _ref.frag,\n        id = _ref.id,\n        initPTS = _ref.initPTS;\n\n    // Always update the new INIT PTS\n    // Can change due level switch\n    if (id === 'main') {\n      var cc = frag.cc;\n      this.initPTS[frag.cc] = initPTS;\n      this.log(\"InitPTS for cc: \" + cc + \" found from main: \" + initPTS);\n      this.videoTrackCC = cc; // If we are waiting, tick immediately to unblock audio fragment transmuxing\n\n      if (this.state === _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"State\"].WAITING_INIT_PTS) {\n        this.tick();\n      }\n    }\n  };\n\n  _proto.startLoad = function startLoad(startPosition) {\n    if (!this.levels) {\n      this.startPosition = startPosition;\n      this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"State\"].STOPPED;\n      return;\n    }\n\n    var lastCurrentTime = this.lastCurrentTime;\n    this.stopLoad();\n    this.setInterval(TICK_INTERVAL);\n    this.fragLoadError = 0;\n\n    if (lastCurrentTime > 0 && startPosition === -1) {\n      this.log(\"Override startPosition with lastCurrentTime @\" + lastCurrentTime.toFixed(3));\n      this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"State\"].IDLE;\n    } else {\n      this.loadedmetadata = false;\n      this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"State\"].WAITING_TRACK;\n    }\n\n    this.nextLoadPosition = this.startPosition = this.lastCurrentTime = startPosition;\n    this.tick();\n  };\n\n  _proto.doTick = function doTick() {\n    switch (this.state) {\n      case _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"State\"].IDLE:\n        this.doTickIdle();\n        break;\n\n      case _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"State\"].WAITING_TRACK:\n        {\n          var _levels$trackId;\n\n          var levels = this.levels,\n              trackId = this.trackId;\n          var details = levels === null || levels === void 0 ? void 0 : (_levels$trackId = levels[trackId]) === null || _levels$trackId === void 0 ? void 0 : _levels$trackId.details;\n\n          if (details) {\n            if (this.waitForCdnTuneIn(details)) {\n              break;\n            }\n\n            this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"State\"].WAITING_INIT_PTS;\n          }\n\n          break;\n        }\n\n      case _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"State\"].FRAG_LOADING_WAITING_RETRY:\n        {\n          var _this$media;\n\n          var now = performance.now();\n          var retryDate = this.retryDate; // if current time is gt than retryDate, or if media seeking let's switch to IDLE state to retry loading\n\n          if (!retryDate || now >= retryDate || (_this$media = this.media) !== null && _this$media !== void 0 && _this$media.seeking) {\n            this.log('RetryDate reached, switch back to IDLE state');\n            this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"State\"].IDLE;\n          }\n\n          break;\n        }\n\n      case _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"State\"].WAITING_INIT_PTS:\n        {\n          // Ensure we don't get stuck in the WAITING_INIT_PTS state if the waiting frag CC doesn't match any initPTS\n          var waitingData = this.waitingData;\n\n          if (waitingData) {\n            var frag = waitingData.frag,\n                part = waitingData.part,\n                cache = waitingData.cache,\n                complete = waitingData.complete;\n\n            if (this.initPTS[frag.cc] !== undefined) {\n              this.waitingData = null;\n              this.waitingVideoCC = -1;\n              this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"State\"].FRAG_LOADING;\n              var payload = cache.flush();\n              var data = {\n                frag: frag,\n                part: part,\n                payload: payload,\n                networkDetails: null\n              };\n\n              this._handleFragmentLoadProgress(data);\n\n              if (complete) {\n                _BaseStreamController.prototype._handleFragmentLoadComplete.call(this, data);\n              }\n            } else if (this.videoTrackCC !== this.waitingVideoCC) {\n              // Drop waiting fragment if videoTrackCC has changed since waitingFragment was set and initPTS was not found\n              _utils_logger__WEBPACK_IMPORTED_MODULE_14__[\"logger\"].log(\"Waiting fragment cc (\" + frag.cc + \") cancelled because video is at cc \" + this.videoTrackCC);\n              this.clearWaitingFragment();\n            } else {\n              // Drop waiting fragment if an earlier fragment is needed\n              var pos = this.getLoadPosition();\n              var bufferInfo = _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_3__[\"BufferHelper\"].bufferInfo(this.mediaBuffer, pos, this.config.maxBufferHole);\n              var waitingFragmentAtPosition = Object(_fragment_finders__WEBPACK_IMPORTED_MODULE_11__[\"fragmentWithinToleranceTest\"])(bufferInfo.end, this.config.maxFragLookUpTolerance, frag);\n\n              if (waitingFragmentAtPosition < 0) {\n                _utils_logger__WEBPACK_IMPORTED_MODULE_14__[\"logger\"].log(\"Waiting fragment cc (\" + frag.cc + \") @ \" + frag.start + \" cancelled because another fragment at \" + bufferInfo.end + \" is needed\");\n                this.clearWaitingFragment();\n              }\n            }\n          } else {\n            this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"State\"].IDLE;\n          }\n        }\n    }\n\n    this.onTickEnd();\n  };\n\n  _proto.clearWaitingFragment = function clearWaitingFragment() {\n    var waitingData = this.waitingData;\n\n    if (waitingData) {\n      this.fragmentTracker.removeFragment(waitingData.frag);\n      this.waitingData = null;\n      this.waitingVideoCC = -1;\n      this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"State\"].IDLE;\n    }\n  };\n\n  _proto.onTickEnd = function onTickEnd() {\n    var media = this.media;\n\n    if (!media || !media.readyState) {\n      // Exit early if we don't have media or if the media hasn't buffered anything yet (readyState 0)\n      return;\n    }\n\n    var mediaBuffer = this.mediaBuffer ? this.mediaBuffer : media;\n    var buffered = mediaBuffer.buffered;\n\n    if (!this.loadedmetadata && buffered.length) {\n      this.loadedmetadata = true;\n    }\n\n    this.lastCurrentTime = media.currentTime;\n  };\n\n  _proto.doTickIdle = function doTickIdle() {\n    var _frag$decryptdata, _frag$decryptdata2;\n\n    var hls = this.hls,\n        levels = this.levels,\n        media = this.media,\n        trackId = this.trackId;\n    var config = hls.config;\n\n    if (!levels || !levels[trackId]) {\n      return;\n    } // if video not attached AND\n    // start fragment already requested OR start frag prefetch not enabled\n    // exit loop\n    // => if media not attached but start frag prefetch is enabled and start frag not requested yet, we will not exit loop\n\n\n    if (!media && (this.startFragRequested || !config.startFragPrefetch)) {\n      return;\n    }\n\n    var levelInfo = levels[trackId];\n    var trackDetails = levelInfo.details;\n\n    if (!trackDetails || trackDetails.live && this.levelLastLoaded !== trackId || this.waitForCdnTuneIn(trackDetails)) {\n      this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"State\"].WAITING_TRACK;\n      return;\n    }\n\n    if (this.bufferFlushed) {\n      this.bufferFlushed = false;\n      this.afterBufferFlushed(this.mediaBuffer ? this.mediaBuffer : this.media, _loader_fragment__WEBPACK_IMPORTED_MODULE_7__[\"ElementaryStreamTypes\"].AUDIO, _types_loader__WEBPACK_IMPORTED_MODULE_6__[\"PlaylistLevelType\"].AUDIO);\n    }\n\n    var bufferInfo = this.getFwdBufferInfo(this.mediaBuffer ? this.mediaBuffer : this.media, _types_loader__WEBPACK_IMPORTED_MODULE_6__[\"PlaylistLevelType\"].AUDIO);\n\n    if (bufferInfo === null) {\n      return;\n    }\n\n    var bufferLen = bufferInfo.len;\n    var maxBufLen = this.getMaxBufferLength();\n    var audioSwitch = this.audioSwitch; // if buffer length is less than maxBufLen try to load a new fragment\n\n    if (bufferLen >= maxBufLen && !audioSwitch) {\n      return;\n    }\n\n    if (!audioSwitch && this._streamEnded(bufferInfo, trackDetails)) {\n      hls.trigger(_events__WEBPACK_IMPORTED_MODULE_2__[\"Events\"].BUFFER_EOS, {\n        type: 'audio'\n      });\n      this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"State\"].ENDED;\n      return;\n    }\n\n    var fragments = trackDetails.fragments;\n    var start = fragments[0].start;\n    var targetBufferTime = bufferInfo.end;\n\n    if (audioSwitch) {\n      var pos = this.getLoadPosition();\n      targetBufferTime = pos; // if currentTime (pos) is less than alt audio playlist start time, it means that alt audio is ahead of currentTime\n\n      if (trackDetails.PTSKnown && pos < start) {\n        // if everything is buffered from pos to start or if audio buffer upfront, let's seek to start\n        if (bufferInfo.end > start || bufferInfo.nextStart) {\n          this.log('Alt audio track ahead of main track, seek to start of alt audio track');\n          media.currentTime = start + 0.05;\n        }\n      }\n    }\n\n    var frag = this.getNextFragment(targetBufferTime, trackDetails);\n\n    if (!frag) {\n      this.bufferFlushed = true;\n      return;\n    }\n\n    if (((_frag$decryptdata = frag.decryptdata) === null || _frag$decryptdata === void 0 ? void 0 : _frag$decryptdata.keyFormat) === 'identity' && !((_frag$decryptdata2 = frag.decryptdata) !== null && _frag$decryptdata2 !== void 0 && _frag$decryptdata2.key)) {\n      this.loadKey(frag, trackDetails);\n    } else {\n      this.loadFragment(frag, trackDetails, targetBufferTime);\n    }\n  };\n\n  _proto.getMaxBufferLength = function getMaxBufferLength() {\n    var maxConfigBuffer = _BaseStreamController.prototype.getMaxBufferLength.call(this);\n\n    var mainBufferInfo = this.getFwdBufferInfo(this.videoBuffer ? this.videoBuffer : this.media, _types_loader__WEBPACK_IMPORTED_MODULE_6__[\"PlaylistLevelType\"].MAIN);\n\n    if (mainBufferInfo === null) {\n      return maxConfigBuffer;\n    }\n\n    return Math.max(maxConfigBuffer, mainBufferInfo.len);\n  };\n\n  _proto.onMediaDetaching = function onMediaDetaching() {\n    this.videoBuffer = null;\n\n    _BaseStreamController.prototype.onMediaDetaching.call(this);\n  };\n\n  _proto.onAudioTracksUpdated = function onAudioTracksUpdated(event, _ref2) {\n    var audioTracks = _ref2.audioTracks;\n    this.resetTransmuxer();\n    this.levels = audioTracks.map(function (mediaPlaylist) {\n      return new _types_level__WEBPACK_IMPORTED_MODULE_5__[\"Level\"](mediaPlaylist);\n    });\n  };\n\n  _proto.onAudioTrackSwitching = function onAudioTrackSwitching(event, data) {\n    // if any URL found on new audio track, it is an alternate audio track\n    var altAudio = !!data.url;\n    this.trackId = data.id;\n    var fragCurrent = this.fragCurrent;\n\n    if (fragCurrent !== null && fragCurrent !== void 0 && fragCurrent.loader) {\n      fragCurrent.loader.abort();\n    }\n\n    this.fragCurrent = null;\n    this.clearWaitingFragment(); // destroy useless transmuxer when switching audio to main\n\n    if (!altAudio) {\n      this.resetTransmuxer();\n    } else {\n      // switching to audio track, start timer if not already started\n      this.setInterval(TICK_INTERVAL);\n    } // should we switch tracks ?\n\n\n    if (altAudio) {\n      this.audioSwitch = true; // main audio track are handled by stream-controller, just do something if switching to alt audio track\n\n      this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"State\"].IDLE;\n    } else {\n      this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"State\"].STOPPED;\n    }\n\n    this.tick();\n  };\n\n  _proto.onManifestLoading = function onManifestLoading() {\n    this.mainDetails = null;\n    this.fragmentTracker.removeAllFragments();\n    this.startPosition = this.lastCurrentTime = 0;\n    this.bufferFlushed = false;\n  };\n\n  _proto.onLevelLoaded = function onLevelLoaded(event, data) {\n    this.mainDetails = data.details;\n  };\n\n  _proto.onAudioTrackLoaded = function onAudioTrackLoaded(event, data) {\n    var _track$details;\n\n    var levels = this.levels;\n    var newDetails = data.details,\n        trackId = data.id;\n\n    if (!levels) {\n      this.warn(\"Audio tracks were reset while loading level \" + trackId);\n      return;\n    }\n\n    this.log(\"Track \" + trackId + \" loaded [\" + newDetails.startSN + \",\" + newDetails.endSN + \"],duration:\" + newDetails.totalduration);\n    var track = levels[trackId];\n    var sliding = 0;\n\n    if (newDetails.live || (_track$details = track.details) !== null && _track$details !== void 0 && _track$details.live) {\n      var mainDetails = this.mainDetails;\n\n      if (!newDetails.fragments[0]) {\n        newDetails.deltaUpdateFailed = true;\n      }\n\n      if (newDetails.deltaUpdateFailed || !mainDetails) {\n        return;\n      }\n\n      if (!track.details && newDetails.hasProgramDateTime && mainDetails.hasProgramDateTime) {\n        // Make sure our audio rendition is aligned with the \"main\" rendition, using\n        // pdt as our reference times.\n        Object(_utils_discontinuities__WEBPACK_IMPORTED_MODULE_12__[\"alignMediaPlaylistByPDT\"])(newDetails, mainDetails);\n        sliding = newDetails.fragments[0].start;\n      } else {\n        sliding = this.alignPlaylists(newDetails, track.details);\n      }\n    }\n\n    track.details = newDetails;\n    this.levelLastLoaded = trackId; // compute start position if we are aligned with the main playlist\n\n    if (!this.startFragRequested && (this.mainDetails || !newDetails.live)) {\n      this.setStartPosition(track.details, sliding);\n    } // only switch back to IDLE state if we were waiting for track to start downloading a new fragment\n\n\n    if (this.state === _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"State\"].WAITING_TRACK && !this.waitForCdnTuneIn(newDetails)) {\n      this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"State\"].IDLE;\n    } // trigger handler right now\n\n\n    this.tick();\n  };\n\n  _proto._handleFragmentLoadProgress = function _handleFragmentLoadProgress(data) {\n    var _frag$initSegment;\n\n    var frag = data.frag,\n        part = data.part,\n        payload = data.payload;\n    var config = this.config,\n        trackId = this.trackId,\n        levels = this.levels;\n\n    if (!levels) {\n      this.warn(\"Audio tracks were reset while fragment load was in progress. Fragment \" + frag.sn + \" of level \" + frag.level + \" will not be buffered\");\n      return;\n    }\n\n    var track = levels[trackId];\n    console.assert(track, 'Audio track is defined on fragment load progress');\n    var details = track.details;\n    console.assert(details, 'Audio track details are defined on fragment load progress');\n    var audioCodec = config.defaultAudioCodec || track.audioCodec || 'mp4a.40.2';\n    var transmuxer = this.transmuxer;\n\n    if (!transmuxer) {\n      transmuxer = this.transmuxer = new _demux_transmuxer_interface__WEBPACK_IMPORTED_MODULE_9__[\"default\"](this.hls, _types_loader__WEBPACK_IMPORTED_MODULE_6__[\"PlaylistLevelType\"].AUDIO, this._handleTransmuxComplete.bind(this), this._handleTransmuxerFlush.bind(this));\n    } // Check if we have video initPTS\n    // If not we need to wait for it\n\n\n    var initPTS = this.initPTS[frag.cc];\n    var initSegmentData = (_frag$initSegment = frag.initSegment) === null || _frag$initSegment === void 0 ? void 0 : _frag$initSegment.data;\n\n    if (initPTS !== undefined) {\n      // this.log(`Transmuxing ${sn} of [${details.startSN} ,${details.endSN}],track ${trackId}`);\n      // time Offset is accurate if level PTS is known, or if playlist is not sliding (not live)\n      var accurateTimeOffset = false; // details.PTSKnown || !details.live;\n\n      var partIndex = part ? part.index : -1;\n      var partial = partIndex !== -1;\n      var chunkMeta = new _types_transmuxer__WEBPACK_IMPORTED_MODULE_10__[\"ChunkMetadata\"](frag.level, frag.sn, frag.stats.chunkCount, payload.byteLength, partIndex, partial);\n      transmuxer.push(payload, initSegmentData, audioCodec, '', frag, part, details.totalduration, accurateTimeOffset, chunkMeta, initPTS);\n    } else {\n      _utils_logger__WEBPACK_IMPORTED_MODULE_14__[\"logger\"].log(\"Unknown video PTS for cc \" + frag.cc + \", waiting for video PTS before demuxing audio frag \" + frag.sn + \" of [\" + details.startSN + \" ,\" + details.endSN + \"],track \" + trackId);\n\n      var _this$waitingData = this.waitingData = this.waitingData || {\n        frag: frag,\n        part: part,\n        cache: new _demux_chunk_cache__WEBPACK_IMPORTED_MODULE_8__[\"default\"](),\n        complete: false\n      },\n          cache = _this$waitingData.cache;\n\n      cache.push(new Uint8Array(payload));\n      this.waitingVideoCC = this.videoTrackCC;\n      this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"State\"].WAITING_INIT_PTS;\n    }\n  };\n\n  _proto._handleFragmentLoadComplete = function _handleFragmentLoadComplete(fragLoadedData) {\n    if (this.waitingData) {\n      this.waitingData.complete = true;\n      return;\n    }\n\n    _BaseStreamController.prototype._handleFragmentLoadComplete.call(this, fragLoadedData);\n  };\n\n  _proto.onBufferReset = function\n    /* event: Events.BUFFER_RESET */\n  onBufferReset() {\n    // reset reference to sourcebuffers\n    this.mediaBuffer = this.videoBuffer = null;\n    this.loadedmetadata = false;\n  };\n\n  _proto.onBufferCreated = function onBufferCreated(event, data) {\n    var audioTrack = data.tracks.audio;\n\n    if (audioTrack) {\n      this.mediaBuffer = audioTrack.buffer;\n    }\n\n    if (data.tracks.video) {\n      this.videoBuffer = data.tracks.video.buffer;\n    }\n  };\n\n  _proto.onFragBuffered = function onFragBuffered(event, data) {\n    var frag = data.frag,\n        part = data.part;\n\n    if (frag.type !== _types_loader__WEBPACK_IMPORTED_MODULE_6__[\"PlaylistLevelType\"].AUDIO) {\n      return;\n    }\n\n    if (this.fragContextChanged(frag)) {\n      // If a level switch was requested while a fragment was buffering, it will emit the FRAG_BUFFERED event upon completion\n      // Avoid setting state back to IDLE or concluding the audio switch; otherwise, the switched-to track will not buffer\n      this.warn(\"Fragment \" + frag.sn + (part ? ' p: ' + part.index : '') + \" of level \" + frag.level + \" finished buffering, but was aborted. state: \" + this.state + \", audioSwitch: \" + this.audioSwitch);\n      return;\n    }\n\n    if (frag.sn !== 'initSegment') {\n      this.fragPrevious = frag;\n\n      if (this.audioSwitch) {\n        this.audioSwitch = false;\n        this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_2__[\"Events\"].AUDIO_TRACK_SWITCHED, {\n          id: this.trackId\n        });\n      }\n    }\n\n    this.fragBufferedComplete(frag, part);\n  };\n\n  _proto.onError = function onError(event, data) {\n    switch (data.details) {\n      case _errors__WEBPACK_IMPORTED_MODULE_13__[\"ErrorDetails\"].FRAG_LOAD_ERROR:\n      case _errors__WEBPACK_IMPORTED_MODULE_13__[\"ErrorDetails\"].FRAG_LOAD_TIMEOUT:\n      case _errors__WEBPACK_IMPORTED_MODULE_13__[\"ErrorDetails\"].KEY_LOAD_ERROR:\n      case _errors__WEBPACK_IMPORTED_MODULE_13__[\"ErrorDetails\"].KEY_LOAD_TIMEOUT:\n        // TODO: Skip fragments that do not belong to this.fragCurrent audio-group id\n        this.onFragmentOrKeyLoadError(_types_loader__WEBPACK_IMPORTED_MODULE_6__[\"PlaylistLevelType\"].AUDIO, data);\n        break;\n\n      case _errors__WEBPACK_IMPORTED_MODULE_13__[\"ErrorDetails\"].AUDIO_TRACK_LOAD_ERROR:\n      case _errors__WEBPACK_IMPORTED_MODULE_13__[\"ErrorDetails\"].AUDIO_TRACK_LOAD_TIMEOUT:\n        //  when in ERROR state, don't switch back to IDLE state in case a non-fatal error is received\n        if (this.state !== _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"State\"].ERROR && this.state !== _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"State\"].STOPPED) {\n          // if fatal error, stop processing, otherwise move to IDLE to retry loading\n          this.state = data.fatal ? _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"State\"].ERROR : _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"State\"].IDLE;\n          this.warn(data.details + \" while loading frag, switching to \" + this.state + \" state\");\n        }\n\n        break;\n\n      case _errors__WEBPACK_IMPORTED_MODULE_13__[\"ErrorDetails\"].BUFFER_FULL_ERROR:\n        // if in appending state\n        if (data.parent === 'audio' && (this.state === _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"State\"].PARSING || this.state === _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"State\"].PARSED)) {\n          var flushBuffer = true;\n          var bufferedInfo = this.getFwdBufferInfo(this.mediaBuffer, _types_loader__WEBPACK_IMPORTED_MODULE_6__[\"PlaylistLevelType\"].AUDIO); // 0.5 : tolerance needed as some browsers stalls playback before reaching buffered end\n          // reduce max buf len if current position is buffered\n\n          if (bufferedInfo && bufferedInfo.len > 0.5) {\n            flushBuffer = !this.reduceMaxBufferLength(bufferedInfo.len);\n          }\n\n          if (flushBuffer) {\n            // current position is not buffered, but browser is still complaining about buffer full error\n            // this happens on IE/Edge, refer to https://github.com/video-dev/hls.js/pull/708\n            // in that case flush the whole audio buffer to recover\n            this.warn('Buffer full error also media.currentTime is not buffered, flush audio buffer');\n            this.fragCurrent = null;\n\n            _BaseStreamController.prototype.flushMainBuffer.call(this, 0, Number.POSITIVE_INFINITY, 'audio');\n          }\n\n          this.resetLoadingState();\n        }\n\n        break;\n\n      default:\n        break;\n    }\n  };\n\n  _proto.onBufferFlushed = function onBufferFlushed(event, _ref3) {\n    var type = _ref3.type;\n\n    if (type === _loader_fragment__WEBPACK_IMPORTED_MODULE_7__[\"ElementaryStreamTypes\"].AUDIO) {\n      this.bufferFlushed = true;\n    }\n  };\n\n  _proto._handleTransmuxComplete = function _handleTransmuxComplete(transmuxResult) {\n    var _id3$samples;\n\n    var id = 'audio';\n    var hls = this.hls;\n    var remuxResult = transmuxResult.remuxResult,\n        chunkMeta = transmuxResult.chunkMeta;\n    var context = this.getCurrentContext(chunkMeta);\n\n    if (!context) {\n      this.warn(\"The loading context changed while buffering fragment \" + chunkMeta.sn + \" of level \" + chunkMeta.level + \". This chunk will not be buffered.\");\n      this.resetLiveStartWhenNotLoaded(chunkMeta.level);\n      return;\n    }\n\n    var frag = context.frag,\n        part = context.part;\n    var audio = remuxResult.audio,\n        text = remuxResult.text,\n        id3 = remuxResult.id3,\n        initSegment = remuxResult.initSegment; // Check if the current fragment has been aborted. We check this by first seeing if we're still playing the current level.\n    // If we are, subsequently check if the currently loading fragment (fragCurrent) has changed.\n\n    if (this.fragContextChanged(frag)) {\n      return;\n    }\n\n    this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"State\"].PARSING;\n\n    if (this.audioSwitch && audio) {\n      this.completeAudioSwitch();\n    }\n\n    if (initSegment !== null && initSegment !== void 0 && initSegment.tracks) {\n      this._bufferInitSegment(initSegment.tracks, frag, chunkMeta);\n\n      hls.trigger(_events__WEBPACK_IMPORTED_MODULE_2__[\"Events\"].FRAG_PARSING_INIT_SEGMENT, {\n        frag: frag,\n        id: id,\n        tracks: initSegment.tracks\n      }); // Only flush audio from old audio tracks when PTS is known on new audio track\n    }\n\n    if (audio) {\n      var startPTS = audio.startPTS,\n          endPTS = audio.endPTS,\n          startDTS = audio.startDTS,\n          endDTS = audio.endDTS;\n\n      if (part) {\n        part.elementaryStreams[_loader_fragment__WEBPACK_IMPORTED_MODULE_7__[\"ElementaryStreamTypes\"].AUDIO] = {\n          startPTS: startPTS,\n          endPTS: endPTS,\n          startDTS: startDTS,\n          endDTS: endDTS\n        };\n      }\n\n      frag.setElementaryStreamInfo(_loader_fragment__WEBPACK_IMPORTED_MODULE_7__[\"ElementaryStreamTypes\"].AUDIO, startPTS, endPTS, startDTS, endDTS);\n      this.bufferFragmentData(audio, frag, part, chunkMeta);\n    }\n\n    if (id3 !== null && id3 !== void 0 && (_id3$samples = id3.samples) !== null && _id3$samples !== void 0 && _id3$samples.length) {\n      var emittedID3 = _extends({\n        frag: frag,\n        id: id\n      }, id3);\n\n      hls.trigger(_events__WEBPACK_IMPORTED_MODULE_2__[\"Events\"].FRAG_PARSING_METADATA, emittedID3);\n    }\n\n    if (text) {\n      var emittedText = _extends({\n        frag: frag,\n        id: id\n      }, text);\n\n      hls.trigger(_events__WEBPACK_IMPORTED_MODULE_2__[\"Events\"].FRAG_PARSING_USERDATA, emittedText);\n    }\n  };\n\n  _proto._bufferInitSegment = function _bufferInitSegment(tracks, frag, chunkMeta) {\n    if (this.state !== _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"State\"].PARSING) {\n      return;\n    } // delete any video track found on audio transmuxer\n\n\n    if (tracks.video) {\n      delete tracks.video;\n    } // include levelCodec in audio and video tracks\n\n\n    var track = tracks.audio;\n\n    if (!track) {\n      return;\n    }\n\n    track.levelCodec = track.codec;\n    track.id = 'audio';\n    this.log(\"Init audio buffer, container:\" + track.container + \", codecs[parsed]=[\" + track.codec + \"]\");\n    this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_2__[\"Events\"].BUFFER_CODECS, tracks);\n    var initSegment = track.initSegment;\n\n    if (initSegment !== null && initSegment !== void 0 && initSegment.byteLength) {\n      var segment = {\n        type: 'audio',\n        frag: frag,\n        part: null,\n        chunkMeta: chunkMeta,\n        parent: frag.type,\n        data: initSegment\n      };\n      this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_2__[\"Events\"].BUFFER_APPENDING, segment);\n    } // trigger handler right now\n\n\n    this.tick();\n  };\n\n  _proto.loadFragment = function loadFragment(frag, trackDetails, targetBufferTime) {\n    // only load if fragment is not loaded or if in audio switch\n    var fragState = this.fragmentTracker.getState(frag);\n    this.fragCurrent = frag; // we force a frag loading in audio switch as fragment tracker might not have evicted previous frags in case of quick audio switch\n\n    if (this.audioSwitch || fragState === _fragment_tracker__WEBPACK_IMPORTED_MODULE_4__[\"FragmentState\"].NOT_LOADED || fragState === _fragment_tracker__WEBPACK_IMPORTED_MODULE_4__[\"FragmentState\"].PARTIAL) {\n      if (frag.sn === 'initSegment') {\n        this._loadInitSegment(frag);\n      } else if (trackDetails.live && !Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__[\"isFiniteNumber\"])(this.initPTS[frag.cc])) {\n        this.log(\"Waiting for video PTS in continuity counter \" + frag.cc + \" of live stream before loading audio fragment \" + frag.sn + \" of level \" + this.trackId);\n        this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"State\"].WAITING_INIT_PTS;\n      } else {\n        this.startFragRequested = true;\n\n        _BaseStreamController.prototype.loadFragment.call(this, frag, trackDetails, targetBufferTime);\n      }\n    }\n  };\n\n  _proto.completeAudioSwitch = function completeAudioSwitch() {\n    var hls = this.hls,\n        media = this.media,\n        trackId = this.trackId;\n\n    if (media) {\n      this.log('Switching audio track : flushing all audio');\n\n      _BaseStreamController.prototype.flushMainBuffer.call(this, 0, Number.POSITIVE_INFINITY, 'audio');\n    }\n\n    this.audioSwitch = false;\n    hls.trigger(_events__WEBPACK_IMPORTED_MODULE_2__[\"Events\"].AUDIO_TRACK_SWITCHED, {\n      id: trackId\n    });\n  };\n\n  return AudioStreamController;\n}(_base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"default\"]);\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (AudioStreamController);\n\n/***/ }),\n\n/***/ \"./src/controller/audio-track-controller.ts\":\n/*!**************************************************!*\\\n  !*** ./src/controller/audio-track-controller.ts ***!\n  \\**************************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_97039__) {\n\n\"use strict\";\n__nested_webpack_require_97039__.r(__webpack_exports__);\n/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_97039__(/*! ../events */ \"./src/events.ts\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_97039__(/*! ../errors */ \"./src/errors.ts\");\n/* harmony import */ var _base_playlist_controller__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_97039__(/*! ./base-playlist-controller */ \"./src/controller/base-playlist-controller.ts\");\n/* harmony import */ var _types_loader__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_97039__(/*! ../types/loader */ \"./src/types/loader.ts\");\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n\n\n\n\n\nvar AudioTrackController = /*#__PURE__*/function (_BasePlaylistControll) {\n  _inheritsLoose(AudioTrackController, _BasePlaylistControll);\n\n  function AudioTrackController(hls) {\n    var _this;\n\n    _this = _BasePlaylistControll.call(this, hls, '[audio-track-controller]') || this;\n    _this.tracks = [];\n    _this.groupId = null;\n    _this.tracksInGroup = [];\n    _this.trackId = -1;\n    _this.trackName = '';\n    _this.selectDefaultTrack = true;\n\n    _this.registerListeners();\n\n    return _this;\n  }\n\n  var _proto = AudioTrackController.prototype;\n\n  _proto.registerListeners = function registerListeners() {\n    var hls = this.hls;\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].MANIFEST_PARSED, this.onManifestParsed, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].LEVEL_LOADING, this.onLevelLoading, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].LEVEL_SWITCHING, this.onLevelSwitching, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].ERROR, this.onError, this);\n  };\n\n  _proto.unregisterListeners = function unregisterListeners() {\n    var hls = this.hls;\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].MANIFEST_PARSED, this.onManifestParsed, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].LEVEL_LOADING, this.onLevelLoading, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].LEVEL_SWITCHING, this.onLevelSwitching, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].ERROR, this.onError, this);\n  };\n\n  _proto.destroy = function destroy() {\n    this.unregisterListeners();\n    this.tracks.length = 0;\n    this.tracksInGroup.length = 0;\n\n    _BasePlaylistControll.prototype.destroy.call(this);\n  };\n\n  _proto.onManifestLoading = function onManifestLoading() {\n    this.tracks = [];\n    this.groupId = null;\n    this.tracksInGroup = [];\n    this.trackId = -1;\n    this.trackName = '';\n    this.selectDefaultTrack = true;\n  };\n\n  _proto.onManifestParsed = function onManifestParsed(event, data) {\n    this.tracks = data.audioTracks || [];\n  };\n\n  _proto.onAudioTrackLoaded = function onAudioTrackLoaded(event, data) {\n    var id = data.id,\n        details = data.details;\n    var currentTrack = this.tracksInGroup[id];\n\n    if (!currentTrack) {\n      this.warn(\"Invalid audio track id \" + id);\n      return;\n    }\n\n    var curDetails = currentTrack.details;\n    currentTrack.details = data.details;\n    this.log(\"audioTrack \" + id + \" loaded [\" + details.startSN + \"-\" + details.endSN + \"]\");\n\n    if (id === this.trackId) {\n      this.retryCount = 0;\n      this.playlistLoaded(id, data, curDetails);\n    }\n  };\n\n  _proto.onLevelLoading = function onLevelLoading(event, data) {\n    this.switchLevel(data.level);\n  };\n\n  _proto.onLevelSwitching = function onLevelSwitching(event, data) {\n    this.switchLevel(data.level);\n  };\n\n  _proto.switchLevel = function switchLevel(levelIndex) {\n    var levelInfo = this.hls.levels[levelIndex];\n\n    if (!(levelInfo !== null && levelInfo !== void 0 && levelInfo.audioGroupIds)) {\n      return;\n    }\n\n    var audioGroupId = levelInfo.audioGroupIds[levelInfo.urlId];\n\n    if (this.groupId !== audioGroupId) {\n      this.groupId = audioGroupId;\n      var audioTracks = this.tracks.filter(function (track) {\n        return !audioGroupId || track.groupId === audioGroupId;\n      }); // Disable selectDefaultTrack if there are no default tracks\n\n      if (this.selectDefaultTrack && !audioTracks.some(function (track) {\n        return track.default;\n      })) {\n        this.selectDefaultTrack = false;\n      }\n\n      this.tracksInGroup = audioTracks;\n      var audioTracksUpdated = {\n        audioTracks: audioTracks\n      };\n      this.log(\"Updating audio tracks, \" + audioTracks.length + \" track(s) found in \\\"\" + audioGroupId + \"\\\" group-id\");\n      this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].AUDIO_TRACKS_UPDATED, audioTracksUpdated);\n      this.selectInitialTrack();\n    }\n  };\n\n  _proto.onError = function onError(event, data) {\n    _BasePlaylistControll.prototype.onError.call(this, event, data);\n\n    if (data.fatal || !data.context) {\n      return;\n    }\n\n    if (data.context.type === _types_loader__WEBPACK_IMPORTED_MODULE_3__[\"PlaylistContextType\"].AUDIO_TRACK && data.context.id === this.trackId && data.context.groupId === this.groupId) {\n      this.retryLoadingOrFail(data);\n    }\n  };\n\n  _proto.setAudioTrack = function setAudioTrack(newId) {\n    var tracks = this.tracksInGroup; // check if level idx is valid\n\n    if (newId < 0 || newId >= tracks.length) {\n      this.warn('Invalid id passed to audio-track controller');\n      return;\n    } // stopping live reloading timer if any\n\n\n    this.clearTimer();\n    var lastTrack = tracks[this.trackId];\n    this.log(\"Now switching to audio-track index \" + newId);\n    var track = tracks[newId];\n    var id = track.id,\n        _track$groupId = track.groupId,\n        groupId = _track$groupId === void 0 ? '' : _track$groupId,\n        name = track.name,\n        type = track.type,\n        url = track.url;\n    this.trackId = newId;\n    this.trackName = name;\n    this.selectDefaultTrack = false;\n    this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].AUDIO_TRACK_SWITCHING, {\n      id: id,\n      groupId: groupId,\n      name: name,\n      type: type,\n      url: url\n    }); // Do not reload track unless live\n\n    if (track.details && !track.details.live) {\n      return;\n    }\n\n    var hlsUrlParameters = this.switchParams(track.url, lastTrack === null || lastTrack === void 0 ? void 0 : lastTrack.details);\n    this.loadPlaylist(hlsUrlParameters);\n  };\n\n  _proto.selectInitialTrack = function selectInitialTrack() {\n    var audioTracks = this.tracksInGroup;\n    console.assert(audioTracks.length, 'Initial audio track should be selected when tracks are known');\n    var currentAudioTrackName = this.trackName;\n    var trackId = this.findTrackId(currentAudioTrackName) || this.findTrackId();\n\n    if (trackId !== -1) {\n      this.setAudioTrack(trackId);\n    } else {\n      this.warn(\"No track found for running audio group-ID: \" + this.groupId);\n      this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].ERROR, {\n        type: _errors__WEBPACK_IMPORTED_MODULE_1__[\"ErrorTypes\"].MEDIA_ERROR,\n        details: _errors__WEBPACK_IMPORTED_MODULE_1__[\"ErrorDetails\"].AUDIO_TRACK_LOAD_ERROR,\n        fatal: true\n      });\n    }\n  };\n\n  _proto.findTrackId = function findTrackId(name) {\n    var audioTracks = this.tracksInGroup;\n\n    for (var i = 0; i < audioTracks.length; i++) {\n      var track = audioTracks[i];\n\n      if (!this.selectDefaultTrack || track.default) {\n        if (!name || name === track.name) {\n          return track.id;\n        }\n      }\n    }\n\n    return -1;\n  };\n\n  _proto.loadPlaylist = function loadPlaylist(hlsUrlParameters) {\n    var audioTrack = this.tracksInGroup[this.trackId];\n\n    if (this.shouldLoadTrack(audioTrack)) {\n      var id = audioTrack.id;\n      var groupId = audioTrack.groupId;\n      var url = audioTrack.url;\n\n      if (hlsUrlParameters) {\n        try {\n          url = hlsUrlParameters.addDirectives(url);\n        } catch (error) {\n          this.warn(\"Could not construct new URL with HLS Delivery Directives: \" + error);\n        }\n      } // track not retrieved yet, or live playlist we need to (re)load it\n\n\n      this.log(\"loading audio-track playlist for id: \" + id);\n      this.clearTimer();\n      this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].AUDIO_TRACK_LOADING, {\n        url: url,\n        id: id,\n        groupId: groupId,\n        deliveryDirectives: hlsUrlParameters || null\n      });\n    }\n  };\n\n  _createClass(AudioTrackController, [{\n    key: \"audioTracks\",\n    get: function get() {\n      return this.tracksInGroup;\n    }\n  }, {\n    key: \"audioTrack\",\n    get: function get() {\n      return this.trackId;\n    },\n    set: function set(newId) {\n      // If audio track is selected from API then don't choose from the manifest default track\n      this.selectDefaultTrack = false;\n      this.setAudioTrack(newId);\n    }\n  }]);\n\n  return AudioTrackController;\n}(_base_playlist_controller__WEBPACK_IMPORTED_MODULE_2__[\"default\"]);\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (AudioTrackController);\n\n/***/ }),\n\n/***/ \"./src/controller/base-playlist-controller.ts\":\n/*!****************************************************!*\\\n  !*** ./src/controller/base-playlist-controller.ts ***!\n  \\****************************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_107600__) {\n\n\"use strict\";\n__nested_webpack_require_107600__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_107600__.d(__webpack_exports__, \"default\", function() { return BasePlaylistController; });\n/* harmony import */ var _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_107600__(/*! ./src/polyfills/number */ \"./src/polyfills/number.ts\");\n/* harmony import */ var _types_level__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_107600__(/*! ../types/level */ \"./src/types/level.ts\");\n/* harmony import */ var _level_helper__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_107600__(/*! ./level-helper */ \"./src/controller/level-helper.ts\");\n/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_107600__(/*! ../utils/logger */ \"./src/utils/logger.ts\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_107600__(/*! ../errors */ \"./src/errors.ts\");\n\n\n\n\n\n\n\nvar BasePlaylistController = /*#__PURE__*/function () {\n  function BasePlaylistController(hls, logPrefix) {\n    this.hls = void 0;\n    this.timer = -1;\n    this.canLoad = false;\n    this.retryCount = 0;\n    this.log = void 0;\n    this.warn = void 0;\n    this.log = _utils_logger__WEBPACK_IMPORTED_MODULE_3__[\"logger\"].log.bind(_utils_logger__WEBPACK_IMPORTED_MODULE_3__[\"logger\"], logPrefix + \":\");\n    this.warn = _utils_logger__WEBPACK_IMPORTED_MODULE_3__[\"logger\"].warn.bind(_utils_logger__WEBPACK_IMPORTED_MODULE_3__[\"logger\"], logPrefix + \":\");\n    this.hls = hls;\n  }\n\n  var _proto = BasePlaylistController.prototype;\n\n  _proto.destroy = function destroy() {\n    this.clearTimer(); // @ts-ignore\n\n    this.hls = this.log = this.warn = null;\n  };\n\n  _proto.onError = function onError(event, data) {\n    if (data.fatal && data.type === _errors__WEBPACK_IMPORTED_MODULE_4__[\"ErrorTypes\"].NETWORK_ERROR) {\n      this.clearTimer();\n    }\n  };\n\n  _proto.clearTimer = function clearTimer() {\n    clearTimeout(this.timer);\n    this.timer = -1;\n  };\n\n  _proto.startLoad = function startLoad() {\n    this.canLoad = true;\n    this.retryCount = 0;\n    this.loadPlaylist();\n  };\n\n  _proto.stopLoad = function stopLoad() {\n    this.canLoad = false;\n    this.clearTimer();\n  };\n\n  _proto.switchParams = function switchParams(playlistUri, previous) {\n    var renditionReports = previous === null || previous === void 0 ? void 0 : previous.renditionReports;\n\n    if (renditionReports) {\n      for (var i = 0; i < renditionReports.length; i++) {\n        var attr = renditionReports[i];\n        var uri = '' + attr.URI;\n\n        if (uri === playlistUri.substr(-uri.length)) {\n          var msn = parseInt(attr['LAST-MSN']);\n          var part = parseInt(attr['LAST-PART']);\n\n          if (previous && this.hls.config.lowLatencyMode) {\n            var currentGoal = Math.min(previous.age - previous.partTarget, previous.targetduration);\n\n            if (part !== undefined && currentGoal > previous.partTarget) {\n              part += 1;\n            }\n          }\n\n          if (Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__[\"isFiniteNumber\"])(msn)) {\n            return new _types_level__WEBPACK_IMPORTED_MODULE_1__[\"HlsUrlParameters\"](msn, Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__[\"isFiniteNumber\"])(part) ? part : undefined, _types_level__WEBPACK_IMPORTED_MODULE_1__[\"HlsSkip\"].No);\n          }\n        }\n      }\n    }\n  };\n\n  _proto.loadPlaylist = function loadPlaylist(hlsUrlParameters) {};\n\n  _proto.shouldLoadTrack = function shouldLoadTrack(track) {\n    return this.canLoad && track && !!track.url && (!track.details || track.details.live);\n  };\n\n  _proto.playlistLoaded = function playlistLoaded(index, data, previousDetails) {\n    var _this = this;\n\n    var details = data.details,\n        stats = data.stats; // Set last updated date-time\n\n    var elapsed = stats.loading.end ? Math.max(0, self.performance.now() - stats.loading.end) : 0;\n    details.advancedDateTime = Date.now() - elapsed; // if current playlist is a live playlist, arm a timer to reload it\n\n    if (details.live || previousDetails !== null && previousDetails !== void 0 && previousDetails.live) {\n      details.reloaded(previousDetails);\n\n      if (previousDetails) {\n        this.log(\"live playlist \" + index + \" \" + (details.advanced ? 'REFRESHED ' + details.lastPartSn + '-' + details.lastPartIndex : 'MISSED'));\n      } // Merge live playlists to adjust fragment starts and fill in delta playlist skipped segments\n\n\n      if (previousDetails && details.fragments.length > 0) {\n        Object(_level_helper__WEBPACK_IMPORTED_MODULE_2__[\"mergeDetails\"])(previousDetails, details);\n      }\n\n      if (!this.canLoad || !details.live) {\n        return;\n      }\n\n      var deliveryDirectives;\n      var msn = undefined;\n      var part = undefined;\n\n      if (details.canBlockReload && details.endSN && details.advanced) {\n        // Load level with LL-HLS delivery directives\n        var lowLatencyMode = this.hls.config.lowLatencyMode;\n        var lastPartSn = details.lastPartSn;\n        var endSn = details.endSN;\n        var lastPartIndex = details.lastPartIndex;\n        var hasParts = lastPartIndex !== -1;\n        var lastPart = lastPartSn === endSn; // When low latency mode is disabled, we'll skip part requests once the last part index is found\n\n        var nextSnStartIndex = lowLatencyMode ? 0 : lastPartIndex;\n\n        if (hasParts) {\n          msn = lastPart ? endSn + 1 : lastPartSn;\n          part = lastPart ? nextSnStartIndex : lastPartIndex + 1;\n        } else {\n          msn = endSn + 1;\n        } // Low-Latency CDN Tune-in: \"age\" header and time since load indicates we're behind by more than one part\n        // Update directives to obtain the Playlist that has the estimated additional duration of media\n\n\n        var lastAdvanced = details.age;\n        var cdnAge = lastAdvanced + details.ageHeader;\n        var currentGoal = Math.min(cdnAge - details.partTarget, details.targetduration * 1.5);\n\n        if (currentGoal > 0) {\n          if (previousDetails && currentGoal > previousDetails.tuneInGoal) {\n            // If we attempted to get the next or latest playlist update, but currentGoal increased,\n            // then we either can't catchup, or the \"age\" header cannot be trusted.\n            this.warn(\"CDN Tune-in goal increased from: \" + previousDetails.tuneInGoal + \" to: \" + currentGoal + \" with playlist age: \" + details.age);\n            currentGoal = 0;\n          } else {\n            var segments = Math.floor(currentGoal / details.targetduration);\n            msn += segments;\n\n            if (part !== undefined) {\n              var parts = Math.round(currentGoal % details.targetduration / details.partTarget);\n              part += parts;\n            }\n\n            this.log(\"CDN Tune-in age: \" + details.ageHeader + \"s last advanced \" + lastAdvanced.toFixed(2) + \"s goal: \" + currentGoal + \" skip sn \" + segments + \" to part \" + part);\n          }\n\n          details.tuneInGoal = currentGoal;\n        }\n\n        deliveryDirectives = this.getDeliveryDirectives(details, data.deliveryDirectives, msn, part);\n\n        if (lowLatencyMode || !lastPart) {\n          this.loadPlaylist(deliveryDirectives);\n          return;\n        }\n      } else {\n        deliveryDirectives = this.getDeliveryDirectives(details, data.deliveryDirectives, msn, part);\n      }\n\n      var reloadInterval = Object(_level_helper__WEBPACK_IMPORTED_MODULE_2__[\"computeReloadInterval\"])(details, stats);\n\n      if (msn !== undefined && details.canBlockReload) {\n        reloadInterval -= details.partTarget || 1;\n      }\n\n      this.log(\"reload live playlist \" + index + \" in \" + Math.round(reloadInterval) + \" ms\");\n      this.timer = self.setTimeout(function () {\n        return _this.loadPlaylist(deliveryDirectives);\n      }, reloadInterval);\n    } else {\n      this.clearTimer();\n    }\n  };\n\n  _proto.getDeliveryDirectives = function getDeliveryDirectives(details, previousDeliveryDirectives, msn, part) {\n    var skip = Object(_types_level__WEBPACK_IMPORTED_MODULE_1__[\"getSkipValue\"])(details, msn);\n\n    if (previousDeliveryDirectives !== null && previousDeliveryDirectives !== void 0 && previousDeliveryDirectives.skip && details.deltaUpdateFailed) {\n      msn = previousDeliveryDirectives.msn;\n      part = previousDeliveryDirectives.part;\n      skip = _types_level__WEBPACK_IMPORTED_MODULE_1__[\"HlsSkip\"].No;\n    }\n\n    return new _types_level__WEBPACK_IMPORTED_MODULE_1__[\"HlsUrlParameters\"](msn, part, skip);\n  };\n\n  _proto.retryLoadingOrFail = function retryLoadingOrFail(errorEvent) {\n    var _this2 = this;\n\n    var config = this.hls.config;\n    var retry = this.retryCount < config.levelLoadingMaxRetry;\n\n    if (retry) {\n      var _errorEvent$context;\n\n      this.retryCount++;\n\n      if (errorEvent.details.indexOf('LoadTimeOut') > -1 && (_errorEvent$context = errorEvent.context) !== null && _errorEvent$context !== void 0 && _errorEvent$context.deliveryDirectives) {\n        // The LL-HLS request already timed out so retry immediately\n        this.warn(\"retry playlist loading #\" + this.retryCount + \" after \\\"\" + errorEvent.details + \"\\\"\");\n        this.loadPlaylist();\n      } else {\n        // exponential backoff capped to max retry timeout\n        var delay = Math.min(Math.pow(2, this.retryCount) * config.levelLoadingRetryDelay, config.levelLoadingMaxRetryTimeout); // Schedule level/track reload\n\n        this.timer = self.setTimeout(function () {\n          return _this2.loadPlaylist();\n        }, delay);\n        this.warn(\"retry playlist loading #\" + this.retryCount + \" in \" + delay + \" ms after \\\"\" + errorEvent.details + \"\\\"\");\n      }\n    } else {\n      this.warn(\"cannot recover from error \\\"\" + errorEvent.details + \"\\\"\"); // stopping live reloading timer if any\n\n      this.clearTimer(); // switch error to fatal\n\n      errorEvent.fatal = true;\n    }\n\n    return retry;\n  };\n\n  return BasePlaylistController;\n}();\n\n\n\n/***/ }),\n\n/***/ \"./src/controller/base-stream-controller.ts\":\n/*!**************************************************!*\\\n  !*** ./src/controller/base-stream-controller.ts ***!\n  \\**************************************************/\n/*! exports provided: State, default */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_117901__) {\n\n\"use strict\";\n__nested_webpack_require_117901__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_117901__.d(__webpack_exports__, \"State\", function() { return State; });\n/* harmony export (binding) */ __nested_webpack_require_117901__.d(__webpack_exports__, \"default\", function() { return BaseStreamController; });\n/* harmony import */ var _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_117901__(/*! ./src/polyfills/number */ \"./src/polyfills/number.ts\");\n/* harmony import */ var _task_loop__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_117901__(/*! ../task-loop */ \"./src/task-loop.ts\");\n/* harmony import */ var _fragment_tracker__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_117901__(/*! ./fragment-tracker */ \"./src/controller/fragment-tracker.ts\");\n/* harmony import */ var _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_117901__(/*! ../utils/buffer-helper */ \"./src/utils/buffer-helper.ts\");\n/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_117901__(/*! ../utils/logger */ \"./src/utils/logger.ts\");\n/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_117901__(/*! ../events */ \"./src/events.ts\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_117901__(/*! ../errors */ \"./src/errors.ts\");\n/* harmony import */ var _types_transmuxer__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_117901__(/*! ../types/transmuxer */ \"./src/types/transmuxer.ts\");\n/* harmony import */ var _utils_mp4_tools__WEBPACK_IMPORTED_MODULE_8__ = __nested_webpack_require_117901__(/*! ../utils/mp4-tools */ \"./src/utils/mp4-tools.ts\");\n/* harmony import */ var _utils_discontinuities__WEBPACK_IMPORTED_MODULE_9__ = __nested_webpack_require_117901__(/*! ../utils/discontinuities */ \"./src/utils/discontinuities.ts\");\n/* harmony import */ var _fragment_finders__WEBPACK_IMPORTED_MODULE_10__ = __nested_webpack_require_117901__(/*! ./fragment-finders */ \"./src/controller/fragment-finders.ts\");\n/* harmony import */ var _level_helper__WEBPACK_IMPORTED_MODULE_11__ = __nested_webpack_require_117901__(/*! ./level-helper */ \"./src/controller/level-helper.ts\");\n/* harmony import */ var _loader_fragment_loader__WEBPACK_IMPORTED_MODULE_12__ = __nested_webpack_require_117901__(/*! ../loader/fragment-loader */ \"./src/loader/fragment-loader.ts\");\n/* harmony import */ var _crypt_decrypter__WEBPACK_IMPORTED_MODULE_13__ = __nested_webpack_require_117901__(/*! ../crypt/decrypter */ \"./src/crypt/decrypter.ts\");\n/* harmony import */ var _utils_time_ranges__WEBPACK_IMPORTED_MODULE_14__ = __nested_webpack_require_117901__(/*! ../utils/time-ranges */ \"./src/utils/time-ranges.ts\");\n/* harmony import */ var _types_loader__WEBPACK_IMPORTED_MODULE_15__ = __nested_webpack_require_117901__(/*! ../types/loader */ \"./src/types/loader.ts\");\n\n\n\n\n\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar State = {\n  STOPPED: 'STOPPED',\n  IDLE: 'IDLE',\n  KEY_LOADING: 'KEY_LOADING',\n  FRAG_LOADING: 'FRAG_LOADING',\n  FRAG_LOADING_WAITING_RETRY: 'FRAG_LOADING_WAITING_RETRY',\n  WAITING_TRACK: 'WAITING_TRACK',\n  PARSING: 'PARSING',\n  PARSED: 'PARSED',\n  BACKTRACKING: 'BACKTRACKING',\n  ENDED: 'ENDED',\n  ERROR: 'ERROR',\n  WAITING_INIT_PTS: 'WAITING_INIT_PTS',\n  WAITING_LEVEL: 'WAITING_LEVEL'\n};\n\nvar BaseStreamController = /*#__PURE__*/function (_TaskLoop) {\n  _inheritsLoose(BaseStreamController, _TaskLoop);\n\n  function BaseStreamController(hls, fragmentTracker, logPrefix) {\n    var _this;\n\n    _this = _TaskLoop.call(this) || this;\n    _this.hls = void 0;\n    _this.fragPrevious = null;\n    _this.fragCurrent = null;\n    _this.fragmentTracker = void 0;\n    _this.transmuxer = null;\n    _this._state = State.STOPPED;\n    _this.media = void 0;\n    _this.mediaBuffer = void 0;\n    _this.config = void 0;\n    _this.bitrateTest = false;\n    _this.lastCurrentTime = 0;\n    _this.nextLoadPosition = 0;\n    _this.startPosition = 0;\n    _this.loadedmetadata = false;\n    _this.fragLoadError = 0;\n    _this.retryDate = 0;\n    _this.levels = null;\n    _this.fragmentLoader = void 0;\n    _this.levelLastLoaded = null;\n    _this.startFragRequested = false;\n    _this.decrypter = void 0;\n    _this.initPTS = [];\n    _this.onvseeking = null;\n    _this.onvended = null;\n    _this.logPrefix = '';\n    _this.log = void 0;\n    _this.warn = void 0;\n    _this.logPrefix = logPrefix;\n    _this.log = _utils_logger__WEBPACK_IMPORTED_MODULE_4__[\"logger\"].log.bind(_utils_logger__WEBPACK_IMPORTED_MODULE_4__[\"logger\"], logPrefix + \":\");\n    _this.warn = _utils_logger__WEBPACK_IMPORTED_MODULE_4__[\"logger\"].warn.bind(_utils_logger__WEBPACK_IMPORTED_MODULE_4__[\"logger\"], logPrefix + \":\");\n    _this.hls = hls;\n    _this.fragmentLoader = new _loader_fragment_loader__WEBPACK_IMPORTED_MODULE_12__[\"default\"](hls.config);\n    _this.fragmentTracker = fragmentTracker;\n    _this.config = hls.config;\n    _this.decrypter = new _crypt_decrypter__WEBPACK_IMPORTED_MODULE_13__[\"default\"](hls, hls.config);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_5__[\"Events\"].KEY_LOADED, _this.onKeyLoaded, _assertThisInitialized(_this));\n    return _this;\n  }\n\n  var _proto = BaseStreamController.prototype;\n\n  _proto.doTick = function doTick() {\n    this.onTickEnd();\n  };\n\n  _proto.onTickEnd = function onTickEnd() {} // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  ;\n\n  _proto.startLoad = function startLoad(startPosition) {};\n\n  _proto.stopLoad = function stopLoad() {\n    this.fragmentLoader.abort();\n    var frag = this.fragCurrent;\n\n    if (frag) {\n      this.fragmentTracker.removeFragment(frag);\n    }\n\n    this.resetTransmuxer();\n    this.fragCurrent = null;\n    this.fragPrevious = null;\n    this.clearInterval();\n    this.clearNextTick();\n    this.state = State.STOPPED;\n  };\n\n  _proto._streamEnded = function _streamEnded(bufferInfo, levelDetails) {\n    var fragCurrent = this.fragCurrent,\n        fragmentTracker = this.fragmentTracker; // we just got done loading the final fragment and there is no other buffered range after ...\n    // rationale is that in case there are any buffered ranges after, it means that there are unbuffered portion in between\n    // so we should not switch to ENDED in that case, to be able to buffer them\n\n    if (!levelDetails.live && fragCurrent && // NOTE: Because of the way parts are currently parsed/represented in the playlist, we can end up\n    // in situations where the current fragment is actually greater than levelDetails.endSN. While\n    // this feels like the \"wrong place\" to account for that, this is a narrower/safer change than\n    // updating e.g. M3U8Parser::parseLevelPlaylist().\n    fragCurrent.sn >= levelDetails.endSN && !bufferInfo.nextStart) {\n      var partList = levelDetails.partList; // Since the last part isn't guaranteed to correspond to fragCurrent for ll-hls, check instead if the last part is buffered.\n\n      if (partList !== null && partList !== void 0 && partList.length) {\n        var lastPart = partList[partList.length - 1]; // Checking the midpoint of the part for potential margin of error and related issues.\n        // NOTE: Technically I believe parts could yield content that is < the computed duration (including potential a duration of 0)\n        // and still be spec-compliant, so there may still be edge cases here. Likewise, there could be issues in end of stream\n        // part mismatches for independent audio and video playlists/segments.\n\n        var lastPartBuffered = _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_3__[\"BufferHelper\"].isBuffered(this.media, lastPart.start + lastPart.duration / 2);\n        return lastPartBuffered;\n      }\n\n      var fragState = fragmentTracker.getState(fragCurrent);\n      return fragState === _fragment_tracker__WEBPACK_IMPORTED_MODULE_2__[\"FragmentState\"].PARTIAL || fragState === _fragment_tracker__WEBPACK_IMPORTED_MODULE_2__[\"FragmentState\"].OK;\n    }\n\n    return false;\n  };\n\n  _proto.onMediaAttached = function onMediaAttached(event, data) {\n    var media = this.media = this.mediaBuffer = data.media;\n    this.onvseeking = this.onMediaSeeking.bind(this);\n    this.onvended = this.onMediaEnded.bind(this);\n    media.addEventListener('seeking', this.onvseeking);\n    media.addEventListener('ended', this.onvended);\n    var config = this.config;\n\n    if (this.levels && config.autoStartLoad && this.state === State.STOPPED) {\n      this.startLoad(config.startPosition);\n    }\n  };\n\n  _proto.onMediaDetaching = function onMediaDetaching() {\n    var media = this.media;\n\n    if (media !== null && media !== void 0 && media.ended) {\n      this.log('MSE detaching and video ended, reset startPosition');\n      this.startPosition = this.lastCurrentTime = 0;\n    } // remove video listeners\n\n\n    if (media) {\n      media.removeEventListener('seeking', this.onvseeking);\n      media.removeEventListener('ended', this.onvended);\n      this.onvseeking = this.onvended = null;\n    }\n\n    this.media = this.mediaBuffer = null;\n    this.loadedmetadata = false;\n    this.fragmentTracker.removeAllFragments();\n    this.stopLoad();\n  };\n\n  _proto.onMediaSeeking = function onMediaSeeking() {\n    var config = this.config,\n        fragCurrent = this.fragCurrent,\n        media = this.media,\n        mediaBuffer = this.mediaBuffer,\n        state = this.state;\n    var currentTime = media ? media.currentTime : 0;\n    var bufferInfo = _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_3__[\"BufferHelper\"].bufferInfo(mediaBuffer || media, currentTime, config.maxBufferHole);\n    this.log(\"media seeking to \" + (Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__[\"isFiniteNumber\"])(currentTime) ? currentTime.toFixed(3) : currentTime) + \", state: \" + state);\n\n    if (state === State.ENDED) {\n      this.resetLoadingState();\n    } else if (fragCurrent && !bufferInfo.len) {\n      // check if we are seeking to a unbuffered area AND if frag loading is in progress\n      var tolerance = config.maxFragLookUpTolerance;\n      var fragStartOffset = fragCurrent.start - tolerance;\n      var fragEndOffset = fragCurrent.start + fragCurrent.duration + tolerance;\n      var pastFragment = currentTime > fragEndOffset; // check if the seek position is past current fragment, and if so abort loading\n\n      if (currentTime < fragStartOffset || pastFragment) {\n        if (pastFragment && fragCurrent.loader) {\n          this.log('seeking outside of buffer while fragment load in progress, cancel fragment load');\n          fragCurrent.loader.abort();\n        }\n\n        this.resetLoadingState();\n      }\n    }\n\n    if (media) {\n      this.lastCurrentTime = currentTime;\n    } // in case seeking occurs although no media buffered, adjust startPosition and nextLoadPosition to seek target\n\n\n    if (!this.loadedmetadata && !bufferInfo.len) {\n      this.nextLoadPosition = this.startPosition = currentTime;\n    } // Async tick to speed up processing\n\n\n    this.tickImmediate();\n  };\n\n  _proto.onMediaEnded = function onMediaEnded() {\n    // reset startPosition and lastCurrentTime to restart playback @ stream beginning\n    this.startPosition = this.lastCurrentTime = 0;\n  };\n\n  _proto.onKeyLoaded = function onKeyLoaded(event, data) {\n    if (this.state !== State.KEY_LOADING || data.frag !== this.fragCurrent || !this.levels) {\n      return;\n    }\n\n    this.state = State.IDLE;\n    var levelDetails = this.levels[data.frag.level].details;\n\n    if (levelDetails) {\n      this.loadFragment(data.frag, levelDetails, data.frag.start);\n    }\n  };\n\n  _proto.onHandlerDestroying = function onHandlerDestroying() {\n    this.stopLoad();\n\n    _TaskLoop.prototype.onHandlerDestroying.call(this);\n  };\n\n  _proto.onHandlerDestroyed = function onHandlerDestroyed() {\n    this.state = State.STOPPED;\n    this.hls.off(_events__WEBPACK_IMPORTED_MODULE_5__[\"Events\"].KEY_LOADED, this.onKeyLoaded, this);\n\n    if (this.fragmentLoader) {\n      this.fragmentLoader.destroy();\n    }\n\n    if (this.decrypter) {\n      this.decrypter.destroy();\n    }\n\n    this.hls = this.log = this.warn = this.decrypter = this.fragmentLoader = this.fragmentTracker = null;\n\n    _TaskLoop.prototype.onHandlerDestroyed.call(this);\n  };\n\n  _proto.loadKey = function loadKey(frag, details) {\n    this.log(\"Loading key for \" + frag.sn + \" of [\" + details.startSN + \"-\" + details.endSN + \"], \" + (this.logPrefix === '[stream-controller]' ? 'level' : 'track') + \" \" + frag.level);\n    this.state = State.KEY_LOADING;\n    this.fragCurrent = frag;\n    this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_5__[\"Events\"].KEY_LOADING, {\n      frag: frag\n    });\n  };\n\n  _proto.loadFragment = function loadFragment(frag, levelDetails, targetBufferTime) {\n    this._loadFragForPlayback(frag, levelDetails, targetBufferTime);\n  };\n\n  _proto._loadFragForPlayback = function _loadFragForPlayback(frag, levelDetails, targetBufferTime) {\n    var _this2 = this;\n\n    var progressCallback = function progressCallback(data) {\n      if (_this2.fragContextChanged(frag)) {\n        _this2.warn(\"Fragment \" + frag.sn + (data.part ? ' p: ' + data.part.index : '') + \" of level \" + frag.level + \" was dropped during download.\");\n\n        _this2.fragmentTracker.removeFragment(frag);\n\n        return;\n      }\n\n      frag.stats.chunkCount++;\n\n      _this2._handleFragmentLoadProgress(data);\n    };\n\n    this._doFragLoad(frag, levelDetails, targetBufferTime, progressCallback).then(function (data) {\n      if (!data) {\n        // if we're here we probably needed to backtrack or are waiting for more parts\n        return;\n      }\n\n      _this2.fragLoadError = 0;\n      var state = _this2.state;\n\n      if (_this2.fragContextChanged(frag)) {\n        if (state === State.FRAG_LOADING || state === State.BACKTRACKING || !_this2.fragCurrent && state === State.PARSING) {\n          _this2.fragmentTracker.removeFragment(frag);\n\n          _this2.state = State.IDLE;\n        }\n\n        return;\n      }\n\n      if ('payload' in data) {\n        _this2.log(\"Loaded fragment \" + frag.sn + \" of level \" + frag.level);\n\n        _this2.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_5__[\"Events\"].FRAG_LOADED, data); // Tracker backtrack must be called after onFragLoaded to update the fragment entity state to BACKTRACKED\n        // This happens after handleTransmuxComplete when the worker or progressive is disabled\n\n\n        if (_this2.state === State.BACKTRACKING) {\n          _this2.fragmentTracker.backtrack(frag, data);\n\n          _this2.resetFragmentLoading(frag);\n\n          return;\n        }\n      } // Pass through the whole payload; controllers not implementing progressive loading receive data from this callback\n\n\n      _this2._handleFragmentLoadComplete(data);\n    }).catch(function (reason) {\n      _this2.warn(reason);\n\n      _this2.resetFragmentLoading(frag);\n    });\n  };\n\n  _proto.flushMainBuffer = function flushMainBuffer(startOffset, endOffset, type) {\n    if (type === void 0) {\n      type = null;\n    }\n\n    if (!(startOffset - endOffset)) {\n      return;\n    } // When alternate audio is playing, the audio-stream-controller is responsible for the audio buffer. Otherwise,\n    // passing a null type flushes both buffers\n\n\n    var flushScope = {\n      startOffset: startOffset,\n      endOffset: endOffset,\n      type: type\n    }; // Reset load errors on flush\n\n    this.fragLoadError = 0;\n    this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_5__[\"Events\"].BUFFER_FLUSHING, flushScope);\n  };\n\n  _proto._loadInitSegment = function _loadInitSegment(frag) {\n    var _this3 = this;\n\n    this._doFragLoad(frag).then(function (data) {\n      if (!data || _this3.fragContextChanged(frag) || !_this3.levels) {\n        throw new Error('init load aborted');\n      }\n\n      return data;\n    }).then(function (data) {\n      var hls = _this3.hls;\n      var payload = data.payload;\n      var decryptData = frag.decryptdata; // check to see if the payload needs to be decrypted\n\n      if (payload && payload.byteLength > 0 && decryptData && decryptData.key && decryptData.iv && decryptData.method === 'AES-128') {\n        var startTime = self.performance.now(); // decrypt the subtitles\n\n        return _this3.decrypter.webCryptoDecrypt(new Uint8Array(payload), decryptData.key.buffer, decryptData.iv.buffer).then(function (decryptedData) {\n          var endTime = self.performance.now();\n          hls.trigger(_events__WEBPACK_IMPORTED_MODULE_5__[\"Events\"].FRAG_DECRYPTED, {\n            frag: frag,\n            payload: decryptedData,\n            stats: {\n              tstart: startTime,\n              tdecrypt: endTime\n            }\n          });\n          data.payload = decryptedData;\n          return data;\n        });\n      }\n\n      return data;\n    }).then(function (data) {\n      var fragCurrent = _this3.fragCurrent,\n          hls = _this3.hls,\n          levels = _this3.levels;\n\n      if (!levels) {\n        throw new Error('init load aborted, missing levels');\n      }\n\n      var details = levels[frag.level].details;\n      console.assert(details, 'Level details are defined when init segment is loaded');\n      var stats = frag.stats;\n      _this3.state = State.IDLE;\n      _this3.fragLoadError = 0;\n      frag.data = new Uint8Array(data.payload);\n      stats.parsing.start = stats.buffering.start = self.performance.now();\n      stats.parsing.end = stats.buffering.end = self.performance.now(); // Silence FRAG_BUFFERED event if fragCurrent is null\n\n      if (data.frag === fragCurrent) {\n        hls.trigger(_events__WEBPACK_IMPORTED_MODULE_5__[\"Events\"].FRAG_BUFFERED, {\n          stats: stats,\n          frag: fragCurrent,\n          part: null,\n          id: frag.type\n        });\n      }\n\n      _this3.tick();\n    }).catch(function (reason) {\n      _this3.warn(reason);\n\n      _this3.resetFragmentLoading(frag);\n    });\n  };\n\n  _proto.fragContextChanged = function fragContextChanged(frag) {\n    var fragCurrent = this.fragCurrent;\n    return !frag || !fragCurrent || frag.level !== fragCurrent.level || frag.sn !== fragCurrent.sn || frag.urlId !== fragCurrent.urlId;\n  };\n\n  _proto.fragBufferedComplete = function fragBufferedComplete(frag, part) {\n    var media = this.mediaBuffer ? this.mediaBuffer : this.media;\n    this.log(\"Buffered \" + frag.type + \" sn: \" + frag.sn + (part ? ' part: ' + part.index : '') + \" of \" + (this.logPrefix === '[stream-controller]' ? 'level' : 'track') + \" \" + frag.level + \" \" + _utils_time_ranges__WEBPACK_IMPORTED_MODULE_14__[\"default\"].toString(_utils_buffer_helper__WEBPACK_IMPORTED_MODULE_3__[\"BufferHelper\"].getBuffered(media)));\n    this.state = State.IDLE;\n    this.tick();\n  };\n\n  _proto._handleFragmentLoadComplete = function _handleFragmentLoadComplete(fragLoadedEndData) {\n    var transmuxer = this.transmuxer;\n\n    if (!transmuxer) {\n      return;\n    }\n\n    var frag = fragLoadedEndData.frag,\n        part = fragLoadedEndData.part,\n        partsLoaded = fragLoadedEndData.partsLoaded; // If we did not load parts, or loaded all parts, we have complete (not partial) fragment data\n\n    var complete = !partsLoaded || partsLoaded.length === 0 || partsLoaded.some(function (fragLoaded) {\n      return !fragLoaded;\n    });\n    var chunkMeta = new _types_transmuxer__WEBPACK_IMPORTED_MODULE_7__[\"ChunkMetadata\"](frag.level, frag.sn, frag.stats.chunkCount + 1, 0, part ? part.index : -1, !complete);\n    transmuxer.flush(chunkMeta);\n  } // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  ;\n\n  _proto._handleFragmentLoadProgress = function _handleFragmentLoadProgress(frag) {};\n\n  _proto._doFragLoad = function _doFragLoad(frag, details, targetBufferTime, progressCallback) {\n    var _this4 = this;\n\n    if (targetBufferTime === void 0) {\n      targetBufferTime = null;\n    }\n\n    if (!this.levels) {\n      throw new Error('frag load aborted, missing levels');\n    }\n\n    targetBufferTime = Math.max(frag.start, targetBufferTime || 0);\n\n    if (this.config.lowLatencyMode && details) {\n      var partList = details.partList;\n\n      if (partList && progressCallback) {\n        if (targetBufferTime > frag.end && details.fragmentHint) {\n          frag = details.fragmentHint;\n        }\n\n        var partIndex = this.getNextPart(partList, frag, targetBufferTime);\n\n        if (partIndex > -1) {\n          var part = partList[partIndex];\n          this.log(\"Loading part sn: \" + frag.sn + \" p: \" + part.index + \" cc: \" + frag.cc + \" of playlist [\" + details.startSN + \"-\" + details.endSN + \"] parts [0-\" + partIndex + \"-\" + (partList.length - 1) + \"] \" + (this.logPrefix === '[stream-controller]' ? 'level' : 'track') + \": \" + frag.level + \", target: \" + parseFloat(targetBufferTime.toFixed(3)));\n          this.nextLoadPosition = part.start + part.duration;\n          this.state = State.FRAG_LOADING;\n          this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_5__[\"Events\"].FRAG_LOADING, {\n            frag: frag,\n            part: partList[partIndex],\n            targetBufferTime: targetBufferTime\n          });\n          return this.doFragPartsLoad(frag, partList, partIndex, progressCallback).catch(function (error) {\n            return _this4.handleFragLoadError(error);\n          });\n        } else if (!frag.url || this.loadedEndOfParts(partList, targetBufferTime)) {\n          // Fragment hint has no parts\n          return Promise.resolve(null);\n        }\n      }\n    }\n\n    this.log(\"Loading fragment \" + frag.sn + \" cc: \" + frag.cc + \" \" + (details ? 'of [' + details.startSN + '-' + details.endSN + '] ' : '') + (this.logPrefix === '[stream-controller]' ? 'level' : 'track') + \": \" + frag.level + \", target: \" + parseFloat(targetBufferTime.toFixed(3))); // Don't update nextLoadPosition for fragments which are not buffered\n\n    if (Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__[\"isFiniteNumber\"])(frag.sn) && !this.bitrateTest) {\n      this.nextLoadPosition = frag.start + frag.duration;\n    }\n\n    this.state = State.FRAG_LOADING;\n    this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_5__[\"Events\"].FRAG_LOADING, {\n      frag: frag,\n      targetBufferTime: targetBufferTime\n    });\n    return this.fragmentLoader.load(frag, progressCallback).catch(function (error) {\n      return _this4.handleFragLoadError(error);\n    });\n  };\n\n  _proto.doFragPartsLoad = function doFragPartsLoad(frag, partList, partIndex, progressCallback) {\n    var _this5 = this;\n\n    return new Promise(function (resolve, reject) {\n      var partsLoaded = [];\n\n      var loadPartIndex = function loadPartIndex(index) {\n        var part = partList[index];\n\n        _this5.fragmentLoader.loadPart(frag, part, progressCallback).then(function (partLoadedData) {\n          partsLoaded[part.index] = partLoadedData;\n          var loadedPart = partLoadedData.part;\n\n          _this5.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_5__[\"Events\"].FRAG_LOADED, partLoadedData);\n\n          var nextPart = partList[index + 1];\n\n          if (nextPart && nextPart.fragment === frag) {\n            loadPartIndex(index + 1);\n          } else {\n            return resolve({\n              frag: frag,\n              part: loadedPart,\n              partsLoaded: partsLoaded\n            });\n          }\n        }).catch(reject);\n      };\n\n      loadPartIndex(partIndex);\n    });\n  };\n\n  _proto.handleFragLoadError = function handleFragLoadError(_ref) {\n    var data = _ref.data;\n\n    if (data && data.details === _errors__WEBPACK_IMPORTED_MODULE_6__[\"ErrorDetails\"].INTERNAL_ABORTED) {\n      this.handleFragLoadAborted(data.frag, data.part);\n    } else {\n      this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_5__[\"Events\"].ERROR, data);\n    }\n\n    return null;\n  };\n\n  _proto._handleTransmuxerFlush = function _handleTransmuxerFlush(chunkMeta) {\n    var context = this.getCurrentContext(chunkMeta);\n\n    if (!context || this.state !== State.PARSING) {\n      if (!this.fragCurrent) {\n        this.state = State.IDLE;\n      }\n\n      return;\n    }\n\n    var frag = context.frag,\n        part = context.part,\n        level = context.level;\n    var now = self.performance.now();\n    frag.stats.parsing.end = now;\n\n    if (part) {\n      part.stats.parsing.end = now;\n    }\n\n    this.updateLevelTiming(frag, part, level, chunkMeta.partial);\n  };\n\n  _proto.getCurrentContext = function getCurrentContext(chunkMeta) {\n    var levels = this.levels;\n    var levelIndex = chunkMeta.level,\n        sn = chunkMeta.sn,\n        partIndex = chunkMeta.part;\n\n    if (!levels || !levels[levelIndex]) {\n      this.warn(\"Levels object was unset while buffering fragment \" + sn + \" of level \" + levelIndex + \". The current chunk will not be buffered.\");\n      return null;\n    }\n\n    var level = levels[levelIndex];\n    var part = partIndex > -1 ? Object(_level_helper__WEBPACK_IMPORTED_MODULE_11__[\"getPartWith\"])(level, sn, partIndex) : null;\n    var frag = part ? part.fragment : Object(_level_helper__WEBPACK_IMPORTED_MODULE_11__[\"getFragmentWithSN\"])(level, sn, this.fragCurrent);\n\n    if (!frag) {\n      return null;\n    }\n\n    return {\n      frag: frag,\n      part: part,\n      level: level\n    };\n  };\n\n  _proto.bufferFragmentData = function bufferFragmentData(data, frag, part, chunkMeta) {\n    if (!data || this.state !== State.PARSING) {\n      return;\n    }\n\n    var data1 = data.data1,\n        data2 = data.data2;\n    var buffer = data1;\n\n    if (data1 && data2) {\n      // Combine the moof + mdat so that we buffer with a single append\n      buffer = Object(_utils_mp4_tools__WEBPACK_IMPORTED_MODULE_8__[\"appendUint8Array\"])(data1, data2);\n    }\n\n    if (!buffer || !buffer.length) {\n      return;\n    }\n\n    var segment = {\n      type: data.type,\n      frag: frag,\n      part: part,\n      chunkMeta: chunkMeta,\n      parent: frag.type,\n      data: buffer\n    };\n    this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_5__[\"Events\"].BUFFER_APPENDING, segment);\n\n    if (data.dropped && data.independent && !part) {\n      // Clear buffer so that we reload previous segments sequentially if required\n      this.flushBufferGap(frag);\n    }\n  };\n\n  _proto.flushBufferGap = function flushBufferGap(frag) {\n    var media = this.media;\n\n    if (!media) {\n      return;\n    } // If currentTime is not buffered, clear the back buffer so that we can backtrack as much as needed\n\n\n    if (!_utils_buffer_helper__WEBPACK_IMPORTED_MODULE_3__[\"BufferHelper\"].isBuffered(media, media.currentTime)) {\n      this.flushMainBuffer(0, frag.start);\n      return;\n    } // Remove back-buffer without interrupting playback to allow back tracking\n\n\n    var currentTime = media.currentTime;\n    var bufferInfo = _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_3__[\"BufferHelper\"].bufferInfo(media, currentTime, 0);\n    var fragDuration = frag.duration;\n    var segmentFraction = Math.min(this.config.maxFragLookUpTolerance * 2, fragDuration * 0.25);\n    var start = Math.max(Math.min(frag.start - segmentFraction, bufferInfo.end - segmentFraction), currentTime + segmentFraction);\n\n    if (frag.start - start > segmentFraction) {\n      this.flushMainBuffer(start, frag.start);\n    }\n  };\n\n  _proto.getFwdBufferInfo = function getFwdBufferInfo(bufferable, type) {\n    var config = this.config;\n    var pos = this.getLoadPosition();\n\n    if (!Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__[\"isFiniteNumber\"])(pos)) {\n      return null;\n    }\n\n    var bufferInfo = _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_3__[\"BufferHelper\"].bufferInfo(bufferable, pos, config.maxBufferHole); // Workaround flaw in getting forward buffer when maxBufferHole is smaller than gap at current pos\n\n    if (bufferInfo.len === 0 && bufferInfo.nextStart !== undefined) {\n      var bufferedFragAtPos = this.fragmentTracker.getBufferedFrag(pos, type);\n\n      if (bufferedFragAtPos && bufferInfo.nextStart < bufferedFragAtPos.end) {\n        return _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_3__[\"BufferHelper\"].bufferInfo(bufferable, pos, Math.max(bufferInfo.nextStart, config.maxBufferHole));\n      }\n    }\n\n    return bufferInfo;\n  };\n\n  _proto.getMaxBufferLength = function getMaxBufferLength(levelBitrate) {\n    var config = this.config;\n    var maxBufLen;\n\n    if (levelBitrate) {\n      maxBufLen = Math.max(8 * config.maxBufferSize / levelBitrate, config.maxBufferLength);\n    } else {\n      maxBufLen = config.maxBufferLength;\n    }\n\n    return Math.min(maxBufLen, config.maxMaxBufferLength);\n  };\n\n  _proto.reduceMaxBufferLength = function reduceMaxBufferLength(threshold) {\n    var config = this.config;\n    var minLength = threshold || config.maxBufferLength;\n\n    if (config.maxMaxBufferLength >= minLength) {\n      // reduce max buffer length as it might be too high. we do this to avoid loop flushing ...\n      config.maxMaxBufferLength /= 2;\n      this.warn(\"Reduce max buffer length to \" + config.maxMaxBufferLength + \"s\");\n      return true;\n    }\n\n    return false;\n  };\n\n  _proto.getNextFragment = function getNextFragment(pos, levelDetails) {\n    var _frag, _frag2;\n\n    var fragments = levelDetails.fragments;\n    var fragLen = fragments.length;\n\n    if (!fragLen) {\n      return null;\n    } // find fragment index, contiguous with end of buffer position\n\n\n    var config = this.config;\n    var start = fragments[0].start;\n    var frag;\n\n    if (levelDetails.live) {\n      var initialLiveManifestSize = config.initialLiveManifestSize;\n\n      if (fragLen < initialLiveManifestSize) {\n        this.warn(\"Not enough fragments to start playback (have: \" + fragLen + \", need: \" + initialLiveManifestSize + \")\");\n        return null;\n      } // The real fragment start times for a live stream are only known after the PTS range for that level is known.\n      // In order to discover the range, we load the best matching fragment for that level and demux it.\n      // Do not load using live logic if the starting frag is requested - we want to use getFragmentAtPosition() so that\n      // we get the fragment matching that start time\n\n\n      if (!levelDetails.PTSKnown && !this.startFragRequested && this.startPosition === -1) {\n        frag = this.getInitialLiveFragment(levelDetails, fragments);\n        this.startPosition = frag ? this.hls.liveSyncPosition || frag.start : pos;\n      }\n    } else if (pos <= start) {\n      // VoD playlist: if loadPosition before start of playlist, load first fragment\n      frag = fragments[0];\n    } // If we haven't run into any special cases already, just load the fragment most closely matching the requested position\n\n\n    if (!frag) {\n      var end = config.lowLatencyMode ? levelDetails.partEnd : levelDetails.fragmentEnd;\n      frag = this.getFragmentAtPosition(pos, end, levelDetails);\n    } // If an initSegment is present, it must be buffered first\n\n\n    if ((_frag = frag) !== null && _frag !== void 0 && _frag.initSegment && !((_frag2 = frag) !== null && _frag2 !== void 0 && _frag2.initSegment.data) && !this.bitrateTest) {\n      frag = frag.initSegment;\n    }\n\n    return frag;\n  };\n\n  _proto.getNextPart = function getNextPart(partList, frag, targetBufferTime) {\n    var nextPart = -1;\n    var contiguous = false;\n    var independentAttrOmitted = true;\n\n    for (var i = 0, len = partList.length; i < len; i++) {\n      var part = partList[i];\n      independentAttrOmitted = independentAttrOmitted && !part.independent;\n\n      if (nextPart > -1 && targetBufferTime < part.start) {\n        break;\n      }\n\n      var loaded = part.loaded;\n\n      if (!loaded && (contiguous || part.independent || independentAttrOmitted) && part.fragment === frag) {\n        nextPart = i;\n      }\n\n      contiguous = loaded;\n    }\n\n    return nextPart;\n  };\n\n  _proto.loadedEndOfParts = function loadedEndOfParts(partList, targetBufferTime) {\n    var lastPart = partList[partList.length - 1];\n    return lastPart && targetBufferTime > lastPart.start && lastPart.loaded;\n  }\n  /*\n   This method is used find the best matching first fragment for a live playlist. This fragment is used to calculate the\n   \"sliding\" of the playlist, which is its offset from the start of playback. After sliding we can compute the real\n   start and end times for each fragment in the playlist (after which this method will not need to be called).\n  */\n  ;\n\n  _proto.getInitialLiveFragment = function getInitialLiveFragment(levelDetails, fragments) {\n    var fragPrevious = this.fragPrevious;\n    var frag = null;\n\n    if (fragPrevious) {\n      if (levelDetails.hasProgramDateTime) {\n        // Prefer using PDT, because it can be accurate enough to choose the correct fragment without knowing the level sliding\n        this.log(\"Live playlist, switching playlist, load frag with same PDT: \" + fragPrevious.programDateTime);\n        frag = Object(_fragment_finders__WEBPACK_IMPORTED_MODULE_10__[\"findFragmentByPDT\"])(fragments, fragPrevious.endProgramDateTime, this.config.maxFragLookUpTolerance);\n      }\n\n      if (!frag) {\n        // SN does not need to be accurate between renditions, but depending on the packaging it may be so.\n        var targetSN = fragPrevious.sn + 1;\n\n        if (targetSN >= levelDetails.startSN && targetSN <= levelDetails.endSN) {\n          var fragNext = fragments[targetSN - levelDetails.startSN]; // Ensure that we're staying within the continuity range, since PTS resets upon a new range\n\n          if (fragPrevious.cc === fragNext.cc) {\n            frag = fragNext;\n            this.log(\"Live playlist, switching playlist, load frag with next SN: \" + frag.sn);\n          }\n        } // It's important to stay within the continuity range if available; otherwise the fragments in the playlist\n        // will have the wrong start times\n\n\n        if (!frag) {\n          frag = Object(_fragment_finders__WEBPACK_IMPORTED_MODULE_10__[\"findFragWithCC\"])(fragments, fragPrevious.cc);\n\n          if (frag) {\n            this.log(\"Live playlist, switching playlist, load frag with same CC: \" + frag.sn);\n          }\n        }\n      }\n    } else {\n      // Find a new start fragment when fragPrevious is null\n      var liveStart = this.hls.liveSyncPosition;\n\n      if (liveStart !== null) {\n        frag = this.getFragmentAtPosition(liveStart, this.bitrateTest ? levelDetails.fragmentEnd : levelDetails.edge, levelDetails);\n      }\n    }\n\n    return frag;\n  }\n  /*\n  This method finds the best matching fragment given the provided position.\n   */\n  ;\n\n  _proto.getFragmentAtPosition = function getFragmentAtPosition(bufferEnd, end, levelDetails) {\n    var config = this.config,\n        fragPrevious = this.fragPrevious;\n    var fragments = levelDetails.fragments,\n        endSN = levelDetails.endSN;\n    var fragmentHint = levelDetails.fragmentHint;\n    var tolerance = config.maxFragLookUpTolerance;\n    var loadingParts = !!(config.lowLatencyMode && levelDetails.partList && fragmentHint);\n\n    if (loadingParts && fragmentHint && !this.bitrateTest) {\n      // Include incomplete fragment with parts at end\n      fragments = fragments.concat(fragmentHint);\n      endSN = fragmentHint.sn;\n    }\n\n    var frag;\n\n    if (bufferEnd < end) {\n      var lookupTolerance = bufferEnd > end - tolerance ? 0 : tolerance; // Remove the tolerance if it would put the bufferEnd past the actual end of stream\n      // Uses buffer and sequence number to calculate switch segment (required if using EXT-X-DISCONTINUITY-SEQUENCE)\n\n      frag = Object(_fragment_finders__WEBPACK_IMPORTED_MODULE_10__[\"findFragmentByPTS\"])(fragPrevious, fragments, bufferEnd, lookupTolerance);\n    } else {\n      // reach end of playlist\n      frag = fragments[fragments.length - 1];\n    }\n\n    if (frag) {\n      var curSNIdx = frag.sn - levelDetails.startSN;\n      var sameLevel = fragPrevious && frag.level === fragPrevious.level;\n      var nextFrag = fragments[curSNIdx + 1];\n      var fragState = this.fragmentTracker.getState(frag);\n\n      if (fragState === _fragment_tracker__WEBPACK_IMPORTED_MODULE_2__[\"FragmentState\"].BACKTRACKED) {\n        frag = null;\n        var i = curSNIdx;\n\n        while (fragments[i] && this.fragmentTracker.getState(fragments[i]) === _fragment_tracker__WEBPACK_IMPORTED_MODULE_2__[\"FragmentState\"].BACKTRACKED) {\n          // When fragPrevious is null, backtrack to first the first fragment is not BACKTRACKED for loading\n          // When fragPrevious is set, we want the first BACKTRACKED fragment for parsing and buffering\n          if (!fragPrevious) {\n            frag = fragments[--i];\n          } else {\n            frag = fragments[i--];\n          }\n        }\n\n        if (!frag) {\n          frag = nextFrag;\n        }\n      } else if (fragPrevious && frag.sn === fragPrevious.sn && !loadingParts) {\n        // Force the next fragment to load if the previous one was already selected. This can occasionally happen with\n        // non-uniform fragment durations\n        if (sameLevel) {\n          if (frag.sn < endSN && this.fragmentTracker.getState(nextFrag) !== _fragment_tracker__WEBPACK_IMPORTED_MODULE_2__[\"FragmentState\"].OK) {\n            this.log(\"SN \" + frag.sn + \" just loaded, load next one: \" + nextFrag.sn);\n            frag = nextFrag;\n          } else {\n            frag = null;\n          }\n        }\n      }\n    }\n\n    return frag;\n  };\n\n  _proto.synchronizeToLiveEdge = function synchronizeToLiveEdge(levelDetails) {\n    var config = this.config,\n        media = this.media;\n\n    if (!media) {\n      return;\n    }\n\n    var liveSyncPosition = this.hls.liveSyncPosition;\n    var currentTime = media.currentTime;\n    var start = levelDetails.fragments[0].start;\n    var end = levelDetails.edge;\n    var withinSlidingWindow = currentTime >= start - config.maxFragLookUpTolerance && currentTime <= end; // Continue if we can seek forward to sync position or if current time is outside of sliding window\n\n    if (liveSyncPosition !== null && media.duration > liveSyncPosition && (currentTime < liveSyncPosition || !withinSlidingWindow)) {\n      // Continue if buffer is starving or if current time is behind max latency\n      var maxLatency = config.liveMaxLatencyDuration !== undefined ? config.liveMaxLatencyDuration : config.liveMaxLatencyDurationCount * levelDetails.targetduration;\n\n      if (!withinSlidingWindow && media.readyState < 4 || currentTime < end - maxLatency) {\n        if (!this.loadedmetadata) {\n          this.nextLoadPosition = liveSyncPosition;\n        } // Only seek if ready and there is not a significant forward buffer available for playback\n\n\n        if (media.readyState) {\n          this.warn(\"Playback: \" + currentTime.toFixed(3) + \" is located too far from the end of live sliding playlist: \" + end + \", reset currentTime to : \" + liveSyncPosition.toFixed(3));\n          media.currentTime = liveSyncPosition;\n        }\n      }\n    }\n  };\n\n  _proto.alignPlaylists = function alignPlaylists(details, previousDetails) {\n    var levels = this.levels,\n        levelLastLoaded = this.levelLastLoaded,\n        fragPrevious = this.fragPrevious;\n    var lastLevel = levelLastLoaded !== null ? levels[levelLastLoaded] : null; // FIXME: If not for `shouldAlignOnDiscontinuities` requiring fragPrevious.cc,\n    //  this could all go in level-helper mergeDetails()\n\n    var length = details.fragments.length;\n\n    if (!length) {\n      this.warn(\"No fragments in live playlist\");\n      return 0;\n    }\n\n    var slidingStart = details.fragments[0].start;\n    var firstLevelLoad = !previousDetails;\n\n    var aligned = details.alignedSliding && Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__[\"isFiniteNumber\"])(slidingStart);\n\n    if (firstLevelLoad || !aligned && !slidingStart) {\n      Object(_utils_discontinuities__WEBPACK_IMPORTED_MODULE_9__[\"alignStream\"])(fragPrevious, lastLevel, details);\n      var alignedSlidingStart = details.fragments[0].start;\n      this.log(\"Live playlist sliding: \" + alignedSlidingStart.toFixed(2) + \" start-sn: \" + (previousDetails ? previousDetails.startSN : 'na') + \"->\" + details.startSN + \" prev-sn: \" + (fragPrevious ? fragPrevious.sn : 'na') + \" fragments: \" + length);\n      return alignedSlidingStart;\n    }\n\n    return slidingStart;\n  };\n\n  _proto.waitForCdnTuneIn = function waitForCdnTuneIn(details) {\n    // Wait for Low-Latency CDN Tune-in to get an updated playlist\n    var advancePartLimit = 3;\n    return details.live && details.canBlockReload && details.tuneInGoal > Math.max(details.partHoldBack, details.partTarget * advancePartLimit);\n  };\n\n  _proto.setStartPosition = function setStartPosition(details, sliding) {\n    // compute start position if set to -1. use it straight away if value is defined\n    var startPosition = this.startPosition;\n\n    if (startPosition < sliding) {\n      startPosition = -1;\n    }\n\n    if (startPosition === -1 || this.lastCurrentTime === -1) {\n      // first, check if start time offset has been set in playlist, if yes, use this value\n      var startTimeOffset = details.startTimeOffset;\n\n      if (Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__[\"isFiniteNumber\"])(startTimeOffset)) {\n        startPosition = sliding + startTimeOffset;\n\n        if (startTimeOffset < 0) {\n          startPosition += details.totalduration;\n        }\n\n        startPosition = Math.min(Math.max(sliding, startPosition), sliding + details.totalduration);\n        this.log(\"Start time offset \" + startTimeOffset + \" found in playlist, adjust startPosition to \" + startPosition);\n        this.startPosition = startPosition;\n      } else if (details.live) {\n        // Leave this.startPosition at -1, so that we can use `getInitialLiveFragment` logic when startPosition has\n        // not been specified via the config or an as an argument to startLoad (#3736).\n        startPosition = this.hls.liveSyncPosition || sliding;\n      } else {\n        this.startPosition = startPosition = 0;\n      }\n\n      this.lastCurrentTime = startPosition;\n    }\n\n    this.nextLoadPosition = startPosition;\n  };\n\n  _proto.getLoadPosition = function getLoadPosition() {\n    var media = this.media; // if we have not yet loaded any fragment, start loading from start position\n\n    var pos = 0;\n\n    if (this.loadedmetadata && media) {\n      pos = media.currentTime;\n    } else if (this.nextLoadPosition) {\n      pos = this.nextLoadPosition;\n    }\n\n    return pos;\n  };\n\n  _proto.handleFragLoadAborted = function handleFragLoadAborted(frag, part) {\n    if (this.transmuxer && frag.sn !== 'initSegment' && frag.stats.aborted) {\n      this.warn(\"Fragment \" + frag.sn + (part ? ' part' + part.index : '') + \" of level \" + frag.level + \" was aborted\");\n      this.resetFragmentLoading(frag);\n    }\n  };\n\n  _proto.resetFragmentLoading = function resetFragmentLoading(frag) {\n    if (!this.fragCurrent || !this.fragContextChanged(frag)) {\n      this.state = State.IDLE;\n    }\n  };\n\n  _proto.onFragmentOrKeyLoadError = function onFragmentOrKeyLoadError(filterType, data) {\n    if (data.fatal) {\n      return;\n    }\n\n    var frag = data.frag; // Handle frag error related to caller's filterType\n\n    if (!frag || frag.type !== filterType) {\n      return;\n    }\n\n    var fragCurrent = this.fragCurrent;\n    console.assert(fragCurrent && frag.sn === fragCurrent.sn && frag.level === fragCurrent.level && frag.urlId === fragCurrent.urlId, 'Frag load error must match current frag to retry');\n    var config = this.config; // keep retrying until the limit will be reached\n\n    if (this.fragLoadError + 1 <= config.fragLoadingMaxRetry) {\n      if (this.resetLiveStartWhenNotLoaded(frag.level)) {\n        return;\n      } // exponential backoff capped to config.fragLoadingMaxRetryTimeout\n\n\n      var delay = Math.min(Math.pow(2, this.fragLoadError) * config.fragLoadingRetryDelay, config.fragLoadingMaxRetryTimeout);\n      this.warn(\"Fragment \" + frag.sn + \" of \" + filterType + \" \" + frag.level + \" failed to load, retrying in \" + delay + \"ms\");\n      this.retryDate = self.performance.now() + delay;\n      this.fragLoadError++;\n      this.state = State.FRAG_LOADING_WAITING_RETRY;\n    } else if (data.levelRetry) {\n      if (filterType === _types_loader__WEBPACK_IMPORTED_MODULE_15__[\"PlaylistLevelType\"].AUDIO) {\n        // Reset current fragment since audio track audio is essential and may not have a fail-over track\n        this.fragCurrent = null;\n      } // Fragment errors that result in a level switch or redundant fail-over\n      // should reset the stream controller state to idle\n\n\n      this.fragLoadError = 0;\n      this.state = State.IDLE;\n    } else {\n      _utils_logger__WEBPACK_IMPORTED_MODULE_4__[\"logger\"].error(data.details + \" reaches max retry, redispatch as fatal ...\"); // switch error to fatal\n\n      data.fatal = true;\n      this.hls.stopLoad();\n      this.state = State.ERROR;\n    }\n  };\n\n  _proto.afterBufferFlushed = function afterBufferFlushed(media, bufferType, playlistType) {\n    if (!media) {\n      return;\n    } // After successful buffer flushing, filter flushed fragments from bufferedFrags use mediaBuffered instead of media\n    // (so that we will check against video.buffered ranges in case of alt audio track)\n\n\n    var bufferedTimeRanges = _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_3__[\"BufferHelper\"].getBuffered(media);\n    this.fragmentTracker.detectEvictedFragments(bufferType, bufferedTimeRanges, playlistType);\n\n    if (this.state === State.ENDED) {\n      this.resetLoadingState();\n    }\n  };\n\n  _proto.resetLoadingState = function resetLoadingState() {\n    this.fragCurrent = null;\n    this.fragPrevious = null;\n    this.state = State.IDLE;\n  };\n\n  _proto.resetLiveStartWhenNotLoaded = function resetLiveStartWhenNotLoaded(level) {\n    // if loadedmetadata is not set, it means that we are emergency switch down on first frag\n    // in that case, reset startFragRequested flag\n    if (!this.loadedmetadata) {\n      this.startFragRequested = false;\n      var details = this.levels ? this.levels[level].details : null;\n\n      if (details !== null && details !== void 0 && details.live) {\n        // We can't afford to retry after a delay in a live scenario. Update the start position and return to IDLE.\n        this.startPosition = -1;\n        this.setStartPosition(details, 0);\n        this.resetLoadingState();\n        return true;\n      }\n\n      this.nextLoadPosition = this.startPosition;\n    }\n\n    return false;\n  };\n\n  _proto.updateLevelTiming = function updateLevelTiming(frag, part, level, partial) {\n    var _this6 = this;\n\n    var details = level.details;\n    console.assert(!!details, 'level.details must be defined');\n    var parsed = Object.keys(frag.elementaryStreams).reduce(function (result, type) {\n      var info = frag.elementaryStreams[type];\n\n      if (info) {\n        var parsedDuration = info.endPTS - info.startPTS;\n\n        if (parsedDuration <= 0) {\n          // Destroy the transmuxer after it's next time offset failed to advance because duration was <= 0.\n          // The new transmuxer will be configured with a time offset matching the next fragment start,\n          // preventing the timeline from shifting.\n          _this6.warn(\"Could not parse fragment \" + frag.sn + \" \" + type + \" duration reliably (\" + parsedDuration + \") resetting transmuxer to fallback to playlist timing\");\n\n          _this6.resetTransmuxer();\n\n          return result || false;\n        }\n\n        var drift = partial ? 0 : Object(_level_helper__WEBPACK_IMPORTED_MODULE_11__[\"updateFragPTSDTS\"])(details, frag, info.startPTS, info.endPTS, info.startDTS, info.endDTS);\n\n        _this6.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_5__[\"Events\"].LEVEL_PTS_UPDATED, {\n          details: details,\n          level: level,\n          drift: drift,\n          type: type,\n          frag: frag,\n          start: info.startPTS,\n          end: info.endPTS\n        });\n\n        return true;\n      }\n\n      return result;\n    }, false);\n\n    if (parsed) {\n      this.state = State.PARSED;\n      this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_5__[\"Events\"].FRAG_PARSED, {\n        frag: frag,\n        part: part\n      });\n    } else {\n      this.resetLoadingState();\n    }\n  };\n\n  _proto.resetTransmuxer = function resetTransmuxer() {\n    if (this.transmuxer) {\n      this.transmuxer.destroy();\n      this.transmuxer = null;\n    }\n  };\n\n  _createClass(BaseStreamController, [{\n    key: \"state\",\n    get: function get() {\n      return this._state;\n    },\n    set: function set(nextState) {\n      var previousState = this._state;\n\n      if (previousState !== nextState) {\n        this._state = nextState;\n        this.log(previousState + \"->\" + nextState);\n      }\n    }\n  }]);\n\n  return BaseStreamController;\n}(_task_loop__WEBPACK_IMPORTED_MODULE_1__[\"default\"]);\n\n\n\n/***/ }),\n\n/***/ \"./src/controller/buffer-controller.ts\":\n/*!*********************************************!*\\\n  !*** ./src/controller/buffer-controller.ts ***!\n  \\*********************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_167429__) {\n\n\"use strict\";\n__nested_webpack_require_167429__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_167429__.d(__webpack_exports__, \"default\", function() { return BufferController; });\n/* harmony import */ var _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_167429__(/*! ./src/polyfills/number */ \"./src/polyfills/number.ts\");\n/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_167429__(/*! ../events */ \"./src/events.ts\");\n/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_167429__(/*! ../utils/logger */ \"./src/utils/logger.ts\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_167429__(/*! ../errors */ \"./src/errors.ts\");\n/* harmony import */ var _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_167429__(/*! ../utils/buffer-helper */ \"./src/utils/buffer-helper.ts\");\n/* harmony import */ var _utils_mediasource_helper__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_167429__(/*! ../utils/mediasource-helper */ \"./src/utils/mediasource-helper.ts\");\n/* harmony import */ var _loader_fragment__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_167429__(/*! ../loader/fragment */ \"./src/loader/fragment.ts\");\n/* harmony import */ var _buffer_operation_queue__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_167429__(/*! ./buffer-operation-queue */ \"./src/controller/buffer-operation-queue.ts\");\n\n\n\n\n\n\n\n\n\n\n\n\nvar MediaSource = Object(_utils_mediasource_helper__WEBPACK_IMPORTED_MODULE_5__[\"getMediaSource\"])();\nvar VIDEO_CODEC_PROFILE_REPACE = /([ha]vc.)(?:\\.[^.,]+)+/;\n\nvar BufferController = /*#__PURE__*/function () {\n  // The level details used to determine duration, target-duration and live\n  // cache the self generated object url to detect hijack of video tag\n  // A queue of buffer operations which require the SourceBuffer to not be updating upon execution\n  // References to event listeners for each SourceBuffer, so that they can be referenced for event removal\n  // The number of BUFFER_CODEC events received before any sourceBuffers are created\n  // The total number of BUFFER_CODEC events received\n  // A reference to the attached media element\n  // A reference to the active media source\n  // counters\n  function BufferController(_hls) {\n    var _this = this;\n\n    this.details = null;\n    this._objectUrl = null;\n    this.operationQueue = void 0;\n    this.listeners = void 0;\n    this.hls = void 0;\n    this.bufferCodecEventsExpected = 0;\n    this._bufferCodecEventsTotal = 0;\n    this.media = null;\n    this.mediaSource = null;\n    this.appendError = 0;\n    this.tracks = {};\n    this.pendingTracks = {};\n    this.sourceBuffer = void 0;\n\n    this._onMediaSourceOpen = function () {\n      var hls = _this.hls,\n          media = _this.media,\n          mediaSource = _this.mediaSource;\n      _utils_logger__WEBPACK_IMPORTED_MODULE_2__[\"logger\"].log('[buffer-controller]: Media source opened');\n\n      if (media) {\n        _this.updateMediaElementDuration();\n\n        hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].MEDIA_ATTACHED, {\n          media: media\n        });\n      }\n\n      if (mediaSource) {\n        // once received, don't listen anymore to sourceopen event\n        mediaSource.removeEventListener('sourceopen', _this._onMediaSourceOpen);\n      }\n\n      _this.checkPendingTracks();\n    };\n\n    this._onMediaSourceClose = function () {\n      _utils_logger__WEBPACK_IMPORTED_MODULE_2__[\"logger\"].log('[buffer-controller]: Media source closed');\n    };\n\n    this._onMediaSourceEnded = function () {\n      _utils_logger__WEBPACK_IMPORTED_MODULE_2__[\"logger\"].log('[buffer-controller]: Media source ended');\n    };\n\n    this.hls = _hls;\n\n    this._initSourceBuffer();\n\n    this.registerListeners();\n  }\n\n  var _proto = BufferController.prototype;\n\n  _proto.hasSourceTypes = function hasSourceTypes() {\n    return this.getSourceBufferTypes().length > 0 || Object.keys(this.pendingTracks).length > 0;\n  };\n\n  _proto.destroy = function destroy() {\n    this.unregisterListeners();\n    this.details = null;\n  };\n\n  _proto.registerListeners = function registerListeners() {\n    var hls = this.hls;\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].MEDIA_ATTACHING, this.onMediaAttaching, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].MEDIA_DETACHING, this.onMediaDetaching, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].MANIFEST_PARSED, this.onManifestParsed, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].BUFFER_RESET, this.onBufferReset, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].BUFFER_APPENDING, this.onBufferAppending, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].BUFFER_CODECS, this.onBufferCodecs, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].BUFFER_EOS, this.onBufferEos, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].BUFFER_FLUSHING, this.onBufferFlushing, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].LEVEL_UPDATED, this.onLevelUpdated, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].FRAG_PARSED, this.onFragParsed, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].FRAG_CHANGED, this.onFragChanged, this);\n  };\n\n  _proto.unregisterListeners = function unregisterListeners() {\n    var hls = this.hls;\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].MEDIA_ATTACHING, this.onMediaAttaching, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].MEDIA_DETACHING, this.onMediaDetaching, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].MANIFEST_PARSED, this.onManifestParsed, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].BUFFER_RESET, this.onBufferReset, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].BUFFER_APPENDING, this.onBufferAppending, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].BUFFER_CODECS, this.onBufferCodecs, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].BUFFER_EOS, this.onBufferEos, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].BUFFER_FLUSHING, this.onBufferFlushing, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].LEVEL_UPDATED, this.onLevelUpdated, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].FRAG_PARSED, this.onFragParsed, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].FRAG_CHANGED, this.onFragChanged, this);\n  };\n\n  _proto._initSourceBuffer = function _initSourceBuffer() {\n    this.sourceBuffer = {};\n    this.operationQueue = new _buffer_operation_queue__WEBPACK_IMPORTED_MODULE_7__[\"default\"](this.sourceBuffer);\n    this.listeners = {\n      audio: [],\n      video: [],\n      audiovideo: []\n    };\n  };\n\n  _proto.onManifestParsed = function onManifestParsed(event, data) {\n    // in case of alt audio 2 BUFFER_CODECS events will be triggered, one per stream controller\n    // sourcebuffers will be created all at once when the expected nb of tracks will be reached\n    // in case alt audio is not used, only one BUFFER_CODEC event will be fired from main stream controller\n    // it will contain the expected nb of source buffers, no need to compute it\n    var codecEvents = 2;\n\n    if (data.audio && !data.video || !data.altAudio) {\n      codecEvents = 1;\n    }\n\n    this.bufferCodecEventsExpected = this._bufferCodecEventsTotal = codecEvents;\n    this.details = null;\n    _utils_logger__WEBPACK_IMPORTED_MODULE_2__[\"logger\"].log(this.bufferCodecEventsExpected + \" bufferCodec event(s) expected\");\n  };\n\n  _proto.onMediaAttaching = function onMediaAttaching(event, data) {\n    var media = this.media = data.media;\n\n    if (media && MediaSource) {\n      var ms = this.mediaSource = new MediaSource(); // MediaSource listeners are arrow functions with a lexical scope, and do not need to be bound\n\n      ms.addEventListener('sourceopen', this._onMediaSourceOpen);\n      ms.addEventListener('sourceended', this._onMediaSourceEnded);\n      ms.addEventListener('sourceclose', this._onMediaSourceClose); // link video and media Source\n\n      media.src = self.URL.createObjectURL(ms); // cache the locally generated object url\n\n      this._objectUrl = media.src;\n    }\n  };\n\n  _proto.onMediaDetaching = function onMediaDetaching() {\n    var media = this.media,\n        mediaSource = this.mediaSource,\n        _objectUrl = this._objectUrl;\n\n    if (mediaSource) {\n      _utils_logger__WEBPACK_IMPORTED_MODULE_2__[\"logger\"].log('[buffer-controller]: media source detaching');\n\n      if (mediaSource.readyState === 'open') {\n        try {\n          // endOfStream could trigger exception if any sourcebuffer is in updating state\n          // we don't really care about checking sourcebuffer state here,\n          // as we are anyway detaching the MediaSource\n          // let's just avoid this exception to propagate\n          mediaSource.endOfStream();\n        } catch (err) {\n          _utils_logger__WEBPACK_IMPORTED_MODULE_2__[\"logger\"].warn(\"[buffer-controller]: onMediaDetaching: \" + err.message + \" while calling endOfStream\");\n        }\n      } // Clean up the SourceBuffers by invoking onBufferReset\n\n\n      this.onBufferReset();\n      mediaSource.removeEventListener('sourceopen', this._onMediaSourceOpen);\n      mediaSource.removeEventListener('sourceended', this._onMediaSourceEnded);\n      mediaSource.removeEventListener('sourceclose', this._onMediaSourceClose); // Detach properly the MediaSource from the HTMLMediaElement as\n      // suggested in https://github.com/w3c/media-source/issues/53.\n\n      if (media) {\n        if (_objectUrl) {\n          self.URL.revokeObjectURL(_objectUrl);\n        } // clean up video tag src only if it's our own url. some external libraries might\n        // hijack the video tag and change its 'src' without destroying the Hls instance first\n\n\n        if (media.src === _objectUrl) {\n          media.removeAttribute('src');\n          media.load();\n        } else {\n          _utils_logger__WEBPACK_IMPORTED_MODULE_2__[\"logger\"].warn('[buffer-controller]: media.src was changed by a third party - skip cleanup');\n        }\n      }\n\n      this.mediaSource = null;\n      this.media = null;\n      this._objectUrl = null;\n      this.bufferCodecEventsExpected = this._bufferCodecEventsTotal;\n      this.pendingTracks = {};\n      this.tracks = {};\n    }\n\n    this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].MEDIA_DETACHED, undefined);\n  };\n\n  _proto.onBufferReset = function onBufferReset() {\n    var _this2 = this;\n\n    this.getSourceBufferTypes().forEach(function (type) {\n      var sb = _this2.sourceBuffer[type];\n\n      try {\n        if (sb) {\n          _this2.removeBufferListeners(type);\n\n          if (_this2.mediaSource) {\n            _this2.mediaSource.removeSourceBuffer(sb);\n          } // Synchronously remove the SB from the map before the next call in order to prevent an async function from\n          // accessing it\n\n\n          _this2.sourceBuffer[type] = undefined;\n        }\n      } catch (err) {\n        _utils_logger__WEBPACK_IMPORTED_MODULE_2__[\"logger\"].warn(\"[buffer-controller]: Failed to reset the \" + type + \" buffer\", err);\n      }\n    });\n\n    this._initSourceBuffer();\n  };\n\n  _proto.onBufferCodecs = function onBufferCodecs(event, data) {\n    var _this3 = this;\n\n    var sourceBufferCount = this.getSourceBufferTypes().length;\n    Object.keys(data).forEach(function (trackName) {\n      if (sourceBufferCount) {\n        // check if SourceBuffer codec needs to change\n        var track = _this3.tracks[trackName];\n\n        if (track && typeof track.buffer.changeType === 'function') {\n          var _data$trackName = data[trackName],\n              codec = _data$trackName.codec,\n              levelCodec = _data$trackName.levelCodec,\n              container = _data$trackName.container;\n          var currentCodec = (track.levelCodec || track.codec).replace(VIDEO_CODEC_PROFILE_REPACE, '$1');\n          var nextCodec = (levelCodec || codec).replace(VIDEO_CODEC_PROFILE_REPACE, '$1');\n\n          if (currentCodec !== nextCodec) {\n            var mimeType = container + \";codecs=\" + (levelCodec || codec);\n\n            _this3.appendChangeType(trackName, mimeType);\n          }\n        }\n      } else {\n        // if source buffer(s) not created yet, appended buffer tracks in this.pendingTracks\n        _this3.pendingTracks[trackName] = data[trackName];\n      }\n    }); // if sourcebuffers already created, do nothing ...\n\n    if (sourceBufferCount) {\n      return;\n    }\n\n    this.bufferCodecEventsExpected = Math.max(this.bufferCodecEventsExpected - 1, 0);\n\n    if (this.mediaSource && this.mediaSource.readyState === 'open') {\n      this.checkPendingTracks();\n    }\n  };\n\n  _proto.appendChangeType = function appendChangeType(type, mimeType) {\n    var _this4 = this;\n\n    var operationQueue = this.operationQueue;\n    var operation = {\n      execute: function execute() {\n        var sb = _this4.sourceBuffer[type];\n\n        if (sb) {\n          _utils_logger__WEBPACK_IMPORTED_MODULE_2__[\"logger\"].log(\"[buffer-controller]: changing \" + type + \" sourceBuffer type to \" + mimeType);\n          sb.changeType(mimeType);\n        }\n\n        operationQueue.shiftAndExecuteNext(type);\n      },\n      onStart: function onStart() {},\n      onComplete: function onComplete() {},\n      onError: function onError(e) {\n        _utils_logger__WEBPACK_IMPORTED_MODULE_2__[\"logger\"].warn(\"[buffer-controller]: Failed to change \" + type + \" SourceBuffer type\", e);\n      }\n    };\n    operationQueue.append(operation, type);\n  };\n\n  _proto.onBufferAppending = function onBufferAppending(event, eventData) {\n    var _this5 = this;\n\n    var hls = this.hls,\n        operationQueue = this.operationQueue,\n        tracks = this.tracks;\n    var data = eventData.data,\n        type = eventData.type,\n        frag = eventData.frag,\n        part = eventData.part,\n        chunkMeta = eventData.chunkMeta;\n    var chunkStats = chunkMeta.buffering[type];\n    var bufferAppendingStart = self.performance.now();\n    chunkStats.start = bufferAppendingStart;\n    var fragBuffering = frag.stats.buffering;\n    var partBuffering = part ? part.stats.buffering : null;\n\n    if (fragBuffering.start === 0) {\n      fragBuffering.start = bufferAppendingStart;\n    }\n\n    if (partBuffering && partBuffering.start === 0) {\n      partBuffering.start = bufferAppendingStart;\n    } // TODO: Only update timestampOffset when audio/mpeg fragment or part is not contiguous with previously appended\n    // Adjusting `SourceBuffer.timestampOffset` (desired point in the timeline where the next frames should be appended)\n    // in Chrome browser when we detect MPEG audio container and time delta between level PTS and `SourceBuffer.timestampOffset`\n    // is greater than 100ms (this is enough to handle seek for VOD or level change for LIVE videos).\n    // More info here: https://github.com/video-dev/hls.js/issues/332#issuecomment-257986486\n\n\n    var audioTrack = tracks.audio;\n    var checkTimestampOffset = type === 'audio' && chunkMeta.id === 1 && (audioTrack === null || audioTrack === void 0 ? void 0 : audioTrack.container) === 'audio/mpeg';\n    var operation = {\n      execute: function execute() {\n        chunkStats.executeStart = self.performance.now();\n\n        if (checkTimestampOffset) {\n          var sb = _this5.sourceBuffer[type];\n\n          if (sb) {\n            var delta = frag.start - sb.timestampOffset;\n\n            if (Math.abs(delta) >= 0.1) {\n              _utils_logger__WEBPACK_IMPORTED_MODULE_2__[\"logger\"].log(\"[buffer-controller]: Updating audio SourceBuffer timestampOffset to \" + frag.start + \" (delta: \" + delta + \") sn: \" + frag.sn + \")\");\n              sb.timestampOffset = frag.start;\n            }\n          }\n        }\n\n        _this5.appendExecutor(data, type);\n      },\n      onStart: function onStart() {// logger.debug(`[buffer-controller]: ${type} SourceBuffer updatestart`);\n      },\n      onComplete: function onComplete() {\n        // logger.debug(`[buffer-controller]: ${type} SourceBuffer updateend`);\n        var end = self.performance.now();\n        chunkStats.executeEnd = chunkStats.end = end;\n\n        if (fragBuffering.first === 0) {\n          fragBuffering.first = end;\n        }\n\n        if (partBuffering && partBuffering.first === 0) {\n          partBuffering.first = end;\n        }\n\n        var sourceBuffer = _this5.sourceBuffer;\n        var timeRanges = {};\n\n        for (var _type in sourceBuffer) {\n          timeRanges[_type] = _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_4__[\"BufferHelper\"].getBuffered(sourceBuffer[_type]);\n        }\n\n        _this5.appendError = 0;\n\n        _this5.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].BUFFER_APPENDED, {\n          type: type,\n          frag: frag,\n          part: part,\n          chunkMeta: chunkMeta,\n          parent: frag.type,\n          timeRanges: timeRanges\n        });\n      },\n      onError: function onError(err) {\n        // in case any error occured while appending, put back segment in segments table\n        _utils_logger__WEBPACK_IMPORTED_MODULE_2__[\"logger\"].error(\"[buffer-controller]: Error encountered while trying to append to the \" + type + \" SourceBuffer\", err);\n        var event = {\n          type: _errors__WEBPACK_IMPORTED_MODULE_3__[\"ErrorTypes\"].MEDIA_ERROR,\n          parent: frag.type,\n          details: _errors__WEBPACK_IMPORTED_MODULE_3__[\"ErrorDetails\"].BUFFER_APPEND_ERROR,\n          err: err,\n          fatal: false\n        };\n\n        if (err.code === DOMException.QUOTA_EXCEEDED_ERR) {\n          // QuotaExceededError: http://www.w3.org/TR/html5/infrastructure.html#quotaexceedederror\n          // let's stop appending any segments, and report BUFFER_FULL_ERROR error\n          event.details = _errors__WEBPACK_IMPORTED_MODULE_3__[\"ErrorDetails\"].BUFFER_FULL_ERROR;\n        } else {\n          _this5.appendError++;\n          event.details = _errors__WEBPACK_IMPORTED_MODULE_3__[\"ErrorDetails\"].BUFFER_APPEND_ERROR;\n          /* with UHD content, we could get loop of quota exceeded error until\n            browser is able to evict some data from sourcebuffer. Retrying can help recover.\n          */\n\n          if (_this5.appendError > hls.config.appendErrorMaxRetry) {\n            _utils_logger__WEBPACK_IMPORTED_MODULE_2__[\"logger\"].error(\"[buffer-controller]: Failed \" + hls.config.appendErrorMaxRetry + \" times to append segment in sourceBuffer\");\n            event.fatal = true;\n          }\n        }\n\n        hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].ERROR, event);\n      }\n    };\n    operationQueue.append(operation, type);\n  };\n\n  _proto.onBufferFlushing = function onBufferFlushing(event, data) {\n    var _this6 = this;\n\n    var operationQueue = this.operationQueue;\n\n    var flushOperation = function flushOperation(type) {\n      return {\n        execute: _this6.removeExecutor.bind(_this6, type, data.startOffset, data.endOffset),\n        onStart: function onStart() {// logger.debug(`[buffer-controller]: Started flushing ${data.startOffset} -> ${data.endOffset} for ${type} Source Buffer`);\n        },\n        onComplete: function onComplete() {\n          // logger.debug(`[buffer-controller]: Finished flushing ${data.startOffset} -> ${data.endOffset} for ${type} Source Buffer`);\n          _this6.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].BUFFER_FLUSHED, {\n            type: type\n          });\n        },\n        onError: function onError(e) {\n          _utils_logger__WEBPACK_IMPORTED_MODULE_2__[\"logger\"].warn(\"[buffer-controller]: Failed to remove from \" + type + \" SourceBuffer\", e);\n        }\n      };\n    };\n\n    if (data.type) {\n      operationQueue.append(flushOperation(data.type), data.type);\n    } else {\n      this.getSourceBufferTypes().forEach(function (type) {\n        operationQueue.append(flushOperation(type), type);\n      });\n    }\n  };\n\n  _proto.onFragParsed = function onFragParsed(event, data) {\n    var _this7 = this;\n\n    var frag = data.frag,\n        part = data.part;\n    var buffersAppendedTo = [];\n    var elementaryStreams = part ? part.elementaryStreams : frag.elementaryStreams;\n\n    if (elementaryStreams[_loader_fragment__WEBPACK_IMPORTED_MODULE_6__[\"ElementaryStreamTypes\"].AUDIOVIDEO]) {\n      buffersAppendedTo.push('audiovideo');\n    } else {\n      if (elementaryStreams[_loader_fragment__WEBPACK_IMPORTED_MODULE_6__[\"ElementaryStreamTypes\"].AUDIO]) {\n        buffersAppendedTo.push('audio');\n      }\n\n      if (elementaryStreams[_loader_fragment__WEBPACK_IMPORTED_MODULE_6__[\"ElementaryStreamTypes\"].VIDEO]) {\n        buffersAppendedTo.push('video');\n      }\n    }\n\n    var onUnblocked = function onUnblocked() {\n      var now = self.performance.now();\n      frag.stats.buffering.end = now;\n\n      if (part) {\n        part.stats.buffering.end = now;\n      }\n\n      var stats = part ? part.stats : frag.stats;\n\n      _this7.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].FRAG_BUFFERED, {\n        frag: frag,\n        part: part,\n        stats: stats,\n        id: frag.type\n      });\n    };\n\n    if (buffersAppendedTo.length === 0) {\n      _utils_logger__WEBPACK_IMPORTED_MODULE_2__[\"logger\"].warn(\"Fragments must have at least one ElementaryStreamType set. type: \" + frag.type + \" level: \" + frag.level + \" sn: \" + frag.sn);\n    }\n\n    this.blockBuffers(onUnblocked, buffersAppendedTo);\n  };\n\n  _proto.onFragChanged = function onFragChanged(event, data) {\n    this.flushBackBuffer();\n  } // on BUFFER_EOS mark matching sourcebuffer(s) as ended and trigger checkEos()\n  // an undefined data.type will mark all buffers as EOS.\n  ;\n\n  _proto.onBufferEos = function onBufferEos(event, data) {\n    var _this8 = this;\n\n    var ended = this.getSourceBufferTypes().reduce(function (acc, type) {\n      var sb = _this8.sourceBuffer[type];\n\n      if (!data.type || data.type === type) {\n        if (sb && !sb.ended) {\n          sb.ended = true;\n          _utils_logger__WEBPACK_IMPORTED_MODULE_2__[\"logger\"].log(\"[buffer-controller]: \" + type + \" sourceBuffer now EOS\");\n        }\n      }\n\n      return acc && !!(!sb || sb.ended);\n    }, true);\n\n    if (ended) {\n      this.blockBuffers(function () {\n        var mediaSource = _this8.mediaSource;\n\n        if (!mediaSource || mediaSource.readyState !== 'open') {\n          return;\n        } // Allow this to throw and be caught by the enqueueing function\n\n\n        mediaSource.endOfStream();\n      });\n    }\n  };\n\n  _proto.onLevelUpdated = function onLevelUpdated(event, _ref) {\n    var details = _ref.details;\n\n    if (!details.fragments.length) {\n      return;\n    }\n\n    this.details = details;\n\n    if (this.getSourceBufferTypes().length) {\n      this.blockBuffers(this.updateMediaElementDuration.bind(this));\n    } else {\n      this.updateMediaElementDuration();\n    }\n  };\n\n  _proto.flushBackBuffer = function flushBackBuffer() {\n    var hls = this.hls,\n        details = this.details,\n        media = this.media,\n        sourceBuffer = this.sourceBuffer;\n\n    if (!media || details === null) {\n      return;\n    }\n\n    var sourceBufferTypes = this.getSourceBufferTypes();\n\n    if (!sourceBufferTypes.length) {\n      return;\n    } // Support for deprecated liveBackBufferLength\n\n\n    var backBufferLength = details.live && hls.config.liveBackBufferLength !== null ? hls.config.liveBackBufferLength : hls.config.backBufferLength;\n\n    if (!Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__[\"isFiniteNumber\"])(backBufferLength) || backBufferLength < 0) {\n      return;\n    }\n\n    var currentTime = media.currentTime;\n    var targetDuration = details.levelTargetDuration;\n    var maxBackBufferLength = Math.max(backBufferLength, targetDuration);\n    var targetBackBufferPosition = Math.floor(currentTime / targetDuration) * targetDuration - maxBackBufferLength;\n    sourceBufferTypes.forEach(function (type) {\n      var sb = sourceBuffer[type];\n\n      if (sb) {\n        var buffered = _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_4__[\"BufferHelper\"].getBuffered(sb); // when target buffer start exceeds actual buffer start\n\n        if (buffered.length > 0 && targetBackBufferPosition > buffered.start(0)) {\n          hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].BACK_BUFFER_REACHED, {\n            bufferEnd: targetBackBufferPosition\n          }); // Support for deprecated event:\n\n          if (details.live) {\n            hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].LIVE_BACK_BUFFER_REACHED, {\n              bufferEnd: targetBackBufferPosition\n            });\n          }\n\n          hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].BUFFER_FLUSHING, {\n            startOffset: 0,\n            endOffset: targetBackBufferPosition,\n            type: type\n          });\n        }\n      }\n    });\n  }\n  /**\n   * Update Media Source duration to current level duration or override to Infinity if configuration parameter\n   * 'liveDurationInfinity` is set to `true`\n   * More details: https://github.com/video-dev/hls.js/issues/355\n   */\n  ;\n\n  _proto.updateMediaElementDuration = function updateMediaElementDuration() {\n    if (!this.details || !this.media || !this.mediaSource || this.mediaSource.readyState !== 'open') {\n      return;\n    }\n\n    var details = this.details,\n        hls = this.hls,\n        media = this.media,\n        mediaSource = this.mediaSource;\n    var levelDuration = details.fragments[0].start + details.totalduration;\n    var mediaDuration = media.duration;\n    var msDuration = Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__[\"isFiniteNumber\"])(mediaSource.duration) ? mediaSource.duration : 0;\n\n    if (details.live && hls.config.liveDurationInfinity) {\n      // Override duration to Infinity\n      _utils_logger__WEBPACK_IMPORTED_MODULE_2__[\"logger\"].log('[buffer-controller]: Media Source duration is set to Infinity');\n      mediaSource.duration = Infinity;\n      this.updateSeekableRange(details);\n    } else if (levelDuration > msDuration && levelDuration > mediaDuration || !Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__[\"isFiniteNumber\"])(mediaDuration)) {\n      // levelDuration was the last value we set.\n      // not using mediaSource.duration as the browser may tweak this value\n      // only update Media Source duration if its value increase, this is to avoid\n      // flushing already buffered portion when switching between quality level\n      _utils_logger__WEBPACK_IMPORTED_MODULE_2__[\"logger\"].log(\"[buffer-controller]: Updating Media Source duration to \" + levelDuration.toFixed(3));\n      mediaSource.duration = levelDuration;\n    }\n  };\n\n  _proto.updateSeekableRange = function updateSeekableRange(levelDetails) {\n    var mediaSource = this.mediaSource;\n    var fragments = levelDetails.fragments;\n    var len = fragments.length;\n\n    if (len && levelDetails.live && mediaSource !== null && mediaSource !== void 0 && mediaSource.setLiveSeekableRange) {\n      var start = Math.max(0, fragments[0].start);\n      var end = Math.max(start, start + levelDetails.totalduration);\n      mediaSource.setLiveSeekableRange(start, end);\n    }\n  };\n\n  _proto.checkPendingTracks = function checkPendingTracks() {\n    var bufferCodecEventsExpected = this.bufferCodecEventsExpected,\n        operationQueue = this.operationQueue,\n        pendingTracks = this.pendingTracks; // Check if we've received all of the expected bufferCodec events. When none remain, create all the sourceBuffers at once.\n    // This is important because the MSE spec allows implementations to throw QuotaExceededErrors if creating new sourceBuffers after\n    // data has been appended to existing ones.\n    // 2 tracks is the max (one for audio, one for video). If we've reach this max go ahead and create the buffers.\n\n    var pendingTracksCount = Object.keys(pendingTracks).length;\n\n    if (pendingTracksCount && !bufferCodecEventsExpected || pendingTracksCount === 2) {\n      // ok, let's create them now !\n      this.createSourceBuffers(pendingTracks);\n      this.pendingTracks = {}; // append any pending segments now !\n\n      var buffers = this.getSourceBufferTypes();\n\n      if (buffers.length === 0) {\n        this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].ERROR, {\n          type: _errors__WEBPACK_IMPORTED_MODULE_3__[\"ErrorTypes\"].MEDIA_ERROR,\n          details: _errors__WEBPACK_IMPORTED_MODULE_3__[\"ErrorDetails\"].BUFFER_INCOMPATIBLE_CODECS_ERROR,\n          fatal: true,\n          reason: 'could not create source buffer for media codec(s)'\n        });\n        return;\n      }\n\n      buffers.forEach(function (type) {\n        operationQueue.executeNext(type);\n      });\n    }\n  };\n\n  _proto.createSourceBuffers = function createSourceBuffers(tracks) {\n    var sourceBuffer = this.sourceBuffer,\n        mediaSource = this.mediaSource;\n\n    if (!mediaSource) {\n      throw Error('createSourceBuffers called when mediaSource was null');\n    }\n\n    var tracksCreated = 0;\n\n    for (var trackName in tracks) {\n      if (!sourceBuffer[trackName]) {\n        var track = tracks[trackName];\n\n        if (!track) {\n          throw Error(\"source buffer exists for track \" + trackName + \", however track does not\");\n        } // use levelCodec as first priority\n\n\n        var codec = track.levelCodec || track.codec;\n        var mimeType = track.container + \";codecs=\" + codec;\n        _utils_logger__WEBPACK_IMPORTED_MODULE_2__[\"logger\"].log(\"[buffer-controller]: creating sourceBuffer(\" + mimeType + \")\");\n\n        try {\n          var sb = sourceBuffer[trackName] = mediaSource.addSourceBuffer(mimeType);\n          var sbName = trackName;\n          this.addBufferListener(sbName, 'updatestart', this._onSBUpdateStart);\n          this.addBufferListener(sbName, 'updateend', this._onSBUpdateEnd);\n          this.addBufferListener(sbName, 'error', this._onSBUpdateError);\n          this.tracks[trackName] = {\n            buffer: sb,\n            codec: codec,\n            container: track.container,\n            levelCodec: track.levelCodec,\n            id: track.id\n          };\n          tracksCreated++;\n        } catch (err) {\n          _utils_logger__WEBPACK_IMPORTED_MODULE_2__[\"logger\"].error(\"[buffer-controller]: error while trying to add sourceBuffer: \" + err.message);\n          this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].ERROR, {\n            type: _errors__WEBPACK_IMPORTED_MODULE_3__[\"ErrorTypes\"].MEDIA_ERROR,\n            details: _errors__WEBPACK_IMPORTED_MODULE_3__[\"ErrorDetails\"].BUFFER_ADD_CODEC_ERROR,\n            fatal: false,\n            error: err,\n            mimeType: mimeType\n          });\n        }\n      }\n    }\n\n    if (tracksCreated) {\n      this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].BUFFER_CREATED, {\n        tracks: this.tracks\n      });\n    }\n  } // Keep as arrow functions so that we can directly reference these functions directly as event listeners\n  ;\n\n  _proto._onSBUpdateStart = function _onSBUpdateStart(type) {\n    var operationQueue = this.operationQueue;\n    var operation = operationQueue.current(type);\n    operation.onStart();\n  };\n\n  _proto._onSBUpdateEnd = function _onSBUpdateEnd(type) {\n    var operationQueue = this.operationQueue;\n    var operation = operationQueue.current(type);\n    operation.onComplete();\n    operationQueue.shiftAndExecuteNext(type);\n  };\n\n  _proto._onSBUpdateError = function _onSBUpdateError(type, event) {\n    _utils_logger__WEBPACK_IMPORTED_MODULE_2__[\"logger\"].error(\"[buffer-controller]: \" + type + \" SourceBuffer error\", event); // according to http://www.w3.org/TR/media-source/#sourcebuffer-append-error\n    // SourceBuffer errors are not necessarily fatal; if so, the HTMLMediaElement will fire an error event\n\n    this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].ERROR, {\n      type: _errors__WEBPACK_IMPORTED_MODULE_3__[\"ErrorTypes\"].MEDIA_ERROR,\n      details: _errors__WEBPACK_IMPORTED_MODULE_3__[\"ErrorDetails\"].BUFFER_APPENDING_ERROR,\n      fatal: false\n    }); // updateend is always fired after error, so we'll allow that to shift the current operation off of the queue\n\n    var operation = this.operationQueue.current(type);\n\n    if (operation) {\n      operation.onError(event);\n    }\n  } // This method must result in an updateend event; if remove is not called, _onSBUpdateEnd must be called manually\n  ;\n\n  _proto.removeExecutor = function removeExecutor(type, startOffset, endOffset) {\n    var media = this.media,\n        mediaSource = this.mediaSource,\n        operationQueue = this.operationQueue,\n        sourceBuffer = this.sourceBuffer;\n    var sb = sourceBuffer[type];\n\n    if (!media || !mediaSource || !sb) {\n      _utils_logger__WEBPACK_IMPORTED_MODULE_2__[\"logger\"].warn(\"[buffer-controller]: Attempting to remove from the \" + type + \" SourceBuffer, but it does not exist\");\n      operationQueue.shiftAndExecuteNext(type);\n      return;\n    }\n\n    var mediaDuration = Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__[\"isFiniteNumber\"])(media.duration) ? media.duration : Infinity;\n    var msDuration = Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__[\"isFiniteNumber\"])(mediaSource.duration) ? mediaSource.duration : Infinity;\n    var removeStart = Math.max(0, startOffset);\n    var removeEnd = Math.min(endOffset, mediaDuration, msDuration);\n\n    if (removeEnd > removeStart) {\n      _utils_logger__WEBPACK_IMPORTED_MODULE_2__[\"logger\"].log(\"[buffer-controller]: Removing [\" + removeStart + \",\" + removeEnd + \"] from the \" + type + \" SourceBuffer\");\n      console.assert(!sb.updating, type + \" sourceBuffer must not be updating\");\n      sb.remove(removeStart, removeEnd);\n    } else {\n      // Cycle the queue\n      operationQueue.shiftAndExecuteNext(type);\n    }\n  } // This method must result in an updateend event; if append is not called, _onSBUpdateEnd must be called manually\n  ;\n\n  _proto.appendExecutor = function appendExecutor(data, type) {\n    var operationQueue = this.operationQueue,\n        sourceBuffer = this.sourceBuffer;\n    var sb = sourceBuffer[type];\n\n    if (!sb) {\n      _utils_logger__WEBPACK_IMPORTED_MODULE_2__[\"logger\"].warn(\"[buffer-controller]: Attempting to append to the \" + type + \" SourceBuffer, but it does not exist\");\n      operationQueue.shiftAndExecuteNext(type);\n      return;\n    }\n\n    sb.ended = false;\n    console.assert(!sb.updating, type + \" sourceBuffer must not be updating\");\n    sb.appendBuffer(data);\n  } // Enqueues an operation to each SourceBuffer queue which, upon execution, resolves a promise. When all promises\n  // resolve, the onUnblocked function is executed. Functions calling this method do not need to unblock the queue\n  // upon completion, since we already do it here\n  ;\n\n  _proto.blockBuffers = function blockBuffers(onUnblocked, buffers) {\n    var _this9 = this;\n\n    if (buffers === void 0) {\n      buffers = this.getSourceBufferTypes();\n    }\n\n    if (!buffers.length) {\n      _utils_logger__WEBPACK_IMPORTED_MODULE_2__[\"logger\"].log('[buffer-controller]: Blocking operation requested, but no SourceBuffers exist');\n      Promise.resolve(onUnblocked);\n      return;\n    }\n\n    var operationQueue = this.operationQueue; // logger.debug(`[buffer-controller]: Blocking ${buffers} SourceBuffer`);\n\n    var blockingOperations = buffers.map(function (type) {\n      return operationQueue.appendBlocker(type);\n    });\n    Promise.all(blockingOperations).then(function () {\n      // logger.debug(`[buffer-controller]: Blocking operation resolved; unblocking ${buffers} SourceBuffer`);\n      onUnblocked();\n      buffers.forEach(function (type) {\n        var sb = _this9.sourceBuffer[type]; // Only cycle the queue if the SB is not updating. There's a bug in Chrome which sets the SB updating flag to\n        // true when changing the MediaSource duration (https://bugs.chromium.org/p/chromium/issues/detail?id=959359&can=2&q=mediasource%20duration)\n        // While this is a workaround, it's probably useful to have around\n\n        if (!sb || !sb.updating) {\n          operationQueue.shiftAndExecuteNext(type);\n        }\n      });\n    });\n  };\n\n  _proto.getSourceBufferTypes = function getSourceBufferTypes() {\n    return Object.keys(this.sourceBuffer);\n  };\n\n  _proto.addBufferListener = function addBufferListener(type, event, fn) {\n    var buffer = this.sourceBuffer[type];\n\n    if (!buffer) {\n      return;\n    }\n\n    var listener = fn.bind(this, type);\n    this.listeners[type].push({\n      event: event,\n      listener: listener\n    });\n    buffer.addEventListener(event, listener);\n  };\n\n  _proto.removeBufferListeners = function removeBufferListeners(type) {\n    var buffer = this.sourceBuffer[type];\n\n    if (!buffer) {\n      return;\n    }\n\n    this.listeners[type].forEach(function (l) {\n      buffer.removeEventListener(l.event, l.listener);\n    });\n  };\n\n  return BufferController;\n}();\n\n\n\n/***/ }),\n\n/***/ \"./src/controller/buffer-operation-queue.ts\":\n/*!**************************************************!*\\\n  !*** ./src/controller/buffer-operation-queue.ts ***!\n  \\**************************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_204665__) {\n\n\"use strict\";\n__nested_webpack_require_204665__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_204665__.d(__webpack_exports__, \"default\", function() { return BufferOperationQueue; });\n/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_204665__(/*! ../utils/logger */ \"./src/utils/logger.ts\");\n\n\nvar BufferOperationQueue = /*#__PURE__*/function () {\n  function BufferOperationQueue(sourceBufferReference) {\n    this.buffers = void 0;\n    this.queues = {\n      video: [],\n      audio: [],\n      audiovideo: []\n    };\n    this.buffers = sourceBufferReference;\n  }\n\n  var _proto = BufferOperationQueue.prototype;\n\n  _proto.append = function append(operation, type) {\n    var queue = this.queues[type];\n    queue.push(operation);\n\n    if (queue.length === 1 && this.buffers[type]) {\n      this.executeNext(type);\n    }\n  };\n\n  _proto.insertAbort = function insertAbort(operation, type) {\n    var queue = this.queues[type];\n    queue.unshift(operation);\n    this.executeNext(type);\n  };\n\n  _proto.appendBlocker = function appendBlocker(type) {\n    var execute;\n    var promise = new Promise(function (resolve) {\n      execute = resolve;\n    });\n    var operation = {\n      execute: execute,\n      onStart: function onStart() {},\n      onComplete: function onComplete() {},\n      onError: function onError() {}\n    };\n    this.append(operation, type);\n    return promise;\n  };\n\n  _proto.executeNext = function executeNext(type) {\n    var buffers = this.buffers,\n        queues = this.queues;\n    var sb = buffers[type];\n    var queue = queues[type];\n\n    if (queue.length) {\n      var operation = queue[0];\n\n      try {\n        // Operations are expected to result in an 'updateend' event being fired. If not, the queue will lock. Operations\n        // which do not end with this event must call _onSBUpdateEnd manually\n        operation.execute();\n      } catch (e) {\n        _utils_logger__WEBPACK_IMPORTED_MODULE_0__[\"logger\"].warn('[buffer-operation-queue]: Unhandled exception executing the current operation');\n        operation.onError(e); // Only shift the current operation off, otherwise the updateend handler will do this for us\n\n        if (!sb || !sb.updating) {\n          queue.shift();\n          this.executeNext(type);\n        }\n      }\n    }\n  };\n\n  _proto.shiftAndExecuteNext = function shiftAndExecuteNext(type) {\n    this.queues[type].shift();\n    this.executeNext(type);\n  };\n\n  _proto.current = function current(type) {\n    return this.queues[type][0];\n  };\n\n  return BufferOperationQueue;\n}();\n\n\n\n/***/ }),\n\n/***/ \"./src/controller/cap-level-controller.ts\":\n/*!************************************************!*\\\n  !*** ./src/controller/cap-level-controller.ts ***!\n  \\************************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_207537__) {\n\n\"use strict\";\n__nested_webpack_require_207537__.r(__webpack_exports__);\n/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_207537__(/*! ../events */ \"./src/events.ts\");\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/*\n * cap stream level to media size dimension controller\n */\n\n\nvar CapLevelController = /*#__PURE__*/function () {\n  function CapLevelController(hls) {\n    this.autoLevelCapping = void 0;\n    this.firstLevel = void 0;\n    this.media = void 0;\n    this.restrictedLevels = void 0;\n    this.timer = void 0;\n    this.hls = void 0;\n    this.streamController = void 0;\n    this.clientRect = void 0;\n    this.hls = hls;\n    this.autoLevelCapping = Number.POSITIVE_INFINITY;\n    this.firstLevel = -1;\n    this.media = null;\n    this.restrictedLevels = [];\n    this.timer = undefined;\n    this.clientRect = null;\n    this.registerListeners();\n  }\n\n  var _proto = CapLevelController.prototype;\n\n  _proto.setStreamController = function setStreamController(streamController) {\n    this.streamController = streamController;\n  };\n\n  _proto.destroy = function destroy() {\n    this.unregisterListener();\n\n    if (this.hls.config.capLevelToPlayerSize) {\n      this.stopCapping();\n    }\n\n    this.media = null;\n    this.clientRect = null; // @ts-ignore\n\n    this.hls = this.streamController = null;\n  };\n\n  _proto.registerListeners = function registerListeners() {\n    var hls = this.hls;\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].FPS_DROP_LEVEL_CAPPING, this.onFpsDropLevelCapping, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].MEDIA_ATTACHING, this.onMediaAttaching, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].MANIFEST_PARSED, this.onManifestParsed, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].BUFFER_CODECS, this.onBufferCodecs, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].MEDIA_DETACHING, this.onMediaDetaching, this);\n  };\n\n  _proto.unregisterListener = function unregisterListener() {\n    var hls = this.hls;\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].FPS_DROP_LEVEL_CAPPING, this.onFpsDropLevelCapping, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].MEDIA_ATTACHING, this.onMediaAttaching, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].MANIFEST_PARSED, this.onManifestParsed, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].BUFFER_CODECS, this.onBufferCodecs, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].MEDIA_DETACHING, this.onMediaDetaching, this);\n  };\n\n  _proto.onFpsDropLevelCapping = function onFpsDropLevelCapping(event, data) {\n    // Don't add a restricted level more than once\n    if (CapLevelController.isLevelAllowed(data.droppedLevel, this.restrictedLevels)) {\n      this.restrictedLevels.push(data.droppedLevel);\n    }\n  };\n\n  _proto.onMediaAttaching = function onMediaAttaching(event, data) {\n    this.media = data.media instanceof HTMLVideoElement ? data.media : null;\n  };\n\n  _proto.onManifestParsed = function onManifestParsed(event, data) {\n    var hls = this.hls;\n    this.restrictedLevels = [];\n    this.firstLevel = data.firstLevel;\n\n    if (hls.config.capLevelToPlayerSize && data.video) {\n      // Start capping immediately if the manifest has signaled video codecs\n      this.startCapping();\n    }\n  } // Only activate capping when playing a video stream; otherwise, multi-bitrate audio-only streams will be restricted\n  // to the first level\n  ;\n\n  _proto.onBufferCodecs = function onBufferCodecs(event, data) {\n    var hls = this.hls;\n\n    if (hls.config.capLevelToPlayerSize && data.video) {\n      // If the manifest did not signal a video codec capping has been deferred until we're certain video is present\n      this.startCapping();\n    }\n  };\n\n  _proto.onMediaDetaching = function onMediaDetaching() {\n    this.stopCapping();\n  };\n\n  _proto.detectPlayerSize = function detectPlayerSize() {\n    if (this.media && this.mediaHeight > 0 && this.mediaWidth > 0) {\n      var levels = this.hls.levels;\n\n      if (levels.length) {\n        var hls = this.hls;\n        hls.autoLevelCapping = this.getMaxLevel(levels.length - 1);\n\n        if (hls.autoLevelCapping > this.autoLevelCapping && this.streamController) {\n          // if auto level capping has a higher value for the previous one, flush the buffer using nextLevelSwitch\n          // usually happen when the user go to the fullscreen mode.\n          this.streamController.nextLevelSwitch();\n        }\n\n        this.autoLevelCapping = hls.autoLevelCapping;\n      }\n    }\n  }\n  /*\n   * returns level should be the one with the dimensions equal or greater than the media (player) dimensions (so the video will be downscaled)\n   */\n  ;\n\n  _proto.getMaxLevel = function getMaxLevel(capLevelIndex) {\n    var _this = this;\n\n    var levels = this.hls.levels;\n\n    if (!levels.length) {\n      return -1;\n    }\n\n    var validLevels = levels.filter(function (level, index) {\n      return CapLevelController.isLevelAllowed(index, _this.restrictedLevels) && index <= capLevelIndex;\n    });\n    this.clientRect = null;\n    return CapLevelController.getMaxLevelByMediaSize(validLevels, this.mediaWidth, this.mediaHeight);\n  };\n\n  _proto.startCapping = function startCapping() {\n    if (this.timer) {\n      // Don't reset capping if started twice; this can happen if the manifest signals a video codec\n      return;\n    }\n\n    this.autoLevelCapping = Number.POSITIVE_INFINITY;\n    this.hls.firstLevel = this.getMaxLevel(this.firstLevel);\n    self.clearInterval(this.timer);\n    this.timer = self.setInterval(this.detectPlayerSize.bind(this), 1000);\n    this.detectPlayerSize();\n  };\n\n  _proto.stopCapping = function stopCapping() {\n    this.restrictedLevels = [];\n    this.firstLevel = -1;\n    this.autoLevelCapping = Number.POSITIVE_INFINITY;\n\n    if (this.timer) {\n      self.clearInterval(this.timer);\n      this.timer = undefined;\n    }\n  };\n\n  _proto.getDimensions = function getDimensions() {\n    if (this.clientRect) {\n      return this.clientRect;\n    }\n\n    var media = this.media;\n    var boundsRect = {\n      width: 0,\n      height: 0\n    };\n\n    if (media) {\n      var clientRect = media.getBoundingClientRect();\n      boundsRect.width = clientRect.width;\n      boundsRect.height = clientRect.height;\n\n      if (!boundsRect.width && !boundsRect.height) {\n        // When the media element has no width or height (equivalent to not being in the DOM),\n        // then use its width and height attributes (media.width, media.height)\n        boundsRect.width = clientRect.right - clientRect.left || media.width || 0;\n        boundsRect.height = clientRect.bottom - clientRect.top || media.height || 0;\n      }\n    }\n\n    this.clientRect = boundsRect;\n    return boundsRect;\n  };\n\n  CapLevelController.isLevelAllowed = function isLevelAllowed(level, restrictedLevels) {\n    if (restrictedLevels === void 0) {\n      restrictedLevels = [];\n    }\n\n    return restrictedLevels.indexOf(level) === -1;\n  };\n\n  CapLevelController.getMaxLevelByMediaSize = function getMaxLevelByMediaSize(levels, width, height) {\n    if (!levels || !levels.length) {\n      return -1;\n    } // Levels can have the same dimensions but differing bandwidths - since levels are ordered, we can look to the next\n    // to determine whether we've chosen the greatest bandwidth for the media's dimensions\n\n\n    var atGreatestBandiwdth = function atGreatestBandiwdth(curLevel, nextLevel) {\n      if (!nextLevel) {\n        return true;\n      }\n\n      return curLevel.width !== nextLevel.width || curLevel.height !== nextLevel.height;\n    }; // If we run through the loop without breaking, the media's dimensions are greater than every level, so default to\n    // the max level\n\n\n    var maxLevelIndex = levels.length - 1;\n\n    for (var i = 0; i < levels.length; i += 1) {\n      var level = levels[i];\n\n      if ((level.width >= width || level.height >= height) && atGreatestBandiwdth(level, levels[i + 1])) {\n        maxLevelIndex = i;\n        break;\n      }\n    }\n\n    return maxLevelIndex;\n  };\n\n  _createClass(CapLevelController, [{\n    key: \"mediaWidth\",\n    get: function get() {\n      return this.getDimensions().width * CapLevelController.contentScaleFactor;\n    }\n  }, {\n    key: \"mediaHeight\",\n    get: function get() {\n      return this.getDimensions().height * CapLevelController.contentScaleFactor;\n    }\n  }], [{\n    key: \"contentScaleFactor\",\n    get: function get() {\n      var pixelRatio = 1;\n\n      try {\n        pixelRatio = self.devicePixelRatio;\n      } catch (e) {\n        /* no-op */\n      }\n\n      return pixelRatio;\n    }\n  }]);\n\n  return CapLevelController;\n}();\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (CapLevelController);\n\n/***/ }),\n\n/***/ \"./src/controller/cmcd-controller.ts\":\n/*!*******************************************!*\\\n  !*** ./src/controller/cmcd-controller.ts ***!\n  \\*******************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_217051__) {\n\n\"use strict\";\n__nested_webpack_require_217051__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_217051__.d(__webpack_exports__, \"default\", function() { return CMCDController; });\n/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_217051__(/*! ../events */ \"./src/events.ts\");\n/* harmony import */ var _types_cmcd__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_217051__(/*! ../types/cmcd */ \"./src/types/cmcd.ts\");\n/* harmony import */ var _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_217051__(/*! ../utils/buffer-helper */ \"./src/utils/buffer-helper.ts\");\n/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_217051__(/*! ../utils/logger */ \"./src/utils/logger.ts\");\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\n\n\n\n\n/**\n * Controller to deal with Common Media Client Data (CMCD)\n * @see https://cdn.cta.tech/cta/media/media/resources/standards/pdfs/cta-5004-final.pdf\n */\n\nvar CMCDController = /*#__PURE__*/function () {\n  // eslint-disable-line no-restricted-globals\n  // eslint-disable-line no-restricted-globals\n  function CMCDController(hls) {\n    var _this = this;\n\n    this.hls = void 0;\n    this.config = void 0;\n    this.media = void 0;\n    this.sid = void 0;\n    this.cid = void 0;\n    this.useHeaders = false;\n    this.initialized = false;\n    this.starved = false;\n    this.buffering = true;\n    this.audioBuffer = void 0;\n    this.videoBuffer = void 0;\n\n    this.onWaiting = function () {\n      if (_this.initialized) {\n        _this.starved = true;\n      }\n\n      _this.buffering = true;\n    };\n\n    this.onPlaying = function () {\n      if (!_this.initialized) {\n        _this.initialized = true;\n      }\n\n      _this.buffering = false;\n    };\n\n    this.applyPlaylistData = function (context) {\n      try {\n        _this.apply(context, {\n          ot: _types_cmcd__WEBPACK_IMPORTED_MODULE_1__[\"CMCDObjectType\"].MANIFEST,\n          su: !_this.initialized\n        });\n      } catch (error) {\n        _utils_logger__WEBPACK_IMPORTED_MODULE_3__[\"logger\"].warn('Could not generate manifest CMCD data.', error);\n      }\n    };\n\n    this.applyFragmentData = function (context) {\n      try {\n        var fragment = context.frag;\n        var level = _this.hls.levels[fragment.level];\n\n        var ot = _this.getObjectType(fragment);\n\n        var data = {\n          d: fragment.duration * 1000,\n          ot: ot\n        };\n\n        if (ot === _types_cmcd__WEBPACK_IMPORTED_MODULE_1__[\"CMCDObjectType\"].VIDEO || ot === _types_cmcd__WEBPACK_IMPORTED_MODULE_1__[\"CMCDObjectType\"].AUDIO || ot == _types_cmcd__WEBPACK_IMPORTED_MODULE_1__[\"CMCDObjectType\"].MUXED) {\n          data.br = level.bitrate / 1000;\n          data.tb = _this.getTopBandwidth(ot) / 1000;\n          data.bl = _this.getBufferLength(ot);\n        }\n\n        _this.apply(context, data);\n      } catch (error) {\n        _utils_logger__WEBPACK_IMPORTED_MODULE_3__[\"logger\"].warn('Could not generate segment CMCD data.', error);\n      }\n    };\n\n    this.hls = hls;\n    var config = this.config = hls.config;\n    var cmcd = config.cmcd;\n\n    if (cmcd != null) {\n      config.pLoader = this.createPlaylistLoader();\n      config.fLoader = this.createFragmentLoader();\n      this.sid = cmcd.sessionId || CMCDController.uuid();\n      this.cid = cmcd.contentId;\n      this.useHeaders = cmcd.useHeaders === true;\n      this.registerListeners();\n    }\n  }\n\n  var _proto = CMCDController.prototype;\n\n  _proto.registerListeners = function registerListeners() {\n    var hls = this.hls;\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].MEDIA_ATTACHED, this.onMediaAttached, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].MEDIA_DETACHED, this.onMediaDetached, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].BUFFER_CREATED, this.onBufferCreated, this);\n  };\n\n  _proto.unregisterListeners = function unregisterListeners() {\n    var hls = this.hls;\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].MEDIA_ATTACHED, this.onMediaAttached, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].MEDIA_DETACHED, this.onMediaDetached, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].BUFFER_CREATED, this.onBufferCreated, this);\n    this.onMediaDetached();\n  };\n\n  _proto.destroy = function destroy() {\n    this.unregisterListeners(); // @ts-ignore\n\n    this.hls = this.config = this.audioBuffer = this.videoBuffer = null;\n  };\n\n  _proto.onMediaAttached = function onMediaAttached(event, data) {\n    this.media = data.media;\n    this.media.addEventListener('waiting', this.onWaiting);\n    this.media.addEventListener('playing', this.onPlaying);\n  };\n\n  _proto.onMediaDetached = function onMediaDetached() {\n    if (!this.media) {\n      return;\n    }\n\n    this.media.removeEventListener('waiting', this.onWaiting);\n    this.media.removeEventListener('playing', this.onPlaying); // @ts-ignore\n\n    this.media = null;\n  };\n\n  _proto.onBufferCreated = function onBufferCreated(event, data) {\n    var _data$tracks$audio, _data$tracks$video;\n\n    this.audioBuffer = (_data$tracks$audio = data.tracks.audio) === null || _data$tracks$audio === void 0 ? void 0 : _data$tracks$audio.buffer;\n    this.videoBuffer = (_data$tracks$video = data.tracks.video) === null || _data$tracks$video === void 0 ? void 0 : _data$tracks$video.buffer;\n  };\n\n  /**\n   * Create baseline CMCD data\n   */\n  _proto.createData = function createData() {\n    var _this$media;\n\n    return {\n      v: _types_cmcd__WEBPACK_IMPORTED_MODULE_1__[\"CMCDVersion\"],\n      sf: _types_cmcd__WEBPACK_IMPORTED_MODULE_1__[\"CMCDStreamingFormat\"].HLS,\n      sid: this.sid,\n      cid: this.cid,\n      pr: (_this$media = this.media) === null || _this$media === void 0 ? void 0 : _this$media.playbackRate,\n      mtp: this.hls.bandwidthEstimate / 1000\n    };\n  }\n  /**\n   * Apply CMCD data to a request.\n   */\n  ;\n\n  _proto.apply = function apply(context, data) {\n    if (data === void 0) {\n      data = {};\n    }\n\n    // apply baseline data\n    _extends(data, this.createData());\n\n    var isVideo = data.ot === _types_cmcd__WEBPACK_IMPORTED_MODULE_1__[\"CMCDObjectType\"].INIT || data.ot === _types_cmcd__WEBPACK_IMPORTED_MODULE_1__[\"CMCDObjectType\"].VIDEO || data.ot === _types_cmcd__WEBPACK_IMPORTED_MODULE_1__[\"CMCDObjectType\"].MUXED;\n\n    if (this.starved && isVideo) {\n      data.bs = true;\n      data.su = true;\n      this.starved = false;\n    }\n\n    if (data.su == null) {\n      data.su = this.buffering;\n    } // TODO: Implement rtp, nrr, nor, dl\n\n\n    if (this.useHeaders) {\n      var headers = CMCDController.toHeaders(data);\n\n      if (!Object.keys(headers).length) {\n        return;\n      }\n\n      if (!context.headers) {\n        context.headers = {};\n      }\n\n      _extends(context.headers, headers);\n    } else {\n      var query = CMCDController.toQuery(data);\n\n      if (!query) {\n        return;\n      }\n\n      context.url = CMCDController.appendQueryToUri(context.url, query);\n    }\n  }\n  /**\n   * Apply CMCD data to a manifest request.\n   */\n  ;\n\n  /**\n   * The CMCD object type.\n   */\n  _proto.getObjectType = function getObjectType(fragment) {\n    var type = fragment.type;\n\n    if (type === 'subtitle') {\n      return _types_cmcd__WEBPACK_IMPORTED_MODULE_1__[\"CMCDObjectType\"].TIMED_TEXT;\n    }\n\n    if (fragment.sn === 'initSegment') {\n      return _types_cmcd__WEBPACK_IMPORTED_MODULE_1__[\"CMCDObjectType\"].INIT;\n    }\n\n    if (type === 'audio') {\n      return _types_cmcd__WEBPACK_IMPORTED_MODULE_1__[\"CMCDObjectType\"].AUDIO;\n    }\n\n    if (type === 'main') {\n      if (!this.hls.audioTracks.length) {\n        return _types_cmcd__WEBPACK_IMPORTED_MODULE_1__[\"CMCDObjectType\"].MUXED;\n      }\n\n      return _types_cmcd__WEBPACK_IMPORTED_MODULE_1__[\"CMCDObjectType\"].VIDEO;\n    }\n\n    return undefined;\n  }\n  /**\n   * Get the highest bitrate.\n   */\n  ;\n\n  _proto.getTopBandwidth = function getTopBandwidth(type) {\n    var bitrate = 0;\n    var levels;\n    var hls = this.hls;\n\n    if (type === _types_cmcd__WEBPACK_IMPORTED_MODULE_1__[\"CMCDObjectType\"].AUDIO) {\n      levels = hls.audioTracks;\n    } else {\n      var max = hls.maxAutoLevel;\n      var len = max > -1 ? max + 1 : hls.levels.length;\n      levels = hls.levels.slice(0, len);\n    }\n\n    for (var _iterator = _createForOfIteratorHelperLoose(levels), _step; !(_step = _iterator()).done;) {\n      var level = _step.value;\n\n      if (level.bitrate > bitrate) {\n        bitrate = level.bitrate;\n      }\n    }\n\n    return bitrate > 0 ? bitrate : NaN;\n  }\n  /**\n   * Get the buffer length for a media type in milliseconds\n   */\n  ;\n\n  _proto.getBufferLength = function getBufferLength(type) {\n    var media = this.hls.media;\n    var buffer = type === _types_cmcd__WEBPACK_IMPORTED_MODULE_1__[\"CMCDObjectType\"].AUDIO ? this.audioBuffer : this.videoBuffer;\n\n    if (!buffer || !media) {\n      return NaN;\n    }\n\n    var info = _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_2__[\"BufferHelper\"].bufferInfo(buffer, media.currentTime, this.config.maxBufferHole);\n    return info.len * 1000;\n  }\n  /**\n   * Create a playlist loader\n   */\n  ;\n\n  _proto.createPlaylistLoader = function createPlaylistLoader() {\n    var pLoader = this.config.pLoader;\n    var apply = this.applyPlaylistData;\n    var Ctor = pLoader || this.config.loader;\n    return /*#__PURE__*/function () {\n      function CmcdPlaylistLoader(config) {\n        this.loader = void 0;\n        this.loader = new Ctor(config);\n      }\n\n      var _proto2 = CmcdPlaylistLoader.prototype;\n\n      _proto2.destroy = function destroy() {\n        this.loader.destroy();\n      };\n\n      _proto2.abort = function abort() {\n        this.loader.abort();\n      };\n\n      _proto2.load = function load(context, config, callbacks) {\n        apply(context);\n        this.loader.load(context, config, callbacks);\n      };\n\n      _createClass(CmcdPlaylistLoader, [{\n        key: \"stats\",\n        get: function get() {\n          return this.loader.stats;\n        }\n      }, {\n        key: \"context\",\n        get: function get() {\n          return this.loader.context;\n        }\n      }]);\n\n      return CmcdPlaylistLoader;\n    }();\n  }\n  /**\n   * Create a playlist loader\n   */\n  ;\n\n  _proto.createFragmentLoader = function createFragmentLoader() {\n    var fLoader = this.config.fLoader;\n    var apply = this.applyFragmentData;\n    var Ctor = fLoader || this.config.loader;\n    return /*#__PURE__*/function () {\n      function CmcdFragmentLoader(config) {\n        this.loader = void 0;\n        this.loader = new Ctor(config);\n      }\n\n      var _proto3 = CmcdFragmentLoader.prototype;\n\n      _proto3.destroy = function destroy() {\n        this.loader.destroy();\n      };\n\n      _proto3.abort = function abort() {\n        this.loader.abort();\n      };\n\n      _proto3.load = function load(context, config, callbacks) {\n        apply(context);\n        this.loader.load(context, config, callbacks);\n      };\n\n      _createClass(CmcdFragmentLoader, [{\n        key: \"stats\",\n        get: function get() {\n          return this.loader.stats;\n        }\n      }, {\n        key: \"context\",\n        get: function get() {\n          return this.loader.context;\n        }\n      }]);\n\n      return CmcdFragmentLoader;\n    }();\n  }\n  /**\n   * Generate a random v4 UUI\n   *\n   * @returns {string}\n   */\n  ;\n\n  CMCDController.uuid = function uuid() {\n    var url = URL.createObjectURL(new Blob());\n    var uuid = url.toString();\n    URL.revokeObjectURL(url);\n    return uuid.substr(uuid.lastIndexOf('/') + 1);\n  }\n  /**\n   * Serialize a CMCD data object according to the rules defined in the\n   * section 3.2 of\n   * [CTA-5004](https://cdn.cta.tech/cta/media/media/resources/standards/pdfs/cta-5004-final.pdf).\n   */\n  ;\n\n  CMCDController.serialize = function serialize(data) {\n    var results = [];\n\n    var isValid = function isValid(value) {\n      return !Number.isNaN(value) && value != null && value !== '' && value !== false;\n    };\n\n    var toRounded = function toRounded(value) {\n      return Math.round(value);\n    };\n\n    var toHundred = function toHundred(value) {\n      return toRounded(value / 100) * 100;\n    };\n\n    var toUrlSafe = function toUrlSafe(value) {\n      return encodeURIComponent(value);\n    };\n\n    var formatters = {\n      br: toRounded,\n      d: toRounded,\n      bl: toHundred,\n      dl: toHundred,\n      mtp: toHundred,\n      nor: toUrlSafe,\n      rtp: toHundred,\n      tb: toRounded\n    };\n    var keys = Object.keys(data || {}).sort();\n\n    for (var _iterator2 = _createForOfIteratorHelperLoose(keys), _step2; !(_step2 = _iterator2()).done;) {\n      var key = _step2.value;\n      var value = data[key]; // ignore invalid values\n\n      if (!isValid(value)) {\n        continue;\n      } // Version should only be reported if not equal to 1.\n\n\n      if (key === 'v' && value === 1) {\n        continue;\n      } // Playback rate should only be sent if not equal to 1.\n\n\n      if (key == 'pr' && value === 1) {\n        continue;\n      } // Certain values require special formatting\n\n\n      var formatter = formatters[key];\n\n      if (formatter) {\n        value = formatter(value);\n      } // Serialize the key/value pair\n\n\n      var type = typeof value;\n      var result = void 0;\n\n      if (key === 'ot' || key === 'sf' || key === 'st') {\n        result = key + \"=\" + value;\n      } else if (type === 'boolean') {\n        result = key;\n      } else if (type === 'number') {\n        result = key + \"=\" + value;\n      } else {\n        result = key + \"=\" + JSON.stringify(value);\n      }\n\n      results.push(result);\n    }\n\n    return results.join(',');\n  }\n  /**\n   * Convert a CMCD data object to request headers according to the rules\n   * defined in the section 2.1 and 3.2 of\n   * [CTA-5004](https://cdn.cta.tech/cta/media/media/resources/standards/pdfs/cta-5004-final.pdf).\n   */\n  ;\n\n  CMCDController.toHeaders = function toHeaders(data) {\n    var keys = Object.keys(data);\n    var headers = {};\n    var headerNames = ['Object', 'Request', 'Session', 'Status'];\n    var headerGroups = [{}, {}, {}, {}];\n    var headerMap = {\n      br: 0,\n      d: 0,\n      ot: 0,\n      tb: 0,\n      bl: 1,\n      dl: 1,\n      mtp: 1,\n      nor: 1,\n      nrr: 1,\n      su: 1,\n      cid: 2,\n      pr: 2,\n      sf: 2,\n      sid: 2,\n      st: 2,\n      v: 2,\n      bs: 3,\n      rtp: 3\n    };\n\n    for (var _i = 0, _keys = keys; _i < _keys.length; _i++) {\n      var key = _keys[_i];\n      // Unmapped fields are mapped to the Request header\n      var index = headerMap[key] != null ? headerMap[key] : 1;\n      headerGroups[index][key] = data[key];\n    }\n\n    for (var i = 0; i < headerGroups.length; i++) {\n      var value = CMCDController.serialize(headerGroups[i]);\n\n      if (value) {\n        headers[\"CMCD-\" + headerNames[i]] = value;\n      }\n    }\n\n    return headers;\n  }\n  /**\n   * Convert a CMCD data object to query args according to the rules\n   * defined in the section 2.2 and 3.2 of\n   * [CTA-5004](https://cdn.cta.tech/cta/media/media/resources/standards/pdfs/cta-5004-final.pdf).\n   */\n  ;\n\n  CMCDController.toQuery = function toQuery(data) {\n    return \"CMCD=\" + encodeURIComponent(CMCDController.serialize(data));\n  }\n  /**\n   * Append query args to a uri.\n   */\n  ;\n\n  CMCDController.appendQueryToUri = function appendQueryToUri(uri, query) {\n    if (!query) {\n      return uri;\n    }\n\n    var separator = uri.includes('?') ? '&' : '?';\n    return \"\" + uri + separator + query;\n  };\n\n  return CMCDController;\n}();\n\n\n\n/***/ }),\n\n/***/ \"./src/controller/eme-controller.ts\":\n/*!******************************************!*\\\n  !*** ./src/controller/eme-controller.ts ***!\n  \\******************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_234739__) {\n\n\"use strict\";\n__nested_webpack_require_234739__.r(__webpack_exports__);\n/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_234739__(/*! ../events */ \"./src/events.ts\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_234739__(/*! ../errors */ \"./src/errors.ts\");\n/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_234739__(/*! ../utils/logger */ \"./src/utils/logger.ts\");\n/* harmony import */ var _utils_mediakeys_helper__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_234739__(/*! ../utils/mediakeys-helper */ \"./src/utils/mediakeys-helper.ts\");\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\n * @author Stephan Hesse <disparat@gmail.com> | <tchakabam@gmail.com>\n *\n * DRM support for Hls.js\n */\n\n\n\n\nvar MAX_LICENSE_REQUEST_FAILURES = 3;\n/**\n * @see https://developer.mozilla.org/en-US/docs/Web/API/MediaKeySystemConfiguration\n * @param {Array<string>} audioCodecs List of required audio codecs to support\n * @param {Array<string>} videoCodecs List of required video codecs to support\n * @param {object} drmSystemOptions Optional parameters/requirements for the key-system\n * @returns {Array<MediaSystemConfiguration>} An array of supported configurations\n */\n\nvar createWidevineMediaKeySystemConfigurations = function createWidevineMediaKeySystemConfigurations(audioCodecs, videoCodecs, drmSystemOptions) {\n  /* jshint ignore:line */\n  var baseConfig = {\n    // initDataTypes: ['keyids', 'mp4'],\n    // label: \"\",\n    // persistentState: \"not-allowed\", // or \"required\" ?\n    // distinctiveIdentifier: \"not-allowed\", // or \"required\" ?\n    // sessionTypes: ['temporary'],\n    audioCapabilities: [],\n    // { contentType: 'audio/mp4; codecs=\"mp4a.40.2\"' }\n    videoCapabilities: [] // { contentType: 'video/mp4; codecs=\"avc1.42E01E\"' }\n\n  };\n  audioCodecs.forEach(function (codec) {\n    baseConfig.audioCapabilities.push({\n      contentType: \"audio/mp4; codecs=\\\"\" + codec + \"\\\"\",\n      robustness: drmSystemOptions.audioRobustness || ''\n    });\n  });\n  videoCodecs.forEach(function (codec) {\n    baseConfig.videoCapabilities.push({\n      contentType: \"video/mp4; codecs=\\\"\" + codec + \"\\\"\",\n      robustness: drmSystemOptions.videoRobustness || ''\n    });\n  });\n  return [baseConfig];\n};\n/**\n * The idea here is to handle key-system (and their respective platforms) specific configuration differences\n * in order to work with the local requestMediaKeySystemAccess method.\n *\n * We can also rule-out platform-related key-system support at this point by throwing an error.\n *\n * @param {string} keySystem Identifier for the key-system, see `KeySystems` enum\n * @param {Array<string>} audioCodecs List of required audio codecs to support\n * @param {Array<string>} videoCodecs List of required video codecs to support\n * @throws will throw an error if a unknown key system is passed\n * @returns {Array<MediaSystemConfiguration>} A non-empty Array of MediaKeySystemConfiguration objects\n */\n\n\nvar getSupportedMediaKeySystemConfigurations = function getSupportedMediaKeySystemConfigurations(keySystem, audioCodecs, videoCodecs, drmSystemOptions) {\n  switch (keySystem) {\n    case _utils_mediakeys_helper__WEBPACK_IMPORTED_MODULE_3__[\"KeySystems\"].WIDEVINE:\n      return createWidevineMediaKeySystemConfigurations(audioCodecs, videoCodecs, drmSystemOptions);\n\n    default:\n      throw new Error(\"Unknown key-system: \" + keySystem);\n  }\n};\n\n/**\n * Controller to deal with encrypted media extensions (EME)\n * @see https://developer.mozilla.org/en-US/docs/Web/API/Encrypted_Media_Extensions_API\n *\n * @class\n * @constructor\n */\nvar EMEController = /*#__PURE__*/function () {\n  /**\n   * @constructs\n   * @param {Hls} hls Our Hls.js instance\n   */\n  function EMEController(hls) {\n    this.hls = void 0;\n    this._widevineLicenseUrl = void 0;\n    this._licenseXhrSetup = void 0;\n    this._licenseResponseCallback = void 0;\n    this._emeEnabled = void 0;\n    this._requestMediaKeySystemAccess = void 0;\n    this._drmSystemOptions = void 0;\n    this._config = void 0;\n    this._mediaKeysList = [];\n    this._media = null;\n    this._hasSetMediaKeys = false;\n    this._requestLicenseFailureCount = 0;\n    this.mediaKeysPromise = null;\n    this._onMediaEncrypted = this.onMediaEncrypted.bind(this);\n    this.hls = hls;\n    this._config = hls.config;\n    this._widevineLicenseUrl = this._config.widevineLicenseUrl;\n    this._licenseXhrSetup = this._config.licenseXhrSetup;\n    this._licenseResponseCallback = this._config.licenseResponseCallback;\n    this._emeEnabled = this._config.emeEnabled;\n    this._requestMediaKeySystemAccess = this._config.requestMediaKeySystemAccessFunc;\n    this._drmSystemOptions = this._config.drmSystemOptions;\n\n    this._registerListeners();\n  }\n\n  var _proto = EMEController.prototype;\n\n  _proto.destroy = function destroy() {\n    this._unregisterListeners(); // @ts-ignore\n\n\n    this.hls = this._onMediaEncrypted = null;\n    this._requestMediaKeySystemAccess = null;\n  };\n\n  _proto._registerListeners = function _registerListeners() {\n    this.hls.on(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].MEDIA_ATTACHED, this.onMediaAttached, this);\n    this.hls.on(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].MEDIA_DETACHED, this.onMediaDetached, this);\n    this.hls.on(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].MANIFEST_PARSED, this.onManifestParsed, this);\n  };\n\n  _proto._unregisterListeners = function _unregisterListeners() {\n    this.hls.off(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].MEDIA_ATTACHED, this.onMediaAttached, this);\n    this.hls.off(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].MEDIA_DETACHED, this.onMediaDetached, this);\n    this.hls.off(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].MANIFEST_PARSED, this.onManifestParsed, this);\n  }\n  /**\n   * @param {string} keySystem Identifier for the key-system, see `KeySystems` enum\n   * @returns {string} License server URL for key-system (if any configured, otherwise causes error)\n   * @throws if a unsupported keysystem is passed\n   */\n  ;\n\n  _proto.getLicenseServerUrl = function getLicenseServerUrl(keySystem) {\n    switch (keySystem) {\n      case _utils_mediakeys_helper__WEBPACK_IMPORTED_MODULE_3__[\"KeySystems\"].WIDEVINE:\n        if (!this._widevineLicenseUrl) {\n          break;\n        }\n\n        return this._widevineLicenseUrl;\n    }\n\n    throw new Error(\"no license server URL configured for key-system \\\"\" + keySystem + \"\\\"\");\n  }\n  /**\n   * Requests access object and adds it to our list upon success\n   * @private\n   * @param {string} keySystem System ID (see `KeySystems`)\n   * @param {Array<string>} audioCodecs List of required audio codecs to support\n   * @param {Array<string>} videoCodecs List of required video codecs to support\n   * @throws When a unsupported KeySystem is passed\n   */\n  ;\n\n  _proto._attemptKeySystemAccess = function _attemptKeySystemAccess(keySystem, audioCodecs, videoCodecs) {\n    var _this = this;\n\n    // This can throw, but is caught in event handler callpath\n    var mediaKeySystemConfigs = getSupportedMediaKeySystemConfigurations(keySystem, audioCodecs, videoCodecs, this._drmSystemOptions);\n    _utils_logger__WEBPACK_IMPORTED_MODULE_2__[\"logger\"].log('Requesting encrypted media key-system access'); // expecting interface like window.navigator.requestMediaKeySystemAccess\n\n    var keySystemAccessPromise = this.requestMediaKeySystemAccess(keySystem, mediaKeySystemConfigs);\n    this.mediaKeysPromise = keySystemAccessPromise.then(function (mediaKeySystemAccess) {\n      return _this._onMediaKeySystemAccessObtained(keySystem, mediaKeySystemAccess);\n    });\n    keySystemAccessPromise.catch(function (err) {\n      _utils_logger__WEBPACK_IMPORTED_MODULE_2__[\"logger\"].error(\"Failed to obtain key-system \\\"\" + keySystem + \"\\\" access:\", err);\n    });\n  };\n\n  /**\n   * Handles obtaining access to a key-system\n   * @private\n   * @param {string} keySystem\n   * @param {MediaKeySystemAccess} mediaKeySystemAccess https://developer.mozilla.org/en-US/docs/Web/API/MediaKeySystemAccess\n   */\n  _proto._onMediaKeySystemAccessObtained = function _onMediaKeySystemAccessObtained(keySystem, mediaKeySystemAccess) {\n    var _this2 = this;\n\n    _utils_logger__WEBPACK_IMPORTED_MODULE_2__[\"logger\"].log(\"Access for key-system \\\"\" + keySystem + \"\\\" obtained\");\n    var mediaKeysListItem = {\n      mediaKeysSessionInitialized: false,\n      mediaKeySystemAccess: mediaKeySystemAccess,\n      mediaKeySystemDomain: keySystem\n    };\n\n    this._mediaKeysList.push(mediaKeysListItem);\n\n    var mediaKeysPromise = Promise.resolve().then(function () {\n      return mediaKeySystemAccess.createMediaKeys();\n    }).then(function (mediaKeys) {\n      mediaKeysListItem.mediaKeys = mediaKeys;\n      _utils_logger__WEBPACK_IMPORTED_MODULE_2__[\"logger\"].log(\"Media-keys created for key-system \\\"\" + keySystem + \"\\\"\");\n\n      _this2._onMediaKeysCreated();\n\n      return mediaKeys;\n    });\n    mediaKeysPromise.catch(function (err) {\n      _utils_logger__WEBPACK_IMPORTED_MODULE_2__[\"logger\"].error('Failed to create media-keys:', err);\n    });\n    return mediaKeysPromise;\n  }\n  /**\n   * Handles key-creation (represents access to CDM). We are going to create key-sessions upon this\n   * for all existing keys where no session exists yet.\n   *\n   * @private\n   */\n  ;\n\n  _proto._onMediaKeysCreated = function _onMediaKeysCreated() {\n    var _this3 = this;\n\n    // check for all key-list items if a session exists, otherwise, create one\n    this._mediaKeysList.forEach(function (mediaKeysListItem) {\n      if (!mediaKeysListItem.mediaKeysSession) {\n        // mediaKeys is definitely initialized here\n        mediaKeysListItem.mediaKeysSession = mediaKeysListItem.mediaKeys.createSession();\n\n        _this3._onNewMediaKeySession(mediaKeysListItem.mediaKeysSession);\n      }\n    });\n  }\n  /**\n   * @private\n   * @param {*} keySession\n   */\n  ;\n\n  _proto._onNewMediaKeySession = function _onNewMediaKeySession(keySession) {\n    var _this4 = this;\n\n    _utils_logger__WEBPACK_IMPORTED_MODULE_2__[\"logger\"].log(\"New key-system session \" + keySession.sessionId);\n    keySession.addEventListener('message', function (event) {\n      _this4._onKeySessionMessage(keySession, event.message);\n    }, false);\n  }\n  /**\n   * @private\n   * @param {MediaKeySession} keySession\n   * @param {ArrayBuffer} message\n   */\n  ;\n\n  _proto._onKeySessionMessage = function _onKeySessionMessage(keySession, message) {\n    _utils_logger__WEBPACK_IMPORTED_MODULE_2__[\"logger\"].log('Got EME message event, creating license request');\n\n    this._requestLicense(message, function (data) {\n      _utils_logger__WEBPACK_IMPORTED_MODULE_2__[\"logger\"].log(\"Received license data (length: \" + (data ? data.byteLength : data) + \"), updating key-session\");\n      keySession.update(data);\n    });\n  }\n  /**\n   * @private\n   * @param e {MediaEncryptedEvent}\n   */\n  ;\n\n  _proto.onMediaEncrypted = function onMediaEncrypted(e) {\n    var _this5 = this;\n\n    _utils_logger__WEBPACK_IMPORTED_MODULE_2__[\"logger\"].log(\"Media is encrypted using \\\"\" + e.initDataType + \"\\\" init data type\");\n\n    if (!this.mediaKeysPromise) {\n      _utils_logger__WEBPACK_IMPORTED_MODULE_2__[\"logger\"].error('Fatal: Media is encrypted but no CDM access or no keys have been requested');\n      this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].ERROR, {\n        type: _errors__WEBPACK_IMPORTED_MODULE_1__[\"ErrorTypes\"].KEY_SYSTEM_ERROR,\n        details: _errors__WEBPACK_IMPORTED_MODULE_1__[\"ErrorDetails\"].KEY_SYSTEM_NO_KEYS,\n        fatal: true\n      });\n      return;\n    }\n\n    var finallySetKeyAndStartSession = function finallySetKeyAndStartSession(mediaKeys) {\n      if (!_this5._media) {\n        return;\n      }\n\n      _this5._attemptSetMediaKeys(mediaKeys);\n\n      _this5._generateRequestWithPreferredKeySession(e.initDataType, e.initData);\n    }; // Could use `Promise.finally` but some Promise polyfills are missing it\n\n\n    this.mediaKeysPromise.then(finallySetKeyAndStartSession).catch(finallySetKeyAndStartSession);\n  }\n  /**\n   * @private\n   */\n  ;\n\n  _proto._attemptSetMediaKeys = function _attemptSetMediaKeys(mediaKeys) {\n    if (!this._media) {\n      throw new Error('Attempted to set mediaKeys without first attaching a media element');\n    }\n\n    if (!this._hasSetMediaKeys) {\n      // FIXME: see if we can/want/need-to really to deal with several potential key-sessions?\n      var keysListItem = this._mediaKeysList[0];\n\n      if (!keysListItem || !keysListItem.mediaKeys) {\n        _utils_logger__WEBPACK_IMPORTED_MODULE_2__[\"logger\"].error('Fatal: Media is encrypted but no CDM access or no keys have been obtained yet');\n        this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].ERROR, {\n          type: _errors__WEBPACK_IMPORTED_MODULE_1__[\"ErrorTypes\"].KEY_SYSTEM_ERROR,\n          details: _errors__WEBPACK_IMPORTED_MODULE_1__[\"ErrorDetails\"].KEY_SYSTEM_NO_KEYS,\n          fatal: true\n        });\n        return;\n      }\n\n      _utils_logger__WEBPACK_IMPORTED_MODULE_2__[\"logger\"].log('Setting keys for encrypted media');\n\n      this._media.setMediaKeys(keysListItem.mediaKeys);\n\n      this._hasSetMediaKeys = true;\n    }\n  }\n  /**\n   * @private\n   */\n  ;\n\n  _proto._generateRequestWithPreferredKeySession = function _generateRequestWithPreferredKeySession(initDataType, initData) {\n    var _this6 = this;\n\n    // FIXME: see if we can/want/need-to really to deal with several potential key-sessions?\n    var keysListItem = this._mediaKeysList[0];\n\n    if (!keysListItem) {\n      _utils_logger__WEBPACK_IMPORTED_MODULE_2__[\"logger\"].error('Fatal: Media is encrypted but not any key-system access has been obtained yet');\n      this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].ERROR, {\n        type: _errors__WEBPACK_IMPORTED_MODULE_1__[\"ErrorTypes\"].KEY_SYSTEM_ERROR,\n        details: _errors__WEBPACK_IMPORTED_MODULE_1__[\"ErrorDetails\"].KEY_SYSTEM_NO_ACCESS,\n        fatal: true\n      });\n      return;\n    }\n\n    if (keysListItem.mediaKeysSessionInitialized) {\n      _utils_logger__WEBPACK_IMPORTED_MODULE_2__[\"logger\"].warn('Key-Session already initialized but requested again');\n      return;\n    }\n\n    var keySession = keysListItem.mediaKeysSession;\n\n    if (!keySession) {\n      _utils_logger__WEBPACK_IMPORTED_MODULE_2__[\"logger\"].error('Fatal: Media is encrypted but no key-session existing');\n      this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].ERROR, {\n        type: _errors__WEBPACK_IMPORTED_MODULE_1__[\"ErrorTypes\"].KEY_SYSTEM_ERROR,\n        details: _errors__WEBPACK_IMPORTED_MODULE_1__[\"ErrorDetails\"].KEY_SYSTEM_NO_SESSION,\n        fatal: true\n      });\n      return;\n    } // initData is null if the media is not CORS-same-origin\n\n\n    if (!initData) {\n      _utils_logger__WEBPACK_IMPORTED_MODULE_2__[\"logger\"].warn('Fatal: initData required for generating a key session is null');\n      this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].ERROR, {\n        type: _errors__WEBPACK_IMPORTED_MODULE_1__[\"ErrorTypes\"].KEY_SYSTEM_ERROR,\n        details: _errors__WEBPACK_IMPORTED_MODULE_1__[\"ErrorDetails\"].KEY_SYSTEM_NO_INIT_DATA,\n        fatal: true\n      });\n      return;\n    }\n\n    _utils_logger__WEBPACK_IMPORTED_MODULE_2__[\"logger\"].log(\"Generating key-session request for \\\"\" + initDataType + \"\\\" init data type\");\n    keysListItem.mediaKeysSessionInitialized = true;\n    keySession.generateRequest(initDataType, initData).then(function () {\n      _utils_logger__WEBPACK_IMPORTED_MODULE_2__[\"logger\"].debug('Key-session generation succeeded');\n    }).catch(function (err) {\n      _utils_logger__WEBPACK_IMPORTED_MODULE_2__[\"logger\"].error('Error generating key-session request:', err);\n\n      _this6.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].ERROR, {\n        type: _errors__WEBPACK_IMPORTED_MODULE_1__[\"ErrorTypes\"].KEY_SYSTEM_ERROR,\n        details: _errors__WEBPACK_IMPORTED_MODULE_1__[\"ErrorDetails\"].KEY_SYSTEM_NO_SESSION,\n        fatal: false\n      });\n    });\n  }\n  /**\n   * @private\n   * @param {string} url License server URL\n   * @param {ArrayBuffer} keyMessage Message data issued by key-system\n   * @param {function} callback Called when XHR has succeeded\n   * @returns {XMLHttpRequest} Unsent (but opened state) XHR object\n   * @throws if XMLHttpRequest construction failed\n   */\n  ;\n\n  _proto._createLicenseXhr = function _createLicenseXhr(url, keyMessage, callback) {\n    var xhr = new XMLHttpRequest();\n    xhr.responseType = 'arraybuffer';\n    xhr.onreadystatechange = this._onLicenseRequestReadyStageChange.bind(this, xhr, url, keyMessage, callback);\n    var licenseXhrSetup = this._licenseXhrSetup;\n\n    if (licenseXhrSetup) {\n      try {\n        licenseXhrSetup.call(this.hls, xhr, url);\n        licenseXhrSetup = undefined;\n      } catch (e) {\n        _utils_logger__WEBPACK_IMPORTED_MODULE_2__[\"logger\"].error(e);\n      }\n    }\n\n    try {\n      // if licenseXhrSetup did not yet call open, let's do it now\n      if (!xhr.readyState) {\n        xhr.open('POST', url, true);\n      }\n\n      if (licenseXhrSetup) {\n        licenseXhrSetup.call(this.hls, xhr, url);\n      }\n    } catch (e) {\n      // IE11 throws an exception on xhr.open if attempting to access an HTTP resource over HTTPS\n      throw new Error(\"issue setting up KeySystem license XHR \" + e);\n    }\n\n    return xhr;\n  }\n  /**\n   * @private\n   * @param {XMLHttpRequest} xhr\n   * @param {string} url License server URL\n   * @param {ArrayBuffer} keyMessage Message data issued by key-system\n   * @param {function} callback Called when XHR has succeeded\n   */\n  ;\n\n  _proto._onLicenseRequestReadyStageChange = function _onLicenseRequestReadyStageChange(xhr, url, keyMessage, callback) {\n    switch (xhr.readyState) {\n      case 4:\n        if (xhr.status === 200) {\n          this._requestLicenseFailureCount = 0;\n          _utils_logger__WEBPACK_IMPORTED_MODULE_2__[\"logger\"].log('License request succeeded');\n          var _data = xhr.response;\n          var licenseResponseCallback = this._licenseResponseCallback;\n\n          if (licenseResponseCallback) {\n            try {\n              _data = licenseResponseCallback.call(this.hls, xhr, url);\n            } catch (e) {\n              _utils_logger__WEBPACK_IMPORTED_MODULE_2__[\"logger\"].error(e);\n            }\n          }\n\n          callback(_data);\n        } else {\n          _utils_logger__WEBPACK_IMPORTED_MODULE_2__[\"logger\"].error(\"License Request XHR failed (\" + url + \"). Status: \" + xhr.status + \" (\" + xhr.statusText + \")\");\n          this._requestLicenseFailureCount++;\n\n          if (this._requestLicenseFailureCount > MAX_LICENSE_REQUEST_FAILURES) {\n            this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].ERROR, {\n              type: _errors__WEBPACK_IMPORTED_MODULE_1__[\"ErrorTypes\"].KEY_SYSTEM_ERROR,\n              details: _errors__WEBPACK_IMPORTED_MODULE_1__[\"ErrorDetails\"].KEY_SYSTEM_LICENSE_REQUEST_FAILED,\n              fatal: true\n            });\n            return;\n          }\n\n          var attemptsLeft = MAX_LICENSE_REQUEST_FAILURES - this._requestLicenseFailureCount + 1;\n          _utils_logger__WEBPACK_IMPORTED_MODULE_2__[\"logger\"].warn(\"Retrying license request, \" + attemptsLeft + \" attempts left\");\n\n          this._requestLicense(keyMessage, callback);\n        }\n\n        break;\n    }\n  }\n  /**\n   * @private\n   * @param {MediaKeysListItem} keysListItem\n   * @param {ArrayBuffer} keyMessage\n   * @returns {ArrayBuffer} Challenge data posted to license server\n   * @throws if KeySystem is unsupported\n   */\n  ;\n\n  _proto._generateLicenseRequestChallenge = function _generateLicenseRequestChallenge(keysListItem, keyMessage) {\n    switch (keysListItem.mediaKeySystemDomain) {\n      // case KeySystems.PLAYREADY:\n      // from https://github.com/MicrosoftEdge/Demos/blob/master/eme/scripts/demo.js\n\n      /*\n      if (this.licenseType !== this.LICENSE_TYPE_WIDEVINE) {\n        // For PlayReady CDMs, we need to dig the Challenge out of the XML.\n        var keyMessageXml = new DOMParser().parseFromString(String.fromCharCode.apply(null, new Uint16Array(keyMessage)), 'application/xml');\n        if (keyMessageXml.getElementsByTagName('Challenge')[0]) {\n            challenge = atob(keyMessageXml.getElementsByTagName('Challenge')[0].childNodes[0].nodeValue);\n        } else {\n            throw 'Cannot find <Challenge> in key message';\n        }\n        var headerNames = keyMessageXml.getElementsByTagName('name');\n        var headerValues = keyMessageXml.getElementsByTagName('value');\n        if (headerNames.length !== headerValues.length) {\n            throw 'Mismatched header <name>/<value> pair in key message';\n        }\n        for (var i = 0; i < headerNames.length; i++) {\n            xhr.setRequestHeader(headerNames[i].childNodes[0].nodeValue, headerValues[i].childNodes[0].nodeValue);\n        }\n      }\n      break;\n      */\n      case _utils_mediakeys_helper__WEBPACK_IMPORTED_MODULE_3__[\"KeySystems\"].WIDEVINE:\n        // For Widevine CDMs, the challenge is the keyMessage.\n        return keyMessage;\n    }\n\n    throw new Error(\"unsupported key-system: \" + keysListItem.mediaKeySystemDomain);\n  }\n  /**\n   * @private\n   * @param keyMessage\n   * @param callback\n   */\n  ;\n\n  _proto._requestLicense = function _requestLicense(keyMessage, callback) {\n    _utils_logger__WEBPACK_IMPORTED_MODULE_2__[\"logger\"].log('Requesting content license for key-system');\n    var keysListItem = this._mediaKeysList[0];\n\n    if (!keysListItem) {\n      _utils_logger__WEBPACK_IMPORTED_MODULE_2__[\"logger\"].error('Fatal error: Media is encrypted but no key-system access has been obtained yet');\n      this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].ERROR, {\n        type: _errors__WEBPACK_IMPORTED_MODULE_1__[\"ErrorTypes\"].KEY_SYSTEM_ERROR,\n        details: _errors__WEBPACK_IMPORTED_MODULE_1__[\"ErrorDetails\"].KEY_SYSTEM_NO_ACCESS,\n        fatal: true\n      });\n      return;\n    }\n\n    try {\n      var _url = this.getLicenseServerUrl(keysListItem.mediaKeySystemDomain);\n\n      var _xhr = this._createLicenseXhr(_url, keyMessage, callback);\n\n      _utils_logger__WEBPACK_IMPORTED_MODULE_2__[\"logger\"].log(\"Sending license request to URL: \" + _url);\n\n      var challenge = this._generateLicenseRequestChallenge(keysListItem, keyMessage);\n\n      _xhr.send(challenge);\n    } catch (e) {\n      _utils_logger__WEBPACK_IMPORTED_MODULE_2__[\"logger\"].error(\"Failure requesting DRM license: \" + e);\n      this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].ERROR, {\n        type: _errors__WEBPACK_IMPORTED_MODULE_1__[\"ErrorTypes\"].KEY_SYSTEM_ERROR,\n        details: _errors__WEBPACK_IMPORTED_MODULE_1__[\"ErrorDetails\"].KEY_SYSTEM_LICENSE_REQUEST_FAILED,\n        fatal: true\n      });\n    }\n  };\n\n  _proto.onMediaAttached = function onMediaAttached(event, data) {\n    if (!this._emeEnabled) {\n      return;\n    }\n\n    var media = data.media; // keep reference of media\n\n    this._media = media;\n    media.addEventListener('encrypted', this._onMediaEncrypted);\n  };\n\n  _proto.onMediaDetached = function onMediaDetached() {\n    var media = this._media;\n    var mediaKeysList = this._mediaKeysList;\n\n    if (!media) {\n      return;\n    }\n\n    media.removeEventListener('encrypted', this._onMediaEncrypted);\n    this._media = null;\n    this._mediaKeysList = []; // Close all sessions and remove media keys from the video element.\n\n    Promise.all(mediaKeysList.map(function (mediaKeysListItem) {\n      if (mediaKeysListItem.mediaKeysSession) {\n        return mediaKeysListItem.mediaKeysSession.close().catch(function () {// Ignore errors when closing the sessions. Closing a session that\n          // generated no key requests will throw an error.\n        });\n      }\n    })).then(function () {\n      return media.setMediaKeys(null);\n    }).catch(function () {// Ignore any failures while removing media keys from the video element.\n    });\n  };\n\n  _proto.onManifestParsed = function onManifestParsed(event, data) {\n    if (!this._emeEnabled) {\n      return;\n    }\n\n    var audioCodecs = data.levels.map(function (level) {\n      return level.audioCodec;\n    }).filter(function (audioCodec) {\n      return !!audioCodec;\n    });\n    var videoCodecs = data.levels.map(function (level) {\n      return level.videoCodec;\n    }).filter(function (videoCodec) {\n      return !!videoCodec;\n    });\n\n    this._attemptKeySystemAccess(_utils_mediakeys_helper__WEBPACK_IMPORTED_MODULE_3__[\"KeySystems\"].WIDEVINE, audioCodecs, videoCodecs);\n  };\n\n  _createClass(EMEController, [{\n    key: \"requestMediaKeySystemAccess\",\n    get: function get() {\n      if (!this._requestMediaKeySystemAccess) {\n        throw new Error('No requestMediaKeySystemAccess function configured');\n      }\n\n      return this._requestMediaKeySystemAccess;\n    }\n  }]);\n\n  return EMEController;\n}();\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (EMEController);\n\n/***/ }),\n\n/***/ \"./src/controller/fps-controller.ts\":\n/*!******************************************!*\\\n  !*** ./src/controller/fps-controller.ts ***!\n  \\******************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_260308__) {\n\n\"use strict\";\n__nested_webpack_require_260308__.r(__webpack_exports__);\n/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_260308__(/*! ../events */ \"./src/events.ts\");\n/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_260308__(/*! ../utils/logger */ \"./src/utils/logger.ts\");\n\n\n\nvar FPSController = /*#__PURE__*/function () {\n  // stream controller must be provided as a dependency!\n  function FPSController(hls) {\n    this.hls = void 0;\n    this.isVideoPlaybackQualityAvailable = false;\n    this.timer = void 0;\n    this.media = null;\n    this.lastTime = void 0;\n    this.lastDroppedFrames = 0;\n    this.lastDecodedFrames = 0;\n    this.streamController = void 0;\n    this.hls = hls;\n    this.registerListeners();\n  }\n\n  var _proto = FPSController.prototype;\n\n  _proto.setStreamController = function setStreamController(streamController) {\n    this.streamController = streamController;\n  };\n\n  _proto.registerListeners = function registerListeners() {\n    this.hls.on(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].MEDIA_ATTACHING, this.onMediaAttaching, this);\n  };\n\n  _proto.unregisterListeners = function unregisterListeners() {\n    this.hls.off(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].MEDIA_ATTACHING, this.onMediaAttaching);\n  };\n\n  _proto.destroy = function destroy() {\n    if (this.timer) {\n      clearInterval(this.timer);\n    }\n\n    this.unregisterListeners();\n    this.isVideoPlaybackQualityAvailable = false;\n    this.media = null;\n  };\n\n  _proto.onMediaAttaching = function onMediaAttaching(event, data) {\n    var config = this.hls.config;\n\n    if (config.capLevelOnFPSDrop) {\n      var media = data.media instanceof self.HTMLVideoElement ? data.media : null;\n      this.media = media;\n\n      if (media && typeof media.getVideoPlaybackQuality === 'function') {\n        this.isVideoPlaybackQualityAvailable = true;\n      }\n\n      self.clearInterval(this.timer);\n      this.timer = self.setInterval(this.checkFPSInterval.bind(this), config.fpsDroppedMonitoringPeriod);\n    }\n  };\n\n  _proto.checkFPS = function checkFPS(video, decodedFrames, droppedFrames) {\n    var currentTime = performance.now();\n\n    if (decodedFrames) {\n      if (this.lastTime) {\n        var currentPeriod = currentTime - this.lastTime;\n        var currentDropped = droppedFrames - this.lastDroppedFrames;\n        var currentDecoded = decodedFrames - this.lastDecodedFrames;\n        var droppedFPS = 1000 * currentDropped / currentPeriod;\n        var hls = this.hls;\n        hls.trigger(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].FPS_DROP, {\n          currentDropped: currentDropped,\n          currentDecoded: currentDecoded,\n          totalDroppedFrames: droppedFrames\n        });\n\n        if (droppedFPS > 0) {\n          // logger.log('checkFPS : droppedFPS/decodedFPS:' + droppedFPS/(1000 * currentDecoded / currentPeriod));\n          if (currentDropped > hls.config.fpsDroppedMonitoringThreshold * currentDecoded) {\n            var currentLevel = hls.currentLevel;\n            _utils_logger__WEBPACK_IMPORTED_MODULE_1__[\"logger\"].warn('drop FPS ratio greater than max allowed value for currentLevel: ' + currentLevel);\n\n            if (currentLevel > 0 && (hls.autoLevelCapping === -1 || hls.autoLevelCapping >= currentLevel)) {\n              currentLevel = currentLevel - 1;\n              hls.trigger(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].FPS_DROP_LEVEL_CAPPING, {\n                level: currentLevel,\n                droppedLevel: hls.currentLevel\n              });\n              hls.autoLevelCapping = currentLevel;\n              this.streamController.nextLevelSwitch();\n            }\n          }\n        }\n      }\n\n      this.lastTime = currentTime;\n      this.lastDroppedFrames = droppedFrames;\n      this.lastDecodedFrames = decodedFrames;\n    }\n  };\n\n  _proto.checkFPSInterval = function checkFPSInterval() {\n    var video = this.media;\n\n    if (video) {\n      if (this.isVideoPlaybackQualityAvailable) {\n        var videoPlaybackQuality = video.getVideoPlaybackQuality();\n        this.checkFPS(video, videoPlaybackQuality.totalVideoFrames, videoPlaybackQuality.droppedVideoFrames);\n      } else {\n        // HTMLVideoElement doesn't include the webkit types\n        this.checkFPS(video, video.webkitDecodedFrameCount, video.webkitDroppedFrameCount);\n      }\n    }\n  };\n\n  return FPSController;\n}();\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (FPSController);\n\n/***/ }),\n\n/***/ \"./src/controller/fragment-finders.ts\":\n/*!********************************************!*\\\n  !*** ./src/controller/fragment-finders.ts ***!\n  \\********************************************/\n/*! exports provided: findFragmentByPDT, findFragmentByPTS, fragmentWithinToleranceTest, pdtWithinToleranceTest, findFragWithCC */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_265150__) {\n\n\"use strict\";\n__nested_webpack_require_265150__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_265150__.d(__webpack_exports__, \"findFragmentByPDT\", function() { return findFragmentByPDT; });\n/* harmony export (binding) */ __nested_webpack_require_265150__.d(__webpack_exports__, \"findFragmentByPTS\", function() { return findFragmentByPTS; });\n/* harmony export (binding) */ __nested_webpack_require_265150__.d(__webpack_exports__, \"fragmentWithinToleranceTest\", function() { return fragmentWithinToleranceTest; });\n/* harmony export (binding) */ __nested_webpack_require_265150__.d(__webpack_exports__, \"pdtWithinToleranceTest\", function() { return pdtWithinToleranceTest; });\n/* harmony export (binding) */ __nested_webpack_require_265150__.d(__webpack_exports__, \"findFragWithCC\", function() { return findFragWithCC; });\n/* harmony import */ var _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_265150__(/*! ./src/polyfills/number */ \"./src/polyfills/number.ts\");\n/* harmony import */ var _utils_binary_search__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_265150__(/*! ../utils/binary-search */ \"./src/utils/binary-search.ts\");\n\n\n\n/**\n * Returns first fragment whose endPdt value exceeds the given PDT.\n * @param {Array<Fragment>} fragments - The array of candidate fragments\n * @param {number|null} [PDTValue = null] - The PDT value which must be exceeded\n * @param {number} [maxFragLookUpTolerance = 0] - The amount of time that a fragment's start/end can be within in order to be considered contiguous\n * @returns {*|null} fragment - The best matching fragment\n */\nfunction findFragmentByPDT(fragments, PDTValue, maxFragLookUpTolerance) {\n  if (PDTValue === null || !Array.isArray(fragments) || !fragments.length || !Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__[\"isFiniteNumber\"])(PDTValue)) {\n    return null;\n  } // if less than start\n\n\n  var startPDT = fragments[0].programDateTime;\n\n  if (PDTValue < (startPDT || 0)) {\n    return null;\n  }\n\n  var endPDT = fragments[fragments.length - 1].endProgramDateTime;\n\n  if (PDTValue >= (endPDT || 0)) {\n    return null;\n  }\n\n  maxFragLookUpTolerance = maxFragLookUpTolerance || 0;\n\n  for (var seg = 0; seg < fragments.length; ++seg) {\n    var frag = fragments[seg];\n\n    if (pdtWithinToleranceTest(PDTValue, maxFragLookUpTolerance, frag)) {\n      return frag;\n    }\n  }\n\n  return null;\n}\n/**\n * Finds a fragment based on the SN of the previous fragment; or based on the needs of the current buffer.\n * This method compensates for small buffer gaps by applying a tolerance to the start of any candidate fragment, thus\n * breaking any traps which would cause the same fragment to be continuously selected within a small range.\n * @param {*} fragPrevious - The last frag successfully appended\n * @param {Array} fragments - The array of candidate fragments\n * @param {number} [bufferEnd = 0] - The end of the contiguous buffered range the playhead is currently within\n * @param {number} maxFragLookUpTolerance - The amount of time that a fragment's start/end can be within in order to be considered contiguous\n * @returns {*} foundFrag - The best matching fragment\n */\n\nfunction findFragmentByPTS(fragPrevious, fragments, bufferEnd, maxFragLookUpTolerance) {\n  if (bufferEnd === void 0) {\n    bufferEnd = 0;\n  }\n\n  if (maxFragLookUpTolerance === void 0) {\n    maxFragLookUpTolerance = 0;\n  }\n\n  var fragNext = null;\n\n  if (fragPrevious) {\n    fragNext = fragments[fragPrevious.sn - fragments[0].sn + 1] || null;\n  } else if (bufferEnd === 0 && fragments[0].start === 0) {\n    fragNext = fragments[0];\n  } // Prefer the next fragment if it's within tolerance\n\n\n  if (fragNext && fragmentWithinToleranceTest(bufferEnd, maxFragLookUpTolerance, fragNext) === 0) {\n    return fragNext;\n  } // We might be seeking past the tolerance so find the best match\n\n\n  var foundFragment = _utils_binary_search__WEBPACK_IMPORTED_MODULE_1__[\"default\"].search(fragments, fragmentWithinToleranceTest.bind(null, bufferEnd, maxFragLookUpTolerance));\n\n  if (foundFragment) {\n    return foundFragment;\n  } // If no match was found return the next fragment after fragPrevious, or null\n\n\n  return fragNext;\n}\n/**\n * The test function used by the findFragmentBySn's BinarySearch to look for the best match to the current buffer conditions.\n * @param {*} candidate - The fragment to test\n * @param {number} [bufferEnd = 0] - The end of the current buffered range the playhead is currently within\n * @param {number} [maxFragLookUpTolerance = 0] - The amount of time that a fragment's start can be within in order to be considered contiguous\n * @returns {number} - 0 if it matches, 1 if too low, -1 if too high\n */\n\nfunction fragmentWithinToleranceTest(bufferEnd, maxFragLookUpTolerance, candidate) {\n  if (bufferEnd === void 0) {\n    bufferEnd = 0;\n  }\n\n  if (maxFragLookUpTolerance === void 0) {\n    maxFragLookUpTolerance = 0;\n  }\n\n  // offset should be within fragment boundary - config.maxFragLookUpTolerance\n  // this is to cope with situations like\n  // bufferEnd = 9.991\n  // frag[Ø] : [0,10]\n  // frag[1] : [10,20]\n  // bufferEnd is within frag[0] range ... although what we are expecting is to return frag[1] here\n  //              frag start               frag start+duration\n  //                  |-----------------------------|\n  //              <--->                         <--->\n  //  ...--------><-----------------------------><---------....\n  // previous frag         matching fragment         next frag\n  //  return -1             return 0                 return 1\n  // logger.log(`level/sn/start/end/bufEnd:${level}/${candidate.sn}/${candidate.start}/${(candidate.start+candidate.duration)}/${bufferEnd}`);\n  // Set the lookup tolerance to be small enough to detect the current segment - ensures we don't skip over very small segments\n  var candidateLookupTolerance = Math.min(maxFragLookUpTolerance, candidate.duration + (candidate.deltaPTS ? candidate.deltaPTS : 0));\n\n  if (candidate.start + candidate.duration - candidateLookupTolerance <= bufferEnd) {\n    return 1;\n  } else if (candidate.start - candidateLookupTolerance > bufferEnd && candidate.start) {\n    // if maxFragLookUpTolerance will have negative value then don't return -1 for first element\n    return -1;\n  }\n\n  return 0;\n}\n/**\n * The test function used by the findFragmentByPdt's BinarySearch to look for the best match to the current buffer conditions.\n * This function tests the candidate's program date time values, as represented in Unix time\n * @param {*} candidate - The fragment to test\n * @param {number} [pdtBufferEnd = 0] - The Unix time representing the end of the current buffered range\n * @param {number} [maxFragLookUpTolerance = 0] - The amount of time that a fragment's start can be within in order to be considered contiguous\n * @returns {boolean} True if contiguous, false otherwise\n */\n\nfunction pdtWithinToleranceTest(pdtBufferEnd, maxFragLookUpTolerance, candidate) {\n  var candidateLookupTolerance = Math.min(maxFragLookUpTolerance, candidate.duration + (candidate.deltaPTS ? candidate.deltaPTS : 0)) * 1000; // endProgramDateTime can be null, default to zero\n\n  var endProgramDateTime = candidate.endProgramDateTime || 0;\n  return endProgramDateTime - candidateLookupTolerance > pdtBufferEnd;\n}\nfunction findFragWithCC(fragments, cc) {\n  return _utils_binary_search__WEBPACK_IMPORTED_MODULE_1__[\"default\"].search(fragments, function (candidate) {\n    if (candidate.cc < cc) {\n      return 1;\n    } else if (candidate.cc > cc) {\n      return -1;\n    } else {\n      return 0;\n    }\n  });\n}\n\n/***/ }),\n\n/***/ \"./src/controller/fragment-tracker.ts\":\n/*!********************************************!*\\\n  !*** ./src/controller/fragment-tracker.ts ***!\n  \\********************************************/\n/*! exports provided: FragmentState, FragmentTracker */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_273034__) {\n\n\"use strict\";\n__nested_webpack_require_273034__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_273034__.d(__webpack_exports__, \"FragmentState\", function() { return FragmentState; });\n/* harmony export (binding) */ __nested_webpack_require_273034__.d(__webpack_exports__, \"FragmentTracker\", function() { return FragmentTracker; });\n/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_273034__(/*! ../events */ \"./src/events.ts\");\n/* harmony import */ var _types_loader__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_273034__(/*! ../types/loader */ \"./src/types/loader.ts\");\n\n\nvar FragmentState;\n\n(function (FragmentState) {\n  FragmentState[\"NOT_LOADED\"] = \"NOT_LOADED\";\n  FragmentState[\"BACKTRACKED\"] = \"BACKTRACKED\";\n  FragmentState[\"APPENDING\"] = \"APPENDING\";\n  FragmentState[\"PARTIAL\"] = \"PARTIAL\";\n  FragmentState[\"OK\"] = \"OK\";\n})(FragmentState || (FragmentState = {}));\n\nvar FragmentTracker = /*#__PURE__*/function () {\n  function FragmentTracker(hls) {\n    this.activeFragment = null;\n    this.activeParts = null;\n    this.fragments = Object.create(null);\n    this.timeRanges = Object.create(null);\n    this.bufferPadding = 0.2;\n    this.hls = void 0;\n    this.hls = hls;\n\n    this._registerListeners();\n  }\n\n  var _proto = FragmentTracker.prototype;\n\n  _proto._registerListeners = function _registerListeners() {\n    var hls = this.hls;\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].BUFFER_APPENDED, this.onBufferAppended, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].FRAG_BUFFERED, this.onFragBuffered, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].FRAG_LOADED, this.onFragLoaded, this);\n  };\n\n  _proto._unregisterListeners = function _unregisterListeners() {\n    var hls = this.hls;\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].BUFFER_APPENDED, this.onBufferAppended, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].FRAG_BUFFERED, this.onFragBuffered, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].FRAG_LOADED, this.onFragLoaded, this);\n  };\n\n  _proto.destroy = function destroy() {\n    this._unregisterListeners(); // @ts-ignore\n\n\n    this.fragments = this.timeRanges = null;\n  }\n  /**\n   * Return a Fragment with an appended range that matches the position and levelType.\n   * If not found any Fragment, return null\n   */\n  ;\n\n  _proto.getAppendedFrag = function getAppendedFrag(position, levelType) {\n    if (levelType === _types_loader__WEBPACK_IMPORTED_MODULE_1__[\"PlaylistLevelType\"].MAIN) {\n      var activeFragment = this.activeFragment,\n          activeParts = this.activeParts;\n\n      if (!activeFragment) {\n        return null;\n      }\n\n      if (activeParts) {\n        for (var i = activeParts.length; i--;) {\n          var activePart = activeParts[i];\n          var appendedPTS = activePart ? activePart.end : activeFragment.appendedPTS;\n\n          if (activePart.start <= position && appendedPTS !== undefined && position <= appendedPTS) {\n            // 9 is a magic number. remove parts from lookup after a match but keep some short seeks back.\n            if (i > 9) {\n              this.activeParts = activeParts.slice(i - 9);\n            }\n\n            return activePart;\n          }\n        }\n      } else if (activeFragment.start <= position && activeFragment.appendedPTS !== undefined && position <= activeFragment.appendedPTS) {\n        return activeFragment;\n      }\n    }\n\n    return this.getBufferedFrag(position, levelType);\n  }\n  /**\n   * Return a buffered Fragment that matches the position and levelType.\n   * A buffered Fragment is one whose loading, parsing and appending is done (completed or \"partial\" meaning aborted).\n   * If not found any Fragment, return null\n   */\n  ;\n\n  _proto.getBufferedFrag = function getBufferedFrag(position, levelType) {\n    var fragments = this.fragments;\n    var keys = Object.keys(fragments);\n\n    for (var i = keys.length; i--;) {\n      var fragmentEntity = fragments[keys[i]];\n\n      if ((fragmentEntity === null || fragmentEntity === void 0 ? void 0 : fragmentEntity.body.type) === levelType && fragmentEntity.buffered) {\n        var frag = fragmentEntity.body;\n\n        if (frag.start <= position && position <= frag.end) {\n          return frag;\n        }\n      }\n    }\n\n    return null;\n  }\n  /**\n   * Partial fragments effected by coded frame eviction will be removed\n   * The browser will unload parts of the buffer to free up memory for new buffer data\n   * Fragments will need to be reloaded when the buffer is freed up, removing partial fragments will allow them to reload(since there might be parts that are still playable)\n   */\n  ;\n\n  _proto.detectEvictedFragments = function detectEvictedFragments(elementaryStream, timeRange, playlistType) {\n    var _this = this;\n\n    // Check if any flagged fragments have been unloaded\n    Object.keys(this.fragments).forEach(function (key) {\n      var fragmentEntity = _this.fragments[key];\n\n      if (!fragmentEntity) {\n        return;\n      }\n\n      if (!fragmentEntity.buffered) {\n        if (fragmentEntity.body.type === playlistType) {\n          _this.removeFragment(fragmentEntity.body);\n        }\n\n        return;\n      }\n\n      var esData = fragmentEntity.range[elementaryStream];\n\n      if (!esData) {\n        return;\n      }\n\n      esData.time.some(function (time) {\n        var isNotBuffered = !_this.isTimeBuffered(time.startPTS, time.endPTS, timeRange);\n\n        if (isNotBuffered) {\n          // Unregister partial fragment as it needs to load again to be reused\n          _this.removeFragment(fragmentEntity.body);\n        }\n\n        return isNotBuffered;\n      });\n    });\n  }\n  /**\n   * Checks if the fragment passed in is loaded in the buffer properly\n   * Partially loaded fragments will be registered as a partial fragment\n   */\n  ;\n\n  _proto.detectPartialFragments = function detectPartialFragments(data) {\n    var _this2 = this;\n\n    var timeRanges = this.timeRanges;\n    var frag = data.frag,\n        part = data.part;\n\n    if (!timeRanges || frag.sn === 'initSegment') {\n      return;\n    }\n\n    var fragKey = getFragmentKey(frag);\n    var fragmentEntity = this.fragments[fragKey];\n\n    if (!fragmentEntity) {\n      return;\n    }\n\n    Object.keys(timeRanges).forEach(function (elementaryStream) {\n      var streamInfo = frag.elementaryStreams[elementaryStream];\n\n      if (!streamInfo) {\n        return;\n      }\n\n      var timeRange = timeRanges[elementaryStream];\n      var partial = part !== null || streamInfo.partial === true;\n      fragmentEntity.range[elementaryStream] = _this2.getBufferedTimes(frag, part, partial, timeRange);\n    });\n    fragmentEntity.backtrack = fragmentEntity.loaded = null;\n\n    if (Object.keys(fragmentEntity.range).length) {\n      fragmentEntity.buffered = true;\n    } else {\n      // remove fragment if nothing was appended\n      this.removeFragment(fragmentEntity.body);\n    }\n  };\n\n  _proto.fragBuffered = function fragBuffered(frag) {\n    var fragKey = getFragmentKey(frag);\n    var fragmentEntity = this.fragments[fragKey];\n\n    if (fragmentEntity) {\n      fragmentEntity.backtrack = fragmentEntity.loaded = null;\n      fragmentEntity.buffered = true;\n    }\n  };\n\n  _proto.getBufferedTimes = function getBufferedTimes(fragment, part, partial, timeRange) {\n    var buffered = {\n      time: [],\n      partial: partial\n    };\n    var startPTS = part ? part.start : fragment.start;\n    var endPTS = part ? part.end : fragment.end;\n    var minEndPTS = fragment.minEndPTS || endPTS;\n    var maxStartPTS = fragment.maxStartPTS || startPTS;\n\n    for (var i = 0; i < timeRange.length; i++) {\n      var startTime = timeRange.start(i) - this.bufferPadding;\n      var endTime = timeRange.end(i) + this.bufferPadding;\n\n      if (maxStartPTS >= startTime && minEndPTS <= endTime) {\n        // Fragment is entirely contained in buffer\n        // No need to check the other timeRange times since it's completely playable\n        buffered.time.push({\n          startPTS: Math.max(startPTS, timeRange.start(i)),\n          endPTS: Math.min(endPTS, timeRange.end(i))\n        });\n        break;\n      } else if (startPTS < endTime && endPTS > startTime) {\n        buffered.partial = true; // Check for intersection with buffer\n        // Get playable sections of the fragment\n\n        buffered.time.push({\n          startPTS: Math.max(startPTS, timeRange.start(i)),\n          endPTS: Math.min(endPTS, timeRange.end(i))\n        });\n      } else if (endPTS <= startTime) {\n        // No need to check the rest of the timeRange as it is in order\n        break;\n      }\n    }\n\n    return buffered;\n  }\n  /**\n   * Gets the partial fragment for a certain time\n   */\n  ;\n\n  _proto.getPartialFragment = function getPartialFragment(time) {\n    var bestFragment = null;\n    var timePadding;\n    var startTime;\n    var endTime;\n    var bestOverlap = 0;\n    var bufferPadding = this.bufferPadding,\n        fragments = this.fragments;\n    Object.keys(fragments).forEach(function (key) {\n      var fragmentEntity = fragments[key];\n\n      if (!fragmentEntity) {\n        return;\n      }\n\n      if (isPartial(fragmentEntity)) {\n        startTime = fragmentEntity.body.start - bufferPadding;\n        endTime = fragmentEntity.body.end + bufferPadding;\n\n        if (time >= startTime && time <= endTime) {\n          // Use the fragment that has the most padding from start and end time\n          timePadding = Math.min(time - startTime, endTime - time);\n\n          if (bestOverlap <= timePadding) {\n            bestFragment = fragmentEntity.body;\n            bestOverlap = timePadding;\n          }\n        }\n      }\n    });\n    return bestFragment;\n  };\n\n  _proto.getState = function getState(fragment) {\n    var fragKey = getFragmentKey(fragment);\n    var fragmentEntity = this.fragments[fragKey];\n\n    if (fragmentEntity) {\n      if (!fragmentEntity.buffered) {\n        if (fragmentEntity.backtrack) {\n          return FragmentState.BACKTRACKED;\n        }\n\n        return FragmentState.APPENDING;\n      } else if (isPartial(fragmentEntity)) {\n        return FragmentState.PARTIAL;\n      } else {\n        return FragmentState.OK;\n      }\n    }\n\n    return FragmentState.NOT_LOADED;\n  };\n\n  _proto.backtrack = function backtrack(frag, data) {\n    var fragKey = getFragmentKey(frag);\n    var fragmentEntity = this.fragments[fragKey];\n\n    if (!fragmentEntity || fragmentEntity.backtrack) {\n      return null;\n    }\n\n    var backtrack = fragmentEntity.backtrack = data ? data : fragmentEntity.loaded;\n    fragmentEntity.loaded = null;\n    return backtrack;\n  };\n\n  _proto.getBacktrackData = function getBacktrackData(fragment) {\n    var fragKey = getFragmentKey(fragment);\n    var fragmentEntity = this.fragments[fragKey];\n\n    if (fragmentEntity) {\n      var _backtrack$payload;\n\n      var backtrack = fragmentEntity.backtrack; // If data was already sent to Worker it is detached no longer available\n\n      if (backtrack !== null && backtrack !== void 0 && (_backtrack$payload = backtrack.payload) !== null && _backtrack$payload !== void 0 && _backtrack$payload.byteLength) {\n        return backtrack;\n      } else {\n        this.removeFragment(fragment);\n      }\n    }\n\n    return null;\n  };\n\n  _proto.isTimeBuffered = function isTimeBuffered(startPTS, endPTS, timeRange) {\n    var startTime;\n    var endTime;\n\n    for (var i = 0; i < timeRange.length; i++) {\n      startTime = timeRange.start(i) - this.bufferPadding;\n      endTime = timeRange.end(i) + this.bufferPadding;\n\n      if (startPTS >= startTime && endPTS <= endTime) {\n        return true;\n      }\n\n      if (endPTS <= startTime) {\n        // No need to check the rest of the timeRange as it is in order\n        return false;\n      }\n    }\n\n    return false;\n  };\n\n  _proto.onFragLoaded = function onFragLoaded(event, data) {\n    var frag = data.frag,\n        part = data.part; // don't track initsegment (for which sn is not a number)\n    // don't track frags used for bitrateTest, they're irrelevant.\n    // don't track parts for memory efficiency\n\n    if (frag.sn === 'initSegment' || frag.bitrateTest || part) {\n      return;\n    }\n\n    var fragKey = getFragmentKey(frag);\n    this.fragments[fragKey] = {\n      body: frag,\n      loaded: data,\n      backtrack: null,\n      buffered: false,\n      range: Object.create(null)\n    };\n  };\n\n  _proto.onBufferAppended = function onBufferAppended(event, data) {\n    var _this3 = this;\n\n    var frag = data.frag,\n        part = data.part,\n        timeRanges = data.timeRanges;\n\n    if (frag.type === _types_loader__WEBPACK_IMPORTED_MODULE_1__[\"PlaylistLevelType\"].MAIN) {\n      this.activeFragment = frag;\n\n      if (part) {\n        var activeParts = this.activeParts;\n\n        if (!activeParts) {\n          this.activeParts = activeParts = [];\n        }\n\n        activeParts.push(part);\n      } else {\n        this.activeParts = null;\n      }\n    } // Store the latest timeRanges loaded in the buffer\n\n\n    this.timeRanges = timeRanges;\n    Object.keys(timeRanges).forEach(function (elementaryStream) {\n      var timeRange = timeRanges[elementaryStream];\n\n      _this3.detectEvictedFragments(elementaryStream, timeRange);\n\n      if (!part) {\n        for (var i = 0; i < timeRange.length; i++) {\n          frag.appendedPTS = Math.max(timeRange.end(i), frag.appendedPTS || 0);\n        }\n      }\n    });\n  };\n\n  _proto.onFragBuffered = function onFragBuffered(event, data) {\n    this.detectPartialFragments(data);\n  };\n\n  _proto.hasFragment = function hasFragment(fragment) {\n    var fragKey = getFragmentKey(fragment);\n    return !!this.fragments[fragKey];\n  };\n\n  _proto.removeFragmentsInRange = function removeFragmentsInRange(start, end, playlistType) {\n    var _this4 = this;\n\n    Object.keys(this.fragments).forEach(function (key) {\n      var fragmentEntity = _this4.fragments[key];\n\n      if (!fragmentEntity) {\n        return;\n      }\n\n      if (fragmentEntity.buffered) {\n        var frag = fragmentEntity.body;\n\n        if (frag.type === playlistType && frag.start < end && frag.end > start) {\n          _this4.removeFragment(frag);\n        }\n      }\n    });\n  };\n\n  _proto.removeFragment = function removeFragment(fragment) {\n    var fragKey = getFragmentKey(fragment);\n    fragment.stats.loaded = 0;\n    fragment.clearElementaryStreamInfo();\n    delete this.fragments[fragKey];\n  };\n\n  _proto.removeAllFragments = function removeAllFragments() {\n    this.fragments = Object.create(null);\n    this.activeFragment = null;\n    this.activeParts = null;\n  };\n\n  return FragmentTracker;\n}();\n\nfunction isPartial(fragmentEntity) {\n  var _fragmentEntity$range, _fragmentEntity$range2;\n\n  return fragmentEntity.buffered && (((_fragmentEntity$range = fragmentEntity.range.video) === null || _fragmentEntity$range === void 0 ? void 0 : _fragmentEntity$range.partial) || ((_fragmentEntity$range2 = fragmentEntity.range.audio) === null || _fragmentEntity$range2 === void 0 ? void 0 : _fragmentEntity$range2.partial));\n}\n\nfunction getFragmentKey(fragment) {\n  return fragment.type + \"_\" + fragment.level + \"_\" + fragment.urlId + \"_\" + fragment.sn;\n}\n\n/***/ }),\n\n/***/ \"./src/controller/gap-controller.ts\":\n/*!******************************************!*\\\n  !*** ./src/controller/gap-controller.ts ***!\n  \\******************************************/\n/*! exports provided: STALL_MINIMUM_DURATION_MS, MAX_START_GAP_JUMP, SKIP_BUFFER_HOLE_STEP_SECONDS, SKIP_BUFFER_RANGE_START, default */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_288451__) {\n\n\"use strict\";\n__nested_webpack_require_288451__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_288451__.d(__webpack_exports__, \"STALL_MINIMUM_DURATION_MS\", function() { return STALL_MINIMUM_DURATION_MS; });\n/* harmony export (binding) */ __nested_webpack_require_288451__.d(__webpack_exports__, \"MAX_START_GAP_JUMP\", function() { return MAX_START_GAP_JUMP; });\n/* harmony export (binding) */ __nested_webpack_require_288451__.d(__webpack_exports__, \"SKIP_BUFFER_HOLE_STEP_SECONDS\", function() { return SKIP_BUFFER_HOLE_STEP_SECONDS; });\n/* harmony export (binding) */ __nested_webpack_require_288451__.d(__webpack_exports__, \"SKIP_BUFFER_RANGE_START\", function() { return SKIP_BUFFER_RANGE_START; });\n/* harmony export (binding) */ __nested_webpack_require_288451__.d(__webpack_exports__, \"default\", function() { return GapController; });\n/* harmony import */ var _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_288451__(/*! ../utils/buffer-helper */ \"./src/utils/buffer-helper.ts\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_288451__(/*! ../errors */ \"./src/errors.ts\");\n/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_288451__(/*! ../events */ \"./src/events.ts\");\n/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_288451__(/*! ../utils/logger */ \"./src/utils/logger.ts\");\n\n\n\n\nvar STALL_MINIMUM_DURATION_MS = 250;\nvar MAX_START_GAP_JUMP = 2.0;\nvar SKIP_BUFFER_HOLE_STEP_SECONDS = 0.1;\nvar SKIP_BUFFER_RANGE_START = 0.05;\n\nvar GapController = /*#__PURE__*/function () {\n  function GapController(config, media, fragmentTracker, hls) {\n    this.config = void 0;\n    this.media = void 0;\n    this.fragmentTracker = void 0;\n    this.hls = void 0;\n    this.nudgeRetry = 0;\n    this.stallReported = false;\n    this.stalled = null;\n    this.moved = false;\n    this.seeking = false;\n    this.config = config;\n    this.media = media;\n    this.fragmentTracker = fragmentTracker;\n    this.hls = hls;\n  }\n\n  var _proto = GapController.prototype;\n\n  _proto.destroy = function destroy() {\n    // @ts-ignore\n    this.hls = this.fragmentTracker = this.media = null;\n  }\n  /**\n   * Checks if the playhead is stuck within a gap, and if so, attempts to free it.\n   * A gap is an unbuffered range between two buffered ranges (or the start and the first buffered range).\n   *\n   * @param {number} lastCurrentTime Previously read playhead position\n   */\n  ;\n\n  _proto.poll = function poll(lastCurrentTime) {\n    var config = this.config,\n        media = this.media,\n        stalled = this.stalled;\n    var currentTime = media.currentTime,\n        seeking = media.seeking;\n    var seeked = this.seeking && !seeking;\n    var beginSeek = !this.seeking && seeking;\n    this.seeking = seeking; // The playhead is moving, no-op\n\n    if (currentTime !== lastCurrentTime) {\n      this.moved = true;\n\n      if (stalled !== null) {\n        // The playhead is now moving, but was previously stalled\n        if (this.stallReported) {\n          var _stalledDuration = self.performance.now() - stalled;\n\n          _utils_logger__WEBPACK_IMPORTED_MODULE_3__[\"logger\"].warn(\"playback not stuck anymore @\" + currentTime + \", after \" + Math.round(_stalledDuration) + \"ms\");\n          this.stallReported = false;\n        }\n\n        this.stalled = null;\n        this.nudgeRetry = 0;\n      }\n\n      return;\n    } // Clear stalled state when beginning or finishing seeking so that we don't report stalls coming out of a seek\n\n\n    if (beginSeek || seeked) {\n      this.stalled = null;\n    } // The playhead should not be moving\n\n\n    if (media.paused || media.ended || media.playbackRate === 0 || !_utils_buffer_helper__WEBPACK_IMPORTED_MODULE_0__[\"BufferHelper\"].getBuffered(media).length) {\n      return;\n    }\n\n    var bufferInfo = _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_0__[\"BufferHelper\"].bufferInfo(media, currentTime, 0);\n    var isBuffered = bufferInfo.len > 0;\n    var nextStart = bufferInfo.nextStart || 0; // There is no playable buffer (seeked, waiting for buffer)\n\n    if (!isBuffered && !nextStart) {\n      return;\n    }\n\n    if (seeking) {\n      // Waiting for seeking in a buffered range to complete\n      var hasEnoughBuffer = bufferInfo.len > MAX_START_GAP_JUMP; // Next buffered range is too far ahead to jump to while still seeking\n\n      var noBufferGap = !nextStart || nextStart - currentTime > MAX_START_GAP_JUMP && !this.fragmentTracker.getPartialFragment(currentTime);\n\n      if (hasEnoughBuffer || noBufferGap) {\n        return;\n      } // Reset moved state when seeking to a point in or before a gap\n\n\n      this.moved = false;\n    } // Skip start gaps if we haven't played, but the last poll detected the start of a stall\n    // The addition poll gives the browser a chance to jump the gap for us\n\n\n    if (!this.moved && this.stalled !== null) {\n      var _level$details;\n\n      // Jump start gaps within jump threshold\n      var startJump = Math.max(nextStart, bufferInfo.start || 0) - currentTime; // When joining a live stream with audio tracks, account for live playlist window sliding by allowing\n      // a larger jump over start gaps caused by the audio-stream-controller buffering a start fragment\n      // that begins over 1 target duration after the video start position.\n\n      var level = this.hls.levels ? this.hls.levels[this.hls.currentLevel] : null;\n      var isLive = level === null || level === void 0 ? void 0 : (_level$details = level.details) === null || _level$details === void 0 ? void 0 : _level$details.live;\n      var maxStartGapJump = isLive ? level.details.targetduration * 2 : MAX_START_GAP_JUMP;\n\n      if (startJump > 0 && startJump <= maxStartGapJump) {\n        this._trySkipBufferHole(null);\n\n        return;\n      }\n    } // Start tracking stall time\n\n\n    var tnow = self.performance.now();\n\n    if (stalled === null) {\n      this.stalled = tnow;\n      return;\n    }\n\n    var stalledDuration = tnow - stalled;\n\n    if (!seeking && stalledDuration >= STALL_MINIMUM_DURATION_MS) {\n      // Report stalling after trying to fix\n      this._reportStall(bufferInfo.len);\n    }\n\n    var bufferedWithHoles = _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_0__[\"BufferHelper\"].bufferInfo(media, currentTime, config.maxBufferHole);\n\n    this._tryFixBufferStall(bufferedWithHoles, stalledDuration);\n  }\n  /**\n   * Detects and attempts to fix known buffer stalling issues.\n   * @param bufferInfo - The properties of the current buffer.\n   * @param stalledDurationMs - The amount of time Hls.js has been stalling for.\n   * @private\n   */\n  ;\n\n  _proto._tryFixBufferStall = function _tryFixBufferStall(bufferInfo, stalledDurationMs) {\n    var config = this.config,\n        fragmentTracker = this.fragmentTracker,\n        media = this.media;\n    var currentTime = media.currentTime;\n    var partial = fragmentTracker.getPartialFragment(currentTime);\n\n    if (partial) {\n      // Try to skip over the buffer hole caused by a partial fragment\n      // This method isn't limited by the size of the gap between buffered ranges\n      var targetTime = this._trySkipBufferHole(partial); // we return here in this case, meaning\n      // the branch below only executes when we don't handle a partial fragment\n\n\n      if (targetTime) {\n        return;\n      }\n    } // if we haven't had to skip over a buffer hole of a partial fragment\n    // we may just have to \"nudge\" the playlist as the browser decoding/rendering engine\n    // needs to cross some sort of threshold covering all source-buffers content\n    // to start playing properly.\n\n\n    if (bufferInfo.len > config.maxBufferHole && stalledDurationMs > config.highBufferWatchdogPeriod * 1000) {\n      _utils_logger__WEBPACK_IMPORTED_MODULE_3__[\"logger\"].warn('Trying to nudge playhead over buffer-hole'); // Try to nudge currentTime over a buffer hole if we've been stalling for the configured amount of seconds\n      // We only try to jump the hole if it's under the configured size\n      // Reset stalled so to rearm watchdog timer\n\n      this.stalled = null;\n\n      this._tryNudgeBuffer();\n    }\n  }\n  /**\n   * Triggers a BUFFER_STALLED_ERROR event, but only once per stall period.\n   * @param bufferLen - The playhead distance from the end of the current buffer segment.\n   * @private\n   */\n  ;\n\n  _proto._reportStall = function _reportStall(bufferLen) {\n    var hls = this.hls,\n        media = this.media,\n        stallReported = this.stallReported;\n\n    if (!stallReported) {\n      // Report stalled error once\n      this.stallReported = true;\n      _utils_logger__WEBPACK_IMPORTED_MODULE_3__[\"logger\"].warn(\"Playback stalling at @\" + media.currentTime + \" due to low buffer (buffer=\" + bufferLen + \")\");\n      hls.trigger(_events__WEBPACK_IMPORTED_MODULE_2__[\"Events\"].ERROR, {\n        type: _errors__WEBPACK_IMPORTED_MODULE_1__[\"ErrorTypes\"].MEDIA_ERROR,\n        details: _errors__WEBPACK_IMPORTED_MODULE_1__[\"ErrorDetails\"].BUFFER_STALLED_ERROR,\n        fatal: false,\n        buffer: bufferLen\n      });\n    }\n  }\n  /**\n   * Attempts to fix buffer stalls by jumping over known gaps caused by partial fragments\n   * @param partial - The partial fragment found at the current time (where playback is stalling).\n   * @private\n   */\n  ;\n\n  _proto._trySkipBufferHole = function _trySkipBufferHole(partial) {\n    var config = this.config,\n        hls = this.hls,\n        media = this.media;\n    var currentTime = media.currentTime;\n    var lastEndTime = 0; // Check if currentTime is between unbuffered regions of partial fragments\n\n    var buffered = _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_0__[\"BufferHelper\"].getBuffered(media);\n\n    for (var i = 0; i < buffered.length; i++) {\n      var startTime = buffered.start(i);\n\n      if (currentTime + config.maxBufferHole >= lastEndTime && currentTime < startTime) {\n        var targetTime = Math.max(startTime + SKIP_BUFFER_RANGE_START, media.currentTime + SKIP_BUFFER_HOLE_STEP_SECONDS);\n        _utils_logger__WEBPACK_IMPORTED_MODULE_3__[\"logger\"].warn(\"skipping hole, adjusting currentTime from \" + currentTime + \" to \" + targetTime);\n        this.moved = true;\n        this.stalled = null;\n        media.currentTime = targetTime;\n\n        if (partial) {\n          hls.trigger(_events__WEBPACK_IMPORTED_MODULE_2__[\"Events\"].ERROR, {\n            type: _errors__WEBPACK_IMPORTED_MODULE_1__[\"ErrorTypes\"].MEDIA_ERROR,\n            details: _errors__WEBPACK_IMPORTED_MODULE_1__[\"ErrorDetails\"].BUFFER_SEEK_OVER_HOLE,\n            fatal: false,\n            reason: \"fragment loaded with buffer holes, seeking from \" + currentTime + \" to \" + targetTime,\n            frag: partial\n          });\n        }\n\n        return targetTime;\n      }\n\n      lastEndTime = buffered.end(i);\n    }\n\n    return 0;\n  }\n  /**\n   * Attempts to fix buffer stalls by advancing the mediaElement's current time by a small amount.\n   * @private\n   */\n  ;\n\n  _proto._tryNudgeBuffer = function _tryNudgeBuffer() {\n    var config = this.config,\n        hls = this.hls,\n        media = this.media;\n    var currentTime = media.currentTime;\n    var nudgeRetry = (this.nudgeRetry || 0) + 1;\n    this.nudgeRetry = nudgeRetry;\n\n    if (nudgeRetry < config.nudgeMaxRetry) {\n      var targetTime = currentTime + nudgeRetry * config.nudgeOffset; // playback stalled in buffered area ... let's nudge currentTime to try to overcome this\n\n      _utils_logger__WEBPACK_IMPORTED_MODULE_3__[\"logger\"].warn(\"Nudging 'currentTime' from \" + currentTime + \" to \" + targetTime);\n      media.currentTime = targetTime;\n      hls.trigger(_events__WEBPACK_IMPORTED_MODULE_2__[\"Events\"].ERROR, {\n        type: _errors__WEBPACK_IMPORTED_MODULE_1__[\"ErrorTypes\"].MEDIA_ERROR,\n        details: _errors__WEBPACK_IMPORTED_MODULE_1__[\"ErrorDetails\"].BUFFER_NUDGE_ON_STALL,\n        fatal: false\n      });\n    } else {\n      _utils_logger__WEBPACK_IMPORTED_MODULE_3__[\"logger\"].error(\"Playhead still not moving while enough data buffered @\" + currentTime + \" after \" + config.nudgeMaxRetry + \" nudges\");\n      hls.trigger(_events__WEBPACK_IMPORTED_MODULE_2__[\"Events\"].ERROR, {\n        type: _errors__WEBPACK_IMPORTED_MODULE_1__[\"ErrorTypes\"].MEDIA_ERROR,\n        details: _errors__WEBPACK_IMPORTED_MODULE_1__[\"ErrorDetails\"].BUFFER_STALLED_ERROR,\n        fatal: true\n      });\n    }\n  };\n\n  return GapController;\n}();\n\n\n\n/***/ }),\n\n/***/ \"./src/controller/id3-track-controller.ts\":\n/*!************************************************!*\\\n  !*** ./src/controller/id3-track-controller.ts ***!\n  \\************************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_301002__) {\n\n\"use strict\";\n__nested_webpack_require_301002__.r(__webpack_exports__);\n/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_301002__(/*! ../events */ \"./src/events.ts\");\n/* harmony import */ var _utils_texttrack_utils__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_301002__(/*! ../utils/texttrack-utils */ \"./src/utils/texttrack-utils.ts\");\n/* harmony import */ var _demux_id3__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_301002__(/*! ../demux/id3 */ \"./src/demux/id3.ts\");\n\n\n\nvar MIN_CUE_DURATION = 0.25;\n\nvar ID3TrackController = /*#__PURE__*/function () {\n  function ID3TrackController(hls) {\n    this.hls = void 0;\n    this.id3Track = null;\n    this.media = null;\n    this.hls = hls;\n\n    this._registerListeners();\n  }\n\n  var _proto = ID3TrackController.prototype;\n\n  _proto.destroy = function destroy() {\n    this._unregisterListeners();\n  };\n\n  _proto._registerListeners = function _registerListeners() {\n    var hls = this.hls;\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].MEDIA_ATTACHED, this.onMediaAttached, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].MEDIA_DETACHING, this.onMediaDetaching, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].FRAG_PARSING_METADATA, this.onFragParsingMetadata, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].BUFFER_FLUSHING, this.onBufferFlushing, this);\n  };\n\n  _proto._unregisterListeners = function _unregisterListeners() {\n    var hls = this.hls;\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].MEDIA_ATTACHED, this.onMediaAttached, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].MEDIA_DETACHING, this.onMediaDetaching, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].FRAG_PARSING_METADATA, this.onFragParsingMetadata, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].BUFFER_FLUSHING, this.onBufferFlushing, this);\n  } // Add ID3 metatadata text track.\n  ;\n\n  _proto.onMediaAttached = function onMediaAttached(event, data) {\n    this.media = data.media;\n  };\n\n  _proto.onMediaDetaching = function onMediaDetaching() {\n    if (!this.id3Track) {\n      return;\n    }\n\n    Object(_utils_texttrack_utils__WEBPACK_IMPORTED_MODULE_1__[\"clearCurrentCues\"])(this.id3Track);\n    this.id3Track = null;\n    this.media = null;\n  };\n\n  _proto.getID3Track = function getID3Track(textTracks) {\n    if (!this.media) {\n      return;\n    }\n\n    for (var i = 0; i < textTracks.length; i++) {\n      var textTrack = textTracks[i];\n\n      if (textTrack.kind === 'metadata' && textTrack.label === 'id3') {\n        // send 'addtrack' when reusing the textTrack for metadata,\n        // same as what we do for captions\n        Object(_utils_texttrack_utils__WEBPACK_IMPORTED_MODULE_1__[\"sendAddTrackEvent\"])(textTrack, this.media);\n        return textTrack;\n      }\n    }\n\n    return this.media.addTextTrack('metadata', 'id3');\n  };\n\n  _proto.onFragParsingMetadata = function onFragParsingMetadata(event, data) {\n    if (!this.media) {\n      return;\n    }\n\n    var fragment = data.frag;\n    var samples = data.samples; // create track dynamically\n\n    if (!this.id3Track) {\n      this.id3Track = this.getID3Track(this.media.textTracks);\n      this.id3Track.mode = 'hidden';\n    } // Attempt to recreate Safari functionality by creating\n    // WebKitDataCue objects when available and store the decoded\n    // ID3 data in the value property of the cue\n\n\n    var Cue = self.WebKitDataCue || self.VTTCue || self.TextTrackCue;\n\n    for (var i = 0; i < samples.length; i++) {\n      var frames = _demux_id3__WEBPACK_IMPORTED_MODULE_2__[\"getID3Frames\"](samples[i].data);\n\n      if (frames) {\n        var startTime = samples[i].pts;\n        var endTime = i < samples.length - 1 ? samples[i + 1].pts : fragment.end;\n        var timeDiff = endTime - startTime;\n\n        if (timeDiff <= 0) {\n          endTime = startTime + MIN_CUE_DURATION;\n        }\n\n        for (var j = 0; j < frames.length; j++) {\n          var frame = frames[j]; // Safari doesn't put the timestamp frame in the TextTrack\n\n          if (!_demux_id3__WEBPACK_IMPORTED_MODULE_2__[\"isTimeStampFrame\"](frame)) {\n            var cue = new Cue(startTime, endTime, '');\n            cue.value = frame;\n            this.id3Track.addCue(cue);\n          }\n        }\n      }\n    }\n  };\n\n  _proto.onBufferFlushing = function onBufferFlushing(event, _ref) {\n    var startOffset = _ref.startOffset,\n        endOffset = _ref.endOffset,\n        type = _ref.type;\n\n    if (!type || type === 'audio') {\n      // id3 cues come from parsed audio only remove cues when audio buffer is cleared\n      var id3Track = this.id3Track;\n\n      if (id3Track) {\n        Object(_utils_texttrack_utils__WEBPACK_IMPORTED_MODULE_1__[\"removeCuesInRange\"])(id3Track, startOffset, endOffset);\n      }\n    }\n  };\n\n  return ID3TrackController;\n}();\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (ID3TrackController);\n\n/***/ }),\n\n/***/ \"./src/controller/latency-controller.ts\":\n/*!**********************************************!*\\\n  !*** ./src/controller/latency-controller.ts ***!\n  \\**********************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_306228__) {\n\n\"use strict\";\n__nested_webpack_require_306228__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_306228__.d(__webpack_exports__, \"default\", function() { return LatencyController; });\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_306228__(/*! ../errors */ \"./src/errors.ts\");\n/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_306228__(/*! ../events */ \"./src/events.ts\");\n/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_306228__(/*! ../utils/logger */ \"./src/utils/logger.ts\");\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\n\n\nvar LatencyController = /*#__PURE__*/function () {\n  function LatencyController(hls) {\n    var _this = this;\n\n    this.hls = void 0;\n    this.config = void 0;\n    this.media = null;\n    this.levelDetails = null;\n    this.currentTime = 0;\n    this.stallCount = 0;\n    this._latency = null;\n\n    this.timeupdateHandler = function () {\n      return _this.timeupdate();\n    };\n\n    this.hls = hls;\n    this.config = hls.config;\n    this.registerListeners();\n  }\n\n  var _proto = LatencyController.prototype;\n\n  _proto.destroy = function destroy() {\n    this.unregisterListeners();\n    this.onMediaDetaching();\n    this.levelDetails = null; // @ts-ignore\n\n    this.hls = this.timeupdateHandler = null;\n  };\n\n  _proto.registerListeners = function registerListeners() {\n    this.hls.on(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].MEDIA_ATTACHED, this.onMediaAttached, this);\n    this.hls.on(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].MEDIA_DETACHING, this.onMediaDetaching, this);\n    this.hls.on(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].MANIFEST_LOADING, this.onManifestLoading, this);\n    this.hls.on(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].LEVEL_UPDATED, this.onLevelUpdated, this);\n    this.hls.on(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].ERROR, this.onError, this);\n  };\n\n  _proto.unregisterListeners = function unregisterListeners() {\n    this.hls.off(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].MEDIA_ATTACHED, this.onMediaAttached);\n    this.hls.off(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].MEDIA_DETACHING, this.onMediaDetaching);\n    this.hls.off(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].MANIFEST_LOADING, this.onManifestLoading);\n    this.hls.off(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].LEVEL_UPDATED, this.onLevelUpdated);\n    this.hls.off(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].ERROR, this.onError);\n  };\n\n  _proto.onMediaAttached = function onMediaAttached(event, data) {\n    this.media = data.media;\n    this.media.addEventListener('timeupdate', this.timeupdateHandler);\n  };\n\n  _proto.onMediaDetaching = function onMediaDetaching() {\n    if (this.media) {\n      this.media.removeEventListener('timeupdate', this.timeupdateHandler);\n      this.media = null;\n    }\n  };\n\n  _proto.onManifestLoading = function onManifestLoading() {\n    this.levelDetails = null;\n    this._latency = null;\n    this.stallCount = 0;\n  };\n\n  _proto.onLevelUpdated = function onLevelUpdated(event, _ref) {\n    var details = _ref.details;\n    this.levelDetails = details;\n\n    if (details.advanced) {\n      this.timeupdate();\n    }\n\n    if (!details.live && this.media) {\n      this.media.removeEventListener('timeupdate', this.timeupdateHandler);\n    }\n  };\n\n  _proto.onError = function onError(event, data) {\n    if (data.details !== _errors__WEBPACK_IMPORTED_MODULE_0__[\"ErrorDetails\"].BUFFER_STALLED_ERROR) {\n      return;\n    }\n\n    this.stallCount++;\n    _utils_logger__WEBPACK_IMPORTED_MODULE_2__[\"logger\"].warn('[playback-rate-controller]: Stall detected, adjusting target latency');\n  };\n\n  _proto.timeupdate = function timeupdate() {\n    var media = this.media,\n        levelDetails = this.levelDetails;\n\n    if (!media || !levelDetails) {\n      return;\n    }\n\n    this.currentTime = media.currentTime;\n    var latency = this.computeLatency();\n\n    if (latency === null) {\n      return;\n    }\n\n    this._latency = latency; // Adapt playbackRate to meet target latency in low-latency mode\n\n    var _this$config = this.config,\n        lowLatencyMode = _this$config.lowLatencyMode,\n        maxLiveSyncPlaybackRate = _this$config.maxLiveSyncPlaybackRate;\n\n    if (!lowLatencyMode || maxLiveSyncPlaybackRate === 1) {\n      return;\n    }\n\n    var targetLatency = this.targetLatency;\n\n    if (targetLatency === null) {\n      return;\n    }\n\n    var distanceFromTarget = latency - targetLatency; // Only adjust playbackRate when within one target duration of targetLatency\n    // and more than one second from under-buffering.\n    // Playback further than one target duration from target can be considered DVR playback.\n\n    var liveMinLatencyDuration = Math.min(this.maxLatency, targetLatency + levelDetails.targetduration);\n    var inLiveRange = distanceFromTarget < liveMinLatencyDuration;\n\n    if (levelDetails.live && inLiveRange && distanceFromTarget > 0.05 && this.forwardBufferLength > 1) {\n      var max = Math.min(2, Math.max(1.0, maxLiveSyncPlaybackRate));\n      var rate = Math.round(2 / (1 + Math.exp(-0.75 * distanceFromTarget - this.edgeStalled)) * 20) / 20;\n      media.playbackRate = Math.min(max, Math.max(1, rate));\n    } else if (media.playbackRate !== 1 && media.playbackRate !== 0) {\n      media.playbackRate = 1;\n    }\n  };\n\n  _proto.estimateLiveEdge = function estimateLiveEdge() {\n    var levelDetails = this.levelDetails;\n\n    if (levelDetails === null) {\n      return null;\n    }\n\n    return levelDetails.edge + levelDetails.age;\n  };\n\n  _proto.computeLatency = function computeLatency() {\n    var liveEdge = this.estimateLiveEdge();\n\n    if (liveEdge === null) {\n      return null;\n    }\n\n    return liveEdge - this.currentTime;\n  };\n\n  _createClass(LatencyController, [{\n    key: \"latency\",\n    get: function get() {\n      return this._latency || 0;\n    }\n  }, {\n    key: \"maxLatency\",\n    get: function get() {\n      var config = this.config,\n          levelDetails = this.levelDetails;\n\n      if (config.liveMaxLatencyDuration !== undefined) {\n        return config.liveMaxLatencyDuration;\n      }\n\n      return levelDetails ? config.liveMaxLatencyDurationCount * levelDetails.targetduration : 0;\n    }\n  }, {\n    key: \"targetLatency\",\n    get: function get() {\n      var levelDetails = this.levelDetails;\n\n      if (levelDetails === null) {\n        return null;\n      }\n\n      var holdBack = levelDetails.holdBack,\n          partHoldBack = levelDetails.partHoldBack,\n          targetduration = levelDetails.targetduration;\n      var _this$config2 = this.config,\n          liveSyncDuration = _this$config2.liveSyncDuration,\n          liveSyncDurationCount = _this$config2.liveSyncDurationCount,\n          lowLatencyMode = _this$config2.lowLatencyMode;\n      var userConfig = this.hls.userConfig;\n      var targetLatency = lowLatencyMode ? partHoldBack || holdBack : holdBack;\n\n      if (userConfig.liveSyncDuration || userConfig.liveSyncDurationCount || targetLatency === 0) {\n        targetLatency = liveSyncDuration !== undefined ? liveSyncDuration : liveSyncDurationCount * targetduration;\n      }\n\n      var maxLiveSyncOnStallIncrease = targetduration;\n      var liveSyncOnStallIncrease = 1.0;\n      return targetLatency + Math.min(this.stallCount * liveSyncOnStallIncrease, maxLiveSyncOnStallIncrease);\n    }\n  }, {\n    key: \"liveSyncPosition\",\n    get: function get() {\n      var liveEdge = this.estimateLiveEdge();\n      var targetLatency = this.targetLatency;\n      var levelDetails = this.levelDetails;\n\n      if (liveEdge === null || targetLatency === null || levelDetails === null) {\n        return null;\n      }\n\n      var edge = levelDetails.edge;\n      var syncPosition = liveEdge - targetLatency - this.edgeStalled;\n      var min = edge - levelDetails.totalduration;\n      var max = edge - (this.config.lowLatencyMode && levelDetails.partTarget || levelDetails.targetduration);\n      return Math.min(Math.max(min, syncPosition), max);\n    }\n  }, {\n    key: \"drift\",\n    get: function get() {\n      var levelDetails = this.levelDetails;\n\n      if (levelDetails === null) {\n        return 1;\n      }\n\n      return levelDetails.drift;\n    }\n  }, {\n    key: \"edgeStalled\",\n    get: function get() {\n      var levelDetails = this.levelDetails;\n\n      if (levelDetails === null) {\n        return 0;\n      }\n\n      var maxLevelUpdateAge = (this.config.lowLatencyMode && levelDetails.partTarget || levelDetails.targetduration) * 3;\n      return Math.max(levelDetails.age - maxLevelUpdateAge, 0);\n    }\n  }, {\n    key: \"forwardBufferLength\",\n    get: function get() {\n      var media = this.media,\n          levelDetails = this.levelDetails;\n\n      if (!media || !levelDetails) {\n        return 0;\n      }\n\n      var bufferedRanges = media.buffered.length;\n      return bufferedRanges ? media.buffered.end(bufferedRanges - 1) : levelDetails.edge - this.currentTime;\n    }\n  }]);\n\n  return LatencyController;\n}();\n\n\n\n/***/ }),\n\n/***/ \"./src/controller/level-controller.ts\":\n/*!********************************************!*\\\n  !*** ./src/controller/level-controller.ts ***!\n  \\********************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_315935__) {\n\n\"use strict\";\n__nested_webpack_require_315935__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_315935__.d(__webpack_exports__, \"default\", function() { return LevelController; });\n/* harmony import */ var _types_level__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_315935__(/*! ../types/level */ \"./src/types/level.ts\");\n/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_315935__(/*! ../events */ \"./src/events.ts\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_315935__(/*! ../errors */ \"./src/errors.ts\");\n/* harmony import */ var _utils_codecs__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_315935__(/*! ../utils/codecs */ \"./src/utils/codecs.ts\");\n/* harmony import */ var _level_helper__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_315935__(/*! ./level-helper */ \"./src/controller/level-helper.ts\");\n/* harmony import */ var _base_playlist_controller__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_315935__(/*! ./base-playlist-controller */ \"./src/controller/base-playlist-controller.ts\");\n/* harmony import */ var _types_loader__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_315935__(/*! ../types/loader */ \"./src/types/loader.ts\");\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n/*\n * Level Controller\n */\n\n\n\n\n\n\n\nvar chromeOrFirefox = /chrome|firefox/.test(navigator.userAgent.toLowerCase());\n\nvar LevelController = /*#__PURE__*/function (_BasePlaylistControll) {\n  _inheritsLoose(LevelController, _BasePlaylistControll);\n\n  function LevelController(hls) {\n    var _this;\n\n    _this = _BasePlaylistControll.call(this, hls, '[level-controller]') || this;\n    _this._levels = [];\n    _this._firstLevel = -1;\n    _this._startLevel = void 0;\n    _this.currentLevelIndex = -1;\n    _this.manualLevelIndex = -1;\n    _this.onParsedComplete = void 0;\n\n    _this._registerListeners();\n\n    return _this;\n  }\n\n  var _proto = LevelController.prototype;\n\n  _proto._registerListeners = function _registerListeners() {\n    var hls = this.hls;\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].MANIFEST_LOADED, this.onManifestLoaded, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].LEVEL_LOADED, this.onLevelLoaded, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].FRAG_LOADED, this.onFragLoaded, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].ERROR, this.onError, this);\n  };\n\n  _proto._unregisterListeners = function _unregisterListeners() {\n    var hls = this.hls;\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].MANIFEST_LOADED, this.onManifestLoaded, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].LEVEL_LOADED, this.onLevelLoaded, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].FRAG_LOADED, this.onFragLoaded, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].ERROR, this.onError, this);\n  };\n\n  _proto.destroy = function destroy() {\n    this._unregisterListeners();\n\n    this.manualLevelIndex = -1;\n    this._levels.length = 0;\n\n    _BasePlaylistControll.prototype.destroy.call(this);\n  };\n\n  _proto.startLoad = function startLoad() {\n    var levels = this._levels; // clean up live level details to force reload them, and reset load errors\n\n    levels.forEach(function (level) {\n      level.loadError = 0;\n    });\n\n    _BasePlaylistControll.prototype.startLoad.call(this);\n  };\n\n  _proto.onManifestLoaded = function onManifestLoaded(event, data) {\n    var levels = [];\n    var audioTracks = [];\n    var subtitleTracks = [];\n    var bitrateStart;\n    var levelSet = {};\n    var levelFromSet;\n    var resolutionFound = false;\n    var videoCodecFound = false;\n    var audioCodecFound = false; // regroup redundant levels together\n\n    data.levels.forEach(function (levelParsed) {\n      var attributes = levelParsed.attrs;\n      resolutionFound = resolutionFound || !!(levelParsed.width && levelParsed.height);\n      videoCodecFound = videoCodecFound || !!levelParsed.videoCodec;\n      audioCodecFound = audioCodecFound || !!levelParsed.audioCodec; // erase audio codec info if browser does not support mp4a.40.34.\n      // demuxer will autodetect codec and fallback to mpeg/audio\n\n      if (chromeOrFirefox && levelParsed.audioCodec && levelParsed.audioCodec.indexOf('mp4a.40.34') !== -1) {\n        levelParsed.audioCodec = undefined;\n      }\n\n      var levelKey = levelParsed.bitrate + \"-\" + levelParsed.attrs.RESOLUTION + \"-\" + levelParsed.attrs.CODECS;\n      levelFromSet = levelSet[levelKey];\n\n      if (!levelFromSet) {\n        levelFromSet = new _types_level__WEBPACK_IMPORTED_MODULE_0__[\"Level\"](levelParsed);\n        levelSet[levelKey] = levelFromSet;\n        levels.push(levelFromSet);\n      } else {\n        levelFromSet.url.push(levelParsed.url);\n      }\n\n      if (attributes) {\n        if (attributes.AUDIO) {\n          Object(_level_helper__WEBPACK_IMPORTED_MODULE_4__[\"addGroupId\"])(levelFromSet, 'audio', attributes.AUDIO);\n        }\n\n        if (attributes.SUBTITLES) {\n          Object(_level_helper__WEBPACK_IMPORTED_MODULE_4__[\"addGroupId\"])(levelFromSet, 'text', attributes.SUBTITLES);\n        }\n      }\n    }); // remove audio-only level if we also have levels with video codecs or RESOLUTION signalled\n\n    if ((resolutionFound || videoCodecFound) && audioCodecFound) {\n      levels = levels.filter(function (_ref) {\n        var videoCodec = _ref.videoCodec,\n            width = _ref.width,\n            height = _ref.height;\n        return !!videoCodec || !!(width && height);\n      });\n    } // only keep levels with supported audio/video codecs\n\n\n    levels = levels.filter(function (_ref2) {\n      var audioCodec = _ref2.audioCodec,\n          videoCodec = _ref2.videoCodec;\n      return (!audioCodec || Object(_utils_codecs__WEBPACK_IMPORTED_MODULE_3__[\"isCodecSupportedInMp4\"])(audioCodec, 'audio')) && (!videoCodec || Object(_utils_codecs__WEBPACK_IMPORTED_MODULE_3__[\"isCodecSupportedInMp4\"])(videoCodec, 'video'));\n    });\n\n    if (data.audioTracks) {\n      audioTracks = data.audioTracks.filter(function (track) {\n        return !track.audioCodec || Object(_utils_codecs__WEBPACK_IMPORTED_MODULE_3__[\"isCodecSupportedInMp4\"])(track.audioCodec, 'audio');\n      }); // Assign ids after filtering as array indices by group-id\n\n      Object(_level_helper__WEBPACK_IMPORTED_MODULE_4__[\"assignTrackIdsByGroup\"])(audioTracks);\n    }\n\n    if (data.subtitles) {\n      subtitleTracks = data.subtitles;\n      Object(_level_helper__WEBPACK_IMPORTED_MODULE_4__[\"assignTrackIdsByGroup\"])(subtitleTracks);\n    }\n\n    if (levels.length > 0) {\n      // start bitrate is the first bitrate of the manifest\n      bitrateStart = levels[0].bitrate; // sort level on bitrate\n\n      levels.sort(function (a, b) {\n        return a.bitrate - b.bitrate;\n      });\n      this._levels = levels; // find index of first level in sorted levels\n\n      for (var i = 0; i < levels.length; i++) {\n        if (levels[i].bitrate === bitrateStart) {\n          this._firstLevel = i;\n          this.log(\"manifest loaded, \" + levels.length + \" level(s) found, first bitrate: \" + bitrateStart);\n          break;\n        }\n      } // Audio is only alternate if manifest include a URI along with the audio group tag,\n      // and this is not an audio-only stream where levels contain audio-only\n\n\n      var audioOnly = audioCodecFound && !videoCodecFound;\n      var edata = {\n        levels: levels,\n        audioTracks: audioTracks,\n        subtitleTracks: subtitleTracks,\n        firstLevel: this._firstLevel,\n        stats: data.stats,\n        audio: audioCodecFound,\n        video: videoCodecFound,\n        altAudio: !audioOnly && audioTracks.some(function (t) {\n          return !!t.url;\n        })\n      };\n      this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].MANIFEST_PARSED, edata); // Initiate loading after all controllers have received MANIFEST_PARSED\n\n      if (this.hls.config.autoStartLoad || this.hls.forceStartLoad) {\n        this.hls.startLoad(this.hls.config.startPosition);\n      }\n    } else {\n      this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].ERROR, {\n        type: _errors__WEBPACK_IMPORTED_MODULE_2__[\"ErrorTypes\"].MEDIA_ERROR,\n        details: _errors__WEBPACK_IMPORTED_MODULE_2__[\"ErrorDetails\"].MANIFEST_INCOMPATIBLE_CODECS_ERROR,\n        fatal: true,\n        url: data.url,\n        reason: 'no level with compatible codecs found in manifest'\n      });\n    }\n  };\n\n  _proto.onError = function onError(event, data) {\n    _BasePlaylistControll.prototype.onError.call(this, event, data);\n\n    if (data.fatal) {\n      return;\n    } // Switch to redundant level when track fails to load\n\n\n    var context = data.context;\n    var level = this._levels[this.currentLevelIndex];\n\n    if (context && (context.type === _types_loader__WEBPACK_IMPORTED_MODULE_6__[\"PlaylistContextType\"].AUDIO_TRACK && level.audioGroupIds && context.groupId === level.audioGroupIds[level.urlId] || context.type === _types_loader__WEBPACK_IMPORTED_MODULE_6__[\"PlaylistContextType\"].SUBTITLE_TRACK && level.textGroupIds && context.groupId === level.textGroupIds[level.urlId])) {\n      this.redundantFailover(this.currentLevelIndex);\n      return;\n    }\n\n    var levelError = false;\n    var levelSwitch = true;\n    var levelIndex; // try to recover not fatal errors\n\n    switch (data.details) {\n      case _errors__WEBPACK_IMPORTED_MODULE_2__[\"ErrorDetails\"].FRAG_LOAD_ERROR:\n      case _errors__WEBPACK_IMPORTED_MODULE_2__[\"ErrorDetails\"].FRAG_LOAD_TIMEOUT:\n      case _errors__WEBPACK_IMPORTED_MODULE_2__[\"ErrorDetails\"].KEY_LOAD_ERROR:\n      case _errors__WEBPACK_IMPORTED_MODULE_2__[\"ErrorDetails\"].KEY_LOAD_TIMEOUT:\n        if (data.frag) {\n          var _level = this._levels[data.frag.level]; // Set levelIndex when we're out of fragment retries\n\n          if (_level) {\n            _level.fragmentError++;\n\n            if (_level.fragmentError > this.hls.config.fragLoadingMaxRetry) {\n              levelIndex = data.frag.level;\n            }\n          } else {\n            levelIndex = data.frag.level;\n          }\n        }\n\n        break;\n\n      case _errors__WEBPACK_IMPORTED_MODULE_2__[\"ErrorDetails\"].LEVEL_LOAD_ERROR:\n      case _errors__WEBPACK_IMPORTED_MODULE_2__[\"ErrorDetails\"].LEVEL_LOAD_TIMEOUT:\n        // Do not perform level switch if an error occurred using delivery directives\n        // Attempt to reload level without directives first\n        if (context) {\n          if (context.deliveryDirectives) {\n            levelSwitch = false;\n          }\n\n          levelIndex = context.level;\n        }\n\n        levelError = true;\n        break;\n\n      case _errors__WEBPACK_IMPORTED_MODULE_2__[\"ErrorDetails\"].REMUX_ALLOC_ERROR:\n        levelIndex = data.level;\n        levelError = true;\n        break;\n    }\n\n    if (levelIndex !== undefined) {\n      this.recoverLevel(data, levelIndex, levelError, levelSwitch);\n    }\n  }\n  /**\n   * Switch to a redundant stream if any available.\n   * If redundant stream is not available, emergency switch down if ABR mode is enabled.\n   */\n  ;\n\n  _proto.recoverLevel = function recoverLevel(errorEvent, levelIndex, levelError, levelSwitch) {\n    var errorDetails = errorEvent.details;\n    var level = this._levels[levelIndex];\n    level.loadError++;\n\n    if (levelError) {\n      var retrying = this.retryLoadingOrFail(errorEvent);\n\n      if (retrying) {\n        // boolean used to inform stream controller not to switch back to IDLE on non fatal error\n        errorEvent.levelRetry = true;\n      } else {\n        this.currentLevelIndex = -1;\n        return;\n      }\n    }\n\n    if (levelSwitch) {\n      var redundantLevels = level.url.length; // Try redundant fail-over until level.loadError reaches redundantLevels\n\n      if (redundantLevels > 1 && level.loadError < redundantLevels) {\n        errorEvent.levelRetry = true;\n        this.redundantFailover(levelIndex);\n      } else if (this.manualLevelIndex === -1) {\n        // Search for available level in auto level selection mode, cycling from highest to lowest bitrate\n        var nextLevel = levelIndex === 0 ? this._levels.length - 1 : levelIndex - 1;\n\n        if (this.currentLevelIndex !== nextLevel && this._levels[nextLevel].loadError === 0) {\n          this.warn(errorDetails + \": switch to \" + nextLevel);\n          errorEvent.levelRetry = true;\n          this.hls.nextAutoLevel = nextLevel;\n        }\n      }\n    }\n  };\n\n  _proto.redundantFailover = function redundantFailover(levelIndex) {\n    var level = this._levels[levelIndex];\n    var redundantLevels = level.url.length;\n\n    if (redundantLevels > 1) {\n      // Update the url id of all levels so that we stay on the same set of variants when level switching\n      var newUrlId = (level.urlId + 1) % redundantLevels;\n      this.warn(\"Switching to redundant URL-id \" + newUrlId);\n\n      this._levels.forEach(function (level) {\n        level.urlId = newUrlId;\n      });\n\n      this.level = levelIndex;\n    }\n  } // reset errors on the successful load of a fragment\n  ;\n\n  _proto.onFragLoaded = function onFragLoaded(event, _ref3) {\n    var frag = _ref3.frag;\n\n    if (frag !== undefined && frag.type === _types_loader__WEBPACK_IMPORTED_MODULE_6__[\"PlaylistLevelType\"].MAIN) {\n      var level = this._levels[frag.level];\n\n      if (level !== undefined) {\n        level.fragmentError = 0;\n        level.loadError = 0;\n      }\n    }\n  };\n\n  _proto.onLevelLoaded = function onLevelLoaded(event, data) {\n    var _data$deliveryDirecti2;\n\n    var level = data.level,\n        details = data.details;\n    var curLevel = this._levels[level];\n\n    if (!curLevel) {\n      var _data$deliveryDirecti;\n\n      this.warn(\"Invalid level index \" + level);\n\n      if ((_data$deliveryDirecti = data.deliveryDirectives) !== null && _data$deliveryDirecti !== void 0 && _data$deliveryDirecti.skip) {\n        details.deltaUpdateFailed = true;\n      }\n\n      return;\n    } // only process level loaded events matching with expected level\n\n\n    if (level === this.currentLevelIndex) {\n      // reset level load error counter on successful level loaded only if there is no issues with fragments\n      if (curLevel.fragmentError === 0) {\n        curLevel.loadError = 0;\n        this.retryCount = 0;\n      }\n\n      this.playlistLoaded(level, data, curLevel.details);\n    } else if ((_data$deliveryDirecti2 = data.deliveryDirectives) !== null && _data$deliveryDirecti2 !== void 0 && _data$deliveryDirecti2.skip) {\n      // received a delta playlist update that cannot be merged\n      details.deltaUpdateFailed = true;\n    }\n  };\n\n  _proto.onAudioTrackSwitched = function onAudioTrackSwitched(event, data) {\n    var currentLevel = this.hls.levels[this.currentLevelIndex];\n\n    if (!currentLevel) {\n      return;\n    }\n\n    if (currentLevel.audioGroupIds) {\n      var urlId = -1;\n      var audioGroupId = this.hls.audioTracks[data.id].groupId;\n\n      for (var i = 0; i < currentLevel.audioGroupIds.length; i++) {\n        if (currentLevel.audioGroupIds[i] === audioGroupId) {\n          urlId = i;\n          break;\n        }\n      }\n\n      if (urlId !== currentLevel.urlId) {\n        currentLevel.urlId = urlId;\n        this.startLoad();\n      }\n    }\n  };\n\n  _proto.loadPlaylist = function loadPlaylist(hlsUrlParameters) {\n    var level = this.currentLevelIndex;\n    var currentLevel = this._levels[level];\n\n    if (this.canLoad && currentLevel && currentLevel.url.length > 0) {\n      var id = currentLevel.urlId;\n      var url = currentLevel.url[id];\n\n      if (hlsUrlParameters) {\n        try {\n          url = hlsUrlParameters.addDirectives(url);\n        } catch (error) {\n          this.warn(\"Could not construct new URL with HLS Delivery Directives: \" + error);\n        }\n      }\n\n      this.log(\"Attempt loading level index \" + level + (hlsUrlParameters ? ' at sn ' + hlsUrlParameters.msn + ' part ' + hlsUrlParameters.part : '') + \" with URL-id \" + id + \" \" + url); // console.log('Current audio track group ID:', this.hls.audioTracks[this.hls.audioTrack].groupId);\n      // console.log('New video quality level audio group id:', levelObject.attrs.AUDIO, level);\n\n      this.clearTimer();\n      this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].LEVEL_LOADING, {\n        url: url,\n        level: level,\n        id: id,\n        deliveryDirectives: hlsUrlParameters || null\n      });\n    }\n  };\n\n  _proto.removeLevel = function removeLevel(levelIndex, urlId) {\n    var filterLevelAndGroupByIdIndex = function filterLevelAndGroupByIdIndex(url, id) {\n      return id !== urlId;\n    };\n\n    var levels = this._levels.filter(function (level, index) {\n      if (index !== levelIndex) {\n        return true;\n      }\n\n      if (level.url.length > 1 && urlId !== undefined) {\n        level.url = level.url.filter(filterLevelAndGroupByIdIndex);\n\n        if (level.audioGroupIds) {\n          level.audioGroupIds = level.audioGroupIds.filter(filterLevelAndGroupByIdIndex);\n        }\n\n        if (level.textGroupIds) {\n          level.textGroupIds = level.textGroupIds.filter(filterLevelAndGroupByIdIndex);\n        }\n\n        level.urlId = 0;\n        return true;\n      }\n\n      return false;\n    }).map(function (level, index) {\n      var details = level.details;\n\n      if (details !== null && details !== void 0 && details.fragments) {\n        details.fragments.forEach(function (fragment) {\n          fragment.level = index;\n        });\n      }\n\n      return level;\n    });\n\n    this._levels = levels;\n    this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].LEVELS_UPDATED, {\n      levels: levels\n    });\n  };\n\n  _createClass(LevelController, [{\n    key: \"levels\",\n    get: function get() {\n      if (this._levels.length === 0) {\n        return null;\n      }\n\n      return this._levels;\n    }\n  }, {\n    key: \"level\",\n    get: function get() {\n      return this.currentLevelIndex;\n    },\n    set: function set(newLevel) {\n      var _levels$newLevel;\n\n      var levels = this._levels;\n\n      if (levels.length === 0) {\n        return;\n      }\n\n      if (this.currentLevelIndex === newLevel && (_levels$newLevel = levels[newLevel]) !== null && _levels$newLevel !== void 0 && _levels$newLevel.details) {\n        return;\n      } // check if level idx is valid\n\n\n      if (newLevel < 0 || newLevel >= levels.length) {\n        // invalid level id given, trigger error\n        var fatal = newLevel < 0;\n        this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].ERROR, {\n          type: _errors__WEBPACK_IMPORTED_MODULE_2__[\"ErrorTypes\"].OTHER_ERROR,\n          details: _errors__WEBPACK_IMPORTED_MODULE_2__[\"ErrorDetails\"].LEVEL_SWITCH_ERROR,\n          level: newLevel,\n          fatal: fatal,\n          reason: 'invalid level idx'\n        });\n\n        if (fatal) {\n          return;\n        }\n\n        newLevel = Math.min(newLevel, levels.length - 1);\n      } // stopping live reloading timer if any\n\n\n      this.clearTimer();\n      var lastLevelIndex = this.currentLevelIndex;\n      var lastLevel = levels[lastLevelIndex];\n      var level = levels[newLevel];\n      this.log(\"switching to level \" + newLevel + \" from \" + lastLevelIndex);\n      this.currentLevelIndex = newLevel;\n\n      var levelSwitchingData = _extends({}, level, {\n        level: newLevel,\n        maxBitrate: level.maxBitrate,\n        uri: level.uri,\n        urlId: level.urlId\n      }); // @ts-ignore\n\n\n      delete levelSwitchingData._urlId;\n      this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].LEVEL_SWITCHING, levelSwitchingData); // check if we need to load playlist for this level\n\n      var levelDetails = level.details;\n\n      if (!levelDetails || levelDetails.live) {\n        // level not retrieved yet, or live playlist we need to (re)load it\n        var hlsUrlParameters = this.switchParams(level.uri, lastLevel === null || lastLevel === void 0 ? void 0 : lastLevel.details);\n        this.loadPlaylist(hlsUrlParameters);\n      }\n    }\n  }, {\n    key: \"manualLevel\",\n    get: function get() {\n      return this.manualLevelIndex;\n    },\n    set: function set(newLevel) {\n      this.manualLevelIndex = newLevel;\n\n      if (this._startLevel === undefined) {\n        this._startLevel = newLevel;\n      }\n\n      if (newLevel !== -1) {\n        this.level = newLevel;\n      }\n    }\n  }, {\n    key: \"firstLevel\",\n    get: function get() {\n      return this._firstLevel;\n    },\n    set: function set(newLevel) {\n      this._firstLevel = newLevel;\n    }\n  }, {\n    key: \"startLevel\",\n    get: function get() {\n      // hls.startLevel takes precedence over config.startLevel\n      // if none of these values are defined, fallback on this._firstLevel (first quality level appearing in variant manifest)\n      if (this._startLevel === undefined) {\n        var configStartLevel = this.hls.config.startLevel;\n\n        if (configStartLevel !== undefined) {\n          return configStartLevel;\n        } else {\n          return this._firstLevel;\n        }\n      } else {\n        return this._startLevel;\n      }\n    },\n    set: function set(newLevel) {\n      this._startLevel = newLevel;\n    }\n  }, {\n    key: \"nextLoadLevel\",\n    get: function get() {\n      if (this.manualLevelIndex !== -1) {\n        return this.manualLevelIndex;\n      } else {\n        return this.hls.nextAutoLevel;\n      }\n    },\n    set: function set(nextLevel) {\n      this.level = nextLevel;\n\n      if (this.manualLevelIndex === -1) {\n        this.hls.nextAutoLevel = nextLevel;\n      }\n    }\n  }]);\n\n  return LevelController;\n}(_base_playlist_controller__WEBPACK_IMPORTED_MODULE_5__[\"default\"]);\n\n\n\n/***/ }),\n\n/***/ \"./src/controller/level-helper.ts\":\n/*!****************************************!*\\\n  !*** ./src/controller/level-helper.ts ***!\n  \\****************************************/\n/*! exports provided: addGroupId, assignTrackIdsByGroup, updatePTS, updateFragPTSDTS, mergeDetails, mapPartIntersection, mapFragmentIntersection, adjustSliding, addSliding, computeReloadInterval, getFragmentWithSN, getPartWith */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_339221__) {\n\n\"use strict\";\n__nested_webpack_require_339221__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_339221__.d(__webpack_exports__, \"addGroupId\", function() { return addGroupId; });\n/* harmony export (binding) */ __nested_webpack_require_339221__.d(__webpack_exports__, \"assignTrackIdsByGroup\", function() { return assignTrackIdsByGroup; });\n/* harmony export (binding) */ __nested_webpack_require_339221__.d(__webpack_exports__, \"updatePTS\", function() { return updatePTS; });\n/* harmony export (binding) */ __nested_webpack_require_339221__.d(__webpack_exports__, \"updateFragPTSDTS\", function() { return updateFragPTSDTS; });\n/* harmony export (binding) */ __nested_webpack_require_339221__.d(__webpack_exports__, \"mergeDetails\", function() { return mergeDetails; });\n/* harmony export (binding) */ __nested_webpack_require_339221__.d(__webpack_exports__, \"mapPartIntersection\", function() { return mapPartIntersection; });\n/* harmony export (binding) */ __nested_webpack_require_339221__.d(__webpack_exports__, \"mapFragmentIntersection\", function() { return mapFragmentIntersection; });\n/* harmony export (binding) */ __nested_webpack_require_339221__.d(__webpack_exports__, \"adjustSliding\", function() { return adjustSliding; });\n/* harmony export (binding) */ __nested_webpack_require_339221__.d(__webpack_exports__, \"addSliding\", function() { return addSliding; });\n/* harmony export (binding) */ __nested_webpack_require_339221__.d(__webpack_exports__, \"computeReloadInterval\", function() { return computeReloadInterval; });\n/* harmony export (binding) */ __nested_webpack_require_339221__.d(__webpack_exports__, \"getFragmentWithSN\", function() { return getFragmentWithSN; });\n/* harmony export (binding) */ __nested_webpack_require_339221__.d(__webpack_exports__, \"getPartWith\", function() { return getPartWith; });\n/* harmony import */ var _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_339221__(/*! ./src/polyfills/number */ \"./src/polyfills/number.ts\");\n/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_339221__(/*! ../utils/logger */ \"./src/utils/logger.ts\");\n\n\n\n\n\n\n/**\n * @module LevelHelper\n * Providing methods dealing with playlist sliding and drift\n * */\n\nfunction addGroupId(level, type, id) {\n  switch (type) {\n    case 'audio':\n      if (!level.audioGroupIds) {\n        level.audioGroupIds = [];\n      }\n\n      level.audioGroupIds.push(id);\n      break;\n\n    case 'text':\n      if (!level.textGroupIds) {\n        level.textGroupIds = [];\n      }\n\n      level.textGroupIds.push(id);\n      break;\n  }\n}\nfunction assignTrackIdsByGroup(tracks) {\n  var groups = {};\n  tracks.forEach(function (track) {\n    var groupId = track.groupId || '';\n    track.id = groups[groupId] = groups[groupId] || 0;\n    groups[groupId]++;\n  });\n}\nfunction updatePTS(fragments, fromIdx, toIdx) {\n  var fragFrom = fragments[fromIdx];\n  var fragTo = fragments[toIdx];\n  updateFromToPTS(fragFrom, fragTo);\n}\n\nfunction updateFromToPTS(fragFrom, fragTo) {\n  var fragToPTS = fragTo.startPTS; // if we know startPTS[toIdx]\n\n  if (Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__[\"isFiniteNumber\"])(fragToPTS)) {\n    // update fragment duration.\n    // it helps to fix drifts between playlist reported duration and fragment real duration\n    var duration = 0;\n    var frag;\n\n    if (fragTo.sn > fragFrom.sn) {\n      duration = fragToPTS - fragFrom.start;\n      frag = fragFrom;\n    } else {\n      duration = fragFrom.start - fragToPTS;\n      frag = fragTo;\n    } // TODO? Drift can go either way, or the playlist could be completely accurate\n    // console.assert(duration > 0,\n    //   `duration of ${duration} computed for frag ${frag.sn}, level ${frag.level}, there should be some duration drift between playlist and fragment!`);\n\n\n    if (frag.duration !== duration) {\n      frag.duration = duration;\n    } // we dont know startPTS[toIdx]\n\n  } else if (fragTo.sn > fragFrom.sn) {\n    var contiguous = fragFrom.cc === fragTo.cc; // TODO: With part-loading end/durations we need to confirm the whole fragment is loaded before using (or setting) minEndPTS\n\n    if (contiguous && fragFrom.minEndPTS) {\n      fragTo.start = fragFrom.start + (fragFrom.minEndPTS - fragFrom.start);\n    } else {\n      fragTo.start = fragFrom.start + fragFrom.duration;\n    }\n  } else {\n    fragTo.start = Math.max(fragFrom.start - fragTo.duration, 0);\n  }\n}\n\nfunction updateFragPTSDTS(details, frag, startPTS, endPTS, startDTS, endDTS) {\n  var parsedMediaDuration = endPTS - startPTS;\n\n  if (parsedMediaDuration <= 0) {\n    _utils_logger__WEBPACK_IMPORTED_MODULE_1__[\"logger\"].warn('Fragment should have a positive duration', frag);\n    endPTS = startPTS + frag.duration;\n    endDTS = startDTS + frag.duration;\n  }\n\n  var maxStartPTS = startPTS;\n  var minEndPTS = endPTS;\n  var fragStartPts = frag.startPTS;\n  var fragEndPts = frag.endPTS;\n\n  if (Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__[\"isFiniteNumber\"])(fragStartPts)) {\n    // delta PTS between audio and video\n    var deltaPTS = Math.abs(fragStartPts - startPTS);\n\n    if (!Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__[\"isFiniteNumber\"])(frag.deltaPTS)) {\n      frag.deltaPTS = deltaPTS;\n    } else {\n      frag.deltaPTS = Math.max(deltaPTS, frag.deltaPTS);\n    }\n\n    maxStartPTS = Math.max(startPTS, fragStartPts);\n    startPTS = Math.min(startPTS, fragStartPts);\n    startDTS = Math.min(startDTS, frag.startDTS);\n    minEndPTS = Math.min(endPTS, fragEndPts);\n    endPTS = Math.max(endPTS, fragEndPts);\n    endDTS = Math.max(endDTS, frag.endDTS);\n  }\n\n  frag.duration = endPTS - startPTS;\n  var drift = startPTS - frag.start;\n  frag.appendedPTS = endPTS;\n  frag.start = frag.startPTS = startPTS;\n  frag.maxStartPTS = maxStartPTS;\n  frag.startDTS = startDTS;\n  frag.endPTS = endPTS;\n  frag.minEndPTS = minEndPTS;\n  frag.endDTS = endDTS;\n  var sn = frag.sn; // 'initSegment'\n  // exit if sn out of range\n\n  if (!details || sn < details.startSN || sn > details.endSN) {\n    return 0;\n  }\n\n  var i;\n  var fragIdx = sn - details.startSN;\n  var fragments = details.fragments; // update frag reference in fragments array\n  // rationale is that fragments array might not contain this frag object.\n  // this will happen if playlist has been refreshed between frag loading and call to updateFragPTSDTS()\n  // if we don't update frag, we won't be able to propagate PTS info on the playlist\n  // resulting in invalid sliding computation\n\n  fragments[fragIdx] = frag; // adjust fragment PTS/duration from seqnum-1 to frag 0\n\n  for (i = fragIdx; i > 0; i--) {\n    updateFromToPTS(fragments[i], fragments[i - 1]);\n  } // adjust fragment PTS/duration from seqnum to last frag\n\n\n  for (i = fragIdx; i < fragments.length - 1; i++) {\n    updateFromToPTS(fragments[i], fragments[i + 1]);\n  }\n\n  if (details.fragmentHint) {\n    updateFromToPTS(fragments[fragments.length - 1], details.fragmentHint);\n  }\n\n  details.PTSKnown = details.alignedSliding = true;\n  return drift;\n}\nfunction mergeDetails(oldDetails, newDetails) {\n  // Track the last initSegment processed. Initialize it to the last one on the timeline.\n  var currentInitSegment = null;\n  var oldFragments = oldDetails.fragments;\n\n  for (var i = oldFragments.length - 1; i >= 0; i--) {\n    var oldInit = oldFragments[i].initSegment;\n\n    if (oldInit) {\n      currentInitSegment = oldInit;\n      break;\n    }\n  }\n\n  if (oldDetails.fragmentHint) {\n    // prevent PTS and duration from being adjusted on the next hint\n    delete oldDetails.fragmentHint.endPTS;\n  } // check if old/new playlists have fragments in common\n  // loop through overlapping SN and update startPTS , cc, and duration if any found\n\n\n  var ccOffset = 0;\n  var PTSFrag;\n  mapFragmentIntersection(oldDetails, newDetails, function (oldFrag, newFrag) {\n    if (oldFrag.relurl) {\n      // Do not compare CC if the old fragment has no url. This is a level.fragmentHint used by LL-HLS parts.\n      // It maybe be off by 1 if it was created before any parts or discontinuity tags were appended to the end\n      // of the playlist.\n      ccOffset = oldFrag.cc - newFrag.cc;\n    }\n\n    if (Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__[\"isFiniteNumber\"])(oldFrag.startPTS) && Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__[\"isFiniteNumber\"])(oldFrag.endPTS)) {\n      newFrag.start = newFrag.startPTS = oldFrag.startPTS;\n      newFrag.startDTS = oldFrag.startDTS;\n      newFrag.appendedPTS = oldFrag.appendedPTS;\n      newFrag.maxStartPTS = oldFrag.maxStartPTS;\n      newFrag.endPTS = oldFrag.endPTS;\n      newFrag.endDTS = oldFrag.endDTS;\n      newFrag.minEndPTS = oldFrag.minEndPTS;\n      newFrag.duration = oldFrag.endPTS - oldFrag.startPTS;\n\n      if (newFrag.duration) {\n        PTSFrag = newFrag;\n      } // PTS is known when any segment has startPTS and endPTS\n\n\n      newDetails.PTSKnown = newDetails.alignedSliding = true;\n    }\n\n    newFrag.elementaryStreams = oldFrag.elementaryStreams;\n    newFrag.loader = oldFrag.loader;\n    newFrag.stats = oldFrag.stats;\n    newFrag.urlId = oldFrag.urlId;\n\n    if (oldFrag.initSegment) {\n      newFrag.initSegment = oldFrag.initSegment;\n      currentInitSegment = oldFrag.initSegment;\n    }\n  });\n\n  if (currentInitSegment) {\n    var fragmentsToCheck = newDetails.fragmentHint ? newDetails.fragments.concat(newDetails.fragmentHint) : newDetails.fragments;\n    fragmentsToCheck.forEach(function (frag) {\n      var _currentInitSegment;\n\n      if (!frag.initSegment || frag.initSegment.relurl === ((_currentInitSegment = currentInitSegment) === null || _currentInitSegment === void 0 ? void 0 : _currentInitSegment.relurl)) {\n        frag.initSegment = currentInitSegment;\n      }\n    });\n  }\n\n  if (newDetails.skippedSegments) {\n    newDetails.deltaUpdateFailed = newDetails.fragments.some(function (frag) {\n      return !frag;\n    });\n\n    if (newDetails.deltaUpdateFailed) {\n      _utils_logger__WEBPACK_IMPORTED_MODULE_1__[\"logger\"].warn('[level-helper] Previous playlist missing segments skipped in delta playlist');\n\n      for (var _i = newDetails.skippedSegments; _i--;) {\n        newDetails.fragments.shift();\n      }\n\n      newDetails.startSN = newDetails.fragments[0].sn;\n      newDetails.startCC = newDetails.fragments[0].cc;\n    }\n  }\n\n  var newFragments = newDetails.fragments;\n\n  if (ccOffset) {\n    _utils_logger__WEBPACK_IMPORTED_MODULE_1__[\"logger\"].warn('discontinuity sliding from playlist, take drift into account');\n\n    for (var _i2 = 0; _i2 < newFragments.length; _i2++) {\n      newFragments[_i2].cc += ccOffset;\n    }\n  }\n\n  if (newDetails.skippedSegments) {\n    newDetails.startCC = newDetails.fragments[0].cc;\n  } // Merge parts\n\n\n  mapPartIntersection(oldDetails.partList, newDetails.partList, function (oldPart, newPart) {\n    newPart.elementaryStreams = oldPart.elementaryStreams;\n    newPart.stats = oldPart.stats;\n  }); // if at least one fragment contains PTS info, recompute PTS information for all fragments\n\n  if (PTSFrag) {\n    updateFragPTSDTS(newDetails, PTSFrag, PTSFrag.startPTS, PTSFrag.endPTS, PTSFrag.startDTS, PTSFrag.endDTS);\n  } else {\n    // ensure that delta is within oldFragments range\n    // also adjust sliding in case delta is 0 (we could have old=[50-60] and new=old=[50-61])\n    // in that case we also need to adjust start offset of all fragments\n    adjustSliding(oldDetails, newDetails);\n  }\n\n  if (newFragments.length) {\n    newDetails.totalduration = newDetails.edge - newFragments[0].start;\n  }\n\n  newDetails.driftStartTime = oldDetails.driftStartTime;\n  newDetails.driftStart = oldDetails.driftStart;\n  var advancedDateTime = newDetails.advancedDateTime;\n\n  if (newDetails.advanced && advancedDateTime) {\n    var edge = newDetails.edge;\n\n    if (!newDetails.driftStart) {\n      newDetails.driftStartTime = advancedDateTime;\n      newDetails.driftStart = edge;\n    }\n\n    newDetails.driftEndTime = advancedDateTime;\n    newDetails.driftEnd = edge;\n  } else {\n    newDetails.driftEndTime = oldDetails.driftEndTime;\n    newDetails.driftEnd = oldDetails.driftEnd;\n    newDetails.advancedDateTime = oldDetails.advancedDateTime;\n  }\n}\nfunction mapPartIntersection(oldParts, newParts, intersectionFn) {\n  if (oldParts && newParts) {\n    var delta = 0;\n\n    for (var i = 0, len = oldParts.length; i <= len; i++) {\n      var _oldPart = oldParts[i];\n      var _newPart = newParts[i + delta];\n\n      if (_oldPart && _newPart && _oldPart.index === _newPart.index && _oldPart.fragment.sn === _newPart.fragment.sn) {\n        intersectionFn(_oldPart, _newPart);\n      } else {\n        delta--;\n      }\n    }\n  }\n}\nfunction mapFragmentIntersection(oldDetails, newDetails, intersectionFn) {\n  var skippedSegments = newDetails.skippedSegments;\n  var start = Math.max(oldDetails.startSN, newDetails.startSN) - newDetails.startSN;\n  var end = (oldDetails.fragmentHint ? 1 : 0) + (skippedSegments ? newDetails.endSN : Math.min(oldDetails.endSN, newDetails.endSN)) - newDetails.startSN;\n  var delta = newDetails.startSN - oldDetails.startSN;\n  var newFrags = newDetails.fragmentHint ? newDetails.fragments.concat(newDetails.fragmentHint) : newDetails.fragments;\n  var oldFrags = oldDetails.fragmentHint ? oldDetails.fragments.concat(oldDetails.fragmentHint) : oldDetails.fragments;\n\n  for (var i = start; i <= end; i++) {\n    var _oldFrag = oldFrags[delta + i];\n    var _newFrag = newFrags[i];\n\n    if (skippedSegments && !_newFrag && i < skippedSegments) {\n      // Fill in skipped segments in delta playlist\n      _newFrag = newDetails.fragments[i] = _oldFrag;\n    }\n\n    if (_oldFrag && _newFrag) {\n      intersectionFn(_oldFrag, _newFrag);\n    }\n  }\n}\nfunction adjustSliding(oldDetails, newDetails) {\n  var delta = newDetails.startSN + newDetails.skippedSegments - oldDetails.startSN;\n  var oldFragments = oldDetails.fragments;\n\n  if (delta < 0 || delta >= oldFragments.length) {\n    return;\n  }\n\n  addSliding(newDetails, oldFragments[delta].start);\n}\nfunction addSliding(details, start) {\n  if (start) {\n    var fragments = details.fragments;\n\n    for (var i = details.skippedSegments; i < fragments.length; i++) {\n      fragments[i].start += start;\n    }\n\n    if (details.fragmentHint) {\n      details.fragmentHint.start += start;\n    }\n  }\n}\nfunction computeReloadInterval(newDetails, stats) {\n  var reloadInterval = 1000 * newDetails.levelTargetDuration;\n  var reloadIntervalAfterMiss = reloadInterval / 2;\n  var timeSinceLastModified = newDetails.age;\n  var useLastModified = timeSinceLastModified > 0 && timeSinceLastModified < reloadInterval * 3;\n  var roundTrip = stats.loading.end - stats.loading.start;\n  var estimatedTimeUntilUpdate;\n  var availabilityDelay = newDetails.availabilityDelay; // let estimate = 'average';\n\n  if (newDetails.updated === false) {\n    if (useLastModified) {\n      // estimate = 'miss round trip';\n      // We should have had a hit so try again in the time it takes to get a response,\n      // but no less than 1/3 second.\n      var minRetry = 333 * newDetails.misses;\n      estimatedTimeUntilUpdate = Math.max(Math.min(reloadIntervalAfterMiss, roundTrip * 2), minRetry);\n      newDetails.availabilityDelay = (newDetails.availabilityDelay || 0) + estimatedTimeUntilUpdate;\n    } else {\n      // estimate = 'miss half average';\n      // follow HLS Spec, If the client reloads a Playlist file and finds that it has not\n      // changed then it MUST wait for a period of one-half the target\n      // duration before retrying.\n      estimatedTimeUntilUpdate = reloadIntervalAfterMiss;\n    }\n  } else if (useLastModified) {\n    // estimate = 'next modified date';\n    // Get the closest we've been to timeSinceLastModified on update\n    availabilityDelay = Math.min(availabilityDelay || reloadInterval / 2, timeSinceLastModified);\n    newDetails.availabilityDelay = availabilityDelay;\n    estimatedTimeUntilUpdate = availabilityDelay + reloadInterval - timeSinceLastModified;\n  } else {\n    estimatedTimeUntilUpdate = reloadInterval - roundTrip;\n  } // console.log(`[computeReloadInterval] live reload ${newDetails.updated ? 'REFRESHED' : 'MISSED'}`,\n  //   '\\n  method', estimate,\n  //   '\\n  estimated time until update =>', estimatedTimeUntilUpdate,\n  //   '\\n  average target duration', reloadInterval,\n  //   '\\n  time since modified', timeSinceLastModified,\n  //   '\\n  time round trip', roundTrip,\n  //   '\\n  availability delay', availabilityDelay);\n\n\n  return Math.round(estimatedTimeUntilUpdate);\n}\nfunction getFragmentWithSN(level, sn, fragCurrent) {\n  if (!level || !level.details) {\n    return null;\n  }\n\n  var levelDetails = level.details;\n  var fragment = levelDetails.fragments[sn - levelDetails.startSN];\n\n  if (fragment) {\n    return fragment;\n  }\n\n  fragment = levelDetails.fragmentHint;\n\n  if (fragment && fragment.sn === sn) {\n    return fragment;\n  }\n\n  if (sn < levelDetails.startSN && fragCurrent && fragCurrent.sn === sn) {\n    return fragCurrent;\n  }\n\n  return null;\n}\nfunction getPartWith(level, sn, partIndex) {\n  if (!level || !level.details) {\n    return null;\n  }\n\n  var partList = level.details.partList;\n\n  if (partList) {\n    for (var i = partList.length; i--;) {\n      var part = partList[i];\n\n      if (part.index === partIndex && part.fragment.sn === sn) {\n        return part;\n      }\n    }\n  }\n\n  return null;\n}\n\n/***/ }),\n\n/***/ \"./src/controller/stream-controller.ts\":\n/*!*********************************************!*\\\n  !*** ./src/controller/stream-controller.ts ***!\n  \\*********************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_356770__) {\n\n\"use strict\";\n__nested_webpack_require_356770__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_356770__.d(__webpack_exports__, \"default\", function() { return StreamController; });\n/* harmony import */ var _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_356770__(/*! ./src/polyfills/number */ \"./src/polyfills/number.ts\");\n/* harmony import */ var _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_356770__(/*! ./base-stream-controller */ \"./src/controller/base-stream-controller.ts\");\n/* harmony import */ var _is_supported__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_356770__(/*! ../is-supported */ \"./src/is-supported.ts\");\n/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_356770__(/*! ../events */ \"./src/events.ts\");\n/* harmony import */ var _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_356770__(/*! ../utils/buffer-helper */ \"./src/utils/buffer-helper.ts\");\n/* harmony import */ var _fragment_tracker__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_356770__(/*! ./fragment-tracker */ \"./src/controller/fragment-tracker.ts\");\n/* harmony import */ var _types_loader__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_356770__(/*! ../types/loader */ \"./src/types/loader.ts\");\n/* harmony import */ var _loader_fragment__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_356770__(/*! ../loader/fragment */ \"./src/loader/fragment.ts\");\n/* harmony import */ var _demux_transmuxer_interface__WEBPACK_IMPORTED_MODULE_8__ = __nested_webpack_require_356770__(/*! ../demux/transmuxer-interface */ \"./src/demux/transmuxer-interface.ts\");\n/* harmony import */ var _types_transmuxer__WEBPACK_IMPORTED_MODULE_9__ = __nested_webpack_require_356770__(/*! ../types/transmuxer */ \"./src/types/transmuxer.ts\");\n/* harmony import */ var _gap_controller__WEBPACK_IMPORTED_MODULE_10__ = __nested_webpack_require_356770__(/*! ./gap-controller */ \"./src/controller/gap-controller.ts\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_11__ = __nested_webpack_require_356770__(/*! ../errors */ \"./src/errors.ts\");\n/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_12__ = __nested_webpack_require_356770__(/*! ../utils/logger */ \"./src/utils/logger.ts\");\n\n\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar TICK_INTERVAL = 100; // how often to tick in ms\n\nvar StreamController = /*#__PURE__*/function (_BaseStreamController) {\n  _inheritsLoose(StreamController, _BaseStreamController);\n\n  function StreamController(hls, fragmentTracker) {\n    var _this;\n\n    _this = _BaseStreamController.call(this, hls, fragmentTracker, '[stream-controller]') || this;\n    _this.audioCodecSwap = false;\n    _this.gapController = null;\n    _this.level = -1;\n    _this._forceStartLoad = false;\n    _this.altAudio = false;\n    _this.audioOnly = false;\n    _this.fragPlaying = null;\n    _this.onvplaying = null;\n    _this.onvseeked = null;\n    _this.fragLastKbps = 0;\n    _this.stalled = false;\n    _this.couldBacktrack = false;\n    _this.audioCodecSwitch = false;\n    _this.videoBuffer = null;\n\n    _this._registerListeners();\n\n    return _this;\n  }\n\n  var _proto = StreamController.prototype;\n\n  _proto._registerListeners = function _registerListeners() {\n    var hls = this.hls;\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_3__[\"Events\"].MEDIA_ATTACHED, this.onMediaAttached, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_3__[\"Events\"].MEDIA_DETACHING, this.onMediaDetaching, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_3__[\"Events\"].MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_3__[\"Events\"].MANIFEST_PARSED, this.onManifestParsed, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_3__[\"Events\"].LEVEL_LOADING, this.onLevelLoading, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_3__[\"Events\"].LEVEL_LOADED, this.onLevelLoaded, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_3__[\"Events\"].FRAG_LOAD_EMERGENCY_ABORTED, this.onFragLoadEmergencyAborted, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_3__[\"Events\"].ERROR, this.onError, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_3__[\"Events\"].AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_3__[\"Events\"].AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_3__[\"Events\"].BUFFER_CREATED, this.onBufferCreated, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_3__[\"Events\"].BUFFER_FLUSHED, this.onBufferFlushed, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_3__[\"Events\"].LEVELS_UPDATED, this.onLevelsUpdated, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_3__[\"Events\"].FRAG_BUFFERED, this.onFragBuffered, this);\n  };\n\n  _proto._unregisterListeners = function _unregisterListeners() {\n    var hls = this.hls;\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_3__[\"Events\"].MEDIA_ATTACHED, this.onMediaAttached, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_3__[\"Events\"].MEDIA_DETACHING, this.onMediaDetaching, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_3__[\"Events\"].MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_3__[\"Events\"].MANIFEST_PARSED, this.onManifestParsed, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_3__[\"Events\"].LEVEL_LOADED, this.onLevelLoaded, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_3__[\"Events\"].FRAG_LOAD_EMERGENCY_ABORTED, this.onFragLoadEmergencyAborted, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_3__[\"Events\"].ERROR, this.onError, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_3__[\"Events\"].AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_3__[\"Events\"].AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_3__[\"Events\"].BUFFER_CREATED, this.onBufferCreated, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_3__[\"Events\"].BUFFER_FLUSHED, this.onBufferFlushed, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_3__[\"Events\"].LEVELS_UPDATED, this.onLevelsUpdated, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_3__[\"Events\"].FRAG_BUFFERED, this.onFragBuffered, this);\n  };\n\n  _proto.onHandlerDestroying = function onHandlerDestroying() {\n    this._unregisterListeners();\n\n    this.onMediaDetaching();\n  };\n\n  _proto.startLoad = function startLoad(startPosition) {\n    if (this.levels) {\n      var lastCurrentTime = this.lastCurrentTime,\n          hls = this.hls;\n      this.stopLoad();\n      this.setInterval(TICK_INTERVAL);\n      this.level = -1;\n      this.fragLoadError = 0;\n\n      if (!this.startFragRequested) {\n        // determine load level\n        var startLevel = hls.startLevel;\n\n        if (startLevel === -1) {\n          if (hls.config.testBandwidth) {\n            // -1 : guess start Level by doing a bitrate test by loading first fragment of lowest quality level\n            startLevel = 0;\n            this.bitrateTest = true;\n          } else {\n            startLevel = hls.nextAutoLevel;\n          }\n        } // set new level to playlist loader : this will trigger start level load\n        // hls.nextLoadLevel remains until it is set to a new value or until a new frag is successfully loaded\n\n\n        this.level = hls.nextLoadLevel = startLevel;\n        this.loadedmetadata = false;\n      } // if startPosition undefined but lastCurrentTime set, set startPosition to last currentTime\n\n\n      if (lastCurrentTime > 0 && startPosition === -1) {\n        this.log(\"Override startPosition with lastCurrentTime @\" + lastCurrentTime.toFixed(3));\n        startPosition = lastCurrentTime;\n      }\n\n      this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"State\"].IDLE;\n      this.nextLoadPosition = this.startPosition = this.lastCurrentTime = startPosition;\n      this.tick();\n    } else {\n      this._forceStartLoad = true;\n      this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"State\"].STOPPED;\n    }\n  };\n\n  _proto.stopLoad = function stopLoad() {\n    this._forceStartLoad = false;\n\n    _BaseStreamController.prototype.stopLoad.call(this);\n  };\n\n  _proto.doTick = function doTick() {\n    switch (this.state) {\n      case _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"State\"].IDLE:\n        this.doTickIdle();\n        break;\n\n      case _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"State\"].WAITING_LEVEL:\n        {\n          var _levels$level;\n\n          var levels = this.levels,\n              level = this.level;\n          var details = levels === null || levels === void 0 ? void 0 : (_levels$level = levels[level]) === null || _levels$level === void 0 ? void 0 : _levels$level.details;\n\n          if (details && (!details.live || this.levelLastLoaded === this.level)) {\n            if (this.waitForCdnTuneIn(details)) {\n              break;\n            }\n\n            this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"State\"].IDLE;\n            break;\n          }\n\n          break;\n        }\n\n      case _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"State\"].FRAG_LOADING_WAITING_RETRY:\n        {\n          var _this$media;\n\n          var now = self.performance.now();\n          var retryDate = this.retryDate; // if current time is gt than retryDate, or if media seeking let's switch to IDLE state to retry loading\n\n          if (!retryDate || now >= retryDate || (_this$media = this.media) !== null && _this$media !== void 0 && _this$media.seeking) {\n            this.log('retryDate reached, switch back to IDLE state');\n            this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"State\"].IDLE;\n          }\n        }\n        break;\n\n      default:\n        break;\n    } // check buffer\n    // check/update current fragment\n\n\n    this.onTickEnd();\n  };\n\n  _proto.onTickEnd = function onTickEnd() {\n    _BaseStreamController.prototype.onTickEnd.call(this);\n\n    this.checkBuffer();\n    this.checkFragmentChanged();\n  };\n\n  _proto.doTickIdle = function doTickIdle() {\n    var _frag$decryptdata, _frag$decryptdata2;\n\n    var hls = this.hls,\n        levelLastLoaded = this.levelLastLoaded,\n        levels = this.levels,\n        media = this.media;\n    var config = hls.config,\n        level = hls.nextLoadLevel; // if start level not parsed yet OR\n    // if video not attached AND start fragment already requested OR start frag prefetch not enabled\n    // exit loop, as we either need more info (level not parsed) or we need media to be attached to load new fragment\n\n    if (levelLastLoaded === null || !media && (this.startFragRequested || !config.startFragPrefetch)) {\n      return;\n    } // If the \"main\" level is audio-only but we are loading an alternate track in the same group, do not load anything\n\n\n    if (this.altAudio && this.audioOnly) {\n      return;\n    }\n\n    if (!levels || !levels[level]) {\n      return;\n    }\n\n    var levelInfo = levels[level]; // if buffer length is less than maxBufLen try to load a new fragment\n    // set next load level : this will trigger a playlist load if needed\n\n    this.level = hls.nextLoadLevel = level;\n    var levelDetails = levelInfo.details; // if level info not retrieved yet, switch state and wait for level retrieval\n    // if live playlist, ensure that new playlist has been refreshed to avoid loading/try to load\n    // a useless and outdated fragment (that might even introduce load error if it is already out of the live playlist)\n\n    if (!levelDetails || this.state === _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"State\"].WAITING_LEVEL || levelDetails.live && this.levelLastLoaded !== level) {\n      this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"State\"].WAITING_LEVEL;\n      return;\n    }\n\n    var bufferInfo = this.getFwdBufferInfo(this.mediaBuffer ? this.mediaBuffer : media, _types_loader__WEBPACK_IMPORTED_MODULE_6__[\"PlaylistLevelType\"].MAIN);\n\n    if (bufferInfo === null) {\n      return;\n    }\n\n    var bufferLen = bufferInfo.len; // compute max Buffer Length that we could get from this load level, based on level bitrate. don't buffer more than 60 MB and more than 30s\n\n    var maxBufLen = this.getMaxBufferLength(levelInfo.maxBitrate); // Stay idle if we are still with buffer margins\n\n    if (bufferLen >= maxBufLen) {\n      return;\n    }\n\n    if (this._streamEnded(bufferInfo, levelDetails)) {\n      var data = {};\n\n      if (this.altAudio) {\n        data.type = 'video';\n      }\n\n      this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_3__[\"Events\"].BUFFER_EOS, data);\n      this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"State\"].ENDED;\n      return;\n    }\n\n    var targetBufferTime = bufferInfo.end;\n    var frag = this.getNextFragment(targetBufferTime, levelDetails); // Avoid backtracking after seeking or switching by loading an earlier segment in streams that could backtrack\n\n    if (this.couldBacktrack && !this.fragPrevious && frag && frag.sn !== 'initSegment') {\n      var fragIdx = frag.sn - levelDetails.startSN;\n\n      if (fragIdx > 1) {\n        frag = levelDetails.fragments[fragIdx - 1];\n        this.fragmentTracker.removeFragment(frag);\n      }\n    } // Avoid loop loading by using nextLoadPosition set for backtracking\n\n\n    if (frag && this.fragmentTracker.getState(frag) === _fragment_tracker__WEBPACK_IMPORTED_MODULE_5__[\"FragmentState\"].OK && this.nextLoadPosition > targetBufferTime) {\n      // Cleanup the fragment tracker before trying to find the next unbuffered fragment\n      var type = this.audioOnly && !this.altAudio ? _loader_fragment__WEBPACK_IMPORTED_MODULE_7__[\"ElementaryStreamTypes\"].AUDIO : _loader_fragment__WEBPACK_IMPORTED_MODULE_7__[\"ElementaryStreamTypes\"].VIDEO;\n      this.afterBufferFlushed(media, type, _types_loader__WEBPACK_IMPORTED_MODULE_6__[\"PlaylistLevelType\"].MAIN);\n      frag = this.getNextFragment(this.nextLoadPosition, levelDetails);\n    }\n\n    if (!frag) {\n      return;\n    }\n\n    if (frag.initSegment && !frag.initSegment.data && !this.bitrateTest) {\n      frag = frag.initSegment;\n    } // We want to load the key if we're dealing with an identity key, because we will decrypt\n    // this content using the key we fetch. Other keys will be handled by the DRM CDM via EME.\n\n\n    if (((_frag$decryptdata = frag.decryptdata) === null || _frag$decryptdata === void 0 ? void 0 : _frag$decryptdata.keyFormat) === 'identity' && !((_frag$decryptdata2 = frag.decryptdata) !== null && _frag$decryptdata2 !== void 0 && _frag$decryptdata2.key)) {\n      this.loadKey(frag, levelDetails);\n    } else {\n      this.loadFragment(frag, levelDetails, targetBufferTime);\n    }\n  };\n\n  _proto.loadFragment = function loadFragment(frag, levelDetails, targetBufferTime) {\n    var _this$media2;\n\n    // Check if fragment is not loaded\n    var fragState = this.fragmentTracker.getState(frag);\n    this.fragCurrent = frag; // Use data from loaded backtracked fragment if available\n\n    if (fragState === _fragment_tracker__WEBPACK_IMPORTED_MODULE_5__[\"FragmentState\"].BACKTRACKED) {\n      var data = this.fragmentTracker.getBacktrackData(frag);\n\n      if (data) {\n        this._handleFragmentLoadProgress(data);\n\n        this._handleFragmentLoadComplete(data);\n\n        return;\n      } else {\n        fragState = _fragment_tracker__WEBPACK_IMPORTED_MODULE_5__[\"FragmentState\"].NOT_LOADED;\n      }\n    }\n\n    if (fragState === _fragment_tracker__WEBPACK_IMPORTED_MODULE_5__[\"FragmentState\"].NOT_LOADED || fragState === _fragment_tracker__WEBPACK_IMPORTED_MODULE_5__[\"FragmentState\"].PARTIAL) {\n      if (frag.sn === 'initSegment') {\n        this._loadInitSegment(frag);\n      } else if (this.bitrateTest) {\n        frag.bitrateTest = true;\n        this.log(\"Fragment \" + frag.sn + \" of level \" + frag.level + \" is being downloaded to test bitrate and will not be buffered\");\n\n        this._loadBitrateTestFrag(frag);\n      } else {\n        this.startFragRequested = true;\n\n        _BaseStreamController.prototype.loadFragment.call(this, frag, levelDetails, targetBufferTime);\n      }\n    } else if (fragState === _fragment_tracker__WEBPACK_IMPORTED_MODULE_5__[\"FragmentState\"].APPENDING) {\n      // Lower the buffer size and try again\n      if (this.reduceMaxBufferLength(frag.duration)) {\n        this.fragmentTracker.removeFragment(frag);\n      }\n    } else if (((_this$media2 = this.media) === null || _this$media2 === void 0 ? void 0 : _this$media2.buffered.length) === 0) {\n      // Stop gap for bad tracker / buffer flush behavior\n      this.fragmentTracker.removeAllFragments();\n    }\n  };\n\n  _proto.getAppendedFrag = function getAppendedFrag(position) {\n    var fragOrPart = this.fragmentTracker.getAppendedFrag(position, _types_loader__WEBPACK_IMPORTED_MODULE_6__[\"PlaylistLevelType\"].MAIN);\n\n    if (fragOrPart && 'fragment' in fragOrPart) {\n      return fragOrPart.fragment;\n    }\n\n    return fragOrPart;\n  };\n\n  _proto.getBufferedFrag = function getBufferedFrag(position) {\n    return this.fragmentTracker.getBufferedFrag(position, _types_loader__WEBPACK_IMPORTED_MODULE_6__[\"PlaylistLevelType\"].MAIN);\n  };\n\n  _proto.followingBufferedFrag = function followingBufferedFrag(frag) {\n    if (frag) {\n      // try to get range of next fragment (500ms after this range)\n      return this.getBufferedFrag(frag.end + 0.5);\n    }\n\n    return null;\n  }\n  /*\n    on immediate level switch :\n     - pause playback if playing\n     - cancel any pending load request\n     - and trigger a buffer flush\n  */\n  ;\n\n  _proto.immediateLevelSwitch = function immediateLevelSwitch() {\n    this.abortCurrentFrag();\n    this.flushMainBuffer(0, Number.POSITIVE_INFINITY);\n  }\n  /**\n   * try to switch ASAP without breaking video playback:\n   * in order to ensure smooth but quick level switching,\n   * we need to find the next flushable buffer range\n   * we should take into account new segment fetch time\n   */\n  ;\n\n  _proto.nextLevelSwitch = function nextLevelSwitch() {\n    var levels = this.levels,\n        media = this.media; // ensure that media is defined and that metadata are available (to retrieve currentTime)\n\n    if (media !== null && media !== void 0 && media.readyState) {\n      var fetchdelay;\n      var fragPlayingCurrent = this.getAppendedFrag(media.currentTime);\n\n      if (fragPlayingCurrent && fragPlayingCurrent.start > 1) {\n        // flush buffer preceding current fragment (flush until current fragment start offset)\n        // minus 1s to avoid video freezing, that could happen if we flush keyframe of current video ...\n        this.flushMainBuffer(0, fragPlayingCurrent.start - 1);\n      }\n\n      if (!media.paused && levels) {\n        // add a safety delay of 1s\n        var nextLevelId = this.hls.nextLoadLevel;\n        var nextLevel = levels[nextLevelId];\n        var fragLastKbps = this.fragLastKbps;\n\n        if (fragLastKbps && this.fragCurrent) {\n          fetchdelay = this.fragCurrent.duration * nextLevel.maxBitrate / (1000 * fragLastKbps) + 1;\n        } else {\n          fetchdelay = 0;\n        }\n      } else {\n        fetchdelay = 0;\n      } // this.log('fetchdelay:'+fetchdelay);\n      // find buffer range that will be reached once new fragment will be fetched\n\n\n      var bufferedFrag = this.getBufferedFrag(media.currentTime + fetchdelay);\n\n      if (bufferedFrag) {\n        // we can flush buffer range following this one without stalling playback\n        var nextBufferedFrag = this.followingBufferedFrag(bufferedFrag);\n\n        if (nextBufferedFrag) {\n          // if we are here, we can also cancel any loading/demuxing in progress, as they are useless\n          this.abortCurrentFrag(); // start flush position is in next buffered frag. Leave some padding for non-independent segments and smoother playback.\n\n          var maxStart = nextBufferedFrag.maxStartPTS ? nextBufferedFrag.maxStartPTS : nextBufferedFrag.start;\n          var fragDuration = nextBufferedFrag.duration;\n          var startPts = Math.max(bufferedFrag.end, maxStart + Math.min(Math.max(fragDuration - this.config.maxFragLookUpTolerance, fragDuration * 0.5), fragDuration * 0.75));\n          this.flushMainBuffer(startPts, Number.POSITIVE_INFINITY);\n        }\n      }\n    }\n  };\n\n  _proto.abortCurrentFrag = function abortCurrentFrag() {\n    var fragCurrent = this.fragCurrent;\n    this.fragCurrent = null;\n\n    if (fragCurrent !== null && fragCurrent !== void 0 && fragCurrent.loader) {\n      fragCurrent.loader.abort();\n    }\n\n    if (this.state === _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"State\"].KEY_LOADING) {\n      this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"State\"].IDLE;\n    }\n\n    this.nextLoadPosition = this.getLoadPosition();\n  };\n\n  _proto.flushMainBuffer = function flushMainBuffer(startOffset, endOffset) {\n    _BaseStreamController.prototype.flushMainBuffer.call(this, startOffset, endOffset, this.altAudio ? 'video' : null);\n  };\n\n  _proto.onMediaAttached = function onMediaAttached(event, data) {\n    _BaseStreamController.prototype.onMediaAttached.call(this, event, data);\n\n    var media = data.media;\n    this.onvplaying = this.onMediaPlaying.bind(this);\n    this.onvseeked = this.onMediaSeeked.bind(this);\n    media.addEventListener('playing', this.onvplaying);\n    media.addEventListener('seeked', this.onvseeked);\n    this.gapController = new _gap_controller__WEBPACK_IMPORTED_MODULE_10__[\"default\"](this.config, media, this.fragmentTracker, this.hls);\n  };\n\n  _proto.onMediaDetaching = function onMediaDetaching() {\n    var media = this.media;\n\n    if (media) {\n      media.removeEventListener('playing', this.onvplaying);\n      media.removeEventListener('seeked', this.onvseeked);\n      this.onvplaying = this.onvseeked = null;\n      this.videoBuffer = null;\n    }\n\n    this.fragPlaying = null;\n\n    if (this.gapController) {\n      this.gapController.destroy();\n      this.gapController = null;\n    }\n\n    _BaseStreamController.prototype.onMediaDetaching.call(this);\n  };\n\n  _proto.onMediaPlaying = function onMediaPlaying() {\n    // tick to speed up FRAG_CHANGED triggering\n    this.tick();\n  };\n\n  _proto.onMediaSeeked = function onMediaSeeked() {\n    var media = this.media;\n    var currentTime = media ? media.currentTime : null;\n\n    if (Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__[\"isFiniteNumber\"])(currentTime)) {\n      this.log(\"Media seeked to \" + currentTime.toFixed(3));\n    } // tick to speed up FRAG_CHANGED triggering\n\n\n    this.tick();\n  };\n\n  _proto.onManifestLoading = function onManifestLoading() {\n    // reset buffer on manifest loading\n    this.log('Trigger BUFFER_RESET');\n    this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_3__[\"Events\"].BUFFER_RESET, undefined);\n    this.fragmentTracker.removeAllFragments();\n    this.couldBacktrack = this.stalled = false;\n    this.startPosition = this.lastCurrentTime = 0;\n    this.fragPlaying = null;\n  };\n\n  _proto.onManifestParsed = function onManifestParsed(event, data) {\n    var aac = false;\n    var heaac = false;\n    var codec;\n    data.levels.forEach(function (level) {\n      // detect if we have different kind of audio codecs used amongst playlists\n      codec = level.audioCodec;\n\n      if (codec) {\n        if (codec.indexOf('mp4a.40.2') !== -1) {\n          aac = true;\n        }\n\n        if (codec.indexOf('mp4a.40.5') !== -1) {\n          heaac = true;\n        }\n      }\n    });\n    this.audioCodecSwitch = aac && heaac && !Object(_is_supported__WEBPACK_IMPORTED_MODULE_2__[\"changeTypeSupported\"])();\n\n    if (this.audioCodecSwitch) {\n      this.log('Both AAC/HE-AAC audio found in levels; declaring level codec as HE-AAC');\n    }\n\n    this.levels = data.levels;\n    this.startFragRequested = false;\n  };\n\n  _proto.onLevelLoading = function onLevelLoading(event, data) {\n    var levels = this.levels;\n\n    if (!levels || this.state !== _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"State\"].IDLE) {\n      return;\n    }\n\n    var level = levels[data.level];\n\n    if (!level.details || level.details.live && this.levelLastLoaded !== data.level || this.waitForCdnTuneIn(level.details)) {\n      this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"State\"].WAITING_LEVEL;\n    }\n  };\n\n  _proto.onLevelLoaded = function onLevelLoaded(event, data) {\n    var _curLevel$details;\n\n    var levels = this.levels;\n    var newLevelId = data.level;\n    var newDetails = data.details;\n    var duration = newDetails.totalduration;\n\n    if (!levels) {\n      this.warn(\"Levels were reset while loading level \" + newLevelId);\n      return;\n    }\n\n    this.log(\"Level \" + newLevelId + \" loaded [\" + newDetails.startSN + \",\" + newDetails.endSN + \"], cc [\" + newDetails.startCC + \", \" + newDetails.endCC + \"] duration:\" + duration);\n    var fragCurrent = this.fragCurrent;\n\n    if (fragCurrent && (this.state === _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"State\"].FRAG_LOADING || this.state === _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"State\"].FRAG_LOADING_WAITING_RETRY)) {\n      if (fragCurrent.level !== data.level && fragCurrent.loader) {\n        this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"State\"].IDLE;\n        fragCurrent.loader.abort();\n      }\n    }\n\n    var curLevel = levels[newLevelId];\n    var sliding = 0;\n\n    if (newDetails.live || (_curLevel$details = curLevel.details) !== null && _curLevel$details !== void 0 && _curLevel$details.live) {\n      if (!newDetails.fragments[0]) {\n        newDetails.deltaUpdateFailed = true;\n      }\n\n      if (newDetails.deltaUpdateFailed) {\n        return;\n      }\n\n      sliding = this.alignPlaylists(newDetails, curLevel.details);\n    } // override level info\n\n\n    curLevel.details = newDetails;\n    this.levelLastLoaded = newLevelId;\n    this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_3__[\"Events\"].LEVEL_UPDATED, {\n      details: newDetails,\n      level: newLevelId\n    }); // only switch back to IDLE state if we were waiting for level to start downloading a new fragment\n\n    if (this.state === _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"State\"].WAITING_LEVEL) {\n      if (this.waitForCdnTuneIn(newDetails)) {\n        // Wait for Low-Latency CDN Tune-in\n        return;\n      }\n\n      this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"State\"].IDLE;\n    }\n\n    if (!this.startFragRequested) {\n      this.setStartPosition(newDetails, sliding);\n    } else if (newDetails.live) {\n      this.synchronizeToLiveEdge(newDetails);\n    } // trigger handler right now\n\n\n    this.tick();\n  };\n\n  _proto._handleFragmentLoadProgress = function _handleFragmentLoadProgress(data) {\n    var _frag$initSegment;\n\n    var frag = data.frag,\n        part = data.part,\n        payload = data.payload;\n    var levels = this.levels;\n\n    if (!levels) {\n      this.warn(\"Levels were reset while fragment load was in progress. Fragment \" + frag.sn + \" of level \" + frag.level + \" will not be buffered\");\n      return;\n    }\n\n    var currentLevel = levels[frag.level];\n    var details = currentLevel.details;\n\n    if (!details) {\n      this.warn(\"Dropping fragment \" + frag.sn + \" of level \" + frag.level + \" after level details were reset\");\n      return;\n    }\n\n    var videoCodec = currentLevel.videoCodec; // time Offset is accurate if level PTS is known, or if playlist is not sliding (not live)\n\n    var accurateTimeOffset = details.PTSKnown || !details.live;\n    var initSegmentData = (_frag$initSegment = frag.initSegment) === null || _frag$initSegment === void 0 ? void 0 : _frag$initSegment.data;\n\n    var audioCodec = this._getAudioCodec(currentLevel); // transmux the MPEG-TS data to ISO-BMFF segments\n    // this.log(`Transmuxing ${frag.sn} of [${details.startSN} ,${details.endSN}],level ${frag.level}, cc ${frag.cc}`);\n\n\n    var transmuxer = this.transmuxer = this.transmuxer || new _demux_transmuxer_interface__WEBPACK_IMPORTED_MODULE_8__[\"default\"](this.hls, _types_loader__WEBPACK_IMPORTED_MODULE_6__[\"PlaylistLevelType\"].MAIN, this._handleTransmuxComplete.bind(this), this._handleTransmuxerFlush.bind(this));\n    var partIndex = part ? part.index : -1;\n    var partial = partIndex !== -1;\n    var chunkMeta = new _types_transmuxer__WEBPACK_IMPORTED_MODULE_9__[\"ChunkMetadata\"](frag.level, frag.sn, frag.stats.chunkCount, payload.byteLength, partIndex, partial);\n    var initPTS = this.initPTS[frag.cc];\n    transmuxer.push(payload, initSegmentData, audioCodec, videoCodec, frag, part, details.totalduration, accurateTimeOffset, chunkMeta, initPTS);\n  };\n\n  _proto.onAudioTrackSwitching = function onAudioTrackSwitching(event, data) {\n    // if any URL found on new audio track, it is an alternate audio track\n    var fromAltAudio = this.altAudio;\n    var altAudio = !!data.url;\n    var trackId = data.id; // if we switch on main audio, ensure that main fragment scheduling is synced with media.buffered\n    // don't do anything if we switch to alt audio: audio stream controller is handling it.\n    // we will just have to change buffer scheduling on audioTrackSwitched\n\n    if (!altAudio) {\n      if (this.mediaBuffer !== this.media) {\n        this.log('Switching on main audio, use media.buffered to schedule main fragment loading');\n        this.mediaBuffer = this.media;\n        var fragCurrent = this.fragCurrent; // we need to refill audio buffer from main: cancel any frag loading to speed up audio switch\n\n        if (fragCurrent !== null && fragCurrent !== void 0 && fragCurrent.loader) {\n          this.log('Switching to main audio track, cancel main fragment load');\n          fragCurrent.loader.abort();\n        } // destroy transmuxer to force init segment generation (following audio switch)\n\n\n        this.resetTransmuxer(); // switch to IDLE state to load new fragment\n\n        this.resetLoadingState();\n      } else if (this.audioOnly) {\n        // Reset audio transmuxer so when switching back to main audio we're not still appending where we left off\n        this.resetTransmuxer();\n      }\n\n      var hls = this.hls; // If switching from alt to main audio, flush all audio and trigger track switched\n\n      if (fromAltAudio) {\n        hls.trigger(_events__WEBPACK_IMPORTED_MODULE_3__[\"Events\"].BUFFER_FLUSHING, {\n          startOffset: 0,\n          endOffset: Number.POSITIVE_INFINITY,\n          type: 'audio'\n        });\n      }\n\n      hls.trigger(_events__WEBPACK_IMPORTED_MODULE_3__[\"Events\"].AUDIO_TRACK_SWITCHED, {\n        id: trackId\n      });\n    }\n  };\n\n  _proto.onAudioTrackSwitched = function onAudioTrackSwitched(event, data) {\n    var trackId = data.id;\n    var altAudio = !!this.hls.audioTracks[trackId].url;\n\n    if (altAudio) {\n      var videoBuffer = this.videoBuffer; // if we switched on alternate audio, ensure that main fragment scheduling is synced with video sourcebuffer buffered\n\n      if (videoBuffer && this.mediaBuffer !== videoBuffer) {\n        this.log('Switching on alternate audio, use video.buffered to schedule main fragment loading');\n        this.mediaBuffer = videoBuffer;\n      }\n    }\n\n    this.altAudio = altAudio;\n    this.tick();\n  };\n\n  _proto.onBufferCreated = function onBufferCreated(event, data) {\n    var tracks = data.tracks;\n    var mediaTrack;\n    var name;\n    var alternate = false;\n\n    for (var type in tracks) {\n      var track = tracks[type];\n\n      if (track.id === 'main') {\n        name = type;\n        mediaTrack = track; // keep video source buffer reference\n\n        if (type === 'video') {\n          var videoTrack = tracks[type];\n\n          if (videoTrack) {\n            this.videoBuffer = videoTrack.buffer;\n          }\n        }\n      } else {\n        alternate = true;\n      }\n    }\n\n    if (alternate && mediaTrack) {\n      this.log(\"Alternate track found, use \" + name + \".buffered to schedule main fragment loading\");\n      this.mediaBuffer = mediaTrack.buffer;\n    } else {\n      this.mediaBuffer = this.media;\n    }\n  };\n\n  _proto.onFragBuffered = function onFragBuffered(event, data) {\n    var frag = data.frag,\n        part = data.part;\n\n    if (frag && frag.type !== _types_loader__WEBPACK_IMPORTED_MODULE_6__[\"PlaylistLevelType\"].MAIN) {\n      return;\n    }\n\n    if (this.fragContextChanged(frag)) {\n      // If a level switch was requested while a fragment was buffering, it will emit the FRAG_BUFFERED event upon completion\n      // Avoid setting state back to IDLE, since that will interfere with a level switch\n      this.warn(\"Fragment \" + frag.sn + (part ? ' p: ' + part.index : '') + \" of level \" + frag.level + \" finished buffering, but was aborted. state: \" + this.state);\n\n      if (this.state === _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"State\"].PARSED) {\n        this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"State\"].IDLE;\n      }\n\n      return;\n    }\n\n    var stats = part ? part.stats : frag.stats;\n    this.fragLastKbps = Math.round(8 * stats.total / (stats.buffering.end - stats.loading.first));\n\n    if (frag.sn !== 'initSegment') {\n      this.fragPrevious = frag;\n    }\n\n    this.fragBufferedComplete(frag, part);\n  };\n\n  _proto.onError = function onError(event, data) {\n    switch (data.details) {\n      case _errors__WEBPACK_IMPORTED_MODULE_11__[\"ErrorDetails\"].FRAG_LOAD_ERROR:\n      case _errors__WEBPACK_IMPORTED_MODULE_11__[\"ErrorDetails\"].FRAG_LOAD_TIMEOUT:\n      case _errors__WEBPACK_IMPORTED_MODULE_11__[\"ErrorDetails\"].KEY_LOAD_ERROR:\n      case _errors__WEBPACK_IMPORTED_MODULE_11__[\"ErrorDetails\"].KEY_LOAD_TIMEOUT:\n        this.onFragmentOrKeyLoadError(_types_loader__WEBPACK_IMPORTED_MODULE_6__[\"PlaylistLevelType\"].MAIN, data);\n        break;\n\n      case _errors__WEBPACK_IMPORTED_MODULE_11__[\"ErrorDetails\"].LEVEL_LOAD_ERROR:\n      case _errors__WEBPACK_IMPORTED_MODULE_11__[\"ErrorDetails\"].LEVEL_LOAD_TIMEOUT:\n        if (this.state !== _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"State\"].ERROR) {\n          if (data.fatal) {\n            // if fatal error, stop processing\n            this.warn(\"\" + data.details);\n            this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"State\"].ERROR;\n          } else {\n            // in case of non fatal error while loading level, if level controller is not retrying to load level , switch back to IDLE\n            if (!data.levelRetry && this.state === _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"State\"].WAITING_LEVEL) {\n              this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"State\"].IDLE;\n            }\n          }\n        }\n\n        break;\n\n      case _errors__WEBPACK_IMPORTED_MODULE_11__[\"ErrorDetails\"].BUFFER_FULL_ERROR:\n        // if in appending state\n        if (data.parent === 'main' && (this.state === _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"State\"].PARSING || this.state === _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"State\"].PARSED)) {\n          var flushBuffer = true;\n          var bufferedInfo = this.getFwdBufferInfo(this.media, _types_loader__WEBPACK_IMPORTED_MODULE_6__[\"PlaylistLevelType\"].MAIN); // 0.5 : tolerance needed as some browsers stalls playback before reaching buffered end\n          // reduce max buf len if current position is buffered\n\n          if (bufferedInfo && bufferedInfo.len > 0.5) {\n            flushBuffer = !this.reduceMaxBufferLength(bufferedInfo.len);\n          }\n\n          if (flushBuffer) {\n            // current position is not buffered, but browser is still complaining about buffer full error\n            // this happens on IE/Edge, refer to https://github.com/video-dev/hls.js/pull/708\n            // in that case flush the whole buffer to recover\n            this.warn('buffer full error also media.currentTime is not buffered, flush main'); // flush main buffer\n\n            this.immediateLevelSwitch();\n          }\n\n          this.resetLoadingState();\n        }\n\n        break;\n\n      default:\n        break;\n    }\n  } // Checks the health of the buffer and attempts to resolve playback stalls.\n  ;\n\n  _proto.checkBuffer = function checkBuffer() {\n    var media = this.media,\n        gapController = this.gapController;\n\n    if (!media || !gapController || !media.readyState) {\n      // Exit early if we don't have media or if the media hasn't buffered anything yet (readyState 0)\n      return;\n    } // Check combined buffer\n\n\n    var buffered = _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_4__[\"BufferHelper\"].getBuffered(media);\n\n    if (!this.loadedmetadata && buffered.length) {\n      this.loadedmetadata = true;\n      this.seekToStartPos();\n    } else {\n      // Resolve gaps using the main buffer, whose ranges are the intersections of the A/V sourcebuffers\n      gapController.poll(this.lastCurrentTime);\n    }\n\n    this.lastCurrentTime = media.currentTime;\n  };\n\n  _proto.onFragLoadEmergencyAborted = function onFragLoadEmergencyAborted() {\n    this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"State\"].IDLE; // if loadedmetadata is not set, it means that we are emergency switch down on first frag\n    // in that case, reset startFragRequested flag\n\n    if (!this.loadedmetadata) {\n      this.startFragRequested = false;\n      this.nextLoadPosition = this.startPosition;\n    }\n\n    this.tickImmediate();\n  };\n\n  _proto.onBufferFlushed = function onBufferFlushed(event, _ref) {\n    var type = _ref.type;\n\n    if (type !== _loader_fragment__WEBPACK_IMPORTED_MODULE_7__[\"ElementaryStreamTypes\"].AUDIO || this.audioOnly && !this.altAudio) {\n      var media = (type === _loader_fragment__WEBPACK_IMPORTED_MODULE_7__[\"ElementaryStreamTypes\"].VIDEO ? this.videoBuffer : this.mediaBuffer) || this.media;\n      this.afterBufferFlushed(media, type, _types_loader__WEBPACK_IMPORTED_MODULE_6__[\"PlaylistLevelType\"].MAIN);\n    }\n  };\n\n  _proto.onLevelsUpdated = function onLevelsUpdated(event, data) {\n    this.levels = data.levels;\n  };\n\n  _proto.swapAudioCodec = function swapAudioCodec() {\n    this.audioCodecSwap = !this.audioCodecSwap;\n  }\n  /**\n   * Seeks to the set startPosition if not equal to the mediaElement's current time.\n   * @private\n   */\n  ;\n\n  _proto.seekToStartPos = function seekToStartPos() {\n    var media = this.media;\n    var currentTime = media.currentTime;\n    var startPosition = this.startPosition; // only adjust currentTime if different from startPosition or if startPosition not buffered\n    // at that stage, there should be only one buffered range, as we reach that code after first fragment has been buffered\n\n    if (startPosition >= 0 && currentTime < startPosition) {\n      if (media.seeking) {\n        _utils_logger__WEBPACK_IMPORTED_MODULE_12__[\"logger\"].log(\"could not seek to \" + startPosition + \", already seeking at \" + currentTime);\n        return;\n      }\n\n      var buffered = _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_4__[\"BufferHelper\"].getBuffered(media);\n      var bufferStart = buffered.length ? buffered.start(0) : 0;\n      var delta = bufferStart - startPosition;\n\n      if (delta > 0 && (delta < this.config.maxBufferHole || delta < this.config.maxFragLookUpTolerance)) {\n        _utils_logger__WEBPACK_IMPORTED_MODULE_12__[\"logger\"].log(\"adjusting start position by \" + delta + \" to match buffer start\");\n        startPosition += delta;\n        this.startPosition = startPosition;\n      }\n\n      this.log(\"seek to target start position \" + startPosition + \" from current time \" + currentTime);\n      media.currentTime = startPosition;\n    }\n  };\n\n  _proto._getAudioCodec = function _getAudioCodec(currentLevel) {\n    var audioCodec = this.config.defaultAudioCodec || currentLevel.audioCodec;\n\n    if (this.audioCodecSwap && audioCodec) {\n      this.log('Swapping audio codec');\n\n      if (audioCodec.indexOf('mp4a.40.5') !== -1) {\n        audioCodec = 'mp4a.40.2';\n      } else {\n        audioCodec = 'mp4a.40.5';\n      }\n    }\n\n    return audioCodec;\n  };\n\n  _proto._loadBitrateTestFrag = function _loadBitrateTestFrag(frag) {\n    var _this2 = this;\n\n    this._doFragLoad(frag).then(function (data) {\n      var hls = _this2.hls;\n\n      if (!data || hls.nextLoadLevel || _this2.fragContextChanged(frag)) {\n        return;\n      }\n\n      _this2.fragLoadError = 0;\n      _this2.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"State\"].IDLE;\n      _this2.startFragRequested = false;\n      _this2.bitrateTest = false;\n      var stats = frag.stats; // Bitrate tests fragments are neither parsed nor buffered\n\n      stats.parsing.start = stats.parsing.end = stats.buffering.start = stats.buffering.end = self.performance.now();\n      hls.trigger(_events__WEBPACK_IMPORTED_MODULE_3__[\"Events\"].FRAG_LOADED, data);\n    });\n  };\n\n  _proto._handleTransmuxComplete = function _handleTransmuxComplete(transmuxResult) {\n    var _id3$samples;\n\n    var id = 'main';\n    var hls = this.hls;\n    var remuxResult = transmuxResult.remuxResult,\n        chunkMeta = transmuxResult.chunkMeta;\n    var context = this.getCurrentContext(chunkMeta);\n\n    if (!context) {\n      this.warn(\"The loading context changed while buffering fragment \" + chunkMeta.sn + \" of level \" + chunkMeta.level + \". This chunk will not be buffered.\");\n      this.resetLiveStartWhenNotLoaded(chunkMeta.level);\n      return;\n    }\n\n    var frag = context.frag,\n        part = context.part,\n        level = context.level;\n    var video = remuxResult.video,\n        text = remuxResult.text,\n        id3 = remuxResult.id3,\n        initSegment = remuxResult.initSegment; // The audio-stream-controller handles audio buffering if Hls.js is playing an alternate audio track\n\n    var audio = this.altAudio ? undefined : remuxResult.audio; // Check if the current fragment has been aborted. We check this by first seeing if we're still playing the current level.\n    // If we are, subsequently check if the currently loading fragment (fragCurrent) has changed.\n\n    if (this.fragContextChanged(frag)) {\n      return;\n    }\n\n    this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"State\"].PARSING;\n\n    if (initSegment) {\n      if (initSegment.tracks) {\n        this._bufferInitSegment(level, initSegment.tracks, frag, chunkMeta);\n\n        hls.trigger(_events__WEBPACK_IMPORTED_MODULE_3__[\"Events\"].FRAG_PARSING_INIT_SEGMENT, {\n          frag: frag,\n          id: id,\n          tracks: initSegment.tracks\n        });\n      } // This would be nice if Number.isFinite acted as a typeguard, but it doesn't. See: https://github.com/Microsoft/TypeScript/issues/10038\n\n\n      var initPTS = initSegment.initPTS;\n      var timescale = initSegment.timescale;\n\n      if (Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__[\"isFiniteNumber\"])(initPTS)) {\n        this.initPTS[frag.cc] = initPTS;\n        hls.trigger(_events__WEBPACK_IMPORTED_MODULE_3__[\"Events\"].INIT_PTS_FOUND, {\n          frag: frag,\n          id: id,\n          initPTS: initPTS,\n          timescale: timescale\n        });\n      }\n    } // Avoid buffering if backtracking this fragment\n\n\n    if (video && remuxResult.independent !== false) {\n      if (level.details) {\n        var startPTS = video.startPTS,\n            endPTS = video.endPTS,\n            startDTS = video.startDTS,\n            endDTS = video.endDTS;\n\n        if (part) {\n          part.elementaryStreams[video.type] = {\n            startPTS: startPTS,\n            endPTS: endPTS,\n            startDTS: startDTS,\n            endDTS: endDTS\n          };\n        } else {\n          if (video.firstKeyFrame && video.independent) {\n            this.couldBacktrack = true;\n          }\n\n          if (video.dropped && video.independent) {\n            // Backtrack if dropped frames create a gap after currentTime\n            var pos = this.getLoadPosition() + this.config.maxBufferHole;\n\n            if (pos < startPTS) {\n              this.backtrack(frag);\n              return;\n            } // Set video stream start to fragment start so that truncated samples do not distort the timeline, and mark it partial\n\n\n            frag.setElementaryStreamInfo(video.type, frag.start, endPTS, frag.start, endDTS, true);\n          }\n        }\n\n        frag.setElementaryStreamInfo(video.type, startPTS, endPTS, startDTS, endDTS);\n        this.bufferFragmentData(video, frag, part, chunkMeta);\n      }\n    } else if (remuxResult.independent === false) {\n      this.backtrack(frag);\n      return;\n    }\n\n    if (audio) {\n      var _startPTS = audio.startPTS,\n          _endPTS = audio.endPTS,\n          _startDTS = audio.startDTS,\n          _endDTS = audio.endDTS;\n\n      if (part) {\n        part.elementaryStreams[_loader_fragment__WEBPACK_IMPORTED_MODULE_7__[\"ElementaryStreamTypes\"].AUDIO] = {\n          startPTS: _startPTS,\n          endPTS: _endPTS,\n          startDTS: _startDTS,\n          endDTS: _endDTS\n        };\n      }\n\n      frag.setElementaryStreamInfo(_loader_fragment__WEBPACK_IMPORTED_MODULE_7__[\"ElementaryStreamTypes\"].AUDIO, _startPTS, _endPTS, _startDTS, _endDTS);\n      this.bufferFragmentData(audio, frag, part, chunkMeta);\n    }\n\n    if (id3 !== null && id3 !== void 0 && (_id3$samples = id3.samples) !== null && _id3$samples !== void 0 && _id3$samples.length) {\n      var emittedID3 = {\n        frag: frag,\n        id: id,\n        samples: id3.samples\n      };\n      hls.trigger(_events__WEBPACK_IMPORTED_MODULE_3__[\"Events\"].FRAG_PARSING_METADATA, emittedID3);\n    }\n\n    if (text) {\n      var emittedText = {\n        frag: frag,\n        id: id,\n        samples: text.samples\n      };\n      hls.trigger(_events__WEBPACK_IMPORTED_MODULE_3__[\"Events\"].FRAG_PARSING_USERDATA, emittedText);\n    }\n  };\n\n  _proto._bufferInitSegment = function _bufferInitSegment(currentLevel, tracks, frag, chunkMeta) {\n    var _this3 = this;\n\n    if (this.state !== _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"State\"].PARSING) {\n      return;\n    }\n\n    this.audioOnly = !!tracks.audio && !tracks.video; // if audio track is expected to come from audio stream controller, discard any coming from main\n\n    if (this.altAudio && !this.audioOnly) {\n      delete tracks.audio;\n    } // include levelCodec in audio and video tracks\n\n\n    var audio = tracks.audio,\n        video = tracks.video,\n        audiovideo = tracks.audiovideo;\n\n    if (audio) {\n      var audioCodec = currentLevel.audioCodec;\n      var ua = navigator.userAgent.toLowerCase();\n\n      if (this.audioCodecSwitch) {\n        if (audioCodec) {\n          if (audioCodec.indexOf('mp4a.40.5') !== -1) {\n            audioCodec = 'mp4a.40.2';\n          } else {\n            audioCodec = 'mp4a.40.5';\n          }\n        } // In the case that AAC and HE-AAC audio codecs are signalled in manifest,\n        // force HE-AAC, as it seems that most browsers prefers it.\n        // don't force HE-AAC if mono stream, or in Firefox\n\n\n        if (audio.metadata.channelCount !== 1 && ua.indexOf('firefox') === -1) {\n          audioCodec = 'mp4a.40.5';\n        }\n      } // HE-AAC is broken on Android, always signal audio codec as AAC even if variant manifest states otherwise\n\n\n      if (ua.indexOf('android') !== -1 && audio.container !== 'audio/mpeg') {\n        // Exclude mpeg audio\n        audioCodec = 'mp4a.40.2';\n        this.log(\"Android: force audio codec to \" + audioCodec);\n      }\n\n      if (currentLevel.audioCodec && currentLevel.audioCodec !== audioCodec) {\n        this.log(\"Swapping manifest audio codec \\\"\" + currentLevel.audioCodec + \"\\\" for \\\"\" + audioCodec + \"\\\"\");\n      }\n\n      audio.levelCodec = audioCodec;\n      audio.id = 'main';\n      this.log(\"Init audio buffer, container:\" + audio.container + \", codecs[selected/level/parsed]=[\" + (audioCodec || '') + \"/\" + (currentLevel.audioCodec || '') + \"/\" + audio.codec + \"]\");\n    }\n\n    if (video) {\n      video.levelCodec = currentLevel.videoCodec;\n      video.id = 'main';\n      this.log(\"Init video buffer, container:\" + video.container + \", codecs[level/parsed]=[\" + (currentLevel.videoCodec || '') + \"/\" + video.codec + \"]\");\n    }\n\n    if (audiovideo) {\n      this.log(\"Init audiovideo buffer, container:\" + audiovideo.container + \", codecs[level/parsed]=[\" + (currentLevel.attrs.CODECS || '') + \"/\" + audiovideo.codec + \"]\");\n    }\n\n    this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_3__[\"Events\"].BUFFER_CODECS, tracks); // loop through tracks that are going to be provided to bufferController\n\n    Object.keys(tracks).forEach(function (trackName) {\n      var track = tracks[trackName];\n      var initSegment = track.initSegment;\n\n      if (initSegment !== null && initSegment !== void 0 && initSegment.byteLength) {\n        _this3.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_3__[\"Events\"].BUFFER_APPENDING, {\n          type: trackName,\n          data: initSegment,\n          frag: frag,\n          part: null,\n          chunkMeta: chunkMeta,\n          parent: frag.type\n        });\n      }\n    }); // trigger handler right now\n\n    this.tick();\n  };\n\n  _proto.backtrack = function backtrack(frag) {\n    this.couldBacktrack = true; // Causes findFragments to backtrack through fragments to find the keyframe\n\n    this.resetTransmuxer();\n    this.flushBufferGap(frag);\n    var data = this.fragmentTracker.backtrack(frag);\n    this.fragPrevious = null;\n    this.nextLoadPosition = frag.start;\n\n    if (data) {\n      this.resetFragmentLoading(frag);\n    } else {\n      // Change state to BACKTRACKING so that fragmentEntity.backtrack data can be added after _doFragLoad\n      this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"State\"].BACKTRACKING;\n    }\n  };\n\n  _proto.checkFragmentChanged = function checkFragmentChanged() {\n    var video = this.media;\n    var fragPlayingCurrent = null;\n\n    if (video && video.readyState > 1 && video.seeking === false) {\n      var currentTime = video.currentTime;\n      /* if video element is in seeked state, currentTime can only increase.\n        (assuming that playback rate is positive ...)\n        As sometimes currentTime jumps back to zero after a\n        media decode error, check this, to avoid seeking back to\n        wrong position after a media decode error\n      */\n\n      if (_utils_buffer_helper__WEBPACK_IMPORTED_MODULE_4__[\"BufferHelper\"].isBuffered(video, currentTime)) {\n        fragPlayingCurrent = this.getAppendedFrag(currentTime);\n      } else if (_utils_buffer_helper__WEBPACK_IMPORTED_MODULE_4__[\"BufferHelper\"].isBuffered(video, currentTime + 0.1)) {\n        /* ensure that FRAG_CHANGED event is triggered at startup,\n          when first video frame is displayed and playback is paused.\n          add a tolerance of 100ms, in case current position is not buffered,\n          check if current pos+100ms is buffered and use that buffer range\n          for FRAG_CHANGED event reporting */\n        fragPlayingCurrent = this.getAppendedFrag(currentTime + 0.1);\n      }\n\n      if (fragPlayingCurrent) {\n        var fragPlaying = this.fragPlaying;\n        var fragCurrentLevel = fragPlayingCurrent.level;\n\n        if (!fragPlaying || fragPlayingCurrent.sn !== fragPlaying.sn || fragPlaying.level !== fragCurrentLevel || fragPlayingCurrent.urlId !== fragPlaying.urlId) {\n          this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_3__[\"Events\"].FRAG_CHANGED, {\n            frag: fragPlayingCurrent\n          });\n\n          if (!fragPlaying || fragPlaying.level !== fragCurrentLevel) {\n            this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_3__[\"Events\"].LEVEL_SWITCHED, {\n              level: fragCurrentLevel\n            });\n          }\n\n          this.fragPlaying = fragPlayingCurrent;\n        }\n      }\n    }\n  };\n\n  _createClass(StreamController, [{\n    key: \"nextLevel\",\n    get: function get() {\n      var frag = this.nextBufferedFrag;\n\n      if (frag) {\n        return frag.level;\n      } else {\n        return -1;\n      }\n    }\n  }, {\n    key: \"currentLevel\",\n    get: function get() {\n      var media = this.media;\n\n      if (media) {\n        var fragPlayingCurrent = this.getAppendedFrag(media.currentTime);\n\n        if (fragPlayingCurrent) {\n          return fragPlayingCurrent.level;\n        }\n      }\n\n      return -1;\n    }\n  }, {\n    key: \"nextBufferedFrag\",\n    get: function get() {\n      var media = this.media;\n\n      if (media) {\n        // first get end range of current fragment\n        var fragPlayingCurrent = this.getAppendedFrag(media.currentTime);\n        return this.followingBufferedFrag(fragPlayingCurrent);\n      } else {\n        return null;\n      }\n    }\n  }, {\n    key: \"forceStartLoad\",\n    get: function get() {\n      return this._forceStartLoad;\n    }\n  }]);\n\n  return StreamController;\n}(_base_stream_controller__WEBPACK_IMPORTED_MODULE_1__[\"default\"]);\n\n\n\n/***/ }),\n\n/***/ \"./src/controller/subtitle-stream-controller.ts\":\n/*!******************************************************!*\\\n  !*** ./src/controller/subtitle-stream-controller.ts ***!\n  \\******************************************************/\n/*! exports provided: SubtitleStreamController */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_410221__) {\n\n\"use strict\";\n__nested_webpack_require_410221__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_410221__.d(__webpack_exports__, \"SubtitleStreamController\", function() { return SubtitleStreamController; });\n/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_410221__(/*! ../events */ \"./src/events.ts\");\n/* harmony import */ var _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_410221__(/*! ../utils/buffer-helper */ \"./src/utils/buffer-helper.ts\");\n/* harmony import */ var _fragment_finders__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_410221__(/*! ./fragment-finders */ \"./src/controller/fragment-finders.ts\");\n/* harmony import */ var _utils_discontinuities__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_410221__(/*! ../utils/discontinuities */ \"./src/utils/discontinuities.ts\");\n/* harmony import */ var _level_helper__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_410221__(/*! ./level-helper */ \"./src/controller/level-helper.ts\");\n/* harmony import */ var _fragment_tracker__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_410221__(/*! ./fragment-tracker */ \"./src/controller/fragment-tracker.ts\");\n/* harmony import */ var _base_stream_controller__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_410221__(/*! ./base-stream-controller */ \"./src/controller/base-stream-controller.ts\");\n/* harmony import */ var _types_loader__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_410221__(/*! ../types/loader */ \"./src/types/loader.ts\");\n/* harmony import */ var _types_level__WEBPACK_IMPORTED_MODULE_8__ = __nested_webpack_require_410221__(/*! ../types/level */ \"./src/types/level.ts\");\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n\n\n\n\n\n\n\n\n\nvar TICK_INTERVAL = 500; // how often to tick in ms\n\nvar SubtitleStreamController = /*#__PURE__*/function (_BaseStreamController) {\n  _inheritsLoose(SubtitleStreamController, _BaseStreamController);\n\n  function SubtitleStreamController(hls, fragmentTracker) {\n    var _this;\n\n    _this = _BaseStreamController.call(this, hls, fragmentTracker, '[subtitle-stream-controller]') || this;\n    _this.levels = [];\n    _this.currentTrackId = -1;\n    _this.tracksBuffered = [];\n    _this.mainDetails = null;\n\n    _this._registerListeners();\n\n    return _this;\n  }\n\n  var _proto = SubtitleStreamController.prototype;\n\n  _proto.onHandlerDestroying = function onHandlerDestroying() {\n    this._unregisterListeners();\n\n    this.mainDetails = null;\n  };\n\n  _proto._registerListeners = function _registerListeners() {\n    var hls = this.hls;\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].MEDIA_ATTACHED, this.onMediaAttached, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].MEDIA_DETACHING, this.onMediaDetaching, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].LEVEL_LOADED, this.onLevelLoaded, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].ERROR, this.onError, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].SUBTITLE_FRAG_PROCESSED, this.onSubtitleFragProcessed, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].BUFFER_FLUSHING, this.onBufferFlushing, this);\n  };\n\n  _proto._unregisterListeners = function _unregisterListeners() {\n    var hls = this.hls;\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].MEDIA_ATTACHED, this.onMediaAttached, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].MEDIA_DETACHING, this.onMediaDetaching, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].LEVEL_LOADED, this.onLevelLoaded, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].ERROR, this.onError, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].SUBTITLE_FRAG_PROCESSED, this.onSubtitleFragProcessed, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].BUFFER_FLUSHING, this.onBufferFlushing, this);\n  };\n\n  _proto.startLoad = function startLoad() {\n    this.stopLoad();\n    this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_6__[\"State\"].IDLE;\n    this.setInterval(TICK_INTERVAL);\n    this.tick();\n  };\n\n  _proto.onManifestLoading = function onManifestLoading() {\n    this.mainDetails = null;\n    this.fragmentTracker.removeAllFragments();\n  };\n\n  _proto.onLevelLoaded = function onLevelLoaded(event, data) {\n    this.mainDetails = data.details;\n  };\n\n  _proto.onSubtitleFragProcessed = function onSubtitleFragProcessed(event, data) {\n    var frag = data.frag,\n        success = data.success;\n    this.fragPrevious = frag;\n    this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_6__[\"State\"].IDLE;\n\n    if (!success) {\n      return;\n    }\n\n    var buffered = this.tracksBuffered[this.currentTrackId];\n\n    if (!buffered) {\n      return;\n    } // Create/update a buffered array matching the interface used by BufferHelper.bufferedInfo\n    // so we can re-use the logic used to detect how much has been buffered\n\n\n    var timeRange;\n    var fragStart = frag.start;\n\n    for (var i = 0; i < buffered.length; i++) {\n      if (fragStart >= buffered[i].start && fragStart <= buffered[i].end) {\n        timeRange = buffered[i];\n        break;\n      }\n    }\n\n    var fragEnd = frag.start + frag.duration;\n\n    if (timeRange) {\n      timeRange.end = fragEnd;\n    } else {\n      timeRange = {\n        start: fragStart,\n        end: fragEnd\n      };\n      buffered.push(timeRange);\n    }\n\n    this.fragmentTracker.fragBuffered(frag);\n  };\n\n  _proto.onBufferFlushing = function onBufferFlushing(event, data) {\n    var startOffset = data.startOffset,\n        endOffset = data.endOffset;\n\n    if (startOffset === 0 && endOffset !== Number.POSITIVE_INFINITY) {\n      var currentTrackId = this.currentTrackId,\n          levels = this.levels;\n\n      if (!levels.length || !levels[currentTrackId] || !levels[currentTrackId].details) {\n        return;\n      }\n\n      var trackDetails = levels[currentTrackId].details;\n      var targetDuration = trackDetails.targetduration;\n      var endOffsetSubtitles = endOffset - targetDuration;\n\n      if (endOffsetSubtitles <= 0) {\n        return;\n      }\n\n      data.endOffsetSubtitles = Math.max(0, endOffsetSubtitles);\n      this.tracksBuffered.forEach(function (buffered) {\n        for (var i = 0; i < buffered.length;) {\n          if (buffered[i].end <= endOffsetSubtitles) {\n            buffered.shift();\n            continue;\n          } else if (buffered[i].start < endOffsetSubtitles) {\n            buffered[i].start = endOffsetSubtitles;\n          } else {\n            break;\n          }\n\n          i++;\n        }\n      });\n      this.fragmentTracker.removeFragmentsInRange(startOffset, endOffsetSubtitles, _types_loader__WEBPACK_IMPORTED_MODULE_7__[\"PlaylistLevelType\"].SUBTITLE);\n    }\n  } // If something goes wrong, proceed to next frag, if we were processing one.\n  ;\n\n  _proto.onError = function onError(event, data) {\n    var _this$fragCurrent;\n\n    var frag = data.frag; // don't handle error not related to subtitle fragment\n\n    if (!frag || frag.type !== _types_loader__WEBPACK_IMPORTED_MODULE_7__[\"PlaylistLevelType\"].SUBTITLE) {\n      return;\n    }\n\n    if ((_this$fragCurrent = this.fragCurrent) !== null && _this$fragCurrent !== void 0 && _this$fragCurrent.loader) {\n      this.fragCurrent.loader.abort();\n    }\n\n    this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_6__[\"State\"].IDLE;\n  } // Got all new subtitle levels.\n  ;\n\n  _proto.onSubtitleTracksUpdated = function onSubtitleTracksUpdated(event, _ref) {\n    var _this2 = this;\n\n    var subtitleTracks = _ref.subtitleTracks;\n    this.tracksBuffered = [];\n    this.levels = subtitleTracks.map(function (mediaPlaylist) {\n      return new _types_level__WEBPACK_IMPORTED_MODULE_8__[\"Level\"](mediaPlaylist);\n    });\n    this.fragmentTracker.removeAllFragments();\n    this.fragPrevious = null;\n    this.levels.forEach(function (level) {\n      _this2.tracksBuffered[level.id] = [];\n    });\n    this.mediaBuffer = null;\n  };\n\n  _proto.onSubtitleTrackSwitch = function onSubtitleTrackSwitch(event, data) {\n    this.currentTrackId = data.id;\n\n    if (!this.levels.length || this.currentTrackId === -1) {\n      this.clearInterval();\n      return;\n    } // Check if track has the necessary details to load fragments\n\n\n    var currentTrack = this.levels[this.currentTrackId];\n\n    if (currentTrack !== null && currentTrack !== void 0 && currentTrack.details) {\n      this.mediaBuffer = this.mediaBufferTimeRanges;\n    } else {\n      this.mediaBuffer = null;\n    }\n\n    if (currentTrack) {\n      this.setInterval(TICK_INTERVAL);\n    }\n  } // Got a new set of subtitle fragments.\n  ;\n\n  _proto.onSubtitleTrackLoaded = function onSubtitleTrackLoaded(event, data) {\n    var _track$details;\n\n    var newDetails = data.details,\n        trackId = data.id;\n    var currentTrackId = this.currentTrackId,\n        levels = this.levels;\n\n    if (!levels.length) {\n      return;\n    }\n\n    var track = levels[currentTrackId];\n\n    if (trackId >= levels.length || trackId !== currentTrackId || !track) {\n      return;\n    }\n\n    this.mediaBuffer = this.mediaBufferTimeRanges;\n\n    if (newDetails.live || (_track$details = track.details) !== null && _track$details !== void 0 && _track$details.live) {\n      var mainDetails = this.mainDetails;\n\n      if (newDetails.deltaUpdateFailed || !mainDetails) {\n        return;\n      }\n\n      var mainSlidingStartFragment = mainDetails.fragments[0];\n\n      if (!track.details) {\n        if (newDetails.hasProgramDateTime && mainDetails.hasProgramDateTime) {\n          Object(_utils_discontinuities__WEBPACK_IMPORTED_MODULE_3__[\"alignMediaPlaylistByPDT\"])(newDetails, mainDetails);\n        } else if (mainSlidingStartFragment) {\n          // line up live playlist with main so that fragments in range are loaded\n          Object(_level_helper__WEBPACK_IMPORTED_MODULE_4__[\"addSliding\"])(newDetails, mainSlidingStartFragment.start);\n        }\n      } else {\n        var sliding = this.alignPlaylists(newDetails, track.details);\n\n        if (sliding === 0 && mainSlidingStartFragment) {\n          // realign with main when there is no overlap with last refresh\n          Object(_level_helper__WEBPACK_IMPORTED_MODULE_4__[\"addSliding\"])(newDetails, mainSlidingStartFragment.start);\n        }\n      }\n    }\n\n    track.details = newDetails;\n    this.levelLastLoaded = trackId; // trigger handler right now\n\n    this.tick(); // If playlist is misaligned because of bad PDT or drift, delete details to resync with main on reload\n\n    if (newDetails.live && !this.fragCurrent && this.media && this.state === _base_stream_controller__WEBPACK_IMPORTED_MODULE_6__[\"State\"].IDLE) {\n      var foundFrag = Object(_fragment_finders__WEBPACK_IMPORTED_MODULE_2__[\"findFragmentByPTS\"])(null, newDetails.fragments, this.media.currentTime, 0);\n\n      if (!foundFrag) {\n        this.warn('Subtitle playlist not aligned with playback');\n        track.details = undefined;\n      }\n    }\n  };\n\n  _proto._handleFragmentLoadComplete = function _handleFragmentLoadComplete(fragLoadedData) {\n    var frag = fragLoadedData.frag,\n        payload = fragLoadedData.payload;\n    var decryptData = frag.decryptdata;\n    var hls = this.hls;\n\n    if (this.fragContextChanged(frag)) {\n      return;\n    } // check to see if the payload needs to be decrypted\n\n\n    if (payload && payload.byteLength > 0 && decryptData && decryptData.key && decryptData.iv && decryptData.method === 'AES-128') {\n      var startTime = performance.now(); // decrypt the subtitles\n\n      this.decrypter.webCryptoDecrypt(new Uint8Array(payload), decryptData.key.buffer, decryptData.iv.buffer).then(function (decryptedData) {\n        var endTime = performance.now();\n        hls.trigger(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].FRAG_DECRYPTED, {\n          frag: frag,\n          payload: decryptedData,\n          stats: {\n            tstart: startTime,\n            tdecrypt: endTime\n          }\n        });\n      });\n    }\n  };\n\n  _proto.doTick = function doTick() {\n    if (!this.media) {\n      this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_6__[\"State\"].IDLE;\n      return;\n    }\n\n    if (this.state === _base_stream_controller__WEBPACK_IMPORTED_MODULE_6__[\"State\"].IDLE) {\n      var _foundFrag;\n\n      var currentTrackId = this.currentTrackId,\n          levels = this.levels;\n\n      if (!levels.length || !levels[currentTrackId] || !levels[currentTrackId].details) {\n        return;\n      } // Expand range of subs loaded by one target-duration in either direction to make up for misaligned playlists\n\n\n      var trackDetails = levels[currentTrackId].details;\n      var targetDuration = trackDetails.targetduration;\n      var config = this.config,\n          media = this.media;\n      var bufferedInfo = _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_1__[\"BufferHelper\"].bufferedInfo(this.mediaBufferTimeRanges, media.currentTime - targetDuration, config.maxBufferHole);\n      var targetBufferTime = bufferedInfo.end,\n          bufferLen = bufferedInfo.len;\n      var maxBufLen = this.getMaxBufferLength() + targetDuration;\n\n      if (bufferLen > maxBufLen) {\n        return;\n      }\n\n      console.assert(trackDetails, 'Subtitle track details are defined on idle subtitle stream controller tick');\n      var fragments = trackDetails.fragments;\n      var fragLen = fragments.length;\n      var end = trackDetails.edge;\n      var foundFrag;\n      var fragPrevious = this.fragPrevious;\n\n      if (targetBufferTime < end) {\n        var maxFragLookUpTolerance = config.maxFragLookUpTolerance;\n        foundFrag = Object(_fragment_finders__WEBPACK_IMPORTED_MODULE_2__[\"findFragmentByPTS\"])(fragPrevious, fragments, targetBufferTime, maxFragLookUpTolerance);\n\n        if (!foundFrag && fragPrevious && fragPrevious.start < fragments[0].start) {\n          foundFrag = fragments[0];\n        }\n      } else {\n        foundFrag = fragments[fragLen - 1];\n      }\n\n      if ((_foundFrag = foundFrag) !== null && _foundFrag !== void 0 && _foundFrag.encrypted) {\n        this.loadKey(foundFrag, trackDetails);\n      } else if (foundFrag && this.fragmentTracker.getState(foundFrag) === _fragment_tracker__WEBPACK_IMPORTED_MODULE_5__[\"FragmentState\"].NOT_LOADED) {\n        // only load if fragment is not loaded\n        this.loadFragment(foundFrag, trackDetails, targetBufferTime);\n      }\n    }\n  };\n\n  _proto.loadFragment = function loadFragment(frag, levelDetails, targetBufferTime) {\n    this.fragCurrent = frag;\n\n    _BaseStreamController.prototype.loadFragment.call(this, frag, levelDetails, targetBufferTime);\n  };\n\n  _createClass(SubtitleStreamController, [{\n    key: \"mediaBufferTimeRanges\",\n    get: function get() {\n      return this.tracksBuffered[this.currentTrackId] || [];\n    }\n  }]);\n\n  return SubtitleStreamController;\n}(_base_stream_controller__WEBPACK_IMPORTED_MODULE_6__[\"default\"]);\n\n/***/ }),\n\n/***/ \"./src/controller/subtitle-track-controller.ts\":\n/*!*****************************************************!*\\\n  !*** ./src/controller/subtitle-track-controller.ts ***!\n  \\*****************************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_427037__) {\n\n\"use strict\";\n__nested_webpack_require_427037__.r(__webpack_exports__);\n/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_427037__(/*! ../events */ \"./src/events.ts\");\n/* harmony import */ var _utils_texttrack_utils__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_427037__(/*! ../utils/texttrack-utils */ \"./src/utils/texttrack-utils.ts\");\n/* harmony import */ var _base_playlist_controller__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_427037__(/*! ./base-playlist-controller */ \"./src/controller/base-playlist-controller.ts\");\n/* harmony import */ var _types_loader__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_427037__(/*! ../types/loader */ \"./src/types/loader.ts\");\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n\n\n\n\n\nvar SubtitleTrackController = /*#__PURE__*/function (_BasePlaylistControll) {\n  _inheritsLoose(SubtitleTrackController, _BasePlaylistControll);\n\n  // Enable/disable subtitle display rendering\n  function SubtitleTrackController(hls) {\n    var _this;\n\n    _this = _BasePlaylistControll.call(this, hls, '[subtitle-track-controller]') || this;\n    _this.media = null;\n    _this.tracks = [];\n    _this.groupId = null;\n    _this.tracksInGroup = [];\n    _this.trackId = -1;\n    _this.selectDefaultTrack = true;\n    _this.queuedDefaultTrack = -1;\n\n    _this.trackChangeListener = function () {\n      return _this.onTextTracksChanged();\n    };\n\n    _this.asyncPollTrackChange = function () {\n      return _this.pollTrackChange(0);\n    };\n\n    _this.useTextTrackPolling = false;\n    _this.subtitlePollingInterval = -1;\n    _this.subtitleDisplay = true;\n\n    _this.registerListeners();\n\n    return _this;\n  }\n\n  var _proto = SubtitleTrackController.prototype;\n\n  _proto.destroy = function destroy() {\n    this.unregisterListeners();\n    this.tracks.length = 0;\n    this.tracksInGroup.length = 0;\n    this.trackChangeListener = this.asyncPollTrackChange = null;\n\n    _BasePlaylistControll.prototype.destroy.call(this);\n  };\n\n  _proto.registerListeners = function registerListeners() {\n    var hls = this.hls;\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].MEDIA_ATTACHED, this.onMediaAttached, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].MEDIA_DETACHING, this.onMediaDetaching, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].MANIFEST_PARSED, this.onManifestParsed, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].LEVEL_LOADING, this.onLevelLoading, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].LEVEL_SWITCHING, this.onLevelSwitching, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].ERROR, this.onError, this);\n  };\n\n  _proto.unregisterListeners = function unregisterListeners() {\n    var hls = this.hls;\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].MEDIA_ATTACHED, this.onMediaAttached, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].MEDIA_DETACHING, this.onMediaDetaching, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].MANIFEST_PARSED, this.onManifestParsed, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].LEVEL_LOADING, this.onLevelLoading, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].LEVEL_SWITCHING, this.onLevelSwitching, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].ERROR, this.onError, this);\n  } // Listen for subtitle track change, then extract the current track ID.\n  ;\n\n  _proto.onMediaAttached = function onMediaAttached(event, data) {\n    this.media = data.media;\n\n    if (!this.media) {\n      return;\n    }\n\n    if (this.queuedDefaultTrack > -1) {\n      this.subtitleTrack = this.queuedDefaultTrack;\n      this.queuedDefaultTrack = -1;\n    }\n\n    this.useTextTrackPolling = !(this.media.textTracks && 'onchange' in this.media.textTracks);\n\n    if (this.useTextTrackPolling) {\n      this.pollTrackChange(500);\n    } else {\n      this.media.textTracks.addEventListener('change', this.asyncPollTrackChange);\n    }\n  };\n\n  _proto.pollTrackChange = function pollTrackChange(timeout) {\n    self.clearInterval(this.subtitlePollingInterval);\n    this.subtitlePollingInterval = self.setInterval(this.trackChangeListener, timeout);\n  };\n\n  _proto.onMediaDetaching = function onMediaDetaching() {\n    if (!this.media) {\n      return;\n    }\n\n    self.clearInterval(this.subtitlePollingInterval);\n\n    if (!this.useTextTrackPolling) {\n      this.media.textTracks.removeEventListener('change', this.asyncPollTrackChange);\n    }\n\n    if (this.trackId > -1) {\n      this.queuedDefaultTrack = this.trackId;\n    }\n\n    var textTracks = filterSubtitleTracks(this.media.textTracks); // Clear loaded cues on media detachment from tracks\n\n    textTracks.forEach(function (track) {\n      Object(_utils_texttrack_utils__WEBPACK_IMPORTED_MODULE_1__[\"clearCurrentCues\"])(track);\n    }); // Disable all subtitle tracks before detachment so when reattached only tracks in that content are enabled.\n\n    this.subtitleTrack = -1;\n    this.media = null;\n  };\n\n  _proto.onManifestLoading = function onManifestLoading() {\n    this.tracks = [];\n    this.groupId = null;\n    this.tracksInGroup = [];\n    this.trackId = -1;\n    this.selectDefaultTrack = true;\n  } // Fired whenever a new manifest is loaded.\n  ;\n\n  _proto.onManifestParsed = function onManifestParsed(event, data) {\n    this.tracks = data.subtitleTracks;\n  };\n\n  _proto.onSubtitleTrackLoaded = function onSubtitleTrackLoaded(event, data) {\n    var id = data.id,\n        details = data.details;\n    var trackId = this.trackId;\n    var currentTrack = this.tracksInGroup[trackId];\n\n    if (!currentTrack) {\n      this.warn(\"Invalid subtitle track id \" + id);\n      return;\n    }\n\n    var curDetails = currentTrack.details;\n    currentTrack.details = data.details;\n    this.log(\"subtitle track \" + id + \" loaded [\" + details.startSN + \"-\" + details.endSN + \"]\");\n\n    if (id === this.trackId) {\n      this.retryCount = 0;\n      this.playlistLoaded(id, data, curDetails);\n    }\n  };\n\n  _proto.onLevelLoading = function onLevelLoading(event, data) {\n    this.switchLevel(data.level);\n  };\n\n  _proto.onLevelSwitching = function onLevelSwitching(event, data) {\n    this.switchLevel(data.level);\n  };\n\n  _proto.switchLevel = function switchLevel(levelIndex) {\n    var levelInfo = this.hls.levels[levelIndex];\n\n    if (!(levelInfo !== null && levelInfo !== void 0 && levelInfo.textGroupIds)) {\n      return;\n    }\n\n    var textGroupId = levelInfo.textGroupIds[levelInfo.urlId];\n\n    if (this.groupId !== textGroupId) {\n      var lastTrack = this.tracksInGroup ? this.tracksInGroup[this.trackId] : undefined;\n      var subtitleTracks = this.tracks.filter(function (track) {\n        return !textGroupId || track.groupId === textGroupId;\n      });\n      this.tracksInGroup = subtitleTracks;\n      var initialTrackId = this.findTrackId(lastTrack === null || lastTrack === void 0 ? void 0 : lastTrack.name) || this.findTrackId();\n      this.groupId = textGroupId;\n      var subtitleTracksUpdated = {\n        subtitleTracks: subtitleTracks\n      };\n      this.log(\"Updating subtitle tracks, \" + subtitleTracks.length + \" track(s) found in \\\"\" + textGroupId + \"\\\" group-id\");\n      this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].SUBTITLE_TRACKS_UPDATED, subtitleTracksUpdated);\n\n      if (initialTrackId !== -1) {\n        this.setSubtitleTrack(initialTrackId, lastTrack);\n      }\n    }\n  };\n\n  _proto.findTrackId = function findTrackId(name) {\n    var textTracks = this.tracksInGroup;\n\n    for (var i = 0; i < textTracks.length; i++) {\n      var track = textTracks[i];\n\n      if (!this.selectDefaultTrack || track.default) {\n        if (!name || name === track.name) {\n          return track.id;\n        }\n      }\n    }\n\n    return -1;\n  };\n\n  _proto.onError = function onError(event, data) {\n    _BasePlaylistControll.prototype.onError.call(this, event, data);\n\n    if (data.fatal || !data.context) {\n      return;\n    }\n\n    if (data.context.type === _types_loader__WEBPACK_IMPORTED_MODULE_3__[\"PlaylistContextType\"].SUBTITLE_TRACK && data.context.id === this.trackId && data.context.groupId === this.groupId) {\n      this.retryLoadingOrFail(data);\n    }\n  }\n  /** get alternate subtitle tracks list from playlist **/\n  ;\n\n  _proto.loadPlaylist = function loadPlaylist(hlsUrlParameters) {\n    var currentTrack = this.tracksInGroup[this.trackId];\n\n    if (this.shouldLoadTrack(currentTrack)) {\n      var id = currentTrack.id;\n      var groupId = currentTrack.groupId;\n      var url = currentTrack.url;\n\n      if (hlsUrlParameters) {\n        try {\n          url = hlsUrlParameters.addDirectives(url);\n        } catch (error) {\n          this.warn(\"Could not construct new URL with HLS Delivery Directives: \" + error);\n        }\n      }\n\n      this.log(\"Loading subtitle playlist for id \" + id);\n      this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].SUBTITLE_TRACK_LOADING, {\n        url: url,\n        id: id,\n        groupId: groupId,\n        deliveryDirectives: hlsUrlParameters || null\n      });\n    }\n  }\n  /**\n   * Disables the old subtitleTrack and sets current mode on the next subtitleTrack.\n   * This operates on the DOM textTracks.\n   * A value of -1 will disable all subtitle tracks.\n   */\n  ;\n\n  _proto.toggleTrackModes = function toggleTrackModes(newId) {\n    var _this2 = this;\n\n    var media = this.media,\n        subtitleDisplay = this.subtitleDisplay,\n        trackId = this.trackId;\n\n    if (!media) {\n      return;\n    }\n\n    var textTracks = filterSubtitleTracks(media.textTracks);\n    var groupTracks = textTracks.filter(function (track) {\n      return track.groupId === _this2.groupId;\n    });\n\n    if (newId === -1) {\n      [].slice.call(textTracks).forEach(function (track) {\n        track.mode = 'disabled';\n      });\n    } else {\n      var oldTrack = groupTracks[trackId];\n\n      if (oldTrack) {\n        oldTrack.mode = 'disabled';\n      }\n    }\n\n    var nextTrack = groupTracks[newId];\n\n    if (nextTrack) {\n      nextTrack.mode = subtitleDisplay ? 'showing' : 'hidden';\n    }\n  }\n  /**\n   * This method is responsible for validating the subtitle index and periodically reloading if live.\n   * Dispatches the SUBTITLE_TRACK_SWITCH event, which instructs the subtitle-stream-controller to load the selected track.\n   */\n  ;\n\n  _proto.setSubtitleTrack = function setSubtitleTrack(newId, lastTrack) {\n    var _tracks$newId;\n\n    var tracks = this.tracksInGroup; // setting this.subtitleTrack will trigger internal logic\n    // if media has not been attached yet, it will fail\n    // we keep a reference to the default track id\n    // and we'll set subtitleTrack when onMediaAttached is triggered\n\n    if (!this.media) {\n      this.queuedDefaultTrack = newId;\n      return;\n    }\n\n    if (this.trackId !== newId) {\n      this.toggleTrackModes(newId);\n    } // exit if track id as already set or invalid\n\n\n    if (this.trackId === newId && (newId === -1 || (_tracks$newId = tracks[newId]) !== null && _tracks$newId !== void 0 && _tracks$newId.details) || newId < -1 || newId >= tracks.length) {\n      return;\n    } // stopping live reloading timer if any\n\n\n    this.clearTimer();\n    var track = tracks[newId];\n    this.log(\"Switching to subtitle track \" + newId);\n    this.trackId = newId;\n\n    if (track) {\n      var id = track.id,\n          _track$groupId = track.groupId,\n          groupId = _track$groupId === void 0 ? '' : _track$groupId,\n          name = track.name,\n          type = track.type,\n          url = track.url;\n      this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].SUBTITLE_TRACK_SWITCH, {\n        id: id,\n        groupId: groupId,\n        name: name,\n        type: type,\n        url: url\n      });\n      var hlsUrlParameters = this.switchParams(track.url, lastTrack === null || lastTrack === void 0 ? void 0 : lastTrack.details);\n      this.loadPlaylist(hlsUrlParameters);\n    } else {\n      // switch to -1\n      this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].SUBTITLE_TRACK_SWITCH, {\n        id: newId\n      });\n    }\n  };\n\n  _proto.onTextTracksChanged = function onTextTracksChanged() {\n    if (!this.useTextTrackPolling) {\n      self.clearInterval(this.subtitlePollingInterval);\n    } // Media is undefined when switching streams via loadSource()\n\n\n    if (!this.media || !this.hls.config.renderTextTracksNatively) {\n      return;\n    }\n\n    var trackId = -1;\n    var tracks = filterSubtitleTracks(this.media.textTracks);\n\n    for (var id = 0; id < tracks.length; id++) {\n      if (tracks[id].mode === 'hidden') {\n        // Do not break in case there is a following track with showing.\n        trackId = id;\n      } else if (tracks[id].mode === 'showing') {\n        trackId = id;\n        break;\n      }\n    } // Setting current subtitleTrack will invoke code.\n\n\n    if (this.subtitleTrack !== trackId) {\n      this.subtitleTrack = trackId;\n    }\n  };\n\n  _createClass(SubtitleTrackController, [{\n    key: \"subtitleTracks\",\n    get: function get() {\n      return this.tracksInGroup;\n    }\n    /** get/set index of the selected subtitle track (based on index in subtitle track lists) **/\n\n  }, {\n    key: \"subtitleTrack\",\n    get: function get() {\n      return this.trackId;\n    },\n    set: function set(newId) {\n      this.selectDefaultTrack = false;\n      var lastTrack = this.tracksInGroup ? this.tracksInGroup[this.trackId] : undefined;\n      this.setSubtitleTrack(newId, lastTrack);\n    }\n  }]);\n\n  return SubtitleTrackController;\n}(_base_playlist_controller__WEBPACK_IMPORTED_MODULE_2__[\"default\"]);\n\nfunction filterSubtitleTracks(textTrackList) {\n  var tracks = [];\n\n  for (var i = 0; i < textTrackList.length; i++) {\n    var track = textTrackList[i]; // Edge adds a track without a label; we don't want to use it\n\n    if (track.kind === 'subtitles' && track.label) {\n      tracks.push(textTrackList[i]);\n    }\n  }\n\n  return tracks;\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (SubtitleTrackController);\n\n/***/ }),\n\n/***/ \"./src/controller/timeline-controller.ts\":\n/*!***********************************************!*\\\n  !*** ./src/controller/timeline-controller.ts ***!\n  \\***********************************************/\n/*! exports provided: TimelineController */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_442565__) {\n\n\"use strict\";\n__nested_webpack_require_442565__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_442565__.d(__webpack_exports__, \"TimelineController\", function() { return TimelineController; });\n/* harmony import */ var _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_442565__(/*! ./src/polyfills/number */ \"./src/polyfills/number.ts\");\n/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_442565__(/*! ../events */ \"./src/events.ts\");\n/* harmony import */ var _utils_cea_608_parser__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_442565__(/*! ../utils/cea-608-parser */ \"./src/utils/cea-608-parser.ts\");\n/* harmony import */ var _utils_output_filter__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_442565__(/*! ../utils/output-filter */ \"./src/utils/output-filter.ts\");\n/* harmony import */ var _utils_webvtt_parser__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_442565__(/*! ../utils/webvtt-parser */ \"./src/utils/webvtt-parser.ts\");\n/* harmony import */ var _utils_texttrack_utils__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_442565__(/*! ../utils/texttrack-utils */ \"./src/utils/texttrack-utils.ts\");\n/* harmony import */ var _utils_imsc1_ttml_parser__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_442565__(/*! ../utils/imsc1-ttml-parser */ \"./src/utils/imsc1-ttml-parser.ts\");\n/* harmony import */ var _types_loader__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_442565__(/*! ../types/loader */ \"./src/types/loader.ts\");\n/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_8__ = __nested_webpack_require_442565__(/*! ../utils/logger */ \"./src/utils/logger.ts\");\n\n\n\n\n\n\n\n\n\n\nvar TimelineController = /*#__PURE__*/function () {\n  function TimelineController(hls) {\n    this.hls = void 0;\n    this.media = null;\n    this.config = void 0;\n    this.enabled = true;\n    this.Cues = void 0;\n    this.textTracks = [];\n    this.tracks = [];\n    this.initPTS = [];\n    this.timescale = [];\n    this.unparsedVttFrags = [];\n    this.captionsTracks = {};\n    this.nonNativeCaptionsTracks = {};\n    this.cea608Parser1 = void 0;\n    this.cea608Parser2 = void 0;\n    this.lastSn = -1;\n    this.lastPartIndex = -1;\n    this.prevCC = -1;\n    this.vttCCs = newVTTCCs();\n    this.captionsProperties = void 0;\n    this.hls = hls;\n    this.config = hls.config;\n    this.Cues = hls.config.cueHandler;\n    this.captionsProperties = {\n      textTrack1: {\n        label: this.config.captionsTextTrack1Label,\n        languageCode: this.config.captionsTextTrack1LanguageCode\n      },\n      textTrack2: {\n        label: this.config.captionsTextTrack2Label,\n        languageCode: this.config.captionsTextTrack2LanguageCode\n      },\n      textTrack3: {\n        label: this.config.captionsTextTrack3Label,\n        languageCode: this.config.captionsTextTrack3LanguageCode\n      },\n      textTrack4: {\n        label: this.config.captionsTextTrack4Label,\n        languageCode: this.config.captionsTextTrack4LanguageCode\n      }\n    };\n\n    if (this.config.enableCEA708Captions) {\n      var channel1 = new _utils_output_filter__WEBPACK_IMPORTED_MODULE_3__[\"default\"](this, 'textTrack1');\n      var channel2 = new _utils_output_filter__WEBPACK_IMPORTED_MODULE_3__[\"default\"](this, 'textTrack2');\n      var channel3 = new _utils_output_filter__WEBPACK_IMPORTED_MODULE_3__[\"default\"](this, 'textTrack3');\n      var channel4 = new _utils_output_filter__WEBPACK_IMPORTED_MODULE_3__[\"default\"](this, 'textTrack4');\n      this.cea608Parser1 = new _utils_cea_608_parser__WEBPACK_IMPORTED_MODULE_2__[\"default\"](1, channel1, channel2);\n      this.cea608Parser2 = new _utils_cea_608_parser__WEBPACK_IMPORTED_MODULE_2__[\"default\"](3, channel3, channel4);\n    }\n\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].MEDIA_ATTACHING, this.onMediaAttaching, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].MEDIA_DETACHING, this.onMediaDetaching, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].MANIFEST_LOADED, this.onManifestLoaded, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].FRAG_LOADING, this.onFragLoading, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].FRAG_LOADED, this.onFragLoaded, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].FRAG_PARSING_USERDATA, this.onFragParsingUserdata, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].FRAG_DECRYPTED, this.onFragDecrypted, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].INIT_PTS_FOUND, this.onInitPtsFound, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].SUBTITLE_TRACKS_CLEARED, this.onSubtitleTracksCleared, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].BUFFER_FLUSHING, this.onBufferFlushing, this);\n  }\n\n  var _proto = TimelineController.prototype;\n\n  _proto.destroy = function destroy() {\n    var hls = this.hls;\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].MEDIA_ATTACHING, this.onMediaAttaching, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].MEDIA_DETACHING, this.onMediaDetaching, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].MANIFEST_LOADED, this.onManifestLoaded, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].FRAG_LOADING, this.onFragLoading, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].FRAG_LOADED, this.onFragLoaded, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].FRAG_PARSING_USERDATA, this.onFragParsingUserdata, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].FRAG_DECRYPTED, this.onFragDecrypted, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].INIT_PTS_FOUND, this.onInitPtsFound, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].SUBTITLE_TRACKS_CLEARED, this.onSubtitleTracksCleared, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].BUFFER_FLUSHING, this.onBufferFlushing, this); // @ts-ignore\n\n    this.hls = this.config = this.cea608Parser1 = this.cea608Parser2 = null;\n  };\n\n  _proto.addCues = function addCues(trackName, startTime, endTime, screen, cueRanges) {\n    // skip cues which overlap more than 50% with previously parsed time ranges\n    var merged = false;\n\n    for (var i = cueRanges.length; i--;) {\n      var cueRange = cueRanges[i];\n      var overlap = intersection(cueRange[0], cueRange[1], startTime, endTime);\n\n      if (overlap >= 0) {\n        cueRange[0] = Math.min(cueRange[0], startTime);\n        cueRange[1] = Math.max(cueRange[1], endTime);\n        merged = true;\n\n        if (overlap / (endTime - startTime) > 0.5) {\n          return;\n        }\n      }\n    }\n\n    if (!merged) {\n      cueRanges.push([startTime, endTime]);\n    }\n\n    if (this.config.renderTextTracksNatively) {\n      var track = this.captionsTracks[trackName];\n      this.Cues.newCue(track, startTime, endTime, screen);\n    } else {\n      var cues = this.Cues.newCue(null, startTime, endTime, screen);\n      this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].CUES_PARSED, {\n        type: 'captions',\n        cues: cues,\n        track: trackName\n      });\n    }\n  } // Triggered when an initial PTS is found; used for synchronisation of WebVTT.\n  ;\n\n  _proto.onInitPtsFound = function onInitPtsFound(event, _ref) {\n    var _this = this;\n\n    var frag = _ref.frag,\n        id = _ref.id,\n        initPTS = _ref.initPTS,\n        timescale = _ref.timescale;\n    var unparsedVttFrags = this.unparsedVttFrags;\n\n    if (id === 'main') {\n      this.initPTS[frag.cc] = initPTS;\n      this.timescale[frag.cc] = timescale;\n    } // Due to asynchronous processing, initial PTS may arrive later than the first VTT fragments are loaded.\n    // Parse any unparsed fragments upon receiving the initial PTS.\n\n\n    if (unparsedVttFrags.length) {\n      this.unparsedVttFrags = [];\n      unparsedVttFrags.forEach(function (frag) {\n        _this.onFragLoaded(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].FRAG_LOADED, frag);\n      });\n    }\n  };\n\n  _proto.getExistingTrack = function getExistingTrack(trackName) {\n    var media = this.media;\n\n    if (media) {\n      for (var i = 0; i < media.textTracks.length; i++) {\n        var textTrack = media.textTracks[i];\n\n        if (textTrack[trackName]) {\n          return textTrack;\n        }\n      }\n    }\n\n    return null;\n  };\n\n  _proto.createCaptionsTrack = function createCaptionsTrack(trackName) {\n    if (this.config.renderTextTracksNatively) {\n      this.createNativeTrack(trackName);\n    } else {\n      this.createNonNativeTrack(trackName);\n    }\n  };\n\n  _proto.createNativeTrack = function createNativeTrack(trackName) {\n    if (this.captionsTracks[trackName]) {\n      return;\n    }\n\n    var captionsProperties = this.captionsProperties,\n        captionsTracks = this.captionsTracks,\n        media = this.media;\n    var _captionsProperties$t = captionsProperties[trackName],\n        label = _captionsProperties$t.label,\n        languageCode = _captionsProperties$t.languageCode; // Enable reuse of existing text track.\n\n    var existingTrack = this.getExistingTrack(trackName);\n\n    if (!existingTrack) {\n      var textTrack = this.createTextTrack('captions', label, languageCode);\n\n      if (textTrack) {\n        // Set a special property on the track so we know it's managed by Hls.js\n        textTrack[trackName] = true;\n        captionsTracks[trackName] = textTrack;\n      }\n    } else {\n      captionsTracks[trackName] = existingTrack;\n      Object(_utils_texttrack_utils__WEBPACK_IMPORTED_MODULE_5__[\"clearCurrentCues\"])(captionsTracks[trackName]);\n      Object(_utils_texttrack_utils__WEBPACK_IMPORTED_MODULE_5__[\"sendAddTrackEvent\"])(captionsTracks[trackName], media);\n    }\n  };\n\n  _proto.createNonNativeTrack = function createNonNativeTrack(trackName) {\n    if (this.nonNativeCaptionsTracks[trackName]) {\n      return;\n    } // Create a list of a single track for the provider to consume\n\n\n    var trackProperties = this.captionsProperties[trackName];\n\n    if (!trackProperties) {\n      return;\n    }\n\n    var label = trackProperties.label;\n    var track = {\n      _id: trackName,\n      label: label,\n      kind: 'captions',\n      default: trackProperties.media ? !!trackProperties.media.default : false,\n      closedCaptions: trackProperties.media\n    };\n    this.nonNativeCaptionsTracks[trackName] = track;\n    this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].NON_NATIVE_TEXT_TRACKS_FOUND, {\n      tracks: [track]\n    });\n  };\n\n  _proto.createTextTrack = function createTextTrack(kind, label, lang) {\n    var media = this.media;\n\n    if (!media) {\n      return;\n    }\n\n    return media.addTextTrack(kind, label, lang);\n  };\n\n  _proto.onMediaAttaching = function onMediaAttaching(event, data) {\n    this.media = data.media;\n\n    this._cleanTracks();\n  };\n\n  _proto.onMediaDetaching = function onMediaDetaching() {\n    var captionsTracks = this.captionsTracks;\n    Object.keys(captionsTracks).forEach(function (trackName) {\n      Object(_utils_texttrack_utils__WEBPACK_IMPORTED_MODULE_5__[\"clearCurrentCues\"])(captionsTracks[trackName]);\n      delete captionsTracks[trackName];\n    });\n    this.nonNativeCaptionsTracks = {};\n  };\n\n  _proto.onManifestLoading = function onManifestLoading() {\n    this.lastSn = -1; // Detect discontinuity in fragment parsing\n\n    this.lastPartIndex = -1;\n    this.prevCC = -1;\n    this.vttCCs = newVTTCCs(); // Detect discontinuity in subtitle manifests\n\n    this._cleanTracks();\n\n    this.tracks = [];\n    this.captionsTracks = {};\n    this.nonNativeCaptionsTracks = {};\n    this.textTracks = [];\n    this.unparsedVttFrags = this.unparsedVttFrags || [];\n    this.initPTS = [];\n    this.timescale = [];\n\n    if (this.cea608Parser1 && this.cea608Parser2) {\n      this.cea608Parser1.reset();\n      this.cea608Parser2.reset();\n    }\n  };\n\n  _proto._cleanTracks = function _cleanTracks() {\n    // clear outdated subtitles\n    var media = this.media;\n\n    if (!media) {\n      return;\n    }\n\n    var textTracks = media.textTracks;\n\n    if (textTracks) {\n      for (var i = 0; i < textTracks.length; i++) {\n        Object(_utils_texttrack_utils__WEBPACK_IMPORTED_MODULE_5__[\"clearCurrentCues\"])(textTracks[i]);\n      }\n    }\n  };\n\n  _proto.onSubtitleTracksUpdated = function onSubtitleTracksUpdated(event, data) {\n    var _this2 = this;\n\n    this.textTracks = [];\n    var tracks = data.subtitleTracks || [];\n    var hasIMSC1 = tracks.some(function (track) {\n      return track.textCodec === _utils_imsc1_ttml_parser__WEBPACK_IMPORTED_MODULE_6__[\"IMSC1_CODEC\"];\n    });\n\n    if (this.config.enableWebVTT || hasIMSC1 && this.config.enableIMSC1) {\n      var sameTracks = this.tracks && tracks && this.tracks.length === tracks.length;\n      this.tracks = tracks || [];\n\n      if (this.config.renderTextTracksNatively) {\n        var inUseTracks = this.media ? this.media.textTracks : [];\n        this.tracks.forEach(function (track, index) {\n          var textTrack;\n\n          if (index < inUseTracks.length) {\n            var inUseTrack = null;\n\n            for (var i = 0; i < inUseTracks.length; i++) {\n              if (canReuseVttTextTrack(inUseTracks[i], track)) {\n                inUseTrack = inUseTracks[i];\n                break;\n              }\n            } // Reuse tracks with the same label, but do not reuse 608/708 tracks\n\n\n            if (inUseTrack) {\n              textTrack = inUseTrack;\n            }\n          }\n\n          if (textTrack) {\n            Object(_utils_texttrack_utils__WEBPACK_IMPORTED_MODULE_5__[\"clearCurrentCues\"])(textTrack);\n          } else {\n            textTrack = _this2.createTextTrack('subtitles', track.name, track.lang);\n\n            if (textTrack) {\n              textTrack.mode = 'disabled';\n            }\n          }\n\n          if (textTrack) {\n            textTrack.groupId = track.groupId;\n\n            _this2.textTracks.push(textTrack);\n          }\n        });\n      } else if (!sameTracks && this.tracks && this.tracks.length) {\n        // Create a list of tracks for the provider to consume\n        var tracksList = this.tracks.map(function (track) {\n          return {\n            label: track.name,\n            kind: track.type.toLowerCase(),\n            default: track.default,\n            subtitleTrack: track\n          };\n        });\n        this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].NON_NATIVE_TEXT_TRACKS_FOUND, {\n          tracks: tracksList\n        });\n      }\n    }\n  };\n\n  _proto.onManifestLoaded = function onManifestLoaded(event, data) {\n    var _this3 = this;\n\n    if (this.config.enableCEA708Captions && data.captions) {\n      data.captions.forEach(function (captionsTrack) {\n        var instreamIdMatch = /(?:CC|SERVICE)([1-4])/.exec(captionsTrack.instreamId);\n\n        if (!instreamIdMatch) {\n          return;\n        }\n\n        var trackName = \"textTrack\" + instreamIdMatch[1];\n        var trackProperties = _this3.captionsProperties[trackName];\n\n        if (!trackProperties) {\n          return;\n        }\n\n        trackProperties.label = captionsTrack.name;\n\n        if (captionsTrack.lang) {\n          // optional attribute\n          trackProperties.languageCode = captionsTrack.lang;\n        }\n\n        trackProperties.media = captionsTrack;\n      });\n    }\n  };\n\n  _proto.onFragLoading = function onFragLoading(event, data) {\n    var cea608Parser1 = this.cea608Parser1,\n        cea608Parser2 = this.cea608Parser2,\n        lastSn = this.lastSn,\n        lastPartIndex = this.lastPartIndex;\n\n    if (!this.enabled || !(cea608Parser1 && cea608Parser2)) {\n      return;\n    } // if this frag isn't contiguous, clear the parser so cues with bad start/end times aren't added to the textTrack\n\n\n    if (data.frag.type === _types_loader__WEBPACK_IMPORTED_MODULE_7__[\"PlaylistLevelType\"].MAIN) {\n      var _data$part$index, _data$part;\n\n      var sn = data.frag.sn;\n      var partIndex = (_data$part$index = data === null || data === void 0 ? void 0 : (_data$part = data.part) === null || _data$part === void 0 ? void 0 : _data$part.index) != null ? _data$part$index : -1;\n\n      if (!(sn === lastSn + 1 || sn === lastSn && partIndex === lastPartIndex + 1)) {\n        cea608Parser1.reset();\n        cea608Parser2.reset();\n      }\n\n      this.lastSn = sn;\n      this.lastPartIndex = partIndex;\n    }\n  };\n\n  _proto.onFragLoaded = function onFragLoaded(event, data) {\n    var frag = data.frag,\n        payload = data.payload;\n    var initPTS = this.initPTS,\n        unparsedVttFrags = this.unparsedVttFrags;\n\n    if (frag.type === _types_loader__WEBPACK_IMPORTED_MODULE_7__[\"PlaylistLevelType\"].SUBTITLE) {\n      // If fragment is subtitle type, parse as WebVTT.\n      if (payload.byteLength) {\n        // We need an initial synchronisation PTS. Store fragments as long as none has arrived.\n        if (!Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__[\"isFiniteNumber\"])(initPTS[frag.cc])) {\n          unparsedVttFrags.push(data);\n\n          if (initPTS.length) {\n            // finish unsuccessfully, otherwise the subtitle-stream-controller could be blocked from loading new frags.\n            this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].SUBTITLE_FRAG_PROCESSED, {\n              success: false,\n              frag: frag,\n              error: new Error('Missing initial subtitle PTS')\n            });\n          }\n\n          return;\n        }\n\n        var decryptData = frag.decryptdata; // fragment after decryption has a stats object\n\n        var decrypted = ('stats' in data); // If the subtitles are not encrypted, parse VTTs now. Otherwise, we need to wait.\n\n        if (decryptData == null || decryptData.key == null || decryptData.method !== 'AES-128' || decrypted) {\n          var trackPlaylistMedia = this.tracks[frag.level];\n          var vttCCs = this.vttCCs;\n\n          if (!vttCCs[frag.cc]) {\n            vttCCs[frag.cc] = {\n              start: frag.start,\n              prevCC: this.prevCC,\n              new: true\n            };\n            this.prevCC = frag.cc;\n          }\n\n          if (trackPlaylistMedia && trackPlaylistMedia.textCodec === _utils_imsc1_ttml_parser__WEBPACK_IMPORTED_MODULE_6__[\"IMSC1_CODEC\"]) {\n            this._parseIMSC1(frag, payload);\n          } else {\n            this._parseVTTs(frag, payload, vttCCs);\n          }\n        }\n      } else {\n        // In case there is no payload, finish unsuccessfully.\n        this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].SUBTITLE_FRAG_PROCESSED, {\n          success: false,\n          frag: frag,\n          error: new Error('Empty subtitle payload')\n        });\n      }\n    }\n  };\n\n  _proto._parseIMSC1 = function _parseIMSC1(frag, payload) {\n    var _this4 = this;\n\n    var hls = this.hls;\n    Object(_utils_imsc1_ttml_parser__WEBPACK_IMPORTED_MODULE_6__[\"parseIMSC1\"])(payload, this.initPTS[frag.cc], this.timescale[frag.cc], function (cues) {\n      _this4._appendCues(cues, frag.level);\n\n      hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].SUBTITLE_FRAG_PROCESSED, {\n        success: true,\n        frag: frag\n      });\n    }, function (error) {\n      _utils_logger__WEBPACK_IMPORTED_MODULE_8__[\"logger\"].log(\"Failed to parse IMSC1: \" + error);\n      hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].SUBTITLE_FRAG_PROCESSED, {\n        success: false,\n        frag: frag,\n        error: error\n      });\n    });\n  };\n\n  _proto._parseVTTs = function _parseVTTs(frag, payload, vttCCs) {\n    var _this5 = this;\n\n    var hls = this.hls; // Parse the WebVTT file contents.\n\n    Object(_utils_webvtt_parser__WEBPACK_IMPORTED_MODULE_4__[\"parseWebVTT\"])(payload, this.initPTS[frag.cc], this.timescale[frag.cc], vttCCs, frag.cc, frag.start, function (cues) {\n      _this5._appendCues(cues, frag.level);\n\n      hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].SUBTITLE_FRAG_PROCESSED, {\n        success: true,\n        frag: frag\n      });\n    }, function (error) {\n      _this5._fallbackToIMSC1(frag, payload); // Something went wrong while parsing. Trigger event with success false.\n\n\n      _utils_logger__WEBPACK_IMPORTED_MODULE_8__[\"logger\"].log(\"Failed to parse VTT cue: \" + error);\n      hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].SUBTITLE_FRAG_PROCESSED, {\n        success: false,\n        frag: frag,\n        error: error\n      });\n    });\n  };\n\n  _proto._fallbackToIMSC1 = function _fallbackToIMSC1(frag, payload) {\n    var _this6 = this;\n\n    // If textCodec is unknown, try parsing as IMSC1. Set textCodec based on the result\n    var trackPlaylistMedia = this.tracks[frag.level];\n\n    if (!trackPlaylistMedia.textCodec) {\n      Object(_utils_imsc1_ttml_parser__WEBPACK_IMPORTED_MODULE_6__[\"parseIMSC1\"])(payload, this.initPTS[frag.cc], this.timescale[frag.cc], function () {\n        trackPlaylistMedia.textCodec = _utils_imsc1_ttml_parser__WEBPACK_IMPORTED_MODULE_6__[\"IMSC1_CODEC\"];\n\n        _this6._parseIMSC1(frag, payload);\n      }, function () {\n        trackPlaylistMedia.textCodec = 'wvtt';\n      });\n    }\n  };\n\n  _proto._appendCues = function _appendCues(cues, fragLevel) {\n    var hls = this.hls;\n\n    if (this.config.renderTextTracksNatively) {\n      var textTrack = this.textTracks[fragLevel]; // WebVTTParser.parse is an async method and if the currently selected text track mode is set to \"disabled\"\n      // before parsing is done then don't try to access currentTrack.cues.getCueById as cues will be null\n      // and trying to access getCueById method of cues will throw an exception\n      // Because we check if the mode is disabled, we can force check `cues` below. They can't be null.\n\n      if (textTrack.mode === 'disabled') {\n        return;\n      }\n\n      cues.forEach(function (cue) {\n        return Object(_utils_texttrack_utils__WEBPACK_IMPORTED_MODULE_5__[\"addCueToTrack\"])(textTrack, cue);\n      });\n    } else {\n      var currentTrack = this.tracks[fragLevel];\n      var track = currentTrack.default ? 'default' : 'subtitles' + fragLevel;\n      hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].CUES_PARSED, {\n        type: 'subtitles',\n        cues: cues,\n        track: track\n      });\n    }\n  };\n\n  _proto.onFragDecrypted = function onFragDecrypted(event, data) {\n    var frag = data.frag;\n\n    if (frag.type === _types_loader__WEBPACK_IMPORTED_MODULE_7__[\"PlaylistLevelType\"].SUBTITLE) {\n      if (!Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__[\"isFiniteNumber\"])(this.initPTS[frag.cc])) {\n        this.unparsedVttFrags.push(data);\n        return;\n      }\n\n      this.onFragLoaded(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].FRAG_LOADED, data);\n    }\n  };\n\n  _proto.onSubtitleTracksCleared = function onSubtitleTracksCleared() {\n    this.tracks = [];\n    this.captionsTracks = {};\n  };\n\n  _proto.onFragParsingUserdata = function onFragParsingUserdata(event, data) {\n    var cea608Parser1 = this.cea608Parser1,\n        cea608Parser2 = this.cea608Parser2;\n\n    if (!this.enabled || !(cea608Parser1 && cea608Parser2)) {\n      return;\n    } // If the event contains captions (found in the bytes property), push all bytes into the parser immediately\n    // It will create the proper timestamps based on the PTS value\n\n\n    for (var i = 0; i < data.samples.length; i++) {\n      var ccBytes = data.samples[i].bytes;\n\n      if (ccBytes) {\n        var ccdatas = this.extractCea608Data(ccBytes);\n        cea608Parser1.addData(data.samples[i].pts, ccdatas[0]);\n        cea608Parser2.addData(data.samples[i].pts, ccdatas[1]);\n      }\n    }\n  };\n\n  _proto.onBufferFlushing = function onBufferFlushing(event, _ref2) {\n    var startOffset = _ref2.startOffset,\n        endOffset = _ref2.endOffset,\n        endOffsetSubtitles = _ref2.endOffsetSubtitles,\n        type = _ref2.type;\n    var media = this.media;\n\n    if (!media || media.currentTime < endOffset) {\n      return;\n    } // Clear 608 caption cues from the captions TextTracks when the video back buffer is flushed\n    // Forward cues are never removed because we can loose streamed 608 content from recent fragments\n\n\n    if (!type || type === 'video') {\n      var captionsTracks = this.captionsTracks;\n      Object.keys(captionsTracks).forEach(function (trackName) {\n        return Object(_utils_texttrack_utils__WEBPACK_IMPORTED_MODULE_5__[\"removeCuesInRange\"])(captionsTracks[trackName], startOffset, endOffset);\n      });\n    }\n\n    if (this.config.renderTextTracksNatively) {\n      // Clear VTT/IMSC1 subtitle cues from the subtitle TextTracks when the back buffer is flushed\n      if (startOffset === 0 && endOffsetSubtitles !== undefined) {\n        var textTracks = this.textTracks;\n        Object.keys(textTracks).forEach(function (trackName) {\n          return Object(_utils_texttrack_utils__WEBPACK_IMPORTED_MODULE_5__[\"removeCuesInRange\"])(textTracks[trackName], startOffset, endOffsetSubtitles);\n        });\n      }\n    }\n  };\n\n  _proto.extractCea608Data = function extractCea608Data(byteArray) {\n    var count = byteArray[0] & 31;\n    var position = 2;\n    var actualCCBytes = [[], []];\n\n    for (var j = 0; j < count; j++) {\n      var tmpByte = byteArray[position++];\n      var ccbyte1 = 0x7f & byteArray[position++];\n      var ccbyte2 = 0x7f & byteArray[position++];\n      var ccValid = (4 & tmpByte) !== 0;\n      var ccType = 3 & tmpByte;\n\n      if (ccbyte1 === 0 && ccbyte2 === 0) {\n        continue;\n      }\n\n      if (ccValid) {\n        if (ccType === 0 || ccType === 1) {\n          actualCCBytes[ccType].push(ccbyte1);\n          actualCCBytes[ccType].push(ccbyte2);\n        }\n      }\n    }\n\n    return actualCCBytes;\n  };\n\n  return TimelineController;\n}();\n\nfunction canReuseVttTextTrack(inUseTrack, manifestTrack) {\n  return inUseTrack && inUseTrack.label === manifestTrack.name && !(inUseTrack.textTrack1 || inUseTrack.textTrack2);\n}\n\nfunction intersection(x1, x2, y1, y2) {\n  return Math.min(x2, y2) - Math.max(x1, y1);\n}\n\nfunction newVTTCCs() {\n  return {\n    ccOffset: 0,\n    presentationOffset: 0,\n    0: {\n      start: 0,\n      prevCC: -1,\n      new: false\n    }\n  };\n}\n\n/***/ }),\n\n/***/ \"./src/crypt/aes-crypto.ts\":\n/*!*********************************!*\\\n  !*** ./src/crypt/aes-crypto.ts ***!\n  \\*********************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_469217__) {\n\n\"use strict\";\n__nested_webpack_require_469217__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_469217__.d(__webpack_exports__, \"default\", function() { return AESCrypto; });\nvar AESCrypto = /*#__PURE__*/function () {\n  function AESCrypto(subtle, iv) {\n    this.subtle = void 0;\n    this.aesIV = void 0;\n    this.subtle = subtle;\n    this.aesIV = iv;\n  }\n\n  var _proto = AESCrypto.prototype;\n\n  _proto.decrypt = function decrypt(data, key) {\n    return this.subtle.decrypt({\n      name: 'AES-CBC',\n      iv: this.aesIV\n    }, key, data);\n  };\n\n  return AESCrypto;\n}();\n\n\n\n/***/ }),\n\n/***/ \"./src/crypt/aes-decryptor.ts\":\n/*!************************************!*\\\n  !*** ./src/crypt/aes-decryptor.ts ***!\n  \\************************************/\n/*! exports provided: removePadding, default */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_470083__) {\n\n\"use strict\";\n__nested_webpack_require_470083__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_470083__.d(__webpack_exports__, \"removePadding\", function() { return removePadding; });\n/* harmony export (binding) */ __nested_webpack_require_470083__.d(__webpack_exports__, \"default\", function() { return AESDecryptor; });\n/* harmony import */ var _utils_typed_array__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_470083__(/*! ../utils/typed-array */ \"./src/utils/typed-array.ts\");\n // PKCS7\n\nfunction removePadding(array) {\n  var outputBytes = array.byteLength;\n  var paddingBytes = outputBytes && new DataView(array.buffer).getUint8(outputBytes - 1);\n\n  if (paddingBytes) {\n    return Object(_utils_typed_array__WEBPACK_IMPORTED_MODULE_0__[\"sliceUint8\"])(array, 0, outputBytes - paddingBytes);\n  }\n\n  return array;\n}\n\nvar AESDecryptor = /*#__PURE__*/function () {\n  function AESDecryptor() {\n    this.rcon = [0x0, 0x1, 0x2, 0x4, 0x8, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];\n    this.subMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)];\n    this.invSubMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)];\n    this.sBox = new Uint32Array(256);\n    this.invSBox = new Uint32Array(256);\n    this.key = new Uint32Array(0);\n    this.ksRows = 0;\n    this.keySize = 0;\n    this.keySchedule = void 0;\n    this.invKeySchedule = void 0;\n    this.initTable();\n  } // Using view.getUint32() also swaps the byte order.\n\n\n  var _proto = AESDecryptor.prototype;\n\n  _proto.uint8ArrayToUint32Array_ = function uint8ArrayToUint32Array_(arrayBuffer) {\n    var view = new DataView(arrayBuffer);\n    var newArray = new Uint32Array(4);\n\n    for (var i = 0; i < 4; i++) {\n      newArray[i] = view.getUint32(i * 4);\n    }\n\n    return newArray;\n  };\n\n  _proto.initTable = function initTable() {\n    var sBox = this.sBox;\n    var invSBox = this.invSBox;\n    var subMix = this.subMix;\n    var subMix0 = subMix[0];\n    var subMix1 = subMix[1];\n    var subMix2 = subMix[2];\n    var subMix3 = subMix[3];\n    var invSubMix = this.invSubMix;\n    var invSubMix0 = invSubMix[0];\n    var invSubMix1 = invSubMix[1];\n    var invSubMix2 = invSubMix[2];\n    var invSubMix3 = invSubMix[3];\n    var d = new Uint32Array(256);\n    var x = 0;\n    var xi = 0;\n    var i = 0;\n\n    for (i = 0; i < 256; i++) {\n      if (i < 128) {\n        d[i] = i << 1;\n      } else {\n        d[i] = i << 1 ^ 0x11b;\n      }\n    }\n\n    for (i = 0; i < 256; i++) {\n      var sx = xi ^ xi << 1 ^ xi << 2 ^ xi << 3 ^ xi << 4;\n      sx = sx >>> 8 ^ sx & 0xff ^ 0x63;\n      sBox[x] = sx;\n      invSBox[sx] = x; // Compute multiplication\n\n      var x2 = d[x];\n      var x4 = d[x2];\n      var x8 = d[x4]; // Compute sub/invSub bytes, mix columns tables\n\n      var t = d[sx] * 0x101 ^ sx * 0x1010100;\n      subMix0[x] = t << 24 | t >>> 8;\n      subMix1[x] = t << 16 | t >>> 16;\n      subMix2[x] = t << 8 | t >>> 24;\n      subMix3[x] = t; // Compute inv sub bytes, inv mix columns tables\n\n      t = x8 * 0x1010101 ^ x4 * 0x10001 ^ x2 * 0x101 ^ x * 0x1010100;\n      invSubMix0[sx] = t << 24 | t >>> 8;\n      invSubMix1[sx] = t << 16 | t >>> 16;\n      invSubMix2[sx] = t << 8 | t >>> 24;\n      invSubMix3[sx] = t; // Compute next counter\n\n      if (!x) {\n        x = xi = 1;\n      } else {\n        x = x2 ^ d[d[d[x8 ^ x2]]];\n        xi ^= d[d[xi]];\n      }\n    }\n  };\n\n  _proto.expandKey = function expandKey(keyBuffer) {\n    // convert keyBuffer to Uint32Array\n    var key = this.uint8ArrayToUint32Array_(keyBuffer);\n    var sameKey = true;\n    var offset = 0;\n\n    while (offset < key.length && sameKey) {\n      sameKey = key[offset] === this.key[offset];\n      offset++;\n    }\n\n    if (sameKey) {\n      return;\n    }\n\n    this.key = key;\n    var keySize = this.keySize = key.length;\n\n    if (keySize !== 4 && keySize !== 6 && keySize !== 8) {\n      throw new Error('Invalid aes key size=' + keySize);\n    }\n\n    var ksRows = this.ksRows = (keySize + 6 + 1) * 4;\n    var ksRow;\n    var invKsRow;\n    var keySchedule = this.keySchedule = new Uint32Array(ksRows);\n    var invKeySchedule = this.invKeySchedule = new Uint32Array(ksRows);\n    var sbox = this.sBox;\n    var rcon = this.rcon;\n    var invSubMix = this.invSubMix;\n    var invSubMix0 = invSubMix[0];\n    var invSubMix1 = invSubMix[1];\n    var invSubMix2 = invSubMix[2];\n    var invSubMix3 = invSubMix[3];\n    var prev;\n    var t;\n\n    for (ksRow = 0; ksRow < ksRows; ksRow++) {\n      if (ksRow < keySize) {\n        prev = keySchedule[ksRow] = key[ksRow];\n        continue;\n      }\n\n      t = prev;\n\n      if (ksRow % keySize === 0) {\n        // Rot word\n        t = t << 8 | t >>> 24; // Sub word\n\n        t = sbox[t >>> 24] << 24 | sbox[t >>> 16 & 0xff] << 16 | sbox[t >>> 8 & 0xff] << 8 | sbox[t & 0xff]; // Mix Rcon\n\n        t ^= rcon[ksRow / keySize | 0] << 24;\n      } else if (keySize > 6 && ksRow % keySize === 4) {\n        // Sub word\n        t = sbox[t >>> 24] << 24 | sbox[t >>> 16 & 0xff] << 16 | sbox[t >>> 8 & 0xff] << 8 | sbox[t & 0xff];\n      }\n\n      keySchedule[ksRow] = prev = (keySchedule[ksRow - keySize] ^ t) >>> 0;\n    }\n\n    for (invKsRow = 0; invKsRow < ksRows; invKsRow++) {\n      ksRow = ksRows - invKsRow;\n\n      if (invKsRow & 3) {\n        t = keySchedule[ksRow];\n      } else {\n        t = keySchedule[ksRow - 4];\n      }\n\n      if (invKsRow < 4 || ksRow <= 4) {\n        invKeySchedule[invKsRow] = t;\n      } else {\n        invKeySchedule[invKsRow] = invSubMix0[sbox[t >>> 24]] ^ invSubMix1[sbox[t >>> 16 & 0xff]] ^ invSubMix2[sbox[t >>> 8 & 0xff]] ^ invSubMix3[sbox[t & 0xff]];\n      }\n\n      invKeySchedule[invKsRow] = invKeySchedule[invKsRow] >>> 0;\n    }\n  } // Adding this as a method greatly improves performance.\n  ;\n\n  _proto.networkToHostOrderSwap = function networkToHostOrderSwap(word) {\n    return word << 24 | (word & 0xff00) << 8 | (word & 0xff0000) >> 8 | word >>> 24;\n  };\n\n  _proto.decrypt = function decrypt(inputArrayBuffer, offset, aesIV) {\n    var nRounds = this.keySize + 6;\n    var invKeySchedule = this.invKeySchedule;\n    var invSBOX = this.invSBox;\n    var invSubMix = this.invSubMix;\n    var invSubMix0 = invSubMix[0];\n    var invSubMix1 = invSubMix[1];\n    var invSubMix2 = invSubMix[2];\n    var invSubMix3 = invSubMix[3];\n    var initVector = this.uint8ArrayToUint32Array_(aesIV);\n    var initVector0 = initVector[0];\n    var initVector1 = initVector[1];\n    var initVector2 = initVector[2];\n    var initVector3 = initVector[3];\n    var inputInt32 = new Int32Array(inputArrayBuffer);\n    var outputInt32 = new Int32Array(inputInt32.length);\n    var t0, t1, t2, t3;\n    var s0, s1, s2, s3;\n    var inputWords0, inputWords1, inputWords2, inputWords3;\n    var ksRow, i;\n    var swapWord = this.networkToHostOrderSwap;\n\n    while (offset < inputInt32.length) {\n      inputWords0 = swapWord(inputInt32[offset]);\n      inputWords1 = swapWord(inputInt32[offset + 1]);\n      inputWords2 = swapWord(inputInt32[offset + 2]);\n      inputWords3 = swapWord(inputInt32[offset + 3]);\n      s0 = inputWords0 ^ invKeySchedule[0];\n      s1 = inputWords3 ^ invKeySchedule[1];\n      s2 = inputWords2 ^ invKeySchedule[2];\n      s3 = inputWords1 ^ invKeySchedule[3];\n      ksRow = 4; // Iterate through the rounds of decryption\n\n      for (i = 1; i < nRounds; i++) {\n        t0 = invSubMix0[s0 >>> 24] ^ invSubMix1[s1 >> 16 & 0xff] ^ invSubMix2[s2 >> 8 & 0xff] ^ invSubMix3[s3 & 0xff] ^ invKeySchedule[ksRow];\n        t1 = invSubMix0[s1 >>> 24] ^ invSubMix1[s2 >> 16 & 0xff] ^ invSubMix2[s3 >> 8 & 0xff] ^ invSubMix3[s0 & 0xff] ^ invKeySchedule[ksRow + 1];\n        t2 = invSubMix0[s2 >>> 24] ^ invSubMix1[s3 >> 16 & 0xff] ^ invSubMix2[s0 >> 8 & 0xff] ^ invSubMix3[s1 & 0xff] ^ invKeySchedule[ksRow + 2];\n        t3 = invSubMix0[s3 >>> 24] ^ invSubMix1[s0 >> 16 & 0xff] ^ invSubMix2[s1 >> 8 & 0xff] ^ invSubMix3[s2 & 0xff] ^ invKeySchedule[ksRow + 3]; // Update state\n\n        s0 = t0;\n        s1 = t1;\n        s2 = t2;\n        s3 = t3;\n        ksRow = ksRow + 4;\n      } // Shift rows, sub bytes, add round key\n\n\n      t0 = invSBOX[s0 >>> 24] << 24 ^ invSBOX[s1 >> 16 & 0xff] << 16 ^ invSBOX[s2 >> 8 & 0xff] << 8 ^ invSBOX[s3 & 0xff] ^ invKeySchedule[ksRow];\n      t1 = invSBOX[s1 >>> 24] << 24 ^ invSBOX[s2 >> 16 & 0xff] << 16 ^ invSBOX[s3 >> 8 & 0xff] << 8 ^ invSBOX[s0 & 0xff] ^ invKeySchedule[ksRow + 1];\n      t2 = invSBOX[s2 >>> 24] << 24 ^ invSBOX[s3 >> 16 & 0xff] << 16 ^ invSBOX[s0 >> 8 & 0xff] << 8 ^ invSBOX[s1 & 0xff] ^ invKeySchedule[ksRow + 2];\n      t3 = invSBOX[s3 >>> 24] << 24 ^ invSBOX[s0 >> 16 & 0xff] << 16 ^ invSBOX[s1 >> 8 & 0xff] << 8 ^ invSBOX[s2 & 0xff] ^ invKeySchedule[ksRow + 3]; // Write\n\n      outputInt32[offset] = swapWord(t0 ^ initVector0);\n      outputInt32[offset + 1] = swapWord(t3 ^ initVector1);\n      outputInt32[offset + 2] = swapWord(t2 ^ initVector2);\n      outputInt32[offset + 3] = swapWord(t1 ^ initVector3); // reset initVector to last 4 unsigned int\n\n      initVector0 = inputWords0;\n      initVector1 = inputWords1;\n      initVector2 = inputWords2;\n      initVector3 = inputWords3;\n      offset = offset + 4;\n    }\n\n    return outputInt32.buffer;\n  };\n\n  return AESDecryptor;\n}();\n\n\n\n/***/ }),\n\n/***/ \"./src/crypt/decrypter.ts\":\n/*!********************************!*\\\n  !*** ./src/crypt/decrypter.ts ***!\n  \\********************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_479466__) {\n\n\"use strict\";\n__nested_webpack_require_479466__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_479466__.d(__webpack_exports__, \"default\", function() { return Decrypter; });\n/* harmony import */ var _aes_crypto__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_479466__(/*! ./aes-crypto */ \"./src/crypt/aes-crypto.ts\");\n/* harmony import */ var _fast_aes_key__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_479466__(/*! ./fast-aes-key */ \"./src/crypt/fast-aes-key.ts\");\n/* harmony import */ var _aes_decryptor__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_479466__(/*! ./aes-decryptor */ \"./src/crypt/aes-decryptor.ts\");\n/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_479466__(/*! ../utils/logger */ \"./src/utils/logger.ts\");\n/* harmony import */ var _utils_mp4_tools__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_479466__(/*! ../utils/mp4-tools */ \"./src/utils/mp4-tools.ts\");\n/* harmony import */ var _utils_typed_array__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_479466__(/*! ../utils/typed-array */ \"./src/utils/typed-array.ts\");\n\n\n\n\n\n\nvar CHUNK_SIZE = 16; // 16 bytes, 128 bits\n\nvar Decrypter = /*#__PURE__*/function () {\n  function Decrypter(observer, config, _temp) {\n    var _ref = _temp === void 0 ? {} : _temp,\n        _ref$removePKCS7Paddi = _ref.removePKCS7Padding,\n        removePKCS7Padding = _ref$removePKCS7Paddi === void 0 ? true : _ref$removePKCS7Paddi;\n\n    this.logEnabled = true;\n    this.observer = void 0;\n    this.config = void 0;\n    this.removePKCS7Padding = void 0;\n    this.subtle = null;\n    this.softwareDecrypter = null;\n    this.key = null;\n    this.fastAesKey = null;\n    this.remainderData = null;\n    this.currentIV = null;\n    this.currentResult = null;\n    this.observer = observer;\n    this.config = config;\n    this.removePKCS7Padding = removePKCS7Padding; // built in decryptor expects PKCS7 padding\n\n    if (removePKCS7Padding) {\n      try {\n        var browserCrypto = self.crypto;\n\n        if (browserCrypto) {\n          this.subtle = browserCrypto.subtle || browserCrypto.webkitSubtle;\n        }\n      } catch (e) {\n        /* no-op */\n      }\n    }\n\n    if (this.subtle === null) {\n      this.config.enableSoftwareAES = true;\n    }\n  }\n\n  var _proto = Decrypter.prototype;\n\n  _proto.destroy = function destroy() {\n    // @ts-ignore\n    this.observer = null;\n  };\n\n  _proto.isSync = function isSync() {\n    return this.config.enableSoftwareAES;\n  };\n\n  _proto.flush = function flush() {\n    var currentResult = this.currentResult;\n\n    if (!currentResult) {\n      this.reset();\n      return;\n    }\n\n    var data = new Uint8Array(currentResult);\n    this.reset();\n\n    if (this.removePKCS7Padding) {\n      return Object(_aes_decryptor__WEBPACK_IMPORTED_MODULE_2__[\"removePadding\"])(data);\n    }\n\n    return data;\n  };\n\n  _proto.reset = function reset() {\n    this.currentResult = null;\n    this.currentIV = null;\n    this.remainderData = null;\n\n    if (this.softwareDecrypter) {\n      this.softwareDecrypter = null;\n    }\n  };\n\n  _proto.decrypt = function decrypt(data, key, iv, callback) {\n    if (this.config.enableSoftwareAES) {\n      this.softwareDecrypt(new Uint8Array(data), key, iv);\n      var decryptResult = this.flush();\n\n      if (decryptResult) {\n        callback(decryptResult.buffer);\n      }\n    } else {\n      this.webCryptoDecrypt(new Uint8Array(data), key, iv).then(callback);\n    }\n  };\n\n  _proto.softwareDecrypt = function softwareDecrypt(data, key, iv) {\n    var currentIV = this.currentIV,\n        currentResult = this.currentResult,\n        remainderData = this.remainderData;\n    this.logOnce('JS AES decrypt'); // The output is staggered during progressive parsing - the current result is cached, and emitted on the next call\n    // This is done in order to strip PKCS7 padding, which is found at the end of each segment. We only know we've reached\n    // the end on flush(), but by that time we have already received all bytes for the segment.\n    // Progressive decryption does not work with WebCrypto\n\n    if (remainderData) {\n      data = Object(_utils_mp4_tools__WEBPACK_IMPORTED_MODULE_4__[\"appendUint8Array\"])(remainderData, data);\n      this.remainderData = null;\n    } // Byte length must be a multiple of 16 (AES-128 = 128 bit blocks = 16 bytes)\n\n\n    var currentChunk = this.getValidChunk(data);\n\n    if (!currentChunk.length) {\n      return null;\n    }\n\n    if (currentIV) {\n      iv = currentIV;\n    }\n\n    var softwareDecrypter = this.softwareDecrypter;\n\n    if (!softwareDecrypter) {\n      softwareDecrypter = this.softwareDecrypter = new _aes_decryptor__WEBPACK_IMPORTED_MODULE_2__[\"default\"]();\n    }\n\n    softwareDecrypter.expandKey(key);\n    var result = currentResult;\n    this.currentResult = softwareDecrypter.decrypt(currentChunk.buffer, 0, iv);\n    this.currentIV = Object(_utils_typed_array__WEBPACK_IMPORTED_MODULE_5__[\"sliceUint8\"])(currentChunk, -16).buffer;\n\n    if (!result) {\n      return null;\n    }\n\n    return result;\n  };\n\n  _proto.webCryptoDecrypt = function webCryptoDecrypt(data, key, iv) {\n    var _this = this;\n\n    var subtle = this.subtle;\n\n    if (this.key !== key || !this.fastAesKey) {\n      this.key = key;\n      this.fastAesKey = new _fast_aes_key__WEBPACK_IMPORTED_MODULE_1__[\"default\"](subtle, key);\n    }\n\n    return this.fastAesKey.expandKey().then(function (aesKey) {\n      // decrypt using web crypto\n      if (!subtle) {\n        return Promise.reject(new Error('web crypto not initialized'));\n      }\n\n      var crypto = new _aes_crypto__WEBPACK_IMPORTED_MODULE_0__[\"default\"](subtle, iv);\n      return crypto.decrypt(data.buffer, aesKey);\n    }).catch(function (err) {\n      return _this.onWebCryptoError(err, data, key, iv);\n    });\n  };\n\n  _proto.onWebCryptoError = function onWebCryptoError(err, data, key, iv) {\n    _utils_logger__WEBPACK_IMPORTED_MODULE_3__[\"logger\"].warn('[decrypter.ts]: WebCrypto Error, disable WebCrypto API:', err);\n    this.config.enableSoftwareAES = true;\n    this.logEnabled = true;\n    return this.softwareDecrypt(data, key, iv);\n  };\n\n  _proto.getValidChunk = function getValidChunk(data) {\n    var currentChunk = data;\n    var splitPoint = data.length - data.length % CHUNK_SIZE;\n\n    if (splitPoint !== data.length) {\n      currentChunk = Object(_utils_typed_array__WEBPACK_IMPORTED_MODULE_5__[\"sliceUint8\"])(data, 0, splitPoint);\n      this.remainderData = Object(_utils_typed_array__WEBPACK_IMPORTED_MODULE_5__[\"sliceUint8\"])(data, splitPoint);\n    }\n\n    return currentChunk;\n  };\n\n  _proto.logOnce = function logOnce(msg) {\n    if (!this.logEnabled) {\n      return;\n    }\n\n    _utils_logger__WEBPACK_IMPORTED_MODULE_3__[\"logger\"].log(\"[decrypter.ts]: \" + msg);\n    this.logEnabled = false;\n  };\n\n  return Decrypter;\n}();\n\n\n\n/***/ }),\n\n/***/ \"./src/crypt/fast-aes-key.ts\":\n/*!***********************************!*\\\n  !*** ./src/crypt/fast-aes-key.ts ***!\n  \\***********************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_486437__) {\n\n\"use strict\";\n__nested_webpack_require_486437__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_486437__.d(__webpack_exports__, \"default\", function() { return FastAESKey; });\nvar FastAESKey = /*#__PURE__*/function () {\n  function FastAESKey(subtle, key) {\n    this.subtle = void 0;\n    this.key = void 0;\n    this.subtle = subtle;\n    this.key = key;\n  }\n\n  var _proto = FastAESKey.prototype;\n\n  _proto.expandKey = function expandKey() {\n    return this.subtle.importKey('raw', this.key, {\n      name: 'AES-CBC'\n    }, false, ['encrypt', 'decrypt']);\n  };\n\n  return FastAESKey;\n}();\n\n\n\n/***/ }),\n\n/***/ \"./src/demux/aacdemuxer.ts\":\n/*!*********************************!*\\\n  !*** ./src/demux/aacdemuxer.ts ***!\n  \\*********************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_487291__) {\n\n\"use strict\";\n__nested_webpack_require_487291__.r(__webpack_exports__);\n/* harmony import */ var _base_audio_demuxer__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_487291__(/*! ./base-audio-demuxer */ \"./src/demux/base-audio-demuxer.ts\");\n/* harmony import */ var _adts__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_487291__(/*! ./adts */ \"./src/demux/adts.ts\");\n/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_487291__(/*! ../utils/logger */ \"./src/utils/logger.ts\");\n/* harmony import */ var _demux_id3__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_487291__(/*! ../demux/id3 */ \"./src/demux/id3.ts\");\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n/**\n * AAC demuxer\n */\n\n\n\n\n\nvar AACDemuxer = /*#__PURE__*/function (_BaseAudioDemuxer) {\n  _inheritsLoose(AACDemuxer, _BaseAudioDemuxer);\n\n  function AACDemuxer(observer, config) {\n    var _this;\n\n    _this = _BaseAudioDemuxer.call(this) || this;\n    _this.observer = void 0;\n    _this.config = void 0;\n    _this.observer = observer;\n    _this.config = config;\n    return _this;\n  }\n\n  var _proto = AACDemuxer.prototype;\n\n  _proto.resetInitSegment = function resetInitSegment(audioCodec, videoCodec, duration) {\n    _BaseAudioDemuxer.prototype.resetInitSegment.call(this, audioCodec, videoCodec, duration);\n\n    this._audioTrack = {\n      container: 'audio/adts',\n      type: 'audio',\n      id: 2,\n      pid: -1,\n      sequenceNumber: 0,\n      isAAC: true,\n      samples: [],\n      manifestCodec: audioCodec,\n      duration: duration,\n      inputTimeScale: 90000,\n      dropped: 0\n    };\n  } // Source for probe info - https://wiki.multimedia.cx/index.php?title=ADTS\n  ;\n\n  AACDemuxer.probe = function probe(data) {\n    if (!data) {\n      return false;\n    } // Check for the ADTS sync word\n    // Look for ADTS header | 1111 1111 | 1111 X00X | where X can be either 0 or 1\n    // Layer bits (position 14 and 15) in header should be always 0 for ADTS\n    // More info https://wiki.multimedia.cx/index.php?title=ADTS\n\n\n    var id3Data = _demux_id3__WEBPACK_IMPORTED_MODULE_3__[\"getID3Data\"](data, 0) || [];\n    var offset = id3Data.length;\n\n    for (var length = data.length; offset < length; offset++) {\n      if (_adts__WEBPACK_IMPORTED_MODULE_1__[\"probe\"](data, offset)) {\n        _utils_logger__WEBPACK_IMPORTED_MODULE_2__[\"logger\"].log('ADTS sync word found !');\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  _proto.canParse = function canParse(data, offset) {\n    return _adts__WEBPACK_IMPORTED_MODULE_1__[\"canParse\"](data, offset);\n  };\n\n  _proto.appendFrame = function appendFrame(track, data, offset) {\n    _adts__WEBPACK_IMPORTED_MODULE_1__[\"initTrackConfig\"](track, this.observer, data, offset, track.manifestCodec);\n    var frame = _adts__WEBPACK_IMPORTED_MODULE_1__[\"appendFrame\"](track, data, offset, this.initPTS, this.frameIndex);\n\n    if (frame && frame.missing === 0) {\n      return frame;\n    }\n  };\n\n  return AACDemuxer;\n}(_base_audio_demuxer__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n\nAACDemuxer.minProbeByteLength = 9;\n/* harmony default export */ __webpack_exports__[\"default\"] = (AACDemuxer);\n\n/***/ }),\n\n/***/ \"./src/demux/adts.ts\":\n/*!***************************!*\\\n  !*** ./src/demux/adts.ts ***!\n  \\***************************/\n/*! exports provided: getAudioConfig, isHeaderPattern, getHeaderLength, getFullFrameLength, canGetFrameLength, isHeader, canParse, probe, initTrackConfig, getFrameDuration, parseFrameHeader, appendFrame */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_491109__) {\n\n\"use strict\";\n__nested_webpack_require_491109__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_491109__.d(__webpack_exports__, \"getAudioConfig\", function() { return getAudioConfig; });\n/* harmony export (binding) */ __nested_webpack_require_491109__.d(__webpack_exports__, \"isHeaderPattern\", function() { return isHeaderPattern; });\n/* harmony export (binding) */ __nested_webpack_require_491109__.d(__webpack_exports__, \"getHeaderLength\", function() { return getHeaderLength; });\n/* harmony export (binding) */ __nested_webpack_require_491109__.d(__webpack_exports__, \"getFullFrameLength\", function() { return getFullFrameLength; });\n/* harmony export (binding) */ __nested_webpack_require_491109__.d(__webpack_exports__, \"canGetFrameLength\", function() { return canGetFrameLength; });\n/* harmony export (binding) */ __nested_webpack_require_491109__.d(__webpack_exports__, \"isHeader\", function() { return isHeader; });\n/* harmony export (binding) */ __nested_webpack_require_491109__.d(__webpack_exports__, \"canParse\", function() { return canParse; });\n/* harmony export (binding) */ __nested_webpack_require_491109__.d(__webpack_exports__, \"probe\", function() { return probe; });\n/* harmony export (binding) */ __nested_webpack_require_491109__.d(__webpack_exports__, \"initTrackConfig\", function() { return initTrackConfig; });\n/* harmony export (binding) */ __nested_webpack_require_491109__.d(__webpack_exports__, \"getFrameDuration\", function() { return getFrameDuration; });\n/* harmony export (binding) */ __nested_webpack_require_491109__.d(__webpack_exports__, \"parseFrameHeader\", function() { return parseFrameHeader; });\n/* harmony export (binding) */ __nested_webpack_require_491109__.d(__webpack_exports__, \"appendFrame\", function() { return appendFrame; });\n/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_491109__(/*! ../utils/logger */ \"./src/utils/logger.ts\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_491109__(/*! ../errors */ \"./src/errors.ts\");\n/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_491109__(/*! ../events */ \"./src/events.ts\");\n/**\n * ADTS parser helper\n * @link https://wiki.multimedia.cx/index.php?title=ADTS\n */\n\n\n\nfunction getAudioConfig(observer, data, offset, audioCodec) {\n  var adtsObjectType;\n  var adtsExtensionSamplingIndex;\n  var adtsChanelConfig;\n  var config;\n  var userAgent = navigator.userAgent.toLowerCase();\n  var manifestCodec = audioCodec;\n  var adtsSampleingRates = [96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050, 16000, 12000, 11025, 8000, 7350]; // byte 2\n\n  adtsObjectType = ((data[offset + 2] & 0xc0) >>> 6) + 1;\n  var adtsSamplingIndex = (data[offset + 2] & 0x3c) >>> 2;\n\n  if (adtsSamplingIndex > adtsSampleingRates.length - 1) {\n    observer.trigger(_events__WEBPACK_IMPORTED_MODULE_2__[\"Events\"].ERROR, {\n      type: _errors__WEBPACK_IMPORTED_MODULE_1__[\"ErrorTypes\"].MEDIA_ERROR,\n      details: _errors__WEBPACK_IMPORTED_MODULE_1__[\"ErrorDetails\"].FRAG_PARSING_ERROR,\n      fatal: true,\n      reason: \"invalid ADTS sampling index:\" + adtsSamplingIndex\n    });\n    return;\n  }\n\n  adtsChanelConfig = (data[offset + 2] & 0x01) << 2; // byte 3\n\n  adtsChanelConfig |= (data[offset + 3] & 0xc0) >>> 6;\n  _utils_logger__WEBPACK_IMPORTED_MODULE_0__[\"logger\"].log(\"manifest codec:\" + audioCodec + \", ADTS type:\" + adtsObjectType + \", samplingIndex:\" + adtsSamplingIndex); // firefox: freq less than 24kHz = AAC SBR (HE-AAC)\n\n  if (/firefox/i.test(userAgent)) {\n    if (adtsSamplingIndex >= 6) {\n      adtsObjectType = 5;\n      config = new Array(4); // HE-AAC uses SBR (Spectral Band Replication) , high frequencies are constructed from low frequencies\n      // there is a factor 2 between frame sample rate and output sample rate\n      // multiply frequency by 2 (see table below, equivalent to substract 3)\n\n      adtsExtensionSamplingIndex = adtsSamplingIndex - 3;\n    } else {\n      adtsObjectType = 2;\n      config = new Array(2);\n      adtsExtensionSamplingIndex = adtsSamplingIndex;\n    } // Android : always use AAC\n\n  } else if (userAgent.indexOf('android') !== -1) {\n    adtsObjectType = 2;\n    config = new Array(2);\n    adtsExtensionSamplingIndex = adtsSamplingIndex;\n  } else {\n    /*  for other browsers (Chrome/Vivaldi/Opera ...)\n        always force audio type to be HE-AAC SBR, as some browsers do not support audio codec switch properly (like Chrome ...)\n    */\n    adtsObjectType = 5;\n    config = new Array(4); // if (manifest codec is HE-AAC or HE-AACv2) OR (manifest codec not specified AND frequency less than 24kHz)\n\n    if (audioCodec && (audioCodec.indexOf('mp4a.40.29') !== -1 || audioCodec.indexOf('mp4a.40.5') !== -1) || !audioCodec && adtsSamplingIndex >= 6) {\n      // HE-AAC uses SBR (Spectral Band Replication) , high frequencies are constructed from low frequencies\n      // there is a factor 2 between frame sample rate and output sample rate\n      // multiply frequency by 2 (see table below, equivalent to substract 3)\n      adtsExtensionSamplingIndex = adtsSamplingIndex - 3;\n    } else {\n      // if (manifest codec is AAC) AND (frequency less than 24kHz AND nb channel is 1) OR (manifest codec not specified and mono audio)\n      // Chrome fails to play back with low frequency AAC LC mono when initialized with HE-AAC.  This is not a problem with stereo.\n      if (audioCodec && audioCodec.indexOf('mp4a.40.2') !== -1 && (adtsSamplingIndex >= 6 && adtsChanelConfig === 1 || /vivaldi/i.test(userAgent)) || !audioCodec && adtsChanelConfig === 1) {\n        adtsObjectType = 2;\n        config = new Array(2);\n      }\n\n      adtsExtensionSamplingIndex = adtsSamplingIndex;\n    }\n  }\n  /* refer to http://wiki.multimedia.cx/index.php?title=MPEG-4_Audio#Audio_Specific_Config\n      ISO 14496-3 (AAC).pdf - Table 1.13 — Syntax of AudioSpecificConfig()\n    Audio Profile / Audio Object Type\n    0: Null\n    1: AAC Main\n    2: AAC LC (Low Complexity)\n    3: AAC SSR (Scalable Sample Rate)\n    4: AAC LTP (Long Term Prediction)\n    5: SBR (Spectral Band Replication)\n    6: AAC Scalable\n   sampling freq\n    0: 96000 Hz\n    1: 88200 Hz\n    2: 64000 Hz\n    3: 48000 Hz\n    4: 44100 Hz\n    5: 32000 Hz\n    6: 24000 Hz\n    7: 22050 Hz\n    8: 16000 Hz\n    9: 12000 Hz\n    10: 11025 Hz\n    11: 8000 Hz\n    12: 7350 Hz\n    13: Reserved\n    14: Reserved\n    15: frequency is written explictly\n    Channel Configurations\n    These are the channel configurations:\n    0: Defined in AOT Specifc Config\n    1: 1 channel: front-center\n    2: 2 channels: front-left, front-right\n  */\n  // audioObjectType = profile => profile, the MPEG-4 Audio Object Type minus 1\n\n\n  config[0] = adtsObjectType << 3; // samplingFrequencyIndex\n\n  config[0] |= (adtsSamplingIndex & 0x0e) >> 1;\n  config[1] |= (adtsSamplingIndex & 0x01) << 7; // channelConfiguration\n\n  config[1] |= adtsChanelConfig << 3;\n\n  if (adtsObjectType === 5) {\n    // adtsExtensionSampleingIndex\n    config[1] |= (adtsExtensionSamplingIndex & 0x0e) >> 1;\n    config[2] = (adtsExtensionSamplingIndex & 0x01) << 7; // adtsObjectType (force to 2, chrome is checking that object type is less than 5 ???\n    //    https://chromium.googlesource.com/chromium/src.git/+/master/media/formats/mp4/aac.cc\n\n    config[2] |= 2 << 2;\n    config[3] = 0;\n  }\n\n  return {\n    config: config,\n    samplerate: adtsSampleingRates[adtsSamplingIndex],\n    channelCount: adtsChanelConfig,\n    codec: 'mp4a.40.' + adtsObjectType,\n    manifestCodec: manifestCodec\n  };\n}\nfunction isHeaderPattern(data, offset) {\n  return data[offset] === 0xff && (data[offset + 1] & 0xf6) === 0xf0;\n}\nfunction getHeaderLength(data, offset) {\n  return data[offset + 1] & 0x01 ? 7 : 9;\n}\nfunction getFullFrameLength(data, offset) {\n  return (data[offset + 3] & 0x03) << 11 | data[offset + 4] << 3 | (data[offset + 5] & 0xe0) >>> 5;\n}\nfunction canGetFrameLength(data, offset) {\n  return offset + 5 < data.length;\n}\nfunction isHeader(data, offset) {\n  // Look for ADTS header | 1111 1111 | 1111 X00X | where X can be either 0 or 1\n  // Layer bits (position 14 and 15) in header should be always 0 for ADTS\n  // More info https://wiki.multimedia.cx/index.php?title=ADTS\n  return offset + 1 < data.length && isHeaderPattern(data, offset);\n}\nfunction canParse(data, offset) {\n  return canGetFrameLength(data, offset) && isHeaderPattern(data, offset) && getFullFrameLength(data, offset) <= data.length - offset;\n}\nfunction probe(data, offset) {\n  // same as isHeader but we also check that ADTS frame follows last ADTS frame\n  // or end of data is reached\n  if (isHeader(data, offset)) {\n    // ADTS header Length\n    var headerLength = getHeaderLength(data, offset);\n\n    if (offset + headerLength >= data.length) {\n      return false;\n    } // ADTS frame Length\n\n\n    var frameLength = getFullFrameLength(data, offset);\n\n    if (frameLength <= headerLength) {\n      return false;\n    }\n\n    var newOffset = offset + frameLength;\n    return newOffset === data.length || isHeader(data, newOffset);\n  }\n\n  return false;\n}\nfunction initTrackConfig(track, observer, data, offset, audioCodec) {\n  if (!track.samplerate) {\n    var config = getAudioConfig(observer, data, offset, audioCodec);\n\n    if (!config) {\n      return;\n    }\n\n    track.config = config.config;\n    track.samplerate = config.samplerate;\n    track.channelCount = config.channelCount;\n    track.codec = config.codec;\n    track.manifestCodec = config.manifestCodec;\n    _utils_logger__WEBPACK_IMPORTED_MODULE_0__[\"logger\"].log(\"parsed codec:\" + track.codec + \", rate:\" + config.samplerate + \", channels:\" + config.channelCount);\n  }\n}\nfunction getFrameDuration(samplerate) {\n  return 1024 * 90000 / samplerate;\n}\nfunction parseFrameHeader(data, offset, pts, frameIndex, frameDuration) {\n  // The protection skip bit tells us if we have 2 bytes of CRC data at the end of the ADTS header\n  var headerLength = getHeaderLength(data, offset); // retrieve frame size\n\n  var frameLength = getFullFrameLength(data, offset);\n  frameLength -= headerLength;\n\n  if (frameLength > 0) {\n    var stamp = pts + frameIndex * frameDuration; // logger.log(`AAC frame, offset/length/total/pts:${offset+headerLength}/${frameLength}/${data.byteLength}/${(stamp/90).toFixed(0)}`);\n\n    return {\n      headerLength: headerLength,\n      frameLength: frameLength,\n      stamp: stamp\n    };\n  }\n}\nfunction appendFrame(track, data, offset, pts, frameIndex) {\n  var frameDuration = getFrameDuration(track.samplerate);\n  var header = parseFrameHeader(data, offset, pts, frameIndex, frameDuration);\n\n  if (header) {\n    var frameLength = header.frameLength,\n        headerLength = header.headerLength,\n        stamp = header.stamp;\n    var length = headerLength + frameLength;\n    var missing = Math.max(0, offset + length - data.length); // logger.log(`AAC frame ${frameIndex}, pts:${stamp} length@offset/total: ${frameLength}@${offset+headerLength}/${data.byteLength} missing: ${missing}`);\n\n    var unit;\n\n    if (missing) {\n      unit = new Uint8Array(length - headerLength);\n      unit.set(data.subarray(offset + headerLength, data.length), 0);\n    } else {\n      unit = data.subarray(offset + headerLength, offset + length);\n    }\n\n    var sample = {\n      unit: unit,\n      pts: stamp\n    };\n\n    if (!missing) {\n      track.samples.push(sample);\n    }\n\n    return {\n      sample: sample,\n      length: length,\n      missing: missing\n    };\n  }\n}\n\n/***/ }),\n\n/***/ \"./src/demux/base-audio-demuxer.ts\":\n/*!*****************************************!*\\\n  !*** ./src/demux/base-audio-demuxer.ts ***!\n  \\*****************************************/\n/*! exports provided: initPTSFn, default */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_502634__) {\n\n\"use strict\";\n__nested_webpack_require_502634__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_502634__.d(__webpack_exports__, \"initPTSFn\", function() { return initPTSFn; });\n/* harmony import */ var _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_502634__(/*! ./src/polyfills/number */ \"./src/polyfills/number.ts\");\n/* harmony import */ var _demux_id3__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_502634__(/*! ../demux/id3 */ \"./src/demux/id3.ts\");\n/* harmony import */ var _dummy_demuxed_track__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_502634__(/*! ./dummy-demuxed-track */ \"./src/demux/dummy-demuxed-track.ts\");\n/* harmony import */ var _utils_mp4_tools__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_502634__(/*! ../utils/mp4-tools */ \"./src/utils/mp4-tools.ts\");\n/* harmony import */ var _utils_typed_array__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_502634__(/*! ../utils/typed-array */ \"./src/utils/typed-array.ts\");\n\n\n\n\n\n\nvar BaseAudioDemuxer = /*#__PURE__*/function () {\n  function BaseAudioDemuxer() {\n    this._audioTrack = void 0;\n    this._id3Track = void 0;\n    this.frameIndex = 0;\n    this.cachedData = null;\n    this.initPTS = null;\n  }\n\n  var _proto = BaseAudioDemuxer.prototype;\n\n  _proto.resetInitSegment = function resetInitSegment(audioCodec, videoCodec, duration) {\n    this._id3Track = {\n      type: 'id3',\n      id: 3,\n      pid: -1,\n      inputTimeScale: 90000,\n      sequenceNumber: 0,\n      samples: [],\n      dropped: 0\n    };\n  };\n\n  _proto.resetTimeStamp = function resetTimeStamp() {};\n\n  _proto.resetContiguity = function resetContiguity() {};\n\n  _proto.canParse = function canParse(data, offset) {\n    return false;\n  };\n\n  _proto.appendFrame = function appendFrame(track, data, offset) {} // feed incoming data to the front of the parsing pipeline\n  ;\n\n  _proto.demux = function demux(data, timeOffset) {\n    if (this.cachedData) {\n      data = Object(_utils_mp4_tools__WEBPACK_IMPORTED_MODULE_3__[\"appendUint8Array\"])(this.cachedData, data);\n      this.cachedData = null;\n    }\n\n    var id3Data = _demux_id3__WEBPACK_IMPORTED_MODULE_1__[\"getID3Data\"](data, 0);\n    var offset = id3Data ? id3Data.length : 0;\n    var lastDataIndex;\n    var pts;\n    var track = this._audioTrack;\n    var id3Track = this._id3Track;\n    var timestamp = id3Data ? _demux_id3__WEBPACK_IMPORTED_MODULE_1__[\"getTimeStamp\"](id3Data) : undefined;\n    var length = data.length;\n\n    if (this.frameIndex === 0 || this.initPTS === null) {\n      this.initPTS = initPTSFn(timestamp, timeOffset);\n    } // more expressive than alternative: id3Data?.length\n\n\n    if (id3Data && id3Data.length > 0) {\n      id3Track.samples.push({\n        pts: this.initPTS,\n        dts: this.initPTS,\n        data: id3Data\n      });\n    }\n\n    pts = this.initPTS;\n\n    while (offset < length) {\n      if (this.canParse(data, offset)) {\n        var frame = this.appendFrame(track, data, offset);\n\n        if (frame) {\n          this.frameIndex++;\n          pts = frame.sample.pts;\n          offset += frame.length;\n          lastDataIndex = offset;\n        } else {\n          offset = length;\n        }\n      } else if (_demux_id3__WEBPACK_IMPORTED_MODULE_1__[\"canParse\"](data, offset)) {\n        // after a ID3.canParse, a call to ID3.getID3Data *should* always returns some data\n        id3Data = _demux_id3__WEBPACK_IMPORTED_MODULE_1__[\"getID3Data\"](data, offset);\n        id3Track.samples.push({\n          pts: pts,\n          dts: pts,\n          data: id3Data\n        });\n        offset += id3Data.length;\n        lastDataIndex = offset;\n      } else {\n        offset++;\n      }\n\n      if (offset === length && lastDataIndex !== length) {\n        var partialData = Object(_utils_typed_array__WEBPACK_IMPORTED_MODULE_4__[\"sliceUint8\"])(data, lastDataIndex);\n\n        if (this.cachedData) {\n          this.cachedData = Object(_utils_mp4_tools__WEBPACK_IMPORTED_MODULE_3__[\"appendUint8Array\"])(this.cachedData, partialData);\n        } else {\n          this.cachedData = partialData;\n        }\n      }\n    }\n\n    return {\n      audioTrack: track,\n      avcTrack: Object(_dummy_demuxed_track__WEBPACK_IMPORTED_MODULE_2__[\"dummyTrack\"])(),\n      id3Track: id3Track,\n      textTrack: Object(_dummy_demuxed_track__WEBPACK_IMPORTED_MODULE_2__[\"dummyTrack\"])()\n    };\n  };\n\n  _proto.demuxSampleAes = function demuxSampleAes(data, keyData, timeOffset) {\n    return Promise.reject(new Error(\"[\" + this + \"] This demuxer does not support Sample-AES decryption\"));\n  };\n\n  _proto.flush = function flush(timeOffset) {\n    // Parse cache in case of remaining frames.\n    var cachedData = this.cachedData;\n\n    if (cachedData) {\n      this.cachedData = null;\n      this.demux(cachedData, 0);\n    }\n\n    this.frameIndex = 0;\n    return {\n      audioTrack: this._audioTrack,\n      avcTrack: Object(_dummy_demuxed_track__WEBPACK_IMPORTED_MODULE_2__[\"dummyTrack\"])(),\n      id3Track: this._id3Track,\n      textTrack: Object(_dummy_demuxed_track__WEBPACK_IMPORTED_MODULE_2__[\"dummyTrack\"])()\n    };\n  };\n\n  _proto.destroy = function destroy() {};\n\n  return BaseAudioDemuxer;\n}();\n/**\n * Initialize PTS\n * <p>\n *    use timestamp unless it is undefined, NaN or Infinity\n * </p>\n */\n\n\nvar initPTSFn = function initPTSFn(timestamp, timeOffset) {\n  return Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__[\"isFiniteNumber\"])(timestamp) ? timestamp * 90 : timeOffset * 90000;\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (BaseAudioDemuxer);\n\n/***/ }),\n\n/***/ \"./src/demux/chunk-cache.ts\":\n/*!**********************************!*\\\n  !*** ./src/demux/chunk-cache.ts ***!\n  \\**********************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_508407__) {\n\n\"use strict\";\n__nested_webpack_require_508407__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_508407__.d(__webpack_exports__, \"default\", function() { return ChunkCache; });\nvar ChunkCache = /*#__PURE__*/function () {\n  function ChunkCache() {\n    this.chunks = [];\n    this.dataLength = 0;\n  }\n\n  var _proto = ChunkCache.prototype;\n\n  _proto.push = function push(chunk) {\n    this.chunks.push(chunk);\n    this.dataLength += chunk.length;\n  };\n\n  _proto.flush = function flush() {\n    var chunks = this.chunks,\n        dataLength = this.dataLength;\n    var result;\n\n    if (!chunks.length) {\n      return new Uint8Array(0);\n    } else if (chunks.length === 1) {\n      result = chunks[0];\n    } else {\n      result = concatUint8Arrays(chunks, dataLength);\n    }\n\n    this.reset();\n    return result;\n  };\n\n  _proto.reset = function reset() {\n    this.chunks.length = 0;\n    this.dataLength = 0;\n  };\n\n  return ChunkCache;\n}();\n\n\n\nfunction concatUint8Arrays(chunks, dataLength) {\n  var result = new Uint8Array(dataLength);\n  var offset = 0;\n\n  for (var i = 0; i < chunks.length; i++) {\n    var chunk = chunks[i];\n    result.set(chunk, offset);\n    offset += chunk.length;\n  }\n\n  return result;\n}\n\n/***/ }),\n\n/***/ \"./src/demux/dummy-demuxed-track.ts\":\n/*!******************************************!*\\\n  !*** ./src/demux/dummy-demuxed-track.ts ***!\n  \\******************************************/\n/*! exports provided: dummyTrack */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_509910__) {\n\n\"use strict\";\n__nested_webpack_require_509910__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_509910__.d(__webpack_exports__, \"dummyTrack\", function() { return dummyTrack; });\nfunction dummyTrack() {\n  return {\n    type: '',\n    id: -1,\n    pid: -1,\n    inputTimeScale: 90000,\n    sequenceNumber: -1,\n    samples: [],\n    dropped: 0\n  };\n}\n\n/***/ }),\n\n/***/ \"./src/demux/exp-golomb.ts\":\n/*!*********************************!*\\\n  !*** ./src/demux/exp-golomb.ts ***!\n  \\*********************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_510521__) {\n\n\"use strict\";\n__nested_webpack_require_510521__.r(__webpack_exports__);\n/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_510521__(/*! ../utils/logger */ \"./src/utils/logger.ts\");\n/**\n * Parser for exponential Golomb codes, a variable-bitwidth number encoding scheme used by h264.\n */\n\n\nvar ExpGolomb = /*#__PURE__*/function () {\n  function ExpGolomb(data) {\n    this.data = void 0;\n    this.bytesAvailable = void 0;\n    this.word = void 0;\n    this.bitsAvailable = void 0;\n    this.data = data; // the number of bytes left to examine in this.data\n\n    this.bytesAvailable = data.byteLength; // the current word being examined\n\n    this.word = 0; // :uint\n    // the number of bits left to examine in the current word\n\n    this.bitsAvailable = 0; // :uint\n  } // ():void\n\n\n  var _proto = ExpGolomb.prototype;\n\n  _proto.loadWord = function loadWord() {\n    var data = this.data;\n    var bytesAvailable = this.bytesAvailable;\n    var position = data.byteLength - bytesAvailable;\n    var workingBytes = new Uint8Array(4);\n    var availableBytes = Math.min(4, bytesAvailable);\n\n    if (availableBytes === 0) {\n      throw new Error('no bytes available');\n    }\n\n    workingBytes.set(data.subarray(position, position + availableBytes));\n    this.word = new DataView(workingBytes.buffer).getUint32(0); // track the amount of this.data that has been processed\n\n    this.bitsAvailable = availableBytes * 8;\n    this.bytesAvailable -= availableBytes;\n  } // (count:int):void\n  ;\n\n  _proto.skipBits = function skipBits(count) {\n    var skipBytes; // :int\n\n    if (this.bitsAvailable > count) {\n      this.word <<= count;\n      this.bitsAvailable -= count;\n    } else {\n      count -= this.bitsAvailable;\n      skipBytes = count >> 3;\n      count -= skipBytes >> 3;\n      this.bytesAvailable -= skipBytes;\n      this.loadWord();\n      this.word <<= count;\n      this.bitsAvailable -= count;\n    }\n  } // (size:int):uint\n  ;\n\n  _proto.readBits = function readBits(size) {\n    var bits = Math.min(this.bitsAvailable, size); // :uint\n\n    var valu = this.word >>> 32 - bits; // :uint\n\n    if (size > 32) {\n      _utils_logger__WEBPACK_IMPORTED_MODULE_0__[\"logger\"].error('Cannot read more than 32 bits at a time');\n    }\n\n    this.bitsAvailable -= bits;\n\n    if (this.bitsAvailable > 0) {\n      this.word <<= bits;\n    } else if (this.bytesAvailable > 0) {\n      this.loadWord();\n    }\n\n    bits = size - bits;\n\n    if (bits > 0 && this.bitsAvailable) {\n      return valu << bits | this.readBits(bits);\n    } else {\n      return valu;\n    }\n  } // ():uint\n  ;\n\n  _proto.skipLZ = function skipLZ() {\n    var leadingZeroCount; // :uint\n\n    for (leadingZeroCount = 0; leadingZeroCount < this.bitsAvailable; ++leadingZeroCount) {\n      if ((this.word & 0x80000000 >>> leadingZeroCount) !== 0) {\n        // the first bit of working word is 1\n        this.word <<= leadingZeroCount;\n        this.bitsAvailable -= leadingZeroCount;\n        return leadingZeroCount;\n      }\n    } // we exhausted word and still have not found a 1\n\n\n    this.loadWord();\n    return leadingZeroCount + this.skipLZ();\n  } // ():void\n  ;\n\n  _proto.skipUEG = function skipUEG() {\n    this.skipBits(1 + this.skipLZ());\n  } // ():void\n  ;\n\n  _proto.skipEG = function skipEG() {\n    this.skipBits(1 + this.skipLZ());\n  } // ():uint\n  ;\n\n  _proto.readUEG = function readUEG() {\n    var clz = this.skipLZ(); // :uint\n\n    return this.readBits(clz + 1) - 1;\n  } // ():int\n  ;\n\n  _proto.readEG = function readEG() {\n    var valu = this.readUEG(); // :int\n\n    if (0x01 & valu) {\n      // the number is odd if the low order bit is set\n      return 1 + valu >>> 1; // add 1 to make it even, and divide by 2\n    } else {\n      return -1 * (valu >>> 1); // divide by two then make it negative\n    }\n  } // Some convenience functions\n  // :Boolean\n  ;\n\n  _proto.readBoolean = function readBoolean() {\n    return this.readBits(1) === 1;\n  } // ():int\n  ;\n\n  _proto.readUByte = function readUByte() {\n    return this.readBits(8);\n  } // ():int\n  ;\n\n  _proto.readUShort = function readUShort() {\n    return this.readBits(16);\n  } // ():int\n  ;\n\n  _proto.readUInt = function readUInt() {\n    return this.readBits(32);\n  }\n  /**\n   * Advance the ExpGolomb decoder past a scaling list. The scaling\n   * list is optionally transmitted as part of a sequence parameter\n   * set and is not relevant to transmuxing.\n   * @param count the number of entries in this scaling list\n   * @see Recommendation ITU-T H.264, Section 7.3.2.1.1.1\n   */\n  ;\n\n  _proto.skipScalingList = function skipScalingList(count) {\n    var lastScale = 8;\n    var nextScale = 8;\n    var deltaScale;\n\n    for (var j = 0; j < count; j++) {\n      if (nextScale !== 0) {\n        deltaScale = this.readEG();\n        nextScale = (lastScale + deltaScale + 256) % 256;\n      }\n\n      lastScale = nextScale === 0 ? lastScale : nextScale;\n    }\n  }\n  /**\n   * Read a sequence parameter set and return some interesting video\n   * properties. A sequence parameter set is the H264 metadata that\n   * describes the properties of upcoming video frames.\n   * @param data {Uint8Array} the bytes of a sequence parameter set\n   * @return {object} an object with configuration parsed from the\n   * sequence parameter set, including the dimensions of the\n   * associated video frames.\n   */\n  ;\n\n  _proto.readSPS = function readSPS() {\n    var frameCropLeftOffset = 0;\n    var frameCropRightOffset = 0;\n    var frameCropTopOffset = 0;\n    var frameCropBottomOffset = 0;\n    var numRefFramesInPicOrderCntCycle;\n    var scalingListCount;\n    var i;\n    var readUByte = this.readUByte.bind(this);\n    var readBits = this.readBits.bind(this);\n    var readUEG = this.readUEG.bind(this);\n    var readBoolean = this.readBoolean.bind(this);\n    var skipBits = this.skipBits.bind(this);\n    var skipEG = this.skipEG.bind(this);\n    var skipUEG = this.skipUEG.bind(this);\n    var skipScalingList = this.skipScalingList.bind(this);\n    readUByte();\n    var profileIdc = readUByte(); // profile_idc\n\n    readBits(5); // profileCompat constraint_set[0-4]_flag, u(5)\n\n    skipBits(3); // reserved_zero_3bits u(3),\n\n    readUByte(); // level_idc u(8)\n\n    skipUEG(); // seq_parameter_set_id\n    // some profiles have more optional data we don't need\n\n    if (profileIdc === 100 || profileIdc === 110 || profileIdc === 122 || profileIdc === 244 || profileIdc === 44 || profileIdc === 83 || profileIdc === 86 || profileIdc === 118 || profileIdc === 128) {\n      var chromaFormatIdc = readUEG();\n\n      if (chromaFormatIdc === 3) {\n        skipBits(1);\n      } // separate_colour_plane_flag\n\n\n      skipUEG(); // bit_depth_luma_minus8\n\n      skipUEG(); // bit_depth_chroma_minus8\n\n      skipBits(1); // qpprime_y_zero_transform_bypass_flag\n\n      if (readBoolean()) {\n        // seq_scaling_matrix_present_flag\n        scalingListCount = chromaFormatIdc !== 3 ? 8 : 12;\n\n        for (i = 0; i < scalingListCount; i++) {\n          if (readBoolean()) {\n            // seq_scaling_list_present_flag[ i ]\n            if (i < 6) {\n              skipScalingList(16);\n            } else {\n              skipScalingList(64);\n            }\n          }\n        }\n      }\n    }\n\n    skipUEG(); // log2_max_frame_num_minus4\n\n    var picOrderCntType = readUEG();\n\n    if (picOrderCntType === 0) {\n      readUEG(); // log2_max_pic_order_cnt_lsb_minus4\n    } else if (picOrderCntType === 1) {\n      skipBits(1); // delta_pic_order_always_zero_flag\n\n      skipEG(); // offset_for_non_ref_pic\n\n      skipEG(); // offset_for_top_to_bottom_field\n\n      numRefFramesInPicOrderCntCycle = readUEG();\n\n      for (i = 0; i < numRefFramesInPicOrderCntCycle; i++) {\n        skipEG();\n      } // offset_for_ref_frame[ i ]\n\n    }\n\n    skipUEG(); // max_num_ref_frames\n\n    skipBits(1); // gaps_in_frame_num_value_allowed_flag\n\n    var picWidthInMbsMinus1 = readUEG();\n    var picHeightInMapUnitsMinus1 = readUEG();\n    var frameMbsOnlyFlag = readBits(1);\n\n    if (frameMbsOnlyFlag === 0) {\n      skipBits(1);\n    } // mb_adaptive_frame_field_flag\n\n\n    skipBits(1); // direct_8x8_inference_flag\n\n    if (readBoolean()) {\n      // frame_cropping_flag\n      frameCropLeftOffset = readUEG();\n      frameCropRightOffset = readUEG();\n      frameCropTopOffset = readUEG();\n      frameCropBottomOffset = readUEG();\n    }\n\n    var pixelRatio = [1, 1];\n\n    if (readBoolean()) {\n      // vui_parameters_present_flag\n      if (readBoolean()) {\n        // aspect_ratio_info_present_flag\n        var aspectRatioIdc = readUByte();\n\n        switch (aspectRatioIdc) {\n          case 1:\n            pixelRatio = [1, 1];\n            break;\n\n          case 2:\n            pixelRatio = [12, 11];\n            break;\n\n          case 3:\n            pixelRatio = [10, 11];\n            break;\n\n          case 4:\n            pixelRatio = [16, 11];\n            break;\n\n          case 5:\n            pixelRatio = [40, 33];\n            break;\n\n          case 6:\n            pixelRatio = [24, 11];\n            break;\n\n          case 7:\n            pixelRatio = [20, 11];\n            break;\n\n          case 8:\n            pixelRatio = [32, 11];\n            break;\n\n          case 9:\n            pixelRatio = [80, 33];\n            break;\n\n          case 10:\n            pixelRatio = [18, 11];\n            break;\n\n          case 11:\n            pixelRatio = [15, 11];\n            break;\n\n          case 12:\n            pixelRatio = [64, 33];\n            break;\n\n          case 13:\n            pixelRatio = [160, 99];\n            break;\n\n          case 14:\n            pixelRatio = [4, 3];\n            break;\n\n          case 15:\n            pixelRatio = [3, 2];\n            break;\n\n          case 16:\n            pixelRatio = [2, 1];\n            break;\n\n          case 255:\n            {\n              pixelRatio = [readUByte() << 8 | readUByte(), readUByte() << 8 | readUByte()];\n              break;\n            }\n        }\n      }\n    }\n\n    return {\n      width: Math.ceil((picWidthInMbsMinus1 + 1) * 16 - frameCropLeftOffset * 2 - frameCropRightOffset * 2),\n      height: (2 - frameMbsOnlyFlag) * (picHeightInMapUnitsMinus1 + 1) * 16 - (frameMbsOnlyFlag ? 2 : 4) * (frameCropTopOffset + frameCropBottomOffset),\n      pixelRatio: pixelRatio\n    };\n  };\n\n  _proto.readSliceType = function readSliceType() {\n    // skip NALu type\n    this.readUByte(); // discard first_mb_in_slice\n\n    this.readUEG(); // return slice_type\n\n    return this.readUEG();\n  };\n\n  return ExpGolomb;\n}();\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (ExpGolomb);\n\n/***/ }),\n\n/***/ \"./src/demux/id3.ts\":\n/*!**************************!*\\\n  !*** ./src/demux/id3.ts ***!\n  \\**************************/\n/*! exports provided: isHeader, isFooter, getID3Data, canParse, getTimeStamp, isTimeStampFrame, getID3Frames, decodeFrame, utf8ArrayToStr, testables */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_521362__) {\n\n\"use strict\";\n__nested_webpack_require_521362__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_521362__.d(__webpack_exports__, \"isHeader\", function() { return isHeader; });\n/* harmony export (binding) */ __nested_webpack_require_521362__.d(__webpack_exports__, \"isFooter\", function() { return isFooter; });\n/* harmony export (binding) */ __nested_webpack_require_521362__.d(__webpack_exports__, \"getID3Data\", function() { return getID3Data; });\n/* harmony export (binding) */ __nested_webpack_require_521362__.d(__webpack_exports__, \"canParse\", function() { return canParse; });\n/* harmony export (binding) */ __nested_webpack_require_521362__.d(__webpack_exports__, \"getTimeStamp\", function() { return getTimeStamp; });\n/* harmony export (binding) */ __nested_webpack_require_521362__.d(__webpack_exports__, \"isTimeStampFrame\", function() { return isTimeStampFrame; });\n/* harmony export (binding) */ __nested_webpack_require_521362__.d(__webpack_exports__, \"getID3Frames\", function() { return getID3Frames; });\n/* harmony export (binding) */ __nested_webpack_require_521362__.d(__webpack_exports__, \"decodeFrame\", function() { return decodeFrame; });\n/* harmony export (binding) */ __nested_webpack_require_521362__.d(__webpack_exports__, \"utf8ArrayToStr\", function() { return utf8ArrayToStr; });\n/* harmony export (binding) */ __nested_webpack_require_521362__.d(__webpack_exports__, \"testables\", function() { return testables; });\n// breaking up those two types in order to clarify what is happening in the decoding path.\n\n/**\n * Returns true if an ID3 header can be found at offset in data\n * @param {Uint8Array} data - The data to search in\n * @param {number} offset - The offset at which to start searching\n * @return {boolean} - True if an ID3 header is found\n */\nvar isHeader = function isHeader(data, offset) {\n  /*\n   * http://id3.org/id3v2.3.0\n   * [0]     = 'I'\n   * [1]     = 'D'\n   * [2]     = '3'\n   * [3,4]   = {Version}\n   * [5]     = {Flags}\n   * [6-9]   = {ID3 Size}\n   *\n   * An ID3v2 tag can be detected with the following pattern:\n   *  $49 44 33 yy yy xx zz zz zz zz\n   * Where yy is less than $FF, xx is the 'flags' byte and zz is less than $80\n   */\n  if (offset + 10 <= data.length) {\n    // look for 'ID3' identifier\n    if (data[offset] === 0x49 && data[offset + 1] === 0x44 && data[offset + 2] === 0x33) {\n      // check version is within range\n      if (data[offset + 3] < 0xff && data[offset + 4] < 0xff) {\n        // check size is within range\n        if (data[offset + 6] < 0x80 && data[offset + 7] < 0x80 && data[offset + 8] < 0x80 && data[offset + 9] < 0x80) {\n          return true;\n        }\n      }\n    }\n  }\n\n  return false;\n};\n/**\n * Returns true if an ID3 footer can be found at offset in data\n * @param {Uint8Array} data - The data to search in\n * @param {number} offset - The offset at which to start searching\n * @return {boolean} - True if an ID3 footer is found\n */\n\nvar isFooter = function isFooter(data, offset) {\n  /*\n   * The footer is a copy of the header, but with a different identifier\n   */\n  if (offset + 10 <= data.length) {\n    // look for '3DI' identifier\n    if (data[offset] === 0x33 && data[offset + 1] === 0x44 && data[offset + 2] === 0x49) {\n      // check version is within range\n      if (data[offset + 3] < 0xff && data[offset + 4] < 0xff) {\n        // check size is within range\n        if (data[offset + 6] < 0x80 && data[offset + 7] < 0x80 && data[offset + 8] < 0x80 && data[offset + 9] < 0x80) {\n          return true;\n        }\n      }\n    }\n  }\n\n  return false;\n};\n/**\n * Returns any adjacent ID3 tags found in data starting at offset, as one block of data\n * @param {Uint8Array} data - The data to search in\n * @param {number} offset - The offset at which to start searching\n * @return {Uint8Array | undefined} - The block of data containing any ID3 tags found\n * or *undefined* if no header is found at the starting offset\n */\n\nvar getID3Data = function getID3Data(data, offset) {\n  var front = offset;\n  var length = 0;\n\n  while (isHeader(data, offset)) {\n    // ID3 header is 10 bytes\n    length += 10;\n    var size = readSize(data, offset + 6);\n    length += size;\n\n    if (isFooter(data, offset + 10)) {\n      // ID3 footer is 10 bytes\n      length += 10;\n    }\n\n    offset += length;\n  }\n\n  if (length > 0) {\n    return data.subarray(front, front + length);\n  }\n\n  return undefined;\n};\n\nvar readSize = function readSize(data, offset) {\n  var size = 0;\n  size = (data[offset] & 0x7f) << 21;\n  size |= (data[offset + 1] & 0x7f) << 14;\n  size |= (data[offset + 2] & 0x7f) << 7;\n  size |= data[offset + 3] & 0x7f;\n  return size;\n};\n\nvar canParse = function canParse(data, offset) {\n  return isHeader(data, offset) && readSize(data, offset + 6) + 10 <= data.length - offset;\n};\n/**\n * Searches for the Elementary Stream timestamp found in the ID3 data chunk\n * @param {Uint8Array} data - Block of data containing one or more ID3 tags\n * @return {number | undefined} - The timestamp\n */\n\nvar getTimeStamp = function getTimeStamp(data) {\n  var frames = getID3Frames(data);\n\n  for (var i = 0; i < frames.length; i++) {\n    var frame = frames[i];\n\n    if (isTimeStampFrame(frame)) {\n      return readTimeStamp(frame);\n    }\n  }\n\n  return undefined;\n};\n/**\n * Returns true if the ID3 frame is an Elementary Stream timestamp frame\n * @param {ID3 frame} frame\n */\n\nvar isTimeStampFrame = function isTimeStampFrame(frame) {\n  return frame && frame.key === 'PRIV' && frame.info === 'com.apple.streaming.transportStreamTimestamp';\n};\n\nvar getFrameData = function getFrameData(data) {\n  /*\n  Frame ID       $xx xx xx xx (four characters)\n  Size           $xx xx xx xx\n  Flags          $xx xx\n  */\n  var type = String.fromCharCode(data[0], data[1], data[2], data[3]);\n  var size = readSize(data, 4); // skip frame id, size, and flags\n\n  var offset = 10;\n  return {\n    type: type,\n    size: size,\n    data: data.subarray(offset, offset + size)\n  };\n};\n/**\n * Returns an array of ID3 frames found in all the ID3 tags in the id3Data\n * @param {Uint8Array} id3Data - The ID3 data containing one or more ID3 tags\n * @return {ID3.Frame[]} - Array of ID3 frame objects\n */\n\n\nvar getID3Frames = function getID3Frames(id3Data) {\n  var offset = 0;\n  var frames = [];\n\n  while (isHeader(id3Data, offset)) {\n    var size = readSize(id3Data, offset + 6); // skip past ID3 header\n\n    offset += 10;\n    var end = offset + size; // loop through frames in the ID3 tag\n\n    while (offset + 8 < end) {\n      var frameData = getFrameData(id3Data.subarray(offset));\n      var frame = decodeFrame(frameData);\n\n      if (frame) {\n        frames.push(frame);\n      } // skip frame header and frame data\n\n\n      offset += frameData.size + 10;\n    }\n\n    if (isFooter(id3Data, offset)) {\n      offset += 10;\n    }\n  }\n\n  return frames;\n};\nvar decodeFrame = function decodeFrame(frame) {\n  if (frame.type === 'PRIV') {\n    return decodePrivFrame(frame);\n  } else if (frame.type[0] === 'W') {\n    return decodeURLFrame(frame);\n  }\n\n  return decodeTextFrame(frame);\n};\n\nvar decodePrivFrame = function decodePrivFrame(frame) {\n  /*\n  Format: <text string>\\0<binary data>\n  */\n  if (frame.size < 2) {\n    return undefined;\n  }\n\n  var owner = utf8ArrayToStr(frame.data, true);\n  var privateData = new Uint8Array(frame.data.subarray(owner.length + 1));\n  return {\n    key: frame.type,\n    info: owner,\n    data: privateData.buffer\n  };\n};\n\nvar decodeTextFrame = function decodeTextFrame(frame) {\n  if (frame.size < 2) {\n    return undefined;\n  }\n\n  if (frame.type === 'TXXX') {\n    /*\n    Format:\n    [0]   = {Text Encoding}\n    [1-?] = {Description}\\0{Value}\n    */\n    var index = 1;\n    var description = utf8ArrayToStr(frame.data.subarray(index), true);\n    index += description.length + 1;\n    var value = utf8ArrayToStr(frame.data.subarray(index));\n    return {\n      key: frame.type,\n      info: description,\n      data: value\n    };\n  }\n  /*\n  Format:\n  [0]   = {Text Encoding}\n  [1-?] = {Value}\n  */\n\n\n  var text = utf8ArrayToStr(frame.data.subarray(1));\n  return {\n    key: frame.type,\n    data: text\n  };\n};\n\nvar decodeURLFrame = function decodeURLFrame(frame) {\n  if (frame.type === 'WXXX') {\n    /*\n    Format:\n    [0]   = {Text Encoding}\n    [1-?] = {Description}\\0{URL}\n    */\n    if (frame.size < 2) {\n      return undefined;\n    }\n\n    var index = 1;\n    var description = utf8ArrayToStr(frame.data.subarray(index), true);\n    index += description.length + 1;\n    var value = utf8ArrayToStr(frame.data.subarray(index));\n    return {\n      key: frame.type,\n      info: description,\n      data: value\n    };\n  }\n  /*\n  Format:\n  [0-?] = {URL}\n  */\n\n\n  var url = utf8ArrayToStr(frame.data);\n  return {\n    key: frame.type,\n    data: url\n  };\n};\n\nvar readTimeStamp = function readTimeStamp(timeStampFrame) {\n  if (timeStampFrame.data.byteLength === 8) {\n    var data = new Uint8Array(timeStampFrame.data); // timestamp is 33 bit expressed as a big-endian eight-octet number,\n    // with the upper 31 bits set to zero.\n\n    var pts33Bit = data[3] & 0x1;\n    var timestamp = (data[4] << 23) + (data[5] << 15) + (data[6] << 7) + data[7];\n    timestamp /= 45;\n\n    if (pts33Bit) {\n      timestamp += 47721858.84;\n    } // 2^32 / 90\n\n\n    return Math.round(timestamp);\n  }\n\n  return undefined;\n}; // http://stackoverflow.com/questions/8936984/uint8array-to-string-in-javascript/22373197\n// http://www.onicos.com/staff/iz/amuse/javascript/expert/utf.txt\n\n/* utf.js - UTF-8 <=> UTF-16 convertion\n *\n * Copyright (C) 1999 Masanao Izumo <iz@onicos.co.jp>\n * Version: 1.0\n * LastModified: Dec 25 1999\n * This library is free.  You can redistribute it and/or modify it.\n */\n\n\nvar utf8ArrayToStr = function utf8ArrayToStr(array, exitOnNull) {\n  if (exitOnNull === void 0) {\n    exitOnNull = false;\n  }\n\n  var decoder = getTextDecoder();\n\n  if (decoder) {\n    var decoded = decoder.decode(array);\n\n    if (exitOnNull) {\n      // grab up to the first null\n      var idx = decoded.indexOf('\\0');\n      return idx !== -1 ? decoded.substring(0, idx) : decoded;\n    } // remove any null characters\n\n\n    return decoded.replace(/\\0/g, '');\n  }\n\n  var len = array.length;\n  var c;\n  var char2;\n  var char3;\n  var out = '';\n  var i = 0;\n\n  while (i < len) {\n    c = array[i++];\n\n    if (c === 0x00 && exitOnNull) {\n      return out;\n    } else if (c === 0x00 || c === 0x03) {\n      // If the character is 3 (END_OF_TEXT) or 0 (NULL) then skip it\n      continue;\n    }\n\n    switch (c >> 4) {\n      case 0:\n      case 1:\n      case 2:\n      case 3:\n      case 4:\n      case 5:\n      case 6:\n      case 7:\n        // 0xxxxxxx\n        out += String.fromCharCode(c);\n        break;\n\n      case 12:\n      case 13:\n        // 110x xxxx   10xx xxxx\n        char2 = array[i++];\n        out += String.fromCharCode((c & 0x1f) << 6 | char2 & 0x3f);\n        break;\n\n      case 14:\n        // 1110 xxxx  10xx xxxx  10xx xxxx\n        char2 = array[i++];\n        char3 = array[i++];\n        out += String.fromCharCode((c & 0x0f) << 12 | (char2 & 0x3f) << 6 | (char3 & 0x3f) << 0);\n        break;\n\n      default:\n    }\n  }\n\n  return out;\n};\nvar testables = {\n  decodeTextFrame: decodeTextFrame\n};\nvar decoder;\n\nfunction getTextDecoder() {\n  if (!decoder && typeof self.TextDecoder !== 'undefined') {\n    decoder = new self.TextDecoder('utf-8');\n  }\n\n  return decoder;\n}\n\n/***/ }),\n\n/***/ \"./src/demux/mp3demuxer.ts\":\n/*!*********************************!*\\\n  !*** ./src/demux/mp3demuxer.ts ***!\n  \\*********************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_532784__) {\n\n\"use strict\";\n__nested_webpack_require_532784__.r(__webpack_exports__);\n/* harmony import */ var _base_audio_demuxer__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_532784__(/*! ./base-audio-demuxer */ \"./src/demux/base-audio-demuxer.ts\");\n/* harmony import */ var _demux_id3__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_532784__(/*! ../demux/id3 */ \"./src/demux/id3.ts\");\n/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_532784__(/*! ../utils/logger */ \"./src/utils/logger.ts\");\n/* harmony import */ var _mpegaudio__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_532784__(/*! ./mpegaudio */ \"./src/demux/mpegaudio.ts\");\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n/**\n * MP3 demuxer\n */\n\n\n\n\n\nvar MP3Demuxer = /*#__PURE__*/function (_BaseAudioDemuxer) {\n  _inheritsLoose(MP3Demuxer, _BaseAudioDemuxer);\n\n  function MP3Demuxer() {\n    return _BaseAudioDemuxer.apply(this, arguments) || this;\n  }\n\n  var _proto = MP3Demuxer.prototype;\n\n  _proto.resetInitSegment = function resetInitSegment(audioCodec, videoCodec, duration) {\n    _BaseAudioDemuxer.prototype.resetInitSegment.call(this, audioCodec, videoCodec, duration);\n\n    this._audioTrack = {\n      container: 'audio/mpeg',\n      type: 'audio',\n      id: 2,\n      pid: -1,\n      sequenceNumber: 0,\n      isAAC: false,\n      samples: [],\n      manifestCodec: audioCodec,\n      duration: duration,\n      inputTimeScale: 90000,\n      dropped: 0\n    };\n  };\n\n  MP3Demuxer.probe = function probe(data) {\n    if (!data) {\n      return false;\n    } // check if data contains ID3 timestamp and MPEG sync word\n    // Look for MPEG header | 1111 1111 | 111X XYZX | where X can be either 0 or 1 and Y or Z should be 1\n    // Layer bits (position 14 and 15) in header should be always different from 0 (Layer I or Layer II or Layer III)\n    // More info http://www.mp3-tech.org/programmer/frame_header.html\n\n\n    var id3Data = _demux_id3__WEBPACK_IMPORTED_MODULE_1__[\"getID3Data\"](data, 0) || [];\n    var offset = id3Data.length;\n\n    for (var length = data.length; offset < length; offset++) {\n      if (_mpegaudio__WEBPACK_IMPORTED_MODULE_3__[\"probe\"](data, offset)) {\n        _utils_logger__WEBPACK_IMPORTED_MODULE_2__[\"logger\"].log('MPEG Audio sync word found !');\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  _proto.canParse = function canParse(data, offset) {\n    return _mpegaudio__WEBPACK_IMPORTED_MODULE_3__[\"canParse\"](data, offset);\n  };\n\n  _proto.appendFrame = function appendFrame(track, data, offset) {\n    if (this.initPTS === null) {\n      return;\n    }\n\n    return _mpegaudio__WEBPACK_IMPORTED_MODULE_3__[\"appendFrame\"](track, data, offset, this.initPTS, this.frameIndex);\n  };\n\n  return MP3Demuxer;\n}(_base_audio_demuxer__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n\nMP3Demuxer.minProbeByteLength = 4;\n/* harmony default export */ __webpack_exports__[\"default\"] = (MP3Demuxer);\n\n/***/ }),\n\n/***/ \"./src/demux/mp4demuxer.ts\":\n/*!*********************************!*\\\n  !*** ./src/demux/mp4demuxer.ts ***!\n  \\*********************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_536221__) {\n\n\"use strict\";\n__nested_webpack_require_536221__.r(__webpack_exports__);\n/* harmony import */ var _utils_mp4_tools__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_536221__(/*! ../utils/mp4-tools */ \"./src/utils/mp4-tools.ts\");\n/* harmony import */ var _dummy_demuxed_track__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_536221__(/*! ./dummy-demuxed-track */ \"./src/demux/dummy-demuxed-track.ts\");\n/**\n * MP4 demuxer\n */\n\n\n\nvar MP4Demuxer = /*#__PURE__*/function () {\n  function MP4Demuxer(observer, config) {\n    this.remainderData = null;\n    this.config = void 0;\n    this.config = config;\n  }\n\n  var _proto = MP4Demuxer.prototype;\n\n  _proto.resetTimeStamp = function resetTimeStamp() {};\n\n  _proto.resetInitSegment = function resetInitSegment() {};\n\n  _proto.resetContiguity = function resetContiguity() {};\n\n  MP4Demuxer.probe = function probe(data) {\n    // ensure we find a moof box in the first 16 kB\n    return Object(_utils_mp4_tools__WEBPACK_IMPORTED_MODULE_0__[\"findBox\"])({\n      data: data,\n      start: 0,\n      end: Math.min(data.length, 16384)\n    }, ['moof']).length > 0;\n  };\n\n  _proto.demux = function demux(data) {\n    // Load all data into the avc track. The CMAF remuxer will look for the data in the samples object; the rest of the fields do not matter\n    var avcSamples = data;\n    var avcTrack = Object(_dummy_demuxed_track__WEBPACK_IMPORTED_MODULE_1__[\"dummyTrack\"])();\n\n    if (this.config.progressive) {\n      // Split the bytestream into two ranges: one encompassing all data up until the start of the last moof, and everything else.\n      // This is done to guarantee that we're sending valid data to MSE - when demuxing progressively, we have no guarantee\n      // that the fetch loader gives us flush moof+mdat pairs. If we push jagged data to MSE, it will throw an exception.\n      if (this.remainderData) {\n        avcSamples = Object(_utils_mp4_tools__WEBPACK_IMPORTED_MODULE_0__[\"appendUint8Array\"])(this.remainderData, data);\n      }\n\n      var segmentedData = Object(_utils_mp4_tools__WEBPACK_IMPORTED_MODULE_0__[\"segmentValidRange\"])(avcSamples);\n      this.remainderData = segmentedData.remainder;\n      avcTrack.samples = segmentedData.valid || new Uint8Array();\n    } else {\n      avcTrack.samples = avcSamples;\n    }\n\n    return {\n      audioTrack: Object(_dummy_demuxed_track__WEBPACK_IMPORTED_MODULE_1__[\"dummyTrack\"])(),\n      avcTrack: avcTrack,\n      id3Track: Object(_dummy_demuxed_track__WEBPACK_IMPORTED_MODULE_1__[\"dummyTrack\"])(),\n      textTrack: Object(_dummy_demuxed_track__WEBPACK_IMPORTED_MODULE_1__[\"dummyTrack\"])()\n    };\n  };\n\n  _proto.flush = function flush() {\n    var avcTrack = Object(_dummy_demuxed_track__WEBPACK_IMPORTED_MODULE_1__[\"dummyTrack\"])();\n    avcTrack.samples = this.remainderData || new Uint8Array();\n    this.remainderData = null;\n    return {\n      audioTrack: Object(_dummy_demuxed_track__WEBPACK_IMPORTED_MODULE_1__[\"dummyTrack\"])(),\n      avcTrack: avcTrack,\n      id3Track: Object(_dummy_demuxed_track__WEBPACK_IMPORTED_MODULE_1__[\"dummyTrack\"])(),\n      textTrack: Object(_dummy_demuxed_track__WEBPACK_IMPORTED_MODULE_1__[\"dummyTrack\"])()\n    };\n  };\n\n  _proto.demuxSampleAes = function demuxSampleAes(data, keyData, timeOffset) {\n    return Promise.reject(new Error('The MP4 demuxer does not support SAMPLE-AES decryption'));\n  };\n\n  _proto.destroy = function destroy() {};\n\n  return MP4Demuxer;\n}();\n\nMP4Demuxer.minProbeByteLength = 1024;\n/* harmony default export */ __webpack_exports__[\"default\"] = (MP4Demuxer);\n\n/***/ }),\n\n/***/ \"./src/demux/mpegaudio.ts\":\n/*!********************************!*\\\n  !*** ./src/demux/mpegaudio.ts ***!\n  \\********************************/\n/*! exports provided: appendFrame, parseHeader, isHeaderPattern, isHeader, canParse, probe */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_540022__) {\n\n\"use strict\";\n__nested_webpack_require_540022__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_540022__.d(__webpack_exports__, \"appendFrame\", function() { return appendFrame; });\n/* harmony export (binding) */ __nested_webpack_require_540022__.d(__webpack_exports__, \"parseHeader\", function() { return parseHeader; });\n/* harmony export (binding) */ __nested_webpack_require_540022__.d(__webpack_exports__, \"isHeaderPattern\", function() { return isHeaderPattern; });\n/* harmony export (binding) */ __nested_webpack_require_540022__.d(__webpack_exports__, \"isHeader\", function() { return isHeader; });\n/* harmony export (binding) */ __nested_webpack_require_540022__.d(__webpack_exports__, \"canParse\", function() { return canParse; });\n/* harmony export (binding) */ __nested_webpack_require_540022__.d(__webpack_exports__, \"probe\", function() { return probe; });\n/**\n *  MPEG parser helper\n */\nvar chromeVersion = null;\nvar BitratesMap = [32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448, 32, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 32, 48, 56, 64, 80, 96, 112, 128, 144, 160, 176, 192, 224, 256, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160];\nvar SamplingRateMap = [44100, 48000, 32000, 22050, 24000, 16000, 11025, 12000, 8000];\nvar SamplesCoefficients = [// MPEG 2.5\n[0, // Reserved\n72, // Layer3\n144, // Layer2\n12 // Layer1\n], // Reserved\n[0, // Reserved\n0, // Layer3\n0, // Layer2\n0 // Layer1\n], // MPEG 2\n[0, // Reserved\n72, // Layer3\n144, // Layer2\n12 // Layer1\n], // MPEG 1\n[0, // Reserved\n144, // Layer3\n144, // Layer2\n12 // Layer1\n]];\nvar BytesInSlot = [0, // Reserved\n1, // Layer3\n1, // Layer2\n4 // Layer1\n];\nfunction appendFrame(track, data, offset, pts, frameIndex) {\n  // Using http://www.datavoyage.com/mpgscript/mpeghdr.htm as a reference\n  if (offset + 24 > data.length) {\n    return;\n  }\n\n  var header = parseHeader(data, offset);\n\n  if (header && offset + header.frameLength <= data.length) {\n    var frameDuration = header.samplesPerFrame * 90000 / header.sampleRate;\n    var stamp = pts + frameIndex * frameDuration;\n    var sample = {\n      unit: data.subarray(offset, offset + header.frameLength),\n      pts: stamp,\n      dts: stamp\n    };\n    track.config = [];\n    track.channelCount = header.channelCount;\n    track.samplerate = header.sampleRate;\n    track.samples.push(sample);\n    return {\n      sample: sample,\n      length: header.frameLength,\n      missing: 0\n    };\n  }\n}\nfunction parseHeader(data, offset) {\n  var mpegVersion = data[offset + 1] >> 3 & 3;\n  var mpegLayer = data[offset + 1] >> 1 & 3;\n  var bitRateIndex = data[offset + 2] >> 4 & 15;\n  var sampleRateIndex = data[offset + 2] >> 2 & 3;\n\n  if (mpegVersion !== 1 && bitRateIndex !== 0 && bitRateIndex !== 15 && sampleRateIndex !== 3) {\n    var paddingBit = data[offset + 2] >> 1 & 1;\n    var channelMode = data[offset + 3] >> 6;\n    var columnInBitrates = mpegVersion === 3 ? 3 - mpegLayer : mpegLayer === 3 ? 3 : 4;\n    var bitRate = BitratesMap[columnInBitrates * 14 + bitRateIndex - 1] * 1000;\n    var columnInSampleRates = mpegVersion === 3 ? 0 : mpegVersion === 2 ? 1 : 2;\n    var sampleRate = SamplingRateMap[columnInSampleRates * 3 + sampleRateIndex];\n    var channelCount = channelMode === 3 ? 1 : 2; // If bits of channel mode are `11` then it is a single channel (Mono)\n\n    var sampleCoefficient = SamplesCoefficients[mpegVersion][mpegLayer];\n    var bytesInSlot = BytesInSlot[mpegLayer];\n    var samplesPerFrame = sampleCoefficient * 8 * bytesInSlot;\n    var frameLength = Math.floor(sampleCoefficient * bitRate / sampleRate + paddingBit) * bytesInSlot;\n\n    if (chromeVersion === null) {\n      var userAgent = navigator.userAgent || '';\n      var result = userAgent.match(/Chrome\\/(\\d+)/i);\n      chromeVersion = result ? parseInt(result[1]) : 0;\n    }\n\n    var needChromeFix = !!chromeVersion && chromeVersion <= 87;\n\n    if (needChromeFix && mpegLayer === 2 && bitRate >= 224000 && channelMode === 0) {\n      // Work around bug in Chromium by setting channelMode to dual-channel (01) instead of stereo (00)\n      data[offset + 3] = data[offset + 3] | 0x80;\n    }\n\n    return {\n      sampleRate: sampleRate,\n      channelCount: channelCount,\n      frameLength: frameLength,\n      samplesPerFrame: samplesPerFrame\n    };\n  }\n}\nfunction isHeaderPattern(data, offset) {\n  return data[offset] === 0xff && (data[offset + 1] & 0xe0) === 0xe0 && (data[offset + 1] & 0x06) !== 0x00;\n}\nfunction isHeader(data, offset) {\n  // Look for MPEG header | 1111 1111 | 111X XYZX | where X can be either 0 or 1 and Y or Z should be 1\n  // Layer bits (position 14 and 15) in header should be always different from 0 (Layer I or Layer II or Layer III)\n  // More info http://www.mp3-tech.org/programmer/frame_header.html\n  return offset + 1 < data.length && isHeaderPattern(data, offset);\n}\nfunction canParse(data, offset) {\n  var headerSize = 4;\n  return isHeaderPattern(data, offset) && headerSize <= data.length - offset;\n}\nfunction probe(data, offset) {\n  // same as isHeader but we also check that MPEG frame follows last MPEG frame\n  // or end of data is reached\n  if (offset + 1 < data.length && isHeaderPattern(data, offset)) {\n    // MPEG header Length\n    var headerLength = 4; // MPEG frame Length\n\n    var header = parseHeader(data, offset);\n    var frameLength = headerLength;\n\n    if (header !== null && header !== void 0 && header.frameLength) {\n      frameLength = header.frameLength;\n    }\n\n    var newOffset = offset + frameLength;\n    return newOffset === data.length || isHeader(data, newOffset);\n  }\n\n  return false;\n}\n\n/***/ }),\n\n/***/ \"./src/demux/sample-aes.ts\":\n/*!*********************************!*\\\n  !*** ./src/demux/sample-aes.ts ***!\n  \\*********************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_545861__) {\n\n\"use strict\";\n__nested_webpack_require_545861__.r(__webpack_exports__);\n/* harmony import */ var _crypt_decrypter__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_545861__(/*! ../crypt/decrypter */ \"./src/crypt/decrypter.ts\");\n/* harmony import */ var _tsdemuxer__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_545861__(/*! ./tsdemuxer */ \"./src/demux/tsdemuxer.ts\");\n/**\n * SAMPLE-AES decrypter\n */\n\n\n\nvar SampleAesDecrypter = /*#__PURE__*/function () {\n  function SampleAesDecrypter(observer, config, keyData) {\n    this.keyData = void 0;\n    this.decrypter = void 0;\n    this.keyData = keyData;\n    this.decrypter = new _crypt_decrypter__WEBPACK_IMPORTED_MODULE_0__[\"default\"](observer, config, {\n      removePKCS7Padding: false\n    });\n  }\n\n  var _proto = SampleAesDecrypter.prototype;\n\n  _proto.decryptBuffer = function decryptBuffer(encryptedData, callback) {\n    this.decrypter.decrypt(encryptedData, this.keyData.key.buffer, this.keyData.iv.buffer, callback);\n  } // AAC - encrypt all full 16 bytes blocks starting from offset 16\n  ;\n\n  _proto.decryptAacSample = function decryptAacSample(samples, sampleIndex, callback, sync) {\n    var curUnit = samples[sampleIndex].unit;\n    var encryptedData = curUnit.subarray(16, curUnit.length - curUnit.length % 16);\n    var encryptedBuffer = encryptedData.buffer.slice(encryptedData.byteOffset, encryptedData.byteOffset + encryptedData.length);\n    var localthis = this;\n    this.decryptBuffer(encryptedBuffer, function (decryptedBuffer) {\n      var decryptedData = new Uint8Array(decryptedBuffer);\n      curUnit.set(decryptedData, 16);\n\n      if (!sync) {\n        localthis.decryptAacSamples(samples, sampleIndex + 1, callback);\n      }\n    });\n  };\n\n  _proto.decryptAacSamples = function decryptAacSamples(samples, sampleIndex, callback) {\n    for (;; sampleIndex++) {\n      if (sampleIndex >= samples.length) {\n        callback();\n        return;\n      }\n\n      if (samples[sampleIndex].unit.length < 32) {\n        continue;\n      }\n\n      var sync = this.decrypter.isSync();\n      this.decryptAacSample(samples, sampleIndex, callback, sync);\n\n      if (!sync) {\n        return;\n      }\n    }\n  } // AVC - encrypt one 16 bytes block out of ten, starting from offset 32\n  ;\n\n  _proto.getAvcEncryptedData = function getAvcEncryptedData(decodedData) {\n    var encryptedDataLen = Math.floor((decodedData.length - 48) / 160) * 16 + 16;\n    var encryptedData = new Int8Array(encryptedDataLen);\n    var outputPos = 0;\n\n    for (var inputPos = 32; inputPos < decodedData.length - 16; inputPos += 160, outputPos += 16) {\n      encryptedData.set(decodedData.subarray(inputPos, inputPos + 16), outputPos);\n    }\n\n    return encryptedData;\n  };\n\n  _proto.getAvcDecryptedUnit = function getAvcDecryptedUnit(decodedData, decryptedData) {\n    var uint8DecryptedData = new Uint8Array(decryptedData);\n    var inputPos = 0;\n\n    for (var outputPos = 32; outputPos < decodedData.length - 16; outputPos += 160, inputPos += 16) {\n      decodedData.set(uint8DecryptedData.subarray(inputPos, inputPos + 16), outputPos);\n    }\n\n    return decodedData;\n  };\n\n  _proto.decryptAvcSample = function decryptAvcSample(samples, sampleIndex, unitIndex, callback, curUnit, sync) {\n    var decodedData = Object(_tsdemuxer__WEBPACK_IMPORTED_MODULE_1__[\"discardEPB\"])(curUnit.data);\n    var encryptedData = this.getAvcEncryptedData(decodedData);\n    var localthis = this;\n    this.decryptBuffer(encryptedData.buffer, function (decryptedBuffer) {\n      curUnit.data = localthis.getAvcDecryptedUnit(decodedData, decryptedBuffer);\n\n      if (!sync) {\n        localthis.decryptAvcSamples(samples, sampleIndex, unitIndex + 1, callback);\n      }\n    });\n  };\n\n  _proto.decryptAvcSamples = function decryptAvcSamples(samples, sampleIndex, unitIndex, callback) {\n    if (samples instanceof Uint8Array) {\n      throw new Error('Cannot decrypt samples of type Uint8Array');\n    }\n\n    for (;; sampleIndex++, unitIndex = 0) {\n      if (sampleIndex >= samples.length) {\n        callback();\n        return;\n      }\n\n      var curUnits = samples[sampleIndex].units;\n\n      for (;; unitIndex++) {\n        if (unitIndex >= curUnits.length) {\n          break;\n        }\n\n        var curUnit = curUnits[unitIndex];\n\n        if (curUnit.data.length <= 48 || curUnit.type !== 1 && curUnit.type !== 5) {\n          continue;\n        }\n\n        var sync = this.decrypter.isSync();\n        this.decryptAvcSample(samples, sampleIndex, unitIndex, callback, curUnit, sync);\n\n        if (!sync) {\n          return;\n        }\n      }\n    }\n  };\n\n  return SampleAesDecrypter;\n}();\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (SampleAesDecrypter);\n\n/***/ }),\n\n/***/ \"./src/demux/transmuxer-interface.ts\":\n/*!*******************************************!*\\\n  !*** ./src/demux/transmuxer-interface.ts ***!\n  \\*******************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_550792__) {\n\n\"use strict\";\n__nested_webpack_require_550792__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_550792__.d(__webpack_exports__, \"default\", function() { return TransmuxerInterface; });\n/* harmony import */ var webworkify_webpack__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_550792__(/*! webworkify-webpack */ \"./node_modules/webworkify-webpack/index.js\");\n/* harmony import */ var webworkify_webpack__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__nested_webpack_require_550792__.n(webworkify_webpack__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_550792__(/*! ../events */ \"./src/events.ts\");\n/* harmony import */ var _demux_transmuxer__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_550792__(/*! ../demux/transmuxer */ \"./src/demux/transmuxer.ts\");\n/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_550792__(/*! ../utils/logger */ \"./src/utils/logger.ts\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_550792__(/*! ../errors */ \"./src/errors.ts\");\n/* harmony import */ var _utils_mediasource_helper__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_550792__(/*! ../utils/mediasource-helper */ \"./src/utils/mediasource-helper.ts\");\n/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_550792__(/*! eventemitter3 */ \"./node_modules/eventemitter3/index.js\");\n/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__nested_webpack_require_550792__.n(eventemitter3__WEBPACK_IMPORTED_MODULE_6__);\n\n\n\n\n\n\n\nvar MediaSource = Object(_utils_mediasource_helper__WEBPACK_IMPORTED_MODULE_5__[\"getMediaSource\"])() || {\n  isTypeSupported: function isTypeSupported() {\n    return false;\n  }\n};\n\nvar TransmuxerInterface = /*#__PURE__*/function () {\n  function TransmuxerInterface(hls, id, onTransmuxComplete, onFlush) {\n    var _this = this;\n\n    this.hls = void 0;\n    this.id = void 0;\n    this.observer = void 0;\n    this.frag = null;\n    this.part = null;\n    this.worker = void 0;\n    this.onwmsg = void 0;\n    this.transmuxer = null;\n    this.onTransmuxComplete = void 0;\n    this.onFlush = void 0;\n    this.hls = hls;\n    this.id = id;\n    this.onTransmuxComplete = onTransmuxComplete;\n    this.onFlush = onFlush;\n    var config = hls.config;\n\n    var forwardMessage = function forwardMessage(ev, data) {\n      data = data || {};\n      data.frag = _this.frag;\n      data.id = _this.id;\n      hls.trigger(ev, data);\n    }; // forward events to main thread\n\n\n    this.observer = new eventemitter3__WEBPACK_IMPORTED_MODULE_6__[\"EventEmitter\"]();\n    this.observer.on(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].FRAG_DECRYPTED, forwardMessage);\n    this.observer.on(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].ERROR, forwardMessage);\n    var typeSupported = {\n      mp4: MediaSource.isTypeSupported('video/mp4'),\n      mpeg: MediaSource.isTypeSupported('audio/mpeg'),\n      mp3: MediaSource.isTypeSupported('audio/mp4; codecs=\"mp3\"')\n    }; // navigator.vendor is not always available in Web Worker\n    // refer to https://developer.mozilla.org/en-US/docs/Web/API/WorkerGlobalScope/navigator\n\n    var vendor = navigator.vendor;\n\n    if (config.enableWorker && typeof Worker !== 'undefined') {\n      _utils_logger__WEBPACK_IMPORTED_MODULE_3__[\"logger\"].log('demuxing in webworker');\n      var worker;\n\n      try {\n        worker = this.worker = webworkify_webpack__WEBPACK_IMPORTED_MODULE_0__(/*require.resolve*/(/*! ../demux/transmuxer-worker.ts */ \"./src/demux/transmuxer-worker.ts\"));\n        this.onwmsg = this.onWorkerMessage.bind(this);\n        worker.addEventListener('message', this.onwmsg);\n\n        worker.onerror = function (event) {\n          hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].ERROR, {\n            type: _errors__WEBPACK_IMPORTED_MODULE_4__[\"ErrorTypes\"].OTHER_ERROR,\n            details: _errors__WEBPACK_IMPORTED_MODULE_4__[\"ErrorDetails\"].INTERNAL_EXCEPTION,\n            fatal: true,\n            event: 'demuxerWorker',\n            error: new Error(event.message + \"  (\" + event.filename + \":\" + event.lineno + \")\")\n          });\n        };\n\n        worker.postMessage({\n          cmd: 'init',\n          typeSupported: typeSupported,\n          vendor: vendor,\n          id: id,\n          config: JSON.stringify(config)\n        });\n      } catch (err) {\n        _utils_logger__WEBPACK_IMPORTED_MODULE_3__[\"logger\"].warn('Error in worker:', err);\n        _utils_logger__WEBPACK_IMPORTED_MODULE_3__[\"logger\"].error('Error while initializing DemuxerWorker, fallback to inline');\n\n        if (worker) {\n          // revoke the Object URL that was used to create transmuxer worker, so as not to leak it\n          self.URL.revokeObjectURL(worker.objectURL);\n        }\n\n        this.transmuxer = new _demux_transmuxer__WEBPACK_IMPORTED_MODULE_2__[\"default\"](this.observer, typeSupported, config, vendor, id);\n        this.worker = null;\n      }\n    } else {\n      this.transmuxer = new _demux_transmuxer__WEBPACK_IMPORTED_MODULE_2__[\"default\"](this.observer, typeSupported, config, vendor, id);\n    }\n  }\n\n  var _proto = TransmuxerInterface.prototype;\n\n  _proto.destroy = function destroy() {\n    var w = this.worker;\n\n    if (w) {\n      w.removeEventListener('message', this.onwmsg);\n      w.terminate();\n      this.worker = null;\n    } else {\n      var transmuxer = this.transmuxer;\n\n      if (transmuxer) {\n        transmuxer.destroy();\n        this.transmuxer = null;\n      }\n    }\n\n    var observer = this.observer;\n\n    if (observer) {\n      observer.removeAllListeners();\n    } // @ts-ignore\n\n\n    this.observer = null;\n  };\n\n  _proto.push = function push(data, initSegmentData, audioCodec, videoCodec, frag, part, duration, accurateTimeOffset, chunkMeta, defaultInitPTS) {\n    var _frag$initSegment,\n        _lastFrag$initSegment,\n        _this2 = this;\n\n    chunkMeta.transmuxing.start = self.performance.now();\n    var transmuxer = this.transmuxer,\n        worker = this.worker;\n    var timeOffset = part ? part.start : frag.start;\n    var decryptdata = frag.decryptdata;\n    var lastFrag = this.frag;\n    var discontinuity = !(lastFrag && frag.cc === lastFrag.cc);\n    var trackSwitch = !(lastFrag && chunkMeta.level === lastFrag.level);\n    var snDiff = lastFrag ? chunkMeta.sn - lastFrag.sn : -1;\n    var partDiff = this.part ? chunkMeta.part - this.part.index : 1;\n    var contiguous = !trackSwitch && (snDiff === 1 || snDiff === 0 && partDiff === 1);\n    var now = self.performance.now();\n\n    if (trackSwitch || snDiff || frag.stats.parsing.start === 0) {\n      frag.stats.parsing.start = now;\n    }\n\n    if (part && (partDiff || !contiguous)) {\n      part.stats.parsing.start = now;\n    }\n\n    var initSegmentChange = !(lastFrag && ((_frag$initSegment = frag.initSegment) === null || _frag$initSegment === void 0 ? void 0 : _frag$initSegment.url) === ((_lastFrag$initSegment = lastFrag.initSegment) === null || _lastFrag$initSegment === void 0 ? void 0 : _lastFrag$initSegment.url));\n    var state = new _demux_transmuxer__WEBPACK_IMPORTED_MODULE_2__[\"TransmuxState\"](discontinuity, contiguous, accurateTimeOffset, trackSwitch, timeOffset, initSegmentChange);\n\n    if (!contiguous || discontinuity || initSegmentChange) {\n      _utils_logger__WEBPACK_IMPORTED_MODULE_3__[\"logger\"].log(\"[transmuxer-interface, \" + frag.type + \"]: Starting new transmux session for sn: \" + chunkMeta.sn + \" p: \" + chunkMeta.part + \" level: \" + chunkMeta.level + \" id: \" + chunkMeta.id + \"\\n        discontinuity: \" + discontinuity + \"\\n        trackSwitch: \" + trackSwitch + \"\\n        contiguous: \" + contiguous + \"\\n        accurateTimeOffset: \" + accurateTimeOffset + \"\\n        timeOffset: \" + timeOffset + \"\\n        initSegmentChange: \" + initSegmentChange);\n      var config = new _demux_transmuxer__WEBPACK_IMPORTED_MODULE_2__[\"TransmuxConfig\"](audioCodec, videoCodec, initSegmentData, duration, defaultInitPTS);\n      this.configureTransmuxer(config);\n    }\n\n    this.frag = frag;\n    this.part = part; // Frags with sn of 'initSegment' are not transmuxed\n\n    if (worker) {\n      // post fragment payload as transferable objects for ArrayBuffer (no copy)\n      worker.postMessage({\n        cmd: 'demux',\n        data: data,\n        decryptdata: decryptdata,\n        chunkMeta: chunkMeta,\n        state: state\n      }, data instanceof ArrayBuffer ? [data] : []);\n    } else if (transmuxer) {\n      var _transmuxResult = transmuxer.push(data, decryptdata, chunkMeta, state);\n\n      if (Object(_demux_transmuxer__WEBPACK_IMPORTED_MODULE_2__[\"isPromise\"])(_transmuxResult)) {\n        _transmuxResult.then(function (data) {\n          _this2.handleTransmuxComplete(data);\n        });\n      } else {\n        this.handleTransmuxComplete(_transmuxResult);\n      }\n    }\n  };\n\n  _proto.flush = function flush(chunkMeta) {\n    var _this3 = this;\n\n    chunkMeta.transmuxing.start = self.performance.now();\n    var transmuxer = this.transmuxer,\n        worker = this.worker;\n\n    if (worker) {\n      worker.postMessage({\n        cmd: 'flush',\n        chunkMeta: chunkMeta\n      });\n    } else if (transmuxer) {\n      var _transmuxResult2 = transmuxer.flush(chunkMeta);\n\n      if (Object(_demux_transmuxer__WEBPACK_IMPORTED_MODULE_2__[\"isPromise\"])(_transmuxResult2)) {\n        _transmuxResult2.then(function (data) {\n          _this3.handleFlushResult(data, chunkMeta);\n        });\n      } else {\n        this.handleFlushResult(_transmuxResult2, chunkMeta);\n      }\n    }\n  };\n\n  _proto.handleFlushResult = function handleFlushResult(results, chunkMeta) {\n    var _this4 = this;\n\n    results.forEach(function (result) {\n      _this4.handleTransmuxComplete(result);\n    });\n    this.onFlush(chunkMeta);\n  };\n\n  _proto.onWorkerMessage = function onWorkerMessage(ev) {\n    var data = ev.data;\n    var hls = this.hls;\n\n    switch (data.event) {\n      case 'init':\n        {\n          // revoke the Object URL that was used to create transmuxer worker, so as not to leak it\n          self.URL.revokeObjectURL(this.worker.objectURL);\n          break;\n        }\n\n      case 'transmuxComplete':\n        {\n          this.handleTransmuxComplete(data.data);\n          break;\n        }\n\n      case 'flush':\n        {\n          this.onFlush(data.data);\n          break;\n        }\n\n      /* falls through */\n\n      default:\n        {\n          data.data = data.data || {};\n          data.data.frag = this.frag;\n          data.data.id = this.id;\n          hls.trigger(data.event, data.data);\n          break;\n        }\n    }\n  };\n\n  _proto.configureTransmuxer = function configureTransmuxer(config) {\n    var worker = this.worker,\n        transmuxer = this.transmuxer;\n\n    if (worker) {\n      worker.postMessage({\n        cmd: 'configure',\n        config: config\n      });\n    } else if (transmuxer) {\n      transmuxer.configure(config);\n    }\n  };\n\n  _proto.handleTransmuxComplete = function handleTransmuxComplete(result) {\n    result.chunkMeta.transmuxing.end = self.performance.now();\n    this.onTransmuxComplete(result);\n  };\n\n  return TransmuxerInterface;\n}();\n\n\n\n/***/ }),\n\n/***/ \"./src/demux/transmuxer-worker.ts\":\n/*!****************************************!*\\\n  !*** ./src/demux/transmuxer-worker.ts ***!\n  \\****************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_562108__) {\n\n\"use strict\";\n__nested_webpack_require_562108__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_562108__.d(__webpack_exports__, \"default\", function() { return TransmuxerWorker; });\n/* harmony import */ var _demux_transmuxer__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_562108__(/*! ../demux/transmuxer */ \"./src/demux/transmuxer.ts\");\n/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_562108__(/*! ../events */ \"./src/events.ts\");\n/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_562108__(/*! ../utils/logger */ \"./src/utils/logger.ts\");\n/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_562108__(/*! eventemitter3 */ \"./node_modules/eventemitter3/index.js\");\n/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__nested_webpack_require_562108__.n(eventemitter3__WEBPACK_IMPORTED_MODULE_3__);\n\n\n\n\nfunction TransmuxerWorker(self) {\n  var observer = new eventemitter3__WEBPACK_IMPORTED_MODULE_3__[\"EventEmitter\"]();\n\n  var forwardMessage = function forwardMessage(ev, data) {\n    self.postMessage({\n      event: ev,\n      data: data\n    });\n  }; // forward events to main thread\n\n\n  observer.on(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].FRAG_DECRYPTED, forwardMessage);\n  observer.on(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].ERROR, forwardMessage);\n  self.addEventListener('message', function (ev) {\n    var data = ev.data;\n\n    switch (data.cmd) {\n      case 'init':\n        {\n          var config = JSON.parse(data.config);\n          self.transmuxer = new _demux_transmuxer__WEBPACK_IMPORTED_MODULE_0__[\"default\"](observer, data.typeSupported, config, data.vendor, data.id);\n          Object(_utils_logger__WEBPACK_IMPORTED_MODULE_2__[\"enableLogs\"])(config.debug);\n          forwardMessage('init', null);\n          break;\n        }\n\n      case 'configure':\n        {\n          self.transmuxer.configure(data.config);\n          break;\n        }\n\n      case 'demux':\n        {\n          var transmuxResult = self.transmuxer.push(data.data, data.decryptdata, data.chunkMeta, data.state);\n\n          if (Object(_demux_transmuxer__WEBPACK_IMPORTED_MODULE_0__[\"isPromise\"])(transmuxResult)) {\n            transmuxResult.then(function (data) {\n              emitTransmuxComplete(self, data);\n            });\n          } else {\n            emitTransmuxComplete(self, transmuxResult);\n          }\n\n          break;\n        }\n\n      case 'flush':\n        {\n          var id = data.chunkMeta;\n\n          var _transmuxResult = self.transmuxer.flush(id);\n\n          if (Object(_demux_transmuxer__WEBPACK_IMPORTED_MODULE_0__[\"isPromise\"])(_transmuxResult)) {\n            _transmuxResult.then(function (results) {\n              handleFlushResult(self, results, id);\n            });\n          } else {\n            handleFlushResult(self, _transmuxResult, id);\n          }\n\n          break;\n        }\n\n      default:\n        break;\n    }\n  });\n}\n\nfunction emitTransmuxComplete(self, transmuxResult) {\n  if (isEmptyResult(transmuxResult.remuxResult)) {\n    return;\n  }\n\n  var transferable = [];\n  var _transmuxResult$remux = transmuxResult.remuxResult,\n      audio = _transmuxResult$remux.audio,\n      video = _transmuxResult$remux.video;\n\n  if (audio) {\n    addToTransferable(transferable, audio);\n  }\n\n  if (video) {\n    addToTransferable(transferable, video);\n  }\n\n  self.postMessage({\n    event: 'transmuxComplete',\n    data: transmuxResult\n  }, transferable);\n} // Converts data to a transferable object https://developers.google.com/web/updates/2011/12/Transferable-Objects-Lightning-Fast)\n// in order to minimize message passing overhead\n\n\nfunction addToTransferable(transferable, track) {\n  if (track.data1) {\n    transferable.push(track.data1.buffer);\n  }\n\n  if (track.data2) {\n    transferable.push(track.data2.buffer);\n  }\n}\n\nfunction handleFlushResult(self, results, chunkMeta) {\n  results.forEach(function (result) {\n    emitTransmuxComplete(self, result);\n  });\n  self.postMessage({\n    event: 'flush',\n    data: chunkMeta\n  });\n}\n\nfunction isEmptyResult(remuxResult) {\n  return !remuxResult.audio && !remuxResult.video && !remuxResult.text && !remuxResult.id3 && !remuxResult.initSegment;\n}\n\n/***/ }),\n\n/***/ \"./src/demux/transmuxer.ts\":\n/*!*********************************!*\\\n  !*** ./src/demux/transmuxer.ts ***!\n  \\*********************************/\n/*! exports provided: default, isPromise, TransmuxConfig, TransmuxState */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_566628__) {\n\n\"use strict\";\n__nested_webpack_require_566628__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_566628__.d(__webpack_exports__, \"default\", function() { return Transmuxer; });\n/* harmony export (binding) */ __nested_webpack_require_566628__.d(__webpack_exports__, \"isPromise\", function() { return isPromise; });\n/* harmony export (binding) */ __nested_webpack_require_566628__.d(__webpack_exports__, \"TransmuxConfig\", function() { return TransmuxConfig; });\n/* harmony export (binding) */ __nested_webpack_require_566628__.d(__webpack_exports__, \"TransmuxState\", function() { return TransmuxState; });\n/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_566628__(/*! ../events */ \"./src/events.ts\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_566628__(/*! ../errors */ \"./src/errors.ts\");\n/* harmony import */ var _crypt_decrypter__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_566628__(/*! ../crypt/decrypter */ \"./src/crypt/decrypter.ts\");\n/* harmony import */ var _demux_aacdemuxer__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_566628__(/*! ../demux/aacdemuxer */ \"./src/demux/aacdemuxer.ts\");\n/* harmony import */ var _demux_mp4demuxer__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_566628__(/*! ../demux/mp4demuxer */ \"./src/demux/mp4demuxer.ts\");\n/* harmony import */ var _demux_tsdemuxer__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_566628__(/*! ../demux/tsdemuxer */ \"./src/demux/tsdemuxer.ts\");\n/* harmony import */ var _demux_mp3demuxer__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_566628__(/*! ../demux/mp3demuxer */ \"./src/demux/mp3demuxer.ts\");\n/* harmony import */ var _remux_mp4_remuxer__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_566628__(/*! ../remux/mp4-remuxer */ \"./src/remux/mp4-remuxer.ts\");\n/* harmony import */ var _remux_passthrough_remuxer__WEBPACK_IMPORTED_MODULE_8__ = __nested_webpack_require_566628__(/*! ../remux/passthrough-remuxer */ \"./src/remux/passthrough-remuxer.ts\");\n/* harmony import */ var _chunk_cache__WEBPACK_IMPORTED_MODULE_9__ = __nested_webpack_require_566628__(/*! ./chunk-cache */ \"./src/demux/chunk-cache.ts\");\n/* harmony import */ var _utils_mp4_tools__WEBPACK_IMPORTED_MODULE_10__ = __nested_webpack_require_566628__(/*! ../utils/mp4-tools */ \"./src/utils/mp4-tools.ts\");\n/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_11__ = __nested_webpack_require_566628__(/*! ../utils/logger */ \"./src/utils/logger.ts\");\n\n\n\n\n\n\n\n\n\n\n\n\nvar now; // performance.now() not available on WebWorker, at least on Safari Desktop\n\ntry {\n  now = self.performance.now.bind(self.performance);\n} catch (err) {\n  _utils_logger__WEBPACK_IMPORTED_MODULE_11__[\"logger\"].debug('Unable to use Performance API on this environment');\n  now = self.Date.now;\n}\n\nvar muxConfig = [{\n  demux: _demux_tsdemuxer__WEBPACK_IMPORTED_MODULE_5__[\"default\"],\n  remux: _remux_mp4_remuxer__WEBPACK_IMPORTED_MODULE_7__[\"default\"]\n}, {\n  demux: _demux_mp4demuxer__WEBPACK_IMPORTED_MODULE_4__[\"default\"],\n  remux: _remux_passthrough_remuxer__WEBPACK_IMPORTED_MODULE_8__[\"default\"]\n}, {\n  demux: _demux_aacdemuxer__WEBPACK_IMPORTED_MODULE_3__[\"default\"],\n  remux: _remux_mp4_remuxer__WEBPACK_IMPORTED_MODULE_7__[\"default\"]\n}, {\n  demux: _demux_mp3demuxer__WEBPACK_IMPORTED_MODULE_6__[\"default\"],\n  remux: _remux_mp4_remuxer__WEBPACK_IMPORTED_MODULE_7__[\"default\"]\n}];\nvar minProbeByteLength = 1024;\nmuxConfig.forEach(function (_ref) {\n  var demux = _ref.demux;\n  minProbeByteLength = Math.max(minProbeByteLength, demux.minProbeByteLength);\n});\n\nvar Transmuxer = /*#__PURE__*/function () {\n  function Transmuxer(observer, typeSupported, config, vendor, id) {\n    this.observer = void 0;\n    this.typeSupported = void 0;\n    this.config = void 0;\n    this.vendor = void 0;\n    this.id = void 0;\n    this.demuxer = void 0;\n    this.remuxer = void 0;\n    this.decrypter = void 0;\n    this.probe = void 0;\n    this.decryptionPromise = null;\n    this.transmuxConfig = void 0;\n    this.currentTransmuxState = void 0;\n    this.cache = new _chunk_cache__WEBPACK_IMPORTED_MODULE_9__[\"default\"]();\n    this.observer = observer;\n    this.typeSupported = typeSupported;\n    this.config = config;\n    this.vendor = vendor;\n    this.id = id;\n  }\n\n  var _proto = Transmuxer.prototype;\n\n  _proto.configure = function configure(transmuxConfig) {\n    this.transmuxConfig = transmuxConfig;\n\n    if (this.decrypter) {\n      this.decrypter.reset();\n    }\n  };\n\n  _proto.push = function push(data, decryptdata, chunkMeta, state) {\n    var _this = this;\n\n    var stats = chunkMeta.transmuxing;\n    stats.executeStart = now();\n    var uintData = new Uint8Array(data);\n    var cache = this.cache,\n        config = this.config,\n        currentTransmuxState = this.currentTransmuxState,\n        transmuxConfig = this.transmuxConfig;\n\n    if (state) {\n      this.currentTransmuxState = state;\n    }\n\n    var keyData = getEncryptionType(uintData, decryptdata);\n\n    if (keyData && keyData.method === 'AES-128') {\n      var decrypter = this.getDecrypter(); // Software decryption is synchronous; webCrypto is not\n\n      if (config.enableSoftwareAES) {\n        // Software decryption is progressive. Progressive decryption may not return a result on each call. Any cached\n        // data is handled in the flush() call\n        var decryptedData = decrypter.softwareDecrypt(uintData, keyData.key.buffer, keyData.iv.buffer);\n\n        if (!decryptedData) {\n          stats.executeEnd = now();\n          return emptyResult(chunkMeta);\n        }\n\n        uintData = new Uint8Array(decryptedData);\n      } else {\n        this.decryptionPromise = decrypter.webCryptoDecrypt(uintData, keyData.key.buffer, keyData.iv.buffer).then(function (decryptedData) {\n          // Calling push here is important; if flush() is called while this is still resolving, this ensures that\n          // the decrypted data has been transmuxed\n          var result = _this.push(decryptedData, null, chunkMeta);\n\n          _this.decryptionPromise = null;\n          return result;\n        });\n        return this.decryptionPromise;\n      }\n    }\n\n    var _ref2 = state || currentTransmuxState,\n        contiguous = _ref2.contiguous,\n        discontinuity = _ref2.discontinuity,\n        trackSwitch = _ref2.trackSwitch,\n        accurateTimeOffset = _ref2.accurateTimeOffset,\n        timeOffset = _ref2.timeOffset,\n        initSegmentChange = _ref2.initSegmentChange;\n\n    var audioCodec = transmuxConfig.audioCodec,\n        videoCodec = transmuxConfig.videoCodec,\n        defaultInitPts = transmuxConfig.defaultInitPts,\n        duration = transmuxConfig.duration,\n        initSegmentData = transmuxConfig.initSegmentData; // Reset muxers before probing to ensure that their state is clean, even if flushing occurs before a successful probe\n\n    if (discontinuity || trackSwitch || initSegmentChange) {\n      this.resetInitSegment(initSegmentData, audioCodec, videoCodec, duration);\n    }\n\n    if (discontinuity || initSegmentChange) {\n      this.resetInitialTimestamp(defaultInitPts);\n    }\n\n    if (!contiguous) {\n      this.resetContiguity();\n    }\n\n    if (this.needsProbing(uintData, discontinuity, trackSwitch)) {\n      if (cache.dataLength) {\n        var cachedData = cache.flush();\n        uintData = Object(_utils_mp4_tools__WEBPACK_IMPORTED_MODULE_10__[\"appendUint8Array\"])(cachedData, uintData);\n      }\n\n      this.configureTransmuxer(uintData, transmuxConfig);\n    }\n\n    var result = this.transmux(uintData, keyData, timeOffset, accurateTimeOffset, chunkMeta);\n    var currentState = this.currentTransmuxState;\n    currentState.contiguous = true;\n    currentState.discontinuity = false;\n    currentState.trackSwitch = false;\n    stats.executeEnd = now();\n    return result;\n  } // Due to data caching, flush calls can produce more than one TransmuxerResult (hence the Array type)\n  ;\n\n  _proto.flush = function flush(chunkMeta) {\n    var _this2 = this;\n\n    var stats = chunkMeta.transmuxing;\n    stats.executeStart = now();\n    var decrypter = this.decrypter,\n        cache = this.cache,\n        currentTransmuxState = this.currentTransmuxState,\n        decryptionPromise = this.decryptionPromise;\n\n    if (decryptionPromise) {\n      // Upon resolution, the decryption promise calls push() and returns its TransmuxerResult up the stack. Therefore\n      // only flushing is required for async decryption\n      return decryptionPromise.then(function () {\n        return _this2.flush(chunkMeta);\n      });\n    }\n\n    var transmuxResults = [];\n    var timeOffset = currentTransmuxState.timeOffset;\n\n    if (decrypter) {\n      // The decrypter may have data cached, which needs to be demuxed. In this case we'll have two TransmuxResults\n      // This happens in the case that we receive only 1 push call for a segment (either for non-progressive downloads,\n      // or for progressive downloads with small segments)\n      var decryptedData = decrypter.flush();\n\n      if (decryptedData) {\n        // Push always returns a TransmuxerResult if decryptdata is null\n        transmuxResults.push(this.push(decryptedData, null, chunkMeta));\n      }\n    }\n\n    var bytesSeen = cache.dataLength;\n    cache.reset();\n    var demuxer = this.demuxer,\n        remuxer = this.remuxer;\n\n    if (!demuxer || !remuxer) {\n      // If probing failed, and each demuxer saw enough bytes to be able to probe, then Hls.js has been given content its not able to handle\n      if (bytesSeen >= minProbeByteLength) {\n        this.observer.emit(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].ERROR, _events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].ERROR, {\n          type: _errors__WEBPACK_IMPORTED_MODULE_1__[\"ErrorTypes\"].MEDIA_ERROR,\n          details: _errors__WEBPACK_IMPORTED_MODULE_1__[\"ErrorDetails\"].FRAG_PARSING_ERROR,\n          fatal: true,\n          reason: 'no demux matching with content found'\n        });\n      }\n\n      stats.executeEnd = now();\n      return [emptyResult(chunkMeta)];\n    }\n\n    var demuxResultOrPromise = demuxer.flush(timeOffset);\n\n    if (isPromise(demuxResultOrPromise)) {\n      // Decrypt final SAMPLE-AES samples\n      return demuxResultOrPromise.then(function (demuxResult) {\n        _this2.flushRemux(transmuxResults, demuxResult, chunkMeta);\n\n        return transmuxResults;\n      });\n    }\n\n    this.flushRemux(transmuxResults, demuxResultOrPromise, chunkMeta);\n    return transmuxResults;\n  };\n\n  _proto.flushRemux = function flushRemux(transmuxResults, demuxResult, chunkMeta) {\n    var audioTrack = demuxResult.audioTrack,\n        avcTrack = demuxResult.avcTrack,\n        id3Track = demuxResult.id3Track,\n        textTrack = demuxResult.textTrack;\n    var _this$currentTransmux = this.currentTransmuxState,\n        accurateTimeOffset = _this$currentTransmux.accurateTimeOffset,\n        timeOffset = _this$currentTransmux.timeOffset;\n    _utils_logger__WEBPACK_IMPORTED_MODULE_11__[\"logger\"].log(\"[transmuxer.ts]: Flushed fragment \" + chunkMeta.sn + (chunkMeta.part > -1 ? ' p: ' + chunkMeta.part : '') + \" of level \" + chunkMeta.level);\n    var remuxResult = this.remuxer.remux(audioTrack, avcTrack, id3Track, textTrack, timeOffset, accurateTimeOffset, true, this.id);\n    transmuxResults.push({\n      remuxResult: remuxResult,\n      chunkMeta: chunkMeta\n    });\n    chunkMeta.transmuxing.executeEnd = now();\n  };\n\n  _proto.resetInitialTimestamp = function resetInitialTimestamp(defaultInitPts) {\n    var demuxer = this.demuxer,\n        remuxer = this.remuxer;\n\n    if (!demuxer || !remuxer) {\n      return;\n    }\n\n    demuxer.resetTimeStamp(defaultInitPts);\n    remuxer.resetTimeStamp(defaultInitPts);\n  };\n\n  _proto.resetContiguity = function resetContiguity() {\n    var demuxer = this.demuxer,\n        remuxer = this.remuxer;\n\n    if (!demuxer || !remuxer) {\n      return;\n    }\n\n    demuxer.resetContiguity();\n    remuxer.resetNextTimestamp();\n  };\n\n  _proto.resetInitSegment = function resetInitSegment(initSegmentData, audioCodec, videoCodec, duration) {\n    var demuxer = this.demuxer,\n        remuxer = this.remuxer;\n\n    if (!demuxer || !remuxer) {\n      return;\n    }\n\n    demuxer.resetInitSegment(audioCodec, videoCodec, duration);\n    remuxer.resetInitSegment(initSegmentData, audioCodec, videoCodec);\n  };\n\n  _proto.destroy = function destroy() {\n    if (this.demuxer) {\n      this.demuxer.destroy();\n      this.demuxer = undefined;\n    }\n\n    if (this.remuxer) {\n      this.remuxer.destroy();\n      this.remuxer = undefined;\n    }\n  };\n\n  _proto.transmux = function transmux(data, keyData, timeOffset, accurateTimeOffset, chunkMeta) {\n    var result;\n\n    if (keyData && keyData.method === 'SAMPLE-AES') {\n      result = this.transmuxSampleAes(data, keyData, timeOffset, accurateTimeOffset, chunkMeta);\n    } else {\n      result = this.transmuxUnencrypted(data, timeOffset, accurateTimeOffset, chunkMeta);\n    }\n\n    return result;\n  };\n\n  _proto.transmuxUnencrypted = function transmuxUnencrypted(data, timeOffset, accurateTimeOffset, chunkMeta) {\n    var _demux = this.demuxer.demux(data, timeOffset, false, !this.config.progressive),\n        audioTrack = _demux.audioTrack,\n        avcTrack = _demux.avcTrack,\n        id3Track = _demux.id3Track,\n        textTrack = _demux.textTrack;\n\n    var remuxResult = this.remuxer.remux(audioTrack, avcTrack, id3Track, textTrack, timeOffset, accurateTimeOffset, false, this.id);\n    return {\n      remuxResult: remuxResult,\n      chunkMeta: chunkMeta\n    };\n  };\n\n  _proto.transmuxSampleAes = function transmuxSampleAes(data, decryptData, timeOffset, accurateTimeOffset, chunkMeta) {\n    var _this3 = this;\n\n    return this.demuxer.demuxSampleAes(data, decryptData, timeOffset).then(function (demuxResult) {\n      var remuxResult = _this3.remuxer.remux(demuxResult.audioTrack, demuxResult.avcTrack, demuxResult.id3Track, demuxResult.textTrack, timeOffset, accurateTimeOffset, false, _this3.id);\n\n      return {\n        remuxResult: remuxResult,\n        chunkMeta: chunkMeta\n      };\n    });\n  };\n\n  _proto.configureTransmuxer = function configureTransmuxer(data, transmuxConfig) {\n    var config = this.config,\n        observer = this.observer,\n        typeSupported = this.typeSupported,\n        vendor = this.vendor;\n    var audioCodec = transmuxConfig.audioCodec,\n        defaultInitPts = transmuxConfig.defaultInitPts,\n        duration = transmuxConfig.duration,\n        initSegmentData = transmuxConfig.initSegmentData,\n        videoCodec = transmuxConfig.videoCodec; // probe for content type\n\n    var mux;\n\n    for (var i = 0, len = muxConfig.length; i < len; i++) {\n      if (muxConfig[i].demux.probe(data)) {\n        mux = muxConfig[i];\n        break;\n      }\n    }\n\n    if (!mux) {\n      // If probing previous configs fail, use mp4 passthrough\n      _utils_logger__WEBPACK_IMPORTED_MODULE_11__[\"logger\"].warn('Failed to find demuxer by probing frag, treating as mp4 passthrough');\n      mux = {\n        demux: _demux_mp4demuxer__WEBPACK_IMPORTED_MODULE_4__[\"default\"],\n        remux: _remux_passthrough_remuxer__WEBPACK_IMPORTED_MODULE_8__[\"default\"]\n      };\n    } // so let's check that current remuxer and demuxer are still valid\n\n\n    var demuxer = this.demuxer;\n    var remuxer = this.remuxer;\n    var Remuxer = mux.remux;\n    var Demuxer = mux.demux;\n\n    if (!remuxer || !(remuxer instanceof Remuxer)) {\n      this.remuxer = new Remuxer(observer, config, typeSupported, vendor);\n    }\n\n    if (!demuxer || !(demuxer instanceof Demuxer)) {\n      this.demuxer = new Demuxer(observer, config, typeSupported);\n      this.probe = Demuxer.probe;\n    } // Ensure that muxers are always initialized with an initSegment\n\n\n    this.resetInitSegment(initSegmentData, audioCodec, videoCodec, duration);\n    this.resetInitialTimestamp(defaultInitPts);\n  };\n\n  _proto.needsProbing = function needsProbing(data, discontinuity, trackSwitch) {\n    // in case of continuity change, or track switch\n    // we might switch from content type (AAC container to TS container, or TS to fmp4 for example)\n    return !this.demuxer || !this.remuxer || discontinuity || trackSwitch;\n  };\n\n  _proto.getDecrypter = function getDecrypter() {\n    var decrypter = this.decrypter;\n\n    if (!decrypter) {\n      decrypter = this.decrypter = new _crypt_decrypter__WEBPACK_IMPORTED_MODULE_2__[\"default\"](this.observer, this.config);\n    }\n\n    return decrypter;\n  };\n\n  return Transmuxer;\n}();\n\n\n\nfunction getEncryptionType(data, decryptData) {\n  var encryptionType = null;\n\n  if (data.byteLength > 0 && decryptData != null && decryptData.key != null && decryptData.iv !== null && decryptData.method != null) {\n    encryptionType = decryptData;\n  }\n\n  return encryptionType;\n}\n\nvar emptyResult = function emptyResult(chunkMeta) {\n  return {\n    remuxResult: {},\n    chunkMeta: chunkMeta\n  };\n};\n\nfunction isPromise(p) {\n  return 'then' in p && p.then instanceof Function;\n}\nvar TransmuxConfig = function TransmuxConfig(audioCodec, videoCodec, initSegmentData, duration, defaultInitPts) {\n  this.audioCodec = void 0;\n  this.videoCodec = void 0;\n  this.initSegmentData = void 0;\n  this.duration = void 0;\n  this.defaultInitPts = void 0;\n  this.audioCodec = audioCodec;\n  this.videoCodec = videoCodec;\n  this.initSegmentData = initSegmentData;\n  this.duration = duration;\n  this.defaultInitPts = defaultInitPts;\n};\nvar TransmuxState = function TransmuxState(discontinuity, contiguous, accurateTimeOffset, trackSwitch, timeOffset, initSegmentChange) {\n  this.discontinuity = void 0;\n  this.contiguous = void 0;\n  this.accurateTimeOffset = void 0;\n  this.trackSwitch = void 0;\n  this.timeOffset = void 0;\n  this.initSegmentChange = void 0;\n  this.discontinuity = discontinuity;\n  this.contiguous = contiguous;\n  this.accurateTimeOffset = accurateTimeOffset;\n  this.trackSwitch = trackSwitch;\n  this.timeOffset = timeOffset;\n  this.initSegmentChange = initSegmentChange;\n};\n\n/***/ }),\n\n/***/ \"./src/demux/tsdemuxer.ts\":\n/*!********************************!*\\\n  !*** ./src/demux/tsdemuxer.ts ***!\n  \\********************************/\n/*! exports provided: discardEPB, default */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_584518__) {\n\n\"use strict\";\n__nested_webpack_require_584518__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_584518__.d(__webpack_exports__, \"discardEPB\", function() { return discardEPB; });\n/* harmony import */ var _adts__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_584518__(/*! ./adts */ \"./src/demux/adts.ts\");\n/* harmony import */ var _mpegaudio__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_584518__(/*! ./mpegaudio */ \"./src/demux/mpegaudio.ts\");\n/* harmony import */ var _exp_golomb__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_584518__(/*! ./exp-golomb */ \"./src/demux/exp-golomb.ts\");\n/* harmony import */ var _id3__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_584518__(/*! ./id3 */ \"./src/demux/id3.ts\");\n/* harmony import */ var _sample_aes__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_584518__(/*! ./sample-aes */ \"./src/demux/sample-aes.ts\");\n/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_584518__(/*! ../events */ \"./src/events.ts\");\n/* harmony import */ var _utils_mp4_tools__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_584518__(/*! ../utils/mp4-tools */ \"./src/utils/mp4-tools.ts\");\n/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_584518__(/*! ../utils/logger */ \"./src/utils/logger.ts\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_8__ = __nested_webpack_require_584518__(/*! ../errors */ \"./src/errors.ts\");\n/**\n * highly optimized TS demuxer:\n * parse PAT, PMT\n * extract PES packet from audio and video PIDs\n * extract AVC/H264 NAL units and AAC/ADTS samples from PES packet\n * trigger the remuxer upon parsing completion\n * it also tries to workaround as best as it can audio codec switch (HE-AAC to AAC and vice versa), without having to restart the MediaSource.\n * it also controls the remuxing process :\n * upon discontinuity or level switch detection, it will also notifies the remuxer so that it can reset its state.\n */\n\n\n\n\n\n\n\n\n\n// We are using fixed track IDs for driving the MP4 remuxer\n// instead of following the TS PIDs.\n// There is no reason not to do this and some browsers/SourceBuffer-demuxers\n// may not like if there are TrackID \"switches\"\n// See https://github.com/video-dev/hls.js/issues/1331\n// Here we are mapping our internal track types to constant MP4 track IDs\n// With MSE currently one can only have one track of each, and we are muxing\n// whatever video/audio rendition in them.\nvar RemuxerTrackIdConfig = {\n  video: 1,\n  audio: 2,\n  id3: 3,\n  text: 4\n};\n\nvar TSDemuxer = /*#__PURE__*/function () {\n  function TSDemuxer(observer, config, typeSupported) {\n    this.observer = void 0;\n    this.config = void 0;\n    this.typeSupported = void 0;\n    this.sampleAes = null;\n    this.pmtParsed = false;\n    this.audioCodec = void 0;\n    this.videoCodec = void 0;\n    this._duration = 0;\n    this.aacLastPTS = null;\n    this._initPTS = null;\n    this._initDTS = null;\n    this._pmtId = -1;\n    this._avcTrack = void 0;\n    this._audioTrack = void 0;\n    this._id3Track = void 0;\n    this._txtTrack = void 0;\n    this.aacOverFlow = null;\n    this.avcSample = null;\n    this.remainderData = null;\n    this.observer = observer;\n    this.config = config;\n    this.typeSupported = typeSupported;\n  }\n\n  TSDemuxer.probe = function probe(data) {\n    var syncOffset = TSDemuxer.syncOffset(data);\n\n    if (syncOffset < 0) {\n      return false;\n    } else {\n      if (syncOffset) {\n        _utils_logger__WEBPACK_IMPORTED_MODULE_7__[\"logger\"].warn(\"MPEG2-TS detected but first sync word found @ offset \" + syncOffset + \", junk ahead ?\");\n      }\n\n      return true;\n    }\n  };\n\n  TSDemuxer.syncOffset = function syncOffset(data) {\n    // scan 1000 first bytes\n    var scanwindow = Math.min(1000, data.length - 3 * 188);\n    var i = 0;\n\n    while (i < scanwindow) {\n      // a TS fragment should contain at least 3 TS packets, a PAT, a PMT, and one PID, each starting with 0x47\n      if (data[i] === 0x47 && data[i + 188] === 0x47 && data[i + 2 * 188] === 0x47) {\n        return i;\n      } else {\n        i++;\n      }\n    }\n\n    return -1;\n  }\n  /**\n   * Creates a track model internal to demuxer used to drive remuxing input\n   *\n   * @param type 'audio' | 'video' | 'id3' | 'text'\n   * @param duration\n   * @return TSDemuxer's internal track model\n   */\n  ;\n\n  TSDemuxer.createTrack = function createTrack(type, duration) {\n    return {\n      container: type === 'video' || type === 'audio' ? 'video/mp2t' : undefined,\n      type: type,\n      id: RemuxerTrackIdConfig[type],\n      pid: -1,\n      inputTimeScale: 90000,\n      sequenceNumber: 0,\n      samples: [],\n      dropped: 0,\n      duration: type === 'audio' ? duration : undefined\n    };\n  }\n  /**\n   * Initializes a new init segment on the demuxer/remuxer interface. Needed for discontinuities/track-switches (or at stream start)\n   * Resets all internal track instances of the demuxer.\n   */\n  ;\n\n  var _proto = TSDemuxer.prototype;\n\n  _proto.resetInitSegment = function resetInitSegment(audioCodec, videoCodec, duration) {\n    this.pmtParsed = false;\n    this._pmtId = -1;\n    this._avcTrack = TSDemuxer.createTrack('video', duration);\n    this._audioTrack = TSDemuxer.createTrack('audio', duration);\n    this._id3Track = TSDemuxer.createTrack('id3', duration);\n    this._txtTrack = TSDemuxer.createTrack('text', duration);\n    this._audioTrack.isAAC = true; // flush any partial content\n\n    this.aacOverFlow = null;\n    this.aacLastPTS = null;\n    this.avcSample = null;\n    this.audioCodec = audioCodec;\n    this.videoCodec = videoCodec;\n    this._duration = duration;\n  };\n\n  _proto.resetTimeStamp = function resetTimeStamp() {};\n\n  _proto.resetContiguity = function resetContiguity() {\n    var _audioTrack = this._audioTrack,\n        _avcTrack = this._avcTrack,\n        _id3Track = this._id3Track;\n\n    if (_audioTrack) {\n      _audioTrack.pesData = null;\n    }\n\n    if (_avcTrack) {\n      _avcTrack.pesData = null;\n    }\n\n    if (_id3Track) {\n      _id3Track.pesData = null;\n    }\n\n    this.aacOverFlow = null;\n    this.aacLastPTS = null;\n  };\n\n  _proto.demux = function demux(data, timeOffset, isSampleAes, flush) {\n    if (isSampleAes === void 0) {\n      isSampleAes = false;\n    }\n\n    if (flush === void 0) {\n      flush = false;\n    }\n\n    if (!isSampleAes) {\n      this.sampleAes = null;\n    }\n\n    var pes;\n    var avcTrack = this._avcTrack;\n    var audioTrack = this._audioTrack;\n    var id3Track = this._id3Track;\n    var avcId = avcTrack.pid;\n    var avcData = avcTrack.pesData;\n    var audioId = audioTrack.pid;\n    var id3Id = id3Track.pid;\n    var audioData = audioTrack.pesData;\n    var id3Data = id3Track.pesData;\n    var unknownPIDs = false;\n    var pmtParsed = this.pmtParsed;\n    var pmtId = this._pmtId;\n    var len = data.length;\n\n    if (this.remainderData) {\n      data = Object(_utils_mp4_tools__WEBPACK_IMPORTED_MODULE_6__[\"appendUint8Array\"])(this.remainderData, data);\n      len = data.length;\n      this.remainderData = null;\n    }\n\n    if (len < 188 && !flush) {\n      this.remainderData = data;\n      return {\n        audioTrack: audioTrack,\n        avcTrack: avcTrack,\n        id3Track: id3Track,\n        textTrack: this._txtTrack\n      };\n    }\n\n    var syncOffset = Math.max(0, TSDemuxer.syncOffset(data));\n    len -= (len + syncOffset) % 188;\n\n    if (len < data.byteLength && !flush) {\n      this.remainderData = new Uint8Array(data.buffer, len, data.buffer.byteLength - len);\n    } // loop through TS packets\n\n\n    var tsPacketErrors = 0;\n\n    for (var start = syncOffset; start < len; start += 188) {\n      if (data[start] === 0x47) {\n        var stt = !!(data[start + 1] & 0x40); // pid is a 13-bit field starting at the last bit of TS[1]\n\n        var pid = ((data[start + 1] & 0x1f) << 8) + data[start + 2];\n        var atf = (data[start + 3] & 0x30) >> 4; // if an adaption field is present, its length is specified by the fifth byte of the TS packet header.\n\n        var offset = void 0;\n\n        if (atf > 1) {\n          offset = start + 5 + data[start + 4]; // continue if there is only adaptation field\n\n          if (offset === start + 188) {\n            continue;\n          }\n        } else {\n          offset = start + 4;\n        }\n\n        switch (pid) {\n          case avcId:\n            if (stt) {\n              if (avcData && (pes = parsePES(avcData))) {\n                this.parseAVCPES(pes, false);\n              }\n\n              avcData = {\n                data: [],\n                size: 0\n              };\n            }\n\n            if (avcData) {\n              avcData.data.push(data.subarray(offset, start + 188));\n              avcData.size += start + 188 - offset;\n            }\n\n            break;\n\n          case audioId:\n            if (stt) {\n              if (audioData && (pes = parsePES(audioData))) {\n                if (audioTrack.isAAC) {\n                  this.parseAACPES(pes);\n                } else {\n                  this.parseMPEGPES(pes);\n                }\n              }\n\n              audioData = {\n                data: [],\n                size: 0\n              };\n            }\n\n            if (audioData) {\n              audioData.data.push(data.subarray(offset, start + 188));\n              audioData.size += start + 188 - offset;\n            }\n\n            break;\n\n          case id3Id:\n            if (stt) {\n              if (id3Data && (pes = parsePES(id3Data))) {\n                this.parseID3PES(pes);\n              }\n\n              id3Data = {\n                data: [],\n                size: 0\n              };\n            }\n\n            if (id3Data) {\n              id3Data.data.push(data.subarray(offset, start + 188));\n              id3Data.size += start + 188 - offset;\n            }\n\n            break;\n\n          case 0:\n            if (stt) {\n              offset += data[offset] + 1;\n            }\n\n            pmtId = this._pmtId = parsePAT(data, offset);\n            break;\n\n          case pmtId:\n            {\n              if (stt) {\n                offset += data[offset] + 1;\n              }\n\n              var parsedPIDs = parsePMT(data, offset, this.typeSupported.mpeg === true || this.typeSupported.mp3 === true, isSampleAes); // only update track id if track PID found while parsing PMT\n              // this is to avoid resetting the PID to -1 in case\n              // track PID transiently disappears from the stream\n              // this could happen in case of transient missing audio samples for example\n              // NOTE this is only the PID of the track as found in TS,\n              // but we are not using this for MP4 track IDs.\n\n              avcId = parsedPIDs.avc;\n\n              if (avcId > 0) {\n                avcTrack.pid = avcId;\n              }\n\n              audioId = parsedPIDs.audio;\n\n              if (audioId > 0) {\n                audioTrack.pid = audioId;\n                audioTrack.isAAC = parsedPIDs.isAAC;\n              }\n\n              id3Id = parsedPIDs.id3;\n\n              if (id3Id > 0) {\n                id3Track.pid = id3Id;\n              }\n\n              if (unknownPIDs && !pmtParsed) {\n                _utils_logger__WEBPACK_IMPORTED_MODULE_7__[\"logger\"].log('reparse from beginning');\n                unknownPIDs = false; // we set it to -188, the += 188 in the for loop will reset start to 0\n\n                start = syncOffset - 188;\n              }\n\n              pmtParsed = this.pmtParsed = true;\n              break;\n            }\n\n          case 17:\n          case 0x1fff:\n            break;\n\n          default:\n            unknownPIDs = true;\n            break;\n        }\n      } else {\n        tsPacketErrors++;\n      }\n    }\n\n    if (tsPacketErrors > 0) {\n      this.observer.emit(_events__WEBPACK_IMPORTED_MODULE_5__[\"Events\"].ERROR, _events__WEBPACK_IMPORTED_MODULE_5__[\"Events\"].ERROR, {\n        type: _errors__WEBPACK_IMPORTED_MODULE_8__[\"ErrorTypes\"].MEDIA_ERROR,\n        details: _errors__WEBPACK_IMPORTED_MODULE_8__[\"ErrorDetails\"].FRAG_PARSING_ERROR,\n        fatal: false,\n        reason: \"Found \" + tsPacketErrors + \" TS packet/s that do not start with 0x47\"\n      });\n    }\n\n    avcTrack.pesData = avcData;\n    audioTrack.pesData = audioData;\n    id3Track.pesData = id3Data;\n    var demuxResult = {\n      audioTrack: audioTrack,\n      avcTrack: avcTrack,\n      id3Track: id3Track,\n      textTrack: this._txtTrack\n    };\n\n    if (flush) {\n      this.extractRemainingSamples(demuxResult);\n    }\n\n    return demuxResult;\n  };\n\n  _proto.flush = function flush() {\n    var remainderData = this.remainderData;\n    this.remainderData = null;\n    var result;\n\n    if (remainderData) {\n      result = this.demux(remainderData, -1, false, true);\n    } else {\n      result = {\n        audioTrack: this._audioTrack,\n        avcTrack: this._avcTrack,\n        textTrack: this._txtTrack,\n        id3Track: this._id3Track\n      };\n    }\n\n    this.extractRemainingSamples(result);\n\n    if (this.sampleAes) {\n      return this.decrypt(result, this.sampleAes);\n    }\n\n    return result;\n  };\n\n  _proto.extractRemainingSamples = function extractRemainingSamples(demuxResult) {\n    var audioTrack = demuxResult.audioTrack,\n        avcTrack = demuxResult.avcTrack,\n        id3Track = demuxResult.id3Track;\n    var avcData = avcTrack.pesData;\n    var audioData = audioTrack.pesData;\n    var id3Data = id3Track.pesData; // try to parse last PES packets\n\n    var pes;\n\n    if (avcData && (pes = parsePES(avcData))) {\n      this.parseAVCPES(pes, true);\n      avcTrack.pesData = null;\n    } else {\n      // either avcData null or PES truncated, keep it for next frag parsing\n      avcTrack.pesData = avcData;\n    }\n\n    if (audioData && (pes = parsePES(audioData))) {\n      if (audioTrack.isAAC) {\n        this.parseAACPES(pes);\n      } else {\n        this.parseMPEGPES(pes);\n      }\n\n      audioTrack.pesData = null;\n    } else {\n      if (audioData !== null && audioData !== void 0 && audioData.size) {\n        _utils_logger__WEBPACK_IMPORTED_MODULE_7__[\"logger\"].log('last AAC PES packet truncated,might overlap between fragments');\n      } // either audioData null or PES truncated, keep it for next frag parsing\n\n\n      audioTrack.pesData = audioData;\n    }\n\n    if (id3Data && (pes = parsePES(id3Data))) {\n      this.parseID3PES(pes);\n      id3Track.pesData = null;\n    } else {\n      // either id3Data null or PES truncated, keep it for next frag parsing\n      id3Track.pesData = id3Data;\n    }\n  };\n\n  _proto.demuxSampleAes = function demuxSampleAes(data, keyData, timeOffset) {\n    var demuxResult = this.demux(data, timeOffset, true, !this.config.progressive);\n    var sampleAes = this.sampleAes = new _sample_aes__WEBPACK_IMPORTED_MODULE_4__[\"default\"](this.observer, this.config, keyData);\n    return this.decrypt(demuxResult, sampleAes);\n  };\n\n  _proto.decrypt = function decrypt(demuxResult, sampleAes) {\n    return new Promise(function (resolve) {\n      var audioTrack = demuxResult.audioTrack,\n          avcTrack = demuxResult.avcTrack;\n\n      if (audioTrack.samples && audioTrack.isAAC) {\n        sampleAes.decryptAacSamples(audioTrack.samples, 0, function () {\n          if (avcTrack.samples) {\n            sampleAes.decryptAvcSamples(avcTrack.samples, 0, 0, function () {\n              resolve(demuxResult);\n            });\n          } else {\n            resolve(demuxResult);\n          }\n        });\n      } else if (avcTrack.samples) {\n        sampleAes.decryptAvcSamples(avcTrack.samples, 0, 0, function () {\n          resolve(demuxResult);\n        });\n      }\n    });\n  };\n\n  _proto.destroy = function destroy() {\n    this._initPTS = this._initDTS = null;\n    this._duration = 0;\n  };\n\n  _proto.parseAVCPES = function parseAVCPES(pes, last) {\n    var _this = this;\n\n    var track = this._avcTrack;\n    var units = this.parseAVCNALu(pes.data);\n    var debug = false;\n    var avcSample = this.avcSample;\n    var push;\n    var spsfound = false; // free pes.data to save up some memory\n\n    pes.data = null; // if new NAL units found and last sample still there, let's push ...\n    // this helps parsing streams with missing AUD (only do this if AUD never found)\n\n    if (avcSample && units.length && !track.audFound) {\n      pushAccessUnit(avcSample, track);\n      avcSample = this.avcSample = createAVCSample(false, pes.pts, pes.dts, '');\n    }\n\n    units.forEach(function (unit) {\n      switch (unit.type) {\n        // NDR\n        case 1:\n          {\n            push = true;\n\n            if (!avcSample) {\n              avcSample = _this.avcSample = createAVCSample(true, pes.pts, pes.dts, '');\n            }\n\n            if (debug) {\n              avcSample.debug += 'NDR ';\n            }\n\n            avcSample.frame = true;\n            var data = unit.data; // only check slice type to detect KF in case SPS found in same packet (any keyframe is preceded by SPS ...)\n\n            if (spsfound && data.length > 4) {\n              // retrieve slice type by parsing beginning of NAL unit (follow H264 spec, slice_header definition) to detect keyframe embedded in NDR\n              var sliceType = new _exp_golomb__WEBPACK_IMPORTED_MODULE_2__[\"default\"](data).readSliceType(); // 2 : I slice, 4 : SI slice, 7 : I slice, 9: SI slice\n              // SI slice : A slice that is coded using intra prediction only and using quantisation of the prediction samples.\n              // An SI slice can be coded such that its decoded samples can be constructed identically to an SP slice.\n              // I slice: A slice that is not an SI slice that is decoded using intra prediction only.\n              // if (sliceType === 2 || sliceType === 7) {\n\n              if (sliceType === 2 || sliceType === 4 || sliceType === 7 || sliceType === 9) {\n                avcSample.key = true;\n              }\n            }\n\n            break; // IDR\n          }\n\n        case 5:\n          push = true; // handle PES not starting with AUD\n\n          if (!avcSample) {\n            avcSample = _this.avcSample = createAVCSample(true, pes.pts, pes.dts, '');\n          }\n\n          if (debug) {\n            avcSample.debug += 'IDR ';\n          }\n\n          avcSample.key = true;\n          avcSample.frame = true;\n          break;\n        // SEI\n\n        case 6:\n          {\n            push = true;\n\n            if (debug && avcSample) {\n              avcSample.debug += 'SEI ';\n            }\n\n            var expGolombDecoder = new _exp_golomb__WEBPACK_IMPORTED_MODULE_2__[\"default\"](discardEPB(unit.data)); // skip frameType\n\n            expGolombDecoder.readUByte();\n            var payloadType = 0;\n            var payloadSize = 0;\n            var endOfCaptions = false;\n            var b = 0;\n\n            while (!endOfCaptions && expGolombDecoder.bytesAvailable > 1) {\n              payloadType = 0;\n\n              do {\n                b = expGolombDecoder.readUByte();\n                payloadType += b;\n              } while (b === 0xff); // Parse payload size.\n\n\n              payloadSize = 0;\n\n              do {\n                b = expGolombDecoder.readUByte();\n                payloadSize += b;\n              } while (b === 0xff); // TODO: there can be more than one payload in an SEI packet...\n              // TODO: need to read type and size in a while loop to get them all\n\n\n              if (payloadType === 4 && expGolombDecoder.bytesAvailable !== 0) {\n                endOfCaptions = true;\n                var countryCode = expGolombDecoder.readUByte();\n\n                if (countryCode === 181) {\n                  var providerCode = expGolombDecoder.readUShort();\n\n                  if (providerCode === 49) {\n                    var userStructure = expGolombDecoder.readUInt();\n\n                    if (userStructure === 0x47413934) {\n                      var userDataType = expGolombDecoder.readUByte(); // Raw CEA-608 bytes wrapped in CEA-708 packet\n\n                      if (userDataType === 3) {\n                        var firstByte = expGolombDecoder.readUByte();\n                        var secondByte = expGolombDecoder.readUByte();\n                        var totalCCs = 31 & firstByte;\n                        var byteArray = [firstByte, secondByte];\n\n                        for (var i = 0; i < totalCCs; i++) {\n                          // 3 bytes per CC\n                          byteArray.push(expGolombDecoder.readUByte());\n                          byteArray.push(expGolombDecoder.readUByte());\n                          byteArray.push(expGolombDecoder.readUByte());\n                        }\n\n                        insertSampleInOrder(_this._txtTrack.samples, {\n                          type: 3,\n                          pts: pes.pts,\n                          bytes: byteArray\n                        });\n                      }\n                    }\n                  }\n                }\n              } else if (payloadType === 5 && expGolombDecoder.bytesAvailable !== 0) {\n                endOfCaptions = true;\n\n                if (payloadSize > 16) {\n                  var uuidStrArray = [];\n\n                  for (var _i = 0; _i < 16; _i++) {\n                    uuidStrArray.push(expGolombDecoder.readUByte().toString(16));\n\n                    if (_i === 3 || _i === 5 || _i === 7 || _i === 9) {\n                      uuidStrArray.push('-');\n                    }\n                  }\n\n                  var length = payloadSize - 16;\n                  var userDataPayloadBytes = new Uint8Array(length);\n\n                  for (var _i2 = 0; _i2 < length; _i2++) {\n                    userDataPayloadBytes[_i2] = expGolombDecoder.readUByte();\n                  }\n\n                  insertSampleInOrder(_this._txtTrack.samples, {\n                    pts: pes.pts,\n                    payloadType: payloadType,\n                    uuid: uuidStrArray.join(''),\n                    userData: Object(_id3__WEBPACK_IMPORTED_MODULE_3__[\"utf8ArrayToStr\"])(userDataPayloadBytes),\n                    userDataBytes: userDataPayloadBytes\n                  });\n                }\n              } else if (payloadSize < expGolombDecoder.bytesAvailable) {\n                for (var _i3 = 0; _i3 < payloadSize; _i3++) {\n                  expGolombDecoder.readUByte();\n                }\n              }\n            }\n\n            break; // SPS\n          }\n\n        case 7:\n          push = true;\n          spsfound = true;\n\n          if (debug && avcSample) {\n            avcSample.debug += 'SPS ';\n          }\n\n          if (!track.sps) {\n            var _expGolombDecoder = new _exp_golomb__WEBPACK_IMPORTED_MODULE_2__[\"default\"](unit.data);\n\n            var config = _expGolombDecoder.readSPS();\n\n            track.width = config.width;\n            track.height = config.height;\n            track.pixelRatio = config.pixelRatio; // TODO: `track.sps` is defined as a `number[]`, but we're setting it to a `Uint8Array[]`.\n\n            track.sps = [unit.data];\n            track.duration = _this._duration;\n            var codecarray = unit.data.subarray(1, 4);\n            var codecstring = 'avc1.';\n\n            for (var _i4 = 0; _i4 < 3; _i4++) {\n              var h = codecarray[_i4].toString(16);\n\n              if (h.length < 2) {\n                h = '0' + h;\n              }\n\n              codecstring += h;\n            }\n\n            track.codec = codecstring;\n          }\n\n          break;\n        // PPS\n\n        case 8:\n          push = true;\n\n          if (debug && avcSample) {\n            avcSample.debug += 'PPS ';\n          }\n\n          if (!track.pps) {\n            // TODO: `track.pss` is defined as a `number[]`, but we're setting it to a `Uint8Array[]`.\n            track.pps = [unit.data];\n          }\n\n          break;\n        // AUD\n\n        case 9:\n          push = false;\n          track.audFound = true;\n\n          if (avcSample) {\n            pushAccessUnit(avcSample, track);\n          }\n\n          avcSample = _this.avcSample = createAVCSample(false, pes.pts, pes.dts, debug ? 'AUD ' : '');\n          break;\n        // Filler Data\n\n        case 12:\n          push = false;\n          break;\n\n        default:\n          push = false;\n\n          if (avcSample) {\n            avcSample.debug += 'unknown NAL ' + unit.type + ' ';\n          }\n\n          break;\n      }\n\n      if (avcSample && push) {\n        var _units = avcSample.units;\n\n        _units.push(unit);\n      }\n    }); // if last PES packet, push samples\n\n    if (last && avcSample) {\n      pushAccessUnit(avcSample, track);\n      this.avcSample = null;\n    }\n  };\n\n  _proto.getLastNalUnit = function getLastNalUnit() {\n    var _avcSample;\n\n    var avcSample = this.avcSample;\n    var lastUnit; // try to fallback to previous sample if current one is empty\n\n    if (!avcSample || avcSample.units.length === 0) {\n      var samples = this._avcTrack.samples;\n      avcSample = samples[samples.length - 1];\n    }\n\n    if ((_avcSample = avcSample) !== null && _avcSample !== void 0 && _avcSample.units) {\n      var units = avcSample.units;\n      lastUnit = units[units.length - 1];\n    }\n\n    return lastUnit;\n  };\n\n  _proto.parseAVCNALu = function parseAVCNALu(array) {\n    var len = array.byteLength;\n    var track = this._avcTrack;\n    var state = track.naluState || 0;\n    var lastState = state;\n    var units = [];\n    var i = 0;\n    var value;\n    var overflow;\n    var unitType;\n    var lastUnitStart = -1;\n    var lastUnitType = 0; // logger.log('PES:' + Hex.hexDump(array));\n\n    if (state === -1) {\n      // special use case where we found 3 or 4-byte start codes exactly at the end of previous PES packet\n      lastUnitStart = 0; // NALu type is value read from offset 0\n\n      lastUnitType = array[0] & 0x1f;\n      state = 0;\n      i = 1;\n    }\n\n    while (i < len) {\n      value = array[i++]; // optimization. state 0 and 1 are the predominant case. let's handle them outside of the switch/case\n\n      if (!state) {\n        state = value ? 0 : 1;\n        continue;\n      }\n\n      if (state === 1) {\n        state = value ? 0 : 2;\n        continue;\n      } // here we have state either equal to 2 or 3\n\n\n      if (!value) {\n        state = 3;\n      } else if (value === 1) {\n        if (lastUnitStart >= 0) {\n          var unit = {\n            data: array.subarray(lastUnitStart, i - state - 1),\n            type: lastUnitType\n          }; // logger.log('pushing NALU, type/size:' + unit.type + '/' + unit.data.byteLength);\n\n          units.push(unit);\n        } else {\n          // lastUnitStart is undefined => this is the first start code found in this PES packet\n          // first check if start code delimiter is overlapping between 2 PES packets,\n          // ie it started in last packet (lastState not zero)\n          // and ended at the beginning of this PES packet (i <= 4 - lastState)\n          var lastUnit = this.getLastNalUnit();\n\n          if (lastUnit) {\n            if (lastState && i <= 4 - lastState) {\n              // start delimiter overlapping between PES packets\n              // strip start delimiter bytes from the end of last NAL unit\n              // check if lastUnit had a state different from zero\n              if (lastUnit.state) {\n                // strip last bytes\n                lastUnit.data = lastUnit.data.subarray(0, lastUnit.data.byteLength - lastState);\n              }\n            } // If NAL units are not starting right at the beginning of the PES packet, push preceding data into previous NAL unit.\n\n\n            overflow = i - state - 1;\n\n            if (overflow > 0) {\n              // logger.log('first NALU found with overflow:' + overflow);\n              var tmp = new Uint8Array(lastUnit.data.byteLength + overflow);\n              tmp.set(lastUnit.data, 0);\n              tmp.set(array.subarray(0, overflow), lastUnit.data.byteLength);\n              lastUnit.data = tmp;\n              lastUnit.state = 0;\n            }\n          }\n        } // check if we can read unit type\n\n\n        if (i < len) {\n          unitType = array[i] & 0x1f; // logger.log('find NALU @ offset:' + i + ',type:' + unitType);\n\n          lastUnitStart = i;\n          lastUnitType = unitType;\n          state = 0;\n        } else {\n          // not enough byte to read unit type. let's read it on next PES parsing\n          state = -1;\n        }\n      } else {\n        state = 0;\n      }\n    }\n\n    if (lastUnitStart >= 0 && state >= 0) {\n      var _unit = {\n        data: array.subarray(lastUnitStart, len),\n        type: lastUnitType,\n        state: state\n      };\n      units.push(_unit); // logger.log('pushing NALU, type/size/state:' + unit.type + '/' + unit.data.byteLength + '/' + state);\n    } // no NALu found\n\n\n    if (units.length === 0) {\n      // append pes.data to previous NAL unit\n      var _lastUnit = this.getLastNalUnit();\n\n      if (_lastUnit) {\n        var _tmp = new Uint8Array(_lastUnit.data.byteLength + array.byteLength);\n\n        _tmp.set(_lastUnit.data, 0);\n\n        _tmp.set(array, _lastUnit.data.byteLength);\n\n        _lastUnit.data = _tmp;\n      }\n    }\n\n    track.naluState = state;\n    return units;\n  };\n\n  _proto.parseAACPES = function parseAACPES(pes) {\n    var startOffset = 0;\n    var track = this._audioTrack;\n    var aacOverFlow = this.aacOverFlow;\n    var data = pes.data;\n\n    if (aacOverFlow) {\n      this.aacOverFlow = null;\n      var sampleLength = aacOverFlow.sample.unit.byteLength;\n      var frameMissingBytes = Math.min(aacOverFlow.missing, sampleLength);\n      var frameOverflowBytes = sampleLength - frameMissingBytes;\n      aacOverFlow.sample.unit.set(data.subarray(0, frameMissingBytes), frameOverflowBytes);\n      track.samples.push(aacOverFlow.sample); // logger.log(`AAC: append overflowing ${frameOverflowBytes} bytes to beginning of new PES`);\n\n      startOffset = aacOverFlow.missing;\n    } // look for ADTS header (0xFFFx)\n\n\n    var offset;\n    var len;\n\n    for (offset = startOffset, len = data.length; offset < len - 1; offset++) {\n      if (_adts__WEBPACK_IMPORTED_MODULE_0__[\"isHeader\"](data, offset)) {\n        break;\n      }\n    } // if ADTS header does not start straight from the beginning of the PES payload, raise an error\n\n\n    if (offset !== startOffset) {\n      var reason;\n      var fatal;\n\n      if (offset < len - 1) {\n        reason = \"AAC PES did not start with ADTS header,offset:\" + offset;\n        fatal = false;\n      } else {\n        reason = 'no ADTS header found in AAC PES';\n        fatal = true;\n      }\n\n      _utils_logger__WEBPACK_IMPORTED_MODULE_7__[\"logger\"].warn(\"parsing error:\" + reason);\n      this.observer.emit(_events__WEBPACK_IMPORTED_MODULE_5__[\"Events\"].ERROR, _events__WEBPACK_IMPORTED_MODULE_5__[\"Events\"].ERROR, {\n        type: _errors__WEBPACK_IMPORTED_MODULE_8__[\"ErrorTypes\"].MEDIA_ERROR,\n        details: _errors__WEBPACK_IMPORTED_MODULE_8__[\"ErrorDetails\"].FRAG_PARSING_ERROR,\n        fatal: fatal,\n        reason: reason\n      });\n\n      if (fatal) {\n        return;\n      }\n    }\n\n    _adts__WEBPACK_IMPORTED_MODULE_0__[\"initTrackConfig\"](track, this.observer, data, offset, this.audioCodec);\n    var pts;\n\n    if (pes.pts !== undefined) {\n      pts = pes.pts;\n    } else if (aacOverFlow) {\n      // if last AAC frame is overflowing, we should ensure timestamps are contiguous:\n      // first sample PTS should be equal to last sample PTS + frameDuration\n      var frameDuration = _adts__WEBPACK_IMPORTED_MODULE_0__[\"getFrameDuration\"](track.samplerate);\n      pts = aacOverFlow.sample.pts + frameDuration;\n    } else {\n      _utils_logger__WEBPACK_IMPORTED_MODULE_7__[\"logger\"].warn('[tsdemuxer]: AAC PES unknown PTS');\n      return;\n    } // scan for aac samples\n\n\n    var frameIndex = 0;\n\n    while (offset < len) {\n      if (_adts__WEBPACK_IMPORTED_MODULE_0__[\"isHeader\"](data, offset)) {\n        if (offset + 5 < len) {\n          var frame = _adts__WEBPACK_IMPORTED_MODULE_0__[\"appendFrame\"](track, data, offset, pts, frameIndex);\n\n          if (frame) {\n            if (frame.missing) {\n              this.aacOverFlow = frame;\n            } else {\n              offset += frame.length;\n              frameIndex++;\n              continue;\n            }\n          }\n        } // We are at an ADTS header, but do not have enough data for a frame\n        // Remaining data will be added to aacOverFlow\n\n\n        break;\n      } else {\n        // nothing found, keep looking\n        offset++;\n      }\n    }\n  };\n\n  _proto.parseMPEGPES = function parseMPEGPES(pes) {\n    var data = pes.data;\n    var length = data.length;\n    var frameIndex = 0;\n    var offset = 0;\n    var pts = pes.pts;\n\n    if (pts === undefined) {\n      _utils_logger__WEBPACK_IMPORTED_MODULE_7__[\"logger\"].warn('[tsdemuxer]: MPEG PES unknown PTS');\n      return;\n    }\n\n    while (offset < length) {\n      if (_mpegaudio__WEBPACK_IMPORTED_MODULE_1__[\"isHeader\"](data, offset)) {\n        var frame = _mpegaudio__WEBPACK_IMPORTED_MODULE_1__[\"appendFrame\"](this._audioTrack, data, offset, pts, frameIndex);\n\n        if (frame) {\n          offset += frame.length;\n          frameIndex++;\n        } else {\n          // logger.log('Unable to parse Mpeg audio frame');\n          break;\n        }\n      } else {\n        // nothing found, keep looking\n        offset++;\n      }\n    }\n  };\n\n  _proto.parseID3PES = function parseID3PES(pes) {\n    if (pes.pts === undefined) {\n      _utils_logger__WEBPACK_IMPORTED_MODULE_7__[\"logger\"].warn('[tsdemuxer]: ID3 PES unknown PTS');\n      return;\n    }\n\n    this._id3Track.samples.push(pes);\n  };\n\n  return TSDemuxer;\n}();\n\nTSDemuxer.minProbeByteLength = 188;\n\nfunction createAVCSample(key, pts, dts, debug) {\n  return {\n    key: key,\n    frame: false,\n    pts: pts,\n    dts: dts,\n    units: [],\n    debug: debug,\n    length: 0\n  };\n}\n\nfunction parsePAT(data, offset) {\n  // skip the PSI header and parse the first PMT entry\n  return (data[offset + 10] & 0x1f) << 8 | data[offset + 11]; // logger.log('PMT PID:'  + this._pmtId);\n}\n\nfunction parsePMT(data, offset, mpegSupported, isSampleAes) {\n  var result = {\n    audio: -1,\n    avc: -1,\n    id3: -1,\n    isAAC: true\n  };\n  var sectionLength = (data[offset + 1] & 0x0f) << 8 | data[offset + 2];\n  var tableEnd = offset + 3 + sectionLength - 4; // to determine where the table is, we have to figure out how\n  // long the program info descriptors are\n\n  var programInfoLength = (data[offset + 10] & 0x0f) << 8 | data[offset + 11]; // advance the offset to the first entry in the mapping table\n\n  offset += 12 + programInfoLength;\n\n  while (offset < tableEnd) {\n    var pid = (data[offset + 1] & 0x1f) << 8 | data[offset + 2];\n\n    switch (data[offset]) {\n      case 0xcf:\n        // SAMPLE-AES AAC\n        if (!isSampleAes) {\n          _utils_logger__WEBPACK_IMPORTED_MODULE_7__[\"logger\"].log('ADTS AAC with AES-128-CBC frame encryption found in unencrypted stream');\n          break;\n        }\n\n      /* falls through */\n\n      case 0x0f:\n        // ISO/IEC 13818-7 ADTS AAC (MPEG-2 lower bit-rate audio)\n        // logger.log('AAC PID:'  + pid);\n        if (result.audio === -1) {\n          result.audio = pid;\n        }\n\n        break;\n      // Packetized metadata (ID3)\n\n      case 0x15:\n        // logger.log('ID3 PID:'  + pid);\n        if (result.id3 === -1) {\n          result.id3 = pid;\n        }\n\n        break;\n\n      case 0xdb:\n        // SAMPLE-AES AVC\n        if (!isSampleAes) {\n          _utils_logger__WEBPACK_IMPORTED_MODULE_7__[\"logger\"].log('H.264 with AES-128-CBC slice encryption found in unencrypted stream');\n          break;\n        }\n\n      /* falls through */\n\n      case 0x1b:\n        // ITU-T Rec. H.264 and ISO/IEC 14496-10 (lower bit-rate video)\n        // logger.log('AVC PID:'  + pid);\n        if (result.avc === -1) {\n          result.avc = pid;\n        }\n\n        break;\n      // ISO/IEC 11172-3 (MPEG-1 audio)\n      // or ISO/IEC 13818-3 (MPEG-2 halved sample rate audio)\n\n      case 0x03:\n      case 0x04:\n        // logger.log('MPEG PID:'  + pid);\n        if (!mpegSupported) {\n          _utils_logger__WEBPACK_IMPORTED_MODULE_7__[\"logger\"].log('MPEG audio found, not supported in this browser');\n        } else if (result.audio === -1) {\n          result.audio = pid;\n          result.isAAC = false;\n        }\n\n        break;\n\n      case 0x24:\n        _utils_logger__WEBPACK_IMPORTED_MODULE_7__[\"logger\"].warn('Unsupported HEVC stream type found');\n        break;\n\n      default:\n        // logger.log('unknown stream type:' + data[offset]);\n        break;\n    } // move to the next table entry\n    // skip past the elementary stream descriptors, if present\n\n\n    offset += ((data[offset + 3] & 0x0f) << 8 | data[offset + 4]) + 5;\n  }\n\n  return result;\n}\n\nfunction parsePES(stream) {\n  var i = 0;\n  var frag;\n  var pesLen;\n  var pesHdrLen;\n  var pesPts;\n  var pesDts;\n  var data = stream.data; // safety check\n\n  if (!stream || stream.size === 0) {\n    return null;\n  } // we might need up to 19 bytes to read PES header\n  // if first chunk of data is less than 19 bytes, let's merge it with following ones until we get 19 bytes\n  // usually only one merge is needed (and this is rare ...)\n\n\n  while (data[0].length < 19 && data.length > 1) {\n    var newData = new Uint8Array(data[0].length + data[1].length);\n    newData.set(data[0]);\n    newData.set(data[1], data[0].length);\n    data[0] = newData;\n    data.splice(1, 1);\n  } // retrieve PTS/DTS from first fragment\n\n\n  frag = data[0];\n  var pesPrefix = (frag[0] << 16) + (frag[1] << 8) + frag[2];\n\n  if (pesPrefix === 1) {\n    pesLen = (frag[4] << 8) + frag[5]; // if PES parsed length is not zero and greater than total received length, stop parsing. PES might be truncated\n    // minus 6 : PES header size\n\n    if (pesLen && pesLen > stream.size - 6) {\n      return null;\n    }\n\n    var pesFlags = frag[7];\n\n    if (pesFlags & 0xc0) {\n      /* PES header described here : http://dvd.sourceforge.net/dvdinfo/pes-hdr.html\n          as PTS / DTS is 33 bit we cannot use bitwise operator in JS,\n          as Bitwise operators treat their operands as a sequence of 32 bits */\n      pesPts = (frag[9] & 0x0e) * 536870912 + // 1 << 29\n      (frag[10] & 0xff) * 4194304 + // 1 << 22\n      (frag[11] & 0xfe) * 16384 + // 1 << 14\n      (frag[12] & 0xff) * 128 + // 1 << 7\n      (frag[13] & 0xfe) / 2;\n\n      if (pesFlags & 0x40) {\n        pesDts = (frag[14] & 0x0e) * 536870912 + // 1 << 29\n        (frag[15] & 0xff) * 4194304 + // 1 << 22\n        (frag[16] & 0xfe) * 16384 + // 1 << 14\n        (frag[17] & 0xff) * 128 + // 1 << 7\n        (frag[18] & 0xfe) / 2;\n\n        if (pesPts - pesDts > 60 * 90000) {\n          _utils_logger__WEBPACK_IMPORTED_MODULE_7__[\"logger\"].warn(Math.round((pesPts - pesDts) / 90000) + \"s delta between PTS and DTS, align them\");\n          pesPts = pesDts;\n        }\n      } else {\n        pesDts = pesPts;\n      }\n    }\n\n    pesHdrLen = frag[8]; // 9 bytes : 6 bytes for PES header + 3 bytes for PES extension\n\n    var payloadStartOffset = pesHdrLen + 9;\n\n    if (stream.size <= payloadStartOffset) {\n      return null;\n    }\n\n    stream.size -= payloadStartOffset; // reassemble PES packet\n\n    var pesData = new Uint8Array(stream.size);\n\n    for (var j = 0, dataLen = data.length; j < dataLen; j++) {\n      frag = data[j];\n      var len = frag.byteLength;\n\n      if (payloadStartOffset) {\n        if (payloadStartOffset > len) {\n          // trim full frag if PES header bigger than frag\n          payloadStartOffset -= len;\n          continue;\n        } else {\n          // trim partial frag if PES header smaller than frag\n          frag = frag.subarray(payloadStartOffset);\n          len -= payloadStartOffset;\n          payloadStartOffset = 0;\n        }\n      }\n\n      pesData.set(frag, i);\n      i += len;\n    }\n\n    if (pesLen) {\n      // payload size : remove PES header + PES extension\n      pesLen -= pesHdrLen + 3;\n    }\n\n    return {\n      data: pesData,\n      pts: pesPts,\n      dts: pesDts,\n      len: pesLen\n    };\n  }\n\n  return null;\n}\n\nfunction pushAccessUnit(avcSample, avcTrack) {\n  if (avcSample.units.length && avcSample.frame) {\n    // if sample does not have PTS/DTS, patch with last sample PTS/DTS\n    if (avcSample.pts === undefined) {\n      var samples = avcTrack.samples;\n      var nbSamples = samples.length;\n\n      if (nbSamples) {\n        var lastSample = samples[nbSamples - 1];\n        avcSample.pts = lastSample.pts;\n        avcSample.dts = lastSample.dts;\n      } else {\n        // dropping samples, no timestamp found\n        avcTrack.dropped++;\n        return;\n      }\n    }\n\n    avcTrack.samples.push(avcSample);\n  }\n\n  if (avcSample.debug.length) {\n    _utils_logger__WEBPACK_IMPORTED_MODULE_7__[\"logger\"].log(avcSample.pts + '/' + avcSample.dts + ':' + avcSample.debug);\n  }\n}\n\nfunction insertSampleInOrder(arr, data) {\n  var len = arr.length;\n\n  if (len > 0) {\n    if (data.pts >= arr[len - 1].pts) {\n      arr.push(data);\n    } else {\n      for (var pos = len - 1; pos >= 0; pos--) {\n        if (data.pts < arr[pos].pts) {\n          arr.splice(pos, 0, data);\n          break;\n        }\n      }\n    }\n  } else {\n    arr.push(data);\n  }\n}\n/**\n * remove Emulation Prevention bytes from a RBSP\n */\n\n\nfunction discardEPB(data) {\n  var length = data.byteLength;\n  var EPBPositions = [];\n  var i = 1; // Find all `Emulation Prevention Bytes`\n\n  while (i < length - 2) {\n    if (data[i] === 0 && data[i + 1] === 0 && data[i + 2] === 0x03) {\n      EPBPositions.push(i + 2);\n      i += 2;\n    } else {\n      i++;\n    }\n  } // If no Emulation Prevention Bytes were found just return the original\n  // array\n\n\n  if (EPBPositions.length === 0) {\n    return data;\n  } // Create a new array to hold the NAL unit data\n\n\n  var newLength = length - EPBPositions.length;\n  var newData = new Uint8Array(newLength);\n  var sourceIndex = 0;\n\n  for (i = 0; i < newLength; sourceIndex++, i++) {\n    if (sourceIndex === EPBPositions[0]) {\n      // Skip this byte\n      sourceIndex++; // Remove this position index\n\n      EPBPositions.shift();\n    }\n\n    newData[i] = data[sourceIndex];\n  }\n\n  return newData;\n}\n/* harmony default export */ __webpack_exports__[\"default\"] = (TSDemuxer);\n\n/***/ }),\n\n/***/ \"./src/errors.ts\":\n/*!***********************!*\\\n  !*** ./src/errors.ts ***!\n  \\***********************/\n/*! exports provided: ErrorTypes, ErrorDetails */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_626470__) {\n\n\"use strict\";\n__nested_webpack_require_626470__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_626470__.d(__webpack_exports__, \"ErrorTypes\", function() { return ErrorTypes; });\n/* harmony export (binding) */ __nested_webpack_require_626470__.d(__webpack_exports__, \"ErrorDetails\", function() { return ErrorDetails; });\nvar ErrorTypes;\n/**\n * @enum {ErrorDetails}\n * @typedef {string} ErrorDetail\n */\n\n(function (ErrorTypes) {\n  ErrorTypes[\"NETWORK_ERROR\"] = \"networkError\";\n  ErrorTypes[\"MEDIA_ERROR\"] = \"mediaError\";\n  ErrorTypes[\"KEY_SYSTEM_ERROR\"] = \"keySystemError\";\n  ErrorTypes[\"MUX_ERROR\"] = \"muxError\";\n  ErrorTypes[\"OTHER_ERROR\"] = \"otherError\";\n})(ErrorTypes || (ErrorTypes = {}));\n\nvar ErrorDetails;\n\n(function (ErrorDetails) {\n  ErrorDetails[\"KEY_SYSTEM_NO_KEYS\"] = \"keySystemNoKeys\";\n  ErrorDetails[\"KEY_SYSTEM_NO_ACCESS\"] = \"keySystemNoAccess\";\n  ErrorDetails[\"KEY_SYSTEM_NO_SESSION\"] = \"keySystemNoSession\";\n  ErrorDetails[\"KEY_SYSTEM_LICENSE_REQUEST_FAILED\"] = \"keySystemLicenseRequestFailed\";\n  ErrorDetails[\"KEY_SYSTEM_NO_INIT_DATA\"] = \"keySystemNoInitData\";\n  ErrorDetails[\"MANIFEST_LOAD_ERROR\"] = \"manifestLoadError\";\n  ErrorDetails[\"MANIFEST_LOAD_TIMEOUT\"] = \"manifestLoadTimeOut\";\n  ErrorDetails[\"MANIFEST_PARSING_ERROR\"] = \"manifestParsingError\";\n  ErrorDetails[\"MANIFEST_INCOMPATIBLE_CODECS_ERROR\"] = \"manifestIncompatibleCodecsError\";\n  ErrorDetails[\"LEVEL_EMPTY_ERROR\"] = \"levelEmptyError\";\n  ErrorDetails[\"LEVEL_LOAD_ERROR\"] = \"levelLoadError\";\n  ErrorDetails[\"LEVEL_LOAD_TIMEOUT\"] = \"levelLoadTimeOut\";\n  ErrorDetails[\"LEVEL_SWITCH_ERROR\"] = \"levelSwitchError\";\n  ErrorDetails[\"AUDIO_TRACK_LOAD_ERROR\"] = \"audioTrackLoadError\";\n  ErrorDetails[\"AUDIO_TRACK_LOAD_TIMEOUT\"] = \"audioTrackLoadTimeOut\";\n  ErrorDetails[\"SUBTITLE_LOAD_ERROR\"] = \"subtitleTrackLoadError\";\n  ErrorDetails[\"SUBTITLE_TRACK_LOAD_TIMEOUT\"] = \"subtitleTrackLoadTimeOut\";\n  ErrorDetails[\"FRAG_LOAD_ERROR\"] = \"fragLoadError\";\n  ErrorDetails[\"FRAG_LOAD_TIMEOUT\"] = \"fragLoadTimeOut\";\n  ErrorDetails[\"FRAG_DECRYPT_ERROR\"] = \"fragDecryptError\";\n  ErrorDetails[\"FRAG_PARSING_ERROR\"] = \"fragParsingError\";\n  ErrorDetails[\"REMUX_ALLOC_ERROR\"] = \"remuxAllocError\";\n  ErrorDetails[\"KEY_LOAD_ERROR\"] = \"keyLoadError\";\n  ErrorDetails[\"KEY_LOAD_TIMEOUT\"] = \"keyLoadTimeOut\";\n  ErrorDetails[\"BUFFER_ADD_CODEC_ERROR\"] = \"bufferAddCodecError\";\n  ErrorDetails[\"BUFFER_INCOMPATIBLE_CODECS_ERROR\"] = \"bufferIncompatibleCodecsError\";\n  ErrorDetails[\"BUFFER_APPEND_ERROR\"] = \"bufferAppendError\";\n  ErrorDetails[\"BUFFER_APPENDING_ERROR\"] = \"bufferAppendingError\";\n  ErrorDetails[\"BUFFER_STALLED_ERROR\"] = \"bufferStalledError\";\n  ErrorDetails[\"BUFFER_FULL_ERROR\"] = \"bufferFullError\";\n  ErrorDetails[\"BUFFER_SEEK_OVER_HOLE\"] = \"bufferSeekOverHole\";\n  ErrorDetails[\"BUFFER_NUDGE_ON_STALL\"] = \"bufferNudgeOnStall\";\n  ErrorDetails[\"INTERNAL_EXCEPTION\"] = \"internalException\";\n  ErrorDetails[\"INTERNAL_ABORTED\"] = \"aborted\";\n  ErrorDetails[\"UNKNOWN\"] = \"unknown\";\n})(ErrorDetails || (ErrorDetails = {}));\n\n/***/ }),\n\n/***/ \"./src/events.ts\":\n/*!***********************!*\\\n  !*** ./src/events.ts ***!\n  \\***********************/\n/*! exports provided: Events */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_629660__) {\n\n\"use strict\";\n__nested_webpack_require_629660__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_629660__.d(__webpack_exports__, \"Events\", function() { return Events; });\n/**\n * @readonly\n * @enum {string}\n */\nvar Events;\n\n(function (Events) {\n  Events[\"MEDIA_ATTACHING\"] = \"hlsMediaAttaching\";\n  Events[\"MEDIA_ATTACHED\"] = \"hlsMediaAttached\";\n  Events[\"MEDIA_DETACHING\"] = \"hlsMediaDetaching\";\n  Events[\"MEDIA_DETACHED\"] = \"hlsMediaDetached\";\n  Events[\"BUFFER_RESET\"] = \"hlsBufferReset\";\n  Events[\"BUFFER_CODECS\"] = \"hlsBufferCodecs\";\n  Events[\"BUFFER_CREATED\"] = \"hlsBufferCreated\";\n  Events[\"BUFFER_APPENDING\"] = \"hlsBufferAppending\";\n  Events[\"BUFFER_APPENDED\"] = \"hlsBufferAppended\";\n  Events[\"BUFFER_EOS\"] = \"hlsBufferEos\";\n  Events[\"BUFFER_FLUSHING\"] = \"hlsBufferFlushing\";\n  Events[\"BUFFER_FLUSHED\"] = \"hlsBufferFlushed\";\n  Events[\"MANIFEST_LOADING\"] = \"hlsManifestLoading\";\n  Events[\"MANIFEST_LOADED\"] = \"hlsManifestLoaded\";\n  Events[\"MANIFEST_PARSED\"] = \"hlsManifestParsed\";\n  Events[\"LEVEL_SWITCHING\"] = \"hlsLevelSwitching\";\n  Events[\"LEVEL_SWITCHED\"] = \"hlsLevelSwitched\";\n  Events[\"LEVEL_LOADING\"] = \"hlsLevelLoading\";\n  Events[\"LEVEL_LOADED\"] = \"hlsLevelLoaded\";\n  Events[\"LEVEL_UPDATED\"] = \"hlsLevelUpdated\";\n  Events[\"LEVEL_PTS_UPDATED\"] = \"hlsLevelPtsUpdated\";\n  Events[\"LEVELS_UPDATED\"] = \"hlsLevelsUpdated\";\n  Events[\"AUDIO_TRACKS_UPDATED\"] = \"hlsAudioTracksUpdated\";\n  Events[\"AUDIO_TRACK_SWITCHING\"] = \"hlsAudioTrackSwitching\";\n  Events[\"AUDIO_TRACK_SWITCHED\"] = \"hlsAudioTrackSwitched\";\n  Events[\"AUDIO_TRACK_LOADING\"] = \"hlsAudioTrackLoading\";\n  Events[\"AUDIO_TRACK_LOADED\"] = \"hlsAudioTrackLoaded\";\n  Events[\"SUBTITLE_TRACKS_UPDATED\"] = \"hlsSubtitleTracksUpdated\";\n  Events[\"SUBTITLE_TRACKS_CLEARED\"] = \"hlsSubtitleTracksCleared\";\n  Events[\"SUBTITLE_TRACK_SWITCH\"] = \"hlsSubtitleTrackSwitch\";\n  Events[\"SUBTITLE_TRACK_LOADING\"] = \"hlsSubtitleTrackLoading\";\n  Events[\"SUBTITLE_TRACK_LOADED\"] = \"hlsSubtitleTrackLoaded\";\n  Events[\"SUBTITLE_FRAG_PROCESSED\"] = \"hlsSubtitleFragProcessed\";\n  Events[\"CUES_PARSED\"] = \"hlsCuesParsed\";\n  Events[\"NON_NATIVE_TEXT_TRACKS_FOUND\"] = \"hlsNonNativeTextTracksFound\";\n  Events[\"INIT_PTS_FOUND\"] = \"hlsInitPtsFound\";\n  Events[\"FRAG_LOADING\"] = \"hlsFragLoading\";\n  Events[\"FRAG_LOAD_EMERGENCY_ABORTED\"] = \"hlsFragLoadEmergencyAborted\";\n  Events[\"FRAG_LOADED\"] = \"hlsFragLoaded\";\n  Events[\"FRAG_DECRYPTED\"] = \"hlsFragDecrypted\";\n  Events[\"FRAG_PARSING_INIT_SEGMENT\"] = \"hlsFragParsingInitSegment\";\n  Events[\"FRAG_PARSING_USERDATA\"] = \"hlsFragParsingUserdata\";\n  Events[\"FRAG_PARSING_METADATA\"] = \"hlsFragParsingMetadata\";\n  Events[\"FRAG_PARSED\"] = \"hlsFragParsed\";\n  Events[\"FRAG_BUFFERED\"] = \"hlsFragBuffered\";\n  Events[\"FRAG_CHANGED\"] = \"hlsFragChanged\";\n  Events[\"FPS_DROP\"] = \"hlsFpsDrop\";\n  Events[\"FPS_DROP_LEVEL_CAPPING\"] = \"hlsFpsDropLevelCapping\";\n  Events[\"ERROR\"] = \"hlsError\";\n  Events[\"DESTROYING\"] = \"hlsDestroying\";\n  Events[\"KEY_LOADING\"] = \"hlsKeyLoading\";\n  Events[\"KEY_LOADED\"] = \"hlsKeyLoaded\";\n  Events[\"LIVE_BACK_BUFFER_REACHED\"] = \"hlsLiveBackBufferReached\";\n  Events[\"BACK_BUFFER_REACHED\"] = \"hlsBackBufferReached\";\n})(Events || (Events = {}));\n\n/***/ }),\n\n/***/ \"./src/hls.ts\":\n/*!********************!*\\\n  !*** ./src/hls.ts ***!\n  \\********************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_633000__) {\n\n\"use strict\";\n__nested_webpack_require_633000__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_633000__.d(__webpack_exports__, \"default\", function() { return Hls; });\n/* harmony import */ var url_toolkit__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_633000__(/*! url-toolkit */ \"./node_modules/url-toolkit/src/url-toolkit.js\");\n/* harmony import */ var url_toolkit__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__nested_webpack_require_633000__.n(url_toolkit__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _loader_playlist_loader__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_633000__(/*! ./loader/playlist-loader */ \"./src/loader/playlist-loader.ts\");\n/* harmony import */ var _loader_key_loader__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_633000__(/*! ./loader/key-loader */ \"./src/loader/key-loader.ts\");\n/* harmony import */ var _controller_id3_track_controller__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_633000__(/*! ./controller/id3-track-controller */ \"./src/controller/id3-track-controller.ts\");\n/* harmony import */ var _controller_latency_controller__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_633000__(/*! ./controller/latency-controller */ \"./src/controller/latency-controller.ts\");\n/* harmony import */ var _controller_level_controller__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_633000__(/*! ./controller/level-controller */ \"./src/controller/level-controller.ts\");\n/* harmony import */ var _controller_fragment_tracker__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_633000__(/*! ./controller/fragment-tracker */ \"./src/controller/fragment-tracker.ts\");\n/* harmony import */ var _controller_stream_controller__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_633000__(/*! ./controller/stream-controller */ \"./src/controller/stream-controller.ts\");\n/* harmony import */ var _is_supported__WEBPACK_IMPORTED_MODULE_8__ = __nested_webpack_require_633000__(/*! ./is-supported */ \"./src/is-supported.ts\");\n/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_9__ = __nested_webpack_require_633000__(/*! ./utils/logger */ \"./src/utils/logger.ts\");\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_10__ = __nested_webpack_require_633000__(/*! ./config */ \"./src/config.ts\");\n/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_11__ = __nested_webpack_require_633000__(/*! eventemitter3 */ \"./node_modules/eventemitter3/index.js\");\n/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__nested_webpack_require_633000__.n(eventemitter3__WEBPACK_IMPORTED_MODULE_11__);\n/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_12__ = __nested_webpack_require_633000__(/*! ./events */ \"./src/events.ts\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_13__ = __nested_webpack_require_633000__(/*! ./errors */ \"./src/errors.ts\");\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * @module Hls\n * @class\n * @constructor\n */\nvar Hls = /*#__PURE__*/function () {\n  Hls.isSupported = function isSupported() {\n    return Object(_is_supported__WEBPACK_IMPORTED_MODULE_8__[\"isSupported\"])();\n  };\n\n  /**\n   * Creates an instance of an HLS client that can attach to exactly one `HTMLMediaElement`.\n   *\n   * @constructs Hls\n   * @param {HlsConfig} config\n   */\n  function Hls(userConfig) {\n    if (userConfig === void 0) {\n      userConfig = {};\n    }\n\n    this.config = void 0;\n    this.userConfig = void 0;\n    this.coreComponents = void 0;\n    this.networkControllers = void 0;\n    this._emitter = new eventemitter3__WEBPACK_IMPORTED_MODULE_11__[\"EventEmitter\"]();\n    this._autoLevelCapping = void 0;\n    this.abrController = void 0;\n    this.bufferController = void 0;\n    this.capLevelController = void 0;\n    this.latencyController = void 0;\n    this.levelController = void 0;\n    this.streamController = void 0;\n    this.audioTrackController = void 0;\n    this.subtitleTrackController = void 0;\n    this.emeController = void 0;\n    this.cmcdController = void 0;\n    this._media = null;\n    this.url = null;\n    var config = this.config = Object(_config__WEBPACK_IMPORTED_MODULE_10__[\"mergeConfig\"])(Hls.DefaultConfig, userConfig);\n    this.userConfig = userConfig;\n    Object(_utils_logger__WEBPACK_IMPORTED_MODULE_9__[\"enableLogs\"])(config.debug);\n    this._autoLevelCapping = -1;\n\n    if (config.progressive) {\n      Object(_config__WEBPACK_IMPORTED_MODULE_10__[\"enableStreamingMode\"])(config);\n    } // core controllers and network loaders\n\n\n    var ConfigAbrController = config.abrController,\n        ConfigBufferController = config.bufferController,\n        ConfigCapLevelController = config.capLevelController,\n        ConfigFpsController = config.fpsController;\n    var abrController = this.abrController = new ConfigAbrController(this);\n    var bufferController = this.bufferController = new ConfigBufferController(this);\n    var capLevelController = this.capLevelController = new ConfigCapLevelController(this);\n    var fpsController = new ConfigFpsController(this);\n    var playListLoader = new _loader_playlist_loader__WEBPACK_IMPORTED_MODULE_1__[\"default\"](this);\n    var keyLoader = new _loader_key_loader__WEBPACK_IMPORTED_MODULE_2__[\"default\"](this);\n    var id3TrackController = new _controller_id3_track_controller__WEBPACK_IMPORTED_MODULE_3__[\"default\"](this); // network controllers\n\n    var levelController = this.levelController = new _controller_level_controller__WEBPACK_IMPORTED_MODULE_5__[\"default\"](this); // FragmentTracker must be defined before StreamController because the order of event handling is important\n\n    var fragmentTracker = new _controller_fragment_tracker__WEBPACK_IMPORTED_MODULE_6__[\"FragmentTracker\"](this);\n    var streamController = this.streamController = new _controller_stream_controller__WEBPACK_IMPORTED_MODULE_7__[\"default\"](this, fragmentTracker); // Cap level controller uses streamController to flush the buffer\n\n    capLevelController.setStreamController(streamController); // fpsController uses streamController to switch when frames are being dropped\n\n    fpsController.setStreamController(streamController);\n    var networkControllers = [levelController, streamController];\n    this.networkControllers = networkControllers;\n    var coreComponents = [playListLoader, keyLoader, abrController, bufferController, capLevelController, fpsController, id3TrackController, fragmentTracker];\n    this.audioTrackController = this.createController(config.audioTrackController, null, networkControllers);\n    this.createController(config.audioStreamController, fragmentTracker, networkControllers); // subtitleTrackController must be defined before  because the order of event handling is important\n\n    this.subtitleTrackController = this.createController(config.subtitleTrackController, null, networkControllers);\n    this.createController(config.subtitleStreamController, fragmentTracker, networkControllers);\n    this.createController(config.timelineController, null, coreComponents);\n    this.emeController = this.createController(config.emeController, null, coreComponents);\n    this.cmcdController = this.createController(config.cmcdController, null, coreComponents);\n    this.latencyController = this.createController(_controller_latency_controller__WEBPACK_IMPORTED_MODULE_4__[\"default\"], null, coreComponents);\n    this.coreComponents = coreComponents;\n  }\n\n  var _proto = Hls.prototype;\n\n  _proto.createController = function createController(ControllerClass, fragmentTracker, components) {\n    if (ControllerClass) {\n      var controllerInstance = fragmentTracker ? new ControllerClass(this, fragmentTracker) : new ControllerClass(this);\n\n      if (components) {\n        components.push(controllerInstance);\n      }\n\n      return controllerInstance;\n    }\n\n    return null;\n  } // Delegate the EventEmitter through the public API of Hls.js\n  ;\n\n  _proto.on = function on(event, listener, context) {\n    if (context === void 0) {\n      context = this;\n    }\n\n    this._emitter.on(event, listener, context);\n  };\n\n  _proto.once = function once(event, listener, context) {\n    if (context === void 0) {\n      context = this;\n    }\n\n    this._emitter.once(event, listener, context);\n  };\n\n  _proto.removeAllListeners = function removeAllListeners(event) {\n    this._emitter.removeAllListeners(event);\n  };\n\n  _proto.off = function off(event, listener, context, once) {\n    if (context === void 0) {\n      context = this;\n    }\n\n    this._emitter.off(event, listener, context, once);\n  };\n\n  _proto.listeners = function listeners(event) {\n    return this._emitter.listeners(event);\n  };\n\n  _proto.emit = function emit(event, name, eventObject) {\n    return this._emitter.emit(event, name, eventObject);\n  };\n\n  _proto.trigger = function trigger(event, eventObject) {\n    if (this.config.debug) {\n      return this.emit(event, event, eventObject);\n    } else {\n      try {\n        return this.emit(event, event, eventObject);\n      } catch (e) {\n        _utils_logger__WEBPACK_IMPORTED_MODULE_9__[\"logger\"].error('An internal error happened while handling event ' + event + '. Error message: \"' + e.message + '\". Here is a stacktrace:', e);\n        this.trigger(_events__WEBPACK_IMPORTED_MODULE_12__[\"Events\"].ERROR, {\n          type: _errors__WEBPACK_IMPORTED_MODULE_13__[\"ErrorTypes\"].OTHER_ERROR,\n          details: _errors__WEBPACK_IMPORTED_MODULE_13__[\"ErrorDetails\"].INTERNAL_EXCEPTION,\n          fatal: false,\n          event: event,\n          error: e\n        });\n      }\n    }\n\n    return false;\n  };\n\n  _proto.listenerCount = function listenerCount(event) {\n    return this._emitter.listenerCount(event);\n  }\n  /**\n   * Dispose of the instance\n   */\n  ;\n\n  _proto.destroy = function destroy() {\n    _utils_logger__WEBPACK_IMPORTED_MODULE_9__[\"logger\"].log('destroy');\n    this.trigger(_events__WEBPACK_IMPORTED_MODULE_12__[\"Events\"].DESTROYING, undefined);\n    this.detachMedia();\n    this.removeAllListeners();\n    this._autoLevelCapping = -1;\n    this.url = null;\n    this.networkControllers.forEach(function (component) {\n      return component.destroy();\n    });\n    this.networkControllers.length = 0;\n    this.coreComponents.forEach(function (component) {\n      return component.destroy();\n    });\n    this.coreComponents.length = 0;\n  }\n  /**\n   * Attaches Hls.js to a media element\n   * @param {HTMLMediaElement} media\n   */\n  ;\n\n  _proto.attachMedia = function attachMedia(media) {\n    _utils_logger__WEBPACK_IMPORTED_MODULE_9__[\"logger\"].log('attachMedia');\n    this._media = media;\n    this.trigger(_events__WEBPACK_IMPORTED_MODULE_12__[\"Events\"].MEDIA_ATTACHING, {\n      media: media\n    });\n  }\n  /**\n   * Detach Hls.js from the media\n   */\n  ;\n\n  _proto.detachMedia = function detachMedia() {\n    _utils_logger__WEBPACK_IMPORTED_MODULE_9__[\"logger\"].log('detachMedia');\n    this.trigger(_events__WEBPACK_IMPORTED_MODULE_12__[\"Events\"].MEDIA_DETACHING, undefined);\n    this._media = null;\n  }\n  /**\n   * Set the source URL. Can be relative or absolute.\n   * @param {string} url\n   */\n  ;\n\n  _proto.loadSource = function loadSource(url) {\n    this.stopLoad();\n    var media = this.media;\n    var loadedSource = this.url;\n    var loadingSource = this.url = url_toolkit__WEBPACK_IMPORTED_MODULE_0__[\"buildAbsoluteURL\"](self.location.href, url, {\n      alwaysNormalize: true\n    });\n    _utils_logger__WEBPACK_IMPORTED_MODULE_9__[\"logger\"].log(\"loadSource:\" + loadingSource);\n\n    if (media && loadedSource && loadedSource !== loadingSource && this.bufferController.hasSourceTypes()) {\n      this.detachMedia();\n      this.attachMedia(media);\n    } // when attaching to a source URL, trigger a playlist load\n\n\n    this.trigger(_events__WEBPACK_IMPORTED_MODULE_12__[\"Events\"].MANIFEST_LOADING, {\n      url: url\n    });\n  }\n  /**\n   * Start loading data from the stream source.\n   * Depending on default config, client starts loading automatically when a source is set.\n   *\n   * @param {number} startPosition Set the start position to stream from\n   * @default -1 None (from earliest point)\n   */\n  ;\n\n  _proto.startLoad = function startLoad(startPosition) {\n    if (startPosition === void 0) {\n      startPosition = -1;\n    }\n\n    _utils_logger__WEBPACK_IMPORTED_MODULE_9__[\"logger\"].log(\"startLoad(\" + startPosition + \")\");\n    this.networkControllers.forEach(function (controller) {\n      controller.startLoad(startPosition);\n    });\n  }\n  /**\n   * Stop loading of any stream data.\n   */\n  ;\n\n  _proto.stopLoad = function stopLoad() {\n    _utils_logger__WEBPACK_IMPORTED_MODULE_9__[\"logger\"].log('stopLoad');\n    this.networkControllers.forEach(function (controller) {\n      controller.stopLoad();\n    });\n  }\n  /**\n   * Swap through possible audio codecs in the stream (for example to switch from stereo to 5.1)\n   */\n  ;\n\n  _proto.swapAudioCodec = function swapAudioCodec() {\n    _utils_logger__WEBPACK_IMPORTED_MODULE_9__[\"logger\"].log('swapAudioCodec');\n    this.streamController.swapAudioCodec();\n  }\n  /**\n   * When the media-element fails, this allows to detach and then re-attach it\n   * as one call (convenience method).\n   *\n   * Automatic recovery of media-errors by this process is configurable.\n   */\n  ;\n\n  _proto.recoverMediaError = function recoverMediaError() {\n    _utils_logger__WEBPACK_IMPORTED_MODULE_9__[\"logger\"].log('recoverMediaError');\n    var media = this._media;\n    this.detachMedia();\n\n    if (media) {\n      this.attachMedia(media);\n    }\n  };\n\n  _proto.removeLevel = function removeLevel(levelIndex, urlId) {\n    if (urlId === void 0) {\n      urlId = 0;\n    }\n\n    this.levelController.removeLevel(levelIndex, urlId);\n  }\n  /**\n   * @type {Level[]}\n   */\n  ;\n\n  _createClass(Hls, [{\n    key: \"levels\",\n    get: function get() {\n      var levels = this.levelController.levels;\n      return levels ? levels : [];\n    }\n    /**\n     * Index of quality level currently played\n     * @type {number}\n     */\n\n  }, {\n    key: \"currentLevel\",\n    get: function get() {\n      return this.streamController.currentLevel;\n    }\n    /**\n     * Set quality level index immediately .\n     * This will flush the current buffer to replace the quality asap.\n     * That means playback will interrupt at least shortly to re-buffer and re-sync eventually.\n     * @type {number} -1 for automatic level selection\n     */\n    ,\n    set: function set(newLevel) {\n      _utils_logger__WEBPACK_IMPORTED_MODULE_9__[\"logger\"].log(\"set currentLevel:\" + newLevel);\n      this.loadLevel = newLevel;\n      this.abrController.clearTimer();\n      this.streamController.immediateLevelSwitch();\n    }\n    /**\n     * Index of next quality level loaded as scheduled by stream controller.\n     * @type {number}\n     */\n\n  }, {\n    key: \"nextLevel\",\n    get: function get() {\n      return this.streamController.nextLevel;\n    }\n    /**\n     * Set quality level index for next loaded data.\n     * This will switch the video quality asap, without interrupting playback.\n     * May abort current loading of data, and flush parts of buffer (outside currently played fragment region).\n     * @type {number} -1 for automatic level selection\n     */\n    ,\n    set: function set(newLevel) {\n      _utils_logger__WEBPACK_IMPORTED_MODULE_9__[\"logger\"].log(\"set nextLevel:\" + newLevel);\n      this.levelController.manualLevel = newLevel;\n      this.streamController.nextLevelSwitch();\n    }\n    /**\n     * Return the quality level of the currently or last (of none is loaded currently) segment\n     * @type {number}\n     */\n\n  }, {\n    key: \"loadLevel\",\n    get: function get() {\n      return this.levelController.level;\n    }\n    /**\n     * Set quality level index for next loaded data in a conservative way.\n     * This will switch the quality without flushing, but interrupt current loading.\n     * Thus the moment when the quality switch will appear in effect will only be after the already existing buffer.\n     * @type {number} newLevel -1 for automatic level selection\n     */\n    ,\n    set: function set(newLevel) {\n      _utils_logger__WEBPACK_IMPORTED_MODULE_9__[\"logger\"].log(\"set loadLevel:\" + newLevel);\n      this.levelController.manualLevel = newLevel;\n    }\n    /**\n     * get next quality level loaded\n     * @type {number}\n     */\n\n  }, {\n    key: \"nextLoadLevel\",\n    get: function get() {\n      return this.levelController.nextLoadLevel;\n    }\n    /**\n     * Set quality level of next loaded segment in a fully \"non-destructive\" way.\n     * Same as `loadLevel` but will wait for next switch (until current loading is done).\n     * @type {number} level\n     */\n    ,\n    set: function set(level) {\n      this.levelController.nextLoadLevel = level;\n    }\n    /**\n     * Return \"first level\": like a default level, if not set,\n     * falls back to index of first level referenced in manifest\n     * @type {number}\n     */\n\n  }, {\n    key: \"firstLevel\",\n    get: function get() {\n      return Math.max(this.levelController.firstLevel, this.minAutoLevel);\n    }\n    /**\n     * Sets \"first-level\", see getter.\n     * @type {number}\n     */\n    ,\n    set: function set(newLevel) {\n      _utils_logger__WEBPACK_IMPORTED_MODULE_9__[\"logger\"].log(\"set firstLevel:\" + newLevel);\n      this.levelController.firstLevel = newLevel;\n    }\n    /**\n     * Return start level (level of first fragment that will be played back)\n     * if not overrided by user, first level appearing in manifest will be used as start level\n     * if -1 : automatic start level selection, playback will start from level matching download bandwidth\n     * (determined from download of first segment)\n     * @type {number}\n     */\n\n  }, {\n    key: \"startLevel\",\n    get: function get() {\n      return this.levelController.startLevel;\n    }\n    /**\n     * set  start level (level of first fragment that will be played back)\n     * if not overrided by user, first level appearing in manifest will be used as start level\n     * if -1 : automatic start level selection, playback will start from level matching download bandwidth\n     * (determined from download of first segment)\n     * @type {number} newLevel\n     */\n    ,\n    set: function set(newLevel) {\n      _utils_logger__WEBPACK_IMPORTED_MODULE_9__[\"logger\"].log(\"set startLevel:\" + newLevel); // if not in automatic start level detection, ensure startLevel is greater than minAutoLevel\n\n      if (newLevel !== -1) {\n        newLevel = Math.max(newLevel, this.minAutoLevel);\n      }\n\n      this.levelController.startLevel = newLevel;\n    }\n    /**\n     * Get the current setting for capLevelToPlayerSize\n     *\n     * @type {boolean}\n     */\n\n  }, {\n    key: \"capLevelToPlayerSize\",\n    get: function get() {\n      return this.config.capLevelToPlayerSize;\n    }\n    /**\n     * set  dynamically set capLevelToPlayerSize against (`CapLevelController`)\n     *\n     * @type {boolean}\n     */\n    ,\n    set: function set(shouldStartCapping) {\n      var newCapLevelToPlayerSize = !!shouldStartCapping;\n\n      if (newCapLevelToPlayerSize !== this.config.capLevelToPlayerSize) {\n        if (newCapLevelToPlayerSize) {\n          this.capLevelController.startCapping(); // If capping occurs, nextLevelSwitch will happen based on size.\n        } else {\n          this.capLevelController.stopCapping();\n          this.autoLevelCapping = -1;\n          this.streamController.nextLevelSwitch(); // Now we're uncapped, get the next level asap.\n        }\n\n        this.config.capLevelToPlayerSize = newCapLevelToPlayerSize;\n      }\n    }\n    /**\n     * Capping/max level value that should be used by automatic level selection algorithm (`ABRController`)\n     * @type {number}\n     */\n\n  }, {\n    key: \"autoLevelCapping\",\n    get: function get() {\n      return this._autoLevelCapping;\n    }\n    /**\n     * get bandwidth estimate\n     * @type {number}\n     */\n    ,\n    set:\n    /**\n     * Capping/max level value that should be used by automatic level selection algorithm (`ABRController`)\n     * @type {number}\n     */\n    function set(newLevel) {\n      if (this._autoLevelCapping !== newLevel) {\n        _utils_logger__WEBPACK_IMPORTED_MODULE_9__[\"logger\"].log(\"set autoLevelCapping:\" + newLevel);\n        this._autoLevelCapping = newLevel;\n      }\n    }\n    /**\n     * True when automatic level selection enabled\n     * @type {boolean}\n     */\n\n  }, {\n    key: \"bandwidthEstimate\",\n    get: function get() {\n      var bwEstimator = this.abrController.bwEstimator;\n\n      if (!bwEstimator) {\n        return NaN;\n      }\n\n      return bwEstimator.getEstimate();\n    }\n  }, {\n    key: \"autoLevelEnabled\",\n    get: function get() {\n      return this.levelController.manualLevel === -1;\n    }\n    /**\n     * Level set manually (if any)\n     * @type {number}\n     */\n\n  }, {\n    key: \"manualLevel\",\n    get: function get() {\n      return this.levelController.manualLevel;\n    }\n    /**\n     * min level selectable in auto mode according to config.minAutoBitrate\n     * @type {number}\n     */\n\n  }, {\n    key: \"minAutoLevel\",\n    get: function get() {\n      var levels = this.levels,\n          minAutoBitrate = this.config.minAutoBitrate;\n      if (!levels) return 0;\n      var len = levels.length;\n\n      for (var i = 0; i < len; i++) {\n        if (levels[i].maxBitrate > minAutoBitrate) {\n          return i;\n        }\n      }\n\n      return 0;\n    }\n    /**\n     * max level selectable in auto mode according to autoLevelCapping\n     * @type {number}\n     */\n\n  }, {\n    key: \"maxAutoLevel\",\n    get: function get() {\n      var levels = this.levels,\n          autoLevelCapping = this.autoLevelCapping;\n      var maxAutoLevel;\n\n      if (autoLevelCapping === -1 && levels && levels.length) {\n        maxAutoLevel = levels.length - 1;\n      } else {\n        maxAutoLevel = autoLevelCapping;\n      }\n\n      return maxAutoLevel;\n    }\n    /**\n     * next automatically selected quality level\n     * @type {number}\n     */\n\n  }, {\n    key: \"nextAutoLevel\",\n    get: function get() {\n      // ensure next auto level is between  min and max auto level\n      return Math.min(Math.max(this.abrController.nextAutoLevel, this.minAutoLevel), this.maxAutoLevel);\n    }\n    /**\n     * this setter is used to force next auto level.\n     * this is useful to force a switch down in auto mode:\n     * in case of load error on level N, hls.js can set nextAutoLevel to N-1 for example)\n     * forced value is valid for one fragment. upon successful frag loading at forced level,\n     * this value will be resetted to -1 by ABR controller.\n     * @type {number}\n     */\n    ,\n    set: function set(nextLevel) {\n      this.abrController.nextAutoLevel = Math.max(this.minAutoLevel, nextLevel);\n    }\n    /**\n     * @type {AudioTrack[]}\n     */\n\n  }, {\n    key: \"audioTracks\",\n    get: function get() {\n      var audioTrackController = this.audioTrackController;\n      return audioTrackController ? audioTrackController.audioTracks : [];\n    }\n    /**\n     * index of the selected audio track (index in audio track lists)\n     * @type {number}\n     */\n\n  }, {\n    key: \"audioTrack\",\n    get: function get() {\n      var audioTrackController = this.audioTrackController;\n      return audioTrackController ? audioTrackController.audioTrack : -1;\n    }\n    /**\n     * selects an audio track, based on its index in audio track lists\n     * @type {number}\n     */\n    ,\n    set: function set(audioTrackId) {\n      var audioTrackController = this.audioTrackController;\n\n      if (audioTrackController) {\n        audioTrackController.audioTrack = audioTrackId;\n      }\n    }\n    /**\n     * get alternate subtitle tracks list from playlist\n     * @type {MediaPlaylist[]}\n     */\n\n  }, {\n    key: \"subtitleTracks\",\n    get: function get() {\n      var subtitleTrackController = this.subtitleTrackController;\n      return subtitleTrackController ? subtitleTrackController.subtitleTracks : [];\n    }\n    /**\n     * index of the selected subtitle track (index in subtitle track lists)\n     * @type {number}\n     */\n\n  }, {\n    key: \"subtitleTrack\",\n    get: function get() {\n      var subtitleTrackController = this.subtitleTrackController;\n      return subtitleTrackController ? subtitleTrackController.subtitleTrack : -1;\n    },\n    set:\n    /**\n     * select an subtitle track, based on its index in subtitle track lists\n     * @type {number}\n     */\n    function set(subtitleTrackId) {\n      var subtitleTrackController = this.subtitleTrackController;\n\n      if (subtitleTrackController) {\n        subtitleTrackController.subtitleTrack = subtitleTrackId;\n      }\n    }\n    /**\n     * @type {boolean}\n     */\n\n  }, {\n    key: \"media\",\n    get: function get() {\n      return this._media;\n    }\n  }, {\n    key: \"subtitleDisplay\",\n    get: function get() {\n      var subtitleTrackController = this.subtitleTrackController;\n      return subtitleTrackController ? subtitleTrackController.subtitleDisplay : false;\n    }\n    /**\n     * Enable/disable subtitle display rendering\n     * @type {boolean}\n     */\n    ,\n    set: function set(value) {\n      var subtitleTrackController = this.subtitleTrackController;\n\n      if (subtitleTrackController) {\n        subtitleTrackController.subtitleDisplay = value;\n      }\n    }\n    /**\n     * get mode for Low-Latency HLS loading\n     * @type {boolean}\n     */\n\n  }, {\n    key: \"lowLatencyMode\",\n    get: function get() {\n      return this.config.lowLatencyMode;\n    }\n    /**\n     * Enable/disable Low-Latency HLS part playlist and segment loading, and start live streams at playlist PART-HOLD-BACK rather than HOLD-BACK.\n     * @type {boolean}\n     */\n    ,\n    set: function set(mode) {\n      this.config.lowLatencyMode = mode;\n    }\n    /**\n     * position (in seconds) of live sync point (ie edge of live position minus safety delay defined by ```hls.config.liveSyncDuration```)\n     * @type {number}\n     */\n\n  }, {\n    key: \"liveSyncPosition\",\n    get: function get() {\n      return this.latencyController.liveSyncPosition;\n    }\n    /**\n     * estimated position (in seconds) of live edge (ie edge of live playlist plus time sync playlist advanced)\n     * returns 0 before first playlist is loaded\n     * @type {number}\n     */\n\n  }, {\n    key: \"latency\",\n    get: function get() {\n      return this.latencyController.latency;\n    }\n    /**\n     * maximum distance from the edge before the player seeks forward to ```hls.liveSyncPosition```\n     * configured using ```liveMaxLatencyDurationCount``` (multiple of target duration) or ```liveMaxLatencyDuration```\n     * returns 0 before first playlist is loaded\n     * @type {number}\n     */\n\n  }, {\n    key: \"maxLatency\",\n    get: function get() {\n      return this.latencyController.maxLatency;\n    }\n    /**\n     * target distance from the edge as calculated by the latency controller\n     * @type {number}\n     */\n\n  }, {\n    key: \"targetLatency\",\n    get: function get() {\n      return this.latencyController.targetLatency;\n    }\n    /**\n     * the rate at which the edge of the current live playlist is advancing or 1 if there is none\n     * @type {number}\n     */\n\n  }, {\n    key: \"drift\",\n    get: function get() {\n      return this.latencyController.drift;\n    }\n    /**\n     * set to true when startLoad is called before MANIFEST_PARSED event\n     * @type {boolean}\n     */\n\n  }, {\n    key: \"forceStartLoad\",\n    get: function get() {\n      return this.streamController.forceStartLoad;\n    }\n  }], [{\n    key: \"version\",\n    get: function get() {\n      return \"1.1.5\";\n    }\n  }, {\n    key: \"Events\",\n    get: function get() {\n      return _events__WEBPACK_IMPORTED_MODULE_12__[\"Events\"];\n    }\n  }, {\n    key: \"ErrorTypes\",\n    get: function get() {\n      return _errors__WEBPACK_IMPORTED_MODULE_13__[\"ErrorTypes\"];\n    }\n  }, {\n    key: \"ErrorDetails\",\n    get: function get() {\n      return _errors__WEBPACK_IMPORTED_MODULE_13__[\"ErrorDetails\"];\n    }\n  }, {\n    key: \"DefaultConfig\",\n    get: function get() {\n      if (!Hls.defaultConfig) {\n        return _config__WEBPACK_IMPORTED_MODULE_10__[\"hlsDefaultConfig\"];\n      }\n\n      return Hls.defaultConfig;\n    }\n    /**\n     * @type {HlsConfig}\n     */\n    ,\n    set: function set(defaultConfig) {\n      Hls.defaultConfig = defaultConfig;\n    }\n  }]);\n\n  return Hls;\n}();\n\nHls.defaultConfig = void 0;\n\n\n/***/ }),\n\n/***/ \"./src/is-supported.ts\":\n/*!*****************************!*\\\n  !*** ./src/is-supported.ts ***!\n  \\*****************************/\n/*! exports provided: isSupported, changeTypeSupported */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_661641__) {\n\n\"use strict\";\n__nested_webpack_require_661641__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_661641__.d(__webpack_exports__, \"isSupported\", function() { return isSupported; });\n/* harmony export (binding) */ __nested_webpack_require_661641__.d(__webpack_exports__, \"changeTypeSupported\", function() { return changeTypeSupported; });\n/* harmony import */ var _utils_mediasource_helper__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_661641__(/*! ./utils/mediasource-helper */ \"./src/utils/mediasource-helper.ts\");\n\n\nfunction getSourceBuffer() {\n  return self.SourceBuffer || self.WebKitSourceBuffer;\n}\n\nfunction isSupported() {\n  var mediaSource = Object(_utils_mediasource_helper__WEBPACK_IMPORTED_MODULE_0__[\"getMediaSource\"])();\n\n  if (!mediaSource) {\n    return false;\n  }\n\n  var sourceBuffer = getSourceBuffer();\n  var isTypeSupported = mediaSource && typeof mediaSource.isTypeSupported === 'function' && mediaSource.isTypeSupported('video/mp4; codecs=\"avc1.42E01E,mp4a.40.2\"'); // if SourceBuffer is exposed ensure its API is valid\n  // safari and old version of Chrome doe not expose SourceBuffer globally so checking SourceBuffer.prototype is impossible\n\n  var sourceBufferValidAPI = !sourceBuffer || sourceBuffer.prototype && typeof sourceBuffer.prototype.appendBuffer === 'function' && typeof sourceBuffer.prototype.remove === 'function';\n  return !!isTypeSupported && !!sourceBufferValidAPI;\n}\nfunction changeTypeSupported() {\n  var _sourceBuffer$prototy;\n\n  var sourceBuffer = getSourceBuffer();\n  return typeof (sourceBuffer === null || sourceBuffer === void 0 ? void 0 : (_sourceBuffer$prototy = sourceBuffer.prototype) === null || _sourceBuffer$prototy === void 0 ? void 0 : _sourceBuffer$prototy.changeType) === 'function';\n}\n\n/***/ }),\n\n/***/ \"./src/loader/fragment-loader.ts\":\n/*!***************************************!*\\\n  !*** ./src/loader/fragment-loader.ts ***!\n  \\***************************************/\n/*! exports provided: default, LoadError */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_663669__) {\n\n\"use strict\";\n__nested_webpack_require_663669__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_663669__.d(__webpack_exports__, \"default\", function() { return FragmentLoader; });\n/* harmony export (binding) */ __nested_webpack_require_663669__.d(__webpack_exports__, \"LoadError\", function() { return LoadError; });\n/* harmony import */ var _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_663669__(/*! ./src/polyfills/number */ \"./src/polyfills/number.ts\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_663669__(/*! ../errors */ \"./src/errors.ts\");\n\n\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }\n\nfunction _wrapNativeSuper(Class) { var _cache = typeof Map === \"function\" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== \"function\") { throw new TypeError(\"Super expression must either be null or a function\"); } if (typeof _cache !== \"undefined\") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }\n\nfunction _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _isNativeFunction(fn) { return Function.toString.call(fn).indexOf(\"[native code]\") !== -1; }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\nvar MIN_CHUNK_SIZE = Math.pow(2, 17); // 128kb\n\nvar FragmentLoader = /*#__PURE__*/function () {\n  function FragmentLoader(config) {\n    this.config = void 0;\n    this.loader = null;\n    this.partLoadTimeout = -1;\n    this.config = config;\n  }\n\n  var _proto = FragmentLoader.prototype;\n\n  _proto.destroy = function destroy() {\n    if (this.loader) {\n      this.loader.destroy();\n      this.loader = null;\n    }\n  };\n\n  _proto.abort = function abort() {\n    if (this.loader) {\n      // Abort the loader for current fragment. Only one may load at any given time\n      this.loader.abort();\n    }\n  };\n\n  _proto.load = function load(frag, _onProgress) {\n    var _this = this;\n\n    var url = frag.url;\n\n    if (!url) {\n      return Promise.reject(new LoadError({\n        type: _errors__WEBPACK_IMPORTED_MODULE_1__[\"ErrorTypes\"].NETWORK_ERROR,\n        details: _errors__WEBPACK_IMPORTED_MODULE_1__[\"ErrorDetails\"].FRAG_LOAD_ERROR,\n        fatal: false,\n        frag: frag,\n        networkDetails: null\n      }, \"Fragment does not have a \" + (url ? 'part list' : 'url')));\n    }\n\n    this.abort();\n    var config = this.config;\n    var FragmentILoader = config.fLoader;\n    var DefaultILoader = config.loader;\n    return new Promise(function (resolve, reject) {\n      if (_this.loader) {\n        _this.loader.destroy();\n      }\n\n      var loader = _this.loader = frag.loader = FragmentILoader ? new FragmentILoader(config) : new DefaultILoader(config);\n      var loaderContext = createLoaderContext(frag);\n      var loaderConfig = {\n        timeout: config.fragLoadingTimeOut,\n        maxRetry: 0,\n        retryDelay: 0,\n        maxRetryDelay: config.fragLoadingMaxRetryTimeout,\n        highWaterMark: MIN_CHUNK_SIZE\n      }; // Assign frag stats to the loader's stats reference\n\n      frag.stats = loader.stats;\n      loader.load(loaderContext, loaderConfig, {\n        onSuccess: function onSuccess(response, stats, context, networkDetails) {\n          _this.resetLoader(frag, loader);\n\n          resolve({\n            frag: frag,\n            part: null,\n            payload: response.data,\n            networkDetails: networkDetails\n          });\n        },\n        onError: function onError(response, context, networkDetails) {\n          _this.resetLoader(frag, loader);\n\n          reject(new LoadError({\n            type: _errors__WEBPACK_IMPORTED_MODULE_1__[\"ErrorTypes\"].NETWORK_ERROR,\n            details: _errors__WEBPACK_IMPORTED_MODULE_1__[\"ErrorDetails\"].FRAG_LOAD_ERROR,\n            fatal: false,\n            frag: frag,\n            response: response,\n            networkDetails: networkDetails\n          }));\n        },\n        onAbort: function onAbort(stats, context, networkDetails) {\n          _this.resetLoader(frag, loader);\n\n          reject(new LoadError({\n            type: _errors__WEBPACK_IMPORTED_MODULE_1__[\"ErrorTypes\"].NETWORK_ERROR,\n            details: _errors__WEBPACK_IMPORTED_MODULE_1__[\"ErrorDetails\"].INTERNAL_ABORTED,\n            fatal: false,\n            frag: frag,\n            networkDetails: networkDetails\n          }));\n        },\n        onTimeout: function onTimeout(response, context, networkDetails) {\n          _this.resetLoader(frag, loader);\n\n          reject(new LoadError({\n            type: _errors__WEBPACK_IMPORTED_MODULE_1__[\"ErrorTypes\"].NETWORK_ERROR,\n            details: _errors__WEBPACK_IMPORTED_MODULE_1__[\"ErrorDetails\"].FRAG_LOAD_TIMEOUT,\n            fatal: false,\n            frag: frag,\n            networkDetails: networkDetails\n          }));\n        },\n        onProgress: function onProgress(stats, context, data, networkDetails) {\n          if (_onProgress) {\n            _onProgress({\n              frag: frag,\n              part: null,\n              payload: data,\n              networkDetails: networkDetails\n            });\n          }\n        }\n      });\n    });\n  };\n\n  _proto.loadPart = function loadPart(frag, part, onProgress) {\n    var _this2 = this;\n\n    this.abort();\n    var config = this.config;\n    var FragmentILoader = config.fLoader;\n    var DefaultILoader = config.loader;\n    return new Promise(function (resolve, reject) {\n      if (_this2.loader) {\n        _this2.loader.destroy();\n      }\n\n      var loader = _this2.loader = frag.loader = FragmentILoader ? new FragmentILoader(config) : new DefaultILoader(config);\n      var loaderContext = createLoaderContext(frag, part);\n      var loaderConfig = {\n        timeout: config.fragLoadingTimeOut,\n        maxRetry: 0,\n        retryDelay: 0,\n        maxRetryDelay: config.fragLoadingMaxRetryTimeout,\n        highWaterMark: MIN_CHUNK_SIZE\n      }; // Assign part stats to the loader's stats reference\n\n      part.stats = loader.stats;\n      loader.load(loaderContext, loaderConfig, {\n        onSuccess: function onSuccess(response, stats, context, networkDetails) {\n          _this2.resetLoader(frag, loader);\n\n          _this2.updateStatsFromPart(frag, part);\n\n          var partLoadedData = {\n            frag: frag,\n            part: part,\n            payload: response.data,\n            networkDetails: networkDetails\n          };\n          onProgress(partLoadedData);\n          resolve(partLoadedData);\n        },\n        onError: function onError(response, context, networkDetails) {\n          _this2.resetLoader(frag, loader);\n\n          reject(new LoadError({\n            type: _errors__WEBPACK_IMPORTED_MODULE_1__[\"ErrorTypes\"].NETWORK_ERROR,\n            details: _errors__WEBPACK_IMPORTED_MODULE_1__[\"ErrorDetails\"].FRAG_LOAD_ERROR,\n            fatal: false,\n            frag: frag,\n            part: part,\n            response: response,\n            networkDetails: networkDetails\n          }));\n        },\n        onAbort: function onAbort(stats, context, networkDetails) {\n          frag.stats.aborted = part.stats.aborted;\n\n          _this2.resetLoader(frag, loader);\n\n          reject(new LoadError({\n            type: _errors__WEBPACK_IMPORTED_MODULE_1__[\"ErrorTypes\"].NETWORK_ERROR,\n            details: _errors__WEBPACK_IMPORTED_MODULE_1__[\"ErrorDetails\"].INTERNAL_ABORTED,\n            fatal: false,\n            frag: frag,\n            part: part,\n            networkDetails: networkDetails\n          }));\n        },\n        onTimeout: function onTimeout(response, context, networkDetails) {\n          _this2.resetLoader(frag, loader);\n\n          reject(new LoadError({\n            type: _errors__WEBPACK_IMPORTED_MODULE_1__[\"ErrorTypes\"].NETWORK_ERROR,\n            details: _errors__WEBPACK_IMPORTED_MODULE_1__[\"ErrorDetails\"].FRAG_LOAD_TIMEOUT,\n            fatal: false,\n            frag: frag,\n            part: part,\n            networkDetails: networkDetails\n          }));\n        }\n      });\n    });\n  };\n\n  _proto.updateStatsFromPart = function updateStatsFromPart(frag, part) {\n    var fragStats = frag.stats;\n    var partStats = part.stats;\n    var partTotal = partStats.total;\n    fragStats.loaded += partStats.loaded;\n\n    if (partTotal) {\n      var estTotalParts = Math.round(frag.duration / part.duration);\n      var estLoadedParts = Math.min(Math.round(fragStats.loaded / partTotal), estTotalParts);\n      var estRemainingParts = estTotalParts - estLoadedParts;\n      var estRemainingBytes = estRemainingParts * Math.round(fragStats.loaded / estLoadedParts);\n      fragStats.total = fragStats.loaded + estRemainingBytes;\n    } else {\n      fragStats.total = Math.max(fragStats.loaded, fragStats.total);\n    }\n\n    var fragLoading = fragStats.loading;\n    var partLoading = partStats.loading;\n\n    if (fragLoading.start) {\n      // add to fragment loader latency\n      fragLoading.first += partLoading.first - partLoading.start;\n    } else {\n      fragLoading.start = partLoading.start;\n      fragLoading.first = partLoading.first;\n    }\n\n    fragLoading.end = partLoading.end;\n  };\n\n  _proto.resetLoader = function resetLoader(frag, loader) {\n    frag.loader = null;\n\n    if (this.loader === loader) {\n      self.clearTimeout(this.partLoadTimeout);\n      this.loader = null;\n    }\n\n    loader.destroy();\n  };\n\n  return FragmentLoader;\n}();\n\n\n\nfunction createLoaderContext(frag, part) {\n  if (part === void 0) {\n    part = null;\n  }\n\n  var segment = part || frag;\n  var loaderContext = {\n    frag: frag,\n    part: part,\n    responseType: 'arraybuffer',\n    url: segment.url,\n    headers: {},\n    rangeStart: 0,\n    rangeEnd: 0\n  };\n  var start = segment.byteRangeStartOffset;\n  var end = segment.byteRangeEndOffset;\n\n  if (Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__[\"isFiniteNumber\"])(start) && Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__[\"isFiniteNumber\"])(end)) {\n    loaderContext.rangeStart = start;\n    loaderContext.rangeEnd = end;\n  }\n\n  return loaderContext;\n}\n\nvar LoadError = /*#__PURE__*/function (_Error) {\n  _inheritsLoose(LoadError, _Error);\n\n  function LoadError(data) {\n    var _this3;\n\n    for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      params[_key - 1] = arguments[_key];\n    }\n\n    _this3 = _Error.call.apply(_Error, [this].concat(params)) || this;\n    _this3.data = void 0;\n    _this3.data = data;\n    return _this3;\n  }\n\n  return LoadError;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n\n/***/ }),\n\n/***/ \"./src/loader/fragment.ts\":\n/*!********************************!*\\\n  !*** ./src/loader/fragment.ts ***!\n  \\********************************/\n/*! exports provided: ElementaryStreamTypes, BaseSegment, Fragment, Part */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_676007__) {\n\n\"use strict\";\n__nested_webpack_require_676007__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_676007__.d(__webpack_exports__, \"ElementaryStreamTypes\", function() { return ElementaryStreamTypes; });\n/* harmony export (binding) */ __nested_webpack_require_676007__.d(__webpack_exports__, \"BaseSegment\", function() { return BaseSegment; });\n/* harmony export (binding) */ __nested_webpack_require_676007__.d(__webpack_exports__, \"Fragment\", function() { return Fragment; });\n/* harmony export (binding) */ __nested_webpack_require_676007__.d(__webpack_exports__, \"Part\", function() { return Part; });\n/* harmony import */ var _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_676007__(/*! ./src/polyfills/number */ \"./src/polyfills/number.ts\");\n/* harmony import */ var url_toolkit__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_676007__(/*! url-toolkit */ \"./node_modules/url-toolkit/src/url-toolkit.js\");\n/* harmony import */ var url_toolkit__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__nested_webpack_require_676007__.n(url_toolkit__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_676007__(/*! ../utils/logger */ \"./src/utils/logger.ts\");\n/* harmony import */ var _level_key__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_676007__(/*! ./level-key */ \"./src/loader/level-key.ts\");\n/* harmony import */ var _load_stats__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_676007__(/*! ./load-stats */ \"./src/loader/load-stats.ts\");\n\n\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\n\n\nvar ElementaryStreamTypes;\n\n(function (ElementaryStreamTypes) {\n  ElementaryStreamTypes[\"AUDIO\"] = \"audio\";\n  ElementaryStreamTypes[\"VIDEO\"] = \"video\";\n  ElementaryStreamTypes[\"AUDIOVIDEO\"] = \"audiovideo\";\n})(ElementaryStreamTypes || (ElementaryStreamTypes = {}));\n\nvar BaseSegment = /*#__PURE__*/function () {\n  // baseurl is the URL to the playlist\n  // relurl is the portion of the URL that comes from inside the playlist.\n  // Holds the types of data this fragment supports\n  function BaseSegment(baseurl) {\n    var _this$elementaryStrea;\n\n    this._byteRange = null;\n    this._url = null;\n    this.baseurl = void 0;\n    this.relurl = void 0;\n    this.elementaryStreams = (_this$elementaryStrea = {}, _this$elementaryStrea[ElementaryStreamTypes.AUDIO] = null, _this$elementaryStrea[ElementaryStreamTypes.VIDEO] = null, _this$elementaryStrea[ElementaryStreamTypes.AUDIOVIDEO] = null, _this$elementaryStrea);\n    this.baseurl = baseurl;\n  } // setByteRange converts a EXT-X-BYTERANGE attribute into a two element array\n\n\n  var _proto = BaseSegment.prototype;\n\n  _proto.setByteRange = function setByteRange(value, previous) {\n    var params = value.split('@', 2);\n    var byteRange = [];\n\n    if (params.length === 1) {\n      byteRange[0] = previous ? previous.byteRangeEndOffset : 0;\n    } else {\n      byteRange[0] = parseInt(params[1]);\n    }\n\n    byteRange[1] = parseInt(params[0]) + byteRange[0];\n    this._byteRange = byteRange;\n  };\n\n  _createClass(BaseSegment, [{\n    key: \"byteRange\",\n    get: function get() {\n      if (!this._byteRange) {\n        return [];\n      }\n\n      return this._byteRange;\n    }\n  }, {\n    key: \"byteRangeStartOffset\",\n    get: function get() {\n      return this.byteRange[0];\n    }\n  }, {\n    key: \"byteRangeEndOffset\",\n    get: function get() {\n      return this.byteRange[1];\n    }\n  }, {\n    key: \"url\",\n    get: function get() {\n      if (!this._url && this.baseurl && this.relurl) {\n        this._url = Object(url_toolkit__WEBPACK_IMPORTED_MODULE_1__[\"buildAbsoluteURL\"])(this.baseurl, this.relurl, {\n          alwaysNormalize: true\n        });\n      }\n\n      return this._url || '';\n    },\n    set: function set(value) {\n      this._url = value;\n    }\n  }]);\n\n  return BaseSegment;\n}();\nvar Fragment = /*#__PURE__*/function (_BaseSegment) {\n  _inheritsLoose(Fragment, _BaseSegment);\n\n  // EXTINF has to be present for a m38 to be considered valid\n  // sn notates the sequence number for a segment, and if set to a string can be 'initSegment'\n  // levelkey is the EXT-X-KEY that applies to this segment for decryption\n  // core difference from the private field _decryptdata is the lack of the initialized IV\n  // _decryptdata will set the IV for this segment based on the segment number in the fragment\n  // A string representing the fragment type\n  // A reference to the loader. Set while the fragment is loading, and removed afterwards. Used to abort fragment loading\n  // The level/track index to which the fragment belongs\n  // The continuity counter of the fragment\n  // The starting Presentation Time Stamp (PTS) of the fragment. Set after transmux complete.\n  // The ending Presentation Time Stamp (PTS) of the fragment. Set after transmux complete.\n  // The latest Presentation Time Stamp (PTS) appended to the buffer.\n  // The starting Decode Time Stamp (DTS) of the fragment. Set after transmux complete.\n  // The ending Decode Time Stamp (DTS) of the fragment. Set after transmux complete.\n  // The start time of the fragment, as listed in the manifest. Updated after transmux complete.\n  // Set by `updateFragPTSDTS` in level-helper\n  // The maximum starting Presentation Time Stamp (audio/video PTS) of the fragment. Set after transmux complete.\n  // The minimum ending Presentation Time Stamp (audio/video PTS) of the fragment. Set after transmux complete.\n  // Load/parse timing information\n  // A flag indicating whether the segment was downloaded in order to test bitrate, and was not buffered\n  // #EXTINF  segment title\n  // The Media Initialization Section for this segment\n  function Fragment(type, baseurl) {\n    var _this;\n\n    _this = _BaseSegment.call(this, baseurl) || this;\n    _this._decryptdata = null;\n    _this.rawProgramDateTime = null;\n    _this.programDateTime = null;\n    _this.tagList = [];\n    _this.duration = 0;\n    _this.sn = 0;\n    _this.levelkey = void 0;\n    _this.type = void 0;\n    _this.loader = null;\n    _this.level = -1;\n    _this.cc = 0;\n    _this.startPTS = void 0;\n    _this.endPTS = void 0;\n    _this.appendedPTS = void 0;\n    _this.startDTS = void 0;\n    _this.endDTS = void 0;\n    _this.start = 0;\n    _this.deltaPTS = void 0;\n    _this.maxStartPTS = void 0;\n    _this.minEndPTS = void 0;\n    _this.stats = new _load_stats__WEBPACK_IMPORTED_MODULE_4__[\"LoadStats\"]();\n    _this.urlId = 0;\n    _this.data = void 0;\n    _this.bitrateTest = false;\n    _this.title = null;\n    _this.initSegment = null;\n    _this.type = type;\n    return _this;\n  }\n\n  var _proto2 = Fragment.prototype;\n\n  /**\n   * Utility method for parseLevelPlaylist to create an initialization vector for a given segment\n   * @param {number} segmentNumber - segment number to generate IV with\n   * @returns {Uint8Array}\n   */\n  _proto2.createInitializationVector = function createInitializationVector(segmentNumber) {\n    var uint8View = new Uint8Array(16);\n\n    for (var i = 12; i < 16; i++) {\n      uint8View[i] = segmentNumber >> 8 * (15 - i) & 0xff;\n    }\n\n    return uint8View;\n  }\n  /**\n   * Utility method for parseLevelPlaylist to get a fragment's decryption data from the currently parsed encryption key data\n   * @param levelkey - a playlist's encryption info\n   * @param segmentNumber - the fragment's segment number\n   * @returns {LevelKey} - an object to be applied as a fragment's decryptdata\n   */\n  ;\n\n  _proto2.setDecryptDataFromLevelKey = function setDecryptDataFromLevelKey(levelkey, segmentNumber) {\n    var decryptdata = levelkey;\n\n    if ((levelkey === null || levelkey === void 0 ? void 0 : levelkey.method) === 'AES-128' && levelkey.uri && !levelkey.iv) {\n      decryptdata = _level_key__WEBPACK_IMPORTED_MODULE_3__[\"LevelKey\"].fromURI(levelkey.uri);\n      decryptdata.method = levelkey.method;\n      decryptdata.iv = this.createInitializationVector(segmentNumber);\n      decryptdata.keyFormat = 'identity';\n    }\n\n    return decryptdata;\n  };\n\n  _proto2.setElementaryStreamInfo = function setElementaryStreamInfo(type, startPTS, endPTS, startDTS, endDTS, partial) {\n    if (partial === void 0) {\n      partial = false;\n    }\n\n    var elementaryStreams = this.elementaryStreams;\n    var info = elementaryStreams[type];\n\n    if (!info) {\n      elementaryStreams[type] = {\n        startPTS: startPTS,\n        endPTS: endPTS,\n        startDTS: startDTS,\n        endDTS: endDTS,\n        partial: partial\n      };\n      return;\n    }\n\n    info.startPTS = Math.min(info.startPTS, startPTS);\n    info.endPTS = Math.max(info.endPTS, endPTS);\n    info.startDTS = Math.min(info.startDTS, startDTS);\n    info.endDTS = Math.max(info.endDTS, endDTS);\n  };\n\n  _proto2.clearElementaryStreamInfo = function clearElementaryStreamInfo() {\n    var elementaryStreams = this.elementaryStreams;\n    elementaryStreams[ElementaryStreamTypes.AUDIO] = null;\n    elementaryStreams[ElementaryStreamTypes.VIDEO] = null;\n    elementaryStreams[ElementaryStreamTypes.AUDIOVIDEO] = null;\n  };\n\n  _createClass(Fragment, [{\n    key: \"decryptdata\",\n    get: function get() {\n      if (!this.levelkey && !this._decryptdata) {\n        return null;\n      }\n\n      if (!this._decryptdata && this.levelkey) {\n        var sn = this.sn;\n\n        if (typeof sn !== 'number') {\n          // We are fetching decryption data for a initialization segment\n          // If the segment was encrypted with AES-128\n          // It must have an IV defined. We cannot substitute the Segment Number in.\n          if (this.levelkey && this.levelkey.method === 'AES-128' && !this.levelkey.iv) {\n            _utils_logger__WEBPACK_IMPORTED_MODULE_2__[\"logger\"].warn(\"missing IV for initialization segment with method=\\\"\" + this.levelkey.method + \"\\\" - compliance issue\");\n          }\n          /*\n          Be converted to a Number.\n          'initSegment' will become NaN.\n          NaN, which when converted through ToInt32() -> +0.\n          ---\n          Explicitly set sn to resulting value from implicit conversions 'initSegment' values for IV generation.\n          */\n\n\n          sn = 0;\n        }\n\n        this._decryptdata = this.setDecryptDataFromLevelKey(this.levelkey, sn);\n      }\n\n      return this._decryptdata;\n    }\n  }, {\n    key: \"end\",\n    get: function get() {\n      return this.start + this.duration;\n    }\n  }, {\n    key: \"endProgramDateTime\",\n    get: function get() {\n      if (this.programDateTime === null) {\n        return null;\n      }\n\n      if (!Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__[\"isFiniteNumber\"])(this.programDateTime)) {\n        return null;\n      }\n\n      var duration = !Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__[\"isFiniteNumber\"])(this.duration) ? 0 : this.duration;\n      return this.programDateTime + duration * 1000;\n    }\n  }, {\n    key: \"encrypted\",\n    get: function get() {\n      var _this$decryptdata;\n\n      // At the m3u8-parser level we need to add support for manifest signalled keyformats\n      // when we want the fragment to start reporting that it is encrypted.\n      // Currently, keyFormat will only be set for identity keys\n      if ((_this$decryptdata = this.decryptdata) !== null && _this$decryptdata !== void 0 && _this$decryptdata.keyFormat && this.decryptdata.uri) {\n        return true;\n      }\n\n      return false;\n    }\n  }]);\n\n  return Fragment;\n}(BaseSegment);\nvar Part = /*#__PURE__*/function (_BaseSegment2) {\n  _inheritsLoose(Part, _BaseSegment2);\n\n  function Part(partAttrs, frag, baseurl, index, previous) {\n    var _this2;\n\n    _this2 = _BaseSegment2.call(this, baseurl) || this;\n    _this2.fragOffset = 0;\n    _this2.duration = 0;\n    _this2.gap = false;\n    _this2.independent = false;\n    _this2.relurl = void 0;\n    _this2.fragment = void 0;\n    _this2.index = void 0;\n    _this2.stats = new _load_stats__WEBPACK_IMPORTED_MODULE_4__[\"LoadStats\"]();\n    _this2.duration = partAttrs.decimalFloatingPoint('DURATION');\n    _this2.gap = partAttrs.bool('GAP');\n    _this2.independent = partAttrs.bool('INDEPENDENT');\n    _this2.relurl = partAttrs.enumeratedString('URI');\n    _this2.fragment = frag;\n    _this2.index = index;\n    var byteRange = partAttrs.enumeratedString('BYTERANGE');\n\n    if (byteRange) {\n      _this2.setByteRange(byteRange, previous);\n    }\n\n    if (previous) {\n      _this2.fragOffset = previous.fragOffset + previous.duration;\n    }\n\n    return _this2;\n  }\n\n  _createClass(Part, [{\n    key: \"start\",\n    get: function get() {\n      return this.fragment.start + this.fragOffset;\n    }\n  }, {\n    key: \"end\",\n    get: function get() {\n      return this.start + this.duration;\n    }\n  }, {\n    key: \"loaded\",\n    get: function get() {\n      var elementaryStreams = this.elementaryStreams;\n      return !!(elementaryStreams.audio || elementaryStreams.video || elementaryStreams.audiovideo);\n    }\n  }]);\n\n  return Part;\n}(BaseSegment);\n\n/***/ }),\n\n/***/ \"./src/loader/key-loader.ts\":\n/*!**********************************!*\\\n  !*** ./src/loader/key-loader.ts ***!\n  \\**********************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_689914__) {\n\n\"use strict\";\n__nested_webpack_require_689914__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_689914__.d(__webpack_exports__, \"default\", function() { return KeyLoader; });\n/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_689914__(/*! ../events */ \"./src/events.ts\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_689914__(/*! ../errors */ \"./src/errors.ts\");\n/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_689914__(/*! ../utils/logger */ \"./src/utils/logger.ts\");\n/*\n * Decrypt key Loader\n */\n\n\n\n\nvar KeyLoader = /*#__PURE__*/function () {\n  function KeyLoader(hls) {\n    this.hls = void 0;\n    this.loaders = {};\n    this.decryptkey = null;\n    this.decrypturl = null;\n    this.hls = hls;\n\n    this._registerListeners();\n  }\n\n  var _proto = KeyLoader.prototype;\n\n  _proto._registerListeners = function _registerListeners() {\n    this.hls.on(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].KEY_LOADING, this.onKeyLoading, this);\n  };\n\n  _proto._unregisterListeners = function _unregisterListeners() {\n    this.hls.off(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].KEY_LOADING, this.onKeyLoading);\n  };\n\n  _proto.destroy = function destroy() {\n    this._unregisterListeners();\n\n    for (var loaderName in this.loaders) {\n      var loader = this.loaders[loaderName];\n\n      if (loader) {\n        loader.destroy();\n      }\n    }\n\n    this.loaders = {};\n  };\n\n  _proto.onKeyLoading = function onKeyLoading(event, data) {\n    var frag = data.frag;\n    var type = frag.type;\n    var loader = this.loaders[type];\n\n    if (!frag.decryptdata) {\n      _utils_logger__WEBPACK_IMPORTED_MODULE_2__[\"logger\"].warn('Missing decryption data on fragment in onKeyLoading');\n      return;\n    } // Load the key if the uri is different from previous one, or if the decrypt key has not yet been retrieved\n\n\n    var uri = frag.decryptdata.uri;\n\n    if (uri !== this.decrypturl || this.decryptkey === null) {\n      var config = this.hls.config;\n\n      if (loader) {\n        _utils_logger__WEBPACK_IMPORTED_MODULE_2__[\"logger\"].warn(\"abort previous key loader for type:\" + type);\n        loader.abort();\n      }\n\n      if (!uri) {\n        _utils_logger__WEBPACK_IMPORTED_MODULE_2__[\"logger\"].warn('key uri is falsy');\n        return;\n      }\n\n      var Loader = config.loader;\n      var fragLoader = frag.loader = this.loaders[type] = new Loader(config);\n      this.decrypturl = uri;\n      this.decryptkey = null;\n      var loaderContext = {\n        url: uri,\n        frag: frag,\n        responseType: 'arraybuffer'\n      }; // maxRetry is 0 so that instead of retrying the same key on the same variant multiple times,\n      // key-loader will trigger an error and rely on stream-controller to handle retry logic.\n      // this will also align retry logic with fragment-loader\n\n      var loaderConfig = {\n        timeout: config.fragLoadingTimeOut,\n        maxRetry: 0,\n        retryDelay: config.fragLoadingRetryDelay,\n        maxRetryDelay: config.fragLoadingMaxRetryTimeout,\n        highWaterMark: 0\n      };\n      var loaderCallbacks = {\n        onSuccess: this.loadsuccess.bind(this),\n        onError: this.loaderror.bind(this),\n        onTimeout: this.loadtimeout.bind(this)\n      };\n      fragLoader.load(loaderContext, loaderConfig, loaderCallbacks);\n    } else if (this.decryptkey) {\n      // Return the key if it's already been loaded\n      frag.decryptdata.key = this.decryptkey;\n      this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].KEY_LOADED, {\n        frag: frag\n      });\n    }\n  };\n\n  _proto.loadsuccess = function loadsuccess(response, stats, context) {\n    var frag = context.frag;\n\n    if (!frag.decryptdata) {\n      _utils_logger__WEBPACK_IMPORTED_MODULE_2__[\"logger\"].error('after key load, decryptdata unset');\n      return;\n    }\n\n    this.decryptkey = frag.decryptdata.key = new Uint8Array(response.data); // detach fragment loader on load success\n\n    frag.loader = null;\n    delete this.loaders[frag.type];\n    this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].KEY_LOADED, {\n      frag: frag\n    });\n  };\n\n  _proto.loaderror = function loaderror(response, context) {\n    var frag = context.frag;\n    var loader = frag.loader;\n\n    if (loader) {\n      loader.abort();\n    }\n\n    delete this.loaders[frag.type];\n    this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].ERROR, {\n      type: _errors__WEBPACK_IMPORTED_MODULE_1__[\"ErrorTypes\"].NETWORK_ERROR,\n      details: _errors__WEBPACK_IMPORTED_MODULE_1__[\"ErrorDetails\"].KEY_LOAD_ERROR,\n      fatal: false,\n      frag: frag,\n      response: response\n    });\n  };\n\n  _proto.loadtimeout = function loadtimeout(stats, context) {\n    var frag = context.frag;\n    var loader = frag.loader;\n\n    if (loader) {\n      loader.abort();\n    }\n\n    delete this.loaders[frag.type];\n    this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_0__[\"Events\"].ERROR, {\n      type: _errors__WEBPACK_IMPORTED_MODULE_1__[\"ErrorTypes\"].NETWORK_ERROR,\n      details: _errors__WEBPACK_IMPORTED_MODULE_1__[\"ErrorDetails\"].KEY_LOAD_TIMEOUT,\n      fatal: false,\n      frag: frag\n    });\n  };\n\n  return KeyLoader;\n}();\n\n\n\n/***/ }),\n\n/***/ \"./src/loader/level-details.ts\":\n/*!*************************************!*\\\n  !*** ./src/loader/level-details.ts ***!\n  \\*************************************/\n/*! exports provided: LevelDetails */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_695378__) {\n\n\"use strict\";\n__nested_webpack_require_695378__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_695378__.d(__webpack_exports__, \"LevelDetails\", function() { return LevelDetails; });\n/* harmony import */ var _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_695378__(/*! ./src/polyfills/number */ \"./src/polyfills/number.ts\");\n\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar DEFAULT_TARGET_DURATION = 10;\nvar LevelDetails = /*#__PURE__*/function () {\n  // Manifest reload synchronization\n  function LevelDetails(baseUrl) {\n    this.PTSKnown = false;\n    this.alignedSliding = false;\n    this.averagetargetduration = void 0;\n    this.endCC = 0;\n    this.endSN = 0;\n    this.fragments = void 0;\n    this.fragmentHint = void 0;\n    this.partList = null;\n    this.live = true;\n    this.ageHeader = 0;\n    this.advancedDateTime = void 0;\n    this.updated = true;\n    this.advanced = true;\n    this.availabilityDelay = void 0;\n    this.misses = 0;\n    this.needSidxRanges = false;\n    this.startCC = 0;\n    this.startSN = 0;\n    this.startTimeOffset = null;\n    this.targetduration = 0;\n    this.totalduration = 0;\n    this.type = null;\n    this.url = void 0;\n    this.m3u8 = '';\n    this.version = null;\n    this.canBlockReload = false;\n    this.canSkipUntil = 0;\n    this.canSkipDateRanges = false;\n    this.skippedSegments = 0;\n    this.recentlyRemovedDateranges = void 0;\n    this.partHoldBack = 0;\n    this.holdBack = 0;\n    this.partTarget = 0;\n    this.preloadHint = void 0;\n    this.renditionReports = void 0;\n    this.tuneInGoal = 0;\n    this.deltaUpdateFailed = void 0;\n    this.driftStartTime = 0;\n    this.driftEndTime = 0;\n    this.driftStart = 0;\n    this.driftEnd = 0;\n    this.fragments = [];\n    this.url = baseUrl;\n  }\n\n  var _proto = LevelDetails.prototype;\n\n  _proto.reloaded = function reloaded(previous) {\n    if (!previous) {\n      this.advanced = true;\n      this.updated = true;\n      return;\n    }\n\n    var partSnDiff = this.lastPartSn - previous.lastPartSn;\n    var partIndexDiff = this.lastPartIndex - previous.lastPartIndex;\n    this.updated = this.endSN !== previous.endSN || !!partIndexDiff || !!partSnDiff;\n    this.advanced = this.endSN > previous.endSN || partSnDiff > 0 || partSnDiff === 0 && partIndexDiff > 0;\n\n    if (this.updated || this.advanced) {\n      this.misses = Math.floor(previous.misses * 0.6);\n    } else {\n      this.misses = previous.misses + 1;\n    }\n\n    this.availabilityDelay = previous.availabilityDelay;\n  };\n\n  _createClass(LevelDetails, [{\n    key: \"hasProgramDateTime\",\n    get: function get() {\n      if (this.fragments.length) {\n        return Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__[\"isFiniteNumber\"])(this.fragments[this.fragments.length - 1].programDateTime);\n      }\n\n      return false;\n    }\n  }, {\n    key: \"levelTargetDuration\",\n    get: function get() {\n      return this.averagetargetduration || this.targetduration || DEFAULT_TARGET_DURATION;\n    }\n  }, {\n    key: \"drift\",\n    get: function get() {\n      var runTime = this.driftEndTime - this.driftStartTime;\n\n      if (runTime > 0) {\n        var runDuration = this.driftEnd - this.driftStart;\n        return runDuration * 1000 / runTime;\n      }\n\n      return 1;\n    }\n  }, {\n    key: \"edge\",\n    get: function get() {\n      return this.partEnd || this.fragmentEnd;\n    }\n  }, {\n    key: \"partEnd\",\n    get: function get() {\n      var _this$partList;\n\n      if ((_this$partList = this.partList) !== null && _this$partList !== void 0 && _this$partList.length) {\n        return this.partList[this.partList.length - 1].end;\n      }\n\n      return this.fragmentEnd;\n    }\n  }, {\n    key: \"fragmentEnd\",\n    get: function get() {\n      var _this$fragments;\n\n      if ((_this$fragments = this.fragments) !== null && _this$fragments !== void 0 && _this$fragments.length) {\n        return this.fragments[this.fragments.length - 1].end;\n      }\n\n      return 0;\n    }\n  }, {\n    key: \"age\",\n    get: function get() {\n      if (this.advancedDateTime) {\n        return Math.max(Date.now() - this.advancedDateTime, 0) / 1000;\n      }\n\n      return 0;\n    }\n  }, {\n    key: \"lastPartIndex\",\n    get: function get() {\n      var _this$partList2;\n\n      if ((_this$partList2 = this.partList) !== null && _this$partList2 !== void 0 && _this$partList2.length) {\n        return this.partList[this.partList.length - 1].index;\n      }\n\n      return -1;\n    }\n  }, {\n    key: \"lastPartSn\",\n    get: function get() {\n      var _this$partList3;\n\n      if ((_this$partList3 = this.partList) !== null && _this$partList3 !== void 0 && _this$partList3.length) {\n        return this.partList[this.partList.length - 1].fragment.sn;\n      }\n\n      return this.endSN;\n    }\n  }]);\n\n  return LevelDetails;\n}();\n\n/***/ }),\n\n/***/ \"./src/loader/level-key.ts\":\n/*!*********************************!*\\\n  !*** ./src/loader/level-key.ts ***!\n  \\*********************************/\n/*! exports provided: LevelKey */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_700933__) {\n\n\"use strict\";\n__nested_webpack_require_700933__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_700933__.d(__webpack_exports__, \"LevelKey\", function() { return LevelKey; });\n/* harmony import */ var url_toolkit__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_700933__(/*! url-toolkit */ \"./node_modules/url-toolkit/src/url-toolkit.js\");\n/* harmony import */ var url_toolkit__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__nested_webpack_require_700933__.n(url_toolkit__WEBPACK_IMPORTED_MODULE_0__);\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\nvar LevelKey = /*#__PURE__*/function () {\n  LevelKey.fromURL = function fromURL(baseUrl, relativeUrl) {\n    return new LevelKey(baseUrl, relativeUrl);\n  };\n\n  LevelKey.fromURI = function fromURI(uri) {\n    return new LevelKey(uri);\n  };\n\n  function LevelKey(absoluteOrBaseURI, relativeURL) {\n    this._uri = null;\n    this.method = null;\n    this.keyFormat = null;\n    this.keyFormatVersions = null;\n    this.keyID = null;\n    this.key = null;\n    this.iv = null;\n\n    if (relativeURL) {\n      this._uri = Object(url_toolkit__WEBPACK_IMPORTED_MODULE_0__[\"buildAbsoluteURL\"])(absoluteOrBaseURI, relativeURL, {\n        alwaysNormalize: true\n      });\n    } else {\n      this._uri = absoluteOrBaseURI;\n    }\n  }\n\n  _createClass(LevelKey, [{\n    key: \"uri\",\n    get: function get() {\n      return this._uri;\n    }\n  }]);\n\n  return LevelKey;\n}();\n\n/***/ }),\n\n/***/ \"./src/loader/load-stats.ts\":\n/*!**********************************!*\\\n  !*** ./src/loader/load-stats.ts ***!\n  \\**********************************/\n/*! exports provided: LoadStats */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_703072__) {\n\n\"use strict\";\n__nested_webpack_require_703072__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_703072__.d(__webpack_exports__, \"LoadStats\", function() { return LoadStats; });\nvar LoadStats = function LoadStats() {\n  this.aborted = false;\n  this.loaded = 0;\n  this.retry = 0;\n  this.total = 0;\n  this.chunkCount = 0;\n  this.bwEstimate = 0;\n  this.loading = {\n    start: 0,\n    first: 0,\n    end: 0\n  };\n  this.parsing = {\n    start: 0,\n    end: 0\n  };\n  this.buffering = {\n    start: 0,\n    first: 0,\n    end: 0\n  };\n};\n\n/***/ }),\n\n/***/ \"./src/loader/m3u8-parser.ts\":\n/*!***********************************!*\\\n  !*** ./src/loader/m3u8-parser.ts ***!\n  \\***********************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_703869__) {\n\n\"use strict\";\n__nested_webpack_require_703869__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_703869__.d(__webpack_exports__, \"default\", function() { return M3U8Parser; });\n/* harmony import */ var _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_703869__(/*! ./src/polyfills/number */ \"./src/polyfills/number.ts\");\n/* harmony import */ var url_toolkit__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_703869__(/*! url-toolkit */ \"./node_modules/url-toolkit/src/url-toolkit.js\");\n/* harmony import */ var url_toolkit__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__nested_webpack_require_703869__.n(url_toolkit__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _fragment__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_703869__(/*! ./fragment */ \"./src/loader/fragment.ts\");\n/* harmony import */ var _level_details__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_703869__(/*! ./level-details */ \"./src/loader/level-details.ts\");\n/* harmony import */ var _level_key__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_703869__(/*! ./level-key */ \"./src/loader/level-key.ts\");\n/* harmony import */ var _utils_attr_list__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_703869__(/*! ../utils/attr-list */ \"./src/utils/attr-list.ts\");\n/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_703869__(/*! ../utils/logger */ \"./src/utils/logger.ts\");\n/* harmony import */ var _utils_codecs__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_703869__(/*! ../utils/codecs */ \"./src/utils/codecs.ts\");\n\n\n\n\n\n\n\n\n\n\n\n// https://regex101.com is your friend\nvar MASTER_PLAYLIST_REGEX = /#EXT-X-STREAM-INF:([^\\r\\n]*)(?:[\\r\\n](?:#[^\\r\\n]*)?)*([^\\r\\n]+)|#EXT-X-SESSION-DATA:([^\\r\\n]*)[\\r\\n]+/g;\nvar MASTER_PLAYLIST_MEDIA_REGEX = /#EXT-X-MEDIA:(.*)/g;\nvar LEVEL_PLAYLIST_REGEX_FAST = new RegExp([/#EXTINF:\\s*(\\d*(?:\\.\\d+)?)(?:,(.*)\\s+)?/.source, // duration (#EXTINF:<duration>,<title>), group 1 => duration, group 2 => title\n/(?!#) *(\\S[\\S ]*)/.source, // segment URI, group 3 => the URI (note newline is not eaten)\n/#EXT-X-BYTERANGE:*(.+)/.source, // next segment's byterange, group 4 => range spec (x@y)\n/#EXT-X-PROGRAM-DATE-TIME:(.+)/.source, // next segment's program date/time group 5 => the datetime spec\n/#.*/.source // All other non-segment oriented tags will match with all groups empty\n].join('|'), 'g');\nvar LEVEL_PLAYLIST_REGEX_SLOW = new RegExp([/#(EXTM3U)/.source, /#EXT-X-(PLAYLIST-TYPE):(.+)/.source, /#EXT-X-(MEDIA-SEQUENCE): *(\\d+)/.source, /#EXT-X-(SKIP):(.+)/.source, /#EXT-X-(TARGETDURATION): *(\\d+)/.source, /#EXT-X-(KEY):(.+)/.source, /#EXT-X-(START):(.+)/.source, /#EXT-X-(ENDLIST)/.source, /#EXT-X-(DISCONTINUITY-SEQ)UENCE: *(\\d+)/.source, /#EXT-X-(DIS)CONTINUITY/.source, /#EXT-X-(VERSION):(\\d+)/.source, /#EXT-X-(MAP):(.+)/.source, /#EXT-X-(SERVER-CONTROL):(.+)/.source, /#EXT-X-(PART-INF):(.+)/.source, /#EXT-X-(GAP)/.source, /#EXT-X-(BITRATE):\\s*(\\d+)/.source, /#EXT-X-(PART):(.+)/.source, /#EXT-X-(PRELOAD-HINT):(.+)/.source, /#EXT-X-(RENDITION-REPORT):(.+)/.source, /(#)([^:]*):(.*)/.source, /(#)(.*)(?:.*)\\r?\\n?/.source].join('|'));\nvar MP4_REGEX_SUFFIX = /\\.(mp4|m4s|m4v|m4a)$/i;\n\nfunction isMP4Url(url) {\n  var _URLToolkit$parseURL$, _URLToolkit$parseURL;\n\n  return MP4_REGEX_SUFFIX.test((_URLToolkit$parseURL$ = (_URLToolkit$parseURL = url_toolkit__WEBPACK_IMPORTED_MODULE_1__[\"parseURL\"](url)) === null || _URLToolkit$parseURL === void 0 ? void 0 : _URLToolkit$parseURL.path) != null ? _URLToolkit$parseURL$ : '');\n}\n\nvar M3U8Parser = /*#__PURE__*/function () {\n  function M3U8Parser() {}\n\n  M3U8Parser.findGroup = function findGroup(groups, mediaGroupId) {\n    for (var i = 0; i < groups.length; i++) {\n      var group = groups[i];\n\n      if (group.id === mediaGroupId) {\n        return group;\n      }\n    }\n  };\n\n  M3U8Parser.convertAVC1ToAVCOTI = function convertAVC1ToAVCOTI(codec) {\n    // Convert avc1 codec string from RFC-4281 to RFC-6381 for MediaSource.isTypeSupported\n    var avcdata = codec.split('.');\n\n    if (avcdata.length > 2) {\n      var result = avcdata.shift() + '.';\n      result += parseInt(avcdata.shift()).toString(16);\n      result += ('000' + parseInt(avcdata.shift()).toString(16)).substr(-4);\n      return result;\n    }\n\n    return codec;\n  };\n\n  M3U8Parser.resolve = function resolve(url, baseUrl) {\n    return url_toolkit__WEBPACK_IMPORTED_MODULE_1__[\"buildAbsoluteURL\"](baseUrl, url, {\n      alwaysNormalize: true\n    });\n  };\n\n  M3U8Parser.parseMasterPlaylist = function parseMasterPlaylist(string, baseurl) {\n    var levels = [];\n    var sessionData = {};\n    var hasSessionData = false;\n    MASTER_PLAYLIST_REGEX.lastIndex = 0;\n    var result;\n\n    while ((result = MASTER_PLAYLIST_REGEX.exec(string)) != null) {\n      if (result[1]) {\n        // '#EXT-X-STREAM-INF' is found, parse level tag  in group 1\n        var attrs = new _utils_attr_list__WEBPACK_IMPORTED_MODULE_5__[\"AttrList\"](result[1]);\n        var level = {\n          attrs: attrs,\n          bitrate: attrs.decimalInteger('AVERAGE-BANDWIDTH') || attrs.decimalInteger('BANDWIDTH'),\n          name: attrs.NAME,\n          url: M3U8Parser.resolve(result[2], baseurl)\n        };\n        var resolution = attrs.decimalResolution('RESOLUTION');\n\n        if (resolution) {\n          level.width = resolution.width;\n          level.height = resolution.height;\n        }\n\n        setCodecs((attrs.CODECS || '').split(/[ ,]+/).filter(function (c) {\n          return c;\n        }), level);\n\n        if (level.videoCodec && level.videoCodec.indexOf('avc1') !== -1) {\n          level.videoCodec = M3U8Parser.convertAVC1ToAVCOTI(level.videoCodec);\n        }\n\n        levels.push(level);\n      } else if (result[3]) {\n        // '#EXT-X-SESSION-DATA' is found, parse session data in group 3\n        var sessionAttrs = new _utils_attr_list__WEBPACK_IMPORTED_MODULE_5__[\"AttrList\"](result[3]);\n\n        if (sessionAttrs['DATA-ID']) {\n          hasSessionData = true;\n          sessionData[sessionAttrs['DATA-ID']] = sessionAttrs;\n        }\n      }\n    }\n\n    return {\n      levels: levels,\n      sessionData: hasSessionData ? sessionData : null\n    };\n  };\n\n  M3U8Parser.parseMasterPlaylistMedia = function parseMasterPlaylistMedia(string, baseurl, type, groups) {\n    if (groups === void 0) {\n      groups = [];\n    }\n\n    var result;\n    var medias = [];\n    var id = 0;\n    MASTER_PLAYLIST_MEDIA_REGEX.lastIndex = 0;\n\n    while ((result = MASTER_PLAYLIST_MEDIA_REGEX.exec(string)) !== null) {\n      var attrs = new _utils_attr_list__WEBPACK_IMPORTED_MODULE_5__[\"AttrList\"](result[1]);\n\n      if (attrs.TYPE === type) {\n        var media = {\n          attrs: attrs,\n          bitrate: 0,\n          id: id++,\n          groupId: attrs['GROUP-ID'],\n          instreamId: attrs['INSTREAM-ID'],\n          name: attrs.NAME || attrs.LANGUAGE || '',\n          type: type,\n          default: attrs.bool('DEFAULT'),\n          autoselect: attrs.bool('AUTOSELECT'),\n          forced: attrs.bool('FORCED'),\n          lang: attrs.LANGUAGE,\n          url: attrs.URI ? M3U8Parser.resolve(attrs.URI, baseurl) : ''\n        };\n\n        if (groups.length) {\n          // If there are audio or text groups signalled in the manifest, let's look for a matching codec string for this track\n          // If we don't find the track signalled, lets use the first audio groups codec we have\n          // Acting as a best guess\n          var groupCodec = M3U8Parser.findGroup(groups, media.groupId) || groups[0];\n          assignCodec(media, groupCodec, 'audioCodec');\n          assignCodec(media, groupCodec, 'textCodec');\n        }\n\n        medias.push(media);\n      }\n    }\n\n    return medias;\n  };\n\n  M3U8Parser.parseLevelPlaylist = function parseLevelPlaylist(string, baseurl, id, type, levelUrlId) {\n    var level = new _level_details__WEBPACK_IMPORTED_MODULE_3__[\"LevelDetails\"](baseurl);\n    var fragments = level.fragments; // The most recent init segment seen (applies to all subsequent segments)\n\n    var currentInitSegment = null;\n    var currentSN = 0;\n    var currentPart = 0;\n    var totalduration = 0;\n    var discontinuityCounter = 0;\n    var prevFrag = null;\n    var frag = new _fragment__WEBPACK_IMPORTED_MODULE_2__[\"Fragment\"](type, baseurl);\n    var result;\n    var i;\n    var levelkey;\n    var firstPdtIndex = -1;\n    var createNextFrag = false;\n    LEVEL_PLAYLIST_REGEX_FAST.lastIndex = 0;\n    level.m3u8 = string;\n\n    while ((result = LEVEL_PLAYLIST_REGEX_FAST.exec(string)) !== null) {\n      if (createNextFrag) {\n        createNextFrag = false;\n        frag = new _fragment__WEBPACK_IMPORTED_MODULE_2__[\"Fragment\"](type, baseurl); // setup the next fragment for part loading\n\n        frag.start = totalduration;\n        frag.sn = currentSN;\n        frag.cc = discontinuityCounter;\n        frag.level = id;\n\n        if (currentInitSegment) {\n          frag.initSegment = currentInitSegment;\n          frag.rawProgramDateTime = currentInitSegment.rawProgramDateTime;\n        }\n      }\n\n      var duration = result[1];\n\n      if (duration) {\n        // INF\n        frag.duration = parseFloat(duration); // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939\n\n        var title = (' ' + result[2]).slice(1);\n        frag.title = title || null;\n        frag.tagList.push(title ? ['INF', duration, title] : ['INF', duration]);\n      } else if (result[3]) {\n        // url\n        if (Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__[\"isFiniteNumber\"])(frag.duration)) {\n          frag.start = totalduration;\n\n          if (levelkey) {\n            frag.levelkey = levelkey;\n          }\n\n          frag.sn = currentSN;\n          frag.level = id;\n          frag.cc = discontinuityCounter;\n          frag.urlId = levelUrlId;\n          fragments.push(frag); // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939\n\n          frag.relurl = (' ' + result[3]).slice(1);\n          assignProgramDateTime(frag, prevFrag);\n          prevFrag = frag;\n          totalduration += frag.duration;\n          currentSN++;\n          currentPart = 0;\n          createNextFrag = true;\n        }\n      } else if (result[4]) {\n        // X-BYTERANGE\n        var data = (' ' + result[4]).slice(1);\n\n        if (prevFrag) {\n          frag.setByteRange(data, prevFrag);\n        } else {\n          frag.setByteRange(data);\n        }\n      } else if (result[5]) {\n        // PROGRAM-DATE-TIME\n        // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939\n        frag.rawProgramDateTime = (' ' + result[5]).slice(1);\n        frag.tagList.push(['PROGRAM-DATE-TIME', frag.rawProgramDateTime]);\n\n        if (firstPdtIndex === -1) {\n          firstPdtIndex = fragments.length;\n        }\n      } else {\n        result = result[0].match(LEVEL_PLAYLIST_REGEX_SLOW);\n\n        if (!result) {\n          _utils_logger__WEBPACK_IMPORTED_MODULE_6__[\"logger\"].warn('No matches on slow regex match for level playlist!');\n          continue;\n        }\n\n        for (i = 1; i < result.length; i++) {\n          if (typeof result[i] !== 'undefined') {\n            break;\n          }\n        } // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939\n\n\n        var tag = (' ' + result[i]).slice(1);\n        var value1 = (' ' + result[i + 1]).slice(1);\n        var value2 = result[i + 2] ? (' ' + result[i + 2]).slice(1) : '';\n\n        switch (tag) {\n          case 'PLAYLIST-TYPE':\n            level.type = value1.toUpperCase();\n            break;\n\n          case 'MEDIA-SEQUENCE':\n            currentSN = level.startSN = parseInt(value1);\n            break;\n\n          case 'SKIP':\n            {\n              var skipAttrs = new _utils_attr_list__WEBPACK_IMPORTED_MODULE_5__[\"AttrList\"](value1);\n              var skippedSegments = skipAttrs.decimalInteger('SKIPPED-SEGMENTS');\n\n              if (Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__[\"isFiniteNumber\"])(skippedSegments)) {\n                level.skippedSegments = skippedSegments; // This will result in fragments[] containing undefined values, which we will fill in with `mergeDetails`\n\n                for (var _i = skippedSegments; _i--;) {\n                  fragments.unshift(null);\n                }\n\n                currentSN += skippedSegments;\n              }\n\n              var recentlyRemovedDateranges = skipAttrs.enumeratedString('RECENTLY-REMOVED-DATERANGES');\n\n              if (recentlyRemovedDateranges) {\n                level.recentlyRemovedDateranges = recentlyRemovedDateranges.split('\\t');\n              }\n\n              break;\n            }\n\n          case 'TARGETDURATION':\n            level.targetduration = parseFloat(value1);\n            break;\n\n          case 'VERSION':\n            level.version = parseInt(value1);\n            break;\n\n          case 'EXTM3U':\n            break;\n\n          case 'ENDLIST':\n            level.live = false;\n            break;\n\n          case '#':\n            if (value1 || value2) {\n              frag.tagList.push(value2 ? [value1, value2] : [value1]);\n            }\n\n            break;\n\n          case 'DIS':\n            discontinuityCounter++;\n\n          /* falls through */\n\n          case 'GAP':\n            frag.tagList.push([tag]);\n            break;\n\n          case 'BITRATE':\n            frag.tagList.push([tag, value1]);\n            break;\n\n          case 'DISCONTINUITY-SEQ':\n            discontinuityCounter = parseInt(value1);\n            break;\n\n          case 'KEY':\n            {\n              var _keyAttrs$enumeratedS;\n\n              // https://tools.ietf.org/html/rfc8216#section-4.3.2.4\n              var keyAttrs = new _utils_attr_list__WEBPACK_IMPORTED_MODULE_5__[\"AttrList\"](value1);\n              var decryptmethod = keyAttrs.enumeratedString('METHOD');\n              var decrypturi = keyAttrs.URI;\n              var decryptiv = keyAttrs.hexadecimalInteger('IV');\n              var decryptkeyformatversions = keyAttrs.enumeratedString('KEYFORMATVERSIONS');\n              var decryptkeyid = keyAttrs.enumeratedString('KEYID'); // From RFC: This attribute is OPTIONAL; its absence indicates an implicit value of \"identity\".\n\n              var decryptkeyformat = (_keyAttrs$enumeratedS = keyAttrs.enumeratedString('KEYFORMAT')) != null ? _keyAttrs$enumeratedS : 'identity';\n              var unsupportedKnownKeyformatsInManifest = ['com.apple.streamingkeydelivery', 'com.microsoft.playready', 'urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed', // widevine (v2)\n              'com.widevine' // earlier widevine (v1)\n              ];\n\n              if (unsupportedKnownKeyformatsInManifest.indexOf(decryptkeyformat) > -1) {\n                _utils_logger__WEBPACK_IMPORTED_MODULE_6__[\"logger\"].warn(\"Keyformat \" + decryptkeyformat + \" is not supported from the manifest\");\n                continue;\n              } else if (decryptkeyformat !== 'identity') {\n                // We are supposed to skip keys we don't understand.\n                // As we currently only officially support identity keys\n                // from the manifest we shouldn't save any other key.\n                continue;\n              } // TODO: multiple keys can be defined on a fragment, and we need to support this\n              // for clients that support both playready and widevine\n\n\n              if (decryptmethod) {\n                // TODO: need to determine if the level key is actually a relative URL\n                // if it isn't, then we should instead construct the LevelKey using fromURI.\n                levelkey = _level_key__WEBPACK_IMPORTED_MODULE_4__[\"LevelKey\"].fromURL(baseurl, decrypturi);\n\n                if (decrypturi && ['AES-128', 'SAMPLE-AES', 'SAMPLE-AES-CENC'].indexOf(decryptmethod) >= 0) {\n                  levelkey.method = decryptmethod;\n                  levelkey.keyFormat = decryptkeyformat;\n\n                  if (decryptkeyid) {\n                    levelkey.keyID = decryptkeyid;\n                  }\n\n                  if (decryptkeyformatversions) {\n                    levelkey.keyFormatVersions = decryptkeyformatversions;\n                  } // Initialization Vector (IV)\n\n\n                  levelkey.iv = decryptiv;\n                }\n              }\n\n              break;\n            }\n\n          case 'START':\n            {\n              var startAttrs = new _utils_attr_list__WEBPACK_IMPORTED_MODULE_5__[\"AttrList\"](value1);\n              var startTimeOffset = startAttrs.decimalFloatingPoint('TIME-OFFSET'); // TIME-OFFSET can be 0\n\n              if (Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__[\"isFiniteNumber\"])(startTimeOffset)) {\n                level.startTimeOffset = startTimeOffset;\n              }\n\n              break;\n            }\n\n          case 'MAP':\n            {\n              var mapAttrs = new _utils_attr_list__WEBPACK_IMPORTED_MODULE_5__[\"AttrList\"](value1);\n              frag.relurl = mapAttrs.URI;\n\n              if (mapAttrs.BYTERANGE) {\n                frag.setByteRange(mapAttrs.BYTERANGE);\n              }\n\n              frag.level = id;\n              frag.sn = 'initSegment';\n\n              if (levelkey) {\n                frag.levelkey = levelkey;\n              }\n\n              frag.initSegment = null;\n              currentInitSegment = frag;\n              createNextFrag = true;\n              break;\n            }\n\n          case 'SERVER-CONTROL':\n            {\n              var serverControlAttrs = new _utils_attr_list__WEBPACK_IMPORTED_MODULE_5__[\"AttrList\"](value1);\n              level.canBlockReload = serverControlAttrs.bool('CAN-BLOCK-RELOAD');\n              level.canSkipUntil = serverControlAttrs.optionalFloat('CAN-SKIP-UNTIL', 0);\n              level.canSkipDateRanges = level.canSkipUntil > 0 && serverControlAttrs.bool('CAN-SKIP-DATERANGES');\n              level.partHoldBack = serverControlAttrs.optionalFloat('PART-HOLD-BACK', 0);\n              level.holdBack = serverControlAttrs.optionalFloat('HOLD-BACK', 0);\n              break;\n            }\n\n          case 'PART-INF':\n            {\n              var partInfAttrs = new _utils_attr_list__WEBPACK_IMPORTED_MODULE_5__[\"AttrList\"](value1);\n              level.partTarget = partInfAttrs.decimalFloatingPoint('PART-TARGET');\n              break;\n            }\n\n          case 'PART':\n            {\n              var partList = level.partList;\n\n              if (!partList) {\n                partList = level.partList = [];\n              }\n\n              var previousFragmentPart = currentPart > 0 ? partList[partList.length - 1] : undefined;\n              var index = currentPart++;\n              var part = new _fragment__WEBPACK_IMPORTED_MODULE_2__[\"Part\"](new _utils_attr_list__WEBPACK_IMPORTED_MODULE_5__[\"AttrList\"](value1), frag, baseurl, index, previousFragmentPart);\n              partList.push(part);\n              frag.duration += part.duration;\n              break;\n            }\n\n          case 'PRELOAD-HINT':\n            {\n              var preloadHintAttrs = new _utils_attr_list__WEBPACK_IMPORTED_MODULE_5__[\"AttrList\"](value1);\n              level.preloadHint = preloadHintAttrs;\n              break;\n            }\n\n          case 'RENDITION-REPORT':\n            {\n              var renditionReportAttrs = new _utils_attr_list__WEBPACK_IMPORTED_MODULE_5__[\"AttrList\"](value1);\n              level.renditionReports = level.renditionReports || [];\n              level.renditionReports.push(renditionReportAttrs);\n              break;\n            }\n\n          default:\n            _utils_logger__WEBPACK_IMPORTED_MODULE_6__[\"logger\"].warn(\"line parsed but not handled: \" + result);\n            break;\n        }\n      }\n    }\n\n    if (prevFrag && !prevFrag.relurl) {\n      fragments.pop();\n      totalduration -= prevFrag.duration;\n\n      if (level.partList) {\n        level.fragmentHint = prevFrag;\n      }\n    } else if (level.partList) {\n      assignProgramDateTime(frag, prevFrag);\n      frag.cc = discontinuityCounter;\n      level.fragmentHint = frag;\n    }\n\n    var fragmentLength = fragments.length;\n    var firstFragment = fragments[0];\n    var lastFragment = fragments[fragmentLength - 1];\n    totalduration += level.skippedSegments * level.targetduration;\n\n    if (totalduration > 0 && fragmentLength && lastFragment) {\n      level.averagetargetduration = totalduration / fragmentLength;\n      var lastSn = lastFragment.sn;\n      level.endSN = lastSn !== 'initSegment' ? lastSn : 0;\n\n      if (firstFragment) {\n        level.startCC = firstFragment.cc;\n\n        if (!firstFragment.initSegment) {\n          // this is a bit lurky but HLS really has no other way to tell us\n          // if the fragments are TS or MP4, except if we download them :/\n          // but this is to be able to handle SIDX.\n          if (level.fragments.every(function (frag) {\n            return frag.relurl && isMP4Url(frag.relurl);\n          })) {\n            _utils_logger__WEBPACK_IMPORTED_MODULE_6__[\"logger\"].warn('MP4 fragments found but no init segment (probably no MAP, incomplete M3U8), trying to fetch SIDX');\n            frag = new _fragment__WEBPACK_IMPORTED_MODULE_2__[\"Fragment\"](type, baseurl);\n            frag.relurl = lastFragment.relurl;\n            frag.level = id;\n            frag.sn = 'initSegment';\n            firstFragment.initSegment = frag;\n            level.needSidxRanges = true;\n          }\n        }\n      }\n    } else {\n      level.endSN = 0;\n      level.startCC = 0;\n    }\n\n    if (level.fragmentHint) {\n      totalduration += level.fragmentHint.duration;\n    }\n\n    level.totalduration = totalduration;\n    level.endCC = discontinuityCounter;\n    /**\n     * Backfill any missing PDT values\n     * \"If the first EXT-X-PROGRAM-DATE-TIME tag in a Playlist appears after\n     * one or more Media Segment URIs, the client SHOULD extrapolate\n     * backward from that tag (using EXTINF durations and/or media\n     * timestamps) to associate dates with those segments.\"\n     * We have already extrapolated forward, but all fragments up to the first instance of PDT do not have their PDTs\n     * computed.\n     */\n\n    if (firstPdtIndex > 0) {\n      backfillProgramDateTimes(fragments, firstPdtIndex);\n    }\n\n    return level;\n  };\n\n  return M3U8Parser;\n}();\n\n\n\nfunction setCodecs(codecs, level) {\n  ['video', 'audio', 'text'].forEach(function (type) {\n    var filtered = codecs.filter(function (codec) {\n      return Object(_utils_codecs__WEBPACK_IMPORTED_MODULE_7__[\"isCodecType\"])(codec, type);\n    });\n\n    if (filtered.length) {\n      var preferred = filtered.filter(function (codec) {\n        return codec.lastIndexOf('avc1', 0) === 0 || codec.lastIndexOf('mp4a', 0) === 0;\n      });\n      level[type + \"Codec\"] = preferred.length > 0 ? preferred[0] : filtered[0]; // remove from list\n\n      codecs = codecs.filter(function (codec) {\n        return filtered.indexOf(codec) === -1;\n      });\n    }\n  });\n  level.unknownCodecs = codecs;\n}\n\nfunction assignCodec(media, groupItem, codecProperty) {\n  var codecValue = groupItem[codecProperty];\n\n  if (codecValue) {\n    media[codecProperty] = codecValue;\n  }\n}\n\nfunction backfillProgramDateTimes(fragments, firstPdtIndex) {\n  var fragPrev = fragments[firstPdtIndex];\n\n  for (var i = firstPdtIndex; i--;) {\n    var frag = fragments[i]; // Exit on delta-playlist skipped segments\n\n    if (!frag) {\n      return;\n    }\n\n    frag.programDateTime = fragPrev.programDateTime - frag.duration * 1000;\n    fragPrev = frag;\n  }\n}\n\nfunction assignProgramDateTime(frag, prevFrag) {\n  if (frag.rawProgramDateTime) {\n    frag.programDateTime = Date.parse(frag.rawProgramDateTime);\n  } else if (prevFrag !== null && prevFrag !== void 0 && prevFrag.programDateTime) {\n    frag.programDateTime = prevFrag.endProgramDateTime;\n  }\n\n  if (!Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__[\"isFiniteNumber\"])(frag.programDateTime)) {\n    frag.programDateTime = null;\n    frag.rawProgramDateTime = null;\n  }\n}\n\n/***/ }),\n\n/***/ \"./src/loader/playlist-loader.ts\":\n/*!***************************************!*\\\n  !*** ./src/loader/playlist-loader.ts ***!\n  \\***************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_728000__) {\n\n\"use strict\";\n__nested_webpack_require_728000__.r(__webpack_exports__);\n/* harmony import */ var _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_728000__(/*! ./src/polyfills/number */ \"./src/polyfills/number.ts\");\n/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_728000__(/*! ../events */ \"./src/events.ts\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_728000__(/*! ../errors */ \"./src/errors.ts\");\n/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_728000__(/*! ../utils/logger */ \"./src/utils/logger.ts\");\n/* harmony import */ var _utils_mp4_tools__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_728000__(/*! ../utils/mp4-tools */ \"./src/utils/mp4-tools.ts\");\n/* harmony import */ var _m3u8_parser__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_728000__(/*! ./m3u8-parser */ \"./src/loader/m3u8-parser.ts\");\n/* harmony import */ var _types_loader__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_728000__(/*! ../types/loader */ \"./src/types/loader.ts\");\n/* harmony import */ var _utils_attr_list__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_728000__(/*! ../utils/attr-list */ \"./src/utils/attr-list.ts\");\n\n\n\n/**\n * PlaylistLoader - delegate for media manifest/playlist loading tasks. Takes care of parsing media to internal data-models.\n *\n * Once loaded, dispatches events with parsed data-models of manifest/levels/audio/subtitle tracks.\n *\n * Uses loader(s) set in config to do actual internal loading of resource tasks.\n *\n * @module\n *\n */\n\n\n\n\n\n\n\n\nfunction mapContextToLevelType(context) {\n  var type = context.type;\n\n  switch (type) {\n    case _types_loader__WEBPACK_IMPORTED_MODULE_6__[\"PlaylistContextType\"].AUDIO_TRACK:\n      return _types_loader__WEBPACK_IMPORTED_MODULE_6__[\"PlaylistLevelType\"].AUDIO;\n\n    case _types_loader__WEBPACK_IMPORTED_MODULE_6__[\"PlaylistContextType\"].SUBTITLE_TRACK:\n      return _types_loader__WEBPACK_IMPORTED_MODULE_6__[\"PlaylistLevelType\"].SUBTITLE;\n\n    default:\n      return _types_loader__WEBPACK_IMPORTED_MODULE_6__[\"PlaylistLevelType\"].MAIN;\n  }\n}\n\nfunction getResponseUrl(response, context) {\n  var url = response.url; // responseURL not supported on some browsers (it is used to detect URL redirection)\n  // data-uri mode also not supported (but no need to detect redirection)\n\n  if (url === undefined || url.indexOf('data:') === 0) {\n    // fallback to initial URL\n    url = context.url;\n  }\n\n  return url;\n}\n\nvar PlaylistLoader = /*#__PURE__*/function () {\n  function PlaylistLoader(hls) {\n    this.hls = void 0;\n    this.loaders = Object.create(null);\n    this.hls = hls;\n    this.registerListeners();\n  }\n\n  var _proto = PlaylistLoader.prototype;\n\n  _proto.registerListeners = function registerListeners() {\n    var hls = this.hls;\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].LEVEL_LOADING, this.onLevelLoading, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].AUDIO_TRACK_LOADING, this.onAudioTrackLoading, this);\n    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].SUBTITLE_TRACK_LOADING, this.onSubtitleTrackLoading, this);\n  };\n\n  _proto.unregisterListeners = function unregisterListeners() {\n    var hls = this.hls;\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].LEVEL_LOADING, this.onLevelLoading, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].AUDIO_TRACK_LOADING, this.onAudioTrackLoading, this);\n    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].SUBTITLE_TRACK_LOADING, this.onSubtitleTrackLoading, this);\n  }\n  /**\n   * Returns defaults or configured loader-type overloads (pLoader and loader config params)\n   */\n  ;\n\n  _proto.createInternalLoader = function createInternalLoader(context) {\n    var config = this.hls.config;\n    var PLoader = config.pLoader;\n    var Loader = config.loader;\n    var InternalLoader = PLoader || Loader;\n    var loader = new InternalLoader(config);\n    context.loader = loader;\n    this.loaders[context.type] = loader;\n    return loader;\n  };\n\n  _proto.getInternalLoader = function getInternalLoader(context) {\n    return this.loaders[context.type];\n  };\n\n  _proto.resetInternalLoader = function resetInternalLoader(contextType) {\n    if (this.loaders[contextType]) {\n      delete this.loaders[contextType];\n    }\n  }\n  /**\n   * Call `destroy` on all internal loader instances mapped (one per context type)\n   */\n  ;\n\n  _proto.destroyInternalLoaders = function destroyInternalLoaders() {\n    for (var contextType in this.loaders) {\n      var loader = this.loaders[contextType];\n\n      if (loader) {\n        loader.destroy();\n      }\n\n      this.resetInternalLoader(contextType);\n    }\n  };\n\n  _proto.destroy = function destroy() {\n    this.unregisterListeners();\n    this.destroyInternalLoaders();\n  };\n\n  _proto.onManifestLoading = function onManifestLoading(event, data) {\n    var url = data.url;\n    this.load({\n      id: null,\n      groupId: null,\n      level: 0,\n      responseType: 'text',\n      type: _types_loader__WEBPACK_IMPORTED_MODULE_6__[\"PlaylistContextType\"].MANIFEST,\n      url: url,\n      deliveryDirectives: null\n    });\n  };\n\n  _proto.onLevelLoading = function onLevelLoading(event, data) {\n    var id = data.id,\n        level = data.level,\n        url = data.url,\n        deliveryDirectives = data.deliveryDirectives;\n    this.load({\n      id: id,\n      groupId: null,\n      level: level,\n      responseType: 'text',\n      type: _types_loader__WEBPACK_IMPORTED_MODULE_6__[\"PlaylistContextType\"].LEVEL,\n      url: url,\n      deliveryDirectives: deliveryDirectives\n    });\n  };\n\n  _proto.onAudioTrackLoading = function onAudioTrackLoading(event, data) {\n    var id = data.id,\n        groupId = data.groupId,\n        url = data.url,\n        deliveryDirectives = data.deliveryDirectives;\n    this.load({\n      id: id,\n      groupId: groupId,\n      level: null,\n      responseType: 'text',\n      type: _types_loader__WEBPACK_IMPORTED_MODULE_6__[\"PlaylistContextType\"].AUDIO_TRACK,\n      url: url,\n      deliveryDirectives: deliveryDirectives\n    });\n  };\n\n  _proto.onSubtitleTrackLoading = function onSubtitleTrackLoading(event, data) {\n    var id = data.id,\n        groupId = data.groupId,\n        url = data.url,\n        deliveryDirectives = data.deliveryDirectives;\n    this.load({\n      id: id,\n      groupId: groupId,\n      level: null,\n      responseType: 'text',\n      type: _types_loader__WEBPACK_IMPORTED_MODULE_6__[\"PlaylistContextType\"].SUBTITLE_TRACK,\n      url: url,\n      deliveryDirectives: deliveryDirectives\n    });\n  };\n\n  _proto.load = function load(context) {\n    var _context$deliveryDire;\n\n    var config = this.hls.config; // logger.debug(`[playlist-loader]: Loading playlist of type ${context.type}, level: ${context.level}, id: ${context.id}`);\n    // Check if a loader for this context already exists\n\n    var loader = this.getInternalLoader(context);\n\n    if (loader) {\n      var loaderContext = loader.context;\n\n      if (loaderContext && loaderContext.url === context.url) {\n        // same URL can't overlap\n        _utils_logger__WEBPACK_IMPORTED_MODULE_3__[\"logger\"].trace('[playlist-loader]: playlist request ongoing');\n        return;\n      }\n\n      _utils_logger__WEBPACK_IMPORTED_MODULE_3__[\"logger\"].log(\"[playlist-loader]: aborting previous loader for type: \" + context.type);\n      loader.abort();\n    }\n\n    var maxRetry;\n    var timeout;\n    var retryDelay;\n    var maxRetryDelay; // apply different configs for retries depending on\n    // context (manifest, level, audio/subs playlist)\n\n    switch (context.type) {\n      case _types_loader__WEBPACK_IMPORTED_MODULE_6__[\"PlaylistContextType\"].MANIFEST:\n        maxRetry = config.manifestLoadingMaxRetry;\n        timeout = config.manifestLoadingTimeOut;\n        retryDelay = config.manifestLoadingRetryDelay;\n        maxRetryDelay = config.manifestLoadingMaxRetryTimeout;\n        break;\n\n      case _types_loader__WEBPACK_IMPORTED_MODULE_6__[\"PlaylistContextType\"].LEVEL:\n      case _types_loader__WEBPACK_IMPORTED_MODULE_6__[\"PlaylistContextType\"].AUDIO_TRACK:\n      case _types_loader__WEBPACK_IMPORTED_MODULE_6__[\"PlaylistContextType\"].SUBTITLE_TRACK:\n        // Manage retries in Level/Track Controller\n        maxRetry = 0;\n        timeout = config.levelLoadingTimeOut;\n        break;\n\n      default:\n        maxRetry = config.levelLoadingMaxRetry;\n        timeout = config.levelLoadingTimeOut;\n        retryDelay = config.levelLoadingRetryDelay;\n        maxRetryDelay = config.levelLoadingMaxRetryTimeout;\n        break;\n    }\n\n    loader = this.createInternalLoader(context); // Override level/track timeout for LL-HLS requests\n    // (the default of 10000ms is counter productive to blocking playlist reload requests)\n\n    if ((_context$deliveryDire = context.deliveryDirectives) !== null && _context$deliveryDire !== void 0 && _context$deliveryDire.part) {\n      var levelDetails;\n\n      if (context.type === _types_loader__WEBPACK_IMPORTED_MODULE_6__[\"PlaylistContextType\"].LEVEL && context.level !== null) {\n        levelDetails = this.hls.levels[context.level].details;\n      } else if (context.type === _types_loader__WEBPACK_IMPORTED_MODULE_6__[\"PlaylistContextType\"].AUDIO_TRACK && context.id !== null) {\n        levelDetails = this.hls.audioTracks[context.id].details;\n      } else if (context.type === _types_loader__WEBPACK_IMPORTED_MODULE_6__[\"PlaylistContextType\"].SUBTITLE_TRACK && context.id !== null) {\n        levelDetails = this.hls.subtitleTracks[context.id].details;\n      }\n\n      if (levelDetails) {\n        var partTarget = levelDetails.partTarget;\n        var targetDuration = levelDetails.targetduration;\n\n        if (partTarget && targetDuration) {\n          timeout = Math.min(Math.max(partTarget * 3, targetDuration * 0.8) * 1000, timeout);\n        }\n      }\n    }\n\n    var loaderConfig = {\n      timeout: timeout,\n      maxRetry: maxRetry,\n      retryDelay: retryDelay,\n      maxRetryDelay: maxRetryDelay,\n      highWaterMark: 0\n    };\n    var loaderCallbacks = {\n      onSuccess: this.loadsuccess.bind(this),\n      onError: this.loaderror.bind(this),\n      onTimeout: this.loadtimeout.bind(this)\n    }; // logger.debug(`[playlist-loader]: Calling internal loader delegate for URL: ${context.url}`);\n\n    loader.load(context, loaderConfig, loaderCallbacks);\n  };\n\n  _proto.loadsuccess = function loadsuccess(response, stats, context, networkDetails) {\n    if (networkDetails === void 0) {\n      networkDetails = null;\n    }\n\n    if (context.isSidxRequest) {\n      this.handleSidxRequest(response, context);\n      this.handlePlaylistLoaded(response, stats, context, networkDetails);\n      return;\n    }\n\n    this.resetInternalLoader(context.type);\n    var string = response.data; // Validate if it is an M3U8 at all\n\n    if (string.indexOf('#EXTM3U') !== 0) {\n      this.handleManifestParsingError(response, context, 'no EXTM3U delimiter', networkDetails);\n      return;\n    }\n\n    stats.parsing.start = performance.now(); // Check if chunk-list or master. handle empty chunk list case (first EXTINF not signaled, but TARGETDURATION present)\n\n    if (string.indexOf('#EXTINF:') > 0 || string.indexOf('#EXT-X-TARGETDURATION:') > 0) {\n      this.handleTrackOrLevelPlaylist(response, stats, context, networkDetails);\n    } else {\n      this.handleMasterPlaylist(response, stats, context, networkDetails);\n    }\n  };\n\n  _proto.loaderror = function loaderror(response, context, networkDetails) {\n    if (networkDetails === void 0) {\n      networkDetails = null;\n    }\n\n    this.handleNetworkError(context, networkDetails, false, response);\n  };\n\n  _proto.loadtimeout = function loadtimeout(stats, context, networkDetails) {\n    if (networkDetails === void 0) {\n      networkDetails = null;\n    }\n\n    this.handleNetworkError(context, networkDetails, true);\n  };\n\n  _proto.handleMasterPlaylist = function handleMasterPlaylist(response, stats, context, networkDetails) {\n    var hls = this.hls;\n    var string = response.data;\n    var url = getResponseUrl(response, context);\n\n    var _M3U8Parser$parseMast = _m3u8_parser__WEBPACK_IMPORTED_MODULE_5__[\"default\"].parseMasterPlaylist(string, url),\n        levels = _M3U8Parser$parseMast.levels,\n        sessionData = _M3U8Parser$parseMast.sessionData;\n\n    if (!levels.length) {\n      this.handleManifestParsingError(response, context, 'no level found in manifest', networkDetails);\n      return;\n    } // multi level playlist, parse level info\n\n\n    var audioGroups = levels.map(function (level) {\n      return {\n        id: level.attrs.AUDIO,\n        audioCodec: level.audioCodec\n      };\n    });\n    var subtitleGroups = levels.map(function (level) {\n      return {\n        id: level.attrs.SUBTITLES,\n        textCodec: level.textCodec\n      };\n    });\n    var audioTracks = _m3u8_parser__WEBPACK_IMPORTED_MODULE_5__[\"default\"].parseMasterPlaylistMedia(string, url, 'AUDIO', audioGroups);\n    var subtitles = _m3u8_parser__WEBPACK_IMPORTED_MODULE_5__[\"default\"].parseMasterPlaylistMedia(string, url, 'SUBTITLES', subtitleGroups);\n    var captions = _m3u8_parser__WEBPACK_IMPORTED_MODULE_5__[\"default\"].parseMasterPlaylistMedia(string, url, 'CLOSED-CAPTIONS');\n\n    if (audioTracks.length) {\n      // check if we have found an audio track embedded in main playlist (audio track without URI attribute)\n      var embeddedAudioFound = audioTracks.some(function (audioTrack) {\n        return !audioTrack.url;\n      }); // if no embedded audio track defined, but audio codec signaled in quality level,\n      // we need to signal this main audio track this could happen with playlists with\n      // alt audio rendition in which quality levels (main)\n      // contains both audio+video. but with mixed audio track not signaled\n\n      if (!embeddedAudioFound && levels[0].audioCodec && !levels[0].attrs.AUDIO) {\n        _utils_logger__WEBPACK_IMPORTED_MODULE_3__[\"logger\"].log('[playlist-loader]: audio codec signaled in quality level, but no embedded audio track signaled, create one');\n        audioTracks.unshift({\n          type: 'main',\n          name: 'main',\n          default: false,\n          autoselect: false,\n          forced: false,\n          id: -1,\n          attrs: new _utils_attr_list__WEBPACK_IMPORTED_MODULE_7__[\"AttrList\"]({}),\n          bitrate: 0,\n          url: ''\n        });\n      }\n    }\n\n    hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].MANIFEST_LOADED, {\n      levels: levels,\n      audioTracks: audioTracks,\n      subtitles: subtitles,\n      captions: captions,\n      url: url,\n      stats: stats,\n      networkDetails: networkDetails,\n      sessionData: sessionData\n    });\n  };\n\n  _proto.handleTrackOrLevelPlaylist = function handleTrackOrLevelPlaylist(response, stats, context, networkDetails) {\n    var hls = this.hls;\n    var id = context.id,\n        level = context.level,\n        type = context.type;\n    var url = getResponseUrl(response, context);\n    var levelUrlId = Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__[\"isFiniteNumber\"])(id) ? id : 0;\n    var levelId = Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__[\"isFiniteNumber\"])(level) ? level : levelUrlId;\n    var levelType = mapContextToLevelType(context);\n    var levelDetails = _m3u8_parser__WEBPACK_IMPORTED_MODULE_5__[\"default\"].parseLevelPlaylist(response.data, url, levelId, levelType, levelUrlId);\n\n    if (!levelDetails.fragments.length) {\n      hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].ERROR, {\n        type: _errors__WEBPACK_IMPORTED_MODULE_2__[\"ErrorTypes\"].NETWORK_ERROR,\n        details: _errors__WEBPACK_IMPORTED_MODULE_2__[\"ErrorDetails\"].LEVEL_EMPTY_ERROR,\n        fatal: false,\n        url: url,\n        reason: 'no fragments found in level',\n        level: typeof context.level === 'number' ? context.level : undefined\n      });\n      return;\n    } // We have done our first request (Manifest-type) and receive\n    // not a master playlist but a chunk-list (track/level)\n    // We fire the manifest-loaded event anyway with the parsed level-details\n    // by creating a single-level structure for it.\n\n\n    if (type === _types_loader__WEBPACK_IMPORTED_MODULE_6__[\"PlaylistContextType\"].MANIFEST) {\n      var singleLevel = {\n        attrs: new _utils_attr_list__WEBPACK_IMPORTED_MODULE_7__[\"AttrList\"]({}),\n        bitrate: 0,\n        details: levelDetails,\n        name: '',\n        url: url\n      };\n      hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].MANIFEST_LOADED, {\n        levels: [singleLevel],\n        audioTracks: [],\n        url: url,\n        stats: stats,\n        networkDetails: networkDetails,\n        sessionData: null\n      });\n    } // save parsing time\n\n\n    stats.parsing.end = performance.now(); // in case we need SIDX ranges\n    // return early after calling load for\n    // the SIDX box.\n\n    if (levelDetails.needSidxRanges) {\n      var _levelDetails$fragmen;\n\n      var sidxUrl = (_levelDetails$fragmen = levelDetails.fragments[0].initSegment) === null || _levelDetails$fragmen === void 0 ? void 0 : _levelDetails$fragmen.url;\n      this.load({\n        url: sidxUrl,\n        isSidxRequest: true,\n        type: type,\n        level: level,\n        levelDetails: levelDetails,\n        id: id,\n        groupId: null,\n        rangeStart: 0,\n        rangeEnd: 2048,\n        responseType: 'arraybuffer',\n        deliveryDirectives: null\n      });\n      return;\n    } // extend the context with the new levelDetails property\n\n\n    context.levelDetails = levelDetails;\n    this.handlePlaylistLoaded(response, stats, context, networkDetails);\n  };\n\n  _proto.handleSidxRequest = function handleSidxRequest(response, context) {\n    var sidxInfo = Object(_utils_mp4_tools__WEBPACK_IMPORTED_MODULE_4__[\"parseSegmentIndex\"])(new Uint8Array(response.data)); // if provided fragment does not contain sidx, early return\n\n    if (!sidxInfo) {\n      return;\n    }\n\n    var sidxReferences = sidxInfo.references;\n    var levelDetails = context.levelDetails;\n    sidxReferences.forEach(function (segmentRef, index) {\n      var segRefInfo = segmentRef.info;\n      var frag = levelDetails.fragments[index];\n\n      if (frag.byteRange.length === 0) {\n        frag.setByteRange(String(1 + segRefInfo.end - segRefInfo.start) + '@' + String(segRefInfo.start));\n      }\n\n      if (frag.initSegment) {\n        frag.initSegment.setByteRange(String(sidxInfo.moovEndOffset) + '@0');\n      }\n    });\n  };\n\n  _proto.handleManifestParsingError = function handleManifestParsingError(response, context, reason, networkDetails) {\n    this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].ERROR, {\n      type: _errors__WEBPACK_IMPORTED_MODULE_2__[\"ErrorTypes\"].NETWORK_ERROR,\n      details: _errors__WEBPACK_IMPORTED_MODULE_2__[\"ErrorDetails\"].MANIFEST_PARSING_ERROR,\n      fatal: context.type === _types_loader__WEBPACK_IMPORTED_MODULE_6__[\"PlaylistContextType\"].MANIFEST,\n      url: response.url,\n      reason: reason,\n      response: response,\n      context: context,\n      networkDetails: networkDetails\n    });\n  };\n\n  _proto.handleNetworkError = function handleNetworkError(context, networkDetails, timeout, response) {\n    if (timeout === void 0) {\n      timeout = false;\n    }\n\n    _utils_logger__WEBPACK_IMPORTED_MODULE_3__[\"logger\"].warn(\"[playlist-loader]: A network \" + (timeout ? 'timeout' : 'error') + \" occurred while loading \" + context.type + \" level: \" + context.level + \" id: \" + context.id + \" group-id: \\\"\" + context.groupId + \"\\\"\");\n    var details = _errors__WEBPACK_IMPORTED_MODULE_2__[\"ErrorDetails\"].UNKNOWN;\n    var fatal = false;\n    var loader = this.getInternalLoader(context);\n\n    switch (context.type) {\n      case _types_loader__WEBPACK_IMPORTED_MODULE_6__[\"PlaylistContextType\"].MANIFEST:\n        details = timeout ? _errors__WEBPACK_IMPORTED_MODULE_2__[\"ErrorDetails\"].MANIFEST_LOAD_TIMEOUT : _errors__WEBPACK_IMPORTED_MODULE_2__[\"ErrorDetails\"].MANIFEST_LOAD_ERROR;\n        fatal = true;\n        break;\n\n      case _types_loader__WEBPACK_IMPORTED_MODULE_6__[\"PlaylistContextType\"].LEVEL:\n        details = timeout ? _errors__WEBPACK_IMPORTED_MODULE_2__[\"ErrorDetails\"].LEVEL_LOAD_TIMEOUT : _errors__WEBPACK_IMPORTED_MODULE_2__[\"ErrorDetails\"].LEVEL_LOAD_ERROR;\n        fatal = false;\n        break;\n\n      case _types_loader__WEBPACK_IMPORTED_MODULE_6__[\"PlaylistContextType\"].AUDIO_TRACK:\n        details = timeout ? _errors__WEBPACK_IMPORTED_MODULE_2__[\"ErrorDetails\"].AUDIO_TRACK_LOAD_TIMEOUT : _errors__WEBPACK_IMPORTED_MODULE_2__[\"ErrorDetails\"].AUDIO_TRACK_LOAD_ERROR;\n        fatal = false;\n        break;\n\n      case _types_loader__WEBPACK_IMPORTED_MODULE_6__[\"PlaylistContextType\"].SUBTITLE_TRACK:\n        details = timeout ? _errors__WEBPACK_IMPORTED_MODULE_2__[\"ErrorDetails\"].SUBTITLE_TRACK_LOAD_TIMEOUT : _errors__WEBPACK_IMPORTED_MODULE_2__[\"ErrorDetails\"].SUBTITLE_LOAD_ERROR;\n        fatal = false;\n        break;\n    }\n\n    if (loader) {\n      this.resetInternalLoader(context.type);\n    }\n\n    var errorData = {\n      type: _errors__WEBPACK_IMPORTED_MODULE_2__[\"ErrorTypes\"].NETWORK_ERROR,\n      details: details,\n      fatal: fatal,\n      url: context.url,\n      loader: loader,\n      context: context,\n      networkDetails: networkDetails\n    };\n\n    if (response) {\n      errorData.response = response;\n    }\n\n    this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].ERROR, errorData);\n  };\n\n  _proto.handlePlaylistLoaded = function handlePlaylistLoaded(response, stats, context, networkDetails) {\n    var type = context.type,\n        level = context.level,\n        id = context.id,\n        groupId = context.groupId,\n        loader = context.loader,\n        levelDetails = context.levelDetails,\n        deliveryDirectives = context.deliveryDirectives;\n\n    if (!(levelDetails !== null && levelDetails !== void 0 && levelDetails.targetduration)) {\n      this.handleManifestParsingError(response, context, 'invalid target duration', networkDetails);\n      return;\n    }\n\n    if (!loader) {\n      return;\n    }\n\n    if (levelDetails.live) {\n      if (loader.getCacheAge) {\n        levelDetails.ageHeader = loader.getCacheAge() || 0;\n      }\n\n      if (!loader.getCacheAge || isNaN(levelDetails.ageHeader)) {\n        levelDetails.ageHeader = 0;\n      }\n    }\n\n    switch (type) {\n      case _types_loader__WEBPACK_IMPORTED_MODULE_6__[\"PlaylistContextType\"].MANIFEST:\n      case _types_loader__WEBPACK_IMPORTED_MODULE_6__[\"PlaylistContextType\"].LEVEL:\n        this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].LEVEL_LOADED, {\n          details: levelDetails,\n          level: level || 0,\n          id: id || 0,\n          stats: stats,\n          networkDetails: networkDetails,\n          deliveryDirectives: deliveryDirectives\n        });\n        break;\n\n      case _types_loader__WEBPACK_IMPORTED_MODULE_6__[\"PlaylistContextType\"].AUDIO_TRACK:\n        this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].AUDIO_TRACK_LOADED, {\n          details: levelDetails,\n          id: id || 0,\n          groupId: groupId || '',\n          stats: stats,\n          networkDetails: networkDetails,\n          deliveryDirectives: deliveryDirectives\n        });\n        break;\n\n      case _types_loader__WEBPACK_IMPORTED_MODULE_6__[\"PlaylistContextType\"].SUBTITLE_TRACK:\n        this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__[\"Events\"].SUBTITLE_TRACK_LOADED, {\n          details: levelDetails,\n          id: id || 0,\n          groupId: groupId || '',\n          stats: stats,\n          networkDetails: networkDetails,\n          deliveryDirectives: deliveryDirectives\n        });\n        break;\n    }\n  };\n\n  return PlaylistLoader;\n}();\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (PlaylistLoader);\n\n/***/ }),\n\n/***/ \"./src/polyfills/number.ts\":\n/*!*********************************!*\\\n  !*** ./src/polyfills/number.ts ***!\n  \\*********************************/\n/*! exports provided: isFiniteNumber, MAX_SAFE_INTEGER */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_752181__) {\n\n\"use strict\";\n__nested_webpack_require_752181__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_752181__.d(__webpack_exports__, \"isFiniteNumber\", function() { return isFiniteNumber; });\n/* harmony export (binding) */ __nested_webpack_require_752181__.d(__webpack_exports__, \"MAX_SAFE_INTEGER\", function() { return MAX_SAFE_INTEGER; });\nvar isFiniteNumber = Number.isFinite || function (value) {\n  return typeof value === 'number' && isFinite(value);\n};\nvar MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;\n\n/***/ }),\n\n/***/ \"./src/remux/aac-helper.ts\":\n/*!*********************************!*\\\n  !*** ./src/remux/aac-helper.ts ***!\n  \\*********************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_752957__) {\n\n\"use strict\";\n__nested_webpack_require_752957__.r(__webpack_exports__);\n/**\n *  AAC helper\n */\nvar AAC = /*#__PURE__*/function () {\n  function AAC() {}\n\n  AAC.getSilentFrame = function getSilentFrame(codec, channelCount) {\n    switch (codec) {\n      case 'mp4a.40.2':\n        if (channelCount === 1) {\n          return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x23, 0x80]);\n        } else if (channelCount === 2) {\n          return new Uint8Array([0x21, 0x00, 0x49, 0x90, 0x02, 0x19, 0x00, 0x23, 0x80]);\n        } else if (channelCount === 3) {\n          return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x8e]);\n        } else if (channelCount === 4) {\n          return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x80, 0x2c, 0x80, 0x08, 0x02, 0x38]);\n        } else if (channelCount === 5) {\n          return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x82, 0x30, 0x04, 0x99, 0x00, 0x21, 0x90, 0x02, 0x38]);\n        } else if (channelCount === 6) {\n          return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x82, 0x30, 0x04, 0x99, 0x00, 0x21, 0x90, 0x02, 0x00, 0xb2, 0x00, 0x20, 0x08, 0xe0]);\n        }\n\n        break;\n      // handle HE-AAC below (mp4a.40.5 / mp4a.40.29)\n\n      default:\n        if (channelCount === 1) {\n          // ffmpeg -y -f lavfi -i \"aevalsrc=0:d=0.05\" -c:a libfdk_aac -profile:a aac_he -b:a 4k output.aac && hexdump -v -e '16/1 \"0x%x,\" \"\\n\"' -v output.aac\n          return new Uint8Array([0x1, 0x40, 0x22, 0x80, 0xa3, 0x4e, 0xe6, 0x80, 0xba, 0x8, 0x0, 0x0, 0x0, 0x1c, 0x6, 0xf1, 0xc1, 0xa, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5e]);\n        } else if (channelCount === 2) {\n          // ffmpeg -y -f lavfi -i \"aevalsrc=0|0:d=0.05\" -c:a libfdk_aac -profile:a aac_he_v2 -b:a 4k output.aac && hexdump -v -e '16/1 \"0x%x,\" \"\\n\"' -v output.aac\n          return new Uint8Array([0x1, 0x40, 0x22, 0x80, 0xa3, 0x5e, 0xe6, 0x80, 0xba, 0x8, 0x0, 0x0, 0x0, 0x0, 0x95, 0x0, 0x6, 0xf1, 0xa1, 0xa, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5e]);\n        } else if (channelCount === 3) {\n          // ffmpeg -y -f lavfi -i \"aevalsrc=0|0|0:d=0.05\" -c:a libfdk_aac -profile:a aac_he_v2 -b:a 4k output.aac && hexdump -v -e '16/1 \"0x%x,\" \"\\n\"' -v output.aac\n          return new Uint8Array([0x1, 0x40, 0x22, 0x80, 0xa3, 0x5e, 0xe6, 0x80, 0xba, 0x8, 0x0, 0x0, 0x0, 0x0, 0x95, 0x0, 0x6, 0xf1, 0xa1, 0xa, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5e]);\n        }\n\n        break;\n    }\n\n    return undefined;\n  };\n\n  return AAC;\n}();\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (AAC);\n\n/***/ }),\n\n/***/ \"./src/remux/mp4-generator.ts\":\n/*!************************************!*\\\n  !*** ./src/remux/mp4-generator.ts ***!\n  \\************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_756488__) {\n\n\"use strict\";\n__nested_webpack_require_756488__.r(__webpack_exports__);\n/**\n * Generate MP4 Box\n */\nvar UINT32_MAX = Math.pow(2, 32) - 1;\n\nvar MP4 = /*#__PURE__*/function () {\n  function MP4() {}\n\n  MP4.init = function init() {\n    MP4.types = {\n      avc1: [],\n      // codingname\n      avcC: [],\n      btrt: [],\n      dinf: [],\n      dref: [],\n      esds: [],\n      ftyp: [],\n      hdlr: [],\n      mdat: [],\n      mdhd: [],\n      mdia: [],\n      mfhd: [],\n      minf: [],\n      moof: [],\n      moov: [],\n      mp4a: [],\n      '.mp3': [],\n      mvex: [],\n      mvhd: [],\n      pasp: [],\n      sdtp: [],\n      stbl: [],\n      stco: [],\n      stsc: [],\n      stsd: [],\n      stsz: [],\n      stts: [],\n      tfdt: [],\n      tfhd: [],\n      traf: [],\n      trak: [],\n      trun: [],\n      trex: [],\n      tkhd: [],\n      vmhd: [],\n      smhd: []\n    };\n    var i;\n\n    for (i in MP4.types) {\n      if (MP4.types.hasOwnProperty(i)) {\n        MP4.types[i] = [i.charCodeAt(0), i.charCodeAt(1), i.charCodeAt(2), i.charCodeAt(3)];\n      }\n    }\n\n    var videoHdlr = new Uint8Array([0x00, // version 0\n    0x00, 0x00, 0x00, // flags\n    0x00, 0x00, 0x00, 0x00, // pre_defined\n    0x76, 0x69, 0x64, 0x65, // handler_type: 'vide'\n    0x00, 0x00, 0x00, 0x00, // reserved\n    0x00, 0x00, 0x00, 0x00, // reserved\n    0x00, 0x00, 0x00, 0x00, // reserved\n    0x56, 0x69, 0x64, 0x65, 0x6f, 0x48, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x72, 0x00 // name: 'VideoHandler'\n    ]);\n    var audioHdlr = new Uint8Array([0x00, // version 0\n    0x00, 0x00, 0x00, // flags\n    0x00, 0x00, 0x00, 0x00, // pre_defined\n    0x73, 0x6f, 0x75, 0x6e, // handler_type: 'soun'\n    0x00, 0x00, 0x00, 0x00, // reserved\n    0x00, 0x00, 0x00, 0x00, // reserved\n    0x00, 0x00, 0x00, 0x00, // reserved\n    0x53, 0x6f, 0x75, 0x6e, 0x64, 0x48, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x72, 0x00 // name: 'SoundHandler'\n    ]);\n    MP4.HDLR_TYPES = {\n      video: videoHdlr,\n      audio: audioHdlr\n    };\n    var dref = new Uint8Array([0x00, // version 0\n    0x00, 0x00, 0x00, // flags\n    0x00, 0x00, 0x00, 0x01, // entry_count\n    0x00, 0x00, 0x00, 0x0c, // entry_size\n    0x75, 0x72, 0x6c, 0x20, // 'url' type\n    0x00, // version 0\n    0x00, 0x00, 0x01 // entry_flags\n    ]);\n    var stco = new Uint8Array([0x00, // version\n    0x00, 0x00, 0x00, // flags\n    0x00, 0x00, 0x00, 0x00 // entry_count\n    ]);\n    MP4.STTS = MP4.STSC = MP4.STCO = stco;\n    MP4.STSZ = new Uint8Array([0x00, // version\n    0x00, 0x00, 0x00, // flags\n    0x00, 0x00, 0x00, 0x00, // sample_size\n    0x00, 0x00, 0x00, 0x00 // sample_count\n    ]);\n    MP4.VMHD = new Uint8Array([0x00, // version\n    0x00, 0x00, 0x01, // flags\n    0x00, 0x00, // graphicsmode\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00 // opcolor\n    ]);\n    MP4.SMHD = new Uint8Array([0x00, // version\n    0x00, 0x00, 0x00, // flags\n    0x00, 0x00, // balance\n    0x00, 0x00 // reserved\n    ]);\n    MP4.STSD = new Uint8Array([0x00, // version 0\n    0x00, 0x00, 0x00, // flags\n    0x00, 0x00, 0x00, 0x01]); // entry_count\n\n    var majorBrand = new Uint8Array([105, 115, 111, 109]); // isom\n\n    var avc1Brand = new Uint8Array([97, 118, 99, 49]); // avc1\n\n    var minorVersion = new Uint8Array([0, 0, 0, 1]);\n    MP4.FTYP = MP4.box(MP4.types.ftyp, majorBrand, minorVersion, majorBrand, avc1Brand);\n    MP4.DINF = MP4.box(MP4.types.dinf, MP4.box(MP4.types.dref, dref));\n  };\n\n  MP4.box = function box(type) {\n    var size = 8;\n\n    for (var _len = arguments.length, payload = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      payload[_key - 1] = arguments[_key];\n    }\n\n    var i = payload.length;\n    var len = i; // calculate the total size we need to allocate\n\n    while (i--) {\n      size += payload[i].byteLength;\n    }\n\n    var result = new Uint8Array(size);\n    result[0] = size >> 24 & 0xff;\n    result[1] = size >> 16 & 0xff;\n    result[2] = size >> 8 & 0xff;\n    result[3] = size & 0xff;\n    result.set(type, 4); // copy the payload into the result\n\n    for (i = 0, size = 8; i < len; i++) {\n      // copy payload[i] array @ offset size\n      result.set(payload[i], size);\n      size += payload[i].byteLength;\n    }\n\n    return result;\n  };\n\n  MP4.hdlr = function hdlr(type) {\n    return MP4.box(MP4.types.hdlr, MP4.HDLR_TYPES[type]);\n  };\n\n  MP4.mdat = function mdat(data) {\n    return MP4.box(MP4.types.mdat, data);\n  };\n\n  MP4.mdhd = function mdhd(timescale, duration) {\n    duration *= timescale;\n    var upperWordDuration = Math.floor(duration / (UINT32_MAX + 1));\n    var lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));\n    return MP4.box(MP4.types.mdhd, new Uint8Array([0x01, // version 1\n    0x00, 0x00, 0x00, // flags\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // creation_time\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, // modification_time\n    timescale >> 24 & 0xff, timescale >> 16 & 0xff, timescale >> 8 & 0xff, timescale & 0xff, // timescale\n    upperWordDuration >> 24, upperWordDuration >> 16 & 0xff, upperWordDuration >> 8 & 0xff, upperWordDuration & 0xff, lowerWordDuration >> 24, lowerWordDuration >> 16 & 0xff, lowerWordDuration >> 8 & 0xff, lowerWordDuration & 0xff, 0x55, 0xc4, // 'und' language (undetermined)\n    0x00, 0x00]));\n  };\n\n  MP4.mdia = function mdia(track) {\n    return MP4.box(MP4.types.mdia, MP4.mdhd(track.timescale, track.duration), MP4.hdlr(track.type), MP4.minf(track));\n  };\n\n  MP4.mfhd = function mfhd(sequenceNumber) {\n    return MP4.box(MP4.types.mfhd, new Uint8Array([0x00, 0x00, 0x00, 0x00, // flags\n    sequenceNumber >> 24, sequenceNumber >> 16 & 0xff, sequenceNumber >> 8 & 0xff, sequenceNumber & 0xff // sequence_number\n    ]));\n  };\n\n  MP4.minf = function minf(track) {\n    if (track.type === 'audio') {\n      return MP4.box(MP4.types.minf, MP4.box(MP4.types.smhd, MP4.SMHD), MP4.DINF, MP4.stbl(track));\n    } else {\n      return MP4.box(MP4.types.minf, MP4.box(MP4.types.vmhd, MP4.VMHD), MP4.DINF, MP4.stbl(track));\n    }\n  };\n\n  MP4.moof = function moof(sn, baseMediaDecodeTime, track) {\n    return MP4.box(MP4.types.moof, MP4.mfhd(sn), MP4.traf(track, baseMediaDecodeTime));\n  }\n  /**\n   * @param tracks... (optional) {array} the tracks associated with this movie\n   */\n  ;\n\n  MP4.moov = function moov(tracks) {\n    var i = tracks.length;\n    var boxes = [];\n\n    while (i--) {\n      boxes[i] = MP4.trak(tracks[i]);\n    }\n\n    return MP4.box.apply(null, [MP4.types.moov, MP4.mvhd(tracks[0].timescale, tracks[0].duration)].concat(boxes).concat(MP4.mvex(tracks)));\n  };\n\n  MP4.mvex = function mvex(tracks) {\n    var i = tracks.length;\n    var boxes = [];\n\n    while (i--) {\n      boxes[i] = MP4.trex(tracks[i]);\n    }\n\n    return MP4.box.apply(null, [MP4.types.mvex].concat(boxes));\n  };\n\n  MP4.mvhd = function mvhd(timescale, duration) {\n    duration *= timescale;\n    var upperWordDuration = Math.floor(duration / (UINT32_MAX + 1));\n    var lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));\n    var bytes = new Uint8Array([0x01, // version 1\n    0x00, 0x00, 0x00, // flags\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // creation_time\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, // modification_time\n    timescale >> 24 & 0xff, timescale >> 16 & 0xff, timescale >> 8 & 0xff, timescale & 0xff, // timescale\n    upperWordDuration >> 24, upperWordDuration >> 16 & 0xff, upperWordDuration >> 8 & 0xff, upperWordDuration & 0xff, lowerWordDuration >> 24, lowerWordDuration >> 16 & 0xff, lowerWordDuration >> 8 & 0xff, lowerWordDuration & 0xff, 0x00, 0x01, 0x00, 0x00, // 1.0 rate\n    0x01, 0x00, // 1.0 volume\n    0x00, 0x00, // reserved\n    0x00, 0x00, 0x00, 0x00, // reserved\n    0x00, 0x00, 0x00, 0x00, // reserved\n    0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, // transformation: unity matrix\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // pre_defined\n    0xff, 0xff, 0xff, 0xff // next_track_ID\n    ]);\n    return MP4.box(MP4.types.mvhd, bytes);\n  };\n\n  MP4.sdtp = function sdtp(track) {\n    var samples = track.samples || [];\n    var bytes = new Uint8Array(4 + samples.length);\n    var i;\n    var flags; // leave the full box header (4 bytes) all zero\n    // write the sample table\n\n    for (i = 0; i < samples.length; i++) {\n      flags = samples[i].flags;\n      bytes[i + 4] = flags.dependsOn << 4 | flags.isDependedOn << 2 | flags.hasRedundancy;\n    }\n\n    return MP4.box(MP4.types.sdtp, bytes);\n  };\n\n  MP4.stbl = function stbl(track) {\n    return MP4.box(MP4.types.stbl, MP4.stsd(track), MP4.box(MP4.types.stts, MP4.STTS), MP4.box(MP4.types.stsc, MP4.STSC), MP4.box(MP4.types.stsz, MP4.STSZ), MP4.box(MP4.types.stco, MP4.STCO));\n  };\n\n  MP4.avc1 = function avc1(track) {\n    var sps = [];\n    var pps = [];\n    var i;\n    var data;\n    var len; // assemble the SPSs\n\n    for (i = 0; i < track.sps.length; i++) {\n      data = track.sps[i];\n      len = data.byteLength;\n      sps.push(len >>> 8 & 0xff);\n      sps.push(len & 0xff); // SPS\n\n      sps = sps.concat(Array.prototype.slice.call(data));\n    } // assemble the PPSs\n\n\n    for (i = 0; i < track.pps.length; i++) {\n      data = track.pps[i];\n      len = data.byteLength;\n      pps.push(len >>> 8 & 0xff);\n      pps.push(len & 0xff);\n      pps = pps.concat(Array.prototype.slice.call(data));\n    }\n\n    var avcc = MP4.box(MP4.types.avcC, new Uint8Array([0x01, // version\n    sps[3], // profile\n    sps[4], // profile compat\n    sps[5], // level\n    0xfc | 3, // lengthSizeMinusOne, hard-coded to 4 bytes\n    0xe0 | track.sps.length // 3bit reserved (111) + numOfSequenceParameterSets\n    ].concat(sps).concat([track.pps.length // numOfPictureParameterSets\n    ]).concat(pps))); // \"PPS\"\n\n    var width = track.width;\n    var height = track.height;\n    var hSpacing = track.pixelRatio[0];\n    var vSpacing = track.pixelRatio[1];\n    return MP4.box(MP4.types.avc1, new Uint8Array([0x00, 0x00, 0x00, // reserved\n    0x00, 0x00, 0x00, // reserved\n    0x00, 0x01, // data_reference_index\n    0x00, 0x00, // pre_defined\n    0x00, 0x00, // reserved\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // pre_defined\n    width >> 8 & 0xff, width & 0xff, // width\n    height >> 8 & 0xff, height & 0xff, // height\n    0x00, 0x48, 0x00, 0x00, // horizresolution\n    0x00, 0x48, 0x00, 0x00, // vertresolution\n    0x00, 0x00, 0x00, 0x00, // reserved\n    0x00, 0x01, // frame_count\n    0x12, 0x64, 0x61, 0x69, 0x6c, // dailymotion/hls.js\n    0x79, 0x6d, 0x6f, 0x74, 0x69, 0x6f, 0x6e, 0x2f, 0x68, 0x6c, 0x73, 0x2e, 0x6a, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // compressorname\n    0x00, 0x18, // depth = 24\n    0x11, 0x11]), // pre_defined = -1\n    avcc, MP4.box(MP4.types.btrt, new Uint8Array([0x00, 0x1c, 0x9c, 0x80, // bufferSizeDB\n    0x00, 0x2d, 0xc6, 0xc0, // maxBitrate\n    0x00, 0x2d, 0xc6, 0xc0])), // avgBitrate\n    MP4.box(MP4.types.pasp, new Uint8Array([hSpacing >> 24, // hSpacing\n    hSpacing >> 16 & 0xff, hSpacing >> 8 & 0xff, hSpacing & 0xff, vSpacing >> 24, // vSpacing\n    vSpacing >> 16 & 0xff, vSpacing >> 8 & 0xff, vSpacing & 0xff])));\n  };\n\n  MP4.esds = function esds(track) {\n    var configlen = track.config.length;\n    return new Uint8Array([0x00, // version 0\n    0x00, 0x00, 0x00, // flags\n    0x03, // descriptor_type\n    0x17 + configlen, // length\n    0x00, 0x01, // es_id\n    0x00, // stream_priority\n    0x04, // descriptor_type\n    0x0f + configlen, // length\n    0x40, // codec : mpeg4_audio\n    0x15, // stream_type\n    0x00, 0x00, 0x00, // buffer_size\n    0x00, 0x00, 0x00, 0x00, // maxBitrate\n    0x00, 0x00, 0x00, 0x00, // avgBitrate\n    0x05 // descriptor_type\n    ].concat([configlen]).concat(track.config).concat([0x06, 0x01, 0x02])); // GASpecificConfig)); // length + audio config descriptor\n  };\n\n  MP4.mp4a = function mp4a(track) {\n    var samplerate = track.samplerate;\n    return MP4.box(MP4.types.mp4a, new Uint8Array([0x00, 0x00, 0x00, // reserved\n    0x00, 0x00, 0x00, // reserved\n    0x00, 0x01, // data_reference_index\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // reserved\n    0x00, track.channelCount, // channelcount\n    0x00, 0x10, // sampleSize:16bits\n    0x00, 0x00, 0x00, 0x00, // reserved2\n    samplerate >> 8 & 0xff, samplerate & 0xff, //\n    0x00, 0x00]), MP4.box(MP4.types.esds, MP4.esds(track)));\n  };\n\n  MP4.mp3 = function mp3(track) {\n    var samplerate = track.samplerate;\n    return MP4.box(MP4.types['.mp3'], new Uint8Array([0x00, 0x00, 0x00, // reserved\n    0x00, 0x00, 0x00, // reserved\n    0x00, 0x01, // data_reference_index\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // reserved\n    0x00, track.channelCount, // channelcount\n    0x00, 0x10, // sampleSize:16bits\n    0x00, 0x00, 0x00, 0x00, // reserved2\n    samplerate >> 8 & 0xff, samplerate & 0xff, //\n    0x00, 0x00]));\n  };\n\n  MP4.stsd = function stsd(track) {\n    if (track.type === 'audio') {\n      if (!track.isAAC && track.codec === 'mp3') {\n        return MP4.box(MP4.types.stsd, MP4.STSD, MP4.mp3(track));\n      }\n\n      return MP4.box(MP4.types.stsd, MP4.STSD, MP4.mp4a(track));\n    } else {\n      return MP4.box(MP4.types.stsd, MP4.STSD, MP4.avc1(track));\n    }\n  };\n\n  MP4.tkhd = function tkhd(track) {\n    var id = track.id;\n    var duration = track.duration * track.timescale;\n    var width = track.width;\n    var height = track.height;\n    var upperWordDuration = Math.floor(duration / (UINT32_MAX + 1));\n    var lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));\n    return MP4.box(MP4.types.tkhd, new Uint8Array([0x01, // version 1\n    0x00, 0x00, 0x07, // flags\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // creation_time\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, // modification_time\n    id >> 24 & 0xff, id >> 16 & 0xff, id >> 8 & 0xff, id & 0xff, // track_ID\n    0x00, 0x00, 0x00, 0x00, // reserved\n    upperWordDuration >> 24, upperWordDuration >> 16 & 0xff, upperWordDuration >> 8 & 0xff, upperWordDuration & 0xff, lowerWordDuration >> 24, lowerWordDuration >> 16 & 0xff, lowerWordDuration >> 8 & 0xff, lowerWordDuration & 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // reserved\n    0x00, 0x00, // layer\n    0x00, 0x00, // alternate_group\n    0x00, 0x00, // non-audio track volume\n    0x00, 0x00, // reserved\n    0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, // transformation: unity matrix\n    width >> 8 & 0xff, width & 0xff, 0x00, 0x00, // width\n    height >> 8 & 0xff, height & 0xff, 0x00, 0x00 // height\n    ]));\n  };\n\n  MP4.traf = function traf(track, baseMediaDecodeTime) {\n    var sampleDependencyTable = MP4.sdtp(track);\n    var id = track.id;\n    var upperWordBaseMediaDecodeTime = Math.floor(baseMediaDecodeTime / (UINT32_MAX + 1));\n    var lowerWordBaseMediaDecodeTime = Math.floor(baseMediaDecodeTime % (UINT32_MAX + 1));\n    return MP4.box(MP4.types.traf, MP4.box(MP4.types.tfhd, new Uint8Array([0x00, // version 0\n    0x00, 0x00, 0x00, // flags\n    id >> 24, id >> 16 & 0xff, id >> 8 & 0xff, id & 0xff // track_ID\n    ])), MP4.box(MP4.types.tfdt, new Uint8Array([0x01, // version 1\n    0x00, 0x00, 0x00, // flags\n    upperWordBaseMediaDecodeTime >> 24, upperWordBaseMediaDecodeTime >> 16 & 0xff, upperWordBaseMediaDecodeTime >> 8 & 0xff, upperWordBaseMediaDecodeTime & 0xff, lowerWordBaseMediaDecodeTime >> 24, lowerWordBaseMediaDecodeTime >> 16 & 0xff, lowerWordBaseMediaDecodeTime >> 8 & 0xff, lowerWordBaseMediaDecodeTime & 0xff])), MP4.trun(track, sampleDependencyTable.length + 16 + // tfhd\n    20 + // tfdt\n    8 + // traf header\n    16 + // mfhd\n    8 + // moof header\n    8), // mdat header\n    sampleDependencyTable);\n  }\n  /**\n   * Generate a track box.\n   * @param track {object} a track definition\n   * @return {Uint8Array} the track box\n   */\n  ;\n\n  MP4.trak = function trak(track) {\n    track.duration = track.duration || 0xffffffff;\n    return MP4.box(MP4.types.trak, MP4.tkhd(track), MP4.mdia(track));\n  };\n\n  MP4.trex = function trex(track) {\n    var id = track.id;\n    return MP4.box(MP4.types.trex, new Uint8Array([0x00, // version 0\n    0x00, 0x00, 0x00, // flags\n    id >> 24, id >> 16 & 0xff, id >> 8 & 0xff, id & 0xff, // track_ID\n    0x00, 0x00, 0x00, 0x01, // default_sample_description_index\n    0x00, 0x00, 0x00, 0x00, // default_sample_duration\n    0x00, 0x00, 0x00, 0x00, // default_sample_size\n    0x00, 0x01, 0x00, 0x01 // default_sample_flags\n    ]));\n  };\n\n  MP4.trun = function trun(track, offset) {\n    var samples = track.samples || [];\n    var len = samples.length;\n    var arraylen = 12 + 16 * len;\n    var array = new Uint8Array(arraylen);\n    var i;\n    var sample;\n    var duration;\n    var size;\n    var flags;\n    var cts;\n    offset += 8 + arraylen;\n    array.set([0x00, // version 0\n    0x00, 0x0f, 0x01, // flags\n    len >>> 24 & 0xff, len >>> 16 & 0xff, len >>> 8 & 0xff, len & 0xff, // sample_count\n    offset >>> 24 & 0xff, offset >>> 16 & 0xff, offset >>> 8 & 0xff, offset & 0xff // data_offset\n    ], 0);\n\n    for (i = 0; i < len; i++) {\n      sample = samples[i];\n      duration = sample.duration;\n      size = sample.size;\n      flags = sample.flags;\n      cts = sample.cts;\n      array.set([duration >>> 24 & 0xff, duration >>> 16 & 0xff, duration >>> 8 & 0xff, duration & 0xff, // sample_duration\n      size >>> 24 & 0xff, size >>> 16 & 0xff, size >>> 8 & 0xff, size & 0xff, // sample_size\n      flags.isLeading << 2 | flags.dependsOn, flags.isDependedOn << 6 | flags.hasRedundancy << 4 | flags.paddingValue << 1 | flags.isNonSync, flags.degradPrio & 0xf0 << 8, flags.degradPrio & 0x0f, // sample_flags\n      cts >>> 24 & 0xff, cts >>> 16 & 0xff, cts >>> 8 & 0xff, cts & 0xff // sample_composition_time_offset\n      ], 12 + 16 * i);\n    }\n\n    return MP4.box(MP4.types.trun, array);\n  };\n\n  MP4.initSegment = function initSegment(tracks) {\n    if (!MP4.types) {\n      MP4.init();\n    }\n\n    var movie = MP4.moov(tracks);\n    var result = new Uint8Array(MP4.FTYP.byteLength + movie.byteLength);\n    result.set(MP4.FTYP);\n    result.set(movie, MP4.FTYP.byteLength);\n    return result;\n  };\n\n  return MP4;\n}();\n\nMP4.types = void 0;\nMP4.HDLR_TYPES = void 0;\nMP4.STTS = void 0;\nMP4.STSC = void 0;\nMP4.STCO = void 0;\nMP4.STSZ = void 0;\nMP4.VMHD = void 0;\nMP4.SMHD = void 0;\nMP4.STSD = void 0;\nMP4.FTYP = void 0;\nMP4.DINF = void 0;\n/* harmony default export */ __webpack_exports__[\"default\"] = (MP4);\n\n/***/ }),\n\n/***/ \"./src/remux/mp4-remuxer.ts\":\n/*!**********************************!*\\\n  !*** ./src/remux/mp4-remuxer.ts ***!\n  \\**********************************/\n/*! exports provided: default, normalizePts */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_775410__) {\n\n\"use strict\";\n__nested_webpack_require_775410__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_775410__.d(__webpack_exports__, \"default\", function() { return MP4Remuxer; });\n/* harmony export (binding) */ __nested_webpack_require_775410__.d(__webpack_exports__, \"normalizePts\", function() { return normalizePts; });\n/* harmony import */ var _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_775410__(/*! ./src/polyfills/number */ \"./src/polyfills/number.ts\");\n/* harmony import */ var _aac_helper__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_775410__(/*! ./aac-helper */ \"./src/remux/aac-helper.ts\");\n/* harmony import */ var _mp4_generator__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_775410__(/*! ./mp4-generator */ \"./src/remux/mp4-generator.ts\");\n/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_775410__(/*! ../events */ \"./src/events.ts\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_775410__(/*! ../errors */ \"./src/errors.ts\");\n/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_775410__(/*! ../utils/logger */ \"./src/utils/logger.ts\");\n/* harmony import */ var _types_loader__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_775410__(/*! ../types/loader */ \"./src/types/loader.ts\");\n/* harmony import */ var _utils_timescale_conversion__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_775410__(/*! ../utils/timescale-conversion */ \"./src/utils/timescale-conversion.ts\");\n\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\n\n\n\n\n\n\n\nvar MAX_SILENT_FRAME_DURATION = 10 * 1000; // 10 seconds\n\nvar AAC_SAMPLES_PER_FRAME = 1024;\nvar MPEG_AUDIO_SAMPLE_PER_FRAME = 1152;\nvar chromeVersion = null;\nvar safariWebkitVersion = null;\nvar requiresPositiveDts = false;\n\nvar MP4Remuxer = /*#__PURE__*/function () {\n  function MP4Remuxer(observer, config, typeSupported, vendor) {\n    if (vendor === void 0) {\n      vendor = '';\n    }\n\n    this.observer = void 0;\n    this.config = void 0;\n    this.typeSupported = void 0;\n    this.ISGenerated = false;\n    this._initPTS = void 0;\n    this._initDTS = void 0;\n    this.nextAvcDts = null;\n    this.nextAudioPts = null;\n    this.isAudioContiguous = false;\n    this.isVideoContiguous = false;\n    this.observer = observer;\n    this.config = config;\n    this.typeSupported = typeSupported;\n    this.ISGenerated = false;\n\n    if (chromeVersion === null) {\n      var userAgent = navigator.userAgent || '';\n      var result = userAgent.match(/Chrome\\/(\\d+)/i);\n      chromeVersion = result ? parseInt(result[1]) : 0;\n    }\n\n    if (safariWebkitVersion === null) {\n      var _result = navigator.userAgent.match(/Safari\\/(\\d+)/i);\n\n      safariWebkitVersion = _result ? parseInt(_result[1]) : 0;\n    }\n\n    requiresPositiveDts = !!chromeVersion && chromeVersion < 75 || !!safariWebkitVersion && safariWebkitVersion < 600;\n  }\n\n  var _proto = MP4Remuxer.prototype;\n\n  _proto.destroy = function destroy() {};\n\n  _proto.resetTimeStamp = function resetTimeStamp(defaultTimeStamp) {\n    _utils_logger__WEBPACK_IMPORTED_MODULE_5__[\"logger\"].log('[mp4-remuxer]: initPTS & initDTS reset');\n    this._initPTS = this._initDTS = defaultTimeStamp;\n  };\n\n  _proto.resetNextTimestamp = function resetNextTimestamp() {\n    _utils_logger__WEBPACK_IMPORTED_MODULE_5__[\"logger\"].log('[mp4-remuxer]: reset next timestamp');\n    this.isVideoContiguous = false;\n    this.isAudioContiguous = false;\n  };\n\n  _proto.resetInitSegment = function resetInitSegment() {\n    _utils_logger__WEBPACK_IMPORTED_MODULE_5__[\"logger\"].log('[mp4-remuxer]: ISGenerated flag reset');\n    this.ISGenerated = false;\n  };\n\n  _proto.getVideoStartPts = function getVideoStartPts(videoSamples) {\n    var rolloverDetected = false;\n    var startPTS = videoSamples.reduce(function (minPTS, sample) {\n      var delta = sample.pts - minPTS;\n\n      if (delta < -4294967296) {\n        // 2^32, see PTSNormalize for reasoning, but we're hitting a rollover here, and we don't want that to impact the timeOffset calculation\n        rolloverDetected = true;\n        return normalizePts(minPTS, sample.pts);\n      } else if (delta > 0) {\n        return minPTS;\n      } else {\n        return sample.pts;\n      }\n    }, videoSamples[0].pts);\n\n    if (rolloverDetected) {\n      _utils_logger__WEBPACK_IMPORTED_MODULE_5__[\"logger\"].debug('PTS rollover detected');\n    }\n\n    return startPTS;\n  };\n\n  _proto.remux = function remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, accurateTimeOffset, flush, playlistType) {\n    var video;\n    var audio;\n    var initSegment;\n    var text;\n    var id3;\n    var independent;\n    var audioTimeOffset = timeOffset;\n    var videoTimeOffset = timeOffset; // If we're remuxing audio and video progressively, wait until we've received enough samples for each track before proceeding.\n    // This is done to synchronize the audio and video streams. We know if the current segment will have samples if the \"pid\"\n    // parameter is greater than -1. The pid is set when the PMT is parsed, which contains the tracks list.\n    // However, if the initSegment has already been generated, or we've reached the end of a segment (flush),\n    // then we can remux one track without waiting for the other.\n\n    var hasAudio = audioTrack.pid > -1;\n    var hasVideo = videoTrack.pid > -1;\n    var length = videoTrack.samples.length;\n    var enoughAudioSamples = audioTrack.samples.length > 0;\n    var enoughVideoSamples = length > 1;\n    var canRemuxAvc = (!hasAudio || enoughAudioSamples) && (!hasVideo || enoughVideoSamples) || this.ISGenerated || flush;\n\n    if (canRemuxAvc) {\n      if (!this.ISGenerated) {\n        initSegment = this.generateIS(audioTrack, videoTrack, timeOffset);\n      }\n\n      var isVideoContiguous = this.isVideoContiguous;\n      var firstKeyFrameIndex = -1;\n\n      if (enoughVideoSamples) {\n        firstKeyFrameIndex = findKeyframeIndex(videoTrack.samples);\n\n        if (!isVideoContiguous && this.config.forceKeyFrameOnDiscontinuity) {\n          independent = true;\n\n          if (firstKeyFrameIndex > 0) {\n            _utils_logger__WEBPACK_IMPORTED_MODULE_5__[\"logger\"].warn(\"[mp4-remuxer]: Dropped \" + firstKeyFrameIndex + \" out of \" + length + \" video samples due to a missing keyframe\");\n            var startPTS = this.getVideoStartPts(videoTrack.samples);\n            videoTrack.samples = videoTrack.samples.slice(firstKeyFrameIndex);\n            videoTrack.dropped += firstKeyFrameIndex;\n            videoTimeOffset += (videoTrack.samples[0].pts - startPTS) / (videoTrack.timescale || 90000);\n          } else if (firstKeyFrameIndex === -1) {\n            _utils_logger__WEBPACK_IMPORTED_MODULE_5__[\"logger\"].warn(\"[mp4-remuxer]: No keyframe found out of \" + length + \" video samples\");\n            independent = false;\n          }\n        }\n      }\n\n      if (this.ISGenerated) {\n        if (enoughAudioSamples && enoughVideoSamples) {\n          // timeOffset is expected to be the offset of the first timestamp of this fragment (first DTS)\n          // if first audio DTS is not aligned with first video DTS then we need to take that into account\n          // when providing timeOffset to remuxAudio / remuxVideo. if we don't do that, there might be a permanent / small\n          // drift between audio and video streams\n          var _startPTS = this.getVideoStartPts(videoTrack.samples);\n\n          var tsDelta = normalizePts(audioTrack.samples[0].pts, _startPTS) - _startPTS;\n\n          var audiovideoTimestampDelta = tsDelta / videoTrack.inputTimeScale;\n          audioTimeOffset += Math.max(0, audiovideoTimestampDelta);\n          videoTimeOffset += Math.max(0, -audiovideoTimestampDelta);\n        } // Purposefully remuxing audio before video, so that remuxVideo can use nextAudioPts, which is calculated in remuxAudio.\n\n\n        if (enoughAudioSamples) {\n          // if initSegment was generated without audio samples, regenerate it again\n          if (!audioTrack.samplerate) {\n            _utils_logger__WEBPACK_IMPORTED_MODULE_5__[\"logger\"].warn('[mp4-remuxer]: regenerate InitSegment as audio detected');\n            initSegment = this.generateIS(audioTrack, videoTrack, timeOffset);\n          }\n\n          audio = this.remuxAudio(audioTrack, audioTimeOffset, this.isAudioContiguous, accurateTimeOffset, hasVideo || enoughVideoSamples || playlistType === _types_loader__WEBPACK_IMPORTED_MODULE_6__[\"PlaylistLevelType\"].AUDIO ? videoTimeOffset : undefined);\n\n          if (enoughVideoSamples) {\n            var audioTrackLength = audio ? audio.endPTS - audio.startPTS : 0; // if initSegment was generated without video samples, regenerate it again\n\n            if (!videoTrack.inputTimeScale) {\n              _utils_logger__WEBPACK_IMPORTED_MODULE_5__[\"logger\"].warn('[mp4-remuxer]: regenerate InitSegment as video detected');\n              initSegment = this.generateIS(audioTrack, videoTrack, timeOffset);\n            }\n\n            video = this.remuxVideo(videoTrack, videoTimeOffset, isVideoContiguous, audioTrackLength);\n          }\n        } else if (enoughVideoSamples) {\n          video = this.remuxVideo(videoTrack, videoTimeOffset, isVideoContiguous, 0);\n        }\n\n        if (video) {\n          video.firstKeyFrame = firstKeyFrameIndex;\n          video.independent = firstKeyFrameIndex !== -1;\n        }\n      }\n    } // Allow ID3 and text to remux, even if more audio/video samples are required\n\n\n    if (this.ISGenerated) {\n      if (id3Track.samples.length) {\n        id3 = this.remuxID3(id3Track, timeOffset);\n      }\n\n      if (textTrack.samples.length) {\n        text = this.remuxText(textTrack, timeOffset);\n      }\n    }\n\n    return {\n      audio: audio,\n      video: video,\n      initSegment: initSegment,\n      independent: independent,\n      text: text,\n      id3: id3\n    };\n  };\n\n  _proto.generateIS = function generateIS(audioTrack, videoTrack, timeOffset) {\n    var audioSamples = audioTrack.samples;\n    var videoSamples = videoTrack.samples;\n    var typeSupported = this.typeSupported;\n    var tracks = {};\n    var computePTSDTS = !Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__[\"isFiniteNumber\"])(this._initPTS);\n    var container = 'audio/mp4';\n    var initPTS;\n    var initDTS;\n    var timescale;\n\n    if (computePTSDTS) {\n      initPTS = initDTS = Infinity;\n    }\n\n    if (audioTrack.config && audioSamples.length) {\n      // let's use audio sampling rate as MP4 time scale.\n      // rationale is that there is a integer nb of audio frames per audio sample (1024 for AAC)\n      // using audio sampling rate here helps having an integer MP4 frame duration\n      // this avoids potential rounding issue and AV sync issue\n      audioTrack.timescale = audioTrack.samplerate;\n\n      if (!audioTrack.isAAC) {\n        if (typeSupported.mpeg) {\n          // Chrome and Safari\n          container = 'audio/mpeg';\n          audioTrack.codec = '';\n        } else if (typeSupported.mp3) {\n          // Firefox\n          audioTrack.codec = 'mp3';\n        }\n      }\n\n      tracks.audio = {\n        id: 'audio',\n        container: container,\n        codec: audioTrack.codec,\n        initSegment: !audioTrack.isAAC && typeSupported.mpeg ? new Uint8Array(0) : _mp4_generator__WEBPACK_IMPORTED_MODULE_2__[\"default\"].initSegment([audioTrack]),\n        metadata: {\n          channelCount: audioTrack.channelCount\n        }\n      };\n\n      if (computePTSDTS) {\n        timescale = audioTrack.inputTimeScale; // remember first PTS of this demuxing context. for audio, PTS = DTS\n\n        initPTS = initDTS = audioSamples[0].pts - Math.round(timescale * timeOffset);\n      }\n    }\n\n    if (videoTrack.sps && videoTrack.pps && videoSamples.length) {\n      // let's use input time scale as MP4 video timescale\n      // we use input time scale straight away to avoid rounding issues on frame duration / cts computation\n      videoTrack.timescale = videoTrack.inputTimeScale;\n      tracks.video = {\n        id: 'main',\n        container: 'video/mp4',\n        codec: videoTrack.codec,\n        initSegment: _mp4_generator__WEBPACK_IMPORTED_MODULE_2__[\"default\"].initSegment([videoTrack]),\n        metadata: {\n          width: videoTrack.width,\n          height: videoTrack.height\n        }\n      };\n\n      if (computePTSDTS) {\n        timescale = videoTrack.inputTimeScale;\n        var startPTS = this.getVideoStartPts(videoSamples);\n        var startOffset = Math.round(timescale * timeOffset);\n        initDTS = Math.min(initDTS, normalizePts(videoSamples[0].dts, startPTS) - startOffset);\n        initPTS = Math.min(initPTS, startPTS - startOffset);\n      }\n    }\n\n    if (Object.keys(tracks).length) {\n      this.ISGenerated = true;\n\n      if (computePTSDTS) {\n        this._initPTS = initPTS;\n        this._initDTS = initDTS;\n      }\n\n      return {\n        tracks: tracks,\n        initPTS: initPTS,\n        timescale: timescale\n      };\n    }\n  };\n\n  _proto.remuxVideo = function remuxVideo(track, timeOffset, contiguous, audioTrackLength) {\n    var timeScale = track.inputTimeScale;\n    var inputSamples = track.samples;\n    var outputSamples = [];\n    var nbSamples = inputSamples.length;\n    var initPTS = this._initPTS;\n    var nextAvcDts = this.nextAvcDts;\n    var offset = 8;\n    var mp4SampleDuration;\n    var firstDTS;\n    var lastDTS;\n    var minPTS = Number.POSITIVE_INFINITY;\n    var maxPTS = Number.NEGATIVE_INFINITY;\n    var ptsDtsShift = 0;\n    var sortSamples = false; // if parsed fragment is contiguous with last one, let's use last DTS value as reference\n\n    if (!contiguous || nextAvcDts === null) {\n      var pts = timeOffset * timeScale;\n      var cts = inputSamples[0].pts - normalizePts(inputSamples[0].dts, inputSamples[0].pts); // if not contiguous, let's use target timeOffset\n\n      nextAvcDts = pts - cts;\n    } // PTS is coded on 33bits, and can loop from -2^32 to 2^32\n    // PTSNormalize will make PTS/DTS value monotonic, we use last known DTS value as reference value\n\n\n    for (var i = 0; i < nbSamples; i++) {\n      var sample = inputSamples[i];\n      sample.pts = normalizePts(sample.pts - initPTS, nextAvcDts);\n      sample.dts = normalizePts(sample.dts - initPTS, nextAvcDts);\n\n      if (sample.dts > sample.pts) {\n        var PTS_DTS_SHIFT_TOLERANCE_90KHZ = 90000 * 0.2;\n        ptsDtsShift = Math.max(Math.min(ptsDtsShift, sample.pts - sample.dts), -1 * PTS_DTS_SHIFT_TOLERANCE_90KHZ);\n      }\n\n      if (sample.dts < inputSamples[i > 0 ? i - 1 : i].dts) {\n        sortSamples = true;\n      }\n    } // sort video samples by DTS then PTS then demux id order\n\n\n    if (sortSamples) {\n      inputSamples.sort(function (a, b) {\n        var deltadts = a.dts - b.dts;\n        var deltapts = a.pts - b.pts;\n        return deltadts || deltapts;\n      });\n    } // Get first/last DTS\n\n\n    firstDTS = inputSamples[0].dts;\n    lastDTS = inputSamples[inputSamples.length - 1].dts; // on Safari let's signal the same sample duration for all samples\n    // sample duration (as expected by trun MP4 boxes), should be the delta between sample DTS\n    // set this constant duration as being the avg delta between consecutive DTS.\n\n    var averageSampleDuration = Math.round((lastDTS - firstDTS) / (nbSamples - 1)); // handle broken streams with PTS < DTS, tolerance up 0.2 seconds\n\n    if (ptsDtsShift < 0) {\n      if (ptsDtsShift < averageSampleDuration * -2) {\n        // Fix for \"CNN special report, with CC\" in test-streams (including Safari browser)\n        // With large PTS < DTS errors such as this, we want to correct CTS while maintaining increasing DTS values\n        _utils_logger__WEBPACK_IMPORTED_MODULE_5__[\"logger\"].warn(\"PTS < DTS detected in video samples, offsetting DTS from PTS by \" + Object(_utils_timescale_conversion__WEBPACK_IMPORTED_MODULE_7__[\"toMsFromMpegTsClock\"])(-averageSampleDuration, true) + \" ms\");\n        var lastDts = ptsDtsShift;\n\n        for (var _i = 0; _i < nbSamples; _i++) {\n          inputSamples[_i].dts = lastDts = Math.max(lastDts, inputSamples[_i].pts - averageSampleDuration);\n          inputSamples[_i].pts = Math.max(lastDts, inputSamples[_i].pts);\n        }\n      } else {\n        // Fix for \"Custom IV with bad PTS DTS\" in test-streams\n        // With smaller PTS < DTS errors we can simply move all DTS back. This increases CTS without causing buffer gaps or decode errors in Safari\n        _utils_logger__WEBPACK_IMPORTED_MODULE_5__[\"logger\"].warn(\"PTS < DTS detected in video samples, shifting DTS by \" + Object(_utils_timescale_conversion__WEBPACK_IMPORTED_MODULE_7__[\"toMsFromMpegTsClock\"])(ptsDtsShift, true) + \" ms to overcome this issue\");\n\n        for (var _i2 = 0; _i2 < nbSamples; _i2++) {\n          inputSamples[_i2].dts = inputSamples[_i2].dts + ptsDtsShift;\n        }\n      }\n\n      firstDTS = inputSamples[0].dts;\n    } // if fragment are contiguous, detect hole/overlapping between fragments\n\n\n    if (contiguous) {\n      // check timestamp continuity across consecutive fragments (this is to remove inter-fragment gap/hole)\n      var delta = firstDTS - nextAvcDts;\n      var foundHole = delta > averageSampleDuration;\n      var foundOverlap = delta < -1;\n\n      if (foundHole || foundOverlap) {\n        if (foundHole) {\n          _utils_logger__WEBPACK_IMPORTED_MODULE_5__[\"logger\"].warn(\"AVC: \" + Object(_utils_timescale_conversion__WEBPACK_IMPORTED_MODULE_7__[\"toMsFromMpegTsClock\"])(delta, true) + \" ms (\" + delta + \"dts) hole between fragments detected, filling it\");\n        } else {\n          _utils_logger__WEBPACK_IMPORTED_MODULE_5__[\"logger\"].warn(\"AVC: \" + Object(_utils_timescale_conversion__WEBPACK_IMPORTED_MODULE_7__[\"toMsFromMpegTsClock\"])(-delta, true) + \" ms (\" + delta + \"dts) overlapping between fragments detected\");\n        }\n\n        firstDTS = nextAvcDts;\n        var firstPTS = inputSamples[0].pts - delta;\n        inputSamples[0].dts = firstDTS;\n        inputSamples[0].pts = firstPTS;\n        _utils_logger__WEBPACK_IMPORTED_MODULE_5__[\"logger\"].log(\"Video: First PTS/DTS adjusted: \" + Object(_utils_timescale_conversion__WEBPACK_IMPORTED_MODULE_7__[\"toMsFromMpegTsClock\"])(firstPTS, true) + \"/\" + Object(_utils_timescale_conversion__WEBPACK_IMPORTED_MODULE_7__[\"toMsFromMpegTsClock\"])(firstDTS, true) + \", delta: \" + Object(_utils_timescale_conversion__WEBPACK_IMPORTED_MODULE_7__[\"toMsFromMpegTsClock\"])(delta, true) + \" ms\");\n      }\n    }\n\n    if (requiresPositiveDts) {\n      firstDTS = Math.max(0, firstDTS);\n    }\n\n    var nbNalu = 0;\n    var naluLen = 0;\n\n    for (var _i3 = 0; _i3 < nbSamples; _i3++) {\n      // compute total/avc sample length and nb of NAL units\n      var _sample = inputSamples[_i3];\n      var units = _sample.units;\n      var nbUnits = units.length;\n      var sampleLen = 0;\n\n      for (var j = 0; j < nbUnits; j++) {\n        sampleLen += units[j].data.length;\n      }\n\n      naluLen += sampleLen;\n      nbNalu += nbUnits;\n      _sample.length = sampleLen; // normalize PTS/DTS\n      // ensure sample monotonic DTS\n\n      _sample.dts = Math.max(_sample.dts, firstDTS); // ensure that computed value is greater or equal than sample DTS\n\n      _sample.pts = Math.max(_sample.pts, _sample.dts, 0);\n      minPTS = Math.min(_sample.pts, minPTS);\n      maxPTS = Math.max(_sample.pts, maxPTS);\n    }\n\n    lastDTS = inputSamples[nbSamples - 1].dts;\n    /* concatenate the video data and construct the mdat in place\n      (need 8 more bytes to fill length and mpdat type) */\n\n    var mdatSize = naluLen + 4 * nbNalu + 8;\n    var mdat;\n\n    try {\n      mdat = new Uint8Array(mdatSize);\n    } catch (err) {\n      this.observer.emit(_events__WEBPACK_IMPORTED_MODULE_3__[\"Events\"].ERROR, _events__WEBPACK_IMPORTED_MODULE_3__[\"Events\"].ERROR, {\n        type: _errors__WEBPACK_IMPORTED_MODULE_4__[\"ErrorTypes\"].MUX_ERROR,\n        details: _errors__WEBPACK_IMPORTED_MODULE_4__[\"ErrorDetails\"].REMUX_ALLOC_ERROR,\n        fatal: false,\n        bytes: mdatSize,\n        reason: \"fail allocating video mdat \" + mdatSize\n      });\n      return;\n    }\n\n    var view = new DataView(mdat.buffer);\n    view.setUint32(0, mdatSize);\n    mdat.set(_mp4_generator__WEBPACK_IMPORTED_MODULE_2__[\"default\"].types.mdat, 4);\n\n    for (var _i4 = 0; _i4 < nbSamples; _i4++) {\n      var avcSample = inputSamples[_i4];\n      var avcSampleUnits = avcSample.units;\n      var mp4SampleLength = 0; // convert NALU bitstream to MP4 format (prepend NALU with size field)\n\n      for (var _j = 0, _nbUnits = avcSampleUnits.length; _j < _nbUnits; _j++) {\n        var unit = avcSampleUnits[_j];\n        var unitData = unit.data;\n        var unitDataLen = unit.data.byteLength;\n        view.setUint32(offset, unitDataLen);\n        offset += 4;\n        mdat.set(unitData, offset);\n        offset += unitDataLen;\n        mp4SampleLength += 4 + unitDataLen;\n      } // expected sample duration is the Decoding Timestamp diff of consecutive samples\n\n\n      if (_i4 < nbSamples - 1) {\n        mp4SampleDuration = inputSamples[_i4 + 1].dts - avcSample.dts;\n      } else {\n        var config = this.config;\n        var lastFrameDuration = avcSample.dts - inputSamples[_i4 > 0 ? _i4 - 1 : _i4].dts;\n\n        if (config.stretchShortVideoTrack && this.nextAudioPts !== null) {\n          // In some cases, a segment's audio track duration may exceed the video track duration.\n          // Since we've already remuxed audio, and we know how long the audio track is, we look to\n          // see if the delta to the next segment is longer than maxBufferHole.\n          // If so, playback would potentially get stuck, so we artificially inflate\n          // the duration of the last frame to minimize any potential gap between segments.\n          var gapTolerance = Math.floor(config.maxBufferHole * timeScale);\n          var deltaToFrameEnd = (audioTrackLength ? minPTS + audioTrackLength * timeScale : this.nextAudioPts) - avcSample.pts;\n\n          if (deltaToFrameEnd > gapTolerance) {\n            // We subtract lastFrameDuration from deltaToFrameEnd to try to prevent any video\n            // frame overlap. maxBufferHole should be >> lastFrameDuration anyway.\n            mp4SampleDuration = deltaToFrameEnd - lastFrameDuration;\n\n            if (mp4SampleDuration < 0) {\n              mp4SampleDuration = lastFrameDuration;\n            }\n\n            _utils_logger__WEBPACK_IMPORTED_MODULE_5__[\"logger\"].log(\"[mp4-remuxer]: It is approximately \" + deltaToFrameEnd / 90 + \" ms to the next segment; using duration \" + mp4SampleDuration / 90 + \" ms for the last video frame.\");\n          } else {\n            mp4SampleDuration = lastFrameDuration;\n          }\n        } else {\n          mp4SampleDuration = lastFrameDuration;\n        }\n      }\n\n      var compositionTimeOffset = Math.round(avcSample.pts - avcSample.dts);\n      outputSamples.push(new Mp4Sample(avcSample.key, mp4SampleDuration, mp4SampleLength, compositionTimeOffset));\n    }\n\n    if (outputSamples.length && chromeVersion && chromeVersion < 70) {\n      // Chrome workaround, mark first sample as being a Random Access Point (keyframe) to avoid sourcebuffer append issue\n      // https://code.google.com/p/chromium/issues/detail?id=229412\n      var flags = outputSamples[0].flags;\n      flags.dependsOn = 2;\n      flags.isNonSync = 0;\n    }\n\n    console.assert(mp4SampleDuration !== undefined, 'mp4SampleDuration must be computed'); // next AVC sample DTS should be equal to last sample DTS + last sample duration (in PES timescale)\n\n    this.nextAvcDts = nextAvcDts = lastDTS + mp4SampleDuration;\n    this.isVideoContiguous = true;\n    var moof = _mp4_generator__WEBPACK_IMPORTED_MODULE_2__[\"default\"].moof(track.sequenceNumber++, firstDTS, _extends({}, track, {\n      samples: outputSamples\n    }));\n    var type = 'video';\n    var data = {\n      data1: moof,\n      data2: mdat,\n      startPTS: minPTS / timeScale,\n      endPTS: (maxPTS + mp4SampleDuration) / timeScale,\n      startDTS: firstDTS / timeScale,\n      endDTS: nextAvcDts / timeScale,\n      type: type,\n      hasAudio: false,\n      hasVideo: true,\n      nb: outputSamples.length,\n      dropped: track.dropped\n    };\n    track.samples = [];\n    track.dropped = 0;\n    console.assert(mdat.length, 'MDAT length must not be zero');\n    return data;\n  };\n\n  _proto.remuxAudio = function remuxAudio(track, timeOffset, contiguous, accurateTimeOffset, videoTimeOffset) {\n    var inputTimeScale = track.inputTimeScale;\n    var mp4timeScale = track.samplerate ? track.samplerate : inputTimeScale;\n    var scaleFactor = inputTimeScale / mp4timeScale;\n    var mp4SampleDuration = track.isAAC ? AAC_SAMPLES_PER_FRAME : MPEG_AUDIO_SAMPLE_PER_FRAME;\n    var inputSampleDuration = mp4SampleDuration * scaleFactor;\n    var initPTS = this._initPTS;\n    var rawMPEG = !track.isAAC && this.typeSupported.mpeg;\n    var outputSamples = [];\n    var inputSamples = track.samples;\n    var offset = rawMPEG ? 0 : 8;\n    var nextAudioPts = this.nextAudioPts || -1; // window.audioSamples ? window.audioSamples.push(inputSamples.map(s => s.pts)) : (window.audioSamples = [inputSamples.map(s => s.pts)]);\n    // for audio samples, also consider consecutive fragments as being contiguous (even if a level switch occurs),\n    // for sake of clarity:\n    // consecutive fragments are frags with\n    //  - less than 100ms gaps between new time offset (if accurate) and next expected PTS OR\n    //  - less than 20 audio frames distance\n    // contiguous fragments are consecutive fragments from same quality level (same level, new SN = old SN + 1)\n    // this helps ensuring audio continuity\n    // and this also avoids audio glitches/cut when switching quality, or reporting wrong duration on first audio frame\n\n    var timeOffsetMpegTS = timeOffset * inputTimeScale;\n    this.isAudioContiguous = contiguous = contiguous || inputSamples.length && nextAudioPts > 0 && (accurateTimeOffset && Math.abs(timeOffsetMpegTS - nextAudioPts) < 9000 || Math.abs(normalizePts(inputSamples[0].pts - initPTS, timeOffsetMpegTS) - nextAudioPts) < 20 * inputSampleDuration); // compute normalized PTS\n\n    inputSamples.forEach(function (sample) {\n      sample.pts = normalizePts(sample.pts - initPTS, timeOffsetMpegTS);\n    });\n\n    if (!contiguous || nextAudioPts < 0) {\n      // filter out sample with negative PTS that are not playable anyway\n      // if we don't remove these negative samples, they will shift all audio samples forward.\n      // leading to audio overlap between current / next fragment\n      inputSamples = inputSamples.filter(function (sample) {\n        return sample.pts >= 0;\n      }); // in case all samples have negative PTS, and have been filtered out, return now\n\n      if (!inputSamples.length) {\n        return;\n      }\n\n      if (videoTimeOffset === 0) {\n        // Set the start to 0 to match video so that start gaps larger than inputSampleDuration are filled with silence\n        nextAudioPts = 0;\n      } else if (accurateTimeOffset) {\n        // When not seeking, not live, and LevelDetails.PTSKnown, use fragment start as predicted next audio PTS\n        nextAudioPts = Math.max(0, timeOffsetMpegTS);\n      } else {\n        // if frags are not contiguous and if we cant trust time offset, let's use first sample PTS as next audio PTS\n        nextAudioPts = inputSamples[0].pts;\n      }\n    } // If the audio track is missing samples, the frames seem to get \"left-shifted\" within the\n    // resulting mp4 segment, causing sync issues and leaving gaps at the end of the audio segment.\n    // In an effort to prevent this from happening, we inject frames here where there are gaps.\n    // When possible, we inject a silent frame; when that's not possible, we duplicate the last\n    // frame.\n\n\n    if (track.isAAC) {\n      var alignedWithVideo = videoTimeOffset !== undefined;\n      var maxAudioFramesDrift = this.config.maxAudioFramesDrift;\n\n      for (var i = 0, nextPts = nextAudioPts; i < inputSamples.length; i++) {\n        // First, let's see how far off this frame is from where we expect it to be\n        var sample = inputSamples[i];\n        var pts = sample.pts;\n        var delta = pts - nextPts;\n        var duration = Math.abs(1000 * delta / inputTimeScale); // When remuxing with video, if we're overlapping by more than a duration, drop this sample to stay in sync\n\n        if (delta <= -maxAudioFramesDrift * inputSampleDuration && alignedWithVideo) {\n          if (i === 0) {\n            _utils_logger__WEBPACK_IMPORTED_MODULE_5__[\"logger\"].warn(\"Audio frame @ \" + (pts / inputTimeScale).toFixed(3) + \"s overlaps nextAudioPts by \" + Math.round(1000 * delta / inputTimeScale) + \" ms.\");\n            this.nextAudioPts = nextAudioPts = nextPts = pts;\n          }\n        } // eslint-disable-line brace-style\n        // Insert missing frames if:\n        // 1: We're more than maxAudioFramesDrift frame away\n        // 2: Not more than MAX_SILENT_FRAME_DURATION away\n        // 3: currentTime (aka nextPtsNorm) is not 0\n        // 4: remuxing with video (videoTimeOffset !== undefined)\n        else if (delta >= maxAudioFramesDrift * inputSampleDuration && duration < MAX_SILENT_FRAME_DURATION && alignedWithVideo) {\n          var missing = Math.round(delta / inputSampleDuration); // Adjust nextPts so that silent samples are aligned with media pts. This will prevent media samples from\n          // later being shifted if nextPts is based on timeOffset and delta is not a multiple of inputSampleDuration.\n\n          nextPts = pts - missing * inputSampleDuration;\n\n          if (nextPts < 0) {\n            missing--;\n            nextPts += inputSampleDuration;\n          }\n\n          if (i === 0) {\n            this.nextAudioPts = nextAudioPts = nextPts;\n          }\n\n          _utils_logger__WEBPACK_IMPORTED_MODULE_5__[\"logger\"].warn(\"[mp4-remuxer]: Injecting \" + missing + \" audio frame @ \" + (nextPts / inputTimeScale).toFixed(3) + \"s due to \" + Math.round(1000 * delta / inputTimeScale) + \" ms gap.\");\n\n          for (var j = 0; j < missing; j++) {\n            var newStamp = Math.max(nextPts, 0);\n            var fillFrame = _aac_helper__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getSilentFrame(track.manifestCodec || track.codec, track.channelCount);\n\n            if (!fillFrame) {\n              _utils_logger__WEBPACK_IMPORTED_MODULE_5__[\"logger\"].log('[mp4-remuxer]: Unable to get silent frame for given audio codec; duplicating last frame instead.');\n              fillFrame = sample.unit.subarray();\n            }\n\n            inputSamples.splice(i, 0, {\n              unit: fillFrame,\n              pts: newStamp\n            });\n            nextPts += inputSampleDuration;\n            i++;\n          }\n        }\n\n        sample.pts = nextPts;\n        nextPts += inputSampleDuration;\n      }\n    }\n\n    var firstPTS = null;\n    var lastPTS = null;\n    var mdat;\n    var mdatSize = 0;\n    var sampleLength = inputSamples.length;\n\n    while (sampleLength--) {\n      mdatSize += inputSamples[sampleLength].unit.byteLength;\n    }\n\n    for (var _j2 = 0, _nbSamples = inputSamples.length; _j2 < _nbSamples; _j2++) {\n      var audioSample = inputSamples[_j2];\n      var unit = audioSample.unit;\n      var _pts = audioSample.pts;\n\n      if (lastPTS !== null) {\n        // If we have more than one sample, set the duration of the sample to the \"real\" duration; the PTS diff with\n        // the previous sample\n        var prevSample = outputSamples[_j2 - 1];\n        prevSample.duration = Math.round((_pts - lastPTS) / scaleFactor);\n      } else {\n        if (contiguous && track.isAAC) {\n          // set PTS/DTS to expected PTS/DTS\n          _pts = nextAudioPts;\n        } // remember first PTS of our audioSamples\n\n\n        firstPTS = _pts;\n\n        if (mdatSize > 0) {\n          /* concatenate the audio data and construct the mdat in place\n            (need 8 more bytes to fill length and mdat type) */\n          mdatSize += offset;\n\n          try {\n            mdat = new Uint8Array(mdatSize);\n          } catch (err) {\n            this.observer.emit(_events__WEBPACK_IMPORTED_MODULE_3__[\"Events\"].ERROR, _events__WEBPACK_IMPORTED_MODULE_3__[\"Events\"].ERROR, {\n              type: _errors__WEBPACK_IMPORTED_MODULE_4__[\"ErrorTypes\"].MUX_ERROR,\n              details: _errors__WEBPACK_IMPORTED_MODULE_4__[\"ErrorDetails\"].REMUX_ALLOC_ERROR,\n              fatal: false,\n              bytes: mdatSize,\n              reason: \"fail allocating audio mdat \" + mdatSize\n            });\n            return;\n          }\n\n          if (!rawMPEG) {\n            var view = new DataView(mdat.buffer);\n            view.setUint32(0, mdatSize);\n            mdat.set(_mp4_generator__WEBPACK_IMPORTED_MODULE_2__[\"default\"].types.mdat, 4);\n          }\n        } else {\n          // no audio samples\n          return;\n        }\n      }\n\n      mdat.set(unit, offset);\n      var unitLen = unit.byteLength;\n      offset += unitLen; // Default the sample's duration to the computed mp4SampleDuration, which will either be 1024 for AAC or 1152 for MPEG\n      // In the case that we have 1 sample, this will be the duration. If we have more than one sample, the duration\n      // becomes the PTS diff with the previous sample\n\n      outputSamples.push(new Mp4Sample(true, mp4SampleDuration, unitLen, 0));\n      lastPTS = _pts;\n    } // We could end up with no audio samples if all input samples were overlapping with the previously remuxed ones\n\n\n    var nbSamples = outputSamples.length;\n\n    if (!nbSamples) {\n      return;\n    } // The next audio sample PTS should be equal to last sample PTS + duration\n\n\n    var lastSample = outputSamples[outputSamples.length - 1];\n    this.nextAudioPts = nextAudioPts = lastPTS + scaleFactor * lastSample.duration; // Set the track samples from inputSamples to outputSamples before remuxing\n\n    var moof = rawMPEG ? new Uint8Array(0) : _mp4_generator__WEBPACK_IMPORTED_MODULE_2__[\"default\"].moof(track.sequenceNumber++, firstPTS / scaleFactor, _extends({}, track, {\n      samples: outputSamples\n    })); // Clear the track samples. This also clears the samples array in the demuxer, since the reference is shared\n\n    track.samples = [];\n    var start = firstPTS / inputTimeScale;\n    var end = nextAudioPts / inputTimeScale;\n    var type = 'audio';\n    var audioData = {\n      data1: moof,\n      data2: mdat,\n      startPTS: start,\n      endPTS: end,\n      startDTS: start,\n      endDTS: end,\n      type: type,\n      hasAudio: true,\n      hasVideo: false,\n      nb: nbSamples\n    };\n    this.isAudioContiguous = true;\n    console.assert(mdat.length, 'MDAT length must not be zero');\n    return audioData;\n  };\n\n  _proto.remuxEmptyAudio = function remuxEmptyAudio(track, timeOffset, contiguous, videoData) {\n    var inputTimeScale = track.inputTimeScale;\n    var mp4timeScale = track.samplerate ? track.samplerate : inputTimeScale;\n    var scaleFactor = inputTimeScale / mp4timeScale;\n    var nextAudioPts = this.nextAudioPts; // sync with video's timestamp\n\n    var startDTS = (nextAudioPts !== null ? nextAudioPts : videoData.startDTS * inputTimeScale) + this._initDTS;\n    var endDTS = videoData.endDTS * inputTimeScale + this._initDTS; // one sample's duration value\n\n    var frameDuration = scaleFactor * AAC_SAMPLES_PER_FRAME; // samples count of this segment's duration\n\n    var nbSamples = Math.ceil((endDTS - startDTS) / frameDuration); // silent frame\n\n    var silentFrame = _aac_helper__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getSilentFrame(track.manifestCodec || track.codec, track.channelCount);\n    _utils_logger__WEBPACK_IMPORTED_MODULE_5__[\"logger\"].warn('[mp4-remuxer]: remux empty Audio'); // Can't remux if we can't generate a silent frame...\n\n    if (!silentFrame) {\n      _utils_logger__WEBPACK_IMPORTED_MODULE_5__[\"logger\"].trace('[mp4-remuxer]: Unable to remuxEmptyAudio since we were unable to get a silent frame for given audio codec');\n      return;\n    }\n\n    var samples = [];\n\n    for (var i = 0; i < nbSamples; i++) {\n      var stamp = startDTS + i * frameDuration;\n      samples.push({\n        unit: silentFrame,\n        pts: stamp,\n        dts: stamp\n      });\n    }\n\n    track.samples = samples;\n    return this.remuxAudio(track, timeOffset, contiguous, false);\n  };\n\n  _proto.remuxID3 = function remuxID3(track, timeOffset) {\n    var length = track.samples.length;\n\n    if (!length) {\n      return;\n    }\n\n    var inputTimeScale = track.inputTimeScale;\n    var initPTS = this._initPTS;\n    var initDTS = this._initDTS;\n\n    for (var index = 0; index < length; index++) {\n      var sample = track.samples[index]; // setting id3 pts, dts to relative time\n      // using this._initPTS and this._initDTS to calculate relative time\n\n      sample.pts = normalizePts(sample.pts - initPTS, timeOffset * inputTimeScale) / inputTimeScale;\n      sample.dts = normalizePts(sample.dts - initDTS, timeOffset * inputTimeScale) / inputTimeScale;\n    }\n\n    var samples = track.samples;\n    track.samples = [];\n    return {\n      samples: samples\n    };\n  };\n\n  _proto.remuxText = function remuxText(track, timeOffset) {\n    var length = track.samples.length;\n\n    if (!length) {\n      return;\n    }\n\n    var inputTimeScale = track.inputTimeScale;\n    var initPTS = this._initPTS;\n\n    for (var index = 0; index < length; index++) {\n      var sample = track.samples[index]; // setting text pts, dts to relative time\n      // using this._initPTS and this._initDTS to calculate relative time\n\n      sample.pts = normalizePts(sample.pts - initPTS, timeOffset * inputTimeScale) / inputTimeScale;\n    }\n\n    track.samples.sort(function (a, b) {\n      return a.pts - b.pts;\n    });\n    var samples = track.samples;\n    track.samples = [];\n    return {\n      samples: samples\n    };\n  };\n\n  return MP4Remuxer;\n}();\n\n\nfunction normalizePts(value, reference) {\n  var offset;\n\n  if (reference === null) {\n    return value;\n  }\n\n  if (reference < value) {\n    // - 2^33\n    offset = -8589934592;\n  } else {\n    // + 2^33\n    offset = 8589934592;\n  }\n  /* PTS is 33bit (from 0 to 2^33 -1)\n    if diff between value and reference is bigger than half of the amplitude (2^32) then it means that\n    PTS looping occured. fill the gap */\n\n\n  while (Math.abs(value - reference) > 4294967296) {\n    value += offset;\n  }\n\n  return value;\n}\n\nfunction findKeyframeIndex(samples) {\n  for (var i = 0; i < samples.length; i++) {\n    if (samples[i].key) {\n      return i;\n    }\n  }\n\n  return -1;\n}\n\nvar Mp4Sample = function Mp4Sample(isKeyframe, duration, size, cts) {\n  this.size = void 0;\n  this.duration = void 0;\n  this.cts = void 0;\n  this.flags = void 0;\n  this.duration = duration;\n  this.size = size;\n  this.cts = cts;\n  this.flags = new Mp4SampleFlags(isKeyframe);\n};\n\nvar Mp4SampleFlags = function Mp4SampleFlags(isKeyframe) {\n  this.isLeading = 0;\n  this.isDependedOn = 0;\n  this.hasRedundancy = 0;\n  this.degradPrio = 0;\n  this.dependsOn = 1;\n  this.isNonSync = 1;\n  this.dependsOn = isKeyframe ? 2 : 1;\n  this.isNonSync = isKeyframe ? 0 : 1;\n};\n\n/***/ }),\n\n/***/ \"./src/remux/passthrough-remuxer.ts\":\n/*!******************************************!*\\\n  !*** ./src/remux/passthrough-remuxer.ts ***!\n  \\******************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_814669__) {\n\n\"use strict\";\n__nested_webpack_require_814669__.r(__webpack_exports__);\n/* harmony import */ var _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_814669__(/*! ./src/polyfills/number */ \"./src/polyfills/number.ts\");\n/* harmony import */ var _utils_mp4_tools__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_814669__(/*! ../utils/mp4-tools */ \"./src/utils/mp4-tools.ts\");\n/* harmony import */ var _loader_fragment__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_814669__(/*! ../loader/fragment */ \"./src/loader/fragment.ts\");\n/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_814669__(/*! ../utils/logger */ \"./src/utils/logger.ts\");\n\n\n\n\n\n\nvar PassThroughRemuxer = /*#__PURE__*/function () {\n  function PassThroughRemuxer() {\n    this.emitInitSegment = false;\n    this.audioCodec = void 0;\n    this.videoCodec = void 0;\n    this.initData = void 0;\n    this.initPTS = void 0;\n    this.initTracks = void 0;\n    this.lastEndDTS = null;\n  }\n\n  var _proto = PassThroughRemuxer.prototype;\n\n  _proto.destroy = function destroy() {};\n\n  _proto.resetTimeStamp = function resetTimeStamp(defaultInitPTS) {\n    this.initPTS = defaultInitPTS;\n    this.lastEndDTS = null;\n  };\n\n  _proto.resetNextTimestamp = function resetNextTimestamp() {\n    this.lastEndDTS = null;\n  };\n\n  _proto.resetInitSegment = function resetInitSegment(initSegment, audioCodec, videoCodec) {\n    this.audioCodec = audioCodec;\n    this.videoCodec = videoCodec;\n    this.generateInitSegment(initSegment);\n    this.emitInitSegment = true;\n  };\n\n  _proto.generateInitSegment = function generateInitSegment(initSegment) {\n    var audioCodec = this.audioCodec,\n        videoCodec = this.videoCodec;\n\n    if (!initSegment || !initSegment.byteLength) {\n      this.initTracks = undefined;\n      this.initData = undefined;\n      return;\n    }\n\n    var initData = this.initData = Object(_utils_mp4_tools__WEBPACK_IMPORTED_MODULE_1__[\"parseInitSegment\"])(initSegment); // Get codec from initSegment or fallback to default\n\n    if (!audioCodec) {\n      audioCodec = getParsedTrackCodec(initData.audio, _loader_fragment__WEBPACK_IMPORTED_MODULE_2__[\"ElementaryStreamTypes\"].AUDIO);\n    }\n\n    if (!videoCodec) {\n      videoCodec = getParsedTrackCodec(initData.video, _loader_fragment__WEBPACK_IMPORTED_MODULE_2__[\"ElementaryStreamTypes\"].VIDEO);\n    }\n\n    var tracks = {};\n\n    if (initData.audio && initData.video) {\n      tracks.audiovideo = {\n        container: 'video/mp4',\n        codec: audioCodec + ',' + videoCodec,\n        initSegment: initSegment,\n        id: 'main'\n      };\n    } else if (initData.audio) {\n      tracks.audio = {\n        container: 'audio/mp4',\n        codec: audioCodec,\n        initSegment: initSegment,\n        id: 'audio'\n      };\n    } else if (initData.video) {\n      tracks.video = {\n        container: 'video/mp4',\n        codec: videoCodec,\n        initSegment: initSegment,\n        id: 'main'\n      };\n    } else {\n      _utils_logger__WEBPACK_IMPORTED_MODULE_3__[\"logger\"].warn('[passthrough-remuxer.ts]: initSegment does not contain moov or trak boxes.');\n    }\n\n    this.initTracks = tracks;\n  };\n\n  _proto.remux = function remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset) {\n    var initPTS = this.initPTS,\n        lastEndDTS = this.lastEndDTS;\n    var result = {\n      audio: undefined,\n      video: undefined,\n      text: textTrack,\n      id3: id3Track,\n      initSegment: undefined\n    }; // If we haven't yet set a lastEndDTS, or it was reset, set it to the provided timeOffset. We want to use the\n    // lastEndDTS over timeOffset whenever possible; during progressive playback, the media source will not update\n    // the media duration (which is what timeOffset is provided as) before we need to process the next chunk.\n\n    if (!Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__[\"isFiniteNumber\"])(lastEndDTS)) {\n      lastEndDTS = this.lastEndDTS = timeOffset || 0;\n    } // The binary segment data is added to the videoTrack in the mp4demuxer. We don't check to see if the data is only\n    // audio or video (or both); adding it to video was an arbitrary choice.\n\n\n    var data = videoTrack.samples;\n\n    if (!data || !data.length) {\n      return result;\n    }\n\n    var initSegment = {\n      initPTS: undefined,\n      timescale: 1\n    };\n    var initData = this.initData;\n\n    if (!initData || !initData.length) {\n      this.generateInitSegment(data);\n      initData = this.initData;\n    }\n\n    if (!initData || !initData.length) {\n      // We can't remux if the initSegment could not be generated\n      _utils_logger__WEBPACK_IMPORTED_MODULE_3__[\"logger\"].warn('[passthrough-remuxer.ts]: Failed to generate initSegment.');\n      return result;\n    }\n\n    if (this.emitInitSegment) {\n      initSegment.tracks = this.initTracks;\n      this.emitInitSegment = false;\n    }\n\n    if (!Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__[\"isFiniteNumber\"])(initPTS)) {\n      this.initPTS = initSegment.initPTS = initPTS = computeInitPTS(initData, data, lastEndDTS);\n    }\n\n    var duration = Object(_utils_mp4_tools__WEBPACK_IMPORTED_MODULE_1__[\"getDuration\"])(data, initData);\n    var startDTS = lastEndDTS;\n    var endDTS = duration + startDTS;\n    Object(_utils_mp4_tools__WEBPACK_IMPORTED_MODULE_1__[\"offsetStartDTS\"])(initData, data, initPTS);\n\n    if (duration > 0) {\n      this.lastEndDTS = endDTS;\n    } else {\n      _utils_logger__WEBPACK_IMPORTED_MODULE_3__[\"logger\"].warn('Duration parsed from mp4 should be greater than zero');\n      this.resetNextTimestamp();\n    }\n\n    var hasAudio = !!initData.audio;\n    var hasVideo = !!initData.video;\n    var type = '';\n\n    if (hasAudio) {\n      type += 'audio';\n    }\n\n    if (hasVideo) {\n      type += 'video';\n    }\n\n    var track = {\n      data1: data,\n      startPTS: startDTS,\n      startDTS: startDTS,\n      endPTS: endDTS,\n      endDTS: endDTS,\n      type: type,\n      hasAudio: hasAudio,\n      hasVideo: hasVideo,\n      nb: 1,\n      dropped: 0\n    };\n    result.audio = track.type === 'audio' ? track : undefined;\n    result.video = track.type !== 'audio' ? track : undefined;\n    result.text = textTrack;\n    result.id3 = id3Track;\n    result.initSegment = initSegment;\n    return result;\n  };\n\n  return PassThroughRemuxer;\n}();\n\nvar computeInitPTS = function computeInitPTS(initData, data, timeOffset) {\n  return Object(_utils_mp4_tools__WEBPACK_IMPORTED_MODULE_1__[\"getStartDTS\"])(initData, data) - timeOffset;\n};\n\nfunction getParsedTrackCodec(track, type) {\n  var parsedCodec = track === null || track === void 0 ? void 0 : track.codec;\n\n  if (parsedCodec && parsedCodec.length > 4) {\n    return parsedCodec;\n  } // Since mp4-tools cannot parse full codec string (see 'TODO: Parse codec details'... in mp4-tools)\n  // Provide defaults based on codec type\n  // This allows for some playback of some fmp4 playlists without CODECS defined in manifest\n\n\n  if (parsedCodec === 'hvc1') {\n    return 'hvc1.1.c.L120.90';\n  }\n\n  if (parsedCodec === 'av01') {\n    return 'av01.0.04M.08';\n  }\n\n  if (parsedCodec === 'avc1' || type === _loader_fragment__WEBPACK_IMPORTED_MODULE_2__[\"ElementaryStreamTypes\"].VIDEO) {\n    return 'avc1.42e01e';\n  }\n\n  return 'mp4a.40.5';\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (PassThroughRemuxer);\n\n/***/ }),\n\n/***/ \"./src/task-loop.ts\":\n/*!**************************!*\\\n  !*** ./src/task-loop.ts ***!\n  \\**************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_822249__) {\n\n\"use strict\";\n__nested_webpack_require_822249__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_822249__.d(__webpack_exports__, \"default\", function() { return TaskLoop; });\n/**\n * Sub-class specialization of EventHandler base class.\n *\n * TaskLoop allows to schedule a task function being called (optionnaly repeatedly) on the main loop,\n * scheduled asynchroneously, avoiding recursive calls in the same tick.\n *\n * The task itself is implemented in `doTick`. It can be requested and called for single execution\n * using the `tick` method.\n *\n * It will be assured that the task execution method (`tick`) only gets called once per main loop \"tick\",\n * no matter how often it gets requested for execution. Execution in further ticks will be scheduled accordingly.\n *\n * If further execution requests have already been scheduled on the next tick, it can be checked with `hasNextTick`,\n * and cancelled with `clearNextTick`.\n *\n * The task can be scheduled as an interval repeatedly with a period as parameter (see `setInterval`, `clearInterval`).\n *\n * Sub-classes need to implement the `doTick` method which will effectively have the task execution routine.\n *\n * Further explanations:\n *\n * The baseclass has a `tick` method that will schedule the doTick call. It may be called synchroneously\n * only for a stack-depth of one. On re-entrant calls, sub-sequent calls are scheduled for next main loop ticks.\n *\n * When the task execution (`tick` method) is called in re-entrant way this is detected and\n * we are limiting the task execution per call stack to exactly one, but scheduling/post-poning further\n * task processing on the next main loop iteration (also known as \"next tick\" in the Node/JS runtime lingo).\n */\nvar TaskLoop = /*#__PURE__*/function () {\n  function TaskLoop() {\n    this._boundTick = void 0;\n    this._tickTimer = null;\n    this._tickInterval = null;\n    this._tickCallCount = 0;\n    this._boundTick = this.tick.bind(this);\n  }\n\n  var _proto = TaskLoop.prototype;\n\n  _proto.destroy = function destroy() {\n    this.onHandlerDestroying();\n    this.onHandlerDestroyed();\n  };\n\n  _proto.onHandlerDestroying = function onHandlerDestroying() {\n    // clear all timers before unregistering from event bus\n    this.clearNextTick();\n    this.clearInterval();\n  };\n\n  _proto.onHandlerDestroyed = function onHandlerDestroyed() {}\n  /**\n   * @returns {boolean}\n   */\n  ;\n\n  _proto.hasInterval = function hasInterval() {\n    return !!this._tickInterval;\n  }\n  /**\n   * @returns {boolean}\n   */\n  ;\n\n  _proto.hasNextTick = function hasNextTick() {\n    return !!this._tickTimer;\n  }\n  /**\n   * @param {number} millis Interval time (ms)\n   * @returns {boolean} True when interval has been scheduled, false when already scheduled (no effect)\n   */\n  ;\n\n  _proto.setInterval = function setInterval(millis) {\n    if (!this._tickInterval) {\n      this._tickInterval = self.setInterval(this._boundTick, millis);\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * @returns {boolean} True when interval was cleared, false when none was set (no effect)\n   */\n  ;\n\n  _proto.clearInterval = function clearInterval() {\n    if (this._tickInterval) {\n      self.clearInterval(this._tickInterval);\n      this._tickInterval = null;\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * @returns {boolean} True when timeout was cleared, false when none was set (no effect)\n   */\n  ;\n\n  _proto.clearNextTick = function clearNextTick() {\n    if (this._tickTimer) {\n      self.clearTimeout(this._tickTimer);\n      this._tickTimer = null;\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * Will call the subclass doTick implementation in this main loop tick\n   * or in the next one (via setTimeout(,0)) in case it has already been called\n   * in this tick (in case this is a re-entrant call).\n   */\n  ;\n\n  _proto.tick = function tick() {\n    this._tickCallCount++;\n\n    if (this._tickCallCount === 1) {\n      this.doTick(); // re-entrant call to tick from previous doTick call stack\n      // -> schedule a call on the next main loop iteration to process this task processing request\n\n      if (this._tickCallCount > 1) {\n        // make sure only one timer exists at any time at max\n        this.tickImmediate();\n      }\n\n      this._tickCallCount = 0;\n    }\n  };\n\n  _proto.tickImmediate = function tickImmediate() {\n    this.clearNextTick();\n    this._tickTimer = self.setTimeout(this._boundTick, 0);\n  }\n  /**\n   * For subclass to implement task logic\n   * @abstract\n   */\n  ;\n\n  _proto.doTick = function doTick() {};\n\n  return TaskLoop;\n}();\n\n\n\n/***/ }),\n\n/***/ \"./src/types/cmcd.ts\":\n/*!***************************!*\\\n  !*** ./src/types/cmcd.ts ***!\n  \\***************************/\n/*! exports provided: CMCDVersion, CMCDObjectType, CMCDStreamingFormat, CMCDStreamType */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_827106__) {\n\n\"use strict\";\n__nested_webpack_require_827106__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_827106__.d(__webpack_exports__, \"CMCDVersion\", function() { return CMCDVersion; });\n/* harmony export (binding) */ __nested_webpack_require_827106__.d(__webpack_exports__, \"CMCDObjectType\", function() { return CMCDObjectType; });\n/* harmony export (binding) */ __nested_webpack_require_827106__.d(__webpack_exports__, \"CMCDStreamingFormat\", function() { return CMCDStreamingFormat; });\n/* harmony export (binding) */ __nested_webpack_require_827106__.d(__webpack_exports__, \"CMCDStreamType\", function() { return CMCDStreamType; });\n/**\n * CMCD spec version\n */\nvar CMCDVersion = 1;\n/**\n * CMCD Object Type\n */\n\nvar CMCDObjectType;\n/**\n * CMCD Streaming Format\n */\n\n(function (CMCDObjectType) {\n  CMCDObjectType[\"MANIFEST\"] = \"m\";\n  CMCDObjectType[\"AUDIO\"] = \"a\";\n  CMCDObjectType[\"VIDEO\"] = \"v\";\n  CMCDObjectType[\"MUXED\"] = \"av\";\n  CMCDObjectType[\"INIT\"] = \"i\";\n  CMCDObjectType[\"CAPTION\"] = \"c\";\n  CMCDObjectType[\"TIMED_TEXT\"] = \"tt\";\n  CMCDObjectType[\"KEY\"] = \"k\";\n  CMCDObjectType[\"OTHER\"] = \"o\";\n})(CMCDObjectType || (CMCDObjectType = {}));\n\nvar CMCDStreamingFormat;\n/**\n * CMCD Streaming Type\n */\n\n(function (CMCDStreamingFormat) {\n  CMCDStreamingFormat[\"DASH\"] = \"d\";\n  CMCDStreamingFormat[\"HLS\"] = \"h\";\n  CMCDStreamingFormat[\"SMOOTH\"] = \"s\";\n  CMCDStreamingFormat[\"OTHER\"] = \"o\";\n})(CMCDStreamingFormat || (CMCDStreamingFormat = {}));\n\nvar CMCDStreamType;\n/**\n * CMCD Headers\n */\n\n(function (CMCDStreamType) {\n  CMCDStreamType[\"VOD\"] = \"v\";\n  CMCDStreamType[\"LIVE\"] = \"l\";\n})(CMCDStreamType || (CMCDStreamType = {}));\n\n/***/ }),\n\n/***/ \"./src/types/level.ts\":\n/*!****************************!*\\\n  !*** ./src/types/level.ts ***!\n  \\****************************/\n/*! exports provided: HlsSkip, getSkipValue, HlsUrlParameters, Level */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_828973__) {\n\n\"use strict\";\n__nested_webpack_require_828973__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_828973__.d(__webpack_exports__, \"HlsSkip\", function() { return HlsSkip; });\n/* harmony export (binding) */ __nested_webpack_require_828973__.d(__webpack_exports__, \"getSkipValue\", function() { return getSkipValue; });\n/* harmony export (binding) */ __nested_webpack_require_828973__.d(__webpack_exports__, \"HlsUrlParameters\", function() { return HlsUrlParameters; });\n/* harmony export (binding) */ __nested_webpack_require_828973__.d(__webpack_exports__, \"Level\", function() { return Level; });\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar HlsSkip;\n\n(function (HlsSkip) {\n  HlsSkip[\"No\"] = \"\";\n  HlsSkip[\"Yes\"] = \"YES\";\n  HlsSkip[\"v2\"] = \"v2\";\n})(HlsSkip || (HlsSkip = {}));\n\nfunction getSkipValue(details, msn) {\n  var canSkipUntil = details.canSkipUntil,\n      canSkipDateRanges = details.canSkipDateRanges,\n      endSN = details.endSN;\n  var snChangeGoal = msn !== undefined ? msn - endSN : 0;\n\n  if (canSkipUntil && snChangeGoal < canSkipUntil) {\n    if (canSkipDateRanges) {\n      return HlsSkip.v2;\n    }\n\n    return HlsSkip.Yes;\n  }\n\n  return HlsSkip.No;\n}\nvar HlsUrlParameters = /*#__PURE__*/function () {\n  function HlsUrlParameters(msn, part, skip) {\n    this.msn = void 0;\n    this.part = void 0;\n    this.skip = void 0;\n    this.msn = msn;\n    this.part = part;\n    this.skip = skip;\n  }\n\n  var _proto = HlsUrlParameters.prototype;\n\n  _proto.addDirectives = function addDirectives(uri) {\n    var url = new self.URL(uri);\n\n    if (this.msn !== undefined) {\n      url.searchParams.set('_HLS_msn', this.msn.toString());\n    }\n\n    if (this.part !== undefined) {\n      url.searchParams.set('_HLS_part', this.part.toString());\n    }\n\n    if (this.skip) {\n      url.searchParams.set('_HLS_skip', this.skip);\n    }\n\n    return url.toString();\n  };\n\n  return HlsUrlParameters;\n}();\nvar Level = /*#__PURE__*/function () {\n  function Level(data) {\n    this.attrs = void 0;\n    this.audioCodec = void 0;\n    this.bitrate = void 0;\n    this.codecSet = void 0;\n    this.height = void 0;\n    this.id = void 0;\n    this.name = void 0;\n    this.videoCodec = void 0;\n    this.width = void 0;\n    this.unknownCodecs = void 0;\n    this.audioGroupIds = void 0;\n    this.details = void 0;\n    this.fragmentError = 0;\n    this.loadError = 0;\n    this.loaded = void 0;\n    this.realBitrate = 0;\n    this.textGroupIds = void 0;\n    this.url = void 0;\n    this._urlId = 0;\n    this.url = [data.url];\n    this.attrs = data.attrs;\n    this.bitrate = data.bitrate;\n\n    if (data.details) {\n      this.details = data.details;\n    }\n\n    this.id = data.id || 0;\n    this.name = data.name;\n    this.width = data.width || 0;\n    this.height = data.height || 0;\n    this.audioCodec = data.audioCodec;\n    this.videoCodec = data.videoCodec;\n    this.unknownCodecs = data.unknownCodecs;\n    this.codecSet = [data.videoCodec, data.audioCodec].filter(function (c) {\n      return c;\n    }).join(',').replace(/\\.[^.,]+/g, '');\n  }\n\n  _createClass(Level, [{\n    key: \"maxBitrate\",\n    get: function get() {\n      return Math.max(this.realBitrate, this.bitrate);\n    }\n  }, {\n    key: \"uri\",\n    get: function get() {\n      return this.url[this._urlId] || '';\n    }\n  }, {\n    key: \"urlId\",\n    get: function get() {\n      return this._urlId;\n    },\n    set: function set(value) {\n      var newValue = value % this.url.length;\n\n      if (this._urlId !== newValue) {\n        this.details = undefined;\n        this._urlId = newValue;\n      }\n    }\n  }]);\n\n  return Level;\n}();\n\n/***/ }),\n\n/***/ \"./src/types/loader.ts\":\n/*!*****************************!*\\\n  !*** ./src/types/loader.ts ***!\n  \\*****************************/\n/*! exports provided: PlaylistContextType, PlaylistLevelType */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_833253__) {\n\n\"use strict\";\n__nested_webpack_require_833253__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_833253__.d(__webpack_exports__, \"PlaylistContextType\", function() { return PlaylistContextType; });\n/* harmony export (binding) */ __nested_webpack_require_833253__.d(__webpack_exports__, \"PlaylistLevelType\", function() { return PlaylistLevelType; });\nvar PlaylistContextType;\n\n(function (PlaylistContextType) {\n  PlaylistContextType[\"MANIFEST\"] = \"manifest\";\n  PlaylistContextType[\"LEVEL\"] = \"level\";\n  PlaylistContextType[\"AUDIO_TRACK\"] = \"audioTrack\";\n  PlaylistContextType[\"SUBTITLE_TRACK\"] = \"subtitleTrack\";\n})(PlaylistContextType || (PlaylistContextType = {}));\n\nvar PlaylistLevelType;\n\n(function (PlaylistLevelType) {\n  PlaylistLevelType[\"MAIN\"] = \"main\";\n  PlaylistLevelType[\"AUDIO\"] = \"audio\";\n  PlaylistLevelType[\"SUBTITLE\"] = \"subtitle\";\n})(PlaylistLevelType || (PlaylistLevelType = {}));\n\n/***/ }),\n\n/***/ \"./src/types/transmuxer.ts\":\n/*!*********************************!*\\\n  !*** ./src/types/transmuxer.ts ***!\n  \\*********************************/\n/*! exports provided: ChunkMetadata */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_834411__) {\n\n\"use strict\";\n__nested_webpack_require_834411__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_834411__.d(__webpack_exports__, \"ChunkMetadata\", function() { return ChunkMetadata; });\nvar ChunkMetadata = function ChunkMetadata(level, sn, id, size, part, partial) {\n  if (size === void 0) {\n    size = 0;\n  }\n\n  if (part === void 0) {\n    part = -1;\n  }\n\n  if (partial === void 0) {\n    partial = false;\n  }\n\n  this.level = void 0;\n  this.sn = void 0;\n  this.part = void 0;\n  this.id = void 0;\n  this.size = void 0;\n  this.partial = void 0;\n  this.transmuxing = getNewPerformanceTiming();\n  this.buffering = {\n    audio: getNewPerformanceTiming(),\n    video: getNewPerformanceTiming(),\n    audiovideo: getNewPerformanceTiming()\n  };\n  this.level = level;\n  this.sn = sn;\n  this.id = id;\n  this.size = size;\n  this.part = part;\n  this.partial = partial;\n};\n\nfunction getNewPerformanceTiming() {\n  return {\n    start: 0,\n    executeStart: 0,\n    executeEnd: 0,\n    end: 0\n  };\n}\n\n/***/ }),\n\n/***/ \"./src/utils/attr-list.ts\":\n/*!********************************!*\\\n  !*** ./src/utils/attr-list.ts ***!\n  \\********************************/\n/*! exports provided: AttrList */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_835653__) {\n\n\"use strict\";\n__nested_webpack_require_835653__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_835653__.d(__webpack_exports__, \"AttrList\", function() { return AttrList; });\nvar DECIMAL_RESOLUTION_REGEX = /^(\\d+)x(\\d+)$/; // eslint-disable-line no-useless-escape\n\nvar ATTR_LIST_REGEX = /\\s*(.+?)\\s*=((?:\\\".*?\\\")|.*?)(?:,|$)/g; // eslint-disable-line no-useless-escape\n// adapted from https://github.com/kanongil/node-m3u8parse/blob/master/attrlist.js\n\nvar AttrList = /*#__PURE__*/function () {\n  function AttrList(attrs) {\n    if (typeof attrs === 'string') {\n      attrs = AttrList.parseAttrList(attrs);\n    }\n\n    for (var attr in attrs) {\n      if (attrs.hasOwnProperty(attr)) {\n        this[attr] = attrs[attr];\n      }\n    }\n  }\n\n  var _proto = AttrList.prototype;\n\n  _proto.decimalInteger = function decimalInteger(attrName) {\n    var intValue = parseInt(this[attrName], 10);\n\n    if (intValue > Number.MAX_SAFE_INTEGER) {\n      return Infinity;\n    }\n\n    return intValue;\n  };\n\n  _proto.hexadecimalInteger = function hexadecimalInteger(attrName) {\n    if (this[attrName]) {\n      var stringValue = (this[attrName] || '0x').slice(2);\n      stringValue = (stringValue.length & 1 ? '0' : '') + stringValue;\n      var value = new Uint8Array(stringValue.length / 2);\n\n      for (var i = 0; i < stringValue.length / 2; i++) {\n        value[i] = parseInt(stringValue.slice(i * 2, i * 2 + 2), 16);\n      }\n\n      return value;\n    } else {\n      return null;\n    }\n  };\n\n  _proto.hexadecimalIntegerAsNumber = function hexadecimalIntegerAsNumber(attrName) {\n    var intValue = parseInt(this[attrName], 16);\n\n    if (intValue > Number.MAX_SAFE_INTEGER) {\n      return Infinity;\n    }\n\n    return intValue;\n  };\n\n  _proto.decimalFloatingPoint = function decimalFloatingPoint(attrName) {\n    return parseFloat(this[attrName]);\n  };\n\n  _proto.optionalFloat = function optionalFloat(attrName, defaultValue) {\n    var value = this[attrName];\n    return value ? parseFloat(value) : defaultValue;\n  };\n\n  _proto.enumeratedString = function enumeratedString(attrName) {\n    return this[attrName];\n  };\n\n  _proto.bool = function bool(attrName) {\n    return this[attrName] === 'YES';\n  };\n\n  _proto.decimalResolution = function decimalResolution(attrName) {\n    var res = DECIMAL_RESOLUTION_REGEX.exec(this[attrName]);\n\n    if (res === null) {\n      return undefined;\n    }\n\n    return {\n      width: parseInt(res[1], 10),\n      height: parseInt(res[2], 10)\n    };\n  };\n\n  AttrList.parseAttrList = function parseAttrList(input) {\n    var match;\n    var attrs = {};\n    var quote = '\"';\n    ATTR_LIST_REGEX.lastIndex = 0;\n\n    while ((match = ATTR_LIST_REGEX.exec(input)) !== null) {\n      var value = match[2];\n\n      if (value.indexOf(quote) === 0 && value.lastIndexOf(quote) === value.length - 1) {\n        value = value.slice(1, -1);\n      }\n\n      attrs[match[1]] = value;\n    }\n\n    return attrs;\n  };\n\n  return AttrList;\n}();\n\n/***/ }),\n\n/***/ \"./src/utils/binary-search.ts\":\n/*!************************************!*\\\n  !*** ./src/utils/binary-search.ts ***!\n  \\************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_838854__) {\n\n\"use strict\";\n__nested_webpack_require_838854__.r(__webpack_exports__);\nvar BinarySearch = {\n  /**\n   * Searches for an item in an array which matches a certain condition.\n   * This requires the condition to only match one item in the array,\n   * and for the array to be ordered.\n   *\n   * @param {Array<T>} list The array to search.\n   * @param {BinarySearchComparison<T>} comparisonFn\n   *      Called and provided a candidate item as the first argument.\n   *      Should return:\n   *          > -1 if the item should be located at a lower index than the provided item.\n   *          > 1 if the item should be located at a higher index than the provided item.\n   *          > 0 if the item is the item you're looking for.\n   *\n   * @return {T | null} The object if it is found or null otherwise.\n   */\n  search: function search(list, comparisonFn) {\n    var minIndex = 0;\n    var maxIndex = list.length - 1;\n    var currentIndex = null;\n    var currentElement = null;\n\n    while (minIndex <= maxIndex) {\n      currentIndex = (minIndex + maxIndex) / 2 | 0;\n      currentElement = list[currentIndex];\n      var comparisonResult = comparisonFn(currentElement);\n\n      if (comparisonResult > 0) {\n        minIndex = currentIndex + 1;\n      } else if (comparisonResult < 0) {\n        maxIndex = currentIndex - 1;\n      } else {\n        return currentElement;\n      }\n    }\n\n    return null;\n  }\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (BinarySearch);\n\n/***/ }),\n\n/***/ \"./src/utils/buffer-helper.ts\":\n/*!************************************!*\\\n  !*** ./src/utils/buffer-helper.ts ***!\n  \\************************************/\n/*! exports provided: BufferHelper */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_840595__) {\n\n\"use strict\";\n__nested_webpack_require_840595__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_840595__.d(__webpack_exports__, \"BufferHelper\", function() { return BufferHelper; });\n/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_840595__(/*! ./logger */ \"./src/utils/logger.ts\");\n/**\n * @module BufferHelper\n *\n * Providing methods dealing with buffer length retrieval for example.\n *\n * In general, a helper around HTML5 MediaElement TimeRanges gathered from `buffered` property.\n *\n * Also @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/buffered\n */\n\nvar noopBuffered = {\n  length: 0,\n  start: function start() {\n    return 0;\n  },\n  end: function end() {\n    return 0;\n  }\n};\nvar BufferHelper = /*#__PURE__*/function () {\n  function BufferHelper() {}\n\n  /**\n   * Return true if `media`'s buffered include `position`\n   * @param {Bufferable} media\n   * @param {number} position\n   * @returns {boolean}\n   */\n  BufferHelper.isBuffered = function isBuffered(media, position) {\n    try {\n      if (media) {\n        var buffered = BufferHelper.getBuffered(media);\n\n        for (var i = 0; i < buffered.length; i++) {\n          if (position >= buffered.start(i) && position <= buffered.end(i)) {\n            return true;\n          }\n        }\n      }\n    } catch (error) {// this is to catch\n      // InvalidStateError: Failed to read the 'buffered' property from 'SourceBuffer':\n      // This SourceBuffer has been removed from the parent media source\n    }\n\n    return false;\n  };\n\n  BufferHelper.bufferInfo = function bufferInfo(media, pos, maxHoleDuration) {\n    try {\n      if (media) {\n        var vbuffered = BufferHelper.getBuffered(media);\n        var buffered = [];\n        var i;\n\n        for (i = 0; i < vbuffered.length; i++) {\n          buffered.push({\n            start: vbuffered.start(i),\n            end: vbuffered.end(i)\n          });\n        }\n\n        return this.bufferedInfo(buffered, pos, maxHoleDuration);\n      }\n    } catch (error) {// this is to catch\n      // InvalidStateError: Failed to read the 'buffered' property from 'SourceBuffer':\n      // This SourceBuffer has been removed from the parent media source\n    }\n\n    return {\n      len: 0,\n      start: pos,\n      end: pos,\n      nextStart: undefined\n    };\n  };\n\n  BufferHelper.bufferedInfo = function bufferedInfo(buffered, pos, maxHoleDuration) {\n    pos = Math.max(0, pos); // sort on buffer.start/smaller end (IE does not always return sorted buffered range)\n\n    buffered.sort(function (a, b) {\n      var diff = a.start - b.start;\n\n      if (diff) {\n        return diff;\n      } else {\n        return b.end - a.end;\n      }\n    });\n    var buffered2 = [];\n\n    if (maxHoleDuration) {\n      // there might be some small holes between buffer time range\n      // consider that holes smaller than maxHoleDuration are irrelevant and build another\n      // buffer time range representations that discards those holes\n      for (var i = 0; i < buffered.length; i++) {\n        var buf2len = buffered2.length;\n\n        if (buf2len) {\n          var buf2end = buffered2[buf2len - 1].end; // if small hole (value between 0 or maxHoleDuration ) or overlapping (negative)\n\n          if (buffered[i].start - buf2end < maxHoleDuration) {\n            // merge overlapping time ranges\n            // update lastRange.end only if smaller than item.end\n            // e.g.  [ 1, 15] with  [ 2,8] => [ 1,15] (no need to modify lastRange.end)\n            // whereas [ 1, 8] with  [ 2,15] => [ 1,15] ( lastRange should switch from [1,8] to [1,15])\n            if (buffered[i].end > buf2end) {\n              buffered2[buf2len - 1].end = buffered[i].end;\n            }\n          } else {\n            // big hole\n            buffered2.push(buffered[i]);\n          }\n        } else {\n          // first value\n          buffered2.push(buffered[i]);\n        }\n      }\n    } else {\n      buffered2 = buffered;\n    }\n\n    var bufferLen = 0; // bufferStartNext can possibly be undefined based on the conditional logic below\n\n    var bufferStartNext; // bufferStart and bufferEnd are buffer boundaries around current video position\n\n    var bufferStart = pos;\n    var bufferEnd = pos;\n\n    for (var _i = 0; _i < buffered2.length; _i++) {\n      var start = buffered2[_i].start;\n      var end = buffered2[_i].end; // logger.log('buf start/end:' + buffered.start(i) + '/' + buffered.end(i));\n\n      if (pos + maxHoleDuration >= start && pos < end) {\n        // play position is inside this buffer TimeRange, retrieve end of buffer position and buffer length\n        bufferStart = start;\n        bufferEnd = end;\n        bufferLen = bufferEnd - pos;\n      } else if (pos + maxHoleDuration < start) {\n        bufferStartNext = start;\n        break;\n      }\n    }\n\n    return {\n      len: bufferLen,\n      start: bufferStart || 0,\n      end: bufferEnd || 0,\n      nextStart: bufferStartNext\n    };\n  }\n  /**\n   * Safe method to get buffered property.\n   * SourceBuffer.buffered may throw if SourceBuffer is removed from it's MediaSource\n   */\n  ;\n\n  BufferHelper.getBuffered = function getBuffered(media) {\n    try {\n      return media.buffered;\n    } catch (e) {\n      _logger__WEBPACK_IMPORTED_MODULE_0__[\"logger\"].log('failed to get media.buffered', e);\n      return noopBuffered;\n    }\n  };\n\n  return BufferHelper;\n}();\n\n/***/ }),\n\n/***/ \"./src/utils/cea-608-parser.ts\":\n/*!*************************************!*\\\n  !*** ./src/utils/cea-608-parser.ts ***!\n  \\*************************************/\n/*! exports provided: Row, CaptionScreen, default */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_846225__) {\n\n\"use strict\";\n__nested_webpack_require_846225__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_846225__.d(__webpack_exports__, \"Row\", function() { return Row; });\n/* harmony export (binding) */ __nested_webpack_require_846225__.d(__webpack_exports__, \"CaptionScreen\", function() { return CaptionScreen; });\n/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_846225__(/*! ../utils/logger */ \"./src/utils/logger.ts\");\n\n/**\n *\n * This code was ported from the dash.js project at:\n *   https://github.com/Dash-Industry-Forum/dash.js/blob/development/externals/cea608-parser.js\n *   https://github.com/Dash-Industry-Forum/dash.js/commit/8269b26a761e0853bb21d78780ed945144ecdd4d#diff-71bc295a2d6b6b7093a1d3290d53a4b2\n *\n * The original copyright appears below:\n *\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2015-2016, DASH Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  1. Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  2. Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n\n/**\n *  Exceptions from regular ASCII. CodePoints are mapped to UTF-16 codes\n */\n\nvar specialCea608CharsCodes = {\n  0x2a: 0xe1,\n  // lowercase a, acute accent\n  0x5c: 0xe9,\n  // lowercase e, acute accent\n  0x5e: 0xed,\n  // lowercase i, acute accent\n  0x5f: 0xf3,\n  // lowercase o, acute accent\n  0x60: 0xfa,\n  // lowercase u, acute accent\n  0x7b: 0xe7,\n  // lowercase c with cedilla\n  0x7c: 0xf7,\n  // division symbol\n  0x7d: 0xd1,\n  // uppercase N tilde\n  0x7e: 0xf1,\n  // lowercase n tilde\n  0x7f: 0x2588,\n  // Full block\n  // THIS BLOCK INCLUDES THE 16 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS\n  // THAT COME FROM HI BYTE=0x11 AND LOW BETWEEN 0x30 AND 0x3F\n  // THIS MEANS THAT \\x50 MUST BE ADDED TO THE VALUES\n  0x80: 0xae,\n  // Registered symbol (R)\n  0x81: 0xb0,\n  // degree sign\n  0x82: 0xbd,\n  // 1/2 symbol\n  0x83: 0xbf,\n  // Inverted (open) question mark\n  0x84: 0x2122,\n  // Trademark symbol (TM)\n  0x85: 0xa2,\n  // Cents symbol\n  0x86: 0xa3,\n  // Pounds sterling\n  0x87: 0x266a,\n  // Music 8'th note\n  0x88: 0xe0,\n  // lowercase a, grave accent\n  0x89: 0x20,\n  // transparent space (regular)\n  0x8a: 0xe8,\n  // lowercase e, grave accent\n  0x8b: 0xe2,\n  // lowercase a, circumflex accent\n  0x8c: 0xea,\n  // lowercase e, circumflex accent\n  0x8d: 0xee,\n  // lowercase i, circumflex accent\n  0x8e: 0xf4,\n  // lowercase o, circumflex accent\n  0x8f: 0xfb,\n  // lowercase u, circumflex accent\n  // THIS BLOCK INCLUDES THE 32 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS\n  // THAT COME FROM HI BYTE=0x12 AND LOW BETWEEN 0x20 AND 0x3F\n  0x90: 0xc1,\n  // capital letter A with acute\n  0x91: 0xc9,\n  // capital letter E with acute\n  0x92: 0xd3,\n  // capital letter O with acute\n  0x93: 0xda,\n  // capital letter U with acute\n  0x94: 0xdc,\n  // capital letter U with diaresis\n  0x95: 0xfc,\n  // lowercase letter U with diaeresis\n  0x96: 0x2018,\n  // opening single quote\n  0x97: 0xa1,\n  // inverted exclamation mark\n  0x98: 0x2a,\n  // asterisk\n  0x99: 0x2019,\n  // closing single quote\n  0x9a: 0x2501,\n  // box drawings heavy horizontal\n  0x9b: 0xa9,\n  // copyright sign\n  0x9c: 0x2120,\n  // Service mark\n  0x9d: 0x2022,\n  // (round) bullet\n  0x9e: 0x201c,\n  // Left double quotation mark\n  0x9f: 0x201d,\n  // Right double quotation mark\n  0xa0: 0xc0,\n  // uppercase A, grave accent\n  0xa1: 0xc2,\n  // uppercase A, circumflex\n  0xa2: 0xc7,\n  // uppercase C with cedilla\n  0xa3: 0xc8,\n  // uppercase E, grave accent\n  0xa4: 0xca,\n  // uppercase E, circumflex\n  0xa5: 0xcb,\n  // capital letter E with diaresis\n  0xa6: 0xeb,\n  // lowercase letter e with diaresis\n  0xa7: 0xce,\n  // uppercase I, circumflex\n  0xa8: 0xcf,\n  // uppercase I, with diaresis\n  0xa9: 0xef,\n  // lowercase i, with diaresis\n  0xaa: 0xd4,\n  // uppercase O, circumflex\n  0xab: 0xd9,\n  // uppercase U, grave accent\n  0xac: 0xf9,\n  // lowercase u, grave accent\n  0xad: 0xdb,\n  // uppercase U, circumflex\n  0xae: 0xab,\n  // left-pointing double angle quotation mark\n  0xaf: 0xbb,\n  // right-pointing double angle quotation mark\n  // THIS BLOCK INCLUDES THE 32 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS\n  // THAT COME FROM HI BYTE=0x13 AND LOW BETWEEN 0x20 AND 0x3F\n  0xb0: 0xc3,\n  // Uppercase A, tilde\n  0xb1: 0xe3,\n  // Lowercase a, tilde\n  0xb2: 0xcd,\n  // Uppercase I, acute accent\n  0xb3: 0xcc,\n  // Uppercase I, grave accent\n  0xb4: 0xec,\n  // Lowercase i, grave accent\n  0xb5: 0xd2,\n  // Uppercase O, grave accent\n  0xb6: 0xf2,\n  // Lowercase o, grave accent\n  0xb7: 0xd5,\n  // Uppercase O, tilde\n  0xb8: 0xf5,\n  // Lowercase o, tilde\n  0xb9: 0x7b,\n  // Open curly brace\n  0xba: 0x7d,\n  // Closing curly brace\n  0xbb: 0x5c,\n  // Backslash\n  0xbc: 0x5e,\n  // Caret\n  0xbd: 0x5f,\n  // Underscore\n  0xbe: 0x7c,\n  // Pipe (vertical line)\n  0xbf: 0x223c,\n  // Tilde operator\n  0xc0: 0xc4,\n  // Uppercase A, umlaut\n  0xc1: 0xe4,\n  // Lowercase A, umlaut\n  0xc2: 0xd6,\n  // Uppercase O, umlaut\n  0xc3: 0xf6,\n  // Lowercase o, umlaut\n  0xc4: 0xdf,\n  // Esszett (sharp S)\n  0xc5: 0xa5,\n  // Yen symbol\n  0xc6: 0xa4,\n  // Generic currency sign\n  0xc7: 0x2503,\n  // Box drawings heavy vertical\n  0xc8: 0xc5,\n  // Uppercase A, ring\n  0xc9: 0xe5,\n  // Lowercase A, ring\n  0xca: 0xd8,\n  // Uppercase O, stroke\n  0xcb: 0xf8,\n  // Lowercase o, strok\n  0xcc: 0x250f,\n  // Box drawings heavy down and right\n  0xcd: 0x2513,\n  // Box drawings heavy down and left\n  0xce: 0x2517,\n  // Box drawings heavy up and right\n  0xcf: 0x251b // Box drawings heavy up and left\n\n};\n/**\n * Utils\n */\n\nvar getCharForByte = function getCharForByte(_byte) {\n  var charCode = _byte;\n\n  if (specialCea608CharsCodes.hasOwnProperty(_byte)) {\n    charCode = specialCea608CharsCodes[_byte];\n  }\n\n  return String.fromCharCode(charCode);\n};\n\nvar NR_ROWS = 15;\nvar NR_COLS = 100; // Tables to look up row from PAC data\n\nvar rowsLowCh1 = {\n  0x11: 1,\n  0x12: 3,\n  0x15: 5,\n  0x16: 7,\n  0x17: 9,\n  0x10: 11,\n  0x13: 12,\n  0x14: 14\n};\nvar rowsHighCh1 = {\n  0x11: 2,\n  0x12: 4,\n  0x15: 6,\n  0x16: 8,\n  0x17: 10,\n  0x13: 13,\n  0x14: 15\n};\nvar rowsLowCh2 = {\n  0x19: 1,\n  0x1a: 3,\n  0x1d: 5,\n  0x1e: 7,\n  0x1f: 9,\n  0x18: 11,\n  0x1b: 12,\n  0x1c: 14\n};\nvar rowsHighCh2 = {\n  0x19: 2,\n  0x1a: 4,\n  0x1d: 6,\n  0x1e: 8,\n  0x1f: 10,\n  0x1b: 13,\n  0x1c: 15\n};\nvar backgroundColors = ['white', 'green', 'blue', 'cyan', 'red', 'yellow', 'magenta', 'black', 'transparent'];\nvar VerboseLevel;\n\n(function (VerboseLevel) {\n  VerboseLevel[VerboseLevel[\"ERROR\"] = 0] = \"ERROR\";\n  VerboseLevel[VerboseLevel[\"TEXT\"] = 1] = \"TEXT\";\n  VerboseLevel[VerboseLevel[\"WARNING\"] = 2] = \"WARNING\";\n  VerboseLevel[VerboseLevel[\"INFO\"] = 2] = \"INFO\";\n  VerboseLevel[VerboseLevel[\"DEBUG\"] = 3] = \"DEBUG\";\n  VerboseLevel[VerboseLevel[\"DATA\"] = 3] = \"DATA\";\n})(VerboseLevel || (VerboseLevel = {}));\n\nvar CaptionsLogger = /*#__PURE__*/function () {\n  function CaptionsLogger() {\n    this.time = null;\n    this.verboseLevel = VerboseLevel.ERROR;\n  }\n\n  var _proto = CaptionsLogger.prototype;\n\n  _proto.log = function log(severity, msg) {\n    if (this.verboseLevel >= severity) {\n      _utils_logger__WEBPACK_IMPORTED_MODULE_0__[\"logger\"].log(this.time + \" [\" + severity + \"] \" + msg);\n    }\n  };\n\n  return CaptionsLogger;\n}();\n\nvar numArrayToHexArray = function numArrayToHexArray(numArray) {\n  var hexArray = [];\n\n  for (var j = 0; j < numArray.length; j++) {\n    hexArray.push(numArray[j].toString(16));\n  }\n\n  return hexArray;\n};\n\nvar PenState = /*#__PURE__*/function () {\n  function PenState(foreground, underline, italics, background, flash) {\n    this.foreground = void 0;\n    this.underline = void 0;\n    this.italics = void 0;\n    this.background = void 0;\n    this.flash = void 0;\n    this.foreground = foreground || 'white';\n    this.underline = underline || false;\n    this.italics = italics || false;\n    this.background = background || 'black';\n    this.flash = flash || false;\n  }\n\n  var _proto2 = PenState.prototype;\n\n  _proto2.reset = function reset() {\n    this.foreground = 'white';\n    this.underline = false;\n    this.italics = false;\n    this.background = 'black';\n    this.flash = false;\n  };\n\n  _proto2.setStyles = function setStyles(styles) {\n    var attribs = ['foreground', 'underline', 'italics', 'background', 'flash'];\n\n    for (var i = 0; i < attribs.length; i++) {\n      var style = attribs[i];\n\n      if (styles.hasOwnProperty(style)) {\n        this[style] = styles[style];\n      }\n    }\n  };\n\n  _proto2.isDefault = function isDefault() {\n    return this.foreground === 'white' && !this.underline && !this.italics && this.background === 'black' && !this.flash;\n  };\n\n  _proto2.equals = function equals(other) {\n    return this.foreground === other.foreground && this.underline === other.underline && this.italics === other.italics && this.background === other.background && this.flash === other.flash;\n  };\n\n  _proto2.copy = function copy(newPenState) {\n    this.foreground = newPenState.foreground;\n    this.underline = newPenState.underline;\n    this.italics = newPenState.italics;\n    this.background = newPenState.background;\n    this.flash = newPenState.flash;\n  };\n\n  _proto2.toString = function toString() {\n    return 'color=' + this.foreground + ', underline=' + this.underline + ', italics=' + this.italics + ', background=' + this.background + ', flash=' + this.flash;\n  };\n\n  return PenState;\n}();\n/**\n * Unicode character with styling and background.\n * @constructor\n */\n\n\nvar StyledUnicodeChar = /*#__PURE__*/function () {\n  function StyledUnicodeChar(uchar, foreground, underline, italics, background, flash) {\n    this.uchar = void 0;\n    this.penState = void 0;\n    this.uchar = uchar || ' '; // unicode character\n\n    this.penState = new PenState(foreground, underline, italics, background, flash);\n  }\n\n  var _proto3 = StyledUnicodeChar.prototype;\n\n  _proto3.reset = function reset() {\n    this.uchar = ' ';\n    this.penState.reset();\n  };\n\n  _proto3.setChar = function setChar(uchar, newPenState) {\n    this.uchar = uchar;\n    this.penState.copy(newPenState);\n  };\n\n  _proto3.setPenState = function setPenState(newPenState) {\n    this.penState.copy(newPenState);\n  };\n\n  _proto3.equals = function equals(other) {\n    return this.uchar === other.uchar && this.penState.equals(other.penState);\n  };\n\n  _proto3.copy = function copy(newChar) {\n    this.uchar = newChar.uchar;\n    this.penState.copy(newChar.penState);\n  };\n\n  _proto3.isEmpty = function isEmpty() {\n    return this.uchar === ' ' && this.penState.isDefault();\n  };\n\n  return StyledUnicodeChar;\n}();\n/**\n * CEA-608 row consisting of NR_COLS instances of StyledUnicodeChar.\n * @constructor\n */\n\n\nvar Row = /*#__PURE__*/function () {\n  function Row(logger) {\n    this.chars = void 0;\n    this.pos = void 0;\n    this.currPenState = void 0;\n    this.cueStartTime = void 0;\n    this.logger = void 0;\n    this.chars = [];\n\n    for (var i = 0; i < NR_COLS; i++) {\n      this.chars.push(new StyledUnicodeChar());\n    }\n\n    this.logger = logger;\n    this.pos = 0;\n    this.currPenState = new PenState();\n  }\n\n  var _proto4 = Row.prototype;\n\n  _proto4.equals = function equals(other) {\n    var equal = true;\n\n    for (var i = 0; i < NR_COLS; i++) {\n      if (!this.chars[i].equals(other.chars[i])) {\n        equal = false;\n        break;\n      }\n    }\n\n    return equal;\n  };\n\n  _proto4.copy = function copy(other) {\n    for (var i = 0; i < NR_COLS; i++) {\n      this.chars[i].copy(other.chars[i]);\n    }\n  };\n\n  _proto4.isEmpty = function isEmpty() {\n    var empty = true;\n\n    for (var i = 0; i < NR_COLS; i++) {\n      if (!this.chars[i].isEmpty()) {\n        empty = false;\n        break;\n      }\n    }\n\n    return empty;\n  }\n  /**\n   *  Set the cursor to a valid column.\n   */\n  ;\n\n  _proto4.setCursor = function setCursor(absPos) {\n    if (this.pos !== absPos) {\n      this.pos = absPos;\n    }\n\n    if (this.pos < 0) {\n      this.logger.log(VerboseLevel.DEBUG, 'Negative cursor position ' + this.pos);\n      this.pos = 0;\n    } else if (this.pos > NR_COLS) {\n      this.logger.log(VerboseLevel.DEBUG, 'Too large cursor position ' + this.pos);\n      this.pos = NR_COLS;\n    }\n  }\n  /**\n   * Move the cursor relative to current position.\n   */\n  ;\n\n  _proto4.moveCursor = function moveCursor(relPos) {\n    var newPos = this.pos + relPos;\n\n    if (relPos > 1) {\n      for (var i = this.pos + 1; i < newPos + 1; i++) {\n        this.chars[i].setPenState(this.currPenState);\n      }\n    }\n\n    this.setCursor(newPos);\n  }\n  /**\n   * Backspace, move one step back and clear character.\n   */\n  ;\n\n  _proto4.backSpace = function backSpace() {\n    this.moveCursor(-1);\n    this.chars[this.pos].setChar(' ', this.currPenState);\n  };\n\n  _proto4.insertChar = function insertChar(_byte2) {\n    if (_byte2 >= 0x90) {\n      // Extended char\n      this.backSpace();\n    }\n\n    var _char = getCharForByte(_byte2);\n\n    if (this.pos >= NR_COLS) {\n      this.logger.log(VerboseLevel.ERROR, 'Cannot insert ' + _byte2.toString(16) + ' (' + _char + ') at position ' + this.pos + '. Skipping it!');\n      return;\n    }\n\n    this.chars[this.pos].setChar(_char, this.currPenState);\n    this.moveCursor(1);\n  };\n\n  _proto4.clearFromPos = function clearFromPos(startPos) {\n    var i;\n\n    for (i = startPos; i < NR_COLS; i++) {\n      this.chars[i].reset();\n    }\n  };\n\n  _proto4.clear = function clear() {\n    this.clearFromPos(0);\n    this.pos = 0;\n    this.currPenState.reset();\n  };\n\n  _proto4.clearToEndOfRow = function clearToEndOfRow() {\n    this.clearFromPos(this.pos);\n  };\n\n  _proto4.getTextString = function getTextString() {\n    var chars = [];\n    var empty = true;\n\n    for (var i = 0; i < NR_COLS; i++) {\n      var _char2 = this.chars[i].uchar;\n\n      if (_char2 !== ' ') {\n        empty = false;\n      }\n\n      chars.push(_char2);\n    }\n\n    if (empty) {\n      return '';\n    } else {\n      return chars.join('');\n    }\n  };\n\n  _proto4.setPenStyles = function setPenStyles(styles) {\n    this.currPenState.setStyles(styles);\n    var currChar = this.chars[this.pos];\n    currChar.setPenState(this.currPenState);\n  };\n\n  return Row;\n}();\n/**\n * Keep a CEA-608 screen of 32x15 styled characters\n * @constructor\n */\n\nvar CaptionScreen = /*#__PURE__*/function () {\n  function CaptionScreen(logger) {\n    this.rows = void 0;\n    this.currRow = void 0;\n    this.nrRollUpRows = void 0;\n    this.lastOutputScreen = void 0;\n    this.logger = void 0;\n    this.rows = [];\n\n    for (var i = 0; i < NR_ROWS; i++) {\n      this.rows.push(new Row(logger));\n    } // Note that we use zero-based numbering (0-14)\n\n\n    this.logger = logger;\n    this.currRow = NR_ROWS - 1;\n    this.nrRollUpRows = null;\n    this.lastOutputScreen = null;\n    this.reset();\n  }\n\n  var _proto5 = CaptionScreen.prototype;\n\n  _proto5.reset = function reset() {\n    for (var i = 0; i < NR_ROWS; i++) {\n      this.rows[i].clear();\n    }\n\n    this.currRow = NR_ROWS - 1;\n  };\n\n  _proto5.equals = function equals(other) {\n    var equal = true;\n\n    for (var i = 0; i < NR_ROWS; i++) {\n      if (!this.rows[i].equals(other.rows[i])) {\n        equal = false;\n        break;\n      }\n    }\n\n    return equal;\n  };\n\n  _proto5.copy = function copy(other) {\n    for (var i = 0; i < NR_ROWS; i++) {\n      this.rows[i].copy(other.rows[i]);\n    }\n  };\n\n  _proto5.isEmpty = function isEmpty() {\n    var empty = true;\n\n    for (var i = 0; i < NR_ROWS; i++) {\n      if (!this.rows[i].isEmpty()) {\n        empty = false;\n        break;\n      }\n    }\n\n    return empty;\n  };\n\n  _proto5.backSpace = function backSpace() {\n    var row = this.rows[this.currRow];\n    row.backSpace();\n  };\n\n  _proto5.clearToEndOfRow = function clearToEndOfRow() {\n    var row = this.rows[this.currRow];\n    row.clearToEndOfRow();\n  }\n  /**\n   * Insert a character (without styling) in the current row.\n   */\n  ;\n\n  _proto5.insertChar = function insertChar(_char3) {\n    var row = this.rows[this.currRow];\n    row.insertChar(_char3);\n  };\n\n  _proto5.setPen = function setPen(styles) {\n    var row = this.rows[this.currRow];\n    row.setPenStyles(styles);\n  };\n\n  _proto5.moveCursor = function moveCursor(relPos) {\n    var row = this.rows[this.currRow];\n    row.moveCursor(relPos);\n  };\n\n  _proto5.setCursor = function setCursor(absPos) {\n    this.logger.log(VerboseLevel.INFO, 'setCursor: ' + absPos);\n    var row = this.rows[this.currRow];\n    row.setCursor(absPos);\n  };\n\n  _proto5.setPAC = function setPAC(pacData) {\n    this.logger.log(VerboseLevel.INFO, 'pacData = ' + JSON.stringify(pacData));\n    var newRow = pacData.row - 1;\n\n    if (this.nrRollUpRows && newRow < this.nrRollUpRows - 1) {\n      newRow = this.nrRollUpRows - 1;\n    } // Make sure this only affects Roll-up Captions by checking this.nrRollUpRows\n\n\n    if (this.nrRollUpRows && this.currRow !== newRow) {\n      // clear all rows first\n      for (var i = 0; i < NR_ROWS; i++) {\n        this.rows[i].clear();\n      } // Copy this.nrRollUpRows rows from lastOutputScreen and place it in the newRow location\n      // topRowIndex - the start of rows to copy (inclusive index)\n\n\n      var topRowIndex = this.currRow + 1 - this.nrRollUpRows; // We only copy if the last position was already shown.\n      // We use the cueStartTime value to check this.\n\n      var lastOutputScreen = this.lastOutputScreen;\n\n      if (lastOutputScreen) {\n        var prevLineTime = lastOutputScreen.rows[topRowIndex].cueStartTime;\n        var time = this.logger.time;\n\n        if (prevLineTime && time !== null && prevLineTime < time) {\n          for (var _i = 0; _i < this.nrRollUpRows; _i++) {\n            this.rows[newRow - this.nrRollUpRows + _i + 1].copy(lastOutputScreen.rows[topRowIndex + _i]);\n          }\n        }\n      }\n    }\n\n    this.currRow = newRow;\n    var row = this.rows[this.currRow];\n\n    if (pacData.indent !== null) {\n      var indent = pacData.indent;\n      var prevPos = Math.max(indent - 1, 0);\n      row.setCursor(pacData.indent);\n      pacData.color = row.chars[prevPos].penState.foreground;\n    }\n\n    var styles = {\n      foreground: pacData.color,\n      underline: pacData.underline,\n      italics: pacData.italics,\n      background: 'black',\n      flash: false\n    };\n    this.setPen(styles);\n  }\n  /**\n   * Set background/extra foreground, but first do back_space, and then insert space (backwards compatibility).\n   */\n  ;\n\n  _proto5.setBkgData = function setBkgData(bkgData) {\n    this.logger.log(VerboseLevel.INFO, 'bkgData = ' + JSON.stringify(bkgData));\n    this.backSpace();\n    this.setPen(bkgData);\n    this.insertChar(0x20); // Space\n  };\n\n  _proto5.setRollUpRows = function setRollUpRows(nrRows) {\n    this.nrRollUpRows = nrRows;\n  };\n\n  _proto5.rollUp = function rollUp() {\n    if (this.nrRollUpRows === null) {\n      this.logger.log(VerboseLevel.DEBUG, 'roll_up but nrRollUpRows not set yet');\n      return; // Not properly setup\n    }\n\n    this.logger.log(VerboseLevel.TEXT, this.getDisplayText());\n    var topRowIndex = this.currRow + 1 - this.nrRollUpRows;\n    var topRow = this.rows.splice(topRowIndex, 1)[0];\n    topRow.clear();\n    this.rows.splice(this.currRow, 0, topRow);\n    this.logger.log(VerboseLevel.INFO, 'Rolling up'); // this.logger.log(VerboseLevel.TEXT, this.get_display_text())\n  }\n  /**\n   * Get all non-empty rows with as unicode text.\n   */\n  ;\n\n  _proto5.getDisplayText = function getDisplayText(asOneRow) {\n    asOneRow = asOneRow || false;\n    var displayText = [];\n    var text = '';\n    var rowNr = -1;\n\n    for (var i = 0; i < NR_ROWS; i++) {\n      var rowText = this.rows[i].getTextString();\n\n      if (rowText) {\n        rowNr = i + 1;\n\n        if (asOneRow) {\n          displayText.push('Row ' + rowNr + \": '\" + rowText + \"'\");\n        } else {\n          displayText.push(rowText.trim());\n        }\n      }\n    }\n\n    if (displayText.length > 0) {\n      if (asOneRow) {\n        text = '[' + displayText.join(' | ') + ']';\n      } else {\n        text = displayText.join('\\n');\n      }\n    }\n\n    return text;\n  };\n\n  _proto5.getTextAndFormat = function getTextAndFormat() {\n    return this.rows;\n  };\n\n  return CaptionScreen;\n}(); // var modes = ['MODE_ROLL-UP', 'MODE_POP-ON', 'MODE_PAINT-ON', 'MODE_TEXT'];\n\nvar Cea608Channel = /*#__PURE__*/function () {\n  function Cea608Channel(channelNumber, outputFilter, logger) {\n    this.chNr = void 0;\n    this.outputFilter = void 0;\n    this.mode = void 0;\n    this.verbose = void 0;\n    this.displayedMemory = void 0;\n    this.nonDisplayedMemory = void 0;\n    this.lastOutputScreen = void 0;\n    this.currRollUpRow = void 0;\n    this.writeScreen = void 0;\n    this.cueStartTime = void 0;\n    this.logger = void 0;\n    this.chNr = channelNumber;\n    this.outputFilter = outputFilter;\n    this.mode = null;\n    this.verbose = 0;\n    this.displayedMemory = new CaptionScreen(logger);\n    this.nonDisplayedMemory = new CaptionScreen(logger);\n    this.lastOutputScreen = new CaptionScreen(logger);\n    this.currRollUpRow = this.displayedMemory.rows[NR_ROWS - 1];\n    this.writeScreen = this.displayedMemory;\n    this.mode = null;\n    this.cueStartTime = null; // Keeps track of where a cue started.\n\n    this.logger = logger;\n  }\n\n  var _proto6 = Cea608Channel.prototype;\n\n  _proto6.reset = function reset() {\n    this.mode = null;\n    this.displayedMemory.reset();\n    this.nonDisplayedMemory.reset();\n    this.lastOutputScreen.reset();\n    this.outputFilter.reset();\n    this.currRollUpRow = this.displayedMemory.rows[NR_ROWS - 1];\n    this.writeScreen = this.displayedMemory;\n    this.mode = null;\n    this.cueStartTime = null;\n  };\n\n  _proto6.getHandler = function getHandler() {\n    return this.outputFilter;\n  };\n\n  _proto6.setHandler = function setHandler(newHandler) {\n    this.outputFilter = newHandler;\n  };\n\n  _proto6.setPAC = function setPAC(pacData) {\n    this.writeScreen.setPAC(pacData);\n  };\n\n  _proto6.setBkgData = function setBkgData(bkgData) {\n    this.writeScreen.setBkgData(bkgData);\n  };\n\n  _proto6.setMode = function setMode(newMode) {\n    if (newMode === this.mode) {\n      return;\n    }\n\n    this.mode = newMode;\n    this.logger.log(VerboseLevel.INFO, 'MODE=' + newMode);\n\n    if (this.mode === 'MODE_POP-ON') {\n      this.writeScreen = this.nonDisplayedMemory;\n    } else {\n      this.writeScreen = this.displayedMemory;\n      this.writeScreen.reset();\n    }\n\n    if (this.mode !== 'MODE_ROLL-UP') {\n      this.displayedMemory.nrRollUpRows = null;\n      this.nonDisplayedMemory.nrRollUpRows = null;\n    }\n\n    this.mode = newMode;\n  };\n\n  _proto6.insertChars = function insertChars(chars) {\n    for (var i = 0; i < chars.length; i++) {\n      this.writeScreen.insertChar(chars[i]);\n    }\n\n    var screen = this.writeScreen === this.displayedMemory ? 'DISP' : 'NON_DISP';\n    this.logger.log(VerboseLevel.INFO, screen + ': ' + this.writeScreen.getDisplayText(true));\n\n    if (this.mode === 'MODE_PAINT-ON' || this.mode === 'MODE_ROLL-UP') {\n      this.logger.log(VerboseLevel.TEXT, 'DISPLAYED: ' + this.displayedMemory.getDisplayText(true));\n      this.outputDataUpdate();\n    }\n  };\n\n  _proto6.ccRCL = function ccRCL() {\n    // Resume Caption Loading (switch mode to Pop On)\n    this.logger.log(VerboseLevel.INFO, 'RCL - Resume Caption Loading');\n    this.setMode('MODE_POP-ON');\n  };\n\n  _proto6.ccBS = function ccBS() {\n    // BackSpace\n    this.logger.log(VerboseLevel.INFO, 'BS - BackSpace');\n\n    if (this.mode === 'MODE_TEXT') {\n      return;\n    }\n\n    this.writeScreen.backSpace();\n\n    if (this.writeScreen === this.displayedMemory) {\n      this.outputDataUpdate();\n    }\n  };\n\n  _proto6.ccAOF = function ccAOF() {// Reserved (formerly Alarm Off)\n  };\n\n  _proto6.ccAON = function ccAON() {// Reserved (formerly Alarm On)\n  };\n\n  _proto6.ccDER = function ccDER() {\n    // Delete to End of Row\n    this.logger.log(VerboseLevel.INFO, 'DER- Delete to End of Row');\n    this.writeScreen.clearToEndOfRow();\n    this.outputDataUpdate();\n  };\n\n  _proto6.ccRU = function ccRU(nrRows) {\n    // Roll-Up Captions-2,3,or 4 Rows\n    this.logger.log(VerboseLevel.INFO, 'RU(' + nrRows + ') - Roll Up');\n    this.writeScreen = this.displayedMemory;\n    this.setMode('MODE_ROLL-UP');\n    this.writeScreen.setRollUpRows(nrRows);\n  };\n\n  _proto6.ccFON = function ccFON() {\n    // Flash On\n    this.logger.log(VerboseLevel.INFO, 'FON - Flash On');\n    this.writeScreen.setPen({\n      flash: true\n    });\n  };\n\n  _proto6.ccRDC = function ccRDC() {\n    // Resume Direct Captioning (switch mode to PaintOn)\n    this.logger.log(VerboseLevel.INFO, 'RDC - Resume Direct Captioning');\n    this.setMode('MODE_PAINT-ON');\n  };\n\n  _proto6.ccTR = function ccTR() {\n    // Text Restart in text mode (not supported, however)\n    this.logger.log(VerboseLevel.INFO, 'TR');\n    this.setMode('MODE_TEXT');\n  };\n\n  _proto6.ccRTD = function ccRTD() {\n    // Resume Text Display in Text mode (not supported, however)\n    this.logger.log(VerboseLevel.INFO, 'RTD');\n    this.setMode('MODE_TEXT');\n  };\n\n  _proto6.ccEDM = function ccEDM() {\n    // Erase Displayed Memory\n    this.logger.log(VerboseLevel.INFO, 'EDM - Erase Displayed Memory');\n    this.displayedMemory.reset();\n    this.outputDataUpdate(true);\n  };\n\n  _proto6.ccCR = function ccCR() {\n    // Carriage Return\n    this.logger.log(VerboseLevel.INFO, 'CR - Carriage Return');\n    this.writeScreen.rollUp();\n    this.outputDataUpdate(true);\n  };\n\n  _proto6.ccENM = function ccENM() {\n    // Erase Non-Displayed Memory\n    this.logger.log(VerboseLevel.INFO, 'ENM - Erase Non-displayed Memory');\n    this.nonDisplayedMemory.reset();\n  };\n\n  _proto6.ccEOC = function ccEOC() {\n    // End of Caption (Flip Memories)\n    this.logger.log(VerboseLevel.INFO, 'EOC - End Of Caption');\n\n    if (this.mode === 'MODE_POP-ON') {\n      var tmp = this.displayedMemory;\n      this.displayedMemory = this.nonDisplayedMemory;\n      this.nonDisplayedMemory = tmp;\n      this.writeScreen = this.nonDisplayedMemory;\n      this.logger.log(VerboseLevel.TEXT, 'DISP: ' + this.displayedMemory.getDisplayText());\n    }\n\n    this.outputDataUpdate(true);\n  };\n\n  _proto6.ccTO = function ccTO(nrCols) {\n    // Tab Offset 1,2, or 3 columns\n    this.logger.log(VerboseLevel.INFO, 'TO(' + nrCols + ') - Tab Offset');\n    this.writeScreen.moveCursor(nrCols);\n  };\n\n  _proto6.ccMIDROW = function ccMIDROW(secondByte) {\n    // Parse MIDROW command\n    var styles = {\n      flash: false\n    };\n    styles.underline = secondByte % 2 === 1;\n    styles.italics = secondByte >= 0x2e;\n\n    if (!styles.italics) {\n      var colorIndex = Math.floor(secondByte / 2) - 0x10;\n      var colors = ['white', 'green', 'blue', 'cyan', 'red', 'yellow', 'magenta'];\n      styles.foreground = colors[colorIndex];\n    } else {\n      styles.foreground = 'white';\n    }\n\n    this.logger.log(VerboseLevel.INFO, 'MIDROW: ' + JSON.stringify(styles));\n    this.writeScreen.setPen(styles);\n  };\n\n  _proto6.outputDataUpdate = function outputDataUpdate(dispatch) {\n    if (dispatch === void 0) {\n      dispatch = false;\n    }\n\n    var time = this.logger.time;\n\n    if (time === null) {\n      return;\n    }\n\n    if (this.outputFilter) {\n      if (this.cueStartTime === null && !this.displayedMemory.isEmpty()) {\n        // Start of a new cue\n        this.cueStartTime = time;\n      } else {\n        if (!this.displayedMemory.equals(this.lastOutputScreen)) {\n          this.outputFilter.newCue(this.cueStartTime, time, this.lastOutputScreen);\n\n          if (dispatch && this.outputFilter.dispatchCue) {\n            this.outputFilter.dispatchCue();\n          }\n\n          this.cueStartTime = this.displayedMemory.isEmpty() ? null : time;\n        }\n      }\n\n      this.lastOutputScreen.copy(this.displayedMemory);\n    }\n  };\n\n  _proto6.cueSplitAtTime = function cueSplitAtTime(t) {\n    if (this.outputFilter) {\n      if (!this.displayedMemory.isEmpty()) {\n        if (this.outputFilter.newCue) {\n          this.outputFilter.newCue(this.cueStartTime, t, this.displayedMemory);\n        }\n\n        this.cueStartTime = t;\n      }\n    }\n  };\n\n  return Cea608Channel;\n}();\n\nvar Cea608Parser = /*#__PURE__*/function () {\n  function Cea608Parser(field, out1, out2) {\n    this.channels = void 0;\n    this.currentChannel = 0;\n    this.cmdHistory = void 0;\n    this.logger = void 0;\n    var logger = new CaptionsLogger();\n    this.channels = [null, new Cea608Channel(field, out1, logger), new Cea608Channel(field + 1, out2, logger)];\n    this.cmdHistory = createCmdHistory();\n    this.logger = logger;\n  }\n\n  var _proto7 = Cea608Parser.prototype;\n\n  _proto7.getHandler = function getHandler(channel) {\n    return this.channels[channel].getHandler();\n  };\n\n  _proto7.setHandler = function setHandler(channel, newHandler) {\n    this.channels[channel].setHandler(newHandler);\n  }\n  /**\n   * Add data for time t in forms of list of bytes (unsigned ints). The bytes are treated as pairs.\n   */\n  ;\n\n  _proto7.addData = function addData(time, byteList) {\n    var cmdFound;\n    var a;\n    var b;\n    var charsFound = false;\n    this.logger.time = time;\n\n    for (var i = 0; i < byteList.length; i += 2) {\n      a = byteList[i] & 0x7f;\n      b = byteList[i + 1] & 0x7f;\n\n      if (a === 0 && b === 0) {\n        continue;\n      } else {\n        this.logger.log(VerboseLevel.DATA, '[' + numArrayToHexArray([byteList[i], byteList[i + 1]]) + '] -> (' + numArrayToHexArray([a, b]) + ')');\n      }\n\n      cmdFound = this.parseCmd(a, b);\n\n      if (!cmdFound) {\n        cmdFound = this.parseMidrow(a, b);\n      }\n\n      if (!cmdFound) {\n        cmdFound = this.parsePAC(a, b);\n      }\n\n      if (!cmdFound) {\n        cmdFound = this.parseBackgroundAttributes(a, b);\n      }\n\n      if (!cmdFound) {\n        charsFound = this.parseChars(a, b);\n\n        if (charsFound) {\n          var currChNr = this.currentChannel;\n\n          if (currChNr && currChNr > 0) {\n            var channel = this.channels[currChNr];\n            channel.insertChars(charsFound);\n          } else {\n            this.logger.log(VerboseLevel.WARNING, 'No channel found yet. TEXT-MODE?');\n          }\n        }\n      }\n\n      if (!cmdFound && !charsFound) {\n        this.logger.log(VerboseLevel.WARNING, \"Couldn't parse cleaned data \" + numArrayToHexArray([a, b]) + ' orig: ' + numArrayToHexArray([byteList[i], byteList[i + 1]]));\n      }\n    }\n  }\n  /**\n   * Parse Command.\n   * @returns {Boolean} Tells if a command was found\n   */\n  ;\n\n  _proto7.parseCmd = function parseCmd(a, b) {\n    var cmdHistory = this.cmdHistory;\n    var cond1 = (a === 0x14 || a === 0x1c || a === 0x15 || a === 0x1d) && b >= 0x20 && b <= 0x2f;\n    var cond2 = (a === 0x17 || a === 0x1f) && b >= 0x21 && b <= 0x23;\n\n    if (!(cond1 || cond2)) {\n      return false;\n    }\n\n    if (hasCmdRepeated(a, b, cmdHistory)) {\n      setLastCmd(null, null, cmdHistory);\n      this.logger.log(VerboseLevel.DEBUG, 'Repeated command (' + numArrayToHexArray([a, b]) + ') is dropped');\n      return true;\n    }\n\n    var chNr = a === 0x14 || a === 0x15 || a === 0x17 ? 1 : 2;\n    var channel = this.channels[chNr];\n\n    if (a === 0x14 || a === 0x15 || a === 0x1c || a === 0x1d) {\n      if (b === 0x20) {\n        channel.ccRCL();\n      } else if (b === 0x21) {\n        channel.ccBS();\n      } else if (b === 0x22) {\n        channel.ccAOF();\n      } else if (b === 0x23) {\n        channel.ccAON();\n      } else if (b === 0x24) {\n        channel.ccDER();\n      } else if (b === 0x25) {\n        channel.ccRU(2);\n      } else if (b === 0x26) {\n        channel.ccRU(3);\n      } else if (b === 0x27) {\n        channel.ccRU(4);\n      } else if (b === 0x28) {\n        channel.ccFON();\n      } else if (b === 0x29) {\n        channel.ccRDC();\n      } else if (b === 0x2a) {\n        channel.ccTR();\n      } else if (b === 0x2b) {\n        channel.ccRTD();\n      } else if (b === 0x2c) {\n        channel.ccEDM();\n      } else if (b === 0x2d) {\n        channel.ccCR();\n      } else if (b === 0x2e) {\n        channel.ccENM();\n      } else if (b === 0x2f) {\n        channel.ccEOC();\n      }\n    } else {\n      // a == 0x17 || a == 0x1F\n      channel.ccTO(b - 0x20);\n    }\n\n    setLastCmd(a, b, cmdHistory);\n    this.currentChannel = chNr;\n    return true;\n  }\n  /**\n   * Parse midrow styling command\n   * @returns {Boolean}\n   */\n  ;\n\n  _proto7.parseMidrow = function parseMidrow(a, b) {\n    var chNr = 0;\n\n    if ((a === 0x11 || a === 0x19) && b >= 0x20 && b <= 0x2f) {\n      if (a === 0x11) {\n        chNr = 1;\n      } else {\n        chNr = 2;\n      }\n\n      if (chNr !== this.currentChannel) {\n        this.logger.log(VerboseLevel.ERROR, 'Mismatch channel in midrow parsing');\n        return false;\n      }\n\n      var channel = this.channels[chNr];\n\n      if (!channel) {\n        return false;\n      }\n\n      channel.ccMIDROW(b);\n      this.logger.log(VerboseLevel.DEBUG, 'MIDROW (' + numArrayToHexArray([a, b]) + ')');\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * Parse Preable Access Codes (Table 53).\n   * @returns {Boolean} Tells if PAC found\n   */\n  ;\n\n  _proto7.parsePAC = function parsePAC(a, b) {\n    var row;\n    var cmdHistory = this.cmdHistory;\n    var case1 = (a >= 0x11 && a <= 0x17 || a >= 0x19 && a <= 0x1f) && b >= 0x40 && b <= 0x7f;\n    var case2 = (a === 0x10 || a === 0x18) && b >= 0x40 && b <= 0x5f;\n\n    if (!(case1 || case2)) {\n      return false;\n    }\n\n    if (hasCmdRepeated(a, b, cmdHistory)) {\n      setLastCmd(null, null, cmdHistory);\n      return true; // Repeated commands are dropped (once)\n    }\n\n    var chNr = a <= 0x17 ? 1 : 2;\n\n    if (b >= 0x40 && b <= 0x5f) {\n      row = chNr === 1 ? rowsLowCh1[a] : rowsLowCh2[a];\n    } else {\n      // 0x60 <= b <= 0x7F\n      row = chNr === 1 ? rowsHighCh1[a] : rowsHighCh2[a];\n    }\n\n    var channel = this.channels[chNr];\n\n    if (!channel) {\n      return false;\n    }\n\n    channel.setPAC(this.interpretPAC(row, b));\n    setLastCmd(a, b, cmdHistory);\n    this.currentChannel = chNr;\n    return true;\n  }\n  /**\n   * Interpret the second byte of the pac, and return the information.\n   * @returns {Object} pacData with style parameters.\n   */\n  ;\n\n  _proto7.interpretPAC = function interpretPAC(row, _byte3) {\n    var pacIndex;\n    var pacData = {\n      color: null,\n      italics: false,\n      indent: null,\n      underline: false,\n      row: row\n    };\n\n    if (_byte3 > 0x5f) {\n      pacIndex = _byte3 - 0x60;\n    } else {\n      pacIndex = _byte3 - 0x40;\n    }\n\n    pacData.underline = (pacIndex & 1) === 1;\n\n    if (pacIndex <= 0xd) {\n      pacData.color = ['white', 'green', 'blue', 'cyan', 'red', 'yellow', 'magenta', 'white'][Math.floor(pacIndex / 2)];\n    } else if (pacIndex <= 0xf) {\n      pacData.italics = true;\n      pacData.color = 'white';\n    } else {\n      pacData.indent = Math.floor((pacIndex - 0x10) / 2) * 4;\n    }\n\n    return pacData; // Note that row has zero offset. The spec uses 1.\n  }\n  /**\n   * Parse characters.\n   * @returns An array with 1 to 2 codes corresponding to chars, if found. null otherwise.\n   */\n  ;\n\n  _proto7.parseChars = function parseChars(a, b) {\n    var channelNr;\n    var charCodes = null;\n    var charCode1 = null;\n\n    if (a >= 0x19) {\n      channelNr = 2;\n      charCode1 = a - 8;\n    } else {\n      channelNr = 1;\n      charCode1 = a;\n    }\n\n    if (charCode1 >= 0x11 && charCode1 <= 0x13) {\n      // Special character\n      var oneCode;\n\n      if (charCode1 === 0x11) {\n        oneCode = b + 0x50;\n      } else if (charCode1 === 0x12) {\n        oneCode = b + 0x70;\n      } else {\n        oneCode = b + 0x90;\n      }\n\n      this.logger.log(VerboseLevel.INFO, \"Special char '\" + getCharForByte(oneCode) + \"' in channel \" + channelNr);\n      charCodes = [oneCode];\n    } else if (a >= 0x20 && a <= 0x7f) {\n      charCodes = b === 0 ? [a] : [a, b];\n    }\n\n    if (charCodes) {\n      var hexCodes = numArrayToHexArray(charCodes);\n      this.logger.log(VerboseLevel.DEBUG, 'Char codes =  ' + hexCodes.join(','));\n      setLastCmd(a, b, this.cmdHistory);\n    }\n\n    return charCodes;\n  }\n  /**\n   * Parse extended background attributes as well as new foreground color black.\n   * @returns {Boolean} Tells if background attributes are found\n   */\n  ;\n\n  _proto7.parseBackgroundAttributes = function parseBackgroundAttributes(a, b) {\n    var case1 = (a === 0x10 || a === 0x18) && b >= 0x20 && b <= 0x2f;\n    var case2 = (a === 0x17 || a === 0x1f) && b >= 0x2d && b <= 0x2f;\n\n    if (!(case1 || case2)) {\n      return false;\n    }\n\n    var index;\n    var bkgData = {};\n\n    if (a === 0x10 || a === 0x18) {\n      index = Math.floor((b - 0x20) / 2);\n      bkgData.background = backgroundColors[index];\n\n      if (b % 2 === 1) {\n        bkgData.background = bkgData.background + '_semi';\n      }\n    } else if (b === 0x2d) {\n      bkgData.background = 'transparent';\n    } else {\n      bkgData.foreground = 'black';\n\n      if (b === 0x2f) {\n        bkgData.underline = true;\n      }\n    }\n\n    var chNr = a <= 0x17 ? 1 : 2;\n    var channel = this.channels[chNr];\n    channel.setBkgData(bkgData);\n    setLastCmd(a, b, this.cmdHistory);\n    return true;\n  }\n  /**\n   * Reset state of parser and its channels.\n   */\n  ;\n\n  _proto7.reset = function reset() {\n    for (var i = 0; i < Object.keys(this.channels).length; i++) {\n      var channel = this.channels[i];\n\n      if (channel) {\n        channel.reset();\n      }\n    }\n\n    this.cmdHistory = createCmdHistory();\n  }\n  /**\n   * Trigger the generation of a cue, and the start of a new one if displayScreens are not empty.\n   */\n  ;\n\n  _proto7.cueSplitAtTime = function cueSplitAtTime(t) {\n    for (var i = 0; i < this.channels.length; i++) {\n      var channel = this.channels[i];\n\n      if (channel) {\n        channel.cueSplitAtTime(t);\n      }\n    }\n  };\n\n  return Cea608Parser;\n}();\n\nfunction setLastCmd(a, b, cmdHistory) {\n  cmdHistory.a = a;\n  cmdHistory.b = b;\n}\n\nfunction hasCmdRepeated(a, b, cmdHistory) {\n  return cmdHistory.a === a && cmdHistory.b === b;\n}\n\nfunction createCmdHistory() {\n  return {\n    a: null,\n    b: null\n  };\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Cea608Parser);\n\n/***/ }),\n\n/***/ \"./src/utils/codecs.ts\":\n/*!*****************************!*\\\n  !*** ./src/utils/codecs.ts ***!\n  \\*****************************/\n/*! exports provided: isCodecType, isCodecSupportedInMp4 */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_885739__) {\n\n\"use strict\";\n__nested_webpack_require_885739__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_885739__.d(__webpack_exports__, \"isCodecType\", function() { return isCodecType; });\n/* harmony export (binding) */ __nested_webpack_require_885739__.d(__webpack_exports__, \"isCodecSupportedInMp4\", function() { return isCodecSupportedInMp4; });\n// from http://mp4ra.org/codecs.html\nvar sampleEntryCodesISO = {\n  audio: {\n    a3ds: true,\n    'ac-3': true,\n    'ac-4': true,\n    alac: true,\n    alaw: true,\n    dra1: true,\n    'dts+': true,\n    'dts-': true,\n    dtsc: true,\n    dtse: true,\n    dtsh: true,\n    'ec-3': true,\n    enca: true,\n    g719: true,\n    g726: true,\n    m4ae: true,\n    mha1: true,\n    mha2: true,\n    mhm1: true,\n    mhm2: true,\n    mlpa: true,\n    mp4a: true,\n    'raw ': true,\n    Opus: true,\n    samr: true,\n    sawb: true,\n    sawp: true,\n    sevc: true,\n    sqcp: true,\n    ssmv: true,\n    twos: true,\n    ulaw: true\n  },\n  video: {\n    avc1: true,\n    avc2: true,\n    avc3: true,\n    avc4: true,\n    avcp: true,\n    av01: true,\n    drac: true,\n    dvav: true,\n    dvhe: true,\n    encv: true,\n    hev1: true,\n    hvc1: true,\n    mjp2: true,\n    mp4v: true,\n    mvc1: true,\n    mvc2: true,\n    mvc3: true,\n    mvc4: true,\n    resv: true,\n    rv60: true,\n    s263: true,\n    svc1: true,\n    svc2: true,\n    'vc-1': true,\n    vp08: true,\n    vp09: true\n  },\n  text: {\n    stpp: true,\n    wvtt: true\n  }\n};\nfunction isCodecType(codec, type) {\n  var typeCodes = sampleEntryCodesISO[type];\n  return !!typeCodes && typeCodes[codec.slice(0, 4)] === true;\n}\nfunction isCodecSupportedInMp4(codec, type) {\n  return MediaSource.isTypeSupported((type || 'video') + \"/mp4;codecs=\\\"\" + codec + \"\\\"\");\n}\n\n/***/ }),\n\n/***/ \"./src/utils/cues.ts\":\n/*!***************************!*\\\n  !*** ./src/utils/cues.ts ***!\n  \\***************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_887680__) {\n\n\"use strict\";\n__nested_webpack_require_887680__.r(__webpack_exports__);\n/* harmony import */ var _vttparser__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_887680__(/*! ./vttparser */ \"./src/utils/vttparser.ts\");\n/* harmony import */ var _webvtt_parser__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_887680__(/*! ./webvtt-parser */ \"./src/utils/webvtt-parser.ts\");\n/* harmony import */ var _texttrack_utils__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_887680__(/*! ./texttrack-utils */ \"./src/utils/texttrack-utils.ts\");\n\n\n\nvar WHITESPACE_CHAR = /\\s/;\nvar Cues = {\n  newCue: function newCue(track, startTime, endTime, captionScreen) {\n    var result = [];\n    var row; // the type data states this is VTTCue, but it can potentially be a TextTrackCue on old browsers\n\n    var cue;\n    var indenting;\n    var indent;\n    var text;\n    var Cue = self.VTTCue || self.TextTrackCue;\n\n    for (var r = 0; r < captionScreen.rows.length; r++) {\n      row = captionScreen.rows[r];\n      indenting = true;\n      indent = 0;\n      text = '';\n\n      if (!row.isEmpty()) {\n        for (var c = 0; c < row.chars.length; c++) {\n          if (WHITESPACE_CHAR.test(row.chars[c].uchar) && indenting) {\n            indent++;\n          } else {\n            text += row.chars[c].uchar;\n            indenting = false;\n          }\n        } // To be used for cleaning-up orphaned roll-up captions\n\n\n        row.cueStartTime = startTime; // Give a slight bump to the endTime if it's equal to startTime to avoid a SyntaxError in IE\n\n        if (startTime === endTime) {\n          endTime += 0.0001;\n        }\n\n        if (indent >= 16) {\n          indent--;\n        } else {\n          indent++;\n        }\n\n        var cueText = Object(_vttparser__WEBPACK_IMPORTED_MODULE_0__[\"fixLineBreaks\"])(text.trim());\n        var id = Object(_webvtt_parser__WEBPACK_IMPORTED_MODULE_1__[\"generateCueId\"])(startTime, endTime, cueText); // If this cue already exists in the track do not push it\n\n        if (!track || !track.cues || !track.cues.getCueById(id)) {\n          cue = new Cue(startTime, endTime, cueText);\n          cue.id = id;\n          cue.line = r + 1;\n          cue.align = 'left'; // Clamp the position between 10 and 80 percent (CEA-608 PAC indent code)\n          // https://dvcs.w3.org/hg/text-tracks/raw-file/default/608toVTT/608toVTT.html#positioning-in-cea-608\n          // Firefox throws an exception and captions break with out of bounds 0-100 values\n\n          cue.position = 10 + Math.min(80, Math.floor(indent * 8 / 32) * 10);\n          result.push(cue);\n        }\n      }\n    }\n\n    if (track && result.length) {\n      // Sort bottom cues in reverse order so that they render in line order when overlapping in Chrome\n      result.sort(function (cueA, cueB) {\n        if (cueA.line === 'auto' || cueB.line === 'auto') {\n          return 0;\n        }\n\n        if (cueA.line > 8 && cueB.line > 8) {\n          return cueB.line - cueA.line;\n        }\n\n        return cueA.line - cueB.line;\n      });\n      result.forEach(function (cue) {\n        return Object(_texttrack_utils__WEBPACK_IMPORTED_MODULE_2__[\"addCueToTrack\"])(track, cue);\n      });\n    }\n\n    return result;\n  }\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (Cues);\n\n/***/ }),\n\n/***/ \"./src/utils/discontinuities.ts\":\n/*!**************************************!*\\\n  !*** ./src/utils/discontinuities.ts ***!\n  \\**************************************/\n/*! exports provided: findFirstFragWithCC, shouldAlignOnDiscontinuities, findDiscontinuousReferenceFrag, adjustSlidingStart, alignStream, alignPDT, alignFragmentByPDTDelta, alignMediaPlaylistByPDT */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_891337__) {\n\n\"use strict\";\n__nested_webpack_require_891337__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_891337__.d(__webpack_exports__, \"findFirstFragWithCC\", function() { return findFirstFragWithCC; });\n/* harmony export (binding) */ __nested_webpack_require_891337__.d(__webpack_exports__, \"shouldAlignOnDiscontinuities\", function() { return shouldAlignOnDiscontinuities; });\n/* harmony export (binding) */ __nested_webpack_require_891337__.d(__webpack_exports__, \"findDiscontinuousReferenceFrag\", function() { return findDiscontinuousReferenceFrag; });\n/* harmony export (binding) */ __nested_webpack_require_891337__.d(__webpack_exports__, \"adjustSlidingStart\", function() { return adjustSlidingStart; });\n/* harmony export (binding) */ __nested_webpack_require_891337__.d(__webpack_exports__, \"alignStream\", function() { return alignStream; });\n/* harmony export (binding) */ __nested_webpack_require_891337__.d(__webpack_exports__, \"alignPDT\", function() { return alignPDT; });\n/* harmony export (binding) */ __nested_webpack_require_891337__.d(__webpack_exports__, \"alignFragmentByPDTDelta\", function() { return alignFragmentByPDTDelta; });\n/* harmony export (binding) */ __nested_webpack_require_891337__.d(__webpack_exports__, \"alignMediaPlaylistByPDT\", function() { return alignMediaPlaylistByPDT; });\n/* harmony import */ var _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_891337__(/*! ./src/polyfills/number */ \"./src/polyfills/number.ts\");\n/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_891337__(/*! ./logger */ \"./src/utils/logger.ts\");\n/* harmony import */ var _controller_level_helper__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_891337__(/*! ../controller/level-helper */ \"./src/controller/level-helper.ts\");\n\n\n\n\nfunction findFirstFragWithCC(fragments, cc) {\n  var firstFrag = null;\n\n  for (var i = 0, len = fragments.length; i < len; i++) {\n    var currentFrag = fragments[i];\n\n    if (currentFrag && currentFrag.cc === cc) {\n      firstFrag = currentFrag;\n      break;\n    }\n  }\n\n  return firstFrag;\n}\nfunction shouldAlignOnDiscontinuities(lastFrag, lastLevel, details) {\n  if (lastLevel.details) {\n    if (details.endCC > details.startCC || lastFrag && lastFrag.cc < details.startCC) {\n      return true;\n    }\n  }\n\n  return false;\n} // Find the first frag in the previous level which matches the CC of the first frag of the new level\n\nfunction findDiscontinuousReferenceFrag(prevDetails, curDetails) {\n  var prevFrags = prevDetails.fragments;\n  var curFrags = curDetails.fragments;\n\n  if (!curFrags.length || !prevFrags.length) {\n    _logger__WEBPACK_IMPORTED_MODULE_1__[\"logger\"].log('No fragments to align');\n    return;\n  }\n\n  var prevStartFrag = findFirstFragWithCC(prevFrags, curFrags[0].cc);\n\n  if (!prevStartFrag || prevStartFrag && !prevStartFrag.startPTS) {\n    _logger__WEBPACK_IMPORTED_MODULE_1__[\"logger\"].log('No frag in previous level to align on');\n    return;\n  }\n\n  return prevStartFrag;\n}\n\nfunction adjustFragmentStart(frag, sliding) {\n  if (frag) {\n    var start = frag.start + sliding;\n    frag.start = frag.startPTS = start;\n    frag.endPTS = start + frag.duration;\n  }\n}\n\nfunction adjustSlidingStart(sliding, details) {\n  // Update segments\n  var fragments = details.fragments;\n\n  for (var i = 0, len = fragments.length; i < len; i++) {\n    adjustFragmentStart(fragments[i], sliding);\n  } // Update LL-HLS parts at the end of the playlist\n\n\n  if (details.fragmentHint) {\n    adjustFragmentStart(details.fragmentHint, sliding);\n  }\n\n  details.alignedSliding = true;\n}\n/**\n * Using the parameters of the last level, this function computes PTS' of the new fragments so that they form a\n * contiguous stream with the last fragments.\n * The PTS of a fragment lets Hls.js know where it fits into a stream - by knowing every PTS, we know which fragment to\n * download at any given time. PTS is normally computed when the fragment is demuxed, so taking this step saves us time\n * and an extra download.\n * @param lastFrag\n * @param lastLevel\n * @param details\n */\n\nfunction alignStream(lastFrag, lastLevel, details) {\n  if (!lastLevel) {\n    return;\n  }\n\n  alignDiscontinuities(lastFrag, details, lastLevel);\n\n  if (!details.alignedSliding && lastLevel.details) {\n    // If the PTS wasn't figured out via discontinuity sequence that means there was no CC increase within the level.\n    // Aligning via Program Date Time should therefore be reliable, since PDT should be the same within the same\n    // discontinuity sequence.\n    alignPDT(details, lastLevel.details);\n  }\n\n  if (!details.alignedSliding && lastLevel.details && !details.skippedSegments) {\n    // Try to align on sn so that we pick a better start fragment.\n    // Do not perform this on playlists with delta updates as this is only to align levels on switch\n    // and adjustSliding only adjusts fragments after skippedSegments.\n    Object(_controller_level_helper__WEBPACK_IMPORTED_MODULE_2__[\"adjustSliding\"])(lastLevel.details, details);\n  }\n}\n/**\n * Computes the PTS if a new level's fragments using the PTS of a fragment in the last level which shares the same\n * discontinuity sequence.\n * @param lastFrag - The last Fragment which shares the same discontinuity sequence\n * @param lastLevel - The details of the last loaded level\n * @param details - The details of the new level\n */\n\nfunction alignDiscontinuities(lastFrag, details, lastLevel) {\n  if (shouldAlignOnDiscontinuities(lastFrag, lastLevel, details)) {\n    var referenceFrag = findDiscontinuousReferenceFrag(lastLevel.details, details);\n\n    if (referenceFrag && Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__[\"isFiniteNumber\"])(referenceFrag.start)) {\n      _logger__WEBPACK_IMPORTED_MODULE_1__[\"logger\"].log(\"Adjusting PTS using last level due to CC increase within current level \" + details.url);\n      adjustSlidingStart(referenceFrag.start, details);\n    }\n  }\n}\n/**\n * Computes the PTS of a new level's fragments using the difference in Program Date Time from the last level.\n * @param details - The details of the new level\n * @param lastDetails - The details of the last loaded level\n */\n\n\nfunction alignPDT(details, lastDetails) {\n  // This check protects the unsafe \"!\" usage below for null program date time access.\n  if (!lastDetails.fragments.length || !details.hasProgramDateTime || !lastDetails.hasProgramDateTime) {\n    return;\n  } // if last level sliding is 1000 and its first frag PROGRAM-DATE-TIME is 2017-08-20 1:10:00 AM\n  // and if new details first frag PROGRAM DATE-TIME is 2017-08-20 1:10:08 AM\n  // then we can deduce that playlist B sliding is 1000+8 = 1008s\n\n\n  var lastPDT = lastDetails.fragments[0].programDateTime; // hasProgramDateTime check above makes this safe.\n\n  var newPDT = details.fragments[0].programDateTime; // date diff is in ms. frag.start is in seconds\n\n  var sliding = (newPDT - lastPDT) / 1000 + lastDetails.fragments[0].start;\n\n  if (sliding && Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__[\"isFiniteNumber\"])(sliding)) {\n    _logger__WEBPACK_IMPORTED_MODULE_1__[\"logger\"].log(\"Adjusting PTS using programDateTime delta \" + (newPDT - lastPDT) + \"ms, sliding:\" + sliding.toFixed(3) + \" \" + details.url + \" \");\n    adjustSlidingStart(sliding, details);\n  }\n}\nfunction alignFragmentByPDTDelta(frag, delta) {\n  var programDateTime = frag.programDateTime;\n  if (!programDateTime) return;\n  var start = (programDateTime - delta) / 1000;\n  frag.start = frag.startPTS = start;\n  frag.endPTS = start + frag.duration;\n}\n/**\n * Ensures appropriate time-alignment between renditions based on PDT. Unlike `alignPDT`, which adjusts\n * the timeline based on the delta between PDTs of the 0th fragment of two playlists/`LevelDetails`,\n * this function assumes the timelines represented in `refDetails` are accurate, including the PDTs,\n * and uses the \"wallclock\"/PDT timeline as a cross-reference to `details`, adjusting the presentation\n * times/timelines of `details` accordingly.\n * Given the asynchronous nature of fetches and initial loads of live `main` and audio/subtitle tracks,\n * the primary purpose of this function is to ensure the \"local timelines\" of audio/subtitle tracks\n * are aligned to the main/video timeline, using PDT as the cross-reference/\"anchor\" that should\n * be consistent across playlists, per the HLS spec.\n * @param details - The details of the rendition you'd like to time-align (e.g. an audio rendition).\n * @param refDetails - The details of the reference rendition with start and PDT times for alignment.\n */\n\nfunction alignMediaPlaylistByPDT(details, refDetails) {\n  // This check protects the unsafe \"!\" usage below for null program date time access.\n  if (!refDetails.fragments.length || !details.hasProgramDateTime || !refDetails.hasProgramDateTime) {\n    return;\n  }\n\n  var refPDT = refDetails.fragments[0].programDateTime; // hasProgramDateTime check above makes this safe.\n\n  var refStart = refDetails.fragments[0].start; // Use the delta between the reference details' presentation timeline's start time and its PDT\n  // to align the other rendtion's timeline.\n\n  var delta = refPDT - refStart * 1000; // Per spec: \"If any Media Playlist in a Master Playlist contains an EXT-X-PROGRAM-DATE-TIME tag, then all\n  // Media Playlists in that Master Playlist MUST contain EXT-X-PROGRAM-DATE-TIME tags with consistent mappings\n  // of date and time to media timestamps.\"\n  // So we should be able to use each rendition's PDT as a reference time and use the delta to compute our relevant\n  // start and end times.\n  // NOTE: This code assumes each level/details timelines have already been made \"internally consistent\"\n\n  details.fragments.forEach(function (frag) {\n    alignFragmentByPDTDelta(frag, delta);\n  });\n\n  if (details.fragmentHint) {\n    alignFragmentByPDTDelta(details.fragmentHint, delta);\n  }\n\n  details.alignedSliding = true;\n}\n\n/***/ }),\n\n/***/ \"./src/utils/ewma-bandwidth-estimator.ts\":\n/*!***********************************************!*\\\n  !*** ./src/utils/ewma-bandwidth-estimator.ts ***!\n  \\***********************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_901495__) {\n\n\"use strict\";\n__nested_webpack_require_901495__.r(__webpack_exports__);\n/* harmony import */ var _utils_ewma__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_901495__(/*! ../utils/ewma */ \"./src/utils/ewma.ts\");\n/*\n * EWMA Bandwidth Estimator\n *  - heavily inspired from shaka-player\n * Tracks bandwidth samples and estimates available bandwidth.\n * Based on the minimum of two exponentially-weighted moving averages with\n * different half-lives.\n */\n\n\nvar EwmaBandWidthEstimator = /*#__PURE__*/function () {\n  function EwmaBandWidthEstimator(slow, fast, defaultEstimate) {\n    this.defaultEstimate_ = void 0;\n    this.minWeight_ = void 0;\n    this.minDelayMs_ = void 0;\n    this.slow_ = void 0;\n    this.fast_ = void 0;\n    this.defaultEstimate_ = defaultEstimate;\n    this.minWeight_ = 0.001;\n    this.minDelayMs_ = 50;\n    this.slow_ = new _utils_ewma__WEBPACK_IMPORTED_MODULE_0__[\"default\"](slow);\n    this.fast_ = new _utils_ewma__WEBPACK_IMPORTED_MODULE_0__[\"default\"](fast);\n  }\n\n  var _proto = EwmaBandWidthEstimator.prototype;\n\n  _proto.update = function update(slow, fast) {\n    var slow_ = this.slow_,\n        fast_ = this.fast_;\n\n    if (this.slow_.halfLife !== slow) {\n      this.slow_ = new _utils_ewma__WEBPACK_IMPORTED_MODULE_0__[\"default\"](slow, slow_.getEstimate(), slow_.getTotalWeight());\n    }\n\n    if (this.fast_.halfLife !== fast) {\n      this.fast_ = new _utils_ewma__WEBPACK_IMPORTED_MODULE_0__[\"default\"](fast, fast_.getEstimate(), fast_.getTotalWeight());\n    }\n  };\n\n  _proto.sample = function sample(durationMs, numBytes) {\n    durationMs = Math.max(durationMs, this.minDelayMs_);\n    var numBits = 8 * numBytes; // weight is duration in seconds\n\n    var durationS = durationMs / 1000; // value is bandwidth in bits/s\n\n    var bandwidthInBps = numBits / durationS;\n    this.fast_.sample(durationS, bandwidthInBps);\n    this.slow_.sample(durationS, bandwidthInBps);\n  };\n\n  _proto.canEstimate = function canEstimate() {\n    var fast = this.fast_;\n    return fast && fast.getTotalWeight() >= this.minWeight_;\n  };\n\n  _proto.getEstimate = function getEstimate() {\n    if (this.canEstimate()) {\n      // console.log('slow estimate:'+ Math.round(this.slow_.getEstimate()));\n      // console.log('fast estimate:'+ Math.round(this.fast_.getEstimate()));\n      // Take the minimum of these two estimates.  This should have the effect of\n      // adapting down quickly, but up more slowly.\n      return Math.min(this.fast_.getEstimate(), this.slow_.getEstimate());\n    } else {\n      return this.defaultEstimate_;\n    }\n  };\n\n  _proto.destroy = function destroy() {};\n\n  return EwmaBandWidthEstimator;\n}();\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (EwmaBandWidthEstimator);\n\n/***/ }),\n\n/***/ \"./src/utils/ewma.ts\":\n/*!***************************!*\\\n  !*** ./src/utils/ewma.ts ***!\n  \\***************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_904431__) {\n\n\"use strict\";\n__nested_webpack_require_904431__.r(__webpack_exports__);\n/*\n * compute an Exponential Weighted moving average\n * - https://en.wikipedia.org/wiki/Moving_average#Exponential_moving_average\n *  - heavily inspired from shaka-player\n */\nvar EWMA = /*#__PURE__*/function () {\n  //  About half of the estimated value will be from the last |halfLife| samples by weight.\n  function EWMA(halfLife, estimate, weight) {\n    if (estimate === void 0) {\n      estimate = 0;\n    }\n\n    if (weight === void 0) {\n      weight = 0;\n    }\n\n    this.halfLife = void 0;\n    this.alpha_ = void 0;\n    this.estimate_ = void 0;\n    this.totalWeight_ = void 0;\n    this.halfLife = halfLife; // Larger values of alpha expire historical data more slowly.\n\n    this.alpha_ = halfLife ? Math.exp(Math.log(0.5) / halfLife) : 0;\n    this.estimate_ = estimate;\n    this.totalWeight_ = weight;\n  }\n\n  var _proto = EWMA.prototype;\n\n  _proto.sample = function sample(weight, value) {\n    var adjAlpha = Math.pow(this.alpha_, weight);\n    this.estimate_ = value * (1 - adjAlpha) + adjAlpha * this.estimate_;\n    this.totalWeight_ += weight;\n  };\n\n  _proto.getTotalWeight = function getTotalWeight() {\n    return this.totalWeight_;\n  };\n\n  _proto.getEstimate = function getEstimate() {\n    if (this.alpha_) {\n      var zeroFactor = 1 - Math.pow(this.alpha_, this.totalWeight_);\n\n      if (zeroFactor) {\n        return this.estimate_ / zeroFactor;\n      }\n    }\n\n    return this.estimate_;\n  };\n\n  return EWMA;\n}();\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (EWMA);\n\n/***/ }),\n\n/***/ \"./src/utils/fetch-loader.ts\":\n/*!***********************************!*\\\n  !*** ./src/utils/fetch-loader.ts ***!\n  \\***********************************/\n/*! exports provided: fetchSupported, default */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_906269__) {\n\n\"use strict\";\n__nested_webpack_require_906269__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_906269__.d(__webpack_exports__, \"fetchSupported\", function() { return fetchSupported; });\n/* harmony import */ var _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_906269__(/*! ./src/polyfills/number */ \"./src/polyfills/number.ts\");\n/* harmony import */ var _loader_load_stats__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_906269__(/*! ../loader/load-stats */ \"./src/loader/load-stats.ts\");\n/* harmony import */ var _demux_chunk_cache__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_906269__(/*! ../demux/chunk-cache */ \"./src/demux/chunk-cache.ts\");\n\n\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }\n\nfunction _wrapNativeSuper(Class) { var _cache = typeof Map === \"function\" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== \"function\") { throw new TypeError(\"Super expression must either be null or a function\"); } if (typeof _cache !== \"undefined\") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }\n\nfunction _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _isNativeFunction(fn) { return Function.toString.call(fn).indexOf(\"[native code]\") !== -1; }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\n\n\nfunction fetchSupported() {\n  if ( // @ts-ignore\n  self.fetch && self.AbortController && self.ReadableStream && self.Request) {\n    try {\n      new self.ReadableStream({}); // eslint-disable-line no-new\n\n      return true;\n    } catch (e) {\n      /* noop */\n    }\n  }\n\n  return false;\n}\n\nvar FetchLoader = /*#__PURE__*/function () {\n  function FetchLoader(config\n  /* HlsConfig */\n  ) {\n    this.fetchSetup = void 0;\n    this.requestTimeout = void 0;\n    this.request = void 0;\n    this.response = void 0;\n    this.controller = void 0;\n    this.context = void 0;\n    this.config = null;\n    this.callbacks = null;\n    this.stats = void 0;\n    this.loader = null;\n    this.fetchSetup = config.fetchSetup || getRequest;\n    this.controller = new self.AbortController();\n    this.stats = new _loader_load_stats__WEBPACK_IMPORTED_MODULE_1__[\"LoadStats\"]();\n  }\n\n  var _proto = FetchLoader.prototype;\n\n  _proto.destroy = function destroy() {\n    this.loader = this.callbacks = null;\n    this.abortInternal();\n  };\n\n  _proto.abortInternal = function abortInternal() {\n    var response = this.response;\n\n    if (!response || !response.ok) {\n      this.stats.aborted = true;\n      this.controller.abort();\n    }\n  };\n\n  _proto.abort = function abort() {\n    var _this$callbacks;\n\n    this.abortInternal();\n\n    if ((_this$callbacks = this.callbacks) !== null && _this$callbacks !== void 0 && _this$callbacks.onAbort) {\n      this.callbacks.onAbort(this.stats, this.context, this.response);\n    }\n  };\n\n  _proto.load = function load(context, config, callbacks) {\n    var _this = this;\n\n    var stats = this.stats;\n\n    if (stats.loading.start) {\n      throw new Error('Loader can only be used once.');\n    }\n\n    stats.loading.start = self.performance.now();\n    var initParams = getRequestParameters(context, this.controller.signal);\n    var onProgress = callbacks.onProgress;\n    var isArrayBuffer = context.responseType === 'arraybuffer';\n    var LENGTH = isArrayBuffer ? 'byteLength' : 'length';\n    this.context = context;\n    this.config = config;\n    this.callbacks = callbacks;\n    this.request = this.fetchSetup(context, initParams);\n    self.clearTimeout(this.requestTimeout);\n    this.requestTimeout = self.setTimeout(function () {\n      _this.abortInternal();\n\n      callbacks.onTimeout(stats, context, _this.response);\n    }, config.timeout);\n    self.fetch(this.request).then(function (response) {\n      _this.response = _this.loader = response;\n\n      if (!response.ok) {\n        var status = response.status,\n            statusText = response.statusText;\n        throw new FetchError(statusText || 'fetch, bad network response', status, response);\n      }\n\n      stats.loading.first = Math.max(self.performance.now(), stats.loading.start);\n      stats.total = parseInt(response.headers.get('Content-Length') || '0');\n\n      if (onProgress && Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__[\"isFiniteNumber\"])(config.highWaterMark)) {\n        return _this.loadProgressively(response, stats, context, config.highWaterMark, onProgress);\n      }\n\n      if (isArrayBuffer) {\n        return response.arrayBuffer();\n      }\n\n      return response.text();\n    }).then(function (responseData) {\n      var response = _this.response;\n      self.clearTimeout(_this.requestTimeout);\n      stats.loading.end = Math.max(self.performance.now(), stats.loading.first);\n      stats.loaded = stats.total = responseData[LENGTH];\n      var loaderResponse = {\n        url: response.url,\n        data: responseData\n      };\n\n      if (onProgress && !Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__[\"isFiniteNumber\"])(config.highWaterMark)) {\n        onProgress(stats, context, responseData, response);\n      }\n\n      callbacks.onSuccess(loaderResponse, stats, context, response);\n    }).catch(function (error) {\n      self.clearTimeout(_this.requestTimeout);\n\n      if (stats.aborted) {\n        return;\n      } // CORS errors result in an undefined code. Set it to 0 here to align with XHR's behavior\n\n\n      var code = error.code || 0;\n      callbacks.onError({\n        code: code,\n        text: error.message\n      }, context, error.details);\n    });\n  };\n\n  _proto.getCacheAge = function getCacheAge() {\n    var result = null;\n\n    if (this.response) {\n      var ageHeader = this.response.headers.get('age');\n      result = ageHeader ? parseFloat(ageHeader) : null;\n    }\n\n    return result;\n  };\n\n  _proto.loadProgressively = function loadProgressively(response, stats, context, highWaterMark, onProgress) {\n    if (highWaterMark === void 0) {\n      highWaterMark = 0;\n    }\n\n    var chunkCache = new _demux_chunk_cache__WEBPACK_IMPORTED_MODULE_2__[\"default\"]();\n    var reader = response.body.getReader();\n\n    var pump = function pump() {\n      return reader.read().then(function (data) {\n        if (data.done) {\n          if (chunkCache.dataLength) {\n            onProgress(stats, context, chunkCache.flush(), response);\n          }\n\n          return Promise.resolve(new ArrayBuffer(0));\n        }\n\n        var chunk = data.value;\n        var len = chunk.length;\n        stats.loaded += len;\n\n        if (len < highWaterMark || chunkCache.dataLength) {\n          // The current chunk is too small to to be emitted or the cache already has data\n          // Push it to the cache\n          chunkCache.push(chunk);\n\n          if (chunkCache.dataLength >= highWaterMark) {\n            // flush in order to join the typed arrays\n            onProgress(stats, context, chunkCache.flush(), response);\n          }\n        } else {\n          // If there's nothing cached already, and the chache is large enough\n          // just emit the progress event\n          onProgress(stats, context, chunk, response);\n        }\n\n        return pump();\n      }).catch(function () {\n        /* aborted */\n        return Promise.reject();\n      });\n    };\n\n    return pump();\n  };\n\n  return FetchLoader;\n}();\n\nfunction getRequestParameters(context, signal) {\n  var initParams = {\n    method: 'GET',\n    mode: 'cors',\n    credentials: 'same-origin',\n    signal: signal,\n    headers: new self.Headers(_extends({}, context.headers))\n  };\n\n  if (context.rangeEnd) {\n    initParams.headers.set('Range', 'bytes=' + context.rangeStart + '-' + String(context.rangeEnd - 1));\n  }\n\n  return initParams;\n}\n\nfunction getRequest(context, initParams) {\n  return new self.Request(context.url, initParams);\n}\n\nvar FetchError = /*#__PURE__*/function (_Error) {\n  _inheritsLoose(FetchError, _Error);\n\n  function FetchError(message, code, details) {\n    var _this2;\n\n    _this2 = _Error.call(this, message) || this;\n    _this2.code = void 0;\n    _this2.details = void 0;\n    _this2.code = code;\n    _this2.details = details;\n    return _this2;\n  }\n\n  return FetchError;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (FetchLoader);\n\n/***/ }),\n\n/***/ \"./src/utils/imsc1-ttml-parser.ts\":\n/*!****************************************!*\\\n  !*** ./src/utils/imsc1-ttml-parser.ts ***!\n  \\****************************************/\n/*! exports provided: IMSC1_CODEC, parseIMSC1 */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_916696__) {\n\n\"use strict\";\n__nested_webpack_require_916696__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_916696__.d(__webpack_exports__, \"IMSC1_CODEC\", function() { return IMSC1_CODEC; });\n/* harmony export (binding) */ __nested_webpack_require_916696__.d(__webpack_exports__, \"parseIMSC1\", function() { return parseIMSC1; });\n/* harmony import */ var _mp4_tools__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_916696__(/*! ./mp4-tools */ \"./src/utils/mp4-tools.ts\");\n/* harmony import */ var _vttparser__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_916696__(/*! ./vttparser */ \"./src/utils/vttparser.ts\");\n/* harmony import */ var _vttcue__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_916696__(/*! ./vttcue */ \"./src/utils/vttcue.ts\");\n/* harmony import */ var _demux_id3__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_916696__(/*! ../demux/id3 */ \"./src/demux/id3.ts\");\n/* harmony import */ var _timescale_conversion__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_916696__(/*! ./timescale-conversion */ \"./src/utils/timescale-conversion.ts\");\n/* harmony import */ var _webvtt_parser__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_916696__(/*! ./webvtt-parser */ \"./src/utils/webvtt-parser.ts\");\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\n\n\n\n\n\n\nvar IMSC1_CODEC = 'stpp.ttml.im1t'; // Time format: h:m:s:frames(.subframes)\n\nvar HMSF_REGEX = /^(\\d{2,}):(\\d{2}):(\\d{2}):(\\d{2})\\.?(\\d+)?$/; // Time format: hours, minutes, seconds, milliseconds, frames, ticks\n\nvar TIME_UNIT_REGEX = /^(\\d*(?:\\.\\d*)?)(h|m|s|ms|f|t)$/;\nvar textAlignToLineAlign = {\n  left: 'start',\n  center: 'center',\n  right: 'end',\n  start: 'start',\n  end: 'end'\n};\nfunction parseIMSC1(payload, initPTS, timescale, callBack, errorCallBack) {\n  var results = Object(_mp4_tools__WEBPACK_IMPORTED_MODULE_0__[\"findBox\"])(new Uint8Array(payload), ['mdat']);\n\n  if (results.length === 0) {\n    errorCallBack(new Error('Could not parse IMSC1 mdat'));\n    return;\n  }\n\n  var mdat = results[0];\n  var ttml = Object(_demux_id3__WEBPACK_IMPORTED_MODULE_3__[\"utf8ArrayToStr\"])(new Uint8Array(payload, mdat.start, mdat.end - mdat.start));\n  var syncTime = Object(_timescale_conversion__WEBPACK_IMPORTED_MODULE_4__[\"toTimescaleFromScale\"])(initPTS, 1, timescale);\n\n  try {\n    callBack(parseTTML(ttml, syncTime));\n  } catch (error) {\n    errorCallBack(error);\n  }\n}\n\nfunction parseTTML(ttml, syncTime) {\n  var parser = new DOMParser();\n  var xmlDoc = parser.parseFromString(ttml, 'text/xml');\n  var tt = xmlDoc.getElementsByTagName('tt')[0];\n\n  if (!tt) {\n    throw new Error('Invalid ttml');\n  }\n\n  var defaultRateInfo = {\n    frameRate: 30,\n    subFrameRate: 1,\n    frameRateMultiplier: 0,\n    tickRate: 0\n  };\n  var rateInfo = Object.keys(defaultRateInfo).reduce(function (result, key) {\n    result[key] = tt.getAttribute(\"ttp:\" + key) || defaultRateInfo[key];\n    return result;\n  }, {});\n  var trim = tt.getAttribute('xml:space') !== 'preserve';\n  var styleElements = collectionToDictionary(getElementCollection(tt, 'styling', 'style'));\n  var regionElements = collectionToDictionary(getElementCollection(tt, 'layout', 'region'));\n  var cueElements = getElementCollection(tt, 'body', '[begin]');\n  return [].map.call(cueElements, function (cueElement) {\n    var cueText = getTextContent(cueElement, trim);\n\n    if (!cueText || !cueElement.hasAttribute('begin')) {\n      return null;\n    }\n\n    var startTime = parseTtmlTime(cueElement.getAttribute('begin'), rateInfo);\n    var duration = parseTtmlTime(cueElement.getAttribute('dur'), rateInfo);\n    var endTime = parseTtmlTime(cueElement.getAttribute('end'), rateInfo);\n\n    if (startTime === null) {\n      throw timestampParsingError(cueElement);\n    }\n\n    if (endTime === null) {\n      if (duration === null) {\n        throw timestampParsingError(cueElement);\n      }\n\n      endTime = startTime + duration;\n    }\n\n    var cue = new _vttcue__WEBPACK_IMPORTED_MODULE_2__[\"default\"](startTime - syncTime, endTime - syncTime, cueText);\n    cue.id = Object(_webvtt_parser__WEBPACK_IMPORTED_MODULE_5__[\"generateCueId\"])(cue.startTime, cue.endTime, cue.text);\n    var region = regionElements[cueElement.getAttribute('region')];\n    var style = styleElements[cueElement.getAttribute('style')]; // TODO: Add regions to track and cue (origin and extend)\n    // These values are hard-coded (for now) to simulate region settings in the demo\n\n    cue.position = 10;\n    cue.size = 80; // Apply styles to cue\n\n    var styles = getTtmlStyles(region, style);\n    var textAlign = styles.textAlign;\n\n    if (textAlign) {\n      // cue.positionAlign not settable in FF~2016\n      var lineAlign = textAlignToLineAlign[textAlign];\n\n      if (lineAlign) {\n        cue.lineAlign = lineAlign;\n      }\n\n      cue.align = textAlign;\n    }\n\n    _extends(cue, styles);\n\n    return cue;\n  }).filter(function (cue) {\n    return cue !== null;\n  });\n}\n\nfunction getElementCollection(fromElement, parentName, childName) {\n  var parent = fromElement.getElementsByTagName(parentName)[0];\n\n  if (parent) {\n    return [].slice.call(parent.querySelectorAll(childName));\n  }\n\n  return [];\n}\n\nfunction collectionToDictionary(elementsWithId) {\n  return elementsWithId.reduce(function (dict, element) {\n    var id = element.getAttribute('xml:id');\n\n    if (id) {\n      dict[id] = element;\n    }\n\n    return dict;\n  }, {});\n}\n\nfunction getTextContent(element, trim) {\n  return [].slice.call(element.childNodes).reduce(function (str, node, i) {\n    var _node$childNodes;\n\n    if (node.nodeName === 'br' && i) {\n      return str + '\\n';\n    }\n\n    if ((_node$childNodes = node.childNodes) !== null && _node$childNodes !== void 0 && _node$childNodes.length) {\n      return getTextContent(node, trim);\n    } else if (trim) {\n      return str + node.textContent.trim().replace(/\\s+/g, ' ');\n    }\n\n    return str + node.textContent;\n  }, '');\n}\n\nfunction getTtmlStyles(region, style) {\n  var ttsNs = 'http://www.w3.org/ns/ttml#styling';\n  var styleAttributes = ['displayAlign', 'textAlign', 'color', 'backgroundColor', 'fontSize', 'fontFamily' // 'fontWeight',\n  // 'lineHeight',\n  // 'wrapOption',\n  // 'fontStyle',\n  // 'direction',\n  // 'writingMode'\n  ];\n  return styleAttributes.reduce(function (styles, name) {\n    var value = getAttributeNS(style, ttsNs, name) || getAttributeNS(region, ttsNs, name);\n\n    if (value) {\n      styles[name] = value;\n    }\n\n    return styles;\n  }, {});\n}\n\nfunction getAttributeNS(element, ns, name) {\n  return element.hasAttributeNS(ns, name) ? element.getAttributeNS(ns, name) : null;\n}\n\nfunction timestampParsingError(node) {\n  return new Error(\"Could not parse ttml timestamp \" + node);\n}\n\nfunction parseTtmlTime(timeAttributeValue, rateInfo) {\n  if (!timeAttributeValue) {\n    return null;\n  }\n\n  var seconds = Object(_vttparser__WEBPACK_IMPORTED_MODULE_1__[\"parseTimeStamp\"])(timeAttributeValue);\n\n  if (seconds === null) {\n    if (HMSF_REGEX.test(timeAttributeValue)) {\n      seconds = parseHoursMinutesSecondsFrames(timeAttributeValue, rateInfo);\n    } else if (TIME_UNIT_REGEX.test(timeAttributeValue)) {\n      seconds = parseTimeUnits(timeAttributeValue, rateInfo);\n    }\n  }\n\n  return seconds;\n}\n\nfunction parseHoursMinutesSecondsFrames(timeAttributeValue, rateInfo) {\n  var m = HMSF_REGEX.exec(timeAttributeValue);\n  var frames = (m[4] | 0) + (m[5] | 0) / rateInfo.subFrameRate;\n  return (m[1] | 0) * 3600 + (m[2] | 0) * 60 + (m[3] | 0) + frames / rateInfo.frameRate;\n}\n\nfunction parseTimeUnits(timeAttributeValue, rateInfo) {\n  var m = TIME_UNIT_REGEX.exec(timeAttributeValue);\n  var value = Number(m[1]);\n  var unit = m[2];\n\n  switch (unit) {\n    case 'h':\n      return value * 3600;\n\n    case 'm':\n      return value * 60;\n\n    case 'ms':\n      return value * 1000;\n\n    case 'f':\n      return value / rateInfo.frameRate;\n\n    case 't':\n      return value / rateInfo.tickRate;\n  }\n\n  return value;\n}\n\n/***/ }),\n\n/***/ \"./src/utils/logger.ts\":\n/*!*****************************!*\\\n  !*** ./src/utils/logger.ts ***!\n  \\*****************************/\n/*! exports provided: enableLogs, logger */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_924995__) {\n\n\"use strict\";\n__nested_webpack_require_924995__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_924995__.d(__webpack_exports__, \"enableLogs\", function() { return enableLogs; });\n/* harmony export (binding) */ __nested_webpack_require_924995__.d(__webpack_exports__, \"logger\", function() { return logger; });\nvar noop = function noop() {};\n\nvar fakeLogger = {\n  trace: noop,\n  debug: noop,\n  log: noop,\n  warn: noop,\n  info: noop,\n  error: noop\n};\nvar exportedLogger = fakeLogger; // let lastCallTime;\n// function formatMsgWithTimeInfo(type, msg) {\n//   const now = Date.now();\n//   const diff = lastCallTime ? '+' + (now - lastCallTime) : '0';\n//   lastCallTime = now;\n//   msg = (new Date(now)).toISOString() + ' | [' +  type + '] > ' + msg + ' ( ' + diff + ' ms )';\n//   return msg;\n// }\n\nfunction consolePrintFn(type) {\n  var func = self.console[type];\n\n  if (func) {\n    return func.bind(self.console, \"[\" + type + \"] >\");\n  }\n\n  return noop;\n}\n\nfunction exportLoggerFunctions(debugConfig) {\n  for (var _len = arguments.length, functions = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    functions[_key - 1] = arguments[_key];\n  }\n\n  functions.forEach(function (type) {\n    exportedLogger[type] = debugConfig[type] ? debugConfig[type].bind(debugConfig) : consolePrintFn(type);\n  });\n}\n\nfunction enableLogs(debugConfig) {\n  // check that console is available\n  if (self.console && debugConfig === true || typeof debugConfig === 'object') {\n    exportLoggerFunctions(debugConfig, // Remove out from list here to hard-disable a log-level\n    // 'trace',\n    'debug', 'log', 'info', 'warn', 'error'); // Some browsers don't allow to use bind on console object anyway\n    // fallback to default if needed\n\n    try {\n      exportedLogger.log();\n    } catch (e) {\n      exportedLogger = fakeLogger;\n    }\n  } else {\n    exportedLogger = fakeLogger;\n  }\n}\nvar logger = exportedLogger;\n\n/***/ }),\n\n/***/ \"./src/utils/mediakeys-helper.ts\":\n/*!***************************************!*\\\n  !*** ./src/utils/mediakeys-helper.ts ***!\n  \\***************************************/\n/*! exports provided: KeySystems, requestMediaKeySystemAccess */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_927212__) {\n\n\"use strict\";\n__nested_webpack_require_927212__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_927212__.d(__webpack_exports__, \"KeySystems\", function() { return KeySystems; });\n/* harmony export (binding) */ __nested_webpack_require_927212__.d(__webpack_exports__, \"requestMediaKeySystemAccess\", function() { return requestMediaKeySystemAccess; });\n/**\n * @see https://developer.mozilla.org/en-US/docs/Web/API/Navigator/requestMediaKeySystemAccess\n */\nvar KeySystems;\n\n(function (KeySystems) {\n  KeySystems[\"WIDEVINE\"] = \"com.widevine.alpha\";\n  KeySystems[\"PLAYREADY\"] = \"com.microsoft.playready\";\n})(KeySystems || (KeySystems = {}));\n\nvar requestMediaKeySystemAccess = function () {\n  if (typeof self !== 'undefined' && self.navigator && self.navigator.requestMediaKeySystemAccess) {\n    return self.navigator.requestMediaKeySystemAccess.bind(self.navigator);\n  } else {\n    return null;\n  }\n}();\n\n\n\n/***/ }),\n\n/***/ \"./src/utils/mediasource-helper.ts\":\n/*!*****************************************!*\\\n  !*** ./src/utils/mediasource-helper.ts ***!\n  \\*****************************************/\n/*! exports provided: getMediaSource */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_928407__) {\n\n\"use strict\";\n__nested_webpack_require_928407__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_928407__.d(__webpack_exports__, \"getMediaSource\", function() { return getMediaSource; });\n/**\n * MediaSource helper\n */\nfunction getMediaSource() {\n  return self.MediaSource || self.WebKitMediaSource;\n}\n\n/***/ }),\n\n/***/ \"./src/utils/mp4-tools.ts\":\n/*!********************************!*\\\n  !*** ./src/utils/mp4-tools.ts ***!\n  \\********************************/\n/*! exports provided: bin2str, readUint16, readUint32, writeUint32, findBox, parseSegmentIndex, parseInitSegment, getStartDTS, getDuration, computeRawDurationFromSamples, offsetStartDTS, segmentValidRange, appendUint8Array */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_929164__) {\n\n\"use strict\";\n__nested_webpack_require_929164__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_929164__.d(__webpack_exports__, \"bin2str\", function() { return bin2str; });\n/* harmony export (binding) */ __nested_webpack_require_929164__.d(__webpack_exports__, \"readUint16\", function() { return readUint16; });\n/* harmony export (binding) */ __nested_webpack_require_929164__.d(__webpack_exports__, \"readUint32\", function() { return readUint32; });\n/* harmony export (binding) */ __nested_webpack_require_929164__.d(__webpack_exports__, \"writeUint32\", function() { return writeUint32; });\n/* harmony export (binding) */ __nested_webpack_require_929164__.d(__webpack_exports__, \"findBox\", function() { return findBox; });\n/* harmony export (binding) */ __nested_webpack_require_929164__.d(__webpack_exports__, \"parseSegmentIndex\", function() { return parseSegmentIndex; });\n/* harmony export (binding) */ __nested_webpack_require_929164__.d(__webpack_exports__, \"parseInitSegment\", function() { return parseInitSegment; });\n/* harmony export (binding) */ __nested_webpack_require_929164__.d(__webpack_exports__, \"getStartDTS\", function() { return getStartDTS; });\n/* harmony export (binding) */ __nested_webpack_require_929164__.d(__webpack_exports__, \"getDuration\", function() { return getDuration; });\n/* harmony export (binding) */ __nested_webpack_require_929164__.d(__webpack_exports__, \"computeRawDurationFromSamples\", function() { return computeRawDurationFromSamples; });\n/* harmony export (binding) */ __nested_webpack_require_929164__.d(__webpack_exports__, \"offsetStartDTS\", function() { return offsetStartDTS; });\n/* harmony export (binding) */ __nested_webpack_require_929164__.d(__webpack_exports__, \"segmentValidRange\", function() { return segmentValidRange; });\n/* harmony export (binding) */ __nested_webpack_require_929164__.d(__webpack_exports__, \"appendUint8Array\", function() { return appendUint8Array; });\n/* harmony import */ var _typed_array__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_929164__(/*! ./typed-array */ \"./src/utils/typed-array.ts\");\n/* harmony import */ var _loader_fragment__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_929164__(/*! ../loader/fragment */ \"./src/loader/fragment.ts\");\n\n\nvar UINT32_MAX = Math.pow(2, 32) - 1;\nvar push = [].push;\nfunction bin2str(data) {\n  return String.fromCharCode.apply(null, data);\n}\nfunction readUint16(buffer, offset) {\n  if ('data' in buffer) {\n    offset += buffer.start;\n    buffer = buffer.data;\n  }\n\n  var val = buffer[offset] << 8 | buffer[offset + 1];\n  return val < 0 ? 65536 + val : val;\n}\nfunction readUint32(buffer, offset) {\n  if ('data' in buffer) {\n    offset += buffer.start;\n    buffer = buffer.data;\n  }\n\n  var val = buffer[offset] << 24 | buffer[offset + 1] << 16 | buffer[offset + 2] << 8 | buffer[offset + 3];\n  return val < 0 ? 4294967296 + val : val;\n}\nfunction writeUint32(buffer, offset, value) {\n  if ('data' in buffer) {\n    offset += buffer.start;\n    buffer = buffer.data;\n  }\n\n  buffer[offset] = value >> 24;\n  buffer[offset + 1] = value >> 16 & 0xff;\n  buffer[offset + 2] = value >> 8 & 0xff;\n  buffer[offset + 3] = value & 0xff;\n} // Find the data for a box specified by its path\n\nfunction findBox(input, path) {\n  var results = [];\n\n  if (!path.length) {\n    // short-circuit the search for empty paths\n    return results;\n  }\n\n  var data;\n  var start;\n  var end;\n\n  if ('data' in input) {\n    data = input.data;\n    start = input.start;\n    end = input.end;\n  } else {\n    data = input;\n    start = 0;\n    end = data.byteLength;\n  }\n\n  for (var i = start; i < end;) {\n    var size = readUint32(data, i);\n    var type = bin2str(data.subarray(i + 4, i + 8));\n    var endbox = size > 1 ? i + size : end;\n\n    if (type === path[0]) {\n      if (path.length === 1) {\n        // this is the end of the path and we've found the box we were\n        // looking for\n        results.push({\n          data: data,\n          start: i + 8,\n          end: endbox\n        });\n      } else {\n        // recursively search for the next box along the path\n        var subresults = findBox({\n          data: data,\n          start: i + 8,\n          end: endbox\n        }, path.slice(1));\n\n        if (subresults.length) {\n          push.apply(results, subresults);\n        }\n      }\n    }\n\n    i = endbox;\n  } // we've finished searching all of data\n\n\n  return results;\n}\nfunction parseSegmentIndex(initSegment) {\n  var moovBox = findBox(initSegment, ['moov']);\n  var moov = moovBox[0];\n  var moovEndOffset = moov ? moov.end : null; // we need this in case we need to chop of garbage of the end of current data\n\n  var sidxBox = findBox(initSegment, ['sidx']);\n\n  if (!sidxBox || !sidxBox[0]) {\n    return null;\n  }\n\n  var references = [];\n  var sidx = sidxBox[0];\n  var version = sidx.data[0]; // set initial offset, we skip the reference ID (not needed)\n\n  var index = version === 0 ? 8 : 16;\n  var timescale = readUint32(sidx, index);\n  index += 4; // TODO: parse earliestPresentationTime and firstOffset\n  // usually zero in our case\n\n  var earliestPresentationTime = 0;\n  var firstOffset = 0;\n\n  if (version === 0) {\n    index += 8;\n  } else {\n    index += 16;\n  } // skip reserved\n\n\n  index += 2;\n  var startByte = sidx.end + firstOffset;\n  var referencesCount = readUint16(sidx, index);\n  index += 2;\n\n  for (var i = 0; i < referencesCount; i++) {\n    var referenceIndex = index;\n    var referenceInfo = readUint32(sidx, referenceIndex);\n    referenceIndex += 4;\n    var referenceSize = referenceInfo & 0x7fffffff;\n    var referenceType = (referenceInfo & 0x80000000) >>> 31;\n\n    if (referenceType === 1) {\n      // eslint-disable-next-line no-console\n      console.warn('SIDX has hierarchical references (not supported)');\n      return null;\n    }\n\n    var subsegmentDuration = readUint32(sidx, referenceIndex);\n    referenceIndex += 4;\n    references.push({\n      referenceSize: referenceSize,\n      subsegmentDuration: subsegmentDuration,\n      // unscaled\n      info: {\n        duration: subsegmentDuration / timescale,\n        start: startByte,\n        end: startByte + referenceSize - 1\n      }\n    });\n    startByte += referenceSize; // Skipping 1 bit for |startsWithSap|, 3 bits for |sapType|, and 28 bits\n    // for |sapDelta|.\n\n    referenceIndex += 4; // skip to next ref\n\n    index = referenceIndex;\n  }\n\n  return {\n    earliestPresentationTime: earliestPresentationTime,\n    timescale: timescale,\n    version: version,\n    referencesCount: referencesCount,\n    references: references,\n    moovEndOffset: moovEndOffset\n  };\n}\n/**\n * Parses an MP4 initialization segment and extracts stream type and\n * timescale values for any declared tracks. Timescale values indicate the\n * number of clock ticks per second to assume for time-based values\n * elsewhere in the MP4.\n *\n * To determine the start time of an MP4, you need two pieces of\n * information: the timescale unit and the earliest base media decode\n * time. Multiple timescales can be specified within an MP4 but the\n * base media decode time is always expressed in the timescale from\n * the media header box for the track:\n * ```\n * moov > trak > mdia > mdhd.timescale\n * moov > trak > mdia > hdlr\n * ```\n * @param initSegment {Uint8Array} the bytes of the init segment\n * @return {InitData} a hash of track type to timescale values or null if\n * the init segment is malformed.\n */\n\nfunction parseInitSegment(initSegment) {\n  var result = [];\n  var traks = findBox(initSegment, ['moov', 'trak']);\n\n  for (var i = 0; i < traks.length; i++) {\n    var trak = traks[i];\n    var tkhd = findBox(trak, ['tkhd'])[0];\n\n    if (tkhd) {\n      var version = tkhd.data[tkhd.start];\n\n      var _index = version === 0 ? 12 : 20;\n\n      var trackId = readUint32(tkhd, _index);\n      var mdhd = findBox(trak, ['mdia', 'mdhd'])[0];\n\n      if (mdhd) {\n        version = mdhd.data[mdhd.start];\n        _index = version === 0 ? 12 : 20;\n        var timescale = readUint32(mdhd, _index);\n        var hdlr = findBox(trak, ['mdia', 'hdlr'])[0];\n\n        if (hdlr) {\n          var hdlrType = bin2str(hdlr.data.subarray(hdlr.start + 8, hdlr.start + 12));\n          var type = {\n            soun: _loader_fragment__WEBPACK_IMPORTED_MODULE_1__[\"ElementaryStreamTypes\"].AUDIO,\n            vide: _loader_fragment__WEBPACK_IMPORTED_MODULE_1__[\"ElementaryStreamTypes\"].VIDEO\n          }[hdlrType];\n\n          if (type) {\n            // Parse codec details\n            var stsd = findBox(trak, ['mdia', 'minf', 'stbl', 'stsd'])[0];\n            var codec = void 0;\n\n            if (stsd) {\n              codec = bin2str(stsd.data.subarray(stsd.start + 12, stsd.start + 16)); // TODO: Parse codec details to be able to build MIME type.\n              // stsd.start += 8;\n              // const codecBox = findBox(stsd, [codec])[0];\n              // if (codecBox) {\n              //   TODO: Codec parsing support for avc1, mp4a, hevc, av01...\n              // }\n            }\n\n            result[trackId] = {\n              timescale: timescale,\n              type: type\n            };\n            result[type] = {\n              timescale: timescale,\n              id: trackId,\n              codec: codec\n            };\n          }\n        }\n      }\n    }\n  }\n\n  var trex = findBox(initSegment, ['moov', 'mvex', 'trex']);\n  trex.forEach(function (trex) {\n    var trackId = readUint32(trex, 4);\n    var track = result[trackId];\n\n    if (track) {\n      track.default = {\n        duration: readUint32(trex, 12),\n        flags: readUint32(trex, 20)\n      };\n    }\n  });\n  return result;\n}\n/**\n * Determine the base media decode start time, in seconds, for an MP4\n * fragment. If multiple fragments are specified, the earliest time is\n * returned.\n *\n * The base media decode time can be parsed from track fragment\n * metadata:\n * ```\n * moof > traf > tfdt.baseMediaDecodeTime\n * ```\n * It requires the timescale value from the mdhd to interpret.\n *\n * @param initData {InitData} a hash of track type to timescale values\n * @param fmp4 {Uint8Array} the bytes of the mp4 fragment\n * @return {number} the earliest base media decode start time for the\n * fragment, in seconds\n */\n\nfunction getStartDTS(initData, fmp4) {\n  // we need info from two children of each track fragment box\n  return findBox(fmp4, ['moof', 'traf']).reduce(function (result, traf) {\n    var tfdt = findBox(traf, ['tfdt'])[0];\n    var version = tfdt.data[tfdt.start];\n    var start = findBox(traf, ['tfhd']).reduce(function (result, tfhd) {\n      // get the track id from the tfhd\n      var id = readUint32(tfhd, 4);\n      var track = initData[id];\n\n      if (track) {\n        var baseTime = readUint32(tfdt, 4);\n\n        if (version === 1) {\n          baseTime *= Math.pow(2, 32);\n          baseTime += readUint32(tfdt, 8);\n        } // assume a 90kHz clock if no timescale was specified\n\n\n        var scale = track.timescale || 90e3; // convert base time to seconds\n\n        var startTime = baseTime / scale;\n\n        if (isFinite(startTime) && (result === null || startTime < result)) {\n          return startTime;\n        }\n      }\n\n      return result;\n    }, null);\n\n    if (start !== null && isFinite(start) && (result === null || start < result)) {\n      return start;\n    }\n\n    return result;\n  }, null) || 0;\n}\n/*\n  For Reference:\n  aligned(8) class TrackFragmentHeaderBox\n           extends FullBox(‘tfhd’, 0, tf_flags){\n     unsigned int(32)  track_ID;\n     // all the following are optional fields\n     unsigned int(64)  base_data_offset;\n     unsigned int(32)  sample_description_index;\n     unsigned int(32)  default_sample_duration;\n     unsigned int(32)  default_sample_size;\n     unsigned int(32)  default_sample_flags\n  }\n */\n\nfunction getDuration(data, initData) {\n  var rawDuration = 0;\n  var videoDuration = 0;\n  var audioDuration = 0;\n  var trafs = findBox(data, ['moof', 'traf']);\n\n  for (var i = 0; i < trafs.length; i++) {\n    var traf = trafs[i]; // There is only one tfhd & trun per traf\n    // This is true for CMAF style content, and we should perhaps check the ftyp\n    // and only look for a single trun then, but for ISOBMFF we should check\n    // for multiple track runs.\n\n    var tfhd = findBox(traf, ['tfhd'])[0]; // get the track id from the tfhd\n\n    var id = readUint32(tfhd, 4);\n    var track = initData[id];\n\n    if (!track) {\n      continue;\n    }\n\n    var trackDefault = track.default;\n    var tfhdFlags = readUint32(tfhd, 0) | (trackDefault === null || trackDefault === void 0 ? void 0 : trackDefault.flags);\n    var sampleDuration = trackDefault === null || trackDefault === void 0 ? void 0 : trackDefault.duration;\n\n    if (tfhdFlags & 0x000008) {\n      // 0x000008 indicates the presence of the default_sample_duration field\n      if (tfhdFlags & 0x000002) {\n        // 0x000002 indicates the presence of the sample_description_index field, which precedes default_sample_duration\n        // If present, the default_sample_duration exists at byte offset 12\n        sampleDuration = readUint32(tfhd, 12);\n      } else {\n        // Otherwise, the duration is at byte offset 8\n        sampleDuration = readUint32(tfhd, 8);\n      }\n    } // assume a 90kHz clock if no timescale was specified\n\n\n    var timescale = track.timescale || 90e3;\n    var truns = findBox(traf, ['trun']);\n\n    for (var j = 0; j < truns.length; j++) {\n      rawDuration = computeRawDurationFromSamples(truns[j]);\n\n      if (!rawDuration && sampleDuration) {\n        var sampleCount = readUint32(truns[j], 4);\n        rawDuration = sampleDuration * sampleCount;\n      }\n\n      if (track.type === _loader_fragment__WEBPACK_IMPORTED_MODULE_1__[\"ElementaryStreamTypes\"].VIDEO) {\n        videoDuration += rawDuration / timescale;\n      } else if (track.type === _loader_fragment__WEBPACK_IMPORTED_MODULE_1__[\"ElementaryStreamTypes\"].AUDIO) {\n        audioDuration += rawDuration / timescale;\n      }\n    }\n  }\n\n  if (videoDuration === 0 && audioDuration === 0) {\n    // If duration samples are not available in the traf use sidx subsegment_duration\n    var sidx = parseSegmentIndex(data);\n\n    if (sidx !== null && sidx !== void 0 && sidx.references) {\n      return sidx.references.reduce(function (dur, ref) {\n        return dur + ref.info.duration || 0;\n      }, 0);\n    }\n  }\n\n  if (videoDuration) {\n    return videoDuration;\n  }\n\n  return audioDuration;\n}\n/*\n  For Reference:\n  aligned(8) class TrackRunBox\n           extends FullBox(‘trun’, version, tr_flags) {\n     unsigned int(32)  sample_count;\n     // the following are optional fields\n     signed int(32) data_offset;\n     unsigned int(32)  first_sample_flags;\n     // all fields in the following array are optional\n     {\n        unsigned int(32)  sample_duration;\n        unsigned int(32)  sample_size;\n        unsigned int(32)  sample_flags\n        if (version == 0)\n           { unsigned int(32)\n        else\n           { signed int(32)\n     }[ sample_count ]\n  }\n */\n\nfunction computeRawDurationFromSamples(trun) {\n  var flags = readUint32(trun, 0); // Flags are at offset 0, non-optional sample_count is at offset 4. Therefore we start 8 bytes in.\n  // Each field is an int32, which is 4 bytes\n\n  var offset = 8; // data-offset-present flag\n\n  if (flags & 0x000001) {\n    offset += 4;\n  } // first-sample-flags-present flag\n\n\n  if (flags & 0x000004) {\n    offset += 4;\n  }\n\n  var duration = 0;\n  var sampleCount = readUint32(trun, 4);\n\n  for (var i = 0; i < sampleCount; i++) {\n    // sample-duration-present flag\n    if (flags & 0x000100) {\n      var sampleDuration = readUint32(trun, offset);\n      duration += sampleDuration;\n      offset += 4;\n    } // sample-size-present flag\n\n\n    if (flags & 0x000200) {\n      offset += 4;\n    } // sample-flags-present flag\n\n\n    if (flags & 0x000400) {\n      offset += 4;\n    } // sample-composition-time-offsets-present flag\n\n\n    if (flags & 0x000800) {\n      offset += 4;\n    }\n  }\n\n  return duration;\n}\nfunction offsetStartDTS(initData, fmp4, timeOffset) {\n  findBox(fmp4, ['moof', 'traf']).forEach(function (traf) {\n    findBox(traf, ['tfhd']).forEach(function (tfhd) {\n      // get the track id from the tfhd\n      var id = readUint32(tfhd, 4);\n      var track = initData[id];\n\n      if (!track) {\n        return;\n      } // assume a 90kHz clock if no timescale was specified\n\n\n      var timescale = track.timescale || 90e3; // get the base media decode time from the tfdt\n\n      findBox(traf, ['tfdt']).forEach(function (tfdt) {\n        var version = tfdt.data[tfdt.start];\n        var baseMediaDecodeTime = readUint32(tfdt, 4);\n\n        if (version === 0) {\n          writeUint32(tfdt, 4, baseMediaDecodeTime - timeOffset * timescale);\n        } else {\n          baseMediaDecodeTime *= Math.pow(2, 32);\n          baseMediaDecodeTime += readUint32(tfdt, 8);\n          baseMediaDecodeTime -= timeOffset * timescale;\n          baseMediaDecodeTime = Math.max(baseMediaDecodeTime, 0);\n          var upper = Math.floor(baseMediaDecodeTime / (UINT32_MAX + 1));\n          var lower = Math.floor(baseMediaDecodeTime % (UINT32_MAX + 1));\n          writeUint32(tfdt, 4, upper);\n          writeUint32(tfdt, 8, lower);\n        }\n      });\n    });\n  });\n} // TODO: Check if the last moof+mdat pair is part of the valid range\n\nfunction segmentValidRange(data) {\n  var segmentedRange = {\n    valid: null,\n    remainder: null\n  };\n  var moofs = findBox(data, ['moof']);\n\n  if (!moofs) {\n    return segmentedRange;\n  } else if (moofs.length < 2) {\n    segmentedRange.remainder = data;\n    return segmentedRange;\n  }\n\n  var last = moofs[moofs.length - 1]; // Offset by 8 bytes; findBox offsets the start by as much\n\n  segmentedRange.valid = Object(_typed_array__WEBPACK_IMPORTED_MODULE_0__[\"sliceUint8\"])(data, 0, last.start - 8);\n  segmentedRange.remainder = Object(_typed_array__WEBPACK_IMPORTED_MODULE_0__[\"sliceUint8\"])(data, last.start - 8);\n  return segmentedRange;\n}\nfunction appendUint8Array(data1, data2) {\n  var temp = new Uint8Array(data1.length + data2.length);\n  temp.set(data1);\n  temp.set(data2, data1.length);\n  return temp;\n}\n\n/***/ }),\n\n/***/ \"./src/utils/output-filter.ts\":\n/*!************************************!*\\\n  !*** ./src/utils/output-filter.ts ***!\n  \\************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_947212__) {\n\n\"use strict\";\n__nested_webpack_require_947212__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_947212__.d(__webpack_exports__, \"default\", function() { return OutputFilter; });\nvar OutputFilter = /*#__PURE__*/function () {\n  function OutputFilter(timelineController, trackName) {\n    this.timelineController = void 0;\n    this.cueRanges = [];\n    this.trackName = void 0;\n    this.startTime = null;\n    this.endTime = null;\n    this.screen = null;\n    this.timelineController = timelineController;\n    this.trackName = trackName;\n  }\n\n  var _proto = OutputFilter.prototype;\n\n  _proto.dispatchCue = function dispatchCue() {\n    if (this.startTime === null) {\n      return;\n    }\n\n    this.timelineController.addCues(this.trackName, this.startTime, this.endTime, this.screen, this.cueRanges);\n    this.startTime = null;\n  };\n\n  _proto.newCue = function newCue(startTime, endTime, screen) {\n    if (this.startTime === null || this.startTime > startTime) {\n      this.startTime = startTime;\n    }\n\n    this.endTime = endTime;\n    this.screen = screen;\n    this.timelineController.createCaptionsTrack(this.trackName);\n  };\n\n  _proto.reset = function reset() {\n    this.cueRanges = [];\n    this.startTime = null;\n  };\n\n  return OutputFilter;\n}();\n\n\n\n/***/ }),\n\n/***/ \"./src/utils/texttrack-utils.ts\":\n/*!**************************************!*\\\n  !*** ./src/utils/texttrack-utils.ts ***!\n  \\**************************************/\n/*! exports provided: sendAddTrackEvent, addCueToTrack, clearCurrentCues, removeCuesInRange, getCuesInRange */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_948822__) {\n\n\"use strict\";\n__nested_webpack_require_948822__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_948822__.d(__webpack_exports__, \"sendAddTrackEvent\", function() { return sendAddTrackEvent; });\n/* harmony export (binding) */ __nested_webpack_require_948822__.d(__webpack_exports__, \"addCueToTrack\", function() { return addCueToTrack; });\n/* harmony export (binding) */ __nested_webpack_require_948822__.d(__webpack_exports__, \"clearCurrentCues\", function() { return clearCurrentCues; });\n/* harmony export (binding) */ __nested_webpack_require_948822__.d(__webpack_exports__, \"removeCuesInRange\", function() { return removeCuesInRange; });\n/* harmony export (binding) */ __nested_webpack_require_948822__.d(__webpack_exports__, \"getCuesInRange\", function() { return getCuesInRange; });\n/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_948822__(/*! ./logger */ \"./src/utils/logger.ts\");\n\nfunction sendAddTrackEvent(track, videoEl) {\n  var event;\n\n  try {\n    event = new Event('addtrack');\n  } catch (err) {\n    // for IE11\n    event = document.createEvent('Event');\n    event.initEvent('addtrack', false, false);\n  }\n\n  event.track = track;\n  videoEl.dispatchEvent(event);\n}\nfunction addCueToTrack(track, cue) {\n  // Sometimes there are cue overlaps on segmented vtts so the same\n  // cue can appear more than once in different vtt files.\n  // This avoid showing duplicated cues with same timecode and text.\n  var mode = track.mode;\n\n  if (mode === 'disabled') {\n    track.mode = 'hidden';\n  }\n\n  if (track.cues && !track.cues.getCueById(cue.id)) {\n    try {\n      track.addCue(cue);\n\n      if (!track.cues.getCueById(cue.id)) {\n        throw new Error(\"addCue is failed for: \" + cue);\n      }\n    } catch (err) {\n      _logger__WEBPACK_IMPORTED_MODULE_0__[\"logger\"].debug(\"[texttrack-utils]: \" + err);\n      var textTrackCue = new self.TextTrackCue(cue.startTime, cue.endTime, cue.text);\n      textTrackCue.id = cue.id;\n      track.addCue(textTrackCue);\n    }\n  }\n\n  if (mode === 'disabled') {\n    track.mode = mode;\n  }\n}\nfunction clearCurrentCues(track) {\n  // When track.mode is disabled, track.cues will be null.\n  // To guarantee the removal of cues, we need to temporarily\n  // change the mode to hidden\n  var mode = track.mode;\n\n  if (mode === 'disabled') {\n    track.mode = 'hidden';\n  }\n\n  if (track.cues) {\n    for (var i = track.cues.length; i--;) {\n      track.removeCue(track.cues[i]);\n    }\n  }\n\n  if (mode === 'disabled') {\n    track.mode = mode;\n  }\n}\nfunction removeCuesInRange(track, start, end) {\n  var mode = track.mode;\n\n  if (mode === 'disabled') {\n    track.mode = 'hidden';\n  }\n\n  if (track.cues && track.cues.length > 0) {\n    var cues = getCuesInRange(track.cues, start, end);\n\n    for (var i = 0; i < cues.length; i++) {\n      track.removeCue(cues[i]);\n    }\n  }\n\n  if (mode === 'disabled') {\n    track.mode = mode;\n  }\n} // Find first cue starting after given time.\n// Modified version of binary search O(log(n)).\n\nfunction getFirstCueIndexAfterTime(cues, time) {\n  // If first cue starts after time, start there\n  if (time < cues[0].startTime) {\n    return 0;\n  } // If the last cue ends before time there is no overlap\n\n\n  var len = cues.length - 1;\n\n  if (time > cues[len].endTime) {\n    return -1;\n  }\n\n  var left = 0;\n  var right = len;\n\n  while (left <= right) {\n    var mid = Math.floor((right + left) / 2);\n\n    if (time < cues[mid].startTime) {\n      right = mid - 1;\n    } else if (time > cues[mid].startTime && left < len) {\n      left = mid + 1;\n    } else {\n      // If it's not lower or higher, it must be equal.\n      return mid;\n    }\n  } // At this point, left and right have swapped.\n  // No direct match was found, left or right element must be the closest. Check which one has the smallest diff.\n\n\n  return cues[left].startTime - time < time - cues[right].startTime ? left : right;\n}\n\nfunction getCuesInRange(cues, start, end) {\n  var cuesFound = [];\n  var firstCueInRange = getFirstCueIndexAfterTime(cues, start);\n\n  if (firstCueInRange > -1) {\n    for (var i = firstCueInRange, len = cues.length; i < len; i++) {\n      var cue = cues[i];\n\n      if (cue.startTime >= start && cue.endTime <= end) {\n        cuesFound.push(cue);\n      } else if (cue.startTime > end) {\n        return cuesFound;\n      }\n    }\n  }\n\n  return cuesFound;\n}\n\n/***/ }),\n\n/***/ \"./src/utils/time-ranges.ts\":\n/*!**********************************!*\\\n  !*** ./src/utils/time-ranges.ts ***!\n  \\**********************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_953347__) {\n\n\"use strict\";\n__nested_webpack_require_953347__.r(__webpack_exports__);\n/**\n *  TimeRanges to string helper\n */\nvar TimeRanges = {\n  toString: function toString(r) {\n    var log = '';\n    var len = r.length;\n\n    for (var i = 0; i < len; i++) {\n      log += '[' + r.start(i).toFixed(3) + ',' + r.end(i).toFixed(3) + ']';\n    }\n\n    return log;\n  }\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (TimeRanges);\n\n/***/ }),\n\n/***/ \"./src/utils/timescale-conversion.ts\":\n/*!*******************************************!*\\\n  !*** ./src/utils/timescale-conversion.ts ***!\n  \\*******************************************/\n/*! exports provided: toTimescaleFromBase, toTimescaleFromScale, toMsFromMpegTsClock, toMpegTsClockFromTimescale */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_954148__) {\n\n\"use strict\";\n__nested_webpack_require_954148__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_954148__.d(__webpack_exports__, \"toTimescaleFromBase\", function() { return toTimescaleFromBase; });\n/* harmony export (binding) */ __nested_webpack_require_954148__.d(__webpack_exports__, \"toTimescaleFromScale\", function() { return toTimescaleFromScale; });\n/* harmony export (binding) */ __nested_webpack_require_954148__.d(__webpack_exports__, \"toMsFromMpegTsClock\", function() { return toMsFromMpegTsClock; });\n/* harmony export (binding) */ __nested_webpack_require_954148__.d(__webpack_exports__, \"toMpegTsClockFromTimescale\", function() { return toMpegTsClockFromTimescale; });\nvar MPEG_TS_CLOCK_FREQ_HZ = 90000;\nfunction toTimescaleFromBase(value, destScale, srcBase, round) {\n  if (srcBase === void 0) {\n    srcBase = 1;\n  }\n\n  if (round === void 0) {\n    round = false;\n  }\n\n  var result = value * destScale * srcBase; // equivalent to `(value * scale) / (1 / base)`\n\n  return round ? Math.round(result) : result;\n}\nfunction toTimescaleFromScale(value, destScale, srcScale, round) {\n  if (srcScale === void 0) {\n    srcScale = 1;\n  }\n\n  if (round === void 0) {\n    round = false;\n  }\n\n  return toTimescaleFromBase(value, destScale, 1 / srcScale, round);\n}\nfunction toMsFromMpegTsClock(value, round) {\n  if (round === void 0) {\n    round = false;\n  }\n\n  return toTimescaleFromBase(value, 1000, 1 / MPEG_TS_CLOCK_FREQ_HZ, round);\n}\nfunction toMpegTsClockFromTimescale(value, srcScale) {\n  if (srcScale === void 0) {\n    srcScale = 1;\n  }\n\n  return toTimescaleFromBase(value, MPEG_TS_CLOCK_FREQ_HZ, 1 / srcScale);\n}\n\n/***/ }),\n\n/***/ \"./src/utils/typed-array.ts\":\n/*!**********************************!*\\\n  !*** ./src/utils/typed-array.ts ***!\n  \\**********************************/\n/*! exports provided: sliceUint8 */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_956000__) {\n\n\"use strict\";\n__nested_webpack_require_956000__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_956000__.d(__webpack_exports__, \"sliceUint8\", function() { return sliceUint8; });\nfunction sliceUint8(array, start, end) {\n  // @ts-expect-error This polyfills IE11 usage of Uint8Array slice.\n  // It always exists in the TypeScript definition so fails, but it fails at runtime on IE11.\n  return Uint8Array.prototype.slice ? array.slice(start, end) : new Uint8Array(Array.prototype.slice.call(array, start, end));\n}\n\n/***/ }),\n\n/***/ \"./src/utils/vttcue.ts\":\n/*!*****************************!*\\\n  !*** ./src/utils/vttcue.ts ***!\n  \\*****************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_956764__) {\n\n\"use strict\";\n__nested_webpack_require_956764__.r(__webpack_exports__);\n/**\n * Copyright 2013 vtt.js Contributors\n *\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/* harmony default export */ __webpack_exports__[\"default\"] = ((function () {\n  if (typeof self !== 'undefined' && self.VTTCue) {\n    return self.VTTCue;\n  }\n\n  var AllowedDirections = ['', 'lr', 'rl'];\n  var AllowedAlignments = ['start', 'middle', 'end', 'left', 'right'];\n\n  function isAllowedValue(allowed, value) {\n    if (typeof value !== 'string') {\n      return false;\n    } // necessary for assuring the generic conforms to the Array interface\n\n\n    if (!Array.isArray(allowed)) {\n      return false;\n    } // reset the type so that the next narrowing works well\n\n\n    var lcValue = value.toLowerCase(); // use the allow list to narrow the type to a specific subset of strings\n\n    if (~allowed.indexOf(lcValue)) {\n      return lcValue;\n    }\n\n    return false;\n  }\n\n  function findDirectionSetting(value) {\n    return isAllowedValue(AllowedDirections, value);\n  }\n\n  function findAlignSetting(value) {\n    return isAllowedValue(AllowedAlignments, value);\n  }\n\n  function extend(obj) {\n    for (var _len = arguments.length, rest = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      rest[_key - 1] = arguments[_key];\n    }\n\n    var i = 1;\n\n    for (; i < arguments.length; i++) {\n      var cobj = arguments[i];\n\n      for (var p in cobj) {\n        obj[p] = cobj[p];\n      }\n    }\n\n    return obj;\n  }\n\n  function VTTCue(startTime, endTime, text) {\n    var cue = this;\n    var baseObj = {\n      enumerable: true\n    };\n    /**\n     * Shim implementation specific properties. These properties are not in\n     * the spec.\n     */\n    // Lets us know when the VTTCue's data has changed in such a way that we need\n    // to recompute its display state. This lets us compute its display state\n    // lazily.\n\n    cue.hasBeenReset = false;\n    /**\n     * VTTCue and TextTrackCue properties\n     * http://dev.w3.org/html5/webvtt/#vttcue-interface\n     */\n\n    var _id = '';\n    var _pauseOnExit = false;\n    var _startTime = startTime;\n    var _endTime = endTime;\n    var _text = text;\n    var _region = null;\n    var _vertical = '';\n    var _snapToLines = true;\n    var _line = 'auto';\n    var _lineAlign = 'start';\n    var _position = 50;\n    var _positionAlign = 'middle';\n    var _size = 50;\n    var _align = 'middle';\n    Object.defineProperty(cue, 'id', extend({}, baseObj, {\n      get: function get() {\n        return _id;\n      },\n      set: function set(value) {\n        _id = '' + value;\n      }\n    }));\n    Object.defineProperty(cue, 'pauseOnExit', extend({}, baseObj, {\n      get: function get() {\n        return _pauseOnExit;\n      },\n      set: function set(value) {\n        _pauseOnExit = !!value;\n      }\n    }));\n    Object.defineProperty(cue, 'startTime', extend({}, baseObj, {\n      get: function get() {\n        return _startTime;\n      },\n      set: function set(value) {\n        if (typeof value !== 'number') {\n          throw new TypeError('Start time must be set to a number.');\n        }\n\n        _startTime = value;\n        this.hasBeenReset = true;\n      }\n    }));\n    Object.defineProperty(cue, 'endTime', extend({}, baseObj, {\n      get: function get() {\n        return _endTime;\n      },\n      set: function set(value) {\n        if (typeof value !== 'number') {\n          throw new TypeError('End time must be set to a number.');\n        }\n\n        _endTime = value;\n        this.hasBeenReset = true;\n      }\n    }));\n    Object.defineProperty(cue, 'text', extend({}, baseObj, {\n      get: function get() {\n        return _text;\n      },\n      set: function set(value) {\n        _text = '' + value;\n        this.hasBeenReset = true;\n      }\n    })); // todo: implement VTTRegion polyfill?\n\n    Object.defineProperty(cue, 'region', extend({}, baseObj, {\n      get: function get() {\n        return _region;\n      },\n      set: function set(value) {\n        _region = value;\n        this.hasBeenReset = true;\n      }\n    }));\n    Object.defineProperty(cue, 'vertical', extend({}, baseObj, {\n      get: function get() {\n        return _vertical;\n      },\n      set: function set(value) {\n        var setting = findDirectionSetting(value); // Have to check for false because the setting an be an empty string.\n\n        if (setting === false) {\n          throw new SyntaxError('An invalid or illegal string was specified.');\n        }\n\n        _vertical = setting;\n        this.hasBeenReset = true;\n      }\n    }));\n    Object.defineProperty(cue, 'snapToLines', extend({}, baseObj, {\n      get: function get() {\n        return _snapToLines;\n      },\n      set: function set(value) {\n        _snapToLines = !!value;\n        this.hasBeenReset = true;\n      }\n    }));\n    Object.defineProperty(cue, 'line', extend({}, baseObj, {\n      get: function get() {\n        return _line;\n      },\n      set: function set(value) {\n        if (typeof value !== 'number' && value !== 'auto') {\n          throw new SyntaxError('An invalid number or illegal string was specified.');\n        }\n\n        _line = value;\n        this.hasBeenReset = true;\n      }\n    }));\n    Object.defineProperty(cue, 'lineAlign', extend({}, baseObj, {\n      get: function get() {\n        return _lineAlign;\n      },\n      set: function set(value) {\n        var setting = findAlignSetting(value);\n\n        if (!setting) {\n          throw new SyntaxError('An invalid or illegal string was specified.');\n        }\n\n        _lineAlign = setting;\n        this.hasBeenReset = true;\n      }\n    }));\n    Object.defineProperty(cue, 'position', extend({}, baseObj, {\n      get: function get() {\n        return _position;\n      },\n      set: function set(value) {\n        if (value < 0 || value > 100) {\n          throw new Error('Position must be between 0 and 100.');\n        }\n\n        _position = value;\n        this.hasBeenReset = true;\n      }\n    }));\n    Object.defineProperty(cue, 'positionAlign', extend({}, baseObj, {\n      get: function get() {\n        return _positionAlign;\n      },\n      set: function set(value) {\n        var setting = findAlignSetting(value);\n\n        if (!setting) {\n          throw new SyntaxError('An invalid or illegal string was specified.');\n        }\n\n        _positionAlign = setting;\n        this.hasBeenReset = true;\n      }\n    }));\n    Object.defineProperty(cue, 'size', extend({}, baseObj, {\n      get: function get() {\n        return _size;\n      },\n      set: function set(value) {\n        if (value < 0 || value > 100) {\n          throw new Error('Size must be between 0 and 100.');\n        }\n\n        _size = value;\n        this.hasBeenReset = true;\n      }\n    }));\n    Object.defineProperty(cue, 'align', extend({}, baseObj, {\n      get: function get() {\n        return _align;\n      },\n      set: function set(value) {\n        var setting = findAlignSetting(value);\n\n        if (!setting) {\n          throw new SyntaxError('An invalid or illegal string was specified.');\n        }\n\n        _align = setting;\n        this.hasBeenReset = true;\n      }\n    }));\n    /**\n     * Other <track> spec defined properties\n     */\n    // http://www.whatwg.org/specs/web-apps/current-work/multipage/the-video-element.html#text-track-cue-display-state\n\n    cue.displayState = undefined;\n  }\n  /**\n   * VTTCue methods\n   */\n\n\n  VTTCue.prototype.getCueAsHTML = function () {\n    // Assume WebVTT.convertCueToDOMTree is on the global.\n    var WebVTT = self.WebVTT;\n    return WebVTT.convertCueToDOMTree(self, this.text);\n  }; // this is a polyfill hack\n\n\n  return VTTCue;\n})());\n\n/***/ }),\n\n/***/ \"./src/utils/vttparser.ts\":\n/*!********************************!*\\\n  !*** ./src/utils/vttparser.ts ***!\n  \\********************************/\n/*! exports provided: parseTimeStamp, fixLineBreaks, VTTParser */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_965141__) {\n\n\"use strict\";\n__nested_webpack_require_965141__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_965141__.d(__webpack_exports__, \"parseTimeStamp\", function() { return parseTimeStamp; });\n/* harmony export (binding) */ __nested_webpack_require_965141__.d(__webpack_exports__, \"fixLineBreaks\", function() { return fixLineBreaks; });\n/* harmony export (binding) */ __nested_webpack_require_965141__.d(__webpack_exports__, \"VTTParser\", function() { return VTTParser; });\n/* harmony import */ var _vttcue__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_965141__(/*! ./vttcue */ \"./src/utils/vttcue.ts\");\n/*\n * Source: https://github.com/mozilla/vtt.js/blob/master/dist/vtt.js\n */\n\n\nvar StringDecoder = /*#__PURE__*/function () {\n  function StringDecoder() {}\n\n  var _proto = StringDecoder.prototype;\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  _proto.decode = function decode(data, options) {\n    if (!data) {\n      return '';\n    }\n\n    if (typeof data !== 'string') {\n      throw new Error('Error - expected string data.');\n    }\n\n    return decodeURIComponent(encodeURIComponent(data));\n  };\n\n  return StringDecoder;\n}(); // Try to parse input as a time stamp.\n\n\nfunction parseTimeStamp(input) {\n  function computeSeconds(h, m, s, f) {\n    return (h | 0) * 3600 + (m | 0) * 60 + (s | 0) + parseFloat(f || 0);\n  }\n\n  var m = input.match(/^(?:(\\d+):)?(\\d{2}):(\\d{2})(\\.\\d+)?/);\n\n  if (!m) {\n    return null;\n  }\n\n  if (parseFloat(m[2]) > 59) {\n    // Timestamp takes the form of [hours]:[minutes].[milliseconds]\n    // First position is hours as it's over 59.\n    return computeSeconds(m[2], m[3], 0, m[4]);\n  } // Timestamp takes the form of [hours (optional)]:[minutes]:[seconds].[milliseconds]\n\n\n  return computeSeconds(m[1], m[2], m[3], m[4]);\n} // A settings object holds key/value pairs and will ignore anything but the first\n// assignment to a specific key.\n\nvar Settings = /*#__PURE__*/function () {\n  function Settings() {\n    this.values = Object.create(null);\n  }\n\n  var _proto2 = Settings.prototype;\n\n  // Only accept the first assignment to any key.\n  _proto2.set = function set(k, v) {\n    if (!this.get(k) && v !== '') {\n      this.values[k] = v;\n    }\n  } // Return the value for a key, or a default value.\n  // If 'defaultKey' is passed then 'dflt' is assumed to be an object with\n  // a number of possible default values as properties where 'defaultKey' is\n  // the key of the property that will be chosen; otherwise it's assumed to be\n  // a single value.\n  ;\n\n  _proto2.get = function get(k, dflt, defaultKey) {\n    if (defaultKey) {\n      return this.has(k) ? this.values[k] : dflt[defaultKey];\n    }\n\n    return this.has(k) ? this.values[k] : dflt;\n  } // Check whether we have a value for a key.\n  ;\n\n  _proto2.has = function has(k) {\n    return k in this.values;\n  } // Accept a setting if its one of the given alternatives.\n  ;\n\n  _proto2.alt = function alt(k, v, a) {\n    for (var n = 0; n < a.length; ++n) {\n      if (v === a[n]) {\n        this.set(k, v);\n        break;\n      }\n    }\n  } // Accept a setting if its a valid (signed) integer.\n  ;\n\n  _proto2.integer = function integer(k, v) {\n    if (/^-?\\d+$/.test(v)) {\n      // integer\n      this.set(k, parseInt(v, 10));\n    }\n  } // Accept a setting if its a valid percentage.\n  ;\n\n  _proto2.percent = function percent(k, v) {\n    if (/^([\\d]{1,3})(\\.[\\d]*)?%$/.test(v)) {\n      var percent = parseFloat(v);\n\n      if (percent >= 0 && percent <= 100) {\n        this.set(k, percent);\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  return Settings;\n}(); // Helper function to parse input into groups separated by 'groupDelim', and\n// interpret each group as a key/value pair separated by 'keyValueDelim'.\n\n\nfunction parseOptions(input, callback, keyValueDelim, groupDelim) {\n  var groups = groupDelim ? input.split(groupDelim) : [input];\n\n  for (var i in groups) {\n    if (typeof groups[i] !== 'string') {\n      continue;\n    }\n\n    var kv = groups[i].split(keyValueDelim);\n\n    if (kv.length !== 2) {\n      continue;\n    }\n\n    var _k = kv[0];\n    var _v = kv[1];\n    callback(_k, _v);\n  }\n}\n\nvar defaults = new _vttcue__WEBPACK_IMPORTED_MODULE_0__[\"default\"](0, 0, ''); // 'middle' was changed to 'center' in the spec: https://github.com/w3c/webvtt/pull/244\n//  Safari doesn't yet support this change, but FF and Chrome do.\n\nvar center = defaults.align === 'middle' ? 'middle' : 'center';\n\nfunction parseCue(input, cue, regionList) {\n  // Remember the original input if we need to throw an error.\n  var oInput = input; // 4.1 WebVTT timestamp\n\n  function consumeTimeStamp() {\n    var ts = parseTimeStamp(input);\n\n    if (ts === null) {\n      throw new Error('Malformed timestamp: ' + oInput);\n    } // Remove time stamp from input.\n\n\n    input = input.replace(/^[^\\sa-zA-Z-]+/, '');\n    return ts;\n  } // 4.4.2 WebVTT cue settings\n\n\n  function consumeCueSettings(input, cue) {\n    var settings = new Settings();\n    parseOptions(input, function (k, v) {\n      var vals;\n\n      switch (k) {\n        case 'region':\n          // Find the last region we parsed with the same region id.\n          for (var i = regionList.length - 1; i >= 0; i--) {\n            if (regionList[i].id === v) {\n              settings.set(k, regionList[i].region);\n              break;\n            }\n          }\n\n          break;\n\n        case 'vertical':\n          settings.alt(k, v, ['rl', 'lr']);\n          break;\n\n        case 'line':\n          vals = v.split(',');\n          settings.integer(k, vals[0]);\n\n          if (settings.percent(k, vals[0])) {\n            settings.set('snapToLines', false);\n          }\n\n          settings.alt(k, vals[0], ['auto']);\n\n          if (vals.length === 2) {\n            settings.alt('lineAlign', vals[1], ['start', center, 'end']);\n          }\n\n          break;\n\n        case 'position':\n          vals = v.split(',');\n          settings.percent(k, vals[0]);\n\n          if (vals.length === 2) {\n            settings.alt('positionAlign', vals[1], ['start', center, 'end', 'line-left', 'line-right', 'auto']);\n          }\n\n          break;\n\n        case 'size':\n          settings.percent(k, v);\n          break;\n\n        case 'align':\n          settings.alt(k, v, ['start', center, 'end', 'left', 'right']);\n          break;\n      }\n    }, /:/, /\\s/); // Apply default values for any missing fields.\n\n    cue.region = settings.get('region', null);\n    cue.vertical = settings.get('vertical', '');\n    var line = settings.get('line', 'auto');\n\n    if (line === 'auto' && defaults.line === -1) {\n      // set numeric line number for Safari\n      line = -1;\n    }\n\n    cue.line = line;\n    cue.lineAlign = settings.get('lineAlign', 'start');\n    cue.snapToLines = settings.get('snapToLines', true);\n    cue.size = settings.get('size', 100);\n    cue.align = settings.get('align', center);\n    var position = settings.get('position', 'auto');\n\n    if (position === 'auto' && defaults.position === 50) {\n      // set numeric position for Safari\n      position = cue.align === 'start' || cue.align === 'left' ? 0 : cue.align === 'end' || cue.align === 'right' ? 100 : 50;\n    }\n\n    cue.position = position;\n  }\n\n  function skipWhitespace() {\n    input = input.replace(/^\\s+/, '');\n  } // 4.1 WebVTT cue timings.\n\n\n  skipWhitespace();\n  cue.startTime = consumeTimeStamp(); // (1) collect cue start time\n\n  skipWhitespace();\n\n  if (input.substr(0, 3) !== '-->') {\n    // (3) next characters must match '-->'\n    throw new Error(\"Malformed time stamp (time stamps must be separated by '-->'): \" + oInput);\n  }\n\n  input = input.substr(3);\n  skipWhitespace();\n  cue.endTime = consumeTimeStamp(); // (5) collect cue end time\n  // 4.1 WebVTT cue settings list.\n\n  skipWhitespace();\n  consumeCueSettings(input, cue);\n}\n\nfunction fixLineBreaks(input) {\n  return input.replace(/<br(?: \\/)?>/gi, '\\n');\n}\nvar VTTParser = /*#__PURE__*/function () {\n  function VTTParser() {\n    this.state = 'INITIAL';\n    this.buffer = '';\n    this.decoder = new StringDecoder();\n    this.regionList = [];\n    this.cue = null;\n    this.oncue = void 0;\n    this.onparsingerror = void 0;\n    this.onflush = void 0;\n  }\n\n  var _proto3 = VTTParser.prototype;\n\n  _proto3.parse = function parse(data) {\n    var _this = this; // If there is no data then we won't decode it, but will just try to parse\n    // whatever is in buffer already. This may occur in circumstances, for\n    // example when flush() is called.\n\n\n    if (data) {\n      // Try to decode the data that we received.\n      _this.buffer += _this.decoder.decode(data, {\n        stream: true\n      });\n    }\n\n    function collectNextLine() {\n      var buffer = _this.buffer;\n      var pos = 0;\n      buffer = fixLineBreaks(buffer);\n\n      while (pos < buffer.length && buffer[pos] !== '\\r' && buffer[pos] !== '\\n') {\n        ++pos;\n      }\n\n      var line = buffer.substr(0, pos); // Advance the buffer early in case we fail below.\n\n      if (buffer[pos] === '\\r') {\n        ++pos;\n      }\n\n      if (buffer[pos] === '\\n') {\n        ++pos;\n      }\n\n      _this.buffer = buffer.substr(pos);\n      return line;\n    } // 3.2 WebVTT metadata header syntax\n\n\n    function parseHeader(input) {\n      parseOptions(input, function (k, v) {// switch (k) {\n        // case 'region':\n        // 3.3 WebVTT region metadata header syntax\n        // console.log('parse region', v);\n        // parseRegion(v);\n        // break;\n        // }\n      }, /:/);\n    } // 5.1 WebVTT file parsing.\n\n\n    try {\n      var line = '';\n\n      if (_this.state === 'INITIAL') {\n        // We can't start parsing until we have the first line.\n        if (!/\\r\\n|\\n/.test(_this.buffer)) {\n          return this;\n        }\n\n        line = collectNextLine(); // strip of UTF-8 BOM if any\n        // https://en.wikipedia.org/wiki/Byte_order_mark#UTF-8\n\n        var m = line.match(/^(ï»¿)?WEBVTT([ \\t].*)?$/);\n\n        if (!m || !m[0]) {\n          throw new Error('Malformed WebVTT signature.');\n        }\n\n        _this.state = 'HEADER';\n      }\n\n      var alreadyCollectedLine = false;\n\n      while (_this.buffer) {\n        // We can't parse a line until we have the full line.\n        if (!/\\r\\n|\\n/.test(_this.buffer)) {\n          return this;\n        }\n\n        if (!alreadyCollectedLine) {\n          line = collectNextLine();\n        } else {\n          alreadyCollectedLine = false;\n        }\n\n        switch (_this.state) {\n          case 'HEADER':\n            // 13-18 - Allow a header (metadata) under the WEBVTT line.\n            if (/:/.test(line)) {\n              parseHeader(line);\n            } else if (!line) {\n              // An empty line terminates the header and starts the body (cues).\n              _this.state = 'ID';\n            }\n\n            continue;\n\n          case 'NOTE':\n            // Ignore NOTE blocks.\n            if (!line) {\n              _this.state = 'ID';\n            }\n\n            continue;\n\n          case 'ID':\n            // Check for the start of NOTE blocks.\n            if (/^NOTE($|[ \\t])/.test(line)) {\n              _this.state = 'NOTE';\n              break;\n            } // 19-29 - Allow any number of line terminators, then initialize new cue values.\n\n\n            if (!line) {\n              continue;\n            }\n\n            _this.cue = new _vttcue__WEBPACK_IMPORTED_MODULE_0__[\"default\"](0, 0, '');\n            _this.state = 'CUE'; // 30-39 - Check if self line contains an optional identifier or timing data.\n\n            if (line.indexOf('-->') === -1) {\n              _this.cue.id = line;\n              continue;\n            }\n\n          // Process line as start of a cue.\n\n          /* falls through */\n\n          case 'CUE':\n            // 40 - Collect cue timings and settings.\n            if (!_this.cue) {\n              _this.state = 'BADCUE';\n              continue;\n            }\n\n            try {\n              parseCue(line, _this.cue, _this.regionList);\n            } catch (e) {\n              // In case of an error ignore rest of the cue.\n              _this.cue = null;\n              _this.state = 'BADCUE';\n              continue;\n            }\n\n            _this.state = 'CUETEXT';\n            continue;\n\n          case 'CUETEXT':\n            {\n              var hasSubstring = line.indexOf('-->') !== -1; // 34 - If we have an empty line then report the cue.\n              // 35 - If we have the special substring '-->' then report the cue,\n              // but do not collect the line as we need to process the current\n              // one as a new cue.\n\n              if (!line || hasSubstring && (alreadyCollectedLine = true)) {\n                // We are done parsing self cue.\n                if (_this.oncue && _this.cue) {\n                  _this.oncue(_this.cue);\n                }\n\n                _this.cue = null;\n                _this.state = 'ID';\n                continue;\n              }\n\n              if (_this.cue === null) {\n                continue;\n              }\n\n              if (_this.cue.text) {\n                _this.cue.text += '\\n';\n              }\n\n              _this.cue.text += line;\n            }\n            continue;\n\n          case 'BADCUE':\n            // 54-62 - Collect and discard the remaining cue.\n            if (!line) {\n              _this.state = 'ID';\n            }\n\n        }\n      }\n    } catch (e) {\n      // If we are currently parsing a cue, report what we have.\n      if (_this.state === 'CUETEXT' && _this.cue && _this.oncue) {\n        _this.oncue(_this.cue);\n      }\n\n      _this.cue = null; // Enter BADWEBVTT state if header was not parsed correctly otherwise\n      // another exception occurred so enter BADCUE state.\n\n      _this.state = _this.state === 'INITIAL' ? 'BADWEBVTT' : 'BADCUE';\n    }\n\n    return this;\n  };\n\n  _proto3.flush = function flush() {\n    var _this = this;\n\n    try {\n      // Finish decoding the stream.\n      // _this.buffer += _this.decoder.decode();\n      // Synthesize the end of the current cue or region.\n      if (_this.cue || _this.state === 'HEADER') {\n        _this.buffer += '\\n\\n';\n\n        _this.parse();\n      } // If we've flushed, parsed, and we're still on the INITIAL state then\n      // that means we don't have enough of the stream to parse the first\n      // line.\n\n\n      if (_this.state === 'INITIAL' || _this.state === 'BADWEBVTT') {\n        throw new Error('Malformed WebVTT signature.');\n      }\n    } catch (e) {\n      if (_this.onparsingerror) {\n        _this.onparsingerror(e);\n      }\n    }\n\n    if (_this.onflush) {\n      _this.onflush();\n    }\n\n    return this;\n  };\n\n  return VTTParser;\n}();\n\n/***/ }),\n\n/***/ \"./src/utils/webvtt-parser.ts\":\n/*!************************************!*\\\n  !*** ./src/utils/webvtt-parser.ts ***!\n  \\************************************/\n/*! exports provided: generateCueId, parseWebVTT */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_979909__) {\n\n\"use strict\";\n__nested_webpack_require_979909__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_979909__.d(__webpack_exports__, \"generateCueId\", function() { return generateCueId; });\n/* harmony export (binding) */ __nested_webpack_require_979909__.d(__webpack_exports__, \"parseWebVTT\", function() { return parseWebVTT; });\n/* harmony import */ var _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_979909__(/*! ./src/polyfills/number */ \"./src/polyfills/number.ts\");\n/* harmony import */ var _vttparser__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_979909__(/*! ./vttparser */ \"./src/utils/vttparser.ts\");\n/* harmony import */ var _demux_id3__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_979909__(/*! ../demux/id3 */ \"./src/demux/id3.ts\");\n/* harmony import */ var _timescale_conversion__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_979909__(/*! ./timescale-conversion */ \"./src/utils/timescale-conversion.ts\");\n/* harmony import */ var _remux_mp4_remuxer__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_979909__(/*! ../remux/mp4-remuxer */ \"./src/remux/mp4-remuxer.ts\");\n\n\n\n\n\n\n\n\nvar LINEBREAKS = /\\r\\n|\\n\\r|\\n|\\r/g; // String.prototype.startsWith is not supported in IE11\n\nvar startsWith = function startsWith(inputString, searchString, position) {\n  if (position === void 0) {\n    position = 0;\n  }\n\n  return inputString.substr(position, searchString.length) === searchString;\n};\n\nvar cueString2millis = function cueString2millis(timeString) {\n  var ts = parseInt(timeString.substr(-3));\n  var secs = parseInt(timeString.substr(-6, 2));\n  var mins = parseInt(timeString.substr(-9, 2));\n  var hours = timeString.length > 9 ? parseInt(timeString.substr(0, timeString.indexOf(':'))) : 0;\n\n  if (!Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__[\"isFiniteNumber\"])(ts) || !Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__[\"isFiniteNumber\"])(secs) || !Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__[\"isFiniteNumber\"])(mins) || !Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__[\"isFiniteNumber\"])(hours)) {\n    throw Error(\"Malformed X-TIMESTAMP-MAP: Local:\" + timeString);\n  }\n\n  ts += 1000 * secs;\n  ts += 60 * 1000 * mins;\n  ts += 60 * 60 * 1000 * hours;\n  return ts;\n}; // From https://github.com/darkskyapp/string-hash\n\n\nvar hash = function hash(text) {\n  var hash = 5381;\n  var i = text.length;\n\n  while (i) {\n    hash = hash * 33 ^ text.charCodeAt(--i);\n  }\n\n  return (hash >>> 0).toString();\n}; // Create a unique hash id for a cue based on start/end times and text.\n// This helps timeline-controller to avoid showing repeated captions.\n\n\nfunction generateCueId(startTime, endTime, text) {\n  return hash(startTime.toString()) + hash(endTime.toString()) + hash(text);\n}\n\nvar calculateOffset = function calculateOffset(vttCCs, cc, presentationTime) {\n  var currCC = vttCCs[cc];\n  var prevCC = vttCCs[currCC.prevCC]; // This is the first discontinuity or cues have been processed since the last discontinuity\n  // Offset = current discontinuity time\n\n  if (!prevCC || !prevCC.new && currCC.new) {\n    vttCCs.ccOffset = vttCCs.presentationOffset = currCC.start;\n    currCC.new = false;\n    return;\n  } // There have been discontinuities since cues were last parsed.\n  // Offset = time elapsed\n\n\n  while ((_prevCC = prevCC) !== null && _prevCC !== void 0 && _prevCC.new) {\n    var _prevCC;\n\n    vttCCs.ccOffset += currCC.start - prevCC.start;\n    currCC.new = false;\n    currCC = prevCC;\n    prevCC = vttCCs[currCC.prevCC];\n  }\n\n  vttCCs.presentationOffset = presentationTime;\n};\n\nfunction parseWebVTT(vttByteArray, initPTS, timescale, vttCCs, cc, timeOffset, callBack, errorCallBack) {\n  var parser = new _vttparser__WEBPACK_IMPORTED_MODULE_1__[\"VTTParser\"](); // Convert byteArray into string, replacing any somewhat exotic linefeeds with \"\\n\", then split on that character.\n  // Uint8Array.prototype.reduce is not implemented in IE11\n\n  var vttLines = Object(_demux_id3__WEBPACK_IMPORTED_MODULE_2__[\"utf8ArrayToStr\"])(new Uint8Array(vttByteArray)).trim().replace(LINEBREAKS, '\\n').split('\\n');\n  var cues = [];\n  var initPTS90Hz = Object(_timescale_conversion__WEBPACK_IMPORTED_MODULE_3__[\"toMpegTsClockFromTimescale\"])(initPTS, timescale);\n  var cueTime = '00:00.000';\n  var timestampMapMPEGTS = 0;\n  var timestampMapLOCAL = 0;\n  var parsingError;\n  var inHeader = true;\n  var timestampMap = false;\n\n  parser.oncue = function (cue) {\n    // Adjust cue timing; clamp cues to start no earlier than - and drop cues that don't end after - 0 on timeline.\n    var currCC = vttCCs[cc];\n    var cueOffset = vttCCs.ccOffset; // Calculate subtitle PTS offset\n\n    var webVttMpegTsMapOffset = (timestampMapMPEGTS - initPTS90Hz) / 90000; // Update offsets for new discontinuities\n\n    if (currCC !== null && currCC !== void 0 && currCC.new) {\n      if (timestampMapLOCAL !== undefined) {\n        // When local time is provided, offset = discontinuity start time - local time\n        cueOffset = vttCCs.ccOffset = currCC.start;\n      } else {\n        calculateOffset(vttCCs, cc, webVttMpegTsMapOffset);\n      }\n    }\n\n    if (webVttMpegTsMapOffset) {\n      // If we have MPEGTS, offset = presentation time + discontinuity offset\n      cueOffset = webVttMpegTsMapOffset - vttCCs.presentationOffset;\n    }\n\n    if (timestampMap) {\n      var duration = cue.endTime - cue.startTime;\n      var startTime = Object(_remux_mp4_remuxer__WEBPACK_IMPORTED_MODULE_4__[\"normalizePts\"])((cue.startTime + cueOffset - timestampMapLOCAL) * 90000, timeOffset * 90000) / 90000;\n      cue.startTime = startTime;\n      cue.endTime = startTime + duration;\n    } //trim trailing webvtt block whitespaces\n\n\n    var text = cue.text.trim(); // Fix encoding of special characters\n\n    cue.text = decodeURIComponent(encodeURIComponent(text)); // If the cue was not assigned an id from the VTT file (line above the content), create one.\n\n    if (!cue.id) {\n      cue.id = generateCueId(cue.startTime, cue.endTime, text);\n    }\n\n    if (cue.endTime > 0) {\n      cues.push(cue);\n    }\n  };\n\n  parser.onparsingerror = function (error) {\n    parsingError = error;\n  };\n\n  parser.onflush = function () {\n    if (parsingError) {\n      errorCallBack(parsingError);\n      return;\n    }\n\n    callBack(cues);\n  }; // Go through contents line by line.\n\n\n  vttLines.forEach(function (line) {\n    if (inHeader) {\n      // Look for X-TIMESTAMP-MAP in header.\n      if (startsWith(line, 'X-TIMESTAMP-MAP=')) {\n        // Once found, no more are allowed anyway, so stop searching.\n        inHeader = false;\n        timestampMap = true; // Extract LOCAL and MPEGTS.\n\n        line.substr(16).split(',').forEach(function (timestamp) {\n          if (startsWith(timestamp, 'LOCAL:')) {\n            cueTime = timestamp.substr(6);\n          } else if (startsWith(timestamp, 'MPEGTS:')) {\n            timestampMapMPEGTS = parseInt(timestamp.substr(7));\n          }\n        });\n\n        try {\n          // Convert cue time to seconds\n          timestampMapLOCAL = cueString2millis(cueTime) / 1000;\n        } catch (error) {\n          timestampMap = false;\n          parsingError = error;\n        } // Return without parsing X-TIMESTAMP-MAP line.\n\n\n        return;\n      } else if (line === '') {\n        inHeader = false;\n      }\n    } // Parse line by default.\n\n\n    parser.parse(line + '\\n');\n  });\n  parser.flush();\n}\n\n/***/ }),\n\n/***/ \"./src/utils/xhr-loader.ts\":\n/*!*********************************!*\\\n  !*** ./src/utils/xhr-loader.ts ***!\n  \\*********************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_987611__) {\n\n\"use strict\";\n__nested_webpack_require_987611__.r(__webpack_exports__);\n/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_987611__(/*! ../utils/logger */ \"./src/utils/logger.ts\");\n/* harmony import */ var _loader_load_stats__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_987611__(/*! ../loader/load-stats */ \"./src/loader/load-stats.ts\");\n\n\nvar AGE_HEADER_LINE_REGEX = /^age:\\s*[\\d.]+\\s*$/m;\n\nvar XhrLoader = /*#__PURE__*/function () {\n  function XhrLoader(config\n  /* HlsConfig */\n  ) {\n    this.xhrSetup = void 0;\n    this.requestTimeout = void 0;\n    this.retryTimeout = void 0;\n    this.retryDelay = void 0;\n    this.config = null;\n    this.callbacks = null;\n    this.context = void 0;\n    this.loader = null;\n    this.stats = void 0;\n    this.xhrSetup = config ? config.xhrSetup : null;\n    this.stats = new _loader_load_stats__WEBPACK_IMPORTED_MODULE_1__[\"LoadStats\"]();\n    this.retryDelay = 0;\n  }\n\n  var _proto = XhrLoader.prototype;\n\n  _proto.destroy = function destroy() {\n    this.callbacks = null;\n    this.abortInternal();\n    this.loader = null;\n    this.config = null;\n  };\n\n  _proto.abortInternal = function abortInternal() {\n    var loader = this.loader;\n    self.clearTimeout(this.requestTimeout);\n    self.clearTimeout(this.retryTimeout);\n\n    if (loader) {\n      loader.onreadystatechange = null;\n      loader.onprogress = null;\n\n      if (loader.readyState !== 4) {\n        this.stats.aborted = true;\n        loader.abort();\n      }\n    }\n  };\n\n  _proto.abort = function abort() {\n    var _this$callbacks;\n\n    this.abortInternal();\n\n    if ((_this$callbacks = this.callbacks) !== null && _this$callbacks !== void 0 && _this$callbacks.onAbort) {\n      this.callbacks.onAbort(this.stats, this.context, this.loader);\n    }\n  };\n\n  _proto.load = function load(context, config, callbacks) {\n    if (this.stats.loading.start) {\n      throw new Error('Loader can only be used once.');\n    }\n\n    this.stats.loading.start = self.performance.now();\n    this.context = context;\n    this.config = config;\n    this.callbacks = callbacks;\n    this.retryDelay = config.retryDelay;\n    this.loadInternal();\n  };\n\n  _proto.loadInternal = function loadInternal() {\n    var config = this.config,\n        context = this.context;\n\n    if (!config) {\n      return;\n    }\n\n    var xhr = this.loader = new self.XMLHttpRequest();\n    var stats = this.stats;\n    stats.loading.first = 0;\n    stats.loaded = 0;\n    var xhrSetup = this.xhrSetup;\n\n    try {\n      if (xhrSetup) {\n        try {\n          xhrSetup(xhr, context.url);\n        } catch (e) {\n          // fix xhrSetup: (xhr, url) => {xhr.setRequestHeader(\"Content-Language\", \"test\");}\n          // not working, as xhr.setRequestHeader expects xhr.readyState === OPEN\n          xhr.open('GET', context.url, true);\n          xhrSetup(xhr, context.url);\n        }\n      }\n\n      if (!xhr.readyState) {\n        xhr.open('GET', context.url, true);\n      }\n\n      var headers = this.context.headers;\n\n      if (headers) {\n        for (var header in headers) {\n          xhr.setRequestHeader(header, headers[header]);\n        }\n      }\n    } catch (e) {\n      // IE11 throws an exception on xhr.open if attempting to access an HTTP resource over HTTPS\n      this.callbacks.onError({\n        code: xhr.status,\n        text: e.message\n      }, context, xhr);\n      return;\n    }\n\n    if (context.rangeEnd) {\n      xhr.setRequestHeader('Range', 'bytes=' + context.rangeStart + '-' + (context.rangeEnd - 1));\n    }\n\n    xhr.onreadystatechange = this.readystatechange.bind(this);\n    xhr.onprogress = this.loadprogress.bind(this);\n    xhr.responseType = context.responseType; // setup timeout before we perform request\n\n    self.clearTimeout(this.requestTimeout);\n    this.requestTimeout = self.setTimeout(this.loadtimeout.bind(this), config.timeout);\n    xhr.send();\n  };\n\n  _proto.readystatechange = function readystatechange() {\n    var context = this.context,\n        xhr = this.loader,\n        stats = this.stats;\n\n    if (!context || !xhr) {\n      return;\n    }\n\n    var readyState = xhr.readyState;\n    var config = this.config; // don't proceed if xhr has been aborted\n\n    if (stats.aborted) {\n      return;\n    } // >= HEADERS_RECEIVED\n\n\n    if (readyState >= 2) {\n      // clear xhr timeout and rearm it if readyState less than 4\n      self.clearTimeout(this.requestTimeout);\n\n      if (stats.loading.first === 0) {\n        stats.loading.first = Math.max(self.performance.now(), stats.loading.start);\n      }\n\n      if (readyState === 4) {\n        xhr.onreadystatechange = null;\n        xhr.onprogress = null;\n        var status = xhr.status; // http status between 200 to 299 are all successful\n\n        if (status >= 200 && status < 300) {\n          stats.loading.end = Math.max(self.performance.now(), stats.loading.first);\n          var data;\n          var len;\n\n          if (context.responseType === 'arraybuffer') {\n            data = xhr.response;\n            len = data.byteLength;\n          } else {\n            data = xhr.responseText;\n            len = data.length;\n          }\n\n          stats.loaded = stats.total = len;\n\n          if (!this.callbacks) {\n            return;\n          }\n\n          var onProgress = this.callbacks.onProgress;\n\n          if (onProgress) {\n            onProgress(stats, context, data, xhr);\n          }\n\n          if (!this.callbacks) {\n            return;\n          }\n\n          var response = {\n            url: xhr.responseURL,\n            data: data\n          };\n          this.callbacks.onSuccess(response, stats, context, xhr);\n        } else {\n          // if max nb of retries reached or if http status between 400 and 499 (such error cannot be recovered, retrying is useless), return error\n          if (stats.retry >= config.maxRetry || status >= 400 && status < 499) {\n            _utils_logger__WEBPACK_IMPORTED_MODULE_0__[\"logger\"].error(status + \" while loading \" + context.url);\n            this.callbacks.onError({\n              code: status,\n              text: xhr.statusText\n            }, context, xhr);\n          } else {\n            // retry\n            _utils_logger__WEBPACK_IMPORTED_MODULE_0__[\"logger\"].warn(status + \" while loading \" + context.url + \", retrying in \" + this.retryDelay + \"...\"); // abort and reset internal state\n\n            this.abortInternal();\n            this.loader = null; // schedule retry\n\n            self.clearTimeout(this.retryTimeout);\n            this.retryTimeout = self.setTimeout(this.loadInternal.bind(this), this.retryDelay); // set exponential backoff\n\n            this.retryDelay = Math.min(2 * this.retryDelay, config.maxRetryDelay);\n            stats.retry++;\n          }\n        }\n      } else {\n        // readyState >= 2 AND readyState !==4 (readyState = HEADERS_RECEIVED || LOADING) rearm timeout as xhr not finished yet\n        self.clearTimeout(this.requestTimeout);\n        this.requestTimeout = self.setTimeout(this.loadtimeout.bind(this), config.timeout);\n      }\n    }\n  };\n\n  _proto.loadtimeout = function loadtimeout() {\n    _utils_logger__WEBPACK_IMPORTED_MODULE_0__[\"logger\"].warn(\"timeout while loading \" + this.context.url);\n    var callbacks = this.callbacks;\n\n    if (callbacks) {\n      this.abortInternal();\n      callbacks.onTimeout(this.stats, this.context, this.loader);\n    }\n  };\n\n  _proto.loadprogress = function loadprogress(event) {\n    var stats = this.stats;\n    stats.loaded = event.loaded;\n\n    if (event.lengthComputable) {\n      stats.total = event.total;\n    }\n  };\n\n  _proto.getCacheAge = function getCacheAge() {\n    var result = null;\n\n    if (this.loader && AGE_HEADER_LINE_REGEX.test(this.loader.getAllResponseHeaders())) {\n      var ageHeader = this.loader.getResponseHeader('age');\n      result = ageHeader ? parseFloat(ageHeader) : null;\n    }\n\n    return result;\n  };\n\n  return XhrLoader;\n}();\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (XhrLoader);\n\n/***/ })\n\n/******/ })[\"default\"];\n});\n//# sourceMappingURL=hls.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2SUFBNkk7QUFDN0k7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sR0FBRztBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0EsTUFBTTs7O0FBR047O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qjs7QUFFN0I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNS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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsNkNBQTZDO0FBQzdDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7O0FBRTVDO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7O0FBRXREO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsOEZBQThGO0FBQzlGOzs7QUFHQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxRQUFRLG1DQUFtQzs7O0FBRzNDO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsMENBQTBDOztBQUUxQztBQUNBLGdEQUFnRDs7QUFFaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RTs7QUFFeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscURBQXFEOztBQUVyRDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOFJBQThSOztBQUU5UjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsMElBQTBJOztBQUUxSTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQ0FBMkMsU0FBUztBQUNwRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUVBQXFFOztBQUVyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsb0VBQW9FO0FBQzlFOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EseUVBQXlFO0FBQ3pFOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEdBQTBHOztBQUUxRztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7O0FBR1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0U7QUFDL0U7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEI7O0FBRTVCOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQjs7QUFFMUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4QkFBOEI7O0FBRTlCO0FBQ0E7QUFDQTtBQUNBLFFBQVE7OztBQUdSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOzs7QUFHQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLGdJQUFnSTs7QUFFaEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7OztBQUlELE9BQU87O0FBRVA7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7OztBQUdWO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE1BQU07OztBQUdOOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwR0FBMEc7O0FBRTFHO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRzs7QUFFZDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsK0JBQStCOztBQUUvQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7OztBQUdWO0FBQ0Es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OztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCOztBQUU1QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxzREFBc0Q7QUFDMUQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7OztBQUdBOztBQUVBLG9CQUFvQixtQkFBbUI7QUFDdkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGlDQUFtQjs7QUFFaEU7QUFDQSxpQ0FBbUI7QUFDbkIsK0JBQStCLGlDQUFtQixnREFBZ0Qsd0JBQXdCO0FBQzFILGdFQUFnRSxpQ0FBbUI7QUFDbkYsb0VBQW9FLGlDQUFtQjtBQUN2Riw2RUFBNkUsaUNBQW1CO0FBQ2hHLHNFQUFzRSxpQ0FBbUI7QUFDekYsNENBQTRDLGdCQUFnQixrQkFBa0IsT0FBTywyQkFBMkIsd0RBQXdELGdDQUFnQyx1REFBdUQ7O0FBRS9QLDhEQUE4RCxzRUFBc0UsOERBQThEOztBQUVsTSw4REFBOEQsaUZBQWlGLGdEQUFnRCx3SEFBd0gsZ0JBQWdCLFdBQVcscUJBQXFCLDRCQUE0QixjQUFjLFNBQVMsbUNBQW1DOztBQUU3YixrREFBa0QsZ0JBQWdCLGdFQUFnRSx3REFBd0QsNkRBQTZELHNEQUFzRDs7QUFFN1MsdUNBQXVDLHVEQUF1RCx1Q0FBdUMsU0FBUyxPQUFPLG9CQUFvQjs7QUFFekssc0JBQXNCLGdEQUFnRCxnQkFBZ0Isc0JBQXNCLE9BQU8sMkJBQTJCLDBCQUEwQix5REFBeUQsaUNBQWlDLGtCQUFrQjs7Ozs7O0FBTXBSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0NBQWdDOztBQUVoQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrREFBK0Q7O0FBRS9EO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlFQUF5RSw0QkFBNEI7QUFDckc7O0FBRUE7QUFD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Q0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlDQUFpQzs7O0FBR2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlDQUF5QyxJQUFJO0FBQzdDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDhCQUE4QixJQUFJO0FBQ2xDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsUUFBUTtBQUNSLGlDQUFpQztBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGdEQUFnRDs7QUFFaEQ7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esd0JBQXdCLHNCQUFzQjtBQUM5QztB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RUE7QUFDQTtBQUNBOztBQUVBLHNCQUFzQix1Q0FBdUM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBLDJMQUEyTDtBQUMzTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTs7O0FBR1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFROzs7QUFHUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxHQUFHOzs7QUFHVjtBQUNBLDRHQUE0Rzs7QUFFNUc7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7Ozs7QUFJRCxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsaUNBQW1COztBQUVoRTtBQUNBLGlDQUFtQjtBQUNuQiwrQkFBK0IsaUNBQW1CLG1EQUFtRCxvQkFBb0I7QUFDekgsK0JBQStCLGlDQUFtQiw4REFBOEQsK0JBQStCO0FBQy9JLCtCQUErQixpQ0FBbUIsa0RBQWtELG1CQUFtQjtBQUN2SCwrQkFBK0IsaUNBQW1CLHlEQUF5RCwwQkFBMEI7QUFDckksK0JBQStCLGlDQUFtQixxREFBcUQsc0JBQXNCO0FBQzdILCtCQUErQixpQ0FBbUIsNERBQTRELDZCQUE2QjtBQUMzSSwrQkFBK0IsaUNBQW1CLGdFQUFnRSxpQ0FBaUM7QUFDbkosK0JBQStCLGlDQUFtQixzREFBc0QsdUJBQXVCO0FBQy9ILCtCQUErQixpQ0FBbUIsbURBQW1ELG9CQUFvQjtBQUN6SCwrQkFBK0IsaUNBQW1CLDhEQUE4RCwrQkFBK0I7QUFDL0ksK0JBQStCLGlDQUFtQiwwREFBMEQsMkJBQTJCO0FBQ3ZJLCtCQUErQixpQ0FBbUIsb0RBQW9ELHFCQUFxQjtBQUMzSCw2R0FBNkcsaUNBQW1CO0FBQ2hJLHNFQUFzRSxpQ0FBbUI7Ozs7Ozs7QUFPekY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUNBQW1DOztBQUVuQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0Esd0JBQXdCLFVBQVUsb0JBQW9CLFFBQVEsVUFBVSxXQUFXOzs7QUFHbkY7QUFDQTtBQUNBLE1BQU07O0FBRU4sSUFBSTtBQUNKLGdEQUFnRDs7QUFFaEQ7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkJBQTZCOztBQUU3QixvQkFBb0IsT0FBTztBQUMzQjtBQUNBLElBQUk7OztBQUdKLG9CQUFvQiwwQkFBMEI7QUFDOUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0NBQXdDLFFBQVE7QUFDaEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7OztBQUdSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUEsZ0RBQWdELEtBQUs7QUFDckQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLHNCQUFzQiwyQkFBMkI7QUFDakQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7QUFDQSxHQUFHLEdBQUc7O0FBRU47QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkNBQTJDLFVBQVU7QUFDckQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsVUFBVTtBQUNoQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMENBQTBDLHNCQUFzQjtBQUNoRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDs7QUFFeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUksc0RBQXNELDRDQUE0QztBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGtDQUFrQyxJQUFJO0FBQ3RDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsaUNBQW1COztBQUVoRTtBQUNBLGlDQUFtQjtBQUNuQiwrQkFBK0IsaUNBQW1CLGdEQUFnRCwwQkFBMEI7QUFDNUgsNkdBQTZHLGlDQUFtQjtBQUNoSSxnRkFBZ0YsaUNBQW1CO0FBQ25HLHNFQUFzRSxpQ0FBbUI7QUFDekYsZ0VBQWdFLGlDQUFtQjtBQUNuRiw2RUFBNkUsaUNBQW1CO0FBQ2hHLDBFQUEwRSxpQ0FBbUI7QUFDN0Ysc0VBQXNFLGlDQUFtQjtBQUN6Rix5RUFBeUUsaUNBQW1CO0FBQzVGLG9GQUFvRixpQ0FBbUI7QUFDdkcsMEVBQTBFLGlDQUFtQjtBQUM3Rix5RUFBeUUsaUNBQW1CO0FBQzVGLGlFQUFpRSxpQ0FBbUI7QUFDcEYsdUVBQXVFLGlDQUFtQjs7OztBQUkxRiw0Q0FBNEMsZ0JBQWdCLGtCQUFrQixPQUFPLDJCQUEyQix3REFBd0QsZ0NBQWdDLHVEQUF1RDs7QUFFL1AsOERBQThELHNFQUFzRSw4REFBOEQ7O0FBRWxNLGdEQUFnRCwwREFBMEQsMkNBQTJDOztBQUVySixpQ0FBaUMsNEVBQTRFLGlCQUFpQixhQUFhOzs7Ozs7Ozs7Ozs7OztBQWMzSSx5QkFBeUI7O0FBRXpCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7OztBQUdBO0FBQ0E7QUFDQSxRQUFROzs7QUFHUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQ0FBMEM7O0FBRTFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG1DQUFtQztBQUNuQzs7QUFFQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxvQ0FBb0M7O0FBRXBDLG1FQUFtRTs7QUFFbkU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUVBQXFFOztBQUVyRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOzs7QUFHQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2QkFBNkI7O0FBRTdCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEI7O0FBRTVCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1DQUFtQzs7QUFFbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLHVEQUF1RDtBQUN2RDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLEdBQUc7O0FBRVI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNOzs7QUFHTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4Q0FBOEM7O0FBRTlDO0FBQ0E7O0FBRUEsd0RBQXdEO0FBQ3hELCtCQUErQixTQUFTLE1BQU0saUJBQWlCLEdBQUcsY0FBYyxVQUFVLFdBQVcsT0FBTyxRQUFROzs7QUFHcEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0Qzs7QUFFNUM7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7O0FBR1YsZ0NBQWdDOztBQUVoQztBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCOztBQUUxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQ0FBMEM7O0FBRTFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNEJBQTRCOztBQUU1QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNJQUFzSTtBQUN0STs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRkFBK0Y7O0FBRS9GO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHFGQUFxRjtBQUNyRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCOztBQUU5QjtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQzs7QUFFL0MsK0RBQStEO0FBQy9EOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTs7O0FBR1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7OztBQUdkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsc0RBQXNEOztBQUV0RDtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7OztBQUdSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDRGQUE0Rjs7QUFFNUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLLEdBQUc7O0FBRVI7QUFDQTs7QUFFQTtBQUNBLGdDQUFnQzs7QUFFaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFD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QUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxvQkFBb0IsdUJBQXVCO0FBQzNDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxxQkFBcUIsb0JBQW9CO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQSxrQkFBa0IsMEJBQTBCO0FBQzVDLGtDQUFrQyxzQ0FBc0M7O0FBRXhFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGlDQUFtQjs7QUFFaEU7QUFDQSxpQ0FBbUI7QUFDbkIsK0JBQStCLGlDQUFtQiwyREFBMkQsNEJBQTRCO0FBQ3pJLDZHQUE2RyxpQ0FBbUI7QUFDaEksZ0VBQWdFLGlDQUFtQjtBQUNuRiw4RUFBOEUsaUNBQW1CO0FBQ2pHLDZFQUE2RSxpQ0FBbUI7QUFDaEcsNkVBQTZFLGlDQUFtQjtBQUNoRywrRUFBK0UsaUNBQW1CO0FBQ2xHLGlGQUFpRixpQ0FBbUI7QUFDcEcsc0VBQXNFLGlDQUFtQjtBQUN6RixzRUFBc0UsaUNBQW1COzs7Ozs7Ozs7OztBQVd6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBHQUEwRzs7QUFFMUc7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsbUNBQW1DLElBQUk7QUFDdkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLElBQUksMkNBQTJDO0FBQy9DOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQiw2QkFBNkI7QUFDbkQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDs7QUFFM0Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCOztBQUV0QjtBQUNBO0FBQ0EsK0JBQStCOztBQUUvQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxzQkFBc0IsdUJBQXVCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDRCQUE0Qix3QkFBd0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjOzs7QUFHZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Q0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLGFBQWEsWUFBWSxHQUFHO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFdBQVc7QUFDWDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLGFBQWEsWUFBWSxHQUFHO0FBQzVCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEOztBQUVoRDs7QUFFQSw0Q0FBNEMsU0FBUztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOzs7O0FBSUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxpQ0FBbUI7O0FBRWhFO0FBQ0EsaUNBQW1CO0FBQ25CLCtCQUErQixpQ0FBbUIsbURBQW1ELG9CQUFvQjtBQUN6SCw4REFBOEQsaUNBQW1CO0FBQ2pGLG1FQUFtRSxpQ0FBbUI7QUFDdEYsb0VBQW9FLGlDQUFtQjtBQUN2Riw2REFBNkQsaUNBQW1CO0FBQ2hGLG9FQUFvRSxpQ0FBbUI7QUFDdkYsZ0VBQWdFLGlDQUFtQjtBQUNuRix5RUFBeUUsaUNBQW1CO0FBQzVGLHNFQUFzRSxpQ0FBbUI7QUFDekYsZ0VBQWdFLGlDQUFtQjtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQzs7QUFFbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjs7QUFFQSxpQ0FBaUMsYUFBYTtBQUM5QztBQUNBLDhDQUE4Qzs7QUFFOUM7QUFDQSxpREFBaUQ7O0FBRWpEOztBQUVBO0FBQ0EsZ0RBQWdEOztBQUVoRDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Ozs7QUFHQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7O0FBRUEsK0VBQStFOztBQUUvRTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCOztBQUUxQjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7O0FBRUE7QUFDQSx1Q0FBdUM7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QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxrQkFBa0I7QUFDL0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQSw4RkFBOEY7O0FBRTlGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xELFVBQVU7QUFDVjtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLFNBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkOztBQUVBLEdBQUc7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLFFBQVE7QUFDN0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNB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Qzs7QUFFOUc7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0I7OztBQUdwQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvRkFBb0Y7O0FBRXBGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOzs7O0FBSUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxpRkFBaUY7O0FBRWpGO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsOEJBQThCLElBQUk7QUFDbEMsNkJBQTZCOztBQUU3QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsaUNBQW1COztBQUVoRTtBQUNBLGlDQUFtQjtBQUNuQiw2R0FBNkcsaUNBQW1CO0FBQ2hJLGdFQUFnRSxpQ0FBbUI7QUFDbkYsZ0VBQWdFLGlDQUFtQjtBQUNuRixzRUFBc0UsaUNBQW1CO0FBQ3pGLHlFQUF5RSxpQ0FBbUI7QUFDNUYscUVBQXFFLGlDQUFtQjtBQUN4RixzRUFBc0UsaUNBQW1CO0FBQ3pGLHlFQUF5RSxpQ0FBbUI7Ozs7QUFJNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQVNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEI7QUFDMUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQSxrQ0FBa0MsK0RBQStELGFBQWEsV0FBVyxjQUFjLFFBQVEsV0FBVztBQUMxSjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpREFBaUQ7QUFDakQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNBLDRCQUE0Qjs7QUFFNUI7QUFDQSxNQUFNOzs7QUFHTixnQkFBZ0Isc0JBQXNCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjs7QUFFdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFLHVCQUF1QjtBQUNuRzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLGNBQWMsWUFBWTtBQUMxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGlDQUFtQjs7QUFFaEU7QUFDQSxpQ0FBbUI7QUFDbkIsK0JBQStCLGlDQUFtQixnREFBZ0Qsb0JBQW9CO0FBQ3RILCtCQUErQixpQ0FBbUIscURBQXFELHNCQUFzQjtBQUM3SCw2R0FBNkcsaUNBQW1CO0FBQ2hJLG9FQUFvRSxpQ0FBbUI7QUFDdkYsdUVBQXVFLGlDQUFtQjtBQUMxRixnRUFBZ0UsaUNBQW1CO0FBQ25GLGdFQUFnRSxpQ0FBbUI7QUFDbkYsc0VBQXNFLGlDQUFtQjtBQUN6RixzRUFBc0UsaUNBQW1CO0FBQ3pGLG9GQUFvRixpQ0FBbUI7OztBQUd2RyxzQkFBc0IsZ0RBQWdELGdCQUFnQixzQkFBc0IsT0FBTywyQkFBMkIsMEJBQTBCLHlEQUF5RCxpQ0FBaUMsa0JBQWtCOzs7Ozs7Ozs7QUFTcFIsMkNBQTJDOztBQUUzQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7O0FBR1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsOEVBQThFOztBQUU5RTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1COztBQUVuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qjs7QUFFOUI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQ0FBb0M7QUFDcEM7O0FBRUEsb0NBQW9DO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsdUNBQXVDO0FBQzNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQiwwQkFBMEI7QUFDOUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsaUNBQW1COztBQUVoRTtBQUNBLGlDQUFtQjtBQUNuQiwrQkFBK0IsaUNBQW1CLG9EQUFvRCxxQkFBcUI7QUFDM0gsK0JBQStCLGlDQUFtQiw4REFBOEQsK0JBQStCO0FBQy9JO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStEO0FBQy9EOztBQUVBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxpQ0FBbUI7O0FBRWhFO0FBQ0EsaUNBQW1CO0FBQ25CLG1FQUFtRSxpQ0FBbUI7QUFDdEYsdUVBQXVFLGlDQUFtQjtBQUMxRix5RUFBeUUsaUNBQW1COzs7O0FBSTVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQiwrQkFBK0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0Isc0JBQXNCO0FBQzlDO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7O0FBR1Ysc0NBQXNDOztBQUV0QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0Esb0hBQW9IOztBQUVwSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxpQ0FBbUI7O0FBRWhFO0FBQ0EsaUNBQW1CO0FBQ25CLCtCQUErQixpQ0FBbUIsNERBQTRELDZCQUE2QjtBQUMzSSwrQkFBK0IsaUNBQW1CLHFFQUFxRSxzQ0FBc0M7QUFDN0osK0JBQStCLGlDQUFtQix1RUFBdUUsd0NBQXdDO0FBQ2pLLCtCQUErQixpQ0FBbUIsMkRBQTJELDRCQUE0QjtBQUN6SSwrQkFBK0IsaUNBQW1CLG9EQUFvRCxxQkFBcUI7QUFDM0gsK0JBQStCLGlDQUFtQixpREFBaUQsa0JBQWtCO0FBQ3JILCtCQUErQixpQ0FBbUIsZ0VBQWdFLGlDQUFpQztBQUNuSiwrQkFBK0IsaUNBQW1CLGdFQUFnRSxpQ0FBaUM7QUFDbkosNkdBQTZHLGlDQUFtQjtBQUNoSSxnRUFBZ0UsaUNBQW1CO0FBQ25GLGlGQUFpRixpQ0FBbUI7Ozs7O0FBS3BHO0FBQ0E7O0FBRUEsMENBQTBDLFNBQVM7QUFDbkQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsMENBQTBDLFNBQVM7QUFDbkQ7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOzs7QUFHQSwwREFBMEQ7O0FBRTFELHFEQUFxRDs7QUFFckQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3REFBd0Q7O0FBRXhELGdEQUFnRDtBQUNoRDs7QUFFQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsaUNBQW1COztBQUVoRTtBQUNBLGlDQUFtQjtBQUNuQixvRUFBb0UsaUNBQW1CO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQ0FBZ0M7O0FBRWhDLHVDQUF1Qzs7QUFFdkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsaUNBQW1COztBQUVoRTtBQUNBLGlDQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qjs7QUFFOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEOztBQUVBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxpQ0FBbUI7O0FBRWhFO0FBQ0EsaUNBQW1CO0FBQ25CLCtCQUErQixpQ0FBbUIsdURBQXVELHdCQUF3QjtBQUNqSSw2R0FBNkcsaUNBQW1CO0FBQ2hJLDJFQUEyRSxpQ0FBbUI7QUFDOUYsMkVBQTJFLGlDQUFtQjs7OztBQUk5RixnREFBZ0QsMERBQTBELDJDQUEyQzs7QUFFckosbUNBQW1DLGdFQUFnRSxzREFBc0QsK0RBQStELG1DQUFtQyw2RUFBNkUscUNBQXFDLGlEQUFpRCw4QkFBOEIscUJBQXFCLDBFQUEwRSxxREFBcUQsZUFBZSx5RUFBeUUsR0FBRywyQ0FBMkM7O0FBRXR0QiwyQ0FBMkMsbUNBQW1DLGtDQUFrQyxPQUFPLHdEQUF3RCxnQkFBZ0IsdUJBQXVCLGtEQUFrRCxrQ0FBa0MsdURBQXVELHNCQUFzQjs7QUFFdlgsdUNBQXVDLHdFQUF3RSwwQ0FBMEMsOENBQThDLE1BQU0sNEVBQTRFLElBQUksZUFBZSxZQUFZOztBQUV4VCxpQ0FBaUM7O0FBRWpDLGlDQUFpQyw0RUFBNEUsaUJBQWlCLGFBQWE7O0FBRTNJLDhCQUE4QixnR0FBZ0csbURBQW1EOztBQUVqTCxzQkFBc0IsZ0RBQWdELGdCQUFnQixzQkFBc0IsT0FBTywyQkFBMkIsMEJBQTBCLHlEQUF5RCxpQ0FBaUMsa0JBQWtCOzs7O0FBSXBSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLEdBQUc7O0FBRW5DO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0EsUUFBUTs7O0FBR1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsaUNBQW1COztBQUVoRTtBQUNBLGlDQUFtQjtBQUNuQiwrQkFBK0IsaUNBQW1CLG9EQUFvRCxxQkFBcUI7QUFDM0gsK0JBQStCLGlDQUFtQixtREFBbUQsb0JBQW9CO0FBQ3pILG1FQUFtRSxpQ0FBbUI7QUFDdEYsbUVBQW1FLGlDQUFtQjtBQUN0RixnRUFBZ0UsaUNBQW1CO0FBQ25GLG1FQUFtRSxpQ0FBbUI7QUFDdEYsOEVBQThFLGlDQUFtQjtBQUNqRyx1RUFBdUUsaUNBQW1CO0FBQzFGLHNCQUFzQixnREFBZ0QsZ0JBQWdCLHNCQUFzQixPQUFPLDJCQUEyQiwwQkFBMEIseURBQXlELGlDQUFpQyxrQkFBa0I7Ozs7Ozs7O0FBUXBSLG9DQUFvQzs7QUFFcEMsdUJBQXVCLEdBQUcsTUFBTSxFQUFFLE1BQU0sRUFBRSxNQUFNLEVBQUUsY0FBYzs7QUFFaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLElBQUk7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUU7QUFDakU7O0FBRUE7QUFDQSxtQkFBbUI7O0FBRW5CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUcsSUFBSTtBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRyxJQUFJO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGlDQUFtQjs7QUFFaEU7QUFDQSxpQ0FBbUI7QUFDbkIsK0JBQStCLGlDQUFtQixtREFBbUQsb0JBQW9CO0FBQ3pILCtCQUErQixpQ0FBbUIsK0NBQStDLGdCQUFnQjtBQUNqSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw4RkFBOEYsYUFBYTtBQUMzRztBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5Qzs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGlDQUFtQjs7QUFFaEU7QUFDQSxpQ0FBbUI7QUFDbkIsK0JBQStCLGlDQUFtQixtREFBbUQsb0JBQW9CO0FBQ3pILCtCQUErQixpQ0FBbUIsb0VBQW9FLHFDQUFxQztBQUMzSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGdDQUFnQzs7QUFFakM7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxDQUFDOzs7O0FBSUQsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGlDQUFtQjs7QUFFaEU7QUFDQSxpQ0FBbUI7QUFDbkIsK0JBQStCLGlDQUFtQix1REFBdUQsd0JBQXdCO0FBQ2pJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsaUNBQW1COztBQUVoRTtBQUNBLGlDQUFtQjtBQUNuQiwrQkFBK0IsaUNBQW1CLGdEQUFnRCxpQkFBaUI7QUFDbkgsK0JBQStCLGlDQUFtQixtREFBbUQsb0JBQW9CO0FBQ3pILCtCQUErQixpQ0FBbUIsbURBQW1ELG9CQUFvQjtBQUN6SCwrQkFBK0IsaUNBQW1CLG9EQUFvRCxxQkFBcUI7QUFDM0gsK0JBQStCLGlDQUFtQixnREFBZ0QsaUJBQWlCO0FBQ25ILCtCQUErQixpQ0FBbUIsMERBQTBELDJCQUEyQjtBQUN2SSwrQkFBK0IsaUNBQW1CLHlEQUF5RCwwQkFBMEI7QUFDckksK0JBQStCLGlDQUFtQixvREFBb0QscUJBQXFCO0FBQzNILCtCQUErQixpQ0FBbUIsb0RBQW9ELHFCQUFxQjtBQUMzSCwrQkFBK0IsaUNBQW1CLHNFQUFzRSx1Q0FBdUM7QUFDL0osK0JBQStCLGlDQUFtQix1REFBdUQsd0JBQXdCO0FBQ2pJLCtCQUErQixpQ0FBbUIsMERBQTBELDJCQUEyQjtBQUN2SSwrQkFBK0IsaUNBQW1CLHlEQUF5RCwwQkFBMEI7QUFDckkscUVBQXFFLGlDQUFtQjtBQUN4Rix5RUFBeUUsaUNBQW1COzs7QUFHNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsUUFBUTtBQUM5QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7O0FBRTlDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOEJBQThCOztBQUU5QjtBQUNBO0FBQ0EsY0FBYztBQUNkOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixxQkFBcUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsZ0NBQWdDO0FBQ2hDOztBQUVBLHlCQUF5Qjs7QUFFekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsWUFBWTtBQUNuQyxZQUFZLFVBQVU7QUFDdEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUZBQXFGO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFVBQVU7QUFDOUIsZ0JBQWdCLFlBQVk7QUFDNUIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7O0FBR1YsNkNBQTZDOztBQUU3Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0Isa0JBQWtCO0FBQ3BDLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7O0FBRUEsMkNBQTJDOztBQUUzQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7O0FBRUEsb0JBQW9CLGtCQUFrQjtBQUN0Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2IsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQSxtQ0FBbUM7QUFDbkM7O0FBRUEsa0JBQWtCOztBQUVsQjtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFROzs7QUFHUiwrQ0FBK0M7O0FBRS9DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBLHNDQUFzQyxzQkFBc0I7O0FBRTVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxpQ0FBbUI7O0FBRWhFO0FBQ0EsaUNBQW1CO0FBQ25CLCtCQUErQixpQ0FBbUIsZ0RBQWdELHNCQUFzQjtBQUN4SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7Ozs7QUFJRCxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsaUNBQW1COztBQUVoRTtBQUNBLGlDQUFtQjtBQUNuQiwrQkFBK0IsaUNBQW1CLDBEQUEwRCwyQkFBMkI7QUFDdkksK0JBQStCLGlDQUFtQixzREFBc0QsdUJBQXVCO0FBQy9ILCtCQUErQixpQ0FBbUIseURBQXlELDBCQUEwQjtBQUNySSwrQkFBK0IsaUNBQW1CLDBEQUEwRCwyQkFBMkI7QUFDdkksK0JBQStCLGlDQUFtQix1REFBdUQsd0JBQXdCO0FBQ2pJLGdFQUFnRSxpQ0FBbUI7O0FBRW5GO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0NBQW9DLElBQUk7QUFDeEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFEQUFxRCxTQUFTO0FBQzlEOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsaUNBQW1COztBQUVoRTtBQUNBLGlDQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxpQ0FBbUI7O0FBRWhFO0FBQ0EsaUNBQW1CO0FBQ25CLCtCQUErQixpQ0FBbUIsNERBQTRELDZCQUE2QjtBQUMzSSwrQkFBK0IsaUNBQW1CLDZEQUE2RCw4QkFBOEI7QUFDN0ksK0JBQStCLGlDQUFtQiw0REFBNEQsNkJBQTZCO0FBQzNJLCtCQUErQixpQ0FBbUIsbUVBQW1FLG9DQUFvQztBQUN6SjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw0Q0FBNEM7O0FBRTVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxpQ0FBbUI7O0FBRWhFO0FBQ0EsaUNBQW1CO0FBQ25CLCtCQUErQixpQ0FBbUIsbURBQW1ELG9CQUFvQjtBQUN6SDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxpQ0FBbUI7O0FBRWhFO0FBQ0EsaUNBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBLE1BQU07OztBQUdOLHVDQUF1Qzs7QUFFdkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJGQUEyRixhQUFhO0FBQ3hHO0FBQ0E7O0FBRUE7O0FBRUEsV0FBVyxzQkFBc0I7QUFDakM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxJQUFJOztBQUVULGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsbURBQW1EOztBQUVuRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQSxDQUFDOztBQUVELE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxpQ0FBbUI7O0FBRWhFO0FBQ0EsaUNBQW1CO0FBQ25CLCtCQUErQixpQ0FBbUIsdURBQXVELHdCQUF3QjtBQUNqSSwrQkFBK0IsaUNBQW1CLHNEQUFzRCx1QkFBdUI7QUFDL0gsK0JBQStCLGlDQUFtQixrREFBa0QsbUJBQW1CO0FBQ3ZILGdFQUFnRSxpQ0FBbUI7QUFDbkY7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDLElBQUk7OztBQUdMO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVDQUF1QyxFQUFFLE1BQU0sRUFBRTs7QUFFakQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBLGdCQUFnQixJQUFJO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLENBQUMsSUFBSTtBQUNMOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhFQUE4RTtBQUM5RTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQXNCOztBQUV0QjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOENBQThDLFFBQVE7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLGNBQWM7O0FBRW5CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQSxzQ0FBc0M7O0FBRXRDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHdDQUF3Qzs7QUFFeEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07OztBQUdOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQ0FBa0M7QUFDbEM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYzs7O0FBR2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUNBQWlDOztBQUVqQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCO0FBQ3hCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVE7QUFDUjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVELE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxpQ0FBbUI7O0FBRWhFO0FBQ0EsaUNBQW1CO0FBQ25CLCtCQUErQixpQ0FBbUIsc0RBQXNELHVCQUF1QjtBQUMvSCwrQkFBK0IsaUNBQW1CLG9EQUFvRCxxQkFBcUI7QUFDM0gsNkdBQTZHLGlDQUFtQjtBQUNoSSxtRUFBbUUsaUNBQW1CO0FBQ3RGLG1FQUFtRSxpQ0FBbUI7QUFDdEYsOEVBQThFLGlDQUFtQjtBQUNqRywyRUFBMkUsaUNBQW1COzs7Ozs7Ozs7QUFTOUYscUNBQXFDOztBQUVyQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsMkVBQTJFO0FBQzNFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBLHFDQUFxQzs7QUFFckMsNEVBQTRFOztBQUU1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOLGdDQUFnQzs7QUFFaEMsNkRBQTZEOztBQUU3RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7O0FBRTdCO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7OztBQUdWO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxpQ0FBbUI7O0FBRWhFO0FBQ0EsaUNBQW1CO0FBQ25CLHNFQUFzRSxpQ0FBbUI7QUFDekYsMkVBQTJFLGlDQUFtQjs7O0FBRzlGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZDQUE2Qzs7QUFFN0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEJBQThCOztBQUU5QjtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7O0FBRWpDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsWUFBWTtBQUNaO0FBQ0EsOEpBQThKOztBQUU5SjtBQUNBLGdDQUFnQzs7QUFFaEM7QUFDQSxnR0FBZ0c7O0FBRWhHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxPQUFPOztBQUVQLFVBQVU7QUFDVixDQUFDO0FBQ0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2hscy5qcy9kaXN0L2hscy5qcz9mN2M1Il0sInNvdXJjZXNDb250ZW50IjpbInR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiZcbihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcIkhsc1wiXSA9IGZhY3RvcnkoKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJIbHNcIl0gPSBmYWN0b3J5KCk7XG59KSh0aGlzLCBmdW5jdGlvbigpIHtcbnJldHVybiAvKioqKioqLyAoZnVuY3Rpb24obW9kdWxlcykgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbi8qKioqKiovIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdGk6IG1vZHVsZUlkLFxuLyoqKioqKi8gXHRcdFx0bDogZmFsc2UsXG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fVxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4vKioqKioqLyBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuLyoqKioqKi9cbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuLyoqKioqKi8gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbi8qKioqKiovIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZ2V0dGVyIH0pO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuLyoqKioqKi8gXHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuLyoqKioqKi8gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBjcmVhdGUgYSBmYWtlIG5hbWVzcGFjZSBvYmplY3Rcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XG4vKioqKioqLyBcdC8vIG1vZGUgJiAyOiBtZXJnZSBhbGwgcHJvcGVydGllcyBvZiB2YWx1ZSBpbnRvIHRoZSBuc1xuLyoqKioqKi8gXHQvLyBtb2RlICYgNDogcmV0dXJuIHZhbHVlIHdoZW4gYWxyZWFkeSBucyBvYmplY3Rcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnQgPSBmdW5jdGlvbih2YWx1ZSwgbW9kZSkge1xuLyoqKioqKi8gXHRcdGlmKG1vZGUgJiAxKSB2YWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18odmFsdWUpO1xuLyoqKioqKi8gXHRcdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XG4vKioqKioqLyBcdFx0aWYoKG1vZGUgJiA0KSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICYmIHZhbHVlLl9fZXNNb2R1bGUpIHJldHVybiB2YWx1ZTtcbi8qKioqKiovIFx0XHR2YXIgbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XG4vKioqKioqLyBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG5zLCAnZGVmYXVsdCcsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHZhbHVlIH0pO1xuLyoqKioqKi8gXHRcdGlmKG1vZGUgJiAyICYmIHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykgZm9yKHZhciBrZXkgaW4gdmFsdWUpIF9fd2VicGFja19yZXF1aXJlX18uZChucywga2V5LCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHZhbHVlW2tleV07IH0uYmluZChudWxsLCBrZXkpKTtcbi8qKioqKiovIFx0XHRyZXR1cm4gbnM7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbi8qKioqKiovIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbi8qKioqKiovIFx0XHRyZXR1cm4gZ2V0dGVyO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiL2Rpc3QvXCI7XG4vKioqKioqL1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IFwiLi9zcmMvaGxzLnRzXCIpO1xuLyoqKioqKi8gfSlcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyAoe1xuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2V2ZW50ZW1pdHRlcjMvaW5kZXguanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9ldmVudGVtaXR0ZXIzL2luZGV4LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHlcbiAgLCBwcmVmaXggPSAnfic7XG5cbi8qKlxuICogQ29uc3RydWN0b3IgdG8gY3JlYXRlIGEgc3RvcmFnZSBmb3Igb3VyIGBFRWAgb2JqZWN0cy5cbiAqIEFuIGBFdmVudHNgIGluc3RhbmNlIGlzIGEgcGxhaW4gb2JqZWN0IHdob3NlIHByb3BlcnRpZXMgYXJlIGV2ZW50IG5hbWVzLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gRXZlbnRzKCkge31cblxuLy9cbi8vIFdlIHRyeSB0byBub3QgaW5oZXJpdCBmcm9tIGBPYmplY3QucHJvdG90eXBlYC4gSW4gc29tZSBlbmdpbmVzIGNyZWF0aW5nIGFuXG4vLyBpbnN0YW5jZSBpbiB0aGlzIHdheSBpcyBmYXN0ZXIgdGhhbiBjYWxsaW5nIGBPYmplY3QuY3JlYXRlKG51bGwpYCBkaXJlY3RseS5cbi8vIElmIGBPYmplY3QuY3JlYXRlKG51bGwpYCBpcyBub3Qgc3VwcG9ydGVkIHdlIHByZWZpeCB0aGUgZXZlbnQgbmFtZXMgd2l0aCBhXG4vLyBjaGFyYWN0ZXIgdG8gbWFrZSBzdXJlIHRoYXQgdGhlIGJ1aWx0LWluIG9iamVjdCBwcm9wZXJ0aWVzIGFyZSBub3Rcbi8vIG92ZXJyaWRkZW4gb3IgdXNlZCBhcyBhbiBhdHRhY2sgdmVjdG9yLlxuLy9cbmlmIChPYmplY3QuY3JlYXRlKSB7XG4gIEV2ZW50cy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gIC8vXG4gIC8vIFRoaXMgaGFjayBpcyBuZWVkZWQgYmVjYXVzZSB0aGUgYF9fcHJvdG9fX2AgcHJvcGVydHkgaXMgc3RpbGwgaW5oZXJpdGVkIGluXG4gIC8vIHNvbWUgb2xkIGJyb3dzZXJzIGxpa2UgQW5kcm9pZCA0LCBpUGhvbmUgNS4xLCBPcGVyYSAxMSBhbmQgU2FmYXJpIDUuXG4gIC8vXG4gIGlmICghbmV3IEV2ZW50cygpLl9fcHJvdG9fXykgcHJlZml4ID0gZmFsc2U7XG59XG5cbi8qKlxuICogUmVwcmVzZW50YXRpb24gb2YgYSBzaW5nbGUgZXZlbnQgbGlzdGVuZXIuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBjb250ZXh0IFRoZSBjb250ZXh0IHRvIGludm9rZSB0aGUgbGlzdGVuZXIgd2l0aC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29uY2U9ZmFsc2VdIFNwZWNpZnkgaWYgdGhlIGxpc3RlbmVyIGlzIGEgb25lLXRpbWUgbGlzdGVuZXIuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIEVFKGZuLCBjb250ZXh0LCBvbmNlKSB7XG4gIHRoaXMuZm4gPSBmbjtcbiAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgdGhpcy5vbmNlID0gb25jZSB8fCBmYWxzZTtcbn1cblxuLyoqXG4gKiBBZGQgYSBsaXN0ZW5lciBmb3IgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50RW1pdHRlcn0gZW1pdHRlciBSZWZlcmVuY2UgdG8gdGhlIGBFdmVudEVtaXR0ZXJgIGluc3RhbmNlLlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBjb250ZXh0IFRoZSBjb250ZXh0IHRvIGludm9rZSB0aGUgbGlzdGVuZXIgd2l0aC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gb25jZSBTcGVjaWZ5IGlmIHRoZSBsaXN0ZW5lciBpcyBhIG9uZS10aW1lIGxpc3RlbmVyLlxuICogQHJldHVybnMge0V2ZW50RW1pdHRlcn1cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGFkZExpc3RlbmVyKGVtaXR0ZXIsIGV2ZW50LCBmbiwgY29udGV4dCwgb25jZSkge1xuICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIGxpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICB9XG5cbiAgdmFyIGxpc3RlbmVyID0gbmV3IEVFKGZuLCBjb250ZXh0IHx8IGVtaXR0ZXIsIG9uY2UpXG4gICAgLCBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50O1xuXG4gIGlmICghZW1pdHRlci5fZXZlbnRzW2V2dF0pIGVtaXR0ZXIuX2V2ZW50c1tldnRdID0gbGlzdGVuZXIsIGVtaXR0ZXIuX2V2ZW50c0NvdW50Kys7XG4gIGVsc2UgaWYgKCFlbWl0dGVyLl9ldmVudHNbZXZ0XS5mbikgZW1pdHRlci5fZXZlbnRzW2V2dF0ucHVzaChsaXN0ZW5lcik7XG4gIGVsc2UgZW1pdHRlci5fZXZlbnRzW2V2dF0gPSBbZW1pdHRlci5fZXZlbnRzW2V2dF0sIGxpc3RlbmVyXTtcblxuICByZXR1cm4gZW1pdHRlcjtcbn1cblxuLyoqXG4gKiBDbGVhciBldmVudCBieSBuYW1lLlxuICpcbiAqIEBwYXJhbSB7RXZlbnRFbWl0dGVyfSBlbWl0dGVyIFJlZmVyZW5jZSB0byB0aGUgYEV2ZW50RW1pdHRlcmAgaW5zdGFuY2UuXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZ0IFRoZSBFdmVudCBuYW1lLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY2xlYXJFdmVudChlbWl0dGVyLCBldnQpIHtcbiAgaWYgKC0tZW1pdHRlci5fZXZlbnRzQ291bnQgPT09IDApIGVtaXR0ZXIuX2V2ZW50cyA9IG5ldyBFdmVudHMoKTtcbiAgZWxzZSBkZWxldGUgZW1pdHRlci5fZXZlbnRzW2V2dF07XG59XG5cbi8qKlxuICogTWluaW1hbCBgRXZlbnRFbWl0dGVyYCBpbnRlcmZhY2UgdGhhdCBpcyBtb2xkZWQgYWdhaW5zdCB0aGUgTm9kZS5qc1xuICogYEV2ZW50RW1pdHRlcmAgaW50ZXJmYWNlLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIHRoaXMuX2V2ZW50cyA9IG5ldyBFdmVudHMoKTtcbiAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xufVxuXG4vKipcbiAqIFJldHVybiBhbiBhcnJheSBsaXN0aW5nIHRoZSBldmVudHMgZm9yIHdoaWNoIHRoZSBlbWl0dGVyIGhhcyByZWdpc3RlcmVkXG4gKiBsaXN0ZW5lcnMuXG4gKlxuICogQHJldHVybnMge0FycmF5fVxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmV2ZW50TmFtZXMgPSBmdW5jdGlvbiBldmVudE5hbWVzKCkge1xuICB2YXIgbmFtZXMgPSBbXVxuICAgICwgZXZlbnRzXG4gICAgLCBuYW1lO1xuXG4gIGlmICh0aGlzLl9ldmVudHNDb3VudCA9PT0gMCkgcmV0dXJuIG5hbWVzO1xuXG4gIGZvciAobmFtZSBpbiAoZXZlbnRzID0gdGhpcy5fZXZlbnRzKSkge1xuICAgIGlmIChoYXMuY2FsbChldmVudHMsIG5hbWUpKSBuYW1lcy5wdXNoKHByZWZpeCA/IG5hbWUuc2xpY2UoMSkgOiBuYW1lKTtcbiAgfVxuXG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgcmV0dXJuIG5hbWVzLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGV2ZW50cykpO1xuICB9XG5cbiAgcmV0dXJuIG5hbWVzO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIGxpc3RlbmVycyByZWdpc3RlcmVkIGZvciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEByZXR1cm5zIHtBcnJheX0gVGhlIHJlZ2lzdGVyZWQgbGlzdGVuZXJzLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uIGxpc3RlbmVycyhldmVudCkge1xuICB2YXIgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudFxuICAgICwgaGFuZGxlcnMgPSB0aGlzLl9ldmVudHNbZXZ0XTtcblxuICBpZiAoIWhhbmRsZXJzKSByZXR1cm4gW107XG4gIGlmIChoYW5kbGVycy5mbikgcmV0dXJuIFtoYW5kbGVycy5mbl07XG5cbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBoYW5kbGVycy5sZW5ndGgsIGVlID0gbmV3IEFycmF5KGwpOyBpIDwgbDsgaSsrKSB7XG4gICAgZWVbaV0gPSBoYW5kbGVyc1tpXS5mbjtcbiAgfVxuXG4gIHJldHVybiBlZTtcbn07XG5cbi8qKlxuICogUmV0dXJuIHRoZSBudW1iZXIgb2YgbGlzdGVuZXJzIGxpc3RlbmluZyB0byBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBudW1iZXIgb2YgbGlzdGVuZXJzLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbiBsaXN0ZW5lckNvdW50KGV2ZW50KSB7XG4gIHZhciBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50XG4gICAgLCBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbZXZ0XTtcblxuICBpZiAoIWxpc3RlbmVycykgcmV0dXJuIDA7XG4gIGlmIChsaXN0ZW5lcnMuZm4pIHJldHVybiAxO1xuICByZXR1cm4gbGlzdGVuZXJzLmxlbmd0aDtcbn07XG5cbi8qKlxuICogQ2FsbHMgZWFjaCBvZiB0aGUgbGlzdGVuZXJzIHJlZ2lzdGVyZWQgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHJldHVybnMge0Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgZXZlbnQgaGFkIGxpc3RlbmVycywgZWxzZSBgZmFsc2VgLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiBlbWl0KGV2ZW50LCBhMSwgYTIsIGEzLCBhNCwgYTUpIHtcbiAgdmFyIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnQ7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHNbZXZ0XSkgcmV0dXJuIGZhbHNlO1xuXG4gIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbZXZ0XVxuICAgICwgbGVuID0gYXJndW1lbnRzLmxlbmd0aFxuICAgICwgYXJnc1xuICAgICwgaTtcblxuICBpZiAobGlzdGVuZXJzLmZuKSB7XG4gICAgaWYgKGxpc3RlbmVycy5vbmNlKSB0aGlzLnJlbW92ZUxpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcnMuZm4sIHVuZGVmaW5lZCwgdHJ1ZSk7XG5cbiAgICBzd2l0Y2ggKGxlbikge1xuICAgICAgY2FzZSAxOiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQpLCB0cnVlO1xuICAgICAgY2FzZSAyOiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExKSwgdHJ1ZTtcbiAgICAgIGNhc2UgMzogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSwgYTIpLCB0cnVlO1xuICAgICAgY2FzZSA0OiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExLCBhMiwgYTMpLCB0cnVlO1xuICAgICAgY2FzZSA1OiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExLCBhMiwgYTMsIGE0KSwgdHJ1ZTtcbiAgICAgIGNhc2UgNjogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSwgYTIsIGEzLCBhNCwgYTUpLCB0cnVlO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDEsIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0xKTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICB9XG5cbiAgICBsaXN0ZW5lcnMuZm4uYXBwbHkobGlzdGVuZXJzLmNvbnRleHQsIGFyZ3MpO1xuICB9IGVsc2Uge1xuICAgIHZhciBsZW5ndGggPSBsaXN0ZW5lcnMubGVuZ3RoXG4gICAgICAsIGo7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChsaXN0ZW5lcnNbaV0ub25jZSkgdGhpcy5yZW1vdmVMaXN0ZW5lcihldmVudCwgbGlzdGVuZXJzW2ldLmZuLCB1bmRlZmluZWQsIHRydWUpO1xuXG4gICAgICBzd2l0Y2ggKGxlbikge1xuICAgICAgICBjYXNlIDE6IGxpc3RlbmVyc1tpXS5mbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0KTsgYnJlYWs7XG4gICAgICAgIGNhc2UgMjogbGlzdGVuZXJzW2ldLmZuLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQsIGExKTsgYnJlYWs7XG4gICAgICAgIGNhc2UgMzogbGlzdGVuZXJzW2ldLmZuLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQsIGExLCBhMik7IGJyZWFrO1xuICAgICAgICBjYXNlIDQ6IGxpc3RlbmVyc1tpXS5mbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0LCBhMSwgYTIsIGEzKTsgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaWYgKCFhcmdzKSBmb3IgKGogPSAxLCBhcmdzID0gbmV3IEFycmF5KGxlbiAtMSk7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgYXJnc1tqIC0gMV0gPSBhcmd1bWVudHNbal07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGlzdGVuZXJzW2ldLmZuLmFwcGx5KGxpc3RlbmVyc1tpXS5jb250ZXh0LCBhcmdzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogQWRkIGEgbGlzdGVuZXIgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBbY29udGV4dD10aGlzXSBUaGUgY29udGV4dCB0byBpbnZva2UgdGhlIGxpc3RlbmVyIHdpdGguXG4gKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSBgdGhpc2AuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBmdW5jdGlvbiBvbihldmVudCwgZm4sIGNvbnRleHQpIHtcbiAgcmV0dXJuIGFkZExpc3RlbmVyKHRoaXMsIGV2ZW50LCBmbiwgY29udGV4dCwgZmFsc2UpO1xufTtcblxuLyoqXG4gKiBBZGQgYSBvbmUtdGltZSBsaXN0ZW5lciBmb3IgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgbGlzdGVuZXIgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IFtjb250ZXh0PXRoaXNdIFRoZSBjb250ZXh0IHRvIGludm9rZSB0aGUgbGlzdGVuZXIgd2l0aC5cbiAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IGB0aGlzYC5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24gb25jZShldmVudCwgZm4sIGNvbnRleHQpIHtcbiAgcmV0dXJuIGFkZExpc3RlbmVyKHRoaXMsIGV2ZW50LCBmbiwgY29udGV4dCwgdHJ1ZSk7XG59O1xuXG4vKipcbiAqIFJlbW92ZSB0aGUgbGlzdGVuZXJzIG9mIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gT25seSByZW1vdmUgdGhlIGxpc3RlbmVycyB0aGF0IG1hdGNoIHRoaXMgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IGNvbnRleHQgT25seSByZW1vdmUgdGhlIGxpc3RlbmVycyB0aGF0IGhhdmUgdGhpcyBjb250ZXh0LlxuICogQHBhcmFtIHtCb29sZWFufSBvbmNlIE9ubHkgcmVtb3ZlIG9uZS10aW1lIGxpc3RlbmVycy5cbiAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IGB0aGlzYC5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKGV2ZW50LCBmbiwgY29udGV4dCwgb25jZSkge1xuICB2YXIgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudDtcblxuICBpZiAoIXRoaXMuX2V2ZW50c1tldnRdKSByZXR1cm4gdGhpcztcbiAgaWYgKCFmbikge1xuICAgIGNsZWFyRXZlbnQodGhpcywgZXZ0KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbZXZ0XTtcblxuICBpZiAobGlzdGVuZXJzLmZuKSB7XG4gICAgaWYgKFxuICAgICAgbGlzdGVuZXJzLmZuID09PSBmbiAmJlxuICAgICAgKCFvbmNlIHx8IGxpc3RlbmVycy5vbmNlKSAmJlxuICAgICAgKCFjb250ZXh0IHx8IGxpc3RlbmVycy5jb250ZXh0ID09PSBjb250ZXh0KVxuICAgICkge1xuICAgICAgY2xlYXJFdmVudCh0aGlzLCBldnQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3IgKHZhciBpID0gMCwgZXZlbnRzID0gW10sIGxlbmd0aCA9IGxpc3RlbmVycy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgaWYgKFxuICAgICAgICBsaXN0ZW5lcnNbaV0uZm4gIT09IGZuIHx8XG4gICAgICAgIChvbmNlICYmICFsaXN0ZW5lcnNbaV0ub25jZSkgfHxcbiAgICAgICAgKGNvbnRleHQgJiYgbGlzdGVuZXJzW2ldLmNvbnRleHQgIT09IGNvbnRleHQpXG4gICAgICApIHtcbiAgICAgICAgZXZlbnRzLnB1c2gobGlzdGVuZXJzW2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvL1xuICAgIC8vIFJlc2V0IHRoZSBhcnJheSwgb3IgcmVtb3ZlIGl0IGNvbXBsZXRlbHkgaWYgd2UgaGF2ZSBubyBtb3JlIGxpc3RlbmVycy5cbiAgICAvL1xuICAgIGlmIChldmVudHMubGVuZ3RoKSB0aGlzLl9ldmVudHNbZXZ0XSA9IGV2ZW50cy5sZW5ndGggPT09IDEgPyBldmVudHNbMF0gOiBldmVudHM7XG4gICAgZWxzZSBjbGVhckV2ZW50KHRoaXMsIGV2dCk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVtb3ZlIGFsbCBsaXN0ZW5lcnMsIG9yIHRob3NlIG9mIHRoZSBzcGVjaWZpZWQgZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IFtldmVudF0gVGhlIGV2ZW50IG5hbWUuXG4gKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSBgdGhpc2AuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24gcmVtb3ZlQWxsTGlzdGVuZXJzKGV2ZW50KSB7XG4gIHZhciBldnQ7XG5cbiAgaWYgKGV2ZW50KSB7XG4gICAgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudDtcbiAgICBpZiAodGhpcy5fZXZlbnRzW2V2dF0pIGNsZWFyRXZlbnQodGhpcywgZXZ0KTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9ldmVudHMgPSBuZXcgRXZlbnRzKCk7XG4gICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vL1xuLy8gQWxpYXMgbWV0aG9kcyBuYW1lcyBiZWNhdXNlIHBlb3BsZSByb2xsIGxpa2UgdGhhdC5cbi8vXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9mZiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXI7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbjtcblxuLy9cbi8vIEV4cG9zZSB0aGUgcHJlZml4LlxuLy9cbkV2ZW50RW1pdHRlci5wcmVmaXhlZCA9IHByZWZpeDtcblxuLy9cbi8vIEFsbG93IGBFdmVudEVtaXR0ZXJgIHRvIGJlIGltcG9ydGVkIGFzIG1vZHVsZSBuYW1lc3BhY2UuXG4vL1xuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxuLy9cbi8vIEV4cG9zZSB0aGUgbW9kdWxlLlxuLy9cbmlmICh0cnVlKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xufVxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3VybC10b29sa2l0L3NyYy91cmwtdG9vbGtpdC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvdXJsLXRvb2xraXQvc3JjL3VybC10b29sa2l0LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyBzZWUgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzE4MDhcblxuKGZ1bmN0aW9uIChyb290KSB7XG4gIHZhciBVUkxfUkVHRVggPVxuICAgIC9eKCg/OlthLXpBLVowLTkrXFwtLl0rOik/KShcXC9cXC9bXlxcLz8jXSopPygoPzpbXlxcLz8jXSpcXC8pKlteOz8jXSopPyg7W14/I10qKT8oXFw/W14jXSopPygjW15dKik/JC87XG4gIHZhciBGSVJTVF9TRUdNRU5UX1JFR0VYID0gL14oW15cXC8/I10qKShbXl0qKSQvO1xuICB2YXIgU0xBU0hfRE9UX1JFR0VYID0gLyg/OlxcL3xeKVxcLig/PVxcLykvZztcbiAgdmFyIFNMQVNIX0RPVF9ET1RfUkVHRVggPSAvKD86XFwvfF4pXFwuXFwuXFwvKD8hXFwuXFwuXFwvKVteXFwvXSooPz1cXC8pL2c7XG5cbiAgdmFyIFVSTFRvb2xraXQgPSB7XG4gICAgLy8gSWYgb3B0cy5hbHdheXNOb3JtYWxpemUgaXMgdHJ1ZSB0aGVuIHRoZSBwYXRoIHdpbGwgYWx3YXlzIGJlIG5vcm1hbGl6ZWQgZXZlbiB3aGVuIGl0IHN0YXJ0cyB3aXRoIC8gb3IgLy9cbiAgICAvLyBFLmdcbiAgICAvLyBXaXRoIG9wdHMuYWx3YXlzTm9ybWFsaXplID0gZmFsc2UgKGRlZmF1bHQsIHNwZWMgY29tcGxpYW50KVxuICAgIC8vIGh0dHA6Ly9hLmNvbS9iL2NkICsgL2UvZi8uLi9nID0+IGh0dHA6Ly9hLmNvbS9lL2YvLi4vZ1xuICAgIC8vIFdpdGggb3B0cy5hbHdheXNOb3JtYWxpemUgPSB0cnVlIChub3Qgc3BlYyBjb21wbGlhbnQpXG4gICAgLy8gaHR0cDovL2EuY29tL2IvY2QgKyAvZS9mLy4uL2cgPT4gaHR0cDovL2EuY29tL2UvZ1xuICAgIGJ1aWxkQWJzb2x1dGVVUkw6IGZ1bmN0aW9uIChiYXNlVVJMLCByZWxhdGl2ZVVSTCwgb3B0cykge1xuICAgICAgb3B0cyA9IG9wdHMgfHwge307XG4gICAgICAvLyByZW1vdmUgYW55IHJlbWFpbmluZyBzcGFjZSBhbmQgQ1JMRlxuICAgICAgYmFzZVVSTCA9IGJhc2VVUkwudHJpbSgpO1xuICAgICAgcmVsYXRpdmVVUkwgPSByZWxhdGl2ZVVSTC50cmltKCk7XG4gICAgICBpZiAoIXJlbGF0aXZlVVJMKSB7XG4gICAgICAgIC8vIDJhKSBJZiB0aGUgZW1iZWRkZWQgVVJMIGlzIGVudGlyZWx5IGVtcHR5LCBpdCBpbmhlcml0cyB0aGVcbiAgICAgICAgLy8gZW50aXJlIGJhc2UgVVJMIChpLmUuLCBpcyBzZXQgZXF1YWwgdG8gdGhlIGJhc2UgVVJMKVxuICAgICAgICAvLyBhbmQgd2UgYXJlIGRvbmUuXG4gICAgICAgIGlmICghb3B0cy5hbHdheXNOb3JtYWxpemUpIHtcbiAgICAgICAgICByZXR1cm4gYmFzZVVSTDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYmFzZVBhcnRzRm9yTm9ybWFsaXNlID0gVVJMVG9vbGtpdC5wYXJzZVVSTChiYXNlVVJMKTtcbiAgICAgICAgaWYgKCFiYXNlUGFydHNGb3JOb3JtYWxpc2UpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Vycm9yIHRyeWluZyB0byBwYXJzZSBiYXNlIFVSTC4nKTtcbiAgICAgICAgfVxuICAgICAgICBiYXNlUGFydHNGb3JOb3JtYWxpc2UucGF0aCA9IFVSTFRvb2xraXQubm9ybWFsaXplUGF0aChcbiAgICAgICAgICBiYXNlUGFydHNGb3JOb3JtYWxpc2UucGF0aFxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gVVJMVG9vbGtpdC5idWlsZFVSTEZyb21QYXJ0cyhiYXNlUGFydHNGb3JOb3JtYWxpc2UpO1xuICAgICAgfVxuICAgICAgdmFyIHJlbGF0aXZlUGFydHMgPSBVUkxUb29sa2l0LnBhcnNlVVJMKHJlbGF0aXZlVVJMKTtcbiAgICAgIGlmICghcmVsYXRpdmVQYXJ0cykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Vycm9yIHRyeWluZyB0byBwYXJzZSByZWxhdGl2ZSBVUkwuJyk7XG4gICAgICB9XG4gICAgICBpZiAocmVsYXRpdmVQYXJ0cy5zY2hlbWUpIHtcbiAgICAgICAgLy8gMmIpIElmIHRoZSBlbWJlZGRlZCBVUkwgc3RhcnRzIHdpdGggYSBzY2hlbWUgbmFtZSwgaXQgaXNcbiAgICAgICAgLy8gaW50ZXJwcmV0ZWQgYXMgYW4gYWJzb2x1dGUgVVJMIGFuZCB3ZSBhcmUgZG9uZS5cbiAgICAgICAgaWYgKCFvcHRzLmFsd2F5c05vcm1hbGl6ZSkge1xuICAgICAgICAgIHJldHVybiByZWxhdGl2ZVVSTDtcbiAgICAgICAgfVxuICAgICAgICByZWxhdGl2ZVBhcnRzLnBhdGggPSBVUkxUb29sa2l0Lm5vcm1hbGl6ZVBhdGgocmVsYXRpdmVQYXJ0cy5wYXRoKTtcbiAgICAgICAgcmV0dXJuIFVSTFRvb2xraXQuYnVpbGRVUkxGcm9tUGFydHMocmVsYXRpdmVQYXJ0cyk7XG4gICAgICB9XG4gICAgICB2YXIgYmFzZVBhcnRzID0gVVJMVG9vbGtpdC5wYXJzZVVSTChiYXNlVVJMKTtcbiAgICAgIGlmICghYmFzZVBhcnRzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXJyb3IgdHJ5aW5nIHRvIHBhcnNlIGJhc2UgVVJMLicpO1xuICAgICAgfVxuICAgICAgaWYgKCFiYXNlUGFydHMubmV0TG9jICYmIGJhc2VQYXJ0cy5wYXRoICYmIGJhc2VQYXJ0cy5wYXRoWzBdICE9PSAnLycpIHtcbiAgICAgICAgLy8gSWYgbmV0TG9jIG1pc3NpbmcgYW5kIHBhdGggZG9lc24ndCBzdGFydCB3aXRoICcvJywgYXNzdW1lIGV2ZXJ0aGluZyBiZWZvcmUgdGhlIGZpcnN0ICcvJyBpcyB0aGUgbmV0TG9jXG4gICAgICAgIC8vIFRoaXMgY2F1c2VzICdleGFtcGxlLmNvbS9hJyB0byBiZSBoYW5kbGVkIGFzICcvL2V4YW1wbGUuY29tL2EnIGluc3RlYWQgb2YgJy9leGFtcGxlLmNvbS9hJ1xuICAgICAgICB2YXIgcGF0aFBhcnRzID0gRklSU1RfU0VHTUVOVF9SRUdFWC5leGVjKGJhc2VQYXJ0cy5wYXRoKTtcbiAgICAgICAgYmFzZVBhcnRzLm5ldExvYyA9IHBhdGhQYXJ0c1sxXTtcbiAgICAgICAgYmFzZVBhcnRzLnBhdGggPSBwYXRoUGFydHNbMl07XG4gICAgICB9XG4gICAgICBpZiAoYmFzZVBhcnRzLm5ldExvYyAmJiAhYmFzZVBhcnRzLnBhdGgpIHtcbiAgICAgICAgYmFzZVBhcnRzLnBhdGggPSAnLyc7XG4gICAgICB9XG4gICAgICB2YXIgYnVpbHRQYXJ0cyA9IHtcbiAgICAgICAgLy8gMmMpIE90aGVyd2lzZSwgdGhlIGVtYmVkZGVkIFVSTCBpbmhlcml0cyB0aGUgc2NoZW1lIG9mXG4gICAgICAgIC8vIHRoZSBiYXNlIFVSTC5cbiAgICAgICAgc2NoZW1lOiBiYXNlUGFydHMuc2NoZW1lLFxuICAgICAgICBuZXRMb2M6IHJlbGF0aXZlUGFydHMubmV0TG9jLFxuICAgICAgICBwYXRoOiBudWxsLFxuICAgICAgICBwYXJhbXM6IHJlbGF0aXZlUGFydHMucGFyYW1zLFxuICAgICAgICBxdWVyeTogcmVsYXRpdmVQYXJ0cy5xdWVyeSxcbiAgICAgICAgZnJhZ21lbnQ6IHJlbGF0aXZlUGFydHMuZnJhZ21lbnQsXG4gICAgICB9O1xuICAgICAgaWYgKCFyZWxhdGl2ZVBhcnRzLm5ldExvYykge1xuICAgICAgICAvLyAzKSBJZiB0aGUgZW1iZWRkZWQgVVJMJ3MgPG5ldF9sb2M+IGlzIG5vbi1lbXB0eSwgd2Ugc2tpcCB0b1xuICAgICAgICAvLyBTdGVwIDcuICBPdGhlcndpc2UsIHRoZSBlbWJlZGRlZCBVUkwgaW5oZXJpdHMgdGhlIDxuZXRfbG9jPlxuICAgICAgICAvLyAoaWYgYW55KSBvZiB0aGUgYmFzZSBVUkwuXG4gICAgICAgIGJ1aWx0UGFydHMubmV0TG9jID0gYmFzZVBhcnRzLm5ldExvYztcbiAgICAgICAgLy8gNCkgSWYgdGhlIGVtYmVkZGVkIFVSTCBwYXRoIGlzIHByZWNlZGVkIGJ5IGEgc2xhc2ggXCIvXCIsIHRoZVxuICAgICAgICAvLyBwYXRoIGlzIG5vdCByZWxhdGl2ZSBhbmQgd2Ugc2tpcCB0byBTdGVwIDcuXG4gICAgICAgIGlmIChyZWxhdGl2ZVBhcnRzLnBhdGhbMF0gIT09ICcvJykge1xuICAgICAgICAgIGlmICghcmVsYXRpdmVQYXJ0cy5wYXRoKSB7XG4gICAgICAgICAgICAvLyA1KSBJZiB0aGUgZW1iZWRkZWQgVVJMIHBhdGggaXMgZW1wdHkgKGFuZCBub3QgcHJlY2VkZWQgYnkgYVxuICAgICAgICAgICAgLy8gc2xhc2gpLCB0aGVuIHRoZSBlbWJlZGRlZCBVUkwgaW5oZXJpdHMgdGhlIGJhc2UgVVJMIHBhdGhcbiAgICAgICAgICAgIGJ1aWx0UGFydHMucGF0aCA9IGJhc2VQYXJ0cy5wYXRoO1xuICAgICAgICAgICAgLy8gNWEpIGlmIHRoZSBlbWJlZGRlZCBVUkwncyA8cGFyYW1zPiBpcyBub24tZW1wdHksIHdlIHNraXAgdG9cbiAgICAgICAgICAgIC8vIHN0ZXAgNzsgb3RoZXJ3aXNlLCBpdCBpbmhlcml0cyB0aGUgPHBhcmFtcz4gb2YgdGhlIGJhc2VcbiAgICAgICAgICAgIC8vIFVSTCAoaWYgYW55KSBhbmRcbiAgICAgICAgICAgIGlmICghcmVsYXRpdmVQYXJ0cy5wYXJhbXMpIHtcbiAgICAgICAgICAgICAgYnVpbHRQYXJ0cy5wYXJhbXMgPSBiYXNlUGFydHMucGFyYW1zO1xuICAgICAgICAgICAgICAvLyA1YikgaWYgdGhlIGVtYmVkZGVkIFVSTCdzIDxxdWVyeT4gaXMgbm9uLWVtcHR5LCB3ZSBza2lwIHRvXG4gICAgICAgICAgICAgIC8vIHN0ZXAgNzsgb3RoZXJ3aXNlLCBpdCBpbmhlcml0cyB0aGUgPHF1ZXJ5PiBvZiB0aGUgYmFzZVxuICAgICAgICAgICAgICAvLyBVUkwgKGlmIGFueSkgYW5kIHdlIHNraXAgdG8gc3RlcCA3LlxuICAgICAgICAgICAgICBpZiAoIXJlbGF0aXZlUGFydHMucXVlcnkpIHtcbiAgICAgICAgICAgICAgICBidWlsdFBhcnRzLnF1ZXJ5ID0gYmFzZVBhcnRzLnF1ZXJ5O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIDYpIFRoZSBsYXN0IHNlZ21lbnQgb2YgdGhlIGJhc2UgVVJMJ3MgcGF0aCAoYW55dGhpbmdcbiAgICAgICAgICAgIC8vIGZvbGxvd2luZyB0aGUgcmlnaHRtb3N0IHNsYXNoIFwiL1wiLCBvciB0aGUgZW50aXJlIHBhdGggaWYgbm9cbiAgICAgICAgICAgIC8vIHNsYXNoIGlzIHByZXNlbnQpIGlzIHJlbW92ZWQgYW5kIHRoZSBlbWJlZGRlZCBVUkwncyBwYXRoIGlzXG4gICAgICAgICAgICAvLyBhcHBlbmRlZCBpbiBpdHMgcGxhY2UuXG4gICAgICAgICAgICB2YXIgYmFzZVVSTFBhdGggPSBiYXNlUGFydHMucGF0aDtcbiAgICAgICAgICAgIHZhciBuZXdQYXRoID1cbiAgICAgICAgICAgICAgYmFzZVVSTFBhdGguc3Vic3RyaW5nKDAsIGJhc2VVUkxQYXRoLmxhc3RJbmRleE9mKCcvJykgKyAxKSArXG4gICAgICAgICAgICAgIHJlbGF0aXZlUGFydHMucGF0aDtcbiAgICAgICAgICAgIGJ1aWx0UGFydHMucGF0aCA9IFVSTFRvb2xraXQubm9ybWFsaXplUGF0aChuZXdQYXRoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChidWlsdFBhcnRzLnBhdGggPT09IG51bGwpIHtcbiAgICAgICAgYnVpbHRQYXJ0cy5wYXRoID0gb3B0cy5hbHdheXNOb3JtYWxpemVcbiAgICAgICAgICA/IFVSTFRvb2xraXQubm9ybWFsaXplUGF0aChyZWxhdGl2ZVBhcnRzLnBhdGgpXG4gICAgICAgICAgOiByZWxhdGl2ZVBhcnRzLnBhdGg7XG4gICAgICB9XG4gICAgICByZXR1cm4gVVJMVG9vbGtpdC5idWlsZFVSTEZyb21QYXJ0cyhidWlsdFBhcnRzKTtcbiAgICB9LFxuICAgIHBhcnNlVVJMOiBmdW5jdGlvbiAodXJsKSB7XG4gICAgICB2YXIgcGFydHMgPSBVUkxfUkVHRVguZXhlYyh1cmwpO1xuICAgICAgaWYgKCFwYXJ0cykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNjaGVtZTogcGFydHNbMV0gfHwgJycsXG4gICAgICAgIG5ldExvYzogcGFydHNbMl0gfHwgJycsXG4gICAgICAgIHBhdGg6IHBhcnRzWzNdIHx8ICcnLFxuICAgICAgICBwYXJhbXM6IHBhcnRzWzRdIHx8ICcnLFxuICAgICAgICBxdWVyeTogcGFydHNbNV0gfHwgJycsXG4gICAgICAgIGZyYWdtZW50OiBwYXJ0c1s2XSB8fCAnJyxcbiAgICAgIH07XG4gICAgfSxcbiAgICBub3JtYWxpemVQYXRoOiBmdW5jdGlvbiAocGF0aCkge1xuICAgICAgLy8gVGhlIGZvbGxvd2luZyBvcGVyYXRpb25zIGFyZVxuICAgICAgLy8gdGhlbiBhcHBsaWVkLCBpbiBvcmRlciwgdG8gdGhlIG5ldyBwYXRoOlxuICAgICAgLy8gNmEpIEFsbCBvY2N1cnJlbmNlcyBvZiBcIi4vXCIsIHdoZXJlIFwiLlwiIGlzIGEgY29tcGxldGUgcGF0aFxuICAgICAgLy8gc2VnbWVudCwgYXJlIHJlbW92ZWQuXG4gICAgICAvLyA2YikgSWYgdGhlIHBhdGggZW5kcyB3aXRoIFwiLlwiIGFzIGEgY29tcGxldGUgcGF0aCBzZWdtZW50LFxuICAgICAgLy8gdGhhdCBcIi5cIiBpcyByZW1vdmVkLlxuICAgICAgcGF0aCA9IHBhdGguc3BsaXQoJycpLnJldmVyc2UoKS5qb2luKCcnKS5yZXBsYWNlKFNMQVNIX0RPVF9SRUdFWCwgJycpO1xuICAgICAgLy8gNmMpIEFsbCBvY2N1cnJlbmNlcyBvZiBcIjxzZWdtZW50Pi8uLi9cIiwgd2hlcmUgPHNlZ21lbnQ+IGlzIGFcbiAgICAgIC8vIGNvbXBsZXRlIHBhdGggc2VnbWVudCBub3QgZXF1YWwgdG8gXCIuLlwiLCBhcmUgcmVtb3ZlZC5cbiAgICAgIC8vIFJlbW92YWwgb2YgdGhlc2UgcGF0aCBzZWdtZW50cyBpcyBwZXJmb3JtZWQgaXRlcmF0aXZlbHksXG4gICAgICAvLyByZW1vdmluZyB0aGUgbGVmdG1vc3QgbWF0Y2hpbmcgcGF0dGVybiBvbiBlYWNoIGl0ZXJhdGlvbixcbiAgICAgIC8vIHVudGlsIG5vIG1hdGNoaW5nIHBhdHRlcm4gcmVtYWlucy5cbiAgICAgIC8vIDZkKSBJZiB0aGUgcGF0aCBlbmRzIHdpdGggXCI8c2VnbWVudD4vLi5cIiwgd2hlcmUgPHNlZ21lbnQ+IGlzIGFcbiAgICAgIC8vIGNvbXBsZXRlIHBhdGggc2VnbWVudCBub3QgZXF1YWwgdG8gXCIuLlwiLCB0aGF0XG4gICAgICAvLyBcIjxzZWdtZW50Pi8uLlwiIGlzIHJlbW92ZWQuXG4gICAgICB3aGlsZSAoXG4gICAgICAgIHBhdGgubGVuZ3RoICE9PSAocGF0aCA9IHBhdGgucmVwbGFjZShTTEFTSF9ET1RfRE9UX1JFR0VYLCAnJykpLmxlbmd0aFxuICAgICAgKSB7fVxuICAgICAgcmV0dXJuIHBhdGguc3BsaXQoJycpLnJldmVyc2UoKS5qb2luKCcnKTtcbiAgICB9LFxuICAgIGJ1aWxkVVJMRnJvbVBhcnRzOiBmdW5jdGlvbiAocGFydHMpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIHBhcnRzLnNjaGVtZSArXG4gICAgICAgIHBhcnRzLm5ldExvYyArXG4gICAgICAgIHBhcnRzLnBhdGggK1xuICAgICAgICBwYXJ0cy5wYXJhbXMgK1xuICAgICAgICBwYXJ0cy5xdWVyeSArXG4gICAgICAgIHBhcnRzLmZyYWdtZW50XG4gICAgICApO1xuICAgIH0sXG4gIH07XG5cbiAgaWYgKHRydWUpXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBVUkxUb29sa2l0O1xuICBlbHNlIHt9XG59KSh0aGlzKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy93ZWJ3b3JraWZ5LXdlYnBhY2svaW5kZXguanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3dlYndvcmtpZnktd2VicGFjay9pbmRleC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuZnVuY3Rpb24gd2VicGFja0Jvb3RzdHJhcEZ1bmMgKG1vZHVsZXMpIHtcbi8qKioqKiovICAvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyAgdmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuLyoqKioqKi8gIC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyAgZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4vKioqKioqLyAgICAvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovICAgIGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxuLyoqKioqKi8gICAgICByZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcblxuLyoqKioqKi8gICAgLy8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovICAgIHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbi8qKioqKiovICAgICAgaTogbW9kdWxlSWQsXG4vKioqKioqLyAgICAgIGw6IGZhbHNlLFxuLyoqKioqKi8gICAgICBleHBvcnRzOiB7fVxuLyoqKioqKi8gICAgfTtcblxuLyoqKioqKi8gICAgLy8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyAgICBtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuLyoqKioqKi8gICAgLy8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuLyoqKioqKi8gICAgbW9kdWxlLmwgPSB0cnVlO1xuXG4vKioqKioqLyAgICAvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gICAgcmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gIH1cblxuLyoqKioqKi8gIC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4vKioqKioqLyAgX193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuLyoqKioqKi8gIC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyAgX193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuLyoqKioqKi8gIC8vIGlkZW50aXR5IGZ1bmN0aW9uIGZvciBjYWxsaW5nIGhhcm1vbnkgaW1wb3J0cyB3aXRoIHRoZSBjb3JyZWN0IGNvbnRleHRcbi8qKioqKiovICBfX3dlYnBhY2tfcmVxdWlyZV9fLmkgPSBmdW5jdGlvbih2YWx1ZSkgeyByZXR1cm4gdmFsdWU7IH07XG5cbi8qKioqKiovICAvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbi8qKioqKiovICBfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbi8qKioqKiovICAgIGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbi8qKioqKiovICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbi8qKioqKiovICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuLyoqKioqKi8gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4vKioqKioqLyAgICAgICAgZ2V0OiBnZXR0ZXJcbi8qKioqKiovICAgICAgfSk7XG4vKioqKioqLyAgICB9XG4vKioqKioqLyAgfTtcblxuLyoqKioqKi8gIC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbi8qKioqKiovICBfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4vKioqKioqLyAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqKioqKi8gIH07XG5cbi8qKioqKiovICAvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuLyoqKioqKi8gIF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuLyoqKioqKi8gICAgdmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4vKioqKioqLyAgICAgIGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4vKioqKioqLyAgICAgIGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4vKioqKioqLyAgICBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4vKioqKioqLyAgICByZXR1cm4gZ2V0dGVyO1xuLyoqKioqKi8gIH07XG5cbi8qKioqKiovICAvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbi8qKioqKiovICBfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbi8qKioqKiovICAvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuLyoqKioqKi8gIF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiL1wiO1xuXG4vKioqKioqLyAgLy8gb24gZXJyb3IgZnVuY3Rpb24gZm9yIGFzeW5jIGxvYWRpbmdcbi8qKioqKiovICBfX3dlYnBhY2tfcmVxdWlyZV9fLm9lID0gZnVuY3Rpb24oZXJyKSB7IGNvbnNvbGUuZXJyb3IoZXJyKTsgdGhyb3cgZXJyOyB9O1xuXG4gIHZhciBmID0gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSBFTlRSWV9NT0RVTEUpXG4gIHJldHVybiBmLmRlZmF1bHQgfHwgZiAvLyB0cnkgdG8gY2FsbCBkZWZhdWx0IGlmIGRlZmluZWQgdG8gYWxzbyBzdXBwb3J0IGJhYmVsIGVzbW9kdWxlIGV4cG9ydHNcbn1cblxudmFyIG1vZHVsZU5hbWVSZXFFeHAgPSAnW1xcXFwufFxcXFwtfFxcXFwrfFxcXFx3fFxcL3xAXSsnXG52YXIgZGVwZW5kZW5jeVJlZ0V4cCA9ICdcXFxcKFxcXFxzKihcXC9cXFxcKi4qP1xcXFwqXFwvKT9cXFxccyouKj8oJyArIG1vZHVsZU5hbWVSZXFFeHAgKyAnKS4qP1xcXFwpJyAvLyBhZGRpdGlvbmFsIGNoYXJzIHdoZW4gb3V0cHV0LnBhdGhpbmZvIGlzIHRydWVcblxuLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjU5MzY2MS8xMzA0NDJcbmZ1bmN0aW9uIHF1b3RlUmVnRXhwIChzdHIpIHtcbiAgcmV0dXJuIChzdHIgKyAnJykucmVwbGFjZSgvWy4/KiteJFtcXF1cXFxcKCl7fXwtXS9nLCAnXFxcXCQmJylcbn1cblxuZnVuY3Rpb24gaXNOdW1lcmljKG4pIHtcbiAgcmV0dXJuICFpc05hTigxICogbik7IC8vIDEgKiBuIGNvbnZlcnRzIGludGVnZXJzLCBpbnRlZ2VycyBhcyBzdHJpbmcgKFwiMTIzXCIpLCAxZTMgYW5kIFwiMWUzXCIgdG8gaW50ZWdlcnMgYW5kIHN0cmluZ3MgdG8gTmFOXG59XG5cbmZ1bmN0aW9uIGdldE1vZHVsZURlcGVuZGVuY2llcyAoc291cmNlcywgbW9kdWxlLCBxdWV1ZU5hbWUpIHtcbiAgdmFyIHJldHZhbCA9IHt9XG4gIHJldHZhbFtxdWV1ZU5hbWVdID0gW11cblxuICB2YXIgZm5TdHJpbmcgPSBtb2R1bGUudG9TdHJpbmcoKVxuICB2YXIgd3JhcHBlclNpZ25hdHVyZSA9IGZuU3RyaW5nLm1hdGNoKC9eZnVuY3Rpb25cXHM/XFx3KlxcKFxcdyssXFxzKlxcdyssXFxzKihcXHcrKVxcKS8pXG4gIGlmICghd3JhcHBlclNpZ25hdHVyZSkgcmV0dXJuIHJldHZhbFxuICB2YXIgd2VicGFja1JlcXVpcmVOYW1lID0gd3JhcHBlclNpZ25hdHVyZVsxXVxuXG4gIC8vIG1haW4gYnVuZGxlIGRlcHNcbiAgdmFyIHJlID0gbmV3IFJlZ0V4cCgnKFxcXFxcXFxcbnxcXFxcVyknICsgcXVvdGVSZWdFeHAod2VicGFja1JlcXVpcmVOYW1lKSArIGRlcGVuZGVuY3lSZWdFeHAsICdnJylcbiAgdmFyIG1hdGNoXG4gIHdoaWxlICgobWF0Y2ggPSByZS5leGVjKGZuU3RyaW5nKSkpIHtcbiAgICBpZiAobWF0Y2hbM10gPT09ICdkbGwtcmVmZXJlbmNlJykgY29udGludWVcbiAgICByZXR2YWxbcXVldWVOYW1lXS5wdXNoKG1hdGNoWzNdKVxuICB9XG5cbiAgLy8gZGxsIGRlcHNcbiAgcmUgPSBuZXcgUmVnRXhwKCdcXFxcKCcgKyBxdW90ZVJlZ0V4cCh3ZWJwYWNrUmVxdWlyZU5hbWUpICsgJ1xcXFwoXCIoZGxsLXJlZmVyZW5jZVxcXFxzKCcgKyBtb2R1bGVOYW1lUmVxRXhwICsgJykpXCJcXFxcKVxcXFwpJyArIGRlcGVuZGVuY3lSZWdFeHAsICdnJylcbiAgd2hpbGUgKChtYXRjaCA9IHJlLmV4ZWMoZm5TdHJpbmcpKSkge1xuICAgIGlmICghc291cmNlc1ttYXRjaFsyXV0pIHtcbiAgICAgIHJldHZhbFtxdWV1ZU5hbWVdLnB1c2gobWF0Y2hbMV0pXG4gICAgICBzb3VyY2VzW21hdGNoWzJdXSA9IF9fd2VicGFja19yZXF1aXJlX18obWF0Y2hbMV0pLm1cbiAgICB9XG4gICAgcmV0dmFsW21hdGNoWzJdXSA9IHJldHZhbFttYXRjaFsyXV0gfHwgW11cbiAgICByZXR2YWxbbWF0Y2hbMl1dLnB1c2gobWF0Y2hbNF0pXG4gIH1cblxuICAvLyBjb252ZXJ0IDFlMyBiYWNrIHRvIDEwMDAgLSB0aGlzIGNhbiBiZSBpbXBvcnRhbnQgYWZ0ZXIgdWdsaWZ5LWpzIGNvbnZlcnRlZCAxMDAwIHRvIDFlM1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHJldHZhbCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgcmV0dmFsW2tleXNbaV1dLmxlbmd0aDsgaisrKSB7XG4gICAgICBpZiAoaXNOdW1lcmljKHJldHZhbFtrZXlzW2ldXVtqXSkpIHtcbiAgICAgICAgcmV0dmFsW2tleXNbaV1dW2pdID0gMSAqIHJldHZhbFtrZXlzW2ldXVtqXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmV0dmFsXG59XG5cbmZ1bmN0aW9uIGhhc1ZhbHVlc0luUXVldWVzIChxdWV1ZXMpIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhxdWV1ZXMpXG4gIHJldHVybiBrZXlzLnJlZHVjZShmdW5jdGlvbiAoaGFzVmFsdWVzLCBrZXkpIHtcbiAgICByZXR1cm4gaGFzVmFsdWVzIHx8IHF1ZXVlc1trZXldLmxlbmd0aCA+IDBcbiAgfSwgZmFsc2UpXG59XG5cbmZ1bmN0aW9uIGdldFJlcXVpcmVkTW9kdWxlcyAoc291cmNlcywgbW9kdWxlSWQpIHtcbiAgdmFyIG1vZHVsZXNRdWV1ZSA9IHtcbiAgICBtYWluOiBbbW9kdWxlSWRdXG4gIH1cbiAgdmFyIHJlcXVpcmVkTW9kdWxlcyA9IHtcbiAgICBtYWluOiBbXVxuICB9XG4gIHZhciBzZWVuTW9kdWxlcyA9IHtcbiAgICBtYWluOiB7fVxuICB9XG5cbiAgd2hpbGUgKGhhc1ZhbHVlc0luUXVldWVzKG1vZHVsZXNRdWV1ZSkpIHtcbiAgICB2YXIgcXVldWVzID0gT2JqZWN0LmtleXMobW9kdWxlc1F1ZXVlKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcXVldWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcXVldWVOYW1lID0gcXVldWVzW2ldXG4gICAgICB2YXIgcXVldWUgPSBtb2R1bGVzUXVldWVbcXVldWVOYW1lXVxuICAgICAgdmFyIG1vZHVsZVRvQ2hlY2sgPSBxdWV1ZS5wb3AoKVxuICAgICAgc2Vlbk1vZHVsZXNbcXVldWVOYW1lXSA9IHNlZW5Nb2R1bGVzW3F1ZXVlTmFtZV0gfHwge31cbiAgICAgIGlmIChzZWVuTW9kdWxlc1txdWV1ZU5hbWVdW21vZHVsZVRvQ2hlY2tdIHx8ICFzb3VyY2VzW3F1ZXVlTmFtZV1bbW9kdWxlVG9DaGVja10pIGNvbnRpbnVlXG4gICAgICBzZWVuTW9kdWxlc1txdWV1ZU5hbWVdW21vZHVsZVRvQ2hlY2tdID0gdHJ1ZVxuICAgICAgcmVxdWlyZWRNb2R1bGVzW3F1ZXVlTmFtZV0gPSByZXF1aXJlZE1vZHVsZXNbcXVldWVOYW1lXSB8fCBbXVxuICAgICAgcmVxdWlyZWRNb2R1bGVzW3F1ZXVlTmFtZV0ucHVzaChtb2R1bGVUb0NoZWNrKVxuICAgICAgdmFyIG5ld01vZHVsZXMgPSBnZXRNb2R1bGVEZXBlbmRlbmNpZXMoc291cmNlcywgc291cmNlc1txdWV1ZU5hbWVdW21vZHVsZVRvQ2hlY2tdLCBxdWV1ZU5hbWUpXG4gICAgICB2YXIgbmV3TW9kdWxlc0tleXMgPSBPYmplY3Qua2V5cyhuZXdNb2R1bGVzKVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBuZXdNb2R1bGVzS2V5cy5sZW5ndGg7IGorKykge1xuICAgICAgICBtb2R1bGVzUXVldWVbbmV3TW9kdWxlc0tleXNbal1dID0gbW9kdWxlc1F1ZXVlW25ld01vZHVsZXNLZXlzW2pdXSB8fCBbXVxuICAgICAgICBtb2R1bGVzUXVldWVbbmV3TW9kdWxlc0tleXNbal1dID0gbW9kdWxlc1F1ZXVlW25ld01vZHVsZXNLZXlzW2pdXS5jb25jYXQobmV3TW9kdWxlc1tuZXdNb2R1bGVzS2V5c1tqXV0pXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlcXVpcmVkTW9kdWxlc1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChtb2R1bGVJZCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuICB2YXIgc291cmNlcyA9IHtcbiAgICBtYWluOiBfX3dlYnBhY2tfcmVxdWlyZV9fLm1cbiAgfVxuXG4gIHZhciByZXF1aXJlZE1vZHVsZXMgPSBvcHRpb25zLmFsbCA/IHsgbWFpbjogT2JqZWN0LmtleXMoc291cmNlcy5tYWluKSB9IDogZ2V0UmVxdWlyZWRNb2R1bGVzKHNvdXJjZXMsIG1vZHVsZUlkKVxuXG4gIHZhciBzcmMgPSAnJ1xuXG4gIE9iamVjdC5rZXlzKHJlcXVpcmVkTW9kdWxlcykuZmlsdGVyKGZ1bmN0aW9uIChtKSB7IHJldHVybiBtICE9PSAnbWFpbicgfSkuZm9yRWFjaChmdW5jdGlvbiAobW9kdWxlKSB7XG4gICAgdmFyIGVudHJ5TW9kdWxlID0gMFxuICAgIHdoaWxlIChyZXF1aXJlZE1vZHVsZXNbbW9kdWxlXVtlbnRyeU1vZHVsZV0pIHtcbiAgICAgIGVudHJ5TW9kdWxlKytcbiAgICB9XG4gICAgcmVxdWlyZWRNb2R1bGVzW21vZHVsZV0ucHVzaChlbnRyeU1vZHVsZSlcbiAgICBzb3VyY2VzW21vZHVsZV1bZW50cnlNb2R1bGVdID0gJyhmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHsgbW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fOyB9KSdcbiAgICBzcmMgPSBzcmMgKyAndmFyICcgKyBtb2R1bGUgKyAnID0gKCcgKyB3ZWJwYWNrQm9vdHN0cmFwRnVuYy50b1N0cmluZygpLnJlcGxhY2UoJ0VOVFJZX01PRFVMRScsIEpTT04uc3RyaW5naWZ5KGVudHJ5TW9kdWxlKSkgKyAnKSh7JyArIHJlcXVpcmVkTW9kdWxlc1ttb2R1bGVdLm1hcChmdW5jdGlvbiAoaWQpIHsgcmV0dXJuICcnICsgSlNPTi5zdHJpbmdpZnkoaWQpICsgJzogJyArIHNvdXJjZXNbbW9kdWxlXVtpZF0udG9TdHJpbmcoKSB9KS5qb2luKCcsJykgKyAnfSk7XFxuJ1xuICB9KVxuXG4gIHNyYyA9IHNyYyArICduZXcgKCgnICsgd2VicGFja0Jvb3RzdHJhcEZ1bmMudG9TdHJpbmcoKS5yZXBsYWNlKCdFTlRSWV9NT0RVTEUnLCBKU09OLnN0cmluZ2lmeShtb2R1bGVJZCkpICsgJykoeycgKyByZXF1aXJlZE1vZHVsZXMubWFpbi5tYXAoZnVuY3Rpb24gKGlkKSB7IHJldHVybiAnJyArIEpTT04uc3RyaW5naWZ5KGlkKSArICc6ICcgKyBzb3VyY2VzLm1haW5baWRdLnRvU3RyaW5nKCkgfSkuam9pbignLCcpICsgJ30pKShzZWxmKTsnXG5cbiAgdmFyIGJsb2IgPSBuZXcgd2luZG93LkJsb2IoW3NyY10sIHsgdHlwZTogJ3RleHQvamF2YXNjcmlwdCcgfSlcbiAgaWYgKG9wdGlvbnMuYmFyZSkgeyByZXR1cm4gYmxvYiB9XG5cbiAgdmFyIFVSTCA9IHdpbmRvdy5VUkwgfHwgd2luZG93LndlYmtpdFVSTCB8fCB3aW5kb3cubW96VVJMIHx8IHdpbmRvdy5tc1VSTFxuXG4gIHZhciB3b3JrZXJVcmwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpXG4gIHZhciB3b3JrZXIgPSBuZXcgd2luZG93Lldvcmtlcih3b3JrZXJVcmwpXG4gIHdvcmtlci5vYmplY3RVUkwgPSB3b3JrZXJVcmxcblxuICByZXR1cm4gd29ya2VyXG59XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY29uZmlnLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9jb25maWcudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGhsc0RlZmF1bHRDb25maWcsIG1lcmdlQ29uZmlnLCBlbmFibGVTdHJlYW1pbmdNb2RlICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImhsc0RlZmF1bHRDb25maWdcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBobHNEZWZhdWx0Q29uZmlnOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJtZXJnZUNvbmZpZ1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIG1lcmdlQ29uZmlnOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJlbmFibGVTdHJlYW1pbmdNb2RlXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZW5hYmxlU3RyZWFtaW5nTW9kZTsgfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2NvbnRyb2xsZXJfYWJyX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vY29udHJvbGxlci9hYnItY29udHJvbGxlciAqLyBcIi4vc3JjL2NvbnRyb2xsZXIvYWJyLWNvbnRyb2xsZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2NvbnRyb2xsZXJfYXVkaW9fc3RyZWFtX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vY29udHJvbGxlci9hdWRpby1zdHJlYW0tY29udHJvbGxlciAqLyBcIi4vc3JjL2NvbnRyb2xsZXIvYXVkaW8tc3RyZWFtLWNvbnRyb2xsZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2NvbnRyb2xsZXJfYXVkaW9fdHJhY2tfY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9jb250cm9sbGVyL2F1ZGlvLXRyYWNrLWNvbnRyb2xsZXIgKi8gXCIuL3NyYy9jb250cm9sbGVyL2F1ZGlvLXRyYWNrLWNvbnRyb2xsZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2NvbnRyb2xsZXJfc3VidGl0bGVfc3RyZWFtX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vY29udHJvbGxlci9zdWJ0aXRsZS1zdHJlYW0tY29udHJvbGxlciAqLyBcIi4vc3JjL2NvbnRyb2xsZXIvc3VidGl0bGUtc3RyZWFtLWNvbnRyb2xsZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2NvbnRyb2xsZXJfc3VidGl0bGVfdHJhY2tfY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9jb250cm9sbGVyL3N1YnRpdGxlLXRyYWNrLWNvbnRyb2xsZXIgKi8gXCIuL3NyYy9jb250cm9sbGVyL3N1YnRpdGxlLXRyYWNrLWNvbnRyb2xsZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2NvbnRyb2xsZXJfYnVmZmVyX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vY29udHJvbGxlci9idWZmZXItY29udHJvbGxlciAqLyBcIi4vc3JjL2NvbnRyb2xsZXIvYnVmZmVyLWNvbnRyb2xsZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2NvbnRyb2xsZXJfdGltZWxpbmVfY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9jb250cm9sbGVyL3RpbWVsaW5lLWNvbnRyb2xsZXIgKi8gXCIuL3NyYy9jb250cm9sbGVyL3RpbWVsaW5lLWNvbnRyb2xsZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2NvbnRyb2xsZXJfY2FwX2xldmVsX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vY29udHJvbGxlci9jYXAtbGV2ZWwtY29udHJvbGxlciAqLyBcIi4vc3JjL2NvbnRyb2xsZXIvY2FwLWxldmVsLWNvbnRyb2xsZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2NvbnRyb2xsZXJfZnBzX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzhfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vY29udHJvbGxlci9mcHMtY29udHJvbGxlciAqLyBcIi4vc3JjL2NvbnRyb2xsZXIvZnBzLWNvbnRyb2xsZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2NvbnRyb2xsZXJfZW1lX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzlfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vY29udHJvbGxlci9lbWUtY29udHJvbGxlciAqLyBcIi4vc3JjL2NvbnRyb2xsZXIvZW1lLWNvbnRyb2xsZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2NvbnRyb2xsZXJfY21jZF9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9jb250cm9sbGVyL2NtY2QtY29udHJvbGxlciAqLyBcIi4vc3JjL2NvbnRyb2xsZXIvY21jZC1jb250cm9sbGVyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc194aHJfbG9hZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi91dGlscy94aHItbG9hZGVyICovIFwiLi9zcmMvdXRpbHMveGhyLWxvYWRlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfZmV0Y2hfbG9hZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi91dGlscy9mZXRjaC1sb2FkZXIgKi8gXCIuL3NyYy91dGlscy9mZXRjaC1sb2FkZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2N1ZXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEzX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3V0aWxzL2N1ZXMgKi8gXCIuL3NyYy91dGlscy9jdWVzLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19tZWRpYWtleXNfaGVscGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xNF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi91dGlscy9tZWRpYWtleXMtaGVscGVyICovIFwiLi9zcmMvdXRpbHMvbWVkaWFrZXlzLWhlbHBlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xNV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi91dGlscy9sb2dnZXIgKi8gXCIuL3NyYy91dGlscy9sb2dnZXIudHNcIik7XG5mdW5jdGlvbiBfZXh0ZW5kcygpIHsgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSB7IHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsgfSBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuLy8gSWYgcG9zc2libGUsIGtlZXAgaGxzRGVmYXVsdENvbmZpZyBzaGFsbG93XG4vLyBJdCBpcyBjbG9uZWQgd2hlbmV2ZXIgYSBuZXcgSGxzIGluc3RhbmNlIGlzIGNyZWF0ZWQsIGJ5IGtlZXBpbmcgdGhlIGNvbmZpZ1xuLy8gc2hhbGxvdyB0aGUgcHJvcGVydGllcyBhcmUgY2xvbmVkLCBhbmQgd2UgZG9uJ3QgZW5kIHVwIG1hbmlwdWxhdGluZyB0aGUgZGVmYXVsdFxudmFyIGhsc0RlZmF1bHRDb25maWcgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe1xuICBhdXRvU3RhcnRMb2FkOiB0cnVlLFxuICAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXG4gIHN0YXJ0UG9zaXRpb246IC0xLFxuICAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXG4gIGRlZmF1bHRBdWRpb0NvZGVjOiB1bmRlZmluZWQsXG4gIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcbiAgZGVidWc6IGZhbHNlLFxuICAvLyB1c2VkIGJ5IGxvZ2dlclxuICBjYXBMZXZlbE9uRlBTRHJvcDogZmFsc2UsXG4gIC8vIHVzZWQgYnkgZnBzLWNvbnRyb2xsZXJcbiAgY2FwTGV2ZWxUb1BsYXllclNpemU6IGZhbHNlLFxuICAvLyB1c2VkIGJ5IGNhcC1sZXZlbC1jb250cm9sbGVyXG4gIGluaXRpYWxMaXZlTWFuaWZlc3RTaXplOiAxLFxuICAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXG4gIG1heEJ1ZmZlckxlbmd0aDogMzAsXG4gIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcbiAgYmFja0J1ZmZlckxlbmd0aDogSW5maW5pdHksXG4gIC8vIHVzZWQgYnkgYnVmZmVyLWNvbnRyb2xsZXJcbiAgbWF4QnVmZmVyU2l6ZTogNjAgKiAxMDAwICogMTAwMCxcbiAgLy8gdXNlZCBieSBzdHJlYW0tY29udHJvbGxlclxuICBtYXhCdWZmZXJIb2xlOiAwLjEsXG4gIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcbiAgaGlnaEJ1ZmZlcldhdGNoZG9nUGVyaW9kOiAyLFxuICAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXG4gIG51ZGdlT2Zmc2V0OiAwLjEsXG4gIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcbiAgbnVkZ2VNYXhSZXRyeTogMyxcbiAgLy8gdXNlZCBieSBzdHJlYW0tY29udHJvbGxlclxuICBtYXhGcmFnTG9va1VwVG9sZXJhbmNlOiAwLjI1LFxuICAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXG4gIGxpdmVTeW5jRHVyYXRpb25Db3VudDogMyxcbiAgLy8gdXNlZCBieSBsYXRlbmN5LWNvbnRyb2xsZXJcbiAgbGl2ZU1heExhdGVuY3lEdXJhdGlvbkNvdW50OiBJbmZpbml0eSxcbiAgLy8gdXNlZCBieSBsYXRlbmN5LWNvbnRyb2xsZXJcbiAgbGl2ZVN5bmNEdXJhdGlvbjogdW5kZWZpbmVkLFxuICAvLyB1c2VkIGJ5IGxhdGVuY3ktY29udHJvbGxlclxuICBsaXZlTWF4TGF0ZW5jeUR1cmF0aW9uOiB1bmRlZmluZWQsXG4gIC8vIHVzZWQgYnkgbGF0ZW5jeS1jb250cm9sbGVyXG4gIG1heExpdmVTeW5jUGxheWJhY2tSYXRlOiAxLFxuICAvLyB1c2VkIGJ5IGxhdGVuY3ktY29udHJvbGxlclxuICBsaXZlRHVyYXRpb25JbmZpbml0eTogZmFsc2UsXG4gIC8vIHVzZWQgYnkgYnVmZmVyLWNvbnRyb2xsZXJcbiAgbGl2ZUJhY2tCdWZmZXJMZW5ndGg6IG51bGwsXG4gIC8vIHVzZWQgYnkgYnVmZmVyLWNvbnRyb2xsZXJcbiAgbWF4TWF4QnVmZmVyTGVuZ3RoOiA2MDAsXG4gIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcbiAgZW5hYmxlV29ya2VyOiB0cnVlLFxuICAvLyB1c2VkIGJ5IGRlbXV4ZXJcbiAgZW5hYmxlU29mdHdhcmVBRVM6IHRydWUsXG4gIC8vIHVzZWQgYnkgZGVjcnlwdGVyXG4gIG1hbmlmZXN0TG9hZGluZ1RpbWVPdXQ6IDEwMDAwLFxuICAvLyB1c2VkIGJ5IHBsYXlsaXN0LWxvYWRlclxuICBtYW5pZmVzdExvYWRpbmdNYXhSZXRyeTogMSxcbiAgLy8gdXNlZCBieSBwbGF5bGlzdC1sb2FkZXJcbiAgbWFuaWZlc3RMb2FkaW5nUmV0cnlEZWxheTogMTAwMCxcbiAgLy8gdXNlZCBieSBwbGF5bGlzdC1sb2FkZXJcbiAgbWFuaWZlc3RMb2FkaW5nTWF4UmV0cnlUaW1lb3V0OiA2NDAwMCxcbiAgLy8gdXNlZCBieSBwbGF5bGlzdC1sb2FkZXJcbiAgc3RhcnRMZXZlbDogdW5kZWZpbmVkLFxuICAvLyB1c2VkIGJ5IGxldmVsLWNvbnRyb2xsZXJcbiAgbGV2ZWxMb2FkaW5nVGltZU91dDogMTAwMDAsXG4gIC8vIHVzZWQgYnkgcGxheWxpc3QtbG9hZGVyXG4gIGxldmVsTG9hZGluZ01heFJldHJ5OiA0LFxuICAvLyB1c2VkIGJ5IHBsYXlsaXN0LWxvYWRlclxuICBsZXZlbExvYWRpbmdSZXRyeURlbGF5OiAxMDAwLFxuICAvLyB1c2VkIGJ5IHBsYXlsaXN0LWxvYWRlclxuICBsZXZlbExvYWRpbmdNYXhSZXRyeVRpbWVvdXQ6IDY0MDAwLFxuICAvLyB1c2VkIGJ5IHBsYXlsaXN0LWxvYWRlclxuICBmcmFnTG9hZGluZ1RpbWVPdXQ6IDIwMDAwLFxuICAvLyB1c2VkIGJ5IGZyYWdtZW50LWxvYWRlclxuICBmcmFnTG9hZGluZ01heFJldHJ5OiA2LFxuICAvLyB1c2VkIGJ5IGZyYWdtZW50LWxvYWRlclxuICBmcmFnTG9hZGluZ1JldHJ5RGVsYXk6IDEwMDAsXG4gIC8vIHVzZWQgYnkgZnJhZ21lbnQtbG9hZGVyXG4gIGZyYWdMb2FkaW5nTWF4UmV0cnlUaW1lb3V0OiA2NDAwMCxcbiAgLy8gdXNlZCBieSBmcmFnbWVudC1sb2FkZXJcbiAgc3RhcnRGcmFnUHJlZmV0Y2g6IGZhbHNlLFxuICAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXG4gIGZwc0Ryb3BwZWRNb25pdG9yaW5nUGVyaW9kOiA1MDAwLFxuICAvLyB1c2VkIGJ5IGZwcy1jb250cm9sbGVyXG4gIGZwc0Ryb3BwZWRNb25pdG9yaW5nVGhyZXNob2xkOiAwLjIsXG4gIC8vIHVzZWQgYnkgZnBzLWNvbnRyb2xsZXJcbiAgYXBwZW5kRXJyb3JNYXhSZXRyeTogMyxcbiAgLy8gdXNlZCBieSBidWZmZXItY29udHJvbGxlclxuICBsb2FkZXI6IF91dGlsc194aHJfbG9hZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMV9fW1wiZGVmYXVsdFwiXSxcbiAgLy8gbG9hZGVyOiBGZXRjaExvYWRlcixcbiAgZkxvYWRlcjogdW5kZWZpbmVkLFxuICAvLyB1c2VkIGJ5IGZyYWdtZW50LWxvYWRlclxuICBwTG9hZGVyOiB1bmRlZmluZWQsXG4gIC8vIHVzZWQgYnkgcGxheWxpc3QtbG9hZGVyXG4gIHhoclNldHVwOiB1bmRlZmluZWQsXG4gIC8vIHVzZWQgYnkgeGhyLWxvYWRlclxuICBsaWNlbnNlWGhyU2V0dXA6IHVuZGVmaW5lZCxcbiAgLy8gdXNlZCBieSBlbWUtY29udHJvbGxlclxuICBsaWNlbnNlUmVzcG9uc2VDYWxsYmFjazogdW5kZWZpbmVkLFxuICAvLyB1c2VkIGJ5IGVtZS1jb250cm9sbGVyXG4gIGFickNvbnRyb2xsZXI6IF9jb250cm9sbGVyX2Ficl9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJkZWZhdWx0XCJdLFxuICBidWZmZXJDb250cm9sbGVyOiBfY29udHJvbGxlcl9idWZmZXJfY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1wiZGVmYXVsdFwiXSxcbiAgY2FwTGV2ZWxDb250cm9sbGVyOiBfY29udHJvbGxlcl9jYXBfbGV2ZWxfY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fW1wiZGVmYXVsdFwiXSxcbiAgZnBzQ29udHJvbGxlcjogX2NvbnRyb2xsZXJfZnBzX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzhfX1tcImRlZmF1bHRcIl0sXG4gIHN0cmV0Y2hTaG9ydFZpZGVvVHJhY2s6IGZhbHNlLFxuICAvLyB1c2VkIGJ5IG1wNC1yZW11eGVyXG4gIG1heEF1ZGlvRnJhbWVzRHJpZnQ6IDEsXG4gIC8vIHVzZWQgYnkgbXA0LXJlbXV4ZXJcbiAgZm9yY2VLZXlGcmFtZU9uRGlzY29udGludWl0eTogdHJ1ZSxcbiAgLy8gdXNlZCBieSB0cy1kZW11eGVyXG4gIGFickV3bWFGYXN0TGl2ZTogMyxcbiAgLy8gdXNlZCBieSBhYnItY29udHJvbGxlclxuICBhYnJFd21hU2xvd0xpdmU6IDksXG4gIC8vIHVzZWQgYnkgYWJyLWNvbnRyb2xsZXJcbiAgYWJyRXdtYUZhc3RWb0Q6IDMsXG4gIC8vIHVzZWQgYnkgYWJyLWNvbnRyb2xsZXJcbiAgYWJyRXdtYVNsb3dWb0Q6IDksXG4gIC8vIHVzZWQgYnkgYWJyLWNvbnRyb2xsZXJcbiAgYWJyRXdtYURlZmF1bHRFc3RpbWF0ZTogNWU1LFxuICAvLyA1MDAga2JwcyAgLy8gdXNlZCBieSBhYnItY29udHJvbGxlclxuICBhYnJCYW5kV2lkdGhGYWN0b3I6IDAuOTUsXG4gIC8vIHVzZWQgYnkgYWJyLWNvbnRyb2xsZXJcbiAgYWJyQmFuZFdpZHRoVXBGYWN0b3I6IDAuNyxcbiAgLy8gdXNlZCBieSBhYnItY29udHJvbGxlclxuICBhYnJNYXhXaXRoUmVhbEJpdHJhdGU6IGZhbHNlLFxuICAvLyB1c2VkIGJ5IGFici1jb250cm9sbGVyXG4gIG1heFN0YXJ2YXRpb25EZWxheTogNCxcbiAgLy8gdXNlZCBieSBhYnItY29udHJvbGxlclxuICBtYXhMb2FkaW5nRGVsYXk6IDQsXG4gIC8vIHVzZWQgYnkgYWJyLWNvbnRyb2xsZXJcbiAgbWluQXV0b0JpdHJhdGU6IDAsXG4gIC8vIHVzZWQgYnkgaGxzXG4gIGVtZUVuYWJsZWQ6IGZhbHNlLFxuICAvLyB1c2VkIGJ5IGVtZS1jb250cm9sbGVyXG4gIHdpZGV2aW5lTGljZW5zZVVybDogdW5kZWZpbmVkLFxuICAvLyB1c2VkIGJ5IGVtZS1jb250cm9sbGVyXG4gIGRybVN5c3RlbU9wdGlvbnM6IHt9LFxuICAvLyB1c2VkIGJ5IGVtZS1jb250cm9sbGVyXG4gIHJlcXVlc3RNZWRpYUtleVN5c3RlbUFjY2Vzc0Z1bmM6IF91dGlsc19tZWRpYWtleXNfaGVscGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xNF9fW1wicmVxdWVzdE1lZGlhS2V5U3lzdGVtQWNjZXNzXCJdLFxuICAvLyB1c2VkIGJ5IGVtZS1jb250cm9sbGVyXG4gIHRlc3RCYW5kd2lkdGg6IHRydWUsXG4gIHByb2dyZXNzaXZlOiBmYWxzZSxcbiAgbG93TGF0ZW5jeU1vZGU6IHRydWUsXG4gIGNtY2Q6IHVuZGVmaW5lZFxufSwgdGltZWxpbmVDb25maWcoKSksIHt9LCB7XG4gIHN1YnRpdGxlU3RyZWFtQ29udHJvbGxlcjogIHRydWUgPyBfY29udHJvbGxlcl9zdWJ0aXRsZV9zdHJlYW1fY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiU3VidGl0bGVTdHJlYW1Db250cm9sbGVyXCJdIDogdW5kZWZpbmVkLFxuICBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlcjogIHRydWUgPyBfY29udHJvbGxlcl9zdWJ0aXRsZV90cmFja19jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXCJkZWZhdWx0XCJdIDogdW5kZWZpbmVkLFxuICB0aW1lbGluZUNvbnRyb2xsZXI6ICB0cnVlID8gX2NvbnRyb2xsZXJfdGltZWxpbmVfY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fW1wiVGltZWxpbmVDb250cm9sbGVyXCJdIDogdW5kZWZpbmVkLFxuICBhdWRpb1N0cmVhbUNvbnRyb2xsZXI6ICB0cnVlID8gX2NvbnRyb2xsZXJfYXVkaW9fc3RyZWFtX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImRlZmF1bHRcIl0gOiB1bmRlZmluZWQsXG4gIGF1ZGlvVHJhY2tDb250cm9sbGVyOiAgdHJ1ZSA/IF9jb250cm9sbGVyX2F1ZGlvX3RyYWNrX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImRlZmF1bHRcIl0gOiB1bmRlZmluZWQsXG4gIGVtZUNvbnRyb2xsZXI6ICB0cnVlID8gX2NvbnRyb2xsZXJfZW1lX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzlfX1tcImRlZmF1bHRcIl0gOiB1bmRlZmluZWQsXG4gIGNtY2RDb250cm9sbGVyOiAgdHJ1ZSA/IF9jb250cm9sbGVyX2NtY2RfY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTBfX1tcImRlZmF1bHRcIl0gOiB1bmRlZmluZWRcbn0pO1xuXG5mdW5jdGlvbiB0aW1lbGluZUNvbmZpZygpIHtcbiAgcmV0dXJuIHtcbiAgICBjdWVIYW5kbGVyOiBfdXRpbHNfY3Vlc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTNfX1tcImRlZmF1bHRcIl0sXG4gICAgLy8gdXNlZCBieSB0aW1lbGluZS1jb250cm9sbGVyXG4gICAgZW5hYmxlQ0VBNzA4Q2FwdGlvbnM6IHRydWUsXG4gICAgLy8gdXNlZCBieSB0aW1lbGluZS1jb250cm9sbGVyXG4gICAgZW5hYmxlV2ViVlRUOiB0cnVlLFxuICAgIC8vIHVzZWQgYnkgdGltZWxpbmUtY29udHJvbGxlclxuICAgIGVuYWJsZUlNU0MxOiB0cnVlLFxuICAgIC8vIHVzZWQgYnkgdGltZWxpbmUtY29udHJvbGxlclxuICAgIGNhcHRpb25zVGV4dFRyYWNrMUxhYmVsOiAnRW5nbGlzaCcsXG4gICAgLy8gdXNlZCBieSB0aW1lbGluZS1jb250cm9sbGVyXG4gICAgY2FwdGlvbnNUZXh0VHJhY2sxTGFuZ3VhZ2VDb2RlOiAnZW4nLFxuICAgIC8vIHVzZWQgYnkgdGltZWxpbmUtY29udHJvbGxlclxuICAgIGNhcHRpb25zVGV4dFRyYWNrMkxhYmVsOiAnU3BhbmlzaCcsXG4gICAgLy8gdXNlZCBieSB0aW1lbGluZS1jb250cm9sbGVyXG4gICAgY2FwdGlvbnNUZXh0VHJhY2syTGFuZ3VhZ2VDb2RlOiAnZXMnLFxuICAgIC8vIHVzZWQgYnkgdGltZWxpbmUtY29udHJvbGxlclxuICAgIGNhcHRpb25zVGV4dFRyYWNrM0xhYmVsOiAnVW5rbm93biBDQycsXG4gICAgLy8gdXNlZCBieSB0aW1lbGluZS1jb250cm9sbGVyXG4gICAgY2FwdGlvbnNUZXh0VHJhY2szTGFuZ3VhZ2VDb2RlOiAnJyxcbiAgICAvLyB1c2VkIGJ5IHRpbWVsaW5lLWNvbnRyb2xsZXJcbiAgICBjYXB0aW9uc1RleHRUcmFjazRMYWJlbDogJ1Vua25vd24gQ0MnLFxuICAgIC8vIHVzZWQgYnkgdGltZWxpbmUtY29udHJvbGxlclxuICAgIGNhcHRpb25zVGV4dFRyYWNrNExhbmd1YWdlQ29kZTogJycsXG4gICAgLy8gdXNlZCBieSB0aW1lbGluZS1jb250cm9sbGVyXG4gICAgcmVuZGVyVGV4dFRyYWNrc05hdGl2ZWx5OiB0cnVlXG4gIH07XG59XG5cbmZ1bmN0aW9uIG1lcmdlQ29uZmlnKGRlZmF1bHRDb25maWcsIHVzZXJDb25maWcpIHtcbiAgaWYgKCh1c2VyQ29uZmlnLmxpdmVTeW5jRHVyYXRpb25Db3VudCB8fCB1c2VyQ29uZmlnLmxpdmVNYXhMYXRlbmN5RHVyYXRpb25Db3VudCkgJiYgKHVzZXJDb25maWcubGl2ZVN5bmNEdXJhdGlvbiB8fCB1c2VyQ29uZmlnLmxpdmVNYXhMYXRlbmN5RHVyYXRpb24pKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSWxsZWdhbCBobHMuanMgY29uZmlnOiBkb24ndCBtaXggdXAgbGl2ZVN5bmNEdXJhdGlvbkNvdW50L2xpdmVNYXhMYXRlbmN5RHVyYXRpb25Db3VudCBhbmQgbGl2ZVN5bmNEdXJhdGlvbi9saXZlTWF4TGF0ZW5jeUR1cmF0aW9uXCIpO1xuICB9XG5cbiAgaWYgKHVzZXJDb25maWcubGl2ZU1heExhdGVuY3lEdXJhdGlvbkNvdW50ICE9PSB1bmRlZmluZWQgJiYgKHVzZXJDb25maWcubGl2ZVN5bmNEdXJhdGlvbkNvdW50ID09PSB1bmRlZmluZWQgfHwgdXNlckNvbmZpZy5saXZlTWF4TGF0ZW5jeUR1cmF0aW9uQ291bnQgPD0gdXNlckNvbmZpZy5saXZlU3luY0R1cmF0aW9uQ291bnQpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbGxlZ2FsIGhscy5qcyBjb25maWc6IFwibGl2ZU1heExhdGVuY3lEdXJhdGlvbkNvdW50XCIgbXVzdCBiZSBncmVhdGVyIHRoYW4gXCJsaXZlU3luY0R1cmF0aW9uQ291bnRcIicpO1xuICB9XG5cbiAgaWYgKHVzZXJDb25maWcubGl2ZU1heExhdGVuY3lEdXJhdGlvbiAhPT0gdW5kZWZpbmVkICYmICh1c2VyQ29uZmlnLmxpdmVTeW5jRHVyYXRpb24gPT09IHVuZGVmaW5lZCB8fCB1c2VyQ29uZmlnLmxpdmVNYXhMYXRlbmN5RHVyYXRpb24gPD0gdXNlckNvbmZpZy5saXZlU3luY0R1cmF0aW9uKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSWxsZWdhbCBobHMuanMgY29uZmlnOiBcImxpdmVNYXhMYXRlbmN5RHVyYXRpb25cIiBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBcImxpdmVTeW5jRHVyYXRpb25cIicpO1xuICB9XG5cbiAgcmV0dXJuIF9leHRlbmRzKHt9LCBkZWZhdWx0Q29uZmlnLCB1c2VyQ29uZmlnKTtcbn1cbmZ1bmN0aW9uIGVuYWJsZVN0cmVhbWluZ01vZGUoY29uZmlnKSB7XG4gIHZhciBjdXJyZW50TG9hZGVyID0gY29uZmlnLmxvYWRlcjtcblxuICBpZiAoY3VycmVudExvYWRlciAhPT0gX3V0aWxzX2ZldGNoX2xvYWRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTJfX1tcImRlZmF1bHRcIl0gJiYgY3VycmVudExvYWRlciAhPT0gX3V0aWxzX3hocl9sb2FkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzExX19bXCJkZWZhdWx0XCJdKSB7XG4gICAgLy8gSWYgYSBkZXZlbG9wZXIgaGFzIGNvbmZpZ3VyZWQgdGhlaXIgb3duIGxvYWRlciwgcmVzcGVjdCB0aGF0IGNob2ljZVxuICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzE1X19bXCJsb2dnZXJcIl0ubG9nKCdbY29uZmlnXTogQ3VzdG9tIGxvYWRlciBkZXRlY3RlZCwgY2Fubm90IGVuYWJsZSBwcm9ncmVzc2l2ZSBzdHJlYW1pbmcnKTtcbiAgICBjb25maWcucHJvZ3Jlc3NpdmUgPSBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgY2FuU3RyZWFtUHJvZ3Jlc3NpdmVseSA9IE9iamVjdChfdXRpbHNfZmV0Y2hfbG9hZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMl9fW1wiZmV0Y2hTdXBwb3J0ZWRcIl0pKCk7XG5cbiAgICBpZiAoY2FuU3RyZWFtUHJvZ3Jlc3NpdmVseSkge1xuICAgICAgY29uZmlnLmxvYWRlciA9IF91dGlsc19mZXRjaF9sb2FkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEyX19bXCJkZWZhdWx0XCJdO1xuICAgICAgY29uZmlnLnByb2dyZXNzaXZlID0gdHJ1ZTtcbiAgICAgIGNvbmZpZy5lbmFibGVTb2Z0d2FyZUFFUyA9IHRydWU7XG4gICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xNV9fW1wibG9nZ2VyXCJdLmxvZygnW2NvbmZpZ106IFByb2dyZXNzaXZlIHN0cmVhbWluZyBlbmFibGVkLCB1c2luZyBGZXRjaExvYWRlcicpO1xuICAgIH1cbiAgfVxufVxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9jb250cm9sbGVyL2Fici1jb250cm9sbGVyLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvY29udHJvbGxlci9hYnItY29udHJvbGxlci50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2hvbWVfcnVubmVyX3dvcmtfaGxzX2pzX2hsc19qc19zcmNfcG9seWZpbGxzX251bWJlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zcmMvcG9seWZpbGxzL251bWJlciAqLyBcIi4vc3JjL3BvbHlmaWxscy9udW1iZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2V3bWFfYmFuZHdpZHRoX2VzdGltYXRvcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvZXdtYS1iYW5kd2lkdGgtZXN0aW1hdG9yICovIFwiLi9zcmMvdXRpbHMvZXdtYS1iYW5kd2lkdGgtZXN0aW1hdG9yLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2V2ZW50cyAqLyBcIi4vc3JjL2V2ZW50cy50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfYnVmZmVyX2hlbHBlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvYnVmZmVyLWhlbHBlciAqLyBcIi4vc3JjL3V0aWxzL2J1ZmZlci1oZWxwZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZXJyb3JzICovIFwiLi9zcmMvZXJyb3JzLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF90eXBlc19sb2FkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3R5cGVzL2xvYWRlciAqLyBcIi4vc3JjL3R5cGVzL2xvYWRlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9sb2dnZXIgKi8gXCIuL3NyYy91dGlscy9sb2dnZXIudHNcIik7XG5cblxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cblxuXG5cblxuXG5cblxudmFyIEFickNvbnRyb2xsZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBBYnJDb250cm9sbGVyKGhscykge1xuICAgIHRoaXMuaGxzID0gdm9pZCAwO1xuICAgIHRoaXMubGFzdExvYWRlZEZyYWdMZXZlbCA9IDA7XG4gICAgdGhpcy5fbmV4dEF1dG9MZXZlbCA9IC0xO1xuICAgIHRoaXMudGltZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5vbkNoZWNrID0gdGhpcy5fYWJhbmRvblJ1bGVzQ2hlY2suYmluZCh0aGlzKTtcbiAgICB0aGlzLmZyYWdDdXJyZW50ID0gbnVsbDtcbiAgICB0aGlzLnBhcnRDdXJyZW50ID0gbnVsbDtcbiAgICB0aGlzLmJpdHJhdGVUZXN0RGVsYXkgPSAwO1xuICAgIHRoaXMuYndFc3RpbWF0b3IgPSB2b2lkIDA7XG4gICAgdGhpcy5obHMgPSBobHM7XG4gICAgdmFyIGNvbmZpZyA9IGhscy5jb25maWc7XG4gICAgdGhpcy5id0VzdGltYXRvciA9IG5ldyBfdXRpbHNfZXdtYV9iYW5kd2lkdGhfZXN0aW1hdG9yX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJkZWZhdWx0XCJdKGNvbmZpZy5hYnJFd21hU2xvd1ZvRCwgY29uZmlnLmFickV3bWFGYXN0Vm9ELCBjb25maWcuYWJyRXdtYURlZmF1bHRFc3RpbWF0ZSk7XG4gICAgdGhpcy5yZWdpc3Rlckxpc3RlbmVycygpO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IEFickNvbnRyb2xsZXIucHJvdG90eXBlO1xuXG4gIF9wcm90by5yZWdpc3Rlckxpc3RlbmVycyA9IGZ1bmN0aW9uIHJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIHZhciBobHMgPSB0aGlzLmhscztcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiRXZlbnRzXCJdLkZSQUdfTE9BRElORywgdGhpcy5vbkZyYWdMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiRXZlbnRzXCJdLkZSQUdfTE9BREVELCB0aGlzLm9uRnJhZ0xvYWRlZCwgdGhpcyk7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcIkV2ZW50c1wiXS5GUkFHX0JVRkZFUkVELCB0aGlzLm9uRnJhZ0J1ZmZlcmVkLCB0aGlzKTtcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiRXZlbnRzXCJdLkxFVkVMX0xPQURFRCwgdGhpcy5vbkxldmVsTG9hZGVkLCB0aGlzKTtcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiRXZlbnRzXCJdLkVSUk9SLCB0aGlzLm9uRXJyb3IsIHRoaXMpO1xuICB9O1xuXG4gIF9wcm90by51bnJlZ2lzdGVyTGlzdGVuZXJzID0gZnVuY3Rpb24gdW5yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICB2YXIgaGxzID0gdGhpcy5obHM7XG4gICAgaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJFdmVudHNcIl0uRlJBR19MT0FESU5HLCB0aGlzLm9uRnJhZ0xvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiRXZlbnRzXCJdLkZSQUdfTE9BREVELCB0aGlzLm9uRnJhZ0xvYWRlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJFdmVudHNcIl0uRlJBR19CVUZGRVJFRCwgdGhpcy5vbkZyYWdCdWZmZXJlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJFdmVudHNcIl0uTEVWRUxfTE9BREVELCB0aGlzLm9uTGV2ZWxMb2FkZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiRXZlbnRzXCJdLkVSUk9SLCB0aGlzLm9uRXJyb3IsIHRoaXMpO1xuICB9O1xuXG4gIF9wcm90by5kZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICB0aGlzLnVucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLmNsZWFyVGltZXIoKTsgLy8gQHRzLWlnbm9yZVxuXG4gICAgdGhpcy5obHMgPSB0aGlzLm9uQ2hlY2sgPSBudWxsO1xuICAgIHRoaXMuZnJhZ0N1cnJlbnQgPSB0aGlzLnBhcnRDdXJyZW50ID0gbnVsbDtcbiAgfTtcblxuICBfcHJvdG8ub25GcmFnTG9hZGluZyA9IGZ1bmN0aW9uIG9uRnJhZ0xvYWRpbmcoZXZlbnQsIGRhdGEpIHtcbiAgICB2YXIgZnJhZyA9IGRhdGEuZnJhZztcblxuICAgIGlmIChmcmFnLnR5cGUgPT09IF90eXBlc19sb2FkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcIlBsYXlsaXN0TGV2ZWxUeXBlXCJdLk1BSU4pIHtcbiAgICAgIGlmICghdGhpcy50aW1lcikge1xuICAgICAgICB2YXIgX2RhdGEkcGFydDtcblxuICAgICAgICB0aGlzLmZyYWdDdXJyZW50ID0gZnJhZztcbiAgICAgICAgdGhpcy5wYXJ0Q3VycmVudCA9IChfZGF0YSRwYXJ0ID0gZGF0YS5wYXJ0KSAhPSBudWxsID8gX2RhdGEkcGFydCA6IG51bGw7XG4gICAgICAgIHRoaXMudGltZXIgPSBzZWxmLnNldEludGVydmFsKHRoaXMub25DaGVjaywgMTAwKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLm9uTGV2ZWxMb2FkZWQgPSBmdW5jdGlvbiBvbkxldmVsTG9hZGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgdmFyIGNvbmZpZyA9IHRoaXMuaGxzLmNvbmZpZztcblxuICAgIGlmIChkYXRhLmRldGFpbHMubGl2ZSkge1xuICAgICAgdGhpcy5id0VzdGltYXRvci51cGRhdGUoY29uZmlnLmFickV3bWFTbG93TGl2ZSwgY29uZmlnLmFickV3bWFGYXN0TGl2ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYndFc3RpbWF0b3IudXBkYXRlKGNvbmZpZy5hYnJFd21hU2xvd1ZvRCwgY29uZmlnLmFickV3bWFGYXN0Vm9EKTtcbiAgICB9XG4gIH1cbiAgLypcbiAgICAgIFRoaXMgbWV0aG9kIG1vbml0b3JzIHRoZSBkb3dubG9hZCByYXRlIG9mIHRoZSBjdXJyZW50IGZyYWdtZW50LCBhbmQgd2lsbCBkb3duc3dpdGNoIGlmIHRoYXQgZnJhZ21lbnQgd2lsbCBub3QgbG9hZFxuICAgICAgcXVpY2tseSBlbm91Z2ggdG8gcHJldmVudCB1bmRlcmJ1ZmZlcmluZ1xuICAgICovXG4gIDtcblxuICBfcHJvdG8uX2FiYW5kb25SdWxlc0NoZWNrID0gZnVuY3Rpb24gX2FiYW5kb25SdWxlc0NoZWNrKCkge1xuICAgIHZhciBmcmFnID0gdGhpcy5mcmFnQ3VycmVudCxcbiAgICAgICAgcGFydCA9IHRoaXMucGFydEN1cnJlbnQsXG4gICAgICAgIGhscyA9IHRoaXMuaGxzO1xuICAgIHZhciBhdXRvTGV2ZWxFbmFibGVkID0gaGxzLmF1dG9MZXZlbEVuYWJsZWQsXG4gICAgICAgIGNvbmZpZyA9IGhscy5jb25maWcsXG4gICAgICAgIG1lZGlhID0gaGxzLm1lZGlhO1xuXG4gICAgaWYgKCFmcmFnIHx8ICFtZWRpYSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBzdGF0cyA9IHBhcnQgPyBwYXJ0LnN0YXRzIDogZnJhZy5zdGF0cztcbiAgICB2YXIgZHVyYXRpb24gPSBwYXJ0ID8gcGFydC5kdXJhdGlvbiA6IGZyYWcuZHVyYXRpb247IC8vIElmIGxvYWRpbmcgaGFzIGJlZW4gYWJvcnRlZCBhbmQgbm90IGluIGxvd0xhdGVuY3lNb2RlLCBzdG9wIHRpbWVyIGFuZCByZXR1cm5cblxuICAgIGlmIChzdGF0cy5hYm9ydGVkKSB7XG4gICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXCJsb2dnZXJcIl0ud2FybignZnJhZyBsb2FkZXIgZGVzdHJveSBvciBhYm9ydGVkLCBkaXNhcm0gYWJhbmRvblJ1bGVzJyk7XG4gICAgICB0aGlzLmNsZWFyVGltZXIoKTsgLy8gcmVzZXQgZm9yY2VkIGF1dG8gbGV2ZWwgdmFsdWUgc28gdGhhdCBuZXh0IGxldmVsIHdpbGwgYmUgc2VsZWN0ZWRcblxuICAgICAgdGhpcy5fbmV4dEF1dG9MZXZlbCA9IC0xO1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gVGhpcyBjaGVjayBvbmx5IHJ1bnMgaWYgd2UncmUgaW4gQUJSIG1vZGUgYW5kIGFjdHVhbGx5IHBsYXlpbmdcblxuXG4gICAgaWYgKCFhdXRvTGV2ZWxFbmFibGVkIHx8IG1lZGlhLnBhdXNlZCB8fCAhbWVkaWEucGxheWJhY2tSYXRlIHx8ICFtZWRpYS5yZWFkeVN0YXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHJlcXVlc3REZWxheSA9IHBlcmZvcm1hbmNlLm5vdygpIC0gc3RhdHMubG9hZGluZy5zdGFydDtcbiAgICB2YXIgcGxheWJhY2tSYXRlID0gTWF0aC5hYnMobWVkaWEucGxheWJhY2tSYXRlKTsgLy8gSW4gb3JkZXIgdG8gd29yayB3aXRoIGEgc3RhYmxlIGJhbmR3aWR0aCwgb25seSBiZWdpbiBtb25pdG9yaW5nIGJhbmR3aWR0aCBhZnRlciBoYWxmIG9mIHRoZSBmcmFnbWVudCBoYXMgYmVlbiBsb2FkZWRcblxuICAgIGlmIChyZXF1ZXN0RGVsYXkgPD0gNTAwICogZHVyYXRpb24gLyBwbGF5YmFja1JhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbGV2ZWxzID0gaGxzLmxldmVscyxcbiAgICAgICAgbWluQXV0b0xldmVsID0gaGxzLm1pbkF1dG9MZXZlbDtcbiAgICB2YXIgbGV2ZWwgPSBsZXZlbHNbZnJhZy5sZXZlbF07XG4gICAgdmFyIGV4cGVjdGVkTGVuID0gc3RhdHMudG90YWwgfHwgTWF0aC5tYXgoc3RhdHMubG9hZGVkLCBNYXRoLnJvdW5kKGR1cmF0aW9uICogbGV2ZWwubWF4Qml0cmF0ZSAvIDgpKTtcbiAgICB2YXIgbG9hZFJhdGUgPSBNYXRoLm1heCgxLCBzdGF0cy5id0VzdGltYXRlID8gc3RhdHMuYndFc3RpbWF0ZSAvIDggOiBzdGF0cy5sb2FkZWQgKiAxMDAwIC8gcmVxdWVzdERlbGF5KTsgLy8gZnJhZ0xvYWREZWxheSBpcyBhbiBlc3RpbWF0ZSBvZiB0aGUgdGltZSAoaW4gc2Vjb25kcykgaXQgd2lsbCB0YWtlIHRvIGJ1ZmZlciB0aGUgZW50aXJlIGZyYWdtZW50XG5cbiAgICB2YXIgZnJhZ0xvYWRlZERlbGF5ID0gKGV4cGVjdGVkTGVuIC0gc3RhdHMubG9hZGVkKSAvIGxvYWRSYXRlO1xuICAgIHZhciBwb3MgPSBtZWRpYS5jdXJyZW50VGltZTsgLy8gYnVmZmVyU3RhcnZhdGlvbkRlbGF5IGlzIGFuIGVzdGltYXRlIG9mIHRoZSBhbW91bnQgdGltZSAoaW4gc2Vjb25kcykgaXQgd2lsbCB0YWtlIHRvIGV4aGF1c3QgdGhlIGJ1ZmZlclxuXG4gICAgdmFyIGJ1ZmZlclN0YXJ2YXRpb25EZWxheSA9IChfdXRpbHNfYnVmZmVyX2hlbHBlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiQnVmZmVySGVscGVyXCJdLmJ1ZmZlckluZm8obWVkaWEsIHBvcywgY29uZmlnLm1heEJ1ZmZlckhvbGUpLmVuZCAtIHBvcykgLyBwbGF5YmFja1JhdGU7IC8vIEF0dGVtcHQgYW4gZW1lcmdlbmN5IGRvd25zd2l0Y2ggb25seSBpZiBsZXNzIHRoYW4gMiBmcmFnbWVudCBsZW5ndGhzIGFyZSBidWZmZXJlZCwgYW5kIHRoZSB0aW1lIHRvIGZpbmlzaCBsb2FkaW5nXG4gICAgLy8gdGhlIGN1cnJlbnQgZnJhZ21lbnQgaXMgZ3JlYXRlciB0aGFuIHRoZSBhbW91bnQgb2YgYnVmZmVyIHdlIGhhdmUgbGVmdFxuXG4gICAgaWYgKGJ1ZmZlclN0YXJ2YXRpb25EZWxheSA+PSAyICogZHVyYXRpb24gLyBwbGF5YmFja1JhdGUgfHwgZnJhZ0xvYWRlZERlbGF5IDw9IGJ1ZmZlclN0YXJ2YXRpb25EZWxheSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBmcmFnTGV2ZWxOZXh0TG9hZGVkRGVsYXkgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgdmFyIG5leHRMb2FkTGV2ZWw7IC8vIEl0ZXJhdGUgdGhyb3VnaCBsb3dlciBsZXZlbCBhbmQgdHJ5IHRvIGZpbmQgdGhlIGxhcmdlc3Qgb25lIHRoYXQgYXZvaWRzIHJlYnVmZmVyaW5nXG5cbiAgICBmb3IgKG5leHRMb2FkTGV2ZWwgPSBmcmFnLmxldmVsIC0gMTsgbmV4dExvYWRMZXZlbCA+IG1pbkF1dG9MZXZlbDsgbmV4dExvYWRMZXZlbC0tKSB7XG4gICAgICAvLyBjb21wdXRlIHRpbWUgdG8gbG9hZCBuZXh0IGZyYWdtZW50IGF0IGxvd2VyIGxldmVsXG4gICAgICAvLyAwLjggOiBjb25zaWRlciBvbmx5IDgwJSBvZiBjdXJyZW50IGJ3IHRvIGJlIGNvbnNlcnZhdGl2ZVxuICAgICAgLy8gOCA9IGJpdHMgcGVyIGJ5dGUgKGJwcy9CcHMpXG4gICAgICB2YXIgbGV2ZWxOZXh0Qml0cmF0ZSA9IGxldmVsc1tuZXh0TG9hZExldmVsXS5tYXhCaXRyYXRlO1xuICAgICAgZnJhZ0xldmVsTmV4dExvYWRlZERlbGF5ID0gZHVyYXRpb24gKiBsZXZlbE5leHRCaXRyYXRlIC8gKDggKiAwLjggKiBsb2FkUmF0ZSk7XG5cbiAgICAgIGlmIChmcmFnTGV2ZWxOZXh0TG9hZGVkRGVsYXkgPCBidWZmZXJTdGFydmF0aW9uRGVsYXkpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSAvLyBPbmx5IGVtZXJnZW5jeSBzd2l0Y2ggZG93biBpZiBpdCB0YWtlcyBsZXNzIHRpbWUgdG8gbG9hZCBhIG5ldyBmcmFnbWVudCBhdCBsb3dlc3QgbGV2ZWwgaW5zdGVhZCBvZiBjb250aW51aW5nXG4gICAgLy8gdG8gbG9hZCB0aGUgY3VycmVudCBvbmVcblxuXG4gICAgaWYgKGZyYWdMZXZlbE5leHRMb2FkZWREZWxheSA+PSBmcmFnTG9hZGVkRGVsYXkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgYndFc3RpbWF0ZSA9IHRoaXMuYndFc3RpbWF0b3IuZ2V0RXN0aW1hdGUoKTtcbiAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXCJsb2dnZXJcIl0ud2FybihcIkZyYWdtZW50IFwiICsgZnJhZy5zbiArIChwYXJ0ID8gJyBwYXJ0ICcgKyBwYXJ0LmluZGV4IDogJycpICsgXCIgb2YgbGV2ZWwgXCIgKyBmcmFnLmxldmVsICsgXCIgaXMgbG9hZGluZyB0b28gc2xvd2x5IGFuZCB3aWxsIGNhdXNlIGFuIHVuZGVyYnVmZmVyOyBhYm9ydGluZyBhbmQgc3dpdGNoaW5nIHRvIGxldmVsIFwiICsgbmV4dExvYWRMZXZlbCArIFwiXFxuICAgICAgQ3VycmVudCBCVyBlc3RpbWF0ZTogXCIgKyAoT2JqZWN0KF9ob21lX3J1bm5lcl93b3JrX2hsc19qc19obHNfanNfc3JjX3BvbHlmaWxsc19udW1iZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImlzRmluaXRlTnVtYmVyXCJdKShid0VzdGltYXRlKSA/IChid0VzdGltYXRlIC8gMTAyNCkudG9GaXhlZCgzKSA6ICdVbmtub3duJykgKyBcIiBLYi9zXFxuICAgICAgRXN0aW1hdGVkIGxvYWQgdGltZSBmb3IgY3VycmVudCBmcmFnbWVudDogXCIgKyBmcmFnTG9hZGVkRGVsYXkudG9GaXhlZCgzKSArIFwiIHNcXG4gICAgICBFc3RpbWF0ZWQgbG9hZCB0aW1lIGZvciB0aGUgbmV4dCBmcmFnbWVudDogXCIgKyBmcmFnTGV2ZWxOZXh0TG9hZGVkRGVsYXkudG9GaXhlZCgzKSArIFwiIHNcXG4gICAgICBUaW1lIHRvIHVuZGVyYnVmZmVyOiBcIiArIGJ1ZmZlclN0YXJ2YXRpb25EZWxheS50b0ZpeGVkKDMpICsgXCIgc1wiKTtcbiAgICBobHMubmV4dExvYWRMZXZlbCA9IG5leHRMb2FkTGV2ZWw7XG4gICAgdGhpcy5id0VzdGltYXRvci5zYW1wbGUocmVxdWVzdERlbGF5LCBzdGF0cy5sb2FkZWQpO1xuICAgIHRoaXMuY2xlYXJUaW1lcigpO1xuXG4gICAgaWYgKGZyYWcubG9hZGVyKSB7XG4gICAgICB0aGlzLmZyYWdDdXJyZW50ID0gdGhpcy5wYXJ0Q3VycmVudCA9IG51bGw7XG4gICAgICBmcmFnLmxvYWRlci5hYm9ydCgpO1xuICAgIH1cblxuICAgIGhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcIkV2ZW50c1wiXS5GUkFHX0xPQURfRU1FUkdFTkNZX0FCT1JURUQsIHtcbiAgICAgIGZyYWc6IGZyYWcsXG4gICAgICBwYXJ0OiBwYXJ0LFxuICAgICAgc3RhdHM6IHN0YXRzXG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLm9uRnJhZ0xvYWRlZCA9IGZ1bmN0aW9uIG9uRnJhZ0xvYWRlZChldmVudCwgX3JlZikge1xuICAgIHZhciBmcmFnID0gX3JlZi5mcmFnLFxuICAgICAgICBwYXJ0ID0gX3JlZi5wYXJ0O1xuXG4gICAgaWYgKGZyYWcudHlwZSA9PT0gX3R5cGVzX2xvYWRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1wiUGxheWxpc3RMZXZlbFR5cGVcIl0uTUFJTiAmJiBPYmplY3QoX2hvbWVfcnVubmVyX3dvcmtfaGxzX2pzX2hsc19qc19zcmNfcG9seWZpbGxzX251bWJlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiaXNGaW5pdGVOdW1iZXJcIl0pKGZyYWcuc24pKSB7XG4gICAgICB2YXIgc3RhdHMgPSBwYXJ0ID8gcGFydC5zdGF0cyA6IGZyYWcuc3RhdHM7XG4gICAgICB2YXIgZHVyYXRpb24gPSBwYXJ0ID8gcGFydC5kdXJhdGlvbiA6IGZyYWcuZHVyYXRpb247IC8vIHN0b3AgbW9uaXRvcmluZyBidyBvbmNlIGZyYWcgbG9hZGVkXG5cbiAgICAgIHRoaXMuY2xlYXJUaW1lcigpOyAvLyBzdG9yZSBsZXZlbCBpZCBhZnRlciBzdWNjZXNzZnVsIGZyYWdtZW50IGxvYWRcblxuICAgICAgdGhpcy5sYXN0TG9hZGVkRnJhZ0xldmVsID0gZnJhZy5sZXZlbDsgLy8gcmVzZXQgZm9yY2VkIGF1dG8gbGV2ZWwgdmFsdWUgc28gdGhhdCBuZXh0IGxldmVsIHdpbGwgYmUgc2VsZWN0ZWRcblxuICAgICAgdGhpcy5fbmV4dEF1dG9MZXZlbCA9IC0xOyAvLyBjb21wdXRlIGxldmVsIGF2ZXJhZ2UgYml0cmF0ZVxuXG4gICAgICBpZiAodGhpcy5obHMuY29uZmlnLmFick1heFdpdGhSZWFsQml0cmF0ZSkge1xuICAgICAgICB2YXIgbGV2ZWwgPSB0aGlzLmhscy5sZXZlbHNbZnJhZy5sZXZlbF07XG4gICAgICAgIHZhciBsb2FkZWRCeXRlcyA9IChsZXZlbC5sb2FkZWQgPyBsZXZlbC5sb2FkZWQuYnl0ZXMgOiAwKSArIHN0YXRzLmxvYWRlZDtcbiAgICAgICAgdmFyIGxvYWRlZER1cmF0aW9uID0gKGxldmVsLmxvYWRlZCA/IGxldmVsLmxvYWRlZC5kdXJhdGlvbiA6IDApICsgZHVyYXRpb247XG4gICAgICAgIGxldmVsLmxvYWRlZCA9IHtcbiAgICAgICAgICBieXRlczogbG9hZGVkQnl0ZXMsXG4gICAgICAgICAgZHVyYXRpb246IGxvYWRlZER1cmF0aW9uXG4gICAgICAgIH07XG4gICAgICAgIGxldmVsLnJlYWxCaXRyYXRlID0gTWF0aC5yb3VuZCg4ICogbG9hZGVkQnl0ZXMgLyBsb2FkZWREdXJhdGlvbik7XG4gICAgICB9XG5cbiAgICAgIGlmIChmcmFnLmJpdHJhdGVUZXN0KSB7XG4gICAgICAgIHZhciBmcmFnQnVmZmVyZWREYXRhID0ge1xuICAgICAgICAgIHN0YXRzOiBzdGF0cyxcbiAgICAgICAgICBmcmFnOiBmcmFnLFxuICAgICAgICAgIHBhcnQ6IHBhcnQsXG4gICAgICAgICAgaWQ6IGZyYWcudHlwZVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9uRnJhZ0J1ZmZlcmVkKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcIkV2ZW50c1wiXS5GUkFHX0JVRkZFUkVELCBmcmFnQnVmZmVyZWREYXRhKTtcbiAgICAgICAgZnJhZy5iaXRyYXRlVGVzdCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBfcHJvdG8ub25GcmFnQnVmZmVyZWQgPSBmdW5jdGlvbiBvbkZyYWdCdWZmZXJlZChldmVudCwgZGF0YSkge1xuICAgIHZhciBmcmFnID0gZGF0YS5mcmFnLFxuICAgICAgICBwYXJ0ID0gZGF0YS5wYXJ0O1xuICAgIHZhciBzdGF0cyA9IHBhcnQgPyBwYXJ0LnN0YXRzIDogZnJhZy5zdGF0cztcblxuICAgIGlmIChzdGF0cy5hYm9ydGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBPbmx5IGNvdW50IG5vbi1hbHQtYXVkaW8gZnJhZ3Mgd2hpY2ggd2VyZSBhY3R1YWxseSBidWZmZXJlZCBpbiBvdXIgQlcgY2FsY3VsYXRpb25zXG5cblxuICAgIGlmIChmcmFnLnR5cGUgIT09IF90eXBlc19sb2FkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcIlBsYXlsaXN0TGV2ZWxUeXBlXCJdLk1BSU4gfHwgZnJhZy5zbiA9PT0gJ2luaXRTZWdtZW50Jykge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gVXNlIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gcGFyc2luZyBhbmQgcmVxdWVzdCBpbnN0ZWFkIG9mIGJ1ZmZlcmluZyBhbmQgcmVxdWVzdCB0byBjb21wdXRlIGZyYWdMb2FkaW5nUHJvY2Vzc2luZztcbiAgICAvLyByYXRpb25hbGUgaXMgdGhhdCBidWZmZXIgYXBwZW5kaW5nIG9ubHkgaGFwcGVucyBvbmNlIG1lZGlhIGlzIGF0dGFjaGVkLiBUaGlzIGNhbiBoYXBwZW4gd2hlbiBjb25maWcuc3RhcnRGcmFnUHJlZmV0Y2hcbiAgICAvLyBpcyB1c2VkLiBJZiB3ZSB1c2VkIGJ1ZmZlcmluZyBpbiB0aGF0IGNhc2UsIG91ciBCVyBlc3RpbWF0ZSBzYW1wbGUgd2lsbCBiZSB2ZXJ5IGxhcmdlLlxuXG5cbiAgICB2YXIgcHJvY2Vzc2luZ01zID0gc3RhdHMucGFyc2luZy5lbmQgLSBzdGF0cy5sb2FkaW5nLnN0YXJ0O1xuICAgIHRoaXMuYndFc3RpbWF0b3Iuc2FtcGxlKHByb2Nlc3NpbmdNcywgc3RhdHMubG9hZGVkKTtcbiAgICBzdGF0cy5id0VzdGltYXRlID0gdGhpcy5id0VzdGltYXRvci5nZXRFc3RpbWF0ZSgpO1xuXG4gICAgaWYgKGZyYWcuYml0cmF0ZVRlc3QpIHtcbiAgICAgIHRoaXMuYml0cmF0ZVRlc3REZWxheSA9IHByb2Nlc3NpbmdNcyAvIDEwMDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYml0cmF0ZVRlc3REZWxheSA9IDA7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5vbkVycm9yID0gZnVuY3Rpb24gb25FcnJvcihldmVudCwgZGF0YSkge1xuICAgIC8vIHN0b3AgdGltZXIgaW4gY2FzZSBvZiBmcmFnIGxvYWRpbmcgZXJyb3JcbiAgICBzd2l0Y2ggKGRhdGEuZGV0YWlscykge1xuICAgICAgY2FzZSBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXCJFcnJvckRldGFpbHNcIl0uRlJBR19MT0FEX0VSUk9SOlxuICAgICAgY2FzZSBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXCJFcnJvckRldGFpbHNcIl0uRlJBR19MT0FEX1RJTUVPVVQ6XG4gICAgICAgIHRoaXMuY2xlYXJUaW1lcigpO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5jbGVhclRpbWVyID0gZnVuY3Rpb24gY2xlYXJUaW1lcigpIHtcbiAgICBzZWxmLmNsZWFySW50ZXJ2YWwodGhpcy50aW1lcik7XG4gICAgdGhpcy50aW1lciA9IHVuZGVmaW5lZDtcbiAgfSAvLyByZXR1cm4gbmV4dCBhdXRvIGxldmVsXG4gIDtcblxuICBfcHJvdG8uZ2V0TmV4dEFCUkF1dG9MZXZlbCA9IGZ1bmN0aW9uIGdldE5leHRBQlJBdXRvTGV2ZWwoKSB7XG4gICAgdmFyIGZyYWdDdXJyZW50ID0gdGhpcy5mcmFnQ3VycmVudCxcbiAgICAgICAgcGFydEN1cnJlbnQgPSB0aGlzLnBhcnRDdXJyZW50LFxuICAgICAgICBobHMgPSB0aGlzLmhscztcbiAgICB2YXIgbWF4QXV0b0xldmVsID0gaGxzLm1heEF1dG9MZXZlbCxcbiAgICAgICAgY29uZmlnID0gaGxzLmNvbmZpZyxcbiAgICAgICAgbWluQXV0b0xldmVsID0gaGxzLm1pbkF1dG9MZXZlbCxcbiAgICAgICAgbWVkaWEgPSBobHMubWVkaWE7XG4gICAgdmFyIGN1cnJlbnRGcmFnRHVyYXRpb24gPSBwYXJ0Q3VycmVudCA/IHBhcnRDdXJyZW50LmR1cmF0aW9uIDogZnJhZ0N1cnJlbnQgPyBmcmFnQ3VycmVudC5kdXJhdGlvbiA6IDA7XG4gICAgdmFyIHBvcyA9IG1lZGlhID8gbWVkaWEuY3VycmVudFRpbWUgOiAwOyAvLyBwbGF5YmFja1JhdGUgaXMgdGhlIGFic29sdXRlIHZhbHVlIG9mIHRoZSBwbGF5YmFjayByYXRlOyBpZiBtZWRpYS5wbGF5YmFja1JhdGUgaXMgMCwgd2UgdXNlIDEgdG8gbG9hZCBhc1xuICAgIC8vIGlmIHdlJ3JlIHBsYXlpbmcgYmFjayBhdCB0aGUgbm9ybWFsIHJhdGUuXG5cbiAgICB2YXIgcGxheWJhY2tSYXRlID0gbWVkaWEgJiYgbWVkaWEucGxheWJhY2tSYXRlICE9PSAwID8gTWF0aC5hYnMobWVkaWEucGxheWJhY2tSYXRlKSA6IDEuMDtcbiAgICB2YXIgYXZnYncgPSB0aGlzLmJ3RXN0aW1hdG9yID8gdGhpcy5id0VzdGltYXRvci5nZXRFc3RpbWF0ZSgpIDogY29uZmlnLmFickV3bWFEZWZhdWx0RXN0aW1hdGU7IC8vIGJ1ZmZlclN0YXJ2YXRpb25EZWxheSBpcyB0aGUgd2FsbC1jbG9jayB0aW1lIGxlZnQgdW50aWwgdGhlIHBsYXliYWNrIGJ1ZmZlciBpcyBleGhhdXN0ZWQuXG5cbiAgICB2YXIgYnVmZmVyU3RhcnZhdGlvbkRlbGF5ID0gKF91dGlsc19idWZmZXJfaGVscGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJCdWZmZXJIZWxwZXJcIl0uYnVmZmVySW5mbyhtZWRpYSwgcG9zLCBjb25maWcubWF4QnVmZmVySG9sZSkuZW5kIC0gcG9zKSAvIHBsYXliYWNrUmF0ZTsgLy8gRmlyc3QsIGxvb2sgdG8gc2VlIGlmIHdlIGNhbiBmaW5kIGEgbGV2ZWwgbWF0Y2hpbmcgd2l0aCBvdXIgYXZnIGJhbmR3aWR0aCBBTkQgdGhhdCBjb3VsZCBhbHNvIGd1YXJhbnRlZSBubyByZWJ1ZmZlcmluZyBhdCBhbGxcblxuICAgIHZhciBiZXN0TGV2ZWwgPSB0aGlzLmZpbmRCZXN0TGV2ZWwoYXZnYncsIG1pbkF1dG9MZXZlbCwgbWF4QXV0b0xldmVsLCBidWZmZXJTdGFydmF0aW9uRGVsYXksIGNvbmZpZy5hYnJCYW5kV2lkdGhGYWN0b3IsIGNvbmZpZy5hYnJCYW5kV2lkdGhVcEZhY3Rvcik7XG5cbiAgICBpZiAoYmVzdExldmVsID49IDApIHtcbiAgICAgIHJldHVybiBiZXN0TGV2ZWw7XG4gICAgfVxuXG4gICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fW1wibG9nZ2VyXCJdLnRyYWNlKChidWZmZXJTdGFydmF0aW9uRGVsYXkgPyAncmVidWZmZXJpbmcgZXhwZWN0ZWQnIDogJ2J1ZmZlciBpcyBlbXB0eScpICsgXCIsIGZpbmRpbmcgb3B0aW1hbCBxdWFsaXR5IGxldmVsXCIpOyAvLyBub3QgcG9zc2libGUgdG8gZ2V0IHJpZCBvZiByZWJ1ZmZlcmluZyAuLi4gbGV0J3MgdHJ5IHRvIGZpbmQgbGV2ZWwgdGhhdCB3aWxsIGd1YXJhbnRlZSBsZXNzIHRoYW4gbWF4U3RhcnZhdGlvbkRlbGF5IG9mIHJlYnVmZmVyaW5nXG4gICAgLy8gaWYgbm8gbWF0Y2hpbmcgbGV2ZWwgZm91bmQsIGxvZ2ljIHdpbGwgcmV0dXJuIDBcblxuICAgIHZhciBtYXhTdGFydmF0aW9uRGVsYXkgPSBjdXJyZW50RnJhZ0R1cmF0aW9uID8gTWF0aC5taW4oY3VycmVudEZyYWdEdXJhdGlvbiwgY29uZmlnLm1heFN0YXJ2YXRpb25EZWxheSkgOiBjb25maWcubWF4U3RhcnZhdGlvbkRlbGF5O1xuICAgIHZhciBid0ZhY3RvciA9IGNvbmZpZy5hYnJCYW5kV2lkdGhGYWN0b3I7XG4gICAgdmFyIGJ3VXBGYWN0b3IgPSBjb25maWcuYWJyQmFuZFdpZHRoVXBGYWN0b3I7XG5cbiAgICBpZiAoIWJ1ZmZlclN0YXJ2YXRpb25EZWxheSkge1xuICAgICAgLy8gaW4gY2FzZSBidWZmZXIgaXMgZW1wdHksIGxldCdzIGNoZWNrIGlmIHByZXZpb3VzIGZyYWdtZW50IHdhcyBsb2FkZWQgdG8gcGVyZm9ybSBhIGJpdHJhdGUgdGVzdFxuICAgICAgdmFyIGJpdHJhdGVUZXN0RGVsYXkgPSB0aGlzLmJpdHJhdGVUZXN0RGVsYXk7XG5cbiAgICAgIGlmIChiaXRyYXRlVGVzdERlbGF5KSB7XG4gICAgICAgIC8vIGlmIGl0IGlzIHRoZSBjYXNlLCB0aGVuIHdlIG5lZWQgdG8gYWRqdXN0IG91ciBtYXggc3RhcnZhdGlvbiBkZWxheSB1c2luZyBtYXhMb2FkaW5nRGVsYXkgY29uZmlnIHZhbHVlXG4gICAgICAgIC8vIG1heCB2aWRlbyBsb2FkaW5nIGRlbGF5IHVzZWQgaW4gIGF1dG9tYXRpYyBzdGFydCBsZXZlbCBzZWxlY3Rpb24gOlxuICAgICAgICAvLyBpbiB0aGF0IG1vZGUgQUJSIGNvbnRyb2xsZXIgd2lsbCBlbnN1cmUgdGhhdCB2aWRlbyBsb2FkaW5nIHRpbWUgKGllIHRoZSB0aW1lIHRvIGZldGNoIHRoZSBmaXJzdCBmcmFnbWVudCBhdCBsb3dlc3QgcXVhbGl0eSBsZXZlbCArXG4gICAgICAgIC8vIHRoZSB0aW1lIHRvIGZldGNoIHRoZSBmcmFnbWVudCBhdCB0aGUgYXBwcm9wcmlhdGUgcXVhbGl0eSBsZXZlbCBpcyBsZXNzIHRoYW4gYGBgbWF4TG9hZGluZ0RlbGF5YGBgIClcbiAgICAgICAgLy8gY2FwIG1heExvYWRpbmdEZWxheSBhbmQgZW5zdXJlIGl0IGlzIG5vdCBiaWdnZXIgJ3RoYW4gYml0cmF0ZSB0ZXN0JyBmcmFnIGR1cmF0aW9uXG4gICAgICAgIHZhciBtYXhMb2FkaW5nRGVsYXkgPSBjdXJyZW50RnJhZ0R1cmF0aW9uID8gTWF0aC5taW4oY3VycmVudEZyYWdEdXJhdGlvbiwgY29uZmlnLm1heExvYWRpbmdEZWxheSkgOiBjb25maWcubWF4TG9hZGluZ0RlbGF5O1xuICAgICAgICBtYXhTdGFydmF0aW9uRGVsYXkgPSBtYXhMb2FkaW5nRGVsYXkgLSBiaXRyYXRlVGVzdERlbGF5O1xuICAgICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXCJsb2dnZXJcIl0udHJhY2UoXCJiaXRyYXRlIHRlc3QgdG9vayBcIiArIE1hdGgucm91bmQoMTAwMCAqIGJpdHJhdGVUZXN0RGVsYXkpICsgXCJtcywgc2V0IGZpcnN0IGZyYWdtZW50IG1heCBmZXRjaER1cmF0aW9uIHRvIFwiICsgTWF0aC5yb3VuZCgxMDAwICogbWF4U3RhcnZhdGlvbkRlbGF5KSArIFwiIG1zXCIpOyAvLyBkb24ndCB1c2UgY29uc2VydmF0aXZlIGZhY3RvciBvbiBiaXRyYXRlIHRlc3RcblxuICAgICAgICBid0ZhY3RvciA9IGJ3VXBGYWN0b3IgPSAxO1xuICAgICAgfVxuICAgIH1cblxuICAgIGJlc3RMZXZlbCA9IHRoaXMuZmluZEJlc3RMZXZlbChhdmdidywgbWluQXV0b0xldmVsLCBtYXhBdXRvTGV2ZWwsIGJ1ZmZlclN0YXJ2YXRpb25EZWxheSArIG1heFN0YXJ2YXRpb25EZWxheSwgYndGYWN0b3IsIGJ3VXBGYWN0b3IpO1xuICAgIHJldHVybiBNYXRoLm1heChiZXN0TGV2ZWwsIDApO1xuICB9O1xuXG4gIF9wcm90by5maW5kQmVzdExldmVsID0gZnVuY3Rpb24gZmluZEJlc3RMZXZlbChjdXJyZW50QncsIG1pbkF1dG9MZXZlbCwgbWF4QXV0b0xldmVsLCBtYXhGZXRjaER1cmF0aW9uLCBid0ZhY3RvciwgYndVcEZhY3Rvcikge1xuICAgIHZhciBfbGV2ZWwkZGV0YWlscztcblxuICAgIHZhciBmcmFnQ3VycmVudCA9IHRoaXMuZnJhZ0N1cnJlbnQsXG4gICAgICAgIHBhcnRDdXJyZW50ID0gdGhpcy5wYXJ0Q3VycmVudCxcbiAgICAgICAgY3VycmVudExldmVsID0gdGhpcy5sYXN0TG9hZGVkRnJhZ0xldmVsO1xuICAgIHZhciBsZXZlbHMgPSB0aGlzLmhscy5sZXZlbHM7XG4gICAgdmFyIGxldmVsID0gbGV2ZWxzW2N1cnJlbnRMZXZlbF07XG4gICAgdmFyIGxpdmUgPSAhIShsZXZlbCAhPT0gbnVsbCAmJiBsZXZlbCAhPT0gdm9pZCAwICYmIChfbGV2ZWwkZGV0YWlscyA9IGxldmVsLmRldGFpbHMpICE9PSBudWxsICYmIF9sZXZlbCRkZXRhaWxzICE9PSB2b2lkIDAgJiYgX2xldmVsJGRldGFpbHMubGl2ZSk7XG4gICAgdmFyIGN1cnJlbnRDb2RlY1NldCA9IGxldmVsID09PSBudWxsIHx8IGxldmVsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsZXZlbC5jb2RlY1NldDtcbiAgICB2YXIgY3VycmVudEZyYWdEdXJhdGlvbiA9IHBhcnRDdXJyZW50ID8gcGFydEN1cnJlbnQuZHVyYXRpb24gOiBmcmFnQ3VycmVudCA/IGZyYWdDdXJyZW50LmR1cmF0aW9uIDogMDtcblxuICAgIGZvciAodmFyIGkgPSBtYXhBdXRvTGV2ZWw7IGkgPj0gbWluQXV0b0xldmVsOyBpLS0pIHtcbiAgICAgIHZhciBsZXZlbEluZm8gPSBsZXZlbHNbaV07XG5cbiAgICAgIGlmICghbGV2ZWxJbmZvIHx8IGN1cnJlbnRDb2RlY1NldCAmJiBsZXZlbEluZm8uY29kZWNTZXQgIT09IGN1cnJlbnRDb2RlY1NldCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGxldmVsRGV0YWlscyA9IGxldmVsSW5mby5kZXRhaWxzO1xuICAgICAgdmFyIGF2Z0R1cmF0aW9uID0gKHBhcnRDdXJyZW50ID8gbGV2ZWxEZXRhaWxzID09PSBudWxsIHx8IGxldmVsRGV0YWlscyA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGV2ZWxEZXRhaWxzLnBhcnRUYXJnZXQgOiBsZXZlbERldGFpbHMgPT09IG51bGwgfHwgbGV2ZWxEZXRhaWxzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsZXZlbERldGFpbHMuYXZlcmFnZXRhcmdldGR1cmF0aW9uKSB8fCBjdXJyZW50RnJhZ0R1cmF0aW9uO1xuICAgICAgdmFyIGFkanVzdGVkYncgPSB2b2lkIDA7IC8vIGZvbGxvdyBhbGdvcml0aG0gY2FwdHVyZWQgZnJvbSBzdGFnZWZyaWdodCA6XG4gICAgICAvLyBodHRwczovL2FuZHJvaWQuZ29vZ2xlc291cmNlLmNvbS9wbGF0Zm9ybS9mcmFtZXdvcmtzL2F2LysvbWFzdGVyL21lZGlhL2xpYnN0YWdlZnJpZ2h0L2h0dHBsaXZlL0xpdmVTZXNzaW9uLmNwcFxuICAgICAgLy8gUGljayB0aGUgaGlnaGVzdCBiYW5kd2lkdGggc3RyZWFtIGJlbG93IG9yIGVxdWFsIHRvIGVzdGltYXRlZCBiYW5kd2lkdGguXG4gICAgICAvLyBjb25zaWRlciBvbmx5IDgwJSBvZiB0aGUgYXZhaWxhYmxlIGJhbmR3aWR0aCwgYnV0IGlmIHdlIGFyZSBzd2l0Y2hpbmcgdXAsXG4gICAgICAvLyBiZSBldmVuIG1vcmUgY29uc2VydmF0aXZlICg3MCUpIHRvIGF2b2lkIG92ZXJlc3RpbWF0aW5nIGFuZCBpbW1lZGlhdGVseVxuICAgICAgLy8gc3dpdGNoaW5nIGJhY2suXG5cbiAgICAgIGlmIChpIDw9IGN1cnJlbnRMZXZlbCkge1xuICAgICAgICBhZGp1c3RlZGJ3ID0gYndGYWN0b3IgKiBjdXJyZW50Qnc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhZGp1c3RlZGJ3ID0gYndVcEZhY3RvciAqIGN1cnJlbnRCdztcbiAgICAgIH1cblxuICAgICAgdmFyIGJpdHJhdGUgPSBsZXZlbHNbaV0ubWF4Qml0cmF0ZTtcbiAgICAgIHZhciBmZXRjaER1cmF0aW9uID0gYml0cmF0ZSAqIGF2Z0R1cmF0aW9uIC8gYWRqdXN0ZWRidztcbiAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcImxvZ2dlclwiXS50cmFjZShcImxldmVsL2FkanVzdGVkYncvYml0cmF0ZS9hdmdEdXJhdGlvbi9tYXhGZXRjaER1cmF0aW9uL2ZldGNoRHVyYXRpb246IFwiICsgaSArIFwiL1wiICsgTWF0aC5yb3VuZChhZGp1c3RlZGJ3KSArIFwiL1wiICsgYml0cmF0ZSArIFwiL1wiICsgYXZnRHVyYXRpb24gKyBcIi9cIiArIG1heEZldGNoRHVyYXRpb24gKyBcIi9cIiArIGZldGNoRHVyYXRpb24pOyAvLyBpZiBhZGp1c3RlZCBidyBpcyBncmVhdGVyIHRoYW4gbGV2ZWwgYml0cmF0ZSBBTkRcblxuICAgICAgaWYgKGFkanVzdGVkYncgPiBiaXRyYXRlICYmICggLy8gZnJhZ21lbnQgZmV0Y2hEdXJhdGlvbiB1bmtub3duIE9SIGxpdmUgc3RyZWFtIE9SIGZyYWdtZW50IGZldGNoRHVyYXRpb24gbGVzcyB0aGFuIG1heCBhbGxvd2VkIGZldGNoIGR1cmF0aW9uLCB0aGVuIHRoaXMgbGV2ZWwgbWF0Y2hlc1xuICAgICAgLy8gd2UgZG9uJ3QgYWNjb3VudCBmb3IgbWF4IEZldGNoIER1cmF0aW9uIGZvciBsaXZlIHN0cmVhbXMsIHRoaXMgaXMgdG8gYXZvaWQgc3dpdGNoaW5nIGRvd24gd2hlbiBuZWFyIHRoZSBlZGdlIG9mIGxpdmUgc2xpZGluZyB3aW5kb3cgLi4uXG4gICAgICAvLyBzcGVjaWFsIGNhc2UgdG8gc3VwcG9ydCBzdGFydExldmVsID0gLTEgKGJpdHJhdGVUZXN0KSBvbiBsaXZlIHN0cmVhbXMgOiBpbiB0aGF0IGNhc2Ugd2Ugc2hvdWxkIG5vdCBleGl0IGxvb3Agc28gdGhhdCBmaW5kQmVzdExldmVsIHdpbGwgcmV0dXJuIC0xXG4gICAgICAhZmV0Y2hEdXJhdGlvbiB8fCBsaXZlICYmICF0aGlzLmJpdHJhdGVUZXN0RGVsYXkgfHwgZmV0Y2hEdXJhdGlvbiA8IG1heEZldGNoRHVyYXRpb24pKSB7XG4gICAgICAgIC8vIGFzIHdlIGFyZSBsb29waW5nIGZyb20gaGlnaGVzdCB0byBsb3dlc3QsIHRoaXMgd2lsbCByZXR1cm4gdGhlIGJlc3QgYWNoaWV2YWJsZSBxdWFsaXR5IGxldmVsXG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfVxuICAgIH0gLy8gbm90IGVub3VnaCB0aW1lIGJ1ZGdldCBldmVuIHdpdGggcXVhbGl0eSBsZXZlbCAwIC4uLiByZWJ1ZmZlcmluZyBtaWdodCBoYXBwZW5cblxuXG4gICAgcmV0dXJuIC0xO1xuICB9O1xuXG4gIF9jcmVhdGVDbGFzcyhBYnJDb250cm9sbGVyLCBbe1xuICAgIGtleTogXCJuZXh0QXV0b0xldmVsXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgZm9yY2VkQXV0b0xldmVsID0gdGhpcy5fbmV4dEF1dG9MZXZlbDtcbiAgICAgIHZhciBid0VzdGltYXRvciA9IHRoaXMuYndFc3RpbWF0b3I7IC8vIGluIGNhc2UgbmV4dCBhdXRvIGxldmVsIGhhcyBiZWVuIGZvcmNlZCwgYW5kIGJ3IG5vdCBhdmFpbGFibGUgb3Igbm90IHJlbGlhYmxlLCByZXR1cm4gZm9yY2VkIHZhbHVlXG5cbiAgICAgIGlmIChmb3JjZWRBdXRvTGV2ZWwgIT09IC0xICYmICghYndFc3RpbWF0b3IgfHwgIWJ3RXN0aW1hdG9yLmNhbkVzdGltYXRlKCkpKSB7XG4gICAgICAgIHJldHVybiBmb3JjZWRBdXRvTGV2ZWw7XG4gICAgICB9IC8vIGNvbXB1dGUgbmV4dCBsZXZlbCB1c2luZyBBQlIgbG9naWNcblxuXG4gICAgICB2YXIgbmV4dEFCUkF1dG9MZXZlbCA9IHRoaXMuZ2V0TmV4dEFCUkF1dG9MZXZlbCgpOyAvLyBpZiBmb3JjZWQgYXV0byBsZXZlbCBoYXMgYmVlbiBkZWZpbmVkLCB1c2UgaXQgdG8gY2FwIEFCUiBjb21wdXRlZCBxdWFsaXR5IGxldmVsXG5cbiAgICAgIGlmIChmb3JjZWRBdXRvTGV2ZWwgIT09IC0xKSB7XG4gICAgICAgIG5leHRBQlJBdXRvTGV2ZWwgPSBNYXRoLm1pbihmb3JjZWRBdXRvTGV2ZWwsIG5leHRBQlJBdXRvTGV2ZWwpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV4dEFCUkF1dG9MZXZlbDtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KG5leHRMZXZlbCkge1xuICAgICAgdGhpcy5fbmV4dEF1dG9MZXZlbCA9IG5leHRMZXZlbDtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQWJyQ29udHJvbGxlcjtcbn0oKTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChBYnJDb250cm9sbGVyKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY29udHJvbGxlci9hdWRpby1zdHJlYW0tY29udHJvbGxlci50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbnRyb2xsZXIvYXVkaW8tc3RyZWFtLWNvbnRyb2xsZXIudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9ob21lX3J1bm5lcl93b3JrX2hsc19qc19obHNfanNfc3JjX3BvbHlmaWxsc19udW1iZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc3JjL3BvbHlmaWxscy9udW1iZXIgKi8gXCIuL3NyYy9wb2x5ZmlsbHMvbnVtYmVyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9iYXNlX3N0cmVhbV9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2Jhc2Utc3RyZWFtLWNvbnRyb2xsZXIgKi8gXCIuL3NyYy9jb250cm9sbGVyL2Jhc2Utc3RyZWFtLWNvbnRyb2xsZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZXZlbnRzICovIFwiLi9zcmMvZXZlbnRzLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19idWZmZXJfaGVscGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9idWZmZXItaGVscGVyICovIFwiLi9zcmMvdXRpbHMvYnVmZmVyLWhlbHBlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZnJhZ21lbnRfdHJhY2tlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9mcmFnbWVudC10cmFja2VyICovIFwiLi9zcmMvY29udHJvbGxlci9mcmFnbWVudC10cmFja2VyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF90eXBlc19sZXZlbF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdHlwZXMvbGV2ZWwgKi8gXCIuL3NyYy90eXBlcy9sZXZlbC50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdHlwZXNfbG9hZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi90eXBlcy9sb2FkZXIgKi8gXCIuL3NyYy90eXBlcy9sb2FkZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2xvYWRlcl9mcmFnbWVudF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vbG9hZGVyL2ZyYWdtZW50ICovIFwiLi9zcmMvbG9hZGVyL2ZyYWdtZW50LnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9kZW11eF9jaHVua19jYWNoZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZGVtdXgvY2h1bmstY2FjaGUgKi8gXCIuL3NyYy9kZW11eC9jaHVuay1jYWNoZS50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZGVtdXhfdHJhbnNtdXhlcl9pbnRlcmZhY2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzlfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2RlbXV4L3RyYW5zbXV4ZXItaW50ZXJmYWNlICovIFwiLi9zcmMvZGVtdXgvdHJhbnNtdXhlci1pbnRlcmZhY2UudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3R5cGVzX3RyYW5zbXV4ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEwX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi90eXBlcy90cmFuc211eGVyICovIFwiLi9zcmMvdHlwZXMvdHJhbnNtdXhlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZnJhZ21lbnRfZmluZGVyc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZnJhZ21lbnQtZmluZGVycyAqLyBcIi4vc3JjL2NvbnRyb2xsZXIvZnJhZ21lbnQtZmluZGVycy50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfZGlzY29udGludWl0aWVzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvZGlzY29udGludWl0aWVzICovIFwiLi9zcmMvdXRpbHMvZGlzY29udGludWl0aWVzLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEzX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9lcnJvcnMgKi8gXCIuL3NyYy9lcnJvcnMudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL2xvZ2dlciAqLyBcIi4vc3JjL3V0aWxzL2xvZ2dlci50c1wiKTtcblxuXG5mdW5jdGlvbiBfZXh0ZW5kcygpIHsgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTsgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7IF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbnZhciBUSUNLX0lOVEVSVkFMID0gMTAwOyAvLyBob3cgb2Z0ZW4gdG8gdGljayBpbiBtc1xuXG52YXIgQXVkaW9TdHJlYW1Db250cm9sbGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQmFzZVN0cmVhbUNvbnRyb2xsZXIpIHtcbiAgX2luaGVyaXRzTG9vc2UoQXVkaW9TdHJlYW1Db250cm9sbGVyLCBfQmFzZVN0cmVhbUNvbnRyb2xsZXIpO1xuXG4gIGZ1bmN0aW9uIEF1ZGlvU3RyZWFtQ29udHJvbGxlcihobHMsIGZyYWdtZW50VHJhY2tlcikge1xuICAgIHZhciBfdGhpcztcblxuICAgIF90aGlzID0gX0Jhc2VTdHJlYW1Db250cm9sbGVyLmNhbGwodGhpcywgaGxzLCBmcmFnbWVudFRyYWNrZXIsICdbYXVkaW8tc3RyZWFtLWNvbnRyb2xsZXJdJykgfHwgdGhpcztcbiAgICBfdGhpcy52aWRlb0J1ZmZlciA9IG51bGw7XG4gICAgX3RoaXMudmlkZW9UcmFja0NDID0gLTE7XG4gICAgX3RoaXMud2FpdGluZ1ZpZGVvQ0MgPSAtMTtcbiAgICBfdGhpcy5hdWRpb1N3aXRjaCA9IGZhbHNlO1xuICAgIF90aGlzLnRyYWNrSWQgPSAtMTtcbiAgICBfdGhpcy53YWl0aW5nRGF0YSA9IG51bGw7XG4gICAgX3RoaXMubWFpbkRldGFpbHMgPSBudWxsO1xuICAgIF90aGlzLmJ1ZmZlckZsdXNoZWQgPSBmYWxzZTtcblxuICAgIF90aGlzLl9yZWdpc3Rlckxpc3RlbmVycygpO1xuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IEF1ZGlvU3RyZWFtQ29udHJvbGxlci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLm9uSGFuZGxlckRlc3Ryb3lpbmcgPSBmdW5jdGlvbiBvbkhhbmRsZXJEZXN0cm95aW5nKCkge1xuICAgIHRoaXMuX3VucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcblxuICAgIHRoaXMubWFpbkRldGFpbHMgPSBudWxsO1xuICB9O1xuXG4gIF9wcm90by5fcmVnaXN0ZXJMaXN0ZW5lcnMgPSBmdW5jdGlvbiBfcmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgdmFyIGhscyA9IHRoaXMuaGxzO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJFdmVudHNcIl0uTUVESUFfQVRUQUNIRUQsIHRoaXMub25NZWRpYUF0dGFjaGVkLCB0aGlzKTtcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiRXZlbnRzXCJdLk1FRElBX0RFVEFDSElORywgdGhpcy5vbk1lZGlhRGV0YWNoaW5nLCB0aGlzKTtcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiRXZlbnRzXCJdLk1BTklGRVNUX0xPQURJTkcsIHRoaXMub25NYW5pZmVzdExvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJFdmVudHNcIl0uTEVWRUxfTE9BREVELCB0aGlzLm9uTGV2ZWxMb2FkZWQsIHRoaXMpO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJFdmVudHNcIl0uQVVESU9fVFJBQ0tTX1VQREFURUQsIHRoaXMub25BdWRpb1RyYWNrc1VwZGF0ZWQsIHRoaXMpO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJFdmVudHNcIl0uQVVESU9fVFJBQ0tfU1dJVENISU5HLCB0aGlzLm9uQXVkaW9UcmFja1N3aXRjaGluZywgdGhpcyk7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcIkV2ZW50c1wiXS5BVURJT19UUkFDS19MT0FERUQsIHRoaXMub25BdWRpb1RyYWNrTG9hZGVkLCB0aGlzKTtcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiRXZlbnRzXCJdLkVSUk9SLCB0aGlzLm9uRXJyb3IsIHRoaXMpO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJFdmVudHNcIl0uQlVGRkVSX1JFU0VULCB0aGlzLm9uQnVmZmVyUmVzZXQsIHRoaXMpO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJFdmVudHNcIl0uQlVGRkVSX0NSRUFURUQsIHRoaXMub25CdWZmZXJDcmVhdGVkLCB0aGlzKTtcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiRXZlbnRzXCJdLkJVRkZFUl9GTFVTSEVELCB0aGlzLm9uQnVmZmVyRmx1c2hlZCwgdGhpcyk7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcIkV2ZW50c1wiXS5JTklUX1BUU19GT1VORCwgdGhpcy5vbkluaXRQdHNGb3VuZCwgdGhpcyk7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcIkV2ZW50c1wiXS5GUkFHX0JVRkZFUkVELCB0aGlzLm9uRnJhZ0J1ZmZlcmVkLCB0aGlzKTtcbiAgfTtcblxuICBfcHJvdG8uX3VucmVnaXN0ZXJMaXN0ZW5lcnMgPSBmdW5jdGlvbiBfdW5yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICB2YXIgaGxzID0gdGhpcy5obHM7XG4gICAgaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJFdmVudHNcIl0uTUVESUFfQVRUQUNIRUQsIHRoaXMub25NZWRpYUF0dGFjaGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcIkV2ZW50c1wiXS5NRURJQV9ERVRBQ0hJTkcsIHRoaXMub25NZWRpYURldGFjaGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJFdmVudHNcIl0uTUFOSUZFU1RfTE9BRElORywgdGhpcy5vbk1hbmlmZXN0TG9hZGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJFdmVudHNcIl0uTEVWRUxfTE9BREVELCB0aGlzLm9uTGV2ZWxMb2FkZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiRXZlbnRzXCJdLkFVRElPX1RSQUNLU19VUERBVEVELCB0aGlzLm9uQXVkaW9UcmFja3NVcGRhdGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcIkV2ZW50c1wiXS5BVURJT19UUkFDS19TV0lUQ0hJTkcsIHRoaXMub25BdWRpb1RyYWNrU3dpdGNoaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcIkV2ZW50c1wiXS5BVURJT19UUkFDS19MT0FERUQsIHRoaXMub25BdWRpb1RyYWNrTG9hZGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcIkV2ZW50c1wiXS5FUlJPUiwgdGhpcy5vbkVycm9yLCB0aGlzKTtcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcIkV2ZW50c1wiXS5CVUZGRVJfUkVTRVQsIHRoaXMub25CdWZmZXJSZXNldCwgdGhpcyk7XG4gICAgaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJFdmVudHNcIl0uQlVGRkVSX0NSRUFURUQsIHRoaXMub25CdWZmZXJDcmVhdGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcIkV2ZW50c1wiXS5CVUZGRVJfRkxVU0hFRCwgdGhpcy5vbkJ1ZmZlckZsdXNoZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiRXZlbnRzXCJdLklOSVRfUFRTX0ZPVU5ELCB0aGlzLm9uSW5pdFB0c0ZvdW5kLCB0aGlzKTtcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcIkV2ZW50c1wiXS5GUkFHX0JVRkZFUkVELCB0aGlzLm9uRnJhZ0J1ZmZlcmVkLCB0aGlzKTtcbiAgfSAvLyBJTklUX1BUU19GT1VORCBpcyB0cmlnZ2VyZWQgd2hlbiB0aGUgdmlkZW8gdHJhY2sgcGFyc2VkIGluIHRoZSBzdHJlYW0tY29udHJvbGxlciBoYXMgYSBuZXcgUFRTIHZhbHVlXG4gIDtcblxuICBfcHJvdG8ub25Jbml0UHRzRm91bmQgPSBmdW5jdGlvbiBvbkluaXRQdHNGb3VuZChldmVudCwgX3JlZikge1xuICAgIHZhciBmcmFnID0gX3JlZi5mcmFnLFxuICAgICAgICBpZCA9IF9yZWYuaWQsXG4gICAgICAgIGluaXRQVFMgPSBfcmVmLmluaXRQVFM7XG5cbiAgICAvLyBBbHdheXMgdXBkYXRlIHRoZSBuZXcgSU5JVCBQVFNcbiAgICAvLyBDYW4gY2hhbmdlIGR1ZSBsZXZlbCBzd2l0Y2hcbiAgICBpZiAoaWQgPT09ICdtYWluJykge1xuICAgICAgdmFyIGNjID0gZnJhZy5jYztcbiAgICAgIHRoaXMuaW5pdFBUU1tmcmFnLmNjXSA9IGluaXRQVFM7XG4gICAgICB0aGlzLmxvZyhcIkluaXRQVFMgZm9yIGNjOiBcIiArIGNjICsgXCIgZm91bmQgZnJvbSBtYWluOiBcIiArIGluaXRQVFMpO1xuICAgICAgdGhpcy52aWRlb1RyYWNrQ0MgPSBjYzsgLy8gSWYgd2UgYXJlIHdhaXRpbmcsIHRpY2sgaW1tZWRpYXRlbHkgdG8gdW5ibG9jayBhdWRpbyBmcmFnbWVudCB0cmFuc211eGluZ1xuXG4gICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gX2Jhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIlN0YXRlXCJdLldBSVRJTkdfSU5JVF9QVFMpIHtcbiAgICAgICAgdGhpcy50aWNrKCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5zdGFydExvYWQgPSBmdW5jdGlvbiBzdGFydExvYWQoc3RhcnRQb3NpdGlvbikge1xuICAgIGlmICghdGhpcy5sZXZlbHMpIHtcbiAgICAgIHRoaXMuc3RhcnRQb3NpdGlvbiA9IHN0YXJ0UG9zaXRpb247XG4gICAgICB0aGlzLnN0YXRlID0gX2Jhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIlN0YXRlXCJdLlNUT1BQRUQ7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGxhc3RDdXJyZW50VGltZSA9IHRoaXMubGFzdEN1cnJlbnRUaW1lO1xuICAgIHRoaXMuc3RvcExvYWQoKTtcbiAgICB0aGlzLnNldEludGVydmFsKFRJQ0tfSU5URVJWQUwpO1xuICAgIHRoaXMuZnJhZ0xvYWRFcnJvciA9IDA7XG5cbiAgICBpZiAobGFzdEN1cnJlbnRUaW1lID4gMCAmJiBzdGFydFBvc2l0aW9uID09PSAtMSkge1xuICAgICAgdGhpcy5sb2coXCJPdmVycmlkZSBzdGFydFBvc2l0aW9uIHdpdGggbGFzdEN1cnJlbnRUaW1lIEBcIiArIGxhc3RDdXJyZW50VGltZS50b0ZpeGVkKDMpKTtcbiAgICAgIHRoaXMuc3RhdGUgPSBfYmFzZV9zdHJlYW1fY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiU3RhdGVcIl0uSURMRTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5sb2FkZWRtZXRhZGF0YSA9IGZhbHNlO1xuICAgICAgdGhpcy5zdGF0ZSA9IF9iYXNlX3N0cmVhbV9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJTdGF0ZVwiXS5XQUlUSU5HX1RSQUNLO1xuICAgIH1cblxuICAgIHRoaXMubmV4dExvYWRQb3NpdGlvbiA9IHRoaXMuc3RhcnRQb3NpdGlvbiA9IHRoaXMubGFzdEN1cnJlbnRUaW1lID0gc3RhcnRQb3NpdGlvbjtcbiAgICB0aGlzLnRpY2soKTtcbiAgfTtcblxuICBfcHJvdG8uZG9UaWNrID0gZnVuY3Rpb24gZG9UaWNrKCkge1xuICAgIHN3aXRjaCAodGhpcy5zdGF0ZSkge1xuICAgICAgY2FzZSBfYmFzZV9zdHJlYW1fY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiU3RhdGVcIl0uSURMRTpcbiAgICAgICAgdGhpcy5kb1RpY2tJZGxlKCk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIF9iYXNlX3N0cmVhbV9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJTdGF0ZVwiXS5XQUlUSU5HX1RSQUNLOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIF9sZXZlbHMkdHJhY2tJZDtcblxuICAgICAgICAgIHZhciBsZXZlbHMgPSB0aGlzLmxldmVscyxcbiAgICAgICAgICAgICAgdHJhY2tJZCA9IHRoaXMudHJhY2tJZDtcbiAgICAgICAgICB2YXIgZGV0YWlscyA9IGxldmVscyA9PT0gbnVsbCB8fCBsZXZlbHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfbGV2ZWxzJHRyYWNrSWQgPSBsZXZlbHNbdHJhY2tJZF0pID09PSBudWxsIHx8IF9sZXZlbHMkdHJhY2tJZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2xldmVscyR0cmFja0lkLmRldGFpbHM7XG5cbiAgICAgICAgICBpZiAoZGV0YWlscykge1xuICAgICAgICAgICAgaWYgKHRoaXMud2FpdEZvckNkblR1bmVJbihkZXRhaWxzKSkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IF9iYXNlX3N0cmVhbV9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJTdGF0ZVwiXS5XQUlUSU5HX0lOSVRfUFRTO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgX2Jhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIlN0YXRlXCJdLkZSQUdfTE9BRElOR19XQUlUSU5HX1JFVFJZOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIF90aGlzJG1lZGlhO1xuXG4gICAgICAgICAgdmFyIG5vdyA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICAgIHZhciByZXRyeURhdGUgPSB0aGlzLnJldHJ5RGF0ZTsgLy8gaWYgY3VycmVudCB0aW1lIGlzIGd0IHRoYW4gcmV0cnlEYXRlLCBvciBpZiBtZWRpYSBzZWVraW5nIGxldCdzIHN3aXRjaCB0byBJRExFIHN0YXRlIHRvIHJldHJ5IGxvYWRpbmdcblxuICAgICAgICAgIGlmICghcmV0cnlEYXRlIHx8IG5vdyA+PSByZXRyeURhdGUgfHwgKF90aGlzJG1lZGlhID0gdGhpcy5tZWRpYSkgIT09IG51bGwgJiYgX3RoaXMkbWVkaWEgIT09IHZvaWQgMCAmJiBfdGhpcyRtZWRpYS5zZWVraW5nKSB7XG4gICAgICAgICAgICB0aGlzLmxvZygnUmV0cnlEYXRlIHJlYWNoZWQsIHN3aXRjaCBiYWNrIHRvIElETEUgc3RhdGUnKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBfYmFzZV9zdHJlYW1fY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiU3RhdGVcIl0uSURMRTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIF9iYXNlX3N0cmVhbV9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJTdGF0ZVwiXS5XQUlUSU5HX0lOSVRfUFRTOlxuICAgICAgICB7XG4gICAgICAgICAgLy8gRW5zdXJlIHdlIGRvbid0IGdldCBzdHVjayBpbiB0aGUgV0FJVElOR19JTklUX1BUUyBzdGF0ZSBpZiB0aGUgd2FpdGluZyBmcmFnIENDIGRvZXNuJ3QgbWF0Y2ggYW55IGluaXRQVFNcbiAgICAgICAgICB2YXIgd2FpdGluZ0RhdGEgPSB0aGlzLndhaXRpbmdEYXRhO1xuXG4gICAgICAgICAgaWYgKHdhaXRpbmdEYXRhKSB7XG4gICAgICAgICAgICB2YXIgZnJhZyA9IHdhaXRpbmdEYXRhLmZyYWcsXG4gICAgICAgICAgICAgICAgcGFydCA9IHdhaXRpbmdEYXRhLnBhcnQsXG4gICAgICAgICAgICAgICAgY2FjaGUgPSB3YWl0aW5nRGF0YS5jYWNoZSxcbiAgICAgICAgICAgICAgICBjb21wbGV0ZSA9IHdhaXRpbmdEYXRhLmNvbXBsZXRlO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5pbml0UFRTW2ZyYWcuY2NdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgdGhpcy53YWl0aW5nRGF0YSA9IG51bGw7XG4gICAgICAgICAgICAgIHRoaXMud2FpdGluZ1ZpZGVvQ0MgPSAtMTtcbiAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IF9iYXNlX3N0cmVhbV9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJTdGF0ZVwiXS5GUkFHX0xPQURJTkc7XG4gICAgICAgICAgICAgIHZhciBwYXlsb2FkID0gY2FjaGUuZmx1c2goKTtcbiAgICAgICAgICAgICAgdmFyIGRhdGEgPSB7XG4gICAgICAgICAgICAgICAgZnJhZzogZnJhZyxcbiAgICAgICAgICAgICAgICBwYXJ0OiBwYXJ0LFxuICAgICAgICAgICAgICAgIHBheWxvYWQ6IHBheWxvYWQsXG4gICAgICAgICAgICAgICAgbmV0d29ya0RldGFpbHM6IG51bGxcbiAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVGcmFnbWVudExvYWRQcm9ncmVzcyhkYXRhKTtcblxuICAgICAgICAgICAgICBpZiAoY29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICBfQmFzZVN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLl9oYW5kbGVGcmFnbWVudExvYWRDb21wbGV0ZS5jYWxsKHRoaXMsIGRhdGEpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMudmlkZW9UcmFja0NDICE9PSB0aGlzLndhaXRpbmdWaWRlb0NDKSB7XG4gICAgICAgICAgICAgIC8vIERyb3Agd2FpdGluZyBmcmFnbWVudCBpZiB2aWRlb1RyYWNrQ0MgaGFzIGNoYW5nZWQgc2luY2Ugd2FpdGluZ0ZyYWdtZW50IHdhcyBzZXQgYW5kIGluaXRQVFMgd2FzIG5vdCBmb3VuZFxuICAgICAgICAgICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xNF9fW1wibG9nZ2VyXCJdLmxvZyhcIldhaXRpbmcgZnJhZ21lbnQgY2MgKFwiICsgZnJhZy5jYyArIFwiKSBjYW5jZWxsZWQgYmVjYXVzZSB2aWRlbyBpcyBhdCBjYyBcIiArIHRoaXMudmlkZW9UcmFja0NDKTtcbiAgICAgICAgICAgICAgdGhpcy5jbGVhcldhaXRpbmdGcmFnbWVudCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gRHJvcCB3YWl0aW5nIGZyYWdtZW50IGlmIGFuIGVhcmxpZXIgZnJhZ21lbnQgaXMgbmVlZGVkXG4gICAgICAgICAgICAgIHZhciBwb3MgPSB0aGlzLmdldExvYWRQb3NpdGlvbigpO1xuICAgICAgICAgICAgICB2YXIgYnVmZmVySW5mbyA9IF91dGlsc19idWZmZXJfaGVscGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJCdWZmZXJIZWxwZXJcIl0uYnVmZmVySW5mbyh0aGlzLm1lZGlhQnVmZmVyLCBwb3MsIHRoaXMuY29uZmlnLm1heEJ1ZmZlckhvbGUpO1xuICAgICAgICAgICAgICB2YXIgd2FpdGluZ0ZyYWdtZW50QXRQb3NpdGlvbiA9IE9iamVjdChfZnJhZ21lbnRfZmluZGVyc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTFfX1tcImZyYWdtZW50V2l0aGluVG9sZXJhbmNlVGVzdFwiXSkoYnVmZmVySW5mby5lbmQsIHRoaXMuY29uZmlnLm1heEZyYWdMb29rVXBUb2xlcmFuY2UsIGZyYWcpO1xuXG4gICAgICAgICAgICAgIGlmICh3YWl0aW5nRnJhZ21lbnRBdFBvc2l0aW9uIDwgMCkge1xuICAgICAgICAgICAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzE0X19bXCJsb2dnZXJcIl0ubG9nKFwiV2FpdGluZyBmcmFnbWVudCBjYyAoXCIgKyBmcmFnLmNjICsgXCIpIEAgXCIgKyBmcmFnLnN0YXJ0ICsgXCIgY2FuY2VsbGVkIGJlY2F1c2UgYW5vdGhlciBmcmFnbWVudCBhdCBcIiArIGJ1ZmZlckluZm8uZW5kICsgXCIgaXMgbmVlZGVkXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJXYWl0aW5nRnJhZ21lbnQoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gX2Jhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIlN0YXRlXCJdLklETEU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5vblRpY2tFbmQoKTtcbiAgfTtcblxuICBfcHJvdG8uY2xlYXJXYWl0aW5nRnJhZ21lbnQgPSBmdW5jdGlvbiBjbGVhcldhaXRpbmdGcmFnbWVudCgpIHtcbiAgICB2YXIgd2FpdGluZ0RhdGEgPSB0aGlzLndhaXRpbmdEYXRhO1xuXG4gICAgaWYgKHdhaXRpbmdEYXRhKSB7XG4gICAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5yZW1vdmVGcmFnbWVudCh3YWl0aW5nRGF0YS5mcmFnKTtcbiAgICAgIHRoaXMud2FpdGluZ0RhdGEgPSBudWxsO1xuICAgICAgdGhpcy53YWl0aW5nVmlkZW9DQyA9IC0xO1xuICAgICAgdGhpcy5zdGF0ZSA9IF9iYXNlX3N0cmVhbV9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJTdGF0ZVwiXS5JRExFO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8ub25UaWNrRW5kID0gZnVuY3Rpb24gb25UaWNrRW5kKCkge1xuICAgIHZhciBtZWRpYSA9IHRoaXMubWVkaWE7XG5cbiAgICBpZiAoIW1lZGlhIHx8ICFtZWRpYS5yZWFkeVN0YXRlKSB7XG4gICAgICAvLyBFeGl0IGVhcmx5IGlmIHdlIGRvbid0IGhhdmUgbWVkaWEgb3IgaWYgdGhlIG1lZGlhIGhhc24ndCBidWZmZXJlZCBhbnl0aGluZyB5ZXQgKHJlYWR5U3RhdGUgMClcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbWVkaWFCdWZmZXIgPSB0aGlzLm1lZGlhQnVmZmVyID8gdGhpcy5tZWRpYUJ1ZmZlciA6IG1lZGlhO1xuICAgIHZhciBidWZmZXJlZCA9IG1lZGlhQnVmZmVyLmJ1ZmZlcmVkO1xuXG4gICAgaWYgKCF0aGlzLmxvYWRlZG1ldGFkYXRhICYmIGJ1ZmZlcmVkLmxlbmd0aCkge1xuICAgICAgdGhpcy5sb2FkZWRtZXRhZGF0YSA9IHRydWU7XG4gICAgfVxuXG4gICAgdGhpcy5sYXN0Q3VycmVudFRpbWUgPSBtZWRpYS5jdXJyZW50VGltZTtcbiAgfTtcblxuICBfcHJvdG8uZG9UaWNrSWRsZSA9IGZ1bmN0aW9uIGRvVGlja0lkbGUoKSB7XG4gICAgdmFyIF9mcmFnJGRlY3J5cHRkYXRhLCBfZnJhZyRkZWNyeXB0ZGF0YTI7XG5cbiAgICB2YXIgaGxzID0gdGhpcy5obHMsXG4gICAgICAgIGxldmVscyA9IHRoaXMubGV2ZWxzLFxuICAgICAgICBtZWRpYSA9IHRoaXMubWVkaWEsXG4gICAgICAgIHRyYWNrSWQgPSB0aGlzLnRyYWNrSWQ7XG4gICAgdmFyIGNvbmZpZyA9IGhscy5jb25maWc7XG5cbiAgICBpZiAoIWxldmVscyB8fCAhbGV2ZWxzW3RyYWNrSWRdKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBpZiB2aWRlbyBub3QgYXR0YWNoZWQgQU5EXG4gICAgLy8gc3RhcnQgZnJhZ21lbnQgYWxyZWFkeSByZXF1ZXN0ZWQgT1Igc3RhcnQgZnJhZyBwcmVmZXRjaCBub3QgZW5hYmxlZFxuICAgIC8vIGV4aXQgbG9vcFxuICAgIC8vID0+IGlmIG1lZGlhIG5vdCBhdHRhY2hlZCBidXQgc3RhcnQgZnJhZyBwcmVmZXRjaCBpcyBlbmFibGVkIGFuZCBzdGFydCBmcmFnIG5vdCByZXF1ZXN0ZWQgeWV0LCB3ZSB3aWxsIG5vdCBleGl0IGxvb3BcblxuXG4gICAgaWYgKCFtZWRpYSAmJiAodGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgfHwgIWNvbmZpZy5zdGFydEZyYWdQcmVmZXRjaCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbGV2ZWxJbmZvID0gbGV2ZWxzW3RyYWNrSWRdO1xuICAgIHZhciB0cmFja0RldGFpbHMgPSBsZXZlbEluZm8uZGV0YWlscztcblxuICAgIGlmICghdHJhY2tEZXRhaWxzIHx8IHRyYWNrRGV0YWlscy5saXZlICYmIHRoaXMubGV2ZWxMYXN0TG9hZGVkICE9PSB0cmFja0lkIHx8IHRoaXMud2FpdEZvckNkblR1bmVJbih0cmFja0RldGFpbHMpKSB7XG4gICAgICB0aGlzLnN0YXRlID0gX2Jhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIlN0YXRlXCJdLldBSVRJTkdfVFJBQ0s7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuYnVmZmVyRmx1c2hlZCkge1xuICAgICAgdGhpcy5idWZmZXJGbHVzaGVkID0gZmFsc2U7XG4gICAgICB0aGlzLmFmdGVyQnVmZmVyRmx1c2hlZCh0aGlzLm1lZGlhQnVmZmVyID8gdGhpcy5tZWRpYUJ1ZmZlciA6IHRoaXMubWVkaWEsIF9sb2FkZXJfZnJhZ21lbnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1tcIkVsZW1lbnRhcnlTdHJlYW1UeXBlc1wiXS5BVURJTywgX3R5cGVzX2xvYWRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fW1wiUGxheWxpc3RMZXZlbFR5cGVcIl0uQVVESU8pO1xuICAgIH1cblxuICAgIHZhciBidWZmZXJJbmZvID0gdGhpcy5nZXRGd2RCdWZmZXJJbmZvKHRoaXMubWVkaWFCdWZmZXIgPyB0aGlzLm1lZGlhQnVmZmVyIDogdGhpcy5tZWRpYSwgX3R5cGVzX2xvYWRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fW1wiUGxheWxpc3RMZXZlbFR5cGVcIl0uQVVESU8pO1xuXG4gICAgaWYgKGJ1ZmZlckluZm8gPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgYnVmZmVyTGVuID0gYnVmZmVySW5mby5sZW47XG4gICAgdmFyIG1heEJ1ZkxlbiA9IHRoaXMuZ2V0TWF4QnVmZmVyTGVuZ3RoKCk7XG4gICAgdmFyIGF1ZGlvU3dpdGNoID0gdGhpcy5hdWRpb1N3aXRjaDsgLy8gaWYgYnVmZmVyIGxlbmd0aCBpcyBsZXNzIHRoYW4gbWF4QnVmTGVuIHRyeSB0byBsb2FkIGEgbmV3IGZyYWdtZW50XG5cbiAgICBpZiAoYnVmZmVyTGVuID49IG1heEJ1ZkxlbiAmJiAhYXVkaW9Td2l0Y2gpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIWF1ZGlvU3dpdGNoICYmIHRoaXMuX3N0cmVhbUVuZGVkKGJ1ZmZlckluZm8sIHRyYWNrRGV0YWlscykpIHtcbiAgICAgIGhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcIkV2ZW50c1wiXS5CVUZGRVJfRU9TLCB7XG4gICAgICAgIHR5cGU6ICdhdWRpbydcbiAgICAgIH0pO1xuICAgICAgdGhpcy5zdGF0ZSA9IF9iYXNlX3N0cmVhbV9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJTdGF0ZVwiXS5FTkRFRDtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZnJhZ21lbnRzID0gdHJhY2tEZXRhaWxzLmZyYWdtZW50cztcbiAgICB2YXIgc3RhcnQgPSBmcmFnbWVudHNbMF0uc3RhcnQ7XG4gICAgdmFyIHRhcmdldEJ1ZmZlclRpbWUgPSBidWZmZXJJbmZvLmVuZDtcblxuICAgIGlmIChhdWRpb1N3aXRjaCkge1xuICAgICAgdmFyIHBvcyA9IHRoaXMuZ2V0TG9hZFBvc2l0aW9uKCk7XG4gICAgICB0YXJnZXRCdWZmZXJUaW1lID0gcG9zOyAvLyBpZiBjdXJyZW50VGltZSAocG9zKSBpcyBsZXNzIHRoYW4gYWx0IGF1ZGlvIHBsYXlsaXN0IHN0YXJ0IHRpbWUsIGl0IG1lYW5zIHRoYXQgYWx0IGF1ZGlvIGlzIGFoZWFkIG9mIGN1cnJlbnRUaW1lXG5cbiAgICAgIGlmICh0cmFja0RldGFpbHMuUFRTS25vd24gJiYgcG9zIDwgc3RhcnQpIHtcbiAgICAgICAgLy8gaWYgZXZlcnl0aGluZyBpcyBidWZmZXJlZCBmcm9tIHBvcyB0byBzdGFydCBvciBpZiBhdWRpbyBidWZmZXIgdXBmcm9udCwgbGV0J3Mgc2VlayB0byBzdGFydFxuICAgICAgICBpZiAoYnVmZmVySW5mby5lbmQgPiBzdGFydCB8fCBidWZmZXJJbmZvLm5leHRTdGFydCkge1xuICAgICAgICAgIHRoaXMubG9nKCdBbHQgYXVkaW8gdHJhY2sgYWhlYWQgb2YgbWFpbiB0cmFjaywgc2VlayB0byBzdGFydCBvZiBhbHQgYXVkaW8gdHJhY2snKTtcbiAgICAgICAgICBtZWRpYS5jdXJyZW50VGltZSA9IHN0YXJ0ICsgMC4wNTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBmcmFnID0gdGhpcy5nZXROZXh0RnJhZ21lbnQodGFyZ2V0QnVmZmVyVGltZSwgdHJhY2tEZXRhaWxzKTtcblxuICAgIGlmICghZnJhZykge1xuICAgICAgdGhpcy5idWZmZXJGbHVzaGVkID0gdHJ1ZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoKChfZnJhZyRkZWNyeXB0ZGF0YSA9IGZyYWcuZGVjcnlwdGRhdGEpID09PSBudWxsIHx8IF9mcmFnJGRlY3J5cHRkYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZnJhZyRkZWNyeXB0ZGF0YS5rZXlGb3JtYXQpID09PSAnaWRlbnRpdHknICYmICEoKF9mcmFnJGRlY3J5cHRkYXRhMiA9IGZyYWcuZGVjcnlwdGRhdGEpICE9PSBudWxsICYmIF9mcmFnJGRlY3J5cHRkYXRhMiAhPT0gdm9pZCAwICYmIF9mcmFnJGRlY3J5cHRkYXRhMi5rZXkpKSB7XG4gICAgICB0aGlzLmxvYWRLZXkoZnJhZywgdHJhY2tEZXRhaWxzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5sb2FkRnJhZ21lbnQoZnJhZywgdHJhY2tEZXRhaWxzLCB0YXJnZXRCdWZmZXJUaW1lKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmdldE1heEJ1ZmZlckxlbmd0aCA9IGZ1bmN0aW9uIGdldE1heEJ1ZmZlckxlbmd0aCgpIHtcbiAgICB2YXIgbWF4Q29uZmlnQnVmZmVyID0gX0Jhc2VTdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZS5nZXRNYXhCdWZmZXJMZW5ndGguY2FsbCh0aGlzKTtcblxuICAgIHZhciBtYWluQnVmZmVySW5mbyA9IHRoaXMuZ2V0RndkQnVmZmVySW5mbyh0aGlzLnZpZGVvQnVmZmVyID8gdGhpcy52aWRlb0J1ZmZlciA6IHRoaXMubWVkaWEsIF90eXBlc19sb2FkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcIlBsYXlsaXN0TGV2ZWxUeXBlXCJdLk1BSU4pO1xuXG4gICAgaWYgKG1haW5CdWZmZXJJbmZvID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gbWF4Q29uZmlnQnVmZmVyO1xuICAgIH1cblxuICAgIHJldHVybiBNYXRoLm1heChtYXhDb25maWdCdWZmZXIsIG1haW5CdWZmZXJJbmZvLmxlbik7XG4gIH07XG5cbiAgX3Byb3RvLm9uTWVkaWFEZXRhY2hpbmcgPSBmdW5jdGlvbiBvbk1lZGlhRGV0YWNoaW5nKCkge1xuICAgIHRoaXMudmlkZW9CdWZmZXIgPSBudWxsO1xuXG4gICAgX0Jhc2VTdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZS5vbk1lZGlhRGV0YWNoaW5nLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgX3Byb3RvLm9uQXVkaW9UcmFja3NVcGRhdGVkID0gZnVuY3Rpb24gb25BdWRpb1RyYWNrc1VwZGF0ZWQoZXZlbnQsIF9yZWYyKSB7XG4gICAgdmFyIGF1ZGlvVHJhY2tzID0gX3JlZjIuYXVkaW9UcmFja3M7XG4gICAgdGhpcy5yZXNldFRyYW5zbXV4ZXIoKTtcbiAgICB0aGlzLmxldmVscyA9IGF1ZGlvVHJhY2tzLm1hcChmdW5jdGlvbiAobWVkaWFQbGF5bGlzdCkge1xuICAgICAgcmV0dXJuIG5ldyBfdHlwZXNfbGV2ZWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcIkxldmVsXCJdKG1lZGlhUGxheWxpc3QpO1xuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90by5vbkF1ZGlvVHJhY2tTd2l0Y2hpbmcgPSBmdW5jdGlvbiBvbkF1ZGlvVHJhY2tTd2l0Y2hpbmcoZXZlbnQsIGRhdGEpIHtcbiAgICAvLyBpZiBhbnkgVVJMIGZvdW5kIG9uIG5ldyBhdWRpbyB0cmFjaywgaXQgaXMgYW4gYWx0ZXJuYXRlIGF1ZGlvIHRyYWNrXG4gICAgdmFyIGFsdEF1ZGlvID0gISFkYXRhLnVybDtcbiAgICB0aGlzLnRyYWNrSWQgPSBkYXRhLmlkO1xuICAgIHZhciBmcmFnQ3VycmVudCA9IHRoaXMuZnJhZ0N1cnJlbnQ7XG5cbiAgICBpZiAoZnJhZ0N1cnJlbnQgIT09IG51bGwgJiYgZnJhZ0N1cnJlbnQgIT09IHZvaWQgMCAmJiBmcmFnQ3VycmVudC5sb2FkZXIpIHtcbiAgICAgIGZyYWdDdXJyZW50LmxvYWRlci5hYm9ydCgpO1xuICAgIH1cblxuICAgIHRoaXMuZnJhZ0N1cnJlbnQgPSBudWxsO1xuICAgIHRoaXMuY2xlYXJXYWl0aW5nRnJhZ21lbnQoKTsgLy8gZGVzdHJveSB1c2VsZXNzIHRyYW5zbXV4ZXIgd2hlbiBzd2l0Y2hpbmcgYXVkaW8gdG8gbWFpblxuXG4gICAgaWYgKCFhbHRBdWRpbykge1xuICAgICAgdGhpcy5yZXNldFRyYW5zbXV4ZXIoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gc3dpdGNoaW5nIHRvIGF1ZGlvIHRyYWNrLCBzdGFydCB0aW1lciBpZiBub3QgYWxyZWFkeSBzdGFydGVkXG4gICAgICB0aGlzLnNldEludGVydmFsKFRJQ0tfSU5URVJWQUwpO1xuICAgIH0gLy8gc2hvdWxkIHdlIHN3aXRjaCB0cmFja3MgP1xuXG5cbiAgICBpZiAoYWx0QXVkaW8pIHtcbiAgICAgIHRoaXMuYXVkaW9Td2l0Y2ggPSB0cnVlOyAvLyBtYWluIGF1ZGlvIHRyYWNrIGFyZSBoYW5kbGVkIGJ5IHN0cmVhbS1jb250cm9sbGVyLCBqdXN0IGRvIHNvbWV0aGluZyBpZiBzd2l0Y2hpbmcgdG8gYWx0IGF1ZGlvIHRyYWNrXG5cbiAgICAgIHRoaXMuc3RhdGUgPSBfYmFzZV9zdHJlYW1fY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiU3RhdGVcIl0uSURMRTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zdGF0ZSA9IF9iYXNlX3N0cmVhbV9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJTdGF0ZVwiXS5TVE9QUEVEO1xuICAgIH1cblxuICAgIHRoaXMudGljaygpO1xuICB9O1xuXG4gIF9wcm90by5vbk1hbmlmZXN0TG9hZGluZyA9IGZ1bmN0aW9uIG9uTWFuaWZlc3RMb2FkaW5nKCkge1xuICAgIHRoaXMubWFpbkRldGFpbHMgPSBudWxsO1xuICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyLnJlbW92ZUFsbEZyYWdtZW50cygpO1xuICAgIHRoaXMuc3RhcnRQb3NpdGlvbiA9IHRoaXMubGFzdEN1cnJlbnRUaW1lID0gMDtcbiAgICB0aGlzLmJ1ZmZlckZsdXNoZWQgPSBmYWxzZTtcbiAgfTtcblxuICBfcHJvdG8ub25MZXZlbExvYWRlZCA9IGZ1bmN0aW9uIG9uTGV2ZWxMb2FkZWQoZXZlbnQsIGRhdGEpIHtcbiAgICB0aGlzLm1haW5EZXRhaWxzID0gZGF0YS5kZXRhaWxzO1xuICB9O1xuXG4gIF9wcm90by5vbkF1ZGlvVHJhY2tMb2FkZWQgPSBmdW5jdGlvbiBvbkF1ZGlvVHJhY2tMb2FkZWQoZXZlbnQsIGRhdGEpIHtcbiAgICB2YXIgX3RyYWNrJGRldGFpbHM7XG5cbiAgICB2YXIgbGV2ZWxzID0gdGhpcy5sZXZlbHM7XG4gICAgdmFyIG5ld0RldGFpbHMgPSBkYXRhLmRldGFpbHMsXG4gICAgICAgIHRyYWNrSWQgPSBkYXRhLmlkO1xuXG4gICAgaWYgKCFsZXZlbHMpIHtcbiAgICAgIHRoaXMud2FybihcIkF1ZGlvIHRyYWNrcyB3ZXJlIHJlc2V0IHdoaWxlIGxvYWRpbmcgbGV2ZWwgXCIgKyB0cmFja0lkKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmxvZyhcIlRyYWNrIFwiICsgdHJhY2tJZCArIFwiIGxvYWRlZCBbXCIgKyBuZXdEZXRhaWxzLnN0YXJ0U04gKyBcIixcIiArIG5ld0RldGFpbHMuZW5kU04gKyBcIl0sZHVyYXRpb246XCIgKyBuZXdEZXRhaWxzLnRvdGFsZHVyYXRpb24pO1xuICAgIHZhciB0cmFjayA9IGxldmVsc1t0cmFja0lkXTtcbiAgICB2YXIgc2xpZGluZyA9IDA7XG5cbiAgICBpZiAobmV3RGV0YWlscy5saXZlIHx8IChfdHJhY2skZGV0YWlscyA9IHRyYWNrLmRldGFpbHMpICE9PSBudWxsICYmIF90cmFjayRkZXRhaWxzICE9PSB2b2lkIDAgJiYgX3RyYWNrJGRldGFpbHMubGl2ZSkge1xuICAgICAgdmFyIG1haW5EZXRhaWxzID0gdGhpcy5tYWluRGV0YWlscztcblxuICAgICAgaWYgKCFuZXdEZXRhaWxzLmZyYWdtZW50c1swXSkge1xuICAgICAgICBuZXdEZXRhaWxzLmRlbHRhVXBkYXRlRmFpbGVkID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKG5ld0RldGFpbHMuZGVsdGFVcGRhdGVGYWlsZWQgfHwgIW1haW5EZXRhaWxzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0cmFjay5kZXRhaWxzICYmIG5ld0RldGFpbHMuaGFzUHJvZ3JhbURhdGVUaW1lICYmIG1haW5EZXRhaWxzLmhhc1Byb2dyYW1EYXRlVGltZSkge1xuICAgICAgICAvLyBNYWtlIHN1cmUgb3VyIGF1ZGlvIHJlbmRpdGlvbiBpcyBhbGlnbmVkIHdpdGggdGhlIFwibWFpblwiIHJlbmRpdGlvbiwgdXNpbmdcbiAgICAgICAgLy8gcGR0IGFzIG91ciByZWZlcmVuY2UgdGltZXMuXG4gICAgICAgIE9iamVjdChfdXRpbHNfZGlzY29udGludWl0aWVzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMl9fW1wiYWxpZ25NZWRpYVBsYXlsaXN0QnlQRFRcIl0pKG5ld0RldGFpbHMsIG1haW5EZXRhaWxzKTtcbiAgICAgICAgc2xpZGluZyA9IG5ld0RldGFpbHMuZnJhZ21lbnRzWzBdLnN0YXJ0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2xpZGluZyA9IHRoaXMuYWxpZ25QbGF5bGlzdHMobmV3RGV0YWlscywgdHJhY2suZGV0YWlscyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdHJhY2suZGV0YWlscyA9IG5ld0RldGFpbHM7XG4gICAgdGhpcy5sZXZlbExhc3RMb2FkZWQgPSB0cmFja0lkOyAvLyBjb21wdXRlIHN0YXJ0IHBvc2l0aW9uIGlmIHdlIGFyZSBhbGlnbmVkIHdpdGggdGhlIG1haW4gcGxheWxpc3RcblxuICAgIGlmICghdGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgJiYgKHRoaXMubWFpbkRldGFpbHMgfHwgIW5ld0RldGFpbHMubGl2ZSkpIHtcbiAgICAgIHRoaXMuc2V0U3RhcnRQb3NpdGlvbih0cmFjay5kZXRhaWxzLCBzbGlkaW5nKTtcbiAgICB9IC8vIG9ubHkgc3dpdGNoIGJhY2sgdG8gSURMRSBzdGF0ZSBpZiB3ZSB3ZXJlIHdhaXRpbmcgZm9yIHRyYWNrIHRvIHN0YXJ0IGRvd25sb2FkaW5nIGEgbmV3IGZyYWdtZW50XG5cblxuICAgIGlmICh0aGlzLnN0YXRlID09PSBfYmFzZV9zdHJlYW1fY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiU3RhdGVcIl0uV0FJVElOR19UUkFDSyAmJiAhdGhpcy53YWl0Rm9yQ2RuVHVuZUluKG5ld0RldGFpbHMpKSB7XG4gICAgICB0aGlzLnN0YXRlID0gX2Jhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIlN0YXRlXCJdLklETEU7XG4gICAgfSAvLyB0cmlnZ2VyIGhhbmRsZXIgcmlnaHQgbm93XG5cblxuICAgIHRoaXMudGljaygpO1xuICB9O1xuXG4gIF9wcm90by5faGFuZGxlRnJhZ21lbnRMb2FkUHJvZ3Jlc3MgPSBmdW5jdGlvbiBfaGFuZGxlRnJhZ21lbnRMb2FkUHJvZ3Jlc3MoZGF0YSkge1xuICAgIHZhciBfZnJhZyRpbml0U2VnbWVudDtcblxuICAgIHZhciBmcmFnID0gZGF0YS5mcmFnLFxuICAgICAgICBwYXJ0ID0gZGF0YS5wYXJ0LFxuICAgICAgICBwYXlsb2FkID0gZGF0YS5wYXlsb2FkO1xuICAgIHZhciBjb25maWcgPSB0aGlzLmNvbmZpZyxcbiAgICAgICAgdHJhY2tJZCA9IHRoaXMudHJhY2tJZCxcbiAgICAgICAgbGV2ZWxzID0gdGhpcy5sZXZlbHM7XG5cbiAgICBpZiAoIWxldmVscykge1xuICAgICAgdGhpcy53YXJuKFwiQXVkaW8gdHJhY2tzIHdlcmUgcmVzZXQgd2hpbGUgZnJhZ21lbnQgbG9hZCB3YXMgaW4gcHJvZ3Jlc3MuIEZyYWdtZW50IFwiICsgZnJhZy5zbiArIFwiIG9mIGxldmVsIFwiICsgZnJhZy5sZXZlbCArIFwiIHdpbGwgbm90IGJlIGJ1ZmZlcmVkXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB0cmFjayA9IGxldmVsc1t0cmFja0lkXTtcbiAgICBjb25zb2xlLmFzc2VydCh0cmFjaywgJ0F1ZGlvIHRyYWNrIGlzIGRlZmluZWQgb24gZnJhZ21lbnQgbG9hZCBwcm9ncmVzcycpO1xuICAgIHZhciBkZXRhaWxzID0gdHJhY2suZGV0YWlscztcbiAgICBjb25zb2xlLmFzc2VydChkZXRhaWxzLCAnQXVkaW8gdHJhY2sgZGV0YWlscyBhcmUgZGVmaW5lZCBvbiBmcmFnbWVudCBsb2FkIHByb2dyZXNzJyk7XG4gICAgdmFyIGF1ZGlvQ29kZWMgPSBjb25maWcuZGVmYXVsdEF1ZGlvQ29kZWMgfHwgdHJhY2suYXVkaW9Db2RlYyB8fCAnbXA0YS40MC4yJztcbiAgICB2YXIgdHJhbnNtdXhlciA9IHRoaXMudHJhbnNtdXhlcjtcblxuICAgIGlmICghdHJhbnNtdXhlcikge1xuICAgICAgdHJhbnNtdXhlciA9IHRoaXMudHJhbnNtdXhlciA9IG5ldyBfZGVtdXhfdHJhbnNtdXhlcl9pbnRlcmZhY2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzlfX1tcImRlZmF1bHRcIl0odGhpcy5obHMsIF90eXBlc19sb2FkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcIlBsYXlsaXN0TGV2ZWxUeXBlXCJdLkFVRElPLCB0aGlzLl9oYW5kbGVUcmFuc211eENvbXBsZXRlLmJpbmQodGhpcyksIHRoaXMuX2hhbmRsZVRyYW5zbXV4ZXJGbHVzaC5iaW5kKHRoaXMpKTtcbiAgICB9IC8vIENoZWNrIGlmIHdlIGhhdmUgdmlkZW8gaW5pdFBUU1xuICAgIC8vIElmIG5vdCB3ZSBuZWVkIHRvIHdhaXQgZm9yIGl0XG5cblxuICAgIHZhciBpbml0UFRTID0gdGhpcy5pbml0UFRTW2ZyYWcuY2NdO1xuICAgIHZhciBpbml0U2VnbWVudERhdGEgPSAoX2ZyYWckaW5pdFNlZ21lbnQgPSBmcmFnLmluaXRTZWdtZW50KSA9PT0gbnVsbCB8fCBfZnJhZyRpbml0U2VnbWVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2ZyYWckaW5pdFNlZ21lbnQuZGF0YTtcblxuICAgIGlmIChpbml0UFRTICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIHRoaXMubG9nKGBUcmFuc211eGluZyAke3NufSBvZiBbJHtkZXRhaWxzLnN0YXJ0U059ICwke2RldGFpbHMuZW5kU059XSx0cmFjayAke3RyYWNrSWR9YCk7XG4gICAgICAvLyB0aW1lIE9mZnNldCBpcyBhY2N1cmF0ZSBpZiBsZXZlbCBQVFMgaXMga25vd24sIG9yIGlmIHBsYXlsaXN0IGlzIG5vdCBzbGlkaW5nIChub3QgbGl2ZSlcbiAgICAgIHZhciBhY2N1cmF0ZVRpbWVPZmZzZXQgPSBmYWxzZTsgLy8gZGV0YWlscy5QVFNLbm93biB8fCAhZGV0YWlscy5saXZlO1xuXG4gICAgICB2YXIgcGFydEluZGV4ID0gcGFydCA/IHBhcnQuaW5kZXggOiAtMTtcbiAgICAgIHZhciBwYXJ0aWFsID0gcGFydEluZGV4ICE9PSAtMTtcbiAgICAgIHZhciBjaHVua01ldGEgPSBuZXcgX3R5cGVzX3RyYW5zbXV4ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEwX19bXCJDaHVua01ldGFkYXRhXCJdKGZyYWcubGV2ZWwsIGZyYWcuc24sIGZyYWcuc3RhdHMuY2h1bmtDb3VudCwgcGF5bG9hZC5ieXRlTGVuZ3RoLCBwYXJ0SW5kZXgsIHBhcnRpYWwpO1xuICAgICAgdHJhbnNtdXhlci5wdXNoKHBheWxvYWQsIGluaXRTZWdtZW50RGF0YSwgYXVkaW9Db2RlYywgJycsIGZyYWcsIHBhcnQsIGRldGFpbHMudG90YWxkdXJhdGlvbiwgYWNjdXJhdGVUaW1lT2Zmc2V0LCBjaHVua01ldGEsIGluaXRQVFMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xNF9fW1wibG9nZ2VyXCJdLmxvZyhcIlVua25vd24gdmlkZW8gUFRTIGZvciBjYyBcIiArIGZyYWcuY2MgKyBcIiwgd2FpdGluZyBmb3IgdmlkZW8gUFRTIGJlZm9yZSBkZW11eGluZyBhdWRpbyBmcmFnIFwiICsgZnJhZy5zbiArIFwiIG9mIFtcIiArIGRldGFpbHMuc3RhcnRTTiArIFwiICxcIiArIGRldGFpbHMuZW5kU04gKyBcIl0sdHJhY2sgXCIgKyB0cmFja0lkKTtcblxuICAgICAgdmFyIF90aGlzJHdhaXRpbmdEYXRhID0gdGhpcy53YWl0aW5nRGF0YSA9IHRoaXMud2FpdGluZ0RhdGEgfHwge1xuICAgICAgICBmcmFnOiBmcmFnLFxuICAgICAgICBwYXJ0OiBwYXJ0LFxuICAgICAgICBjYWNoZTogbmV3IF9kZW11eF9jaHVua19jYWNoZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOF9fW1wiZGVmYXVsdFwiXSgpLFxuICAgICAgICBjb21wbGV0ZTogZmFsc2VcbiAgICAgIH0sXG4gICAgICAgICAgY2FjaGUgPSBfdGhpcyR3YWl0aW5nRGF0YS5jYWNoZTtcblxuICAgICAgY2FjaGUucHVzaChuZXcgVWludDhBcnJheShwYXlsb2FkKSk7XG4gICAgICB0aGlzLndhaXRpbmdWaWRlb0NDID0gdGhpcy52aWRlb1RyYWNrQ0M7XG4gICAgICB0aGlzLnN0YXRlID0gX2Jhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIlN0YXRlXCJdLldBSVRJTkdfSU5JVF9QVFM7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5faGFuZGxlRnJhZ21lbnRMb2FkQ29tcGxldGUgPSBmdW5jdGlvbiBfaGFuZGxlRnJhZ21lbnRMb2FkQ29tcGxldGUoZnJhZ0xvYWRlZERhdGEpIHtcbiAgICBpZiAodGhpcy53YWl0aW5nRGF0YSkge1xuICAgICAgdGhpcy53YWl0aW5nRGF0YS5jb21wbGV0ZSA9IHRydWU7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgX0Jhc2VTdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZS5faGFuZGxlRnJhZ21lbnRMb2FkQ29tcGxldGUuY2FsbCh0aGlzLCBmcmFnTG9hZGVkRGF0YSk7XG4gIH07XG5cbiAgX3Byb3RvLm9uQnVmZmVyUmVzZXQgPSBmdW5jdGlvblxuICAgIC8qIGV2ZW50OiBFdmVudHMuQlVGRkVSX1JFU0VUICovXG4gIG9uQnVmZmVyUmVzZXQoKSB7XG4gICAgLy8gcmVzZXQgcmVmZXJlbmNlIHRvIHNvdXJjZWJ1ZmZlcnNcbiAgICB0aGlzLm1lZGlhQnVmZmVyID0gdGhpcy52aWRlb0J1ZmZlciA9IG51bGw7XG4gICAgdGhpcy5sb2FkZWRtZXRhZGF0YSA9IGZhbHNlO1xuICB9O1xuXG4gIF9wcm90by5vbkJ1ZmZlckNyZWF0ZWQgPSBmdW5jdGlvbiBvbkJ1ZmZlckNyZWF0ZWQoZXZlbnQsIGRhdGEpIHtcbiAgICB2YXIgYXVkaW9UcmFjayA9IGRhdGEudHJhY2tzLmF1ZGlvO1xuXG4gICAgaWYgKGF1ZGlvVHJhY2spIHtcbiAgICAgIHRoaXMubWVkaWFCdWZmZXIgPSBhdWRpb1RyYWNrLmJ1ZmZlcjtcbiAgICB9XG5cbiAgICBpZiAoZGF0YS50cmFja3MudmlkZW8pIHtcbiAgICAgIHRoaXMudmlkZW9CdWZmZXIgPSBkYXRhLnRyYWNrcy52aWRlby5idWZmZXI7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5vbkZyYWdCdWZmZXJlZCA9IGZ1bmN0aW9uIG9uRnJhZ0J1ZmZlcmVkKGV2ZW50LCBkYXRhKSB7XG4gICAgdmFyIGZyYWcgPSBkYXRhLmZyYWcsXG4gICAgICAgIHBhcnQgPSBkYXRhLnBhcnQ7XG5cbiAgICBpZiAoZnJhZy50eXBlICE9PSBfdHlwZXNfbG9hZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXCJQbGF5bGlzdExldmVsVHlwZVwiXS5BVURJTykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmZyYWdDb250ZXh0Q2hhbmdlZChmcmFnKSkge1xuICAgICAgLy8gSWYgYSBsZXZlbCBzd2l0Y2ggd2FzIHJlcXVlc3RlZCB3aGlsZSBhIGZyYWdtZW50IHdhcyBidWZmZXJpbmcsIGl0IHdpbGwgZW1pdCB0aGUgRlJBR19CVUZGRVJFRCBldmVudCB1cG9uIGNvbXBsZXRpb25cbiAgICAgIC8vIEF2b2lkIHNldHRpbmcgc3RhdGUgYmFjayB0byBJRExFIG9yIGNvbmNsdWRpbmcgdGhlIGF1ZGlvIHN3aXRjaDsgb3RoZXJ3aXNlLCB0aGUgc3dpdGNoZWQtdG8gdHJhY2sgd2lsbCBub3QgYnVmZmVyXG4gICAgICB0aGlzLndhcm4oXCJGcmFnbWVudCBcIiArIGZyYWcuc24gKyAocGFydCA/ICcgcDogJyArIHBhcnQuaW5kZXggOiAnJykgKyBcIiBvZiBsZXZlbCBcIiArIGZyYWcubGV2ZWwgKyBcIiBmaW5pc2hlZCBidWZmZXJpbmcsIGJ1dCB3YXMgYWJvcnRlZC4gc3RhdGU6IFwiICsgdGhpcy5zdGF0ZSArIFwiLCBhdWRpb1N3aXRjaDogXCIgKyB0aGlzLmF1ZGlvU3dpdGNoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZnJhZy5zbiAhPT0gJ2luaXRTZWdtZW50Jykge1xuICAgICAgdGhpcy5mcmFnUHJldmlvdXMgPSBmcmFnO1xuXG4gICAgICBpZiAodGhpcy5hdWRpb1N3aXRjaCkge1xuICAgICAgICB0aGlzLmF1ZGlvU3dpdGNoID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiRXZlbnRzXCJdLkFVRElPX1RSQUNLX1NXSVRDSEVELCB7XG4gICAgICAgICAgaWQ6IHRoaXMudHJhY2tJZFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmZyYWdCdWZmZXJlZENvbXBsZXRlKGZyYWcsIHBhcnQpO1xuICB9O1xuXG4gIF9wcm90by5vbkVycm9yID0gZnVuY3Rpb24gb25FcnJvcihldmVudCwgZGF0YSkge1xuICAgIHN3aXRjaCAoZGF0YS5kZXRhaWxzKSB7XG4gICAgICBjYXNlIF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEzX19bXCJFcnJvckRldGFpbHNcIl0uRlJBR19MT0FEX0VSUk9SOlxuICAgICAgY2FzZSBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xM19fW1wiRXJyb3JEZXRhaWxzXCJdLkZSQUdfTE9BRF9USU1FT1VUOlxuICAgICAgY2FzZSBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xM19fW1wiRXJyb3JEZXRhaWxzXCJdLktFWV9MT0FEX0VSUk9SOlxuICAgICAgY2FzZSBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xM19fW1wiRXJyb3JEZXRhaWxzXCJdLktFWV9MT0FEX1RJTUVPVVQ6XG4gICAgICAgIC8vIFRPRE86IFNraXAgZnJhZ21lbnRzIHRoYXQgZG8gbm90IGJlbG9uZyB0byB0aGlzLmZyYWdDdXJyZW50IGF1ZGlvLWdyb3VwIGlkXG4gICAgICAgIHRoaXMub25GcmFnbWVudE9yS2V5TG9hZEVycm9yKF90eXBlc19sb2FkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcIlBsYXlsaXN0TGV2ZWxUeXBlXCJdLkFVRElPLCBkYXRhKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTNfX1tcIkVycm9yRGV0YWlsc1wiXS5BVURJT19UUkFDS19MT0FEX0VSUk9SOlxuICAgICAgY2FzZSBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xM19fW1wiRXJyb3JEZXRhaWxzXCJdLkFVRElPX1RSQUNLX0xPQURfVElNRU9VVDpcbiAgICAgICAgLy8gIHdoZW4gaW4gRVJST1Igc3RhdGUsIGRvbid0IHN3aXRjaCBiYWNrIHRvIElETEUgc3RhdGUgaW4gY2FzZSBhIG5vbi1mYXRhbCBlcnJvciBpcyByZWNlaXZlZFxuICAgICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gX2Jhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIlN0YXRlXCJdLkVSUk9SICYmIHRoaXMuc3RhdGUgIT09IF9iYXNlX3N0cmVhbV9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJTdGF0ZVwiXS5TVE9QUEVEKSB7XG4gICAgICAgICAgLy8gaWYgZmF0YWwgZXJyb3IsIHN0b3AgcHJvY2Vzc2luZywgb3RoZXJ3aXNlIG1vdmUgdG8gSURMRSB0byByZXRyeSBsb2FkaW5nXG4gICAgICAgICAgdGhpcy5zdGF0ZSA9IGRhdGEuZmF0YWwgPyBfYmFzZV9zdHJlYW1fY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiU3RhdGVcIl0uRVJST1IgOiBfYmFzZV9zdHJlYW1fY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiU3RhdGVcIl0uSURMRTtcbiAgICAgICAgICB0aGlzLndhcm4oZGF0YS5kZXRhaWxzICsgXCIgd2hpbGUgbG9hZGluZyBmcmFnLCBzd2l0Y2hpbmcgdG8gXCIgKyB0aGlzLnN0YXRlICsgXCIgc3RhdGVcIik7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xM19fW1wiRXJyb3JEZXRhaWxzXCJdLkJVRkZFUl9GVUxMX0VSUk9SOlxuICAgICAgICAvLyBpZiBpbiBhcHBlbmRpbmcgc3RhdGVcbiAgICAgICAgaWYgKGRhdGEucGFyZW50ID09PSAnYXVkaW8nICYmICh0aGlzLnN0YXRlID09PSBfYmFzZV9zdHJlYW1fY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiU3RhdGVcIl0uUEFSU0lORyB8fCB0aGlzLnN0YXRlID09PSBfYmFzZV9zdHJlYW1fY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiU3RhdGVcIl0uUEFSU0VEKSkge1xuICAgICAgICAgIHZhciBmbHVzaEJ1ZmZlciA9IHRydWU7XG4gICAgICAgICAgdmFyIGJ1ZmZlcmVkSW5mbyA9IHRoaXMuZ2V0RndkQnVmZmVySW5mbyh0aGlzLm1lZGlhQnVmZmVyLCBfdHlwZXNfbG9hZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXCJQbGF5bGlzdExldmVsVHlwZVwiXS5BVURJTyk7IC8vIDAuNSA6IHRvbGVyYW5jZSBuZWVkZWQgYXMgc29tZSBicm93c2VycyBzdGFsbHMgcGxheWJhY2sgYmVmb3JlIHJlYWNoaW5nIGJ1ZmZlcmVkIGVuZFxuICAgICAgICAgIC8vIHJlZHVjZSBtYXggYnVmIGxlbiBpZiBjdXJyZW50IHBvc2l0aW9uIGlzIGJ1ZmZlcmVkXG5cbiAgICAgICAgICBpZiAoYnVmZmVyZWRJbmZvICYmIGJ1ZmZlcmVkSW5mby5sZW4gPiAwLjUpIHtcbiAgICAgICAgICAgIGZsdXNoQnVmZmVyID0gIXRoaXMucmVkdWNlTWF4QnVmZmVyTGVuZ3RoKGJ1ZmZlcmVkSW5mby5sZW4pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChmbHVzaEJ1ZmZlcikge1xuICAgICAgICAgICAgLy8gY3VycmVudCBwb3NpdGlvbiBpcyBub3QgYnVmZmVyZWQsIGJ1dCBicm93c2VyIGlzIHN0aWxsIGNvbXBsYWluaW5nIGFib3V0IGJ1ZmZlciBmdWxsIGVycm9yXG4gICAgICAgICAgICAvLyB0aGlzIGhhcHBlbnMgb24gSUUvRWRnZSwgcmVmZXIgdG8gaHR0cHM6Ly9naXRodWIuY29tL3ZpZGVvLWRldi9obHMuanMvcHVsbC83MDhcbiAgICAgICAgICAgIC8vIGluIHRoYXQgY2FzZSBmbHVzaCB0aGUgd2hvbGUgYXVkaW8gYnVmZmVyIHRvIHJlY292ZXJcbiAgICAgICAgICAgIHRoaXMud2FybignQnVmZmVyIGZ1bGwgZXJyb3IgYWxzbyBtZWRpYS5jdXJyZW50VGltZSBpcyBub3QgYnVmZmVyZWQsIGZsdXNoIGF1ZGlvIGJ1ZmZlcicpO1xuICAgICAgICAgICAgdGhpcy5mcmFnQ3VycmVudCA9IG51bGw7XG5cbiAgICAgICAgICAgIF9CYXNlU3RyZWFtQ29udHJvbGxlci5wcm90b3R5cGUuZmx1c2hNYWluQnVmZmVyLmNhbGwodGhpcywgMCwgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLCAnYXVkaW8nKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLnJlc2V0TG9hZGluZ1N0YXRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5vbkJ1ZmZlckZsdXNoZWQgPSBmdW5jdGlvbiBvbkJ1ZmZlckZsdXNoZWQoZXZlbnQsIF9yZWYzKSB7XG4gICAgdmFyIHR5cGUgPSBfcmVmMy50eXBlO1xuXG4gICAgaWYgKHR5cGUgPT09IF9sb2FkZXJfZnJhZ21lbnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1tcIkVsZW1lbnRhcnlTdHJlYW1UeXBlc1wiXS5BVURJTykge1xuICAgICAgdGhpcy5idWZmZXJGbHVzaGVkID0gdHJ1ZTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLl9oYW5kbGVUcmFuc211eENvbXBsZXRlID0gZnVuY3Rpb24gX2hhbmRsZVRyYW5zbXV4Q29tcGxldGUodHJhbnNtdXhSZXN1bHQpIHtcbiAgICB2YXIgX2lkMyRzYW1wbGVzO1xuXG4gICAgdmFyIGlkID0gJ2F1ZGlvJztcbiAgICB2YXIgaGxzID0gdGhpcy5obHM7XG4gICAgdmFyIHJlbXV4UmVzdWx0ID0gdHJhbnNtdXhSZXN1bHQucmVtdXhSZXN1bHQsXG4gICAgICAgIGNodW5rTWV0YSA9IHRyYW5zbXV4UmVzdWx0LmNodW5rTWV0YTtcbiAgICB2YXIgY29udGV4dCA9IHRoaXMuZ2V0Q3VycmVudENvbnRleHQoY2h1bmtNZXRhKTtcblxuICAgIGlmICghY29udGV4dCkge1xuICAgICAgdGhpcy53YXJuKFwiVGhlIGxvYWRpbmcgY29udGV4dCBjaGFuZ2VkIHdoaWxlIGJ1ZmZlcmluZyBmcmFnbWVudCBcIiArIGNodW5rTWV0YS5zbiArIFwiIG9mIGxldmVsIFwiICsgY2h1bmtNZXRhLmxldmVsICsgXCIuIFRoaXMgY2h1bmsgd2lsbCBub3QgYmUgYnVmZmVyZWQuXCIpO1xuICAgICAgdGhpcy5yZXNldExpdmVTdGFydFdoZW5Ob3RMb2FkZWQoY2h1bmtNZXRhLmxldmVsKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZnJhZyA9IGNvbnRleHQuZnJhZyxcbiAgICAgICAgcGFydCA9IGNvbnRleHQucGFydDtcbiAgICB2YXIgYXVkaW8gPSByZW11eFJlc3VsdC5hdWRpbyxcbiAgICAgICAgdGV4dCA9IHJlbXV4UmVzdWx0LnRleHQsXG4gICAgICAgIGlkMyA9IHJlbXV4UmVzdWx0LmlkMyxcbiAgICAgICAgaW5pdFNlZ21lbnQgPSByZW11eFJlc3VsdC5pbml0U2VnbWVudDsgLy8gQ2hlY2sgaWYgdGhlIGN1cnJlbnQgZnJhZ21lbnQgaGFzIGJlZW4gYWJvcnRlZC4gV2UgY2hlY2sgdGhpcyBieSBmaXJzdCBzZWVpbmcgaWYgd2UncmUgc3RpbGwgcGxheWluZyB0aGUgY3VycmVudCBsZXZlbC5cbiAgICAvLyBJZiB3ZSBhcmUsIHN1YnNlcXVlbnRseSBjaGVjayBpZiB0aGUgY3VycmVudGx5IGxvYWRpbmcgZnJhZ21lbnQgKGZyYWdDdXJyZW50KSBoYXMgY2hhbmdlZC5cblxuICAgIGlmICh0aGlzLmZyYWdDb250ZXh0Q2hhbmdlZChmcmFnKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuc3RhdGUgPSBfYmFzZV9zdHJlYW1fY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiU3RhdGVcIl0uUEFSU0lORztcblxuICAgIGlmICh0aGlzLmF1ZGlvU3dpdGNoICYmIGF1ZGlvKSB7XG4gICAgICB0aGlzLmNvbXBsZXRlQXVkaW9Td2l0Y2goKTtcbiAgICB9XG5cbiAgICBpZiAoaW5pdFNlZ21lbnQgIT09IG51bGwgJiYgaW5pdFNlZ21lbnQgIT09IHZvaWQgMCAmJiBpbml0U2VnbWVudC50cmFja3MpIHtcbiAgICAgIHRoaXMuX2J1ZmZlckluaXRTZWdtZW50KGluaXRTZWdtZW50LnRyYWNrcywgZnJhZywgY2h1bmtNZXRhKTtcblxuICAgICAgaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiRXZlbnRzXCJdLkZSQUdfUEFSU0lOR19JTklUX1NFR01FTlQsIHtcbiAgICAgICAgZnJhZzogZnJhZyxcbiAgICAgICAgaWQ6IGlkLFxuICAgICAgICB0cmFja3M6IGluaXRTZWdtZW50LnRyYWNrc1xuICAgICAgfSk7IC8vIE9ubHkgZmx1c2ggYXVkaW8gZnJvbSBvbGQgYXVkaW8gdHJhY2tzIHdoZW4gUFRTIGlzIGtub3duIG9uIG5ldyBhdWRpbyB0cmFja1xuICAgIH1cblxuICAgIGlmIChhdWRpbykge1xuICAgICAgdmFyIHN0YXJ0UFRTID0gYXVkaW8uc3RhcnRQVFMsXG4gICAgICAgICAgZW5kUFRTID0gYXVkaW8uZW5kUFRTLFxuICAgICAgICAgIHN0YXJ0RFRTID0gYXVkaW8uc3RhcnREVFMsXG4gICAgICAgICAgZW5kRFRTID0gYXVkaW8uZW5kRFRTO1xuXG4gICAgICBpZiAocGFydCkge1xuICAgICAgICBwYXJ0LmVsZW1lbnRhcnlTdHJlYW1zW19sb2FkZXJfZnJhZ21lbnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1tcIkVsZW1lbnRhcnlTdHJlYW1UeXBlc1wiXS5BVURJT10gPSB7XG4gICAgICAgICAgc3RhcnRQVFM6IHN0YXJ0UFRTLFxuICAgICAgICAgIGVuZFBUUzogZW5kUFRTLFxuICAgICAgICAgIHN0YXJ0RFRTOiBzdGFydERUUyxcbiAgICAgICAgICBlbmREVFM6IGVuZERUU1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBmcmFnLnNldEVsZW1lbnRhcnlTdHJlYW1JbmZvKF9sb2FkZXJfZnJhZ21lbnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1tcIkVsZW1lbnRhcnlTdHJlYW1UeXBlc1wiXS5BVURJTywgc3RhcnRQVFMsIGVuZFBUUywgc3RhcnREVFMsIGVuZERUUyk7XG4gICAgICB0aGlzLmJ1ZmZlckZyYWdtZW50RGF0YShhdWRpbywgZnJhZywgcGFydCwgY2h1bmtNZXRhKTtcbiAgICB9XG5cbiAgICBpZiAoaWQzICE9PSBudWxsICYmIGlkMyAhPT0gdm9pZCAwICYmIChfaWQzJHNhbXBsZXMgPSBpZDMuc2FtcGxlcykgIT09IG51bGwgJiYgX2lkMyRzYW1wbGVzICE9PSB2b2lkIDAgJiYgX2lkMyRzYW1wbGVzLmxlbmd0aCkge1xuICAgICAgdmFyIGVtaXR0ZWRJRDMgPSBfZXh0ZW5kcyh7XG4gICAgICAgIGZyYWc6IGZyYWcsXG4gICAgICAgIGlkOiBpZFxuICAgICAgfSwgaWQzKTtcblxuICAgICAgaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiRXZlbnRzXCJdLkZSQUdfUEFSU0lOR19NRVRBREFUQSwgZW1pdHRlZElEMyk7XG4gICAgfVxuXG4gICAgaWYgKHRleHQpIHtcbiAgICAgIHZhciBlbWl0dGVkVGV4dCA9IF9leHRlbmRzKHtcbiAgICAgICAgZnJhZzogZnJhZyxcbiAgICAgICAgaWQ6IGlkXG4gICAgICB9LCB0ZXh0KTtcblxuICAgICAgaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiRXZlbnRzXCJdLkZSQUdfUEFSU0lOR19VU0VSREFUQSwgZW1pdHRlZFRleHQpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uX2J1ZmZlckluaXRTZWdtZW50ID0gZnVuY3Rpb24gX2J1ZmZlckluaXRTZWdtZW50KHRyYWNrcywgZnJhZywgY2h1bmtNZXRhKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUgIT09IF9iYXNlX3N0cmVhbV9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJTdGF0ZVwiXS5QQVJTSU5HKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBkZWxldGUgYW55IHZpZGVvIHRyYWNrIGZvdW5kIG9uIGF1ZGlvIHRyYW5zbXV4ZXJcblxuXG4gICAgaWYgKHRyYWNrcy52aWRlbykge1xuICAgICAgZGVsZXRlIHRyYWNrcy52aWRlbztcbiAgICB9IC8vIGluY2x1ZGUgbGV2ZWxDb2RlYyBpbiBhdWRpbyBhbmQgdmlkZW8gdHJhY2tzXG5cblxuICAgIHZhciB0cmFjayA9IHRyYWNrcy5hdWRpbztcblxuICAgIGlmICghdHJhY2spIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0cmFjay5sZXZlbENvZGVjID0gdHJhY2suY29kZWM7XG4gICAgdHJhY2suaWQgPSAnYXVkaW8nO1xuICAgIHRoaXMubG9nKFwiSW5pdCBhdWRpbyBidWZmZXIsIGNvbnRhaW5lcjpcIiArIHRyYWNrLmNvbnRhaW5lciArIFwiLCBjb2RlY3NbcGFyc2VkXT1bXCIgKyB0cmFjay5jb2RlYyArIFwiXVwiKTtcbiAgICB0aGlzLmhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcIkV2ZW50c1wiXS5CVUZGRVJfQ09ERUNTLCB0cmFja3MpO1xuICAgIHZhciBpbml0U2VnbWVudCA9IHRyYWNrLmluaXRTZWdtZW50O1xuXG4gICAgaWYgKGluaXRTZWdtZW50ICE9PSBudWxsICYmIGluaXRTZWdtZW50ICE9PSB2b2lkIDAgJiYgaW5pdFNlZ21lbnQuYnl0ZUxlbmd0aCkge1xuICAgICAgdmFyIHNlZ21lbnQgPSB7XG4gICAgICAgIHR5cGU6ICdhdWRpbycsXG4gICAgICAgIGZyYWc6IGZyYWcsXG4gICAgICAgIHBhcnQ6IG51bGwsXG4gICAgICAgIGNodW5rTWV0YTogY2h1bmtNZXRhLFxuICAgICAgICBwYXJlbnQ6IGZyYWcudHlwZSxcbiAgICAgICAgZGF0YTogaW5pdFNlZ21lbnRcbiAgICAgIH07XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcIkV2ZW50c1wiXS5CVUZGRVJfQVBQRU5ESU5HLCBzZWdtZW50KTtcbiAgICB9IC8vIHRyaWdnZXIgaGFuZGxlciByaWdodCBub3dcblxuXG4gICAgdGhpcy50aWNrKCk7XG4gIH07XG5cbiAgX3Byb3RvLmxvYWRGcmFnbWVudCA9IGZ1bmN0aW9uIGxvYWRGcmFnbWVudChmcmFnLCB0cmFja0RldGFpbHMsIHRhcmdldEJ1ZmZlclRpbWUpIHtcbiAgICAvLyBvbmx5IGxvYWQgaWYgZnJhZ21lbnQgaXMgbm90IGxvYWRlZCBvciBpZiBpbiBhdWRpbyBzd2l0Y2hcbiAgICB2YXIgZnJhZ1N0YXRlID0gdGhpcy5mcmFnbWVudFRyYWNrZXIuZ2V0U3RhdGUoZnJhZyk7XG4gICAgdGhpcy5mcmFnQ3VycmVudCA9IGZyYWc7IC8vIHdlIGZvcmNlIGEgZnJhZyBsb2FkaW5nIGluIGF1ZGlvIHN3aXRjaCBhcyBmcmFnbWVudCB0cmFja2VyIG1pZ2h0IG5vdCBoYXZlIGV2aWN0ZWQgcHJldmlvdXMgZnJhZ3MgaW4gY2FzZSBvZiBxdWljayBhdWRpbyBzd2l0Y2hcblxuICAgIGlmICh0aGlzLmF1ZGlvU3dpdGNoIHx8IGZyYWdTdGF0ZSA9PT0gX2ZyYWdtZW50X3RyYWNrZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1tcIkZyYWdtZW50U3RhdGVcIl0uTk9UX0xPQURFRCB8fCBmcmFnU3RhdGUgPT09IF9mcmFnbWVudF90cmFja2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXCJGcmFnbWVudFN0YXRlXCJdLlBBUlRJQUwpIHtcbiAgICAgIGlmIChmcmFnLnNuID09PSAnaW5pdFNlZ21lbnQnKSB7XG4gICAgICAgIHRoaXMuX2xvYWRJbml0U2VnbWVudChmcmFnKTtcbiAgICAgIH0gZWxzZSBpZiAodHJhY2tEZXRhaWxzLmxpdmUgJiYgIU9iamVjdChfaG9tZV9ydW5uZXJfd29ya19obHNfanNfaGxzX2pzX3NyY19wb2x5ZmlsbHNfbnVtYmVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJpc0Zpbml0ZU51bWJlclwiXSkodGhpcy5pbml0UFRTW2ZyYWcuY2NdKSkge1xuICAgICAgICB0aGlzLmxvZyhcIldhaXRpbmcgZm9yIHZpZGVvIFBUUyBpbiBjb250aW51aXR5IGNvdW50ZXIgXCIgKyBmcmFnLmNjICsgXCIgb2YgbGl2ZSBzdHJlYW0gYmVmb3JlIGxvYWRpbmcgYXVkaW8gZnJhZ21lbnQgXCIgKyBmcmFnLnNuICsgXCIgb2YgbGV2ZWwgXCIgKyB0aGlzLnRyYWNrSWQpO1xuICAgICAgICB0aGlzLnN0YXRlID0gX2Jhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIlN0YXRlXCJdLldBSVRJTkdfSU5JVF9QVFM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCA9IHRydWU7XG5cbiAgICAgICAgX0Jhc2VTdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZS5sb2FkRnJhZ21lbnQuY2FsbCh0aGlzLCBmcmFnLCB0cmFja0RldGFpbHMsIHRhcmdldEJ1ZmZlclRpbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uY29tcGxldGVBdWRpb1N3aXRjaCA9IGZ1bmN0aW9uIGNvbXBsZXRlQXVkaW9Td2l0Y2goKSB7XG4gICAgdmFyIGhscyA9IHRoaXMuaGxzLFxuICAgICAgICBtZWRpYSA9IHRoaXMubWVkaWEsXG4gICAgICAgIHRyYWNrSWQgPSB0aGlzLnRyYWNrSWQ7XG5cbiAgICBpZiAobWVkaWEpIHtcbiAgICAgIHRoaXMubG9nKCdTd2l0Y2hpbmcgYXVkaW8gdHJhY2sgOiBmbHVzaGluZyBhbGwgYXVkaW8nKTtcblxuICAgICAgX0Jhc2VTdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZS5mbHVzaE1haW5CdWZmZXIuY2FsbCh0aGlzLCAwLCBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksICdhdWRpbycpO1xuICAgIH1cblxuICAgIHRoaXMuYXVkaW9Td2l0Y2ggPSBmYWxzZTtcbiAgICBobHMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJFdmVudHNcIl0uQVVESU9fVFJBQ0tfU1dJVENIRUQsIHtcbiAgICAgIGlkOiB0cmFja0lkXG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIEF1ZGlvU3RyZWFtQ29udHJvbGxlcjtcbn0oX2Jhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImRlZmF1bHRcIl0pO1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKEF1ZGlvU3RyZWFtQ29udHJvbGxlcik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NvbnRyb2xsZXIvYXVkaW8tdHJhY2stY29udHJvbGxlci50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvY29udHJvbGxlci9hdWRpby10cmFjay1jb250cm9sbGVyLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2V2ZW50cyAqLyBcIi4vc3JjL2V2ZW50cy50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9lcnJvcnMgKi8gXCIuL3NyYy9lcnJvcnMudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2Jhc2VfcGxheWxpc3RfY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9iYXNlLXBsYXlsaXN0LWNvbnRyb2xsZXIgKi8gXCIuL3NyYy9jb250cm9sbGVyL2Jhc2UtcGxheWxpc3QtY29udHJvbGxlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdHlwZXNfbG9hZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi90eXBlcy9sb2FkZXIgKi8gXCIuL3NyYy90eXBlcy9sb2FkZXIudHNcIik7XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpOyBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzczsgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5cblxuXG5cblxudmFyIEF1ZGlvVHJhY2tDb250cm9sbGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQmFzZVBsYXlsaXN0Q29udHJvbGwpIHtcbiAgX2luaGVyaXRzTG9vc2UoQXVkaW9UcmFja0NvbnRyb2xsZXIsIF9CYXNlUGxheWxpc3RDb250cm9sbCk7XG5cbiAgZnVuY3Rpb24gQXVkaW9UcmFja0NvbnRyb2xsZXIoaGxzKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX3RoaXMgPSBfQmFzZVBsYXlsaXN0Q29udHJvbGwuY2FsbCh0aGlzLCBobHMsICdbYXVkaW8tdHJhY2stY29udHJvbGxlcl0nKSB8fCB0aGlzO1xuICAgIF90aGlzLnRyYWNrcyA9IFtdO1xuICAgIF90aGlzLmdyb3VwSWQgPSBudWxsO1xuICAgIF90aGlzLnRyYWNrc0luR3JvdXAgPSBbXTtcbiAgICBfdGhpcy50cmFja0lkID0gLTE7XG4gICAgX3RoaXMudHJhY2tOYW1lID0gJyc7XG4gICAgX3RoaXMuc2VsZWN0RGVmYXVsdFRyYWNrID0gdHJ1ZTtcblxuICAgIF90aGlzLnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gQXVkaW9UcmFja0NvbnRyb2xsZXIucHJvdG90eXBlO1xuXG4gIF9wcm90by5yZWdpc3Rlckxpc3RlbmVycyA9IGZ1bmN0aW9uIHJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIHZhciBobHMgPSB0aGlzLmhscztcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiRXZlbnRzXCJdLk1BTklGRVNUX0xPQURJTkcsIHRoaXMub25NYW5pZmVzdExvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJFdmVudHNcIl0uTUFOSUZFU1RfUEFSU0VELCB0aGlzLm9uTWFuaWZlc3RQYXJzZWQsIHRoaXMpO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJFdmVudHNcIl0uTEVWRUxfTE9BRElORywgdGhpcy5vbkxldmVsTG9hZGluZywgdGhpcyk7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIkV2ZW50c1wiXS5MRVZFTF9TV0lUQ0hJTkcsIHRoaXMub25MZXZlbFN3aXRjaGluZywgdGhpcyk7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIkV2ZW50c1wiXS5BVURJT19UUkFDS19MT0FERUQsIHRoaXMub25BdWRpb1RyYWNrTG9hZGVkLCB0aGlzKTtcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiRXZlbnRzXCJdLkVSUk9SLCB0aGlzLm9uRXJyb3IsIHRoaXMpO1xuICB9O1xuXG4gIF9wcm90by51bnJlZ2lzdGVyTGlzdGVuZXJzID0gZnVuY3Rpb24gdW5yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICB2YXIgaGxzID0gdGhpcy5obHM7XG4gICAgaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJFdmVudHNcIl0uTUFOSUZFU1RfTE9BRElORywgdGhpcy5vbk1hbmlmZXN0TG9hZGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJFdmVudHNcIl0uTUFOSUZFU1RfUEFSU0VELCB0aGlzLm9uTWFuaWZlc3RQYXJzZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiRXZlbnRzXCJdLkxFVkVMX0xPQURJTkcsIHRoaXMub25MZXZlbExvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiRXZlbnRzXCJdLkxFVkVMX1NXSVRDSElORywgdGhpcy5vbkxldmVsU3dpdGNoaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIkV2ZW50c1wiXS5BVURJT19UUkFDS19MT0FERUQsIHRoaXMub25BdWRpb1RyYWNrTG9hZGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIkV2ZW50c1wiXS5FUlJPUiwgdGhpcy5vbkVycm9yLCB0aGlzKTtcbiAgfTtcblxuICBfcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgdGhpcy51bnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gICAgdGhpcy50cmFja3MubGVuZ3RoID0gMDtcbiAgICB0aGlzLnRyYWNrc0luR3JvdXAubGVuZ3RoID0gMDtcblxuICAgIF9CYXNlUGxheWxpc3RDb250cm9sbC5wcm90b3R5cGUuZGVzdHJveS5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIF9wcm90by5vbk1hbmlmZXN0TG9hZGluZyA9IGZ1bmN0aW9uIG9uTWFuaWZlc3RMb2FkaW5nKCkge1xuICAgIHRoaXMudHJhY2tzID0gW107XG4gICAgdGhpcy5ncm91cElkID0gbnVsbDtcbiAgICB0aGlzLnRyYWNrc0luR3JvdXAgPSBbXTtcbiAgICB0aGlzLnRyYWNrSWQgPSAtMTtcbiAgICB0aGlzLnRyYWNrTmFtZSA9ICcnO1xuICAgIHRoaXMuc2VsZWN0RGVmYXVsdFRyYWNrID0gdHJ1ZTtcbiAgfTtcblxuICBfcHJvdG8ub25NYW5pZmVzdFBhcnNlZCA9IGZ1bmN0aW9uIG9uTWFuaWZlc3RQYXJzZWQoZXZlbnQsIGRhdGEpIHtcbiAgICB0aGlzLnRyYWNrcyA9IGRhdGEuYXVkaW9UcmFja3MgfHwgW107XG4gIH07XG5cbiAgX3Byb3RvLm9uQXVkaW9UcmFja0xvYWRlZCA9IGZ1bmN0aW9uIG9uQXVkaW9UcmFja0xvYWRlZChldmVudCwgZGF0YSkge1xuICAgIHZhciBpZCA9IGRhdGEuaWQsXG4gICAgICAgIGRldGFpbHMgPSBkYXRhLmRldGFpbHM7XG4gICAgdmFyIGN1cnJlbnRUcmFjayA9IHRoaXMudHJhY2tzSW5Hcm91cFtpZF07XG5cbiAgICBpZiAoIWN1cnJlbnRUcmFjaykge1xuICAgICAgdGhpcy53YXJuKFwiSW52YWxpZCBhdWRpbyB0cmFjayBpZCBcIiArIGlkKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgY3VyRGV0YWlscyA9IGN1cnJlbnRUcmFjay5kZXRhaWxzO1xuICAgIGN1cnJlbnRUcmFjay5kZXRhaWxzID0gZGF0YS5kZXRhaWxzO1xuICAgIHRoaXMubG9nKFwiYXVkaW9UcmFjayBcIiArIGlkICsgXCIgbG9hZGVkIFtcIiArIGRldGFpbHMuc3RhcnRTTiArIFwiLVwiICsgZGV0YWlscy5lbmRTTiArIFwiXVwiKTtcblxuICAgIGlmIChpZCA9PT0gdGhpcy50cmFja0lkKSB7XG4gICAgICB0aGlzLnJldHJ5Q291bnQgPSAwO1xuICAgICAgdGhpcy5wbGF5bGlzdExvYWRlZChpZCwgZGF0YSwgY3VyRGV0YWlscyk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5vbkxldmVsTG9hZGluZyA9IGZ1bmN0aW9uIG9uTGV2ZWxMb2FkaW5nKGV2ZW50LCBkYXRhKSB7XG4gICAgdGhpcy5zd2l0Y2hMZXZlbChkYXRhLmxldmVsKTtcbiAgfTtcblxuICBfcHJvdG8ub25MZXZlbFN3aXRjaGluZyA9IGZ1bmN0aW9uIG9uTGV2ZWxTd2l0Y2hpbmcoZXZlbnQsIGRhdGEpIHtcbiAgICB0aGlzLnN3aXRjaExldmVsKGRhdGEubGV2ZWwpO1xuICB9O1xuXG4gIF9wcm90by5zd2l0Y2hMZXZlbCA9IGZ1bmN0aW9uIHN3aXRjaExldmVsKGxldmVsSW5kZXgpIHtcbiAgICB2YXIgbGV2ZWxJbmZvID0gdGhpcy5obHMubGV2ZWxzW2xldmVsSW5kZXhdO1xuXG4gICAgaWYgKCEobGV2ZWxJbmZvICE9PSBudWxsICYmIGxldmVsSW5mbyAhPT0gdm9pZCAwICYmIGxldmVsSW5mby5hdWRpb0dyb3VwSWRzKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBhdWRpb0dyb3VwSWQgPSBsZXZlbEluZm8uYXVkaW9Hcm91cElkc1tsZXZlbEluZm8udXJsSWRdO1xuXG4gICAgaWYgKHRoaXMuZ3JvdXBJZCAhPT0gYXVkaW9Hcm91cElkKSB7XG4gICAgICB0aGlzLmdyb3VwSWQgPSBhdWRpb0dyb3VwSWQ7XG4gICAgICB2YXIgYXVkaW9UcmFja3MgPSB0aGlzLnRyYWNrcy5maWx0ZXIoZnVuY3Rpb24gKHRyYWNrKSB7XG4gICAgICAgIHJldHVybiAhYXVkaW9Hcm91cElkIHx8IHRyYWNrLmdyb3VwSWQgPT09IGF1ZGlvR3JvdXBJZDtcbiAgICAgIH0pOyAvLyBEaXNhYmxlIHNlbGVjdERlZmF1bHRUcmFjayBpZiB0aGVyZSBhcmUgbm8gZGVmYXVsdCB0cmFja3NcblxuICAgICAgaWYgKHRoaXMuc2VsZWN0RGVmYXVsdFRyYWNrICYmICFhdWRpb1RyYWNrcy5zb21lKGZ1bmN0aW9uICh0cmFjaykge1xuICAgICAgICByZXR1cm4gdHJhY2suZGVmYXVsdDtcbiAgICAgIH0pKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0RGVmYXVsdFRyYWNrID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudHJhY2tzSW5Hcm91cCA9IGF1ZGlvVHJhY2tzO1xuICAgICAgdmFyIGF1ZGlvVHJhY2tzVXBkYXRlZCA9IHtcbiAgICAgICAgYXVkaW9UcmFja3M6IGF1ZGlvVHJhY2tzXG4gICAgICB9O1xuICAgICAgdGhpcy5sb2coXCJVcGRhdGluZyBhdWRpbyB0cmFja3MsIFwiICsgYXVkaW9UcmFja3MubGVuZ3RoICsgXCIgdHJhY2socykgZm91bmQgaW4gXFxcIlwiICsgYXVkaW9Hcm91cElkICsgXCJcXFwiIGdyb3VwLWlkXCIpO1xuICAgICAgdGhpcy5obHMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJFdmVudHNcIl0uQVVESU9fVFJBQ0tTX1VQREFURUQsIGF1ZGlvVHJhY2tzVXBkYXRlZCk7XG4gICAgICB0aGlzLnNlbGVjdEluaXRpYWxUcmFjaygpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8ub25FcnJvciA9IGZ1bmN0aW9uIG9uRXJyb3IoZXZlbnQsIGRhdGEpIHtcbiAgICBfQmFzZVBsYXlsaXN0Q29udHJvbGwucHJvdG90eXBlLm9uRXJyb3IuY2FsbCh0aGlzLCBldmVudCwgZGF0YSk7XG5cbiAgICBpZiAoZGF0YS5mYXRhbCB8fCAhZGF0YS5jb250ZXh0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGRhdGEuY29udGV4dC50eXBlID09PSBfdHlwZXNfbG9hZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJQbGF5bGlzdENvbnRleHRUeXBlXCJdLkFVRElPX1RSQUNLICYmIGRhdGEuY29udGV4dC5pZCA9PT0gdGhpcy50cmFja0lkICYmIGRhdGEuY29udGV4dC5ncm91cElkID09PSB0aGlzLmdyb3VwSWQpIHtcbiAgICAgIHRoaXMucmV0cnlMb2FkaW5nT3JGYWlsKGRhdGEpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uc2V0QXVkaW9UcmFjayA9IGZ1bmN0aW9uIHNldEF1ZGlvVHJhY2sobmV3SWQpIHtcbiAgICB2YXIgdHJhY2tzID0gdGhpcy50cmFja3NJbkdyb3VwOyAvLyBjaGVjayBpZiBsZXZlbCBpZHggaXMgdmFsaWRcblxuICAgIGlmIChuZXdJZCA8IDAgfHwgbmV3SWQgPj0gdHJhY2tzLmxlbmd0aCkge1xuICAgICAgdGhpcy53YXJuKCdJbnZhbGlkIGlkIHBhc3NlZCB0byBhdWRpby10cmFjayBjb250cm9sbGVyJyk7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBzdG9wcGluZyBsaXZlIHJlbG9hZGluZyB0aW1lciBpZiBhbnlcblxuXG4gICAgdGhpcy5jbGVhclRpbWVyKCk7XG4gICAgdmFyIGxhc3RUcmFjayA9IHRyYWNrc1t0aGlzLnRyYWNrSWRdO1xuICAgIHRoaXMubG9nKFwiTm93IHN3aXRjaGluZyB0byBhdWRpby10cmFjayBpbmRleCBcIiArIG5ld0lkKTtcbiAgICB2YXIgdHJhY2sgPSB0cmFja3NbbmV3SWRdO1xuICAgIHZhciBpZCA9IHRyYWNrLmlkLFxuICAgICAgICBfdHJhY2skZ3JvdXBJZCA9IHRyYWNrLmdyb3VwSWQsXG4gICAgICAgIGdyb3VwSWQgPSBfdHJhY2skZ3JvdXBJZCA9PT0gdm9pZCAwID8gJycgOiBfdHJhY2skZ3JvdXBJZCxcbiAgICAgICAgbmFtZSA9IHRyYWNrLm5hbWUsXG4gICAgICAgIHR5cGUgPSB0cmFjay50eXBlLFxuICAgICAgICB1cmwgPSB0cmFjay51cmw7XG4gICAgdGhpcy50cmFja0lkID0gbmV3SWQ7XG4gICAgdGhpcy50cmFja05hbWUgPSBuYW1lO1xuICAgIHRoaXMuc2VsZWN0RGVmYXVsdFRyYWNrID0gZmFsc2U7XG4gICAgdGhpcy5obHMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJFdmVudHNcIl0uQVVESU9fVFJBQ0tfU1dJVENISU5HLCB7XG4gICAgICBpZDogaWQsXG4gICAgICBncm91cElkOiBncm91cElkLFxuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIHR5cGU6IHR5cGUsXG4gICAgICB1cmw6IHVybFxuICAgIH0pOyAvLyBEbyBub3QgcmVsb2FkIHRyYWNrIHVubGVzcyBsaXZlXG5cbiAgICBpZiAodHJhY2suZGV0YWlscyAmJiAhdHJhY2suZGV0YWlscy5saXZlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGhsc1VybFBhcmFtZXRlcnMgPSB0aGlzLnN3aXRjaFBhcmFtcyh0cmFjay51cmwsIGxhc3RUcmFjayA9PT0gbnVsbCB8fCBsYXN0VHJhY2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxhc3RUcmFjay5kZXRhaWxzKTtcbiAgICB0aGlzLmxvYWRQbGF5bGlzdChobHNVcmxQYXJhbWV0ZXJzKTtcbiAgfTtcblxuICBfcHJvdG8uc2VsZWN0SW5pdGlhbFRyYWNrID0gZnVuY3Rpb24gc2VsZWN0SW5pdGlhbFRyYWNrKCkge1xuICAgIHZhciBhdWRpb1RyYWNrcyA9IHRoaXMudHJhY2tzSW5Hcm91cDtcbiAgICBjb25zb2xlLmFzc2VydChhdWRpb1RyYWNrcy5sZW5ndGgsICdJbml0aWFsIGF1ZGlvIHRyYWNrIHNob3VsZCBiZSBzZWxlY3RlZCB3aGVuIHRyYWNrcyBhcmUga25vd24nKTtcbiAgICB2YXIgY3VycmVudEF1ZGlvVHJhY2tOYW1lID0gdGhpcy50cmFja05hbWU7XG4gICAgdmFyIHRyYWNrSWQgPSB0aGlzLmZpbmRUcmFja0lkKGN1cnJlbnRBdWRpb1RyYWNrTmFtZSkgfHwgdGhpcy5maW5kVHJhY2tJZCgpO1xuXG4gICAgaWYgKHRyYWNrSWQgIT09IC0xKSB7XG4gICAgICB0aGlzLnNldEF1ZGlvVHJhY2sodHJhY2tJZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMud2FybihcIk5vIHRyYWNrIGZvdW5kIGZvciBydW5uaW5nIGF1ZGlvIGdyb3VwLUlEOiBcIiArIHRoaXMuZ3JvdXBJZCk7XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIkV2ZW50c1wiXS5FUlJPUiwge1xuICAgICAgICB0eXBlOiBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFcnJvclR5cGVzXCJdLk1FRElBX0VSUk9SLFxuICAgICAgICBkZXRhaWxzOiBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFcnJvckRldGFpbHNcIl0uQVVESU9fVFJBQ0tfTE9BRF9FUlJPUixcbiAgICAgICAgZmF0YWw6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uZmluZFRyYWNrSWQgPSBmdW5jdGlvbiBmaW5kVHJhY2tJZChuYW1lKSB7XG4gICAgdmFyIGF1ZGlvVHJhY2tzID0gdGhpcy50cmFja3NJbkdyb3VwO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhdWRpb1RyYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHRyYWNrID0gYXVkaW9UcmFja3NbaV07XG5cbiAgICAgIGlmICghdGhpcy5zZWxlY3REZWZhdWx0VHJhY2sgfHwgdHJhY2suZGVmYXVsdCkge1xuICAgICAgICBpZiAoIW5hbWUgfHwgbmFtZSA9PT0gdHJhY2submFtZSkge1xuICAgICAgICAgIHJldHVybiB0cmFjay5pZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAtMTtcbiAgfTtcblxuICBfcHJvdG8ubG9hZFBsYXlsaXN0ID0gZnVuY3Rpb24gbG9hZFBsYXlsaXN0KGhsc1VybFBhcmFtZXRlcnMpIHtcbiAgICB2YXIgYXVkaW9UcmFjayA9IHRoaXMudHJhY2tzSW5Hcm91cFt0aGlzLnRyYWNrSWRdO1xuXG4gICAgaWYgKHRoaXMuc2hvdWxkTG9hZFRyYWNrKGF1ZGlvVHJhY2spKSB7XG4gICAgICB2YXIgaWQgPSBhdWRpb1RyYWNrLmlkO1xuICAgICAgdmFyIGdyb3VwSWQgPSBhdWRpb1RyYWNrLmdyb3VwSWQ7XG4gICAgICB2YXIgdXJsID0gYXVkaW9UcmFjay51cmw7XG5cbiAgICAgIGlmIChobHNVcmxQYXJhbWV0ZXJzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdXJsID0gaGxzVXJsUGFyYW1ldGVycy5hZGREaXJlY3RpdmVzKHVybCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgdGhpcy53YXJuKFwiQ291bGQgbm90IGNvbnN0cnVjdCBuZXcgVVJMIHdpdGggSExTIERlbGl2ZXJ5IERpcmVjdGl2ZXM6IFwiICsgZXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9IC8vIHRyYWNrIG5vdCByZXRyaWV2ZWQgeWV0LCBvciBsaXZlIHBsYXlsaXN0IHdlIG5lZWQgdG8gKHJlKWxvYWQgaXRcblxuXG4gICAgICB0aGlzLmxvZyhcImxvYWRpbmcgYXVkaW8tdHJhY2sgcGxheWxpc3QgZm9yIGlkOiBcIiArIGlkKTtcbiAgICAgIHRoaXMuY2xlYXJUaW1lcigpO1xuICAgICAgdGhpcy5obHMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJFdmVudHNcIl0uQVVESU9fVFJBQ0tfTE9BRElORywge1xuICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgaWQ6IGlkLFxuICAgICAgICBncm91cElkOiBncm91cElkLFxuICAgICAgICBkZWxpdmVyeURpcmVjdGl2ZXM6IGhsc1VybFBhcmFtZXRlcnMgfHwgbnVsbFxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIF9jcmVhdGVDbGFzcyhBdWRpb1RyYWNrQ29udHJvbGxlciwgW3tcbiAgICBrZXk6IFwiYXVkaW9UcmFja3NcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnRyYWNrc0luR3JvdXA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImF1ZGlvVHJhY2tcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnRyYWNrSWQ7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldChuZXdJZCkge1xuICAgICAgLy8gSWYgYXVkaW8gdHJhY2sgaXMgc2VsZWN0ZWQgZnJvbSBBUEkgdGhlbiBkb24ndCBjaG9vc2UgZnJvbSB0aGUgbWFuaWZlc3QgZGVmYXVsdCB0cmFja1xuICAgICAgdGhpcy5zZWxlY3REZWZhdWx0VHJhY2sgPSBmYWxzZTtcbiAgICAgIHRoaXMuc2V0QXVkaW9UcmFjayhuZXdJZCk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEF1ZGlvVHJhY2tDb250cm9sbGVyO1xufShfYmFzZV9wbGF5bGlzdF9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJkZWZhdWx0XCJdKTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChBdWRpb1RyYWNrQ29udHJvbGxlcik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NvbnRyb2xsZXIvYmFzZS1wbGF5bGlzdC1jb250cm9sbGVyLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbnRyb2xsZXIvYmFzZS1wbGF5bGlzdC1jb250cm9sbGVyLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZGVmYXVsdFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIEJhc2VQbGF5bGlzdENvbnRyb2xsZXI7IH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9ob21lX3J1bm5lcl93b3JrX2hsc19qc19obHNfanNfc3JjX3BvbHlmaWxsc19udW1iZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc3JjL3BvbHlmaWxscy9udW1iZXIgKi8gXCIuL3NyYy9wb2x5ZmlsbHMvbnVtYmVyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF90eXBlc19sZXZlbF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdHlwZXMvbGV2ZWwgKi8gXCIuL3NyYy90eXBlcy9sZXZlbC50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbGV2ZWxfaGVscGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2xldmVsLWhlbHBlciAqLyBcIi4vc3JjL2NvbnRyb2xsZXIvbGV2ZWwtaGVscGVyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL2xvZ2dlciAqLyBcIi4vc3JjL3V0aWxzL2xvZ2dlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9lcnJvcnMgKi8gXCIuL3NyYy9lcnJvcnMudHNcIik7XG5cblxuXG5cblxuXG5cbnZhciBCYXNlUGxheWxpc3RDb250cm9sbGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQmFzZVBsYXlsaXN0Q29udHJvbGxlcihobHMsIGxvZ1ByZWZpeCkge1xuICAgIHRoaXMuaGxzID0gdm9pZCAwO1xuICAgIHRoaXMudGltZXIgPSAtMTtcbiAgICB0aGlzLmNhbkxvYWQgPSBmYWxzZTtcbiAgICB0aGlzLnJldHJ5Q291bnQgPSAwO1xuICAgIHRoaXMubG9nID0gdm9pZCAwO1xuICAgIHRoaXMud2FybiA9IHZvaWQgMDtcbiAgICB0aGlzLmxvZyA9IF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcImxvZ2dlclwiXS5sb2cuYmluZChfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJsb2dnZXJcIl0sIGxvZ1ByZWZpeCArIFwiOlwiKTtcbiAgICB0aGlzLndhcm4gPSBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJsb2dnZXJcIl0ud2Fybi5iaW5kKF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcImxvZ2dlclwiXSwgbG9nUHJlZml4ICsgXCI6XCIpO1xuICAgIHRoaXMuaGxzID0gaGxzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IEJhc2VQbGF5bGlzdENvbnRyb2xsZXIucHJvdG90eXBlO1xuXG4gIF9wcm90by5kZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICB0aGlzLmNsZWFyVGltZXIoKTsgLy8gQHRzLWlnbm9yZVxuXG4gICAgdGhpcy5obHMgPSB0aGlzLmxvZyA9IHRoaXMud2FybiA9IG51bGw7XG4gIH07XG5cbiAgX3Byb3RvLm9uRXJyb3IgPSBmdW5jdGlvbiBvbkVycm9yKGV2ZW50LCBkYXRhKSB7XG4gICAgaWYgKGRhdGEuZmF0YWwgJiYgZGF0YS50eXBlID09PSBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXCJFcnJvclR5cGVzXCJdLk5FVFdPUktfRVJST1IpIHtcbiAgICAgIHRoaXMuY2xlYXJUaW1lcigpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uY2xlYXJUaW1lciA9IGZ1bmN0aW9uIGNsZWFyVGltZXIoKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZXIpO1xuICAgIHRoaXMudGltZXIgPSAtMTtcbiAgfTtcblxuICBfcHJvdG8uc3RhcnRMb2FkID0gZnVuY3Rpb24gc3RhcnRMb2FkKCkge1xuICAgIHRoaXMuY2FuTG9hZCA9IHRydWU7XG4gICAgdGhpcy5yZXRyeUNvdW50ID0gMDtcbiAgICB0aGlzLmxvYWRQbGF5bGlzdCgpO1xuICB9O1xuXG4gIF9wcm90by5zdG9wTG9hZCA9IGZ1bmN0aW9uIHN0b3BMb2FkKCkge1xuICAgIHRoaXMuY2FuTG9hZCA9IGZhbHNlO1xuICAgIHRoaXMuY2xlYXJUaW1lcigpO1xuICB9O1xuXG4gIF9wcm90by5zd2l0Y2hQYXJhbXMgPSBmdW5jdGlvbiBzd2l0Y2hQYXJhbXMocGxheWxpc3RVcmksIHByZXZpb3VzKSB7XG4gICAgdmFyIHJlbmRpdGlvblJlcG9ydHMgPSBwcmV2aW91cyA9PT0gbnVsbCB8fCBwcmV2aW91cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJldmlvdXMucmVuZGl0aW9uUmVwb3J0cztcblxuICAgIGlmIChyZW5kaXRpb25SZXBvcnRzKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlbmRpdGlvblJlcG9ydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGF0dHIgPSByZW5kaXRpb25SZXBvcnRzW2ldO1xuICAgICAgICB2YXIgdXJpID0gJycgKyBhdHRyLlVSSTtcblxuICAgICAgICBpZiAodXJpID09PSBwbGF5bGlzdFVyaS5zdWJzdHIoLXVyaS5sZW5ndGgpKSB7XG4gICAgICAgICAgdmFyIG1zbiA9IHBhcnNlSW50KGF0dHJbJ0xBU1QtTVNOJ10pO1xuICAgICAgICAgIHZhciBwYXJ0ID0gcGFyc2VJbnQoYXR0clsnTEFTVC1QQVJUJ10pO1xuXG4gICAgICAgICAgaWYgKHByZXZpb3VzICYmIHRoaXMuaGxzLmNvbmZpZy5sb3dMYXRlbmN5TW9kZSkge1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRHb2FsID0gTWF0aC5taW4ocHJldmlvdXMuYWdlIC0gcHJldmlvdXMucGFydFRhcmdldCwgcHJldmlvdXMudGFyZ2V0ZHVyYXRpb24pO1xuXG4gICAgICAgICAgICBpZiAocGFydCAhPT0gdW5kZWZpbmVkICYmIGN1cnJlbnRHb2FsID4gcHJldmlvdXMucGFydFRhcmdldCkge1xuICAgICAgICAgICAgICBwYXJ0ICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKE9iamVjdChfaG9tZV9ydW5uZXJfd29ya19obHNfanNfaGxzX2pzX3NyY19wb2x5ZmlsbHNfbnVtYmVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJpc0Zpbml0ZU51bWJlclwiXSkobXNuKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBfdHlwZXNfbGV2ZWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkhsc1VybFBhcmFtZXRlcnNcIl0obXNuLCBPYmplY3QoX2hvbWVfcnVubmVyX3dvcmtfaGxzX2pzX2hsc19qc19zcmNfcG9seWZpbGxzX251bWJlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiaXNGaW5pdGVOdW1iZXJcIl0pKHBhcnQpID8gcGFydCA6IHVuZGVmaW5lZCwgX3R5cGVzX2xldmVsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJIbHNTa2lwXCJdLk5vKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmxvYWRQbGF5bGlzdCA9IGZ1bmN0aW9uIGxvYWRQbGF5bGlzdChobHNVcmxQYXJhbWV0ZXJzKSB7fTtcblxuICBfcHJvdG8uc2hvdWxkTG9hZFRyYWNrID0gZnVuY3Rpb24gc2hvdWxkTG9hZFRyYWNrKHRyYWNrKSB7XG4gICAgcmV0dXJuIHRoaXMuY2FuTG9hZCAmJiB0cmFjayAmJiAhIXRyYWNrLnVybCAmJiAoIXRyYWNrLmRldGFpbHMgfHwgdHJhY2suZGV0YWlscy5saXZlKTtcbiAgfTtcblxuICBfcHJvdG8ucGxheWxpc3RMb2FkZWQgPSBmdW5jdGlvbiBwbGF5bGlzdExvYWRlZChpbmRleCwgZGF0YSwgcHJldmlvdXNEZXRhaWxzKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHZhciBkZXRhaWxzID0gZGF0YS5kZXRhaWxzLFxuICAgICAgICBzdGF0cyA9IGRhdGEuc3RhdHM7IC8vIFNldCBsYXN0IHVwZGF0ZWQgZGF0ZS10aW1lXG5cbiAgICB2YXIgZWxhcHNlZCA9IHN0YXRzLmxvYWRpbmcuZW5kID8gTWF0aC5tYXgoMCwgc2VsZi5wZXJmb3JtYW5jZS5ub3coKSAtIHN0YXRzLmxvYWRpbmcuZW5kKSA6IDA7XG4gICAgZGV0YWlscy5hZHZhbmNlZERhdGVUaW1lID0gRGF0ZS5ub3coKSAtIGVsYXBzZWQ7IC8vIGlmIGN1cnJlbnQgcGxheWxpc3QgaXMgYSBsaXZlIHBsYXlsaXN0LCBhcm0gYSB0aW1lciB0byByZWxvYWQgaXRcblxuICAgIGlmIChkZXRhaWxzLmxpdmUgfHwgcHJldmlvdXNEZXRhaWxzICE9PSBudWxsICYmIHByZXZpb3VzRGV0YWlscyAhPT0gdm9pZCAwICYmIHByZXZpb3VzRGV0YWlscy5saXZlKSB7XG4gICAgICBkZXRhaWxzLnJlbG9hZGVkKHByZXZpb3VzRGV0YWlscyk7XG5cbiAgICAgIGlmIChwcmV2aW91c0RldGFpbHMpIHtcbiAgICAgICAgdGhpcy5sb2coXCJsaXZlIHBsYXlsaXN0IFwiICsgaW5kZXggKyBcIiBcIiArIChkZXRhaWxzLmFkdmFuY2VkID8gJ1JFRlJFU0hFRCAnICsgZGV0YWlscy5sYXN0UGFydFNuICsgJy0nICsgZGV0YWlscy5sYXN0UGFydEluZGV4IDogJ01JU1NFRCcpKTtcbiAgICAgIH0gLy8gTWVyZ2UgbGl2ZSBwbGF5bGlzdHMgdG8gYWRqdXN0IGZyYWdtZW50IHN0YXJ0cyBhbmQgZmlsbCBpbiBkZWx0YSBwbGF5bGlzdCBza2lwcGVkIHNlZ21lbnRzXG5cblxuICAgICAgaWYgKHByZXZpb3VzRGV0YWlscyAmJiBkZXRhaWxzLmZyYWdtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIE9iamVjdChfbGV2ZWxfaGVscGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJtZXJnZURldGFpbHNcIl0pKHByZXZpb3VzRGV0YWlscywgZGV0YWlscyk7XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5jYW5Mb2FkIHx8ICFkZXRhaWxzLmxpdmUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgZGVsaXZlcnlEaXJlY3RpdmVzO1xuICAgICAgdmFyIG1zbiA9IHVuZGVmaW5lZDtcbiAgICAgIHZhciBwYXJ0ID0gdW5kZWZpbmVkO1xuXG4gICAgICBpZiAoZGV0YWlscy5jYW5CbG9ja1JlbG9hZCAmJiBkZXRhaWxzLmVuZFNOICYmIGRldGFpbHMuYWR2YW5jZWQpIHtcbiAgICAgICAgLy8gTG9hZCBsZXZlbCB3aXRoIExMLUhMUyBkZWxpdmVyeSBkaXJlY3RpdmVzXG4gICAgICAgIHZhciBsb3dMYXRlbmN5TW9kZSA9IHRoaXMuaGxzLmNvbmZpZy5sb3dMYXRlbmN5TW9kZTtcbiAgICAgICAgdmFyIGxhc3RQYXJ0U24gPSBkZXRhaWxzLmxhc3RQYXJ0U247XG4gICAgICAgIHZhciBlbmRTbiA9IGRldGFpbHMuZW5kU047XG4gICAgICAgIHZhciBsYXN0UGFydEluZGV4ID0gZGV0YWlscy5sYXN0UGFydEluZGV4O1xuICAgICAgICB2YXIgaGFzUGFydHMgPSBsYXN0UGFydEluZGV4ICE9PSAtMTtcbiAgICAgICAgdmFyIGxhc3RQYXJ0ID0gbGFzdFBhcnRTbiA9PT0gZW5kU247IC8vIFdoZW4gbG93IGxhdGVuY3kgbW9kZSBpcyBkaXNhYmxlZCwgd2UnbGwgc2tpcCBwYXJ0IHJlcXVlc3RzIG9uY2UgdGhlIGxhc3QgcGFydCBpbmRleCBpcyBmb3VuZFxuXG4gICAgICAgIHZhciBuZXh0U25TdGFydEluZGV4ID0gbG93TGF0ZW5jeU1vZGUgPyAwIDogbGFzdFBhcnRJbmRleDtcblxuICAgICAgICBpZiAoaGFzUGFydHMpIHtcbiAgICAgICAgICBtc24gPSBsYXN0UGFydCA/IGVuZFNuICsgMSA6IGxhc3RQYXJ0U247XG4gICAgICAgICAgcGFydCA9IGxhc3RQYXJ0ID8gbmV4dFNuU3RhcnRJbmRleCA6IGxhc3RQYXJ0SW5kZXggKyAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1zbiA9IGVuZFNuICsgMTtcbiAgICAgICAgfSAvLyBMb3ctTGF0ZW5jeSBDRE4gVHVuZS1pbjogXCJhZ2VcIiBoZWFkZXIgYW5kIHRpbWUgc2luY2UgbG9hZCBpbmRpY2F0ZXMgd2UncmUgYmVoaW5kIGJ5IG1vcmUgdGhhbiBvbmUgcGFydFxuICAgICAgICAvLyBVcGRhdGUgZGlyZWN0aXZlcyB0byBvYnRhaW4gdGhlIFBsYXlsaXN0IHRoYXQgaGFzIHRoZSBlc3RpbWF0ZWQgYWRkaXRpb25hbCBkdXJhdGlvbiBvZiBtZWRpYVxuXG5cbiAgICAgICAgdmFyIGxhc3RBZHZhbmNlZCA9IGRldGFpbHMuYWdlO1xuICAgICAgICB2YXIgY2RuQWdlID0gbGFzdEFkdmFuY2VkICsgZGV0YWlscy5hZ2VIZWFkZXI7XG4gICAgICAgIHZhciBjdXJyZW50R29hbCA9IE1hdGgubWluKGNkbkFnZSAtIGRldGFpbHMucGFydFRhcmdldCwgZGV0YWlscy50YXJnZXRkdXJhdGlvbiAqIDEuNSk7XG5cbiAgICAgICAgaWYgKGN1cnJlbnRHb2FsID4gMCkge1xuICAgICAgICAgIGlmIChwcmV2aW91c0RldGFpbHMgJiYgY3VycmVudEdvYWwgPiBwcmV2aW91c0RldGFpbHMudHVuZUluR29hbCkge1xuICAgICAgICAgICAgLy8gSWYgd2UgYXR0ZW1wdGVkIHRvIGdldCB0aGUgbmV4dCBvciBsYXRlc3QgcGxheWxpc3QgdXBkYXRlLCBidXQgY3VycmVudEdvYWwgaW5jcmVhc2VkLFxuICAgICAgICAgICAgLy8gdGhlbiB3ZSBlaXRoZXIgY2FuJ3QgY2F0Y2h1cCwgb3IgdGhlIFwiYWdlXCIgaGVhZGVyIGNhbm5vdCBiZSB0cnVzdGVkLlxuICAgICAgICAgICAgdGhpcy53YXJuKFwiQ0ROIFR1bmUtaW4gZ29hbCBpbmNyZWFzZWQgZnJvbTogXCIgKyBwcmV2aW91c0RldGFpbHMudHVuZUluR29hbCArIFwiIHRvOiBcIiArIGN1cnJlbnRHb2FsICsgXCIgd2l0aCBwbGF5bGlzdCBhZ2U6IFwiICsgZGV0YWlscy5hZ2UpO1xuICAgICAgICAgICAgY3VycmVudEdvYWwgPSAwO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgc2VnbWVudHMgPSBNYXRoLmZsb29yKGN1cnJlbnRHb2FsIC8gZGV0YWlscy50YXJnZXRkdXJhdGlvbik7XG4gICAgICAgICAgICBtc24gKz0gc2VnbWVudHM7XG5cbiAgICAgICAgICAgIGlmIChwYXJ0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgdmFyIHBhcnRzID0gTWF0aC5yb3VuZChjdXJyZW50R29hbCAlIGRldGFpbHMudGFyZ2V0ZHVyYXRpb24gLyBkZXRhaWxzLnBhcnRUYXJnZXQpO1xuICAgICAgICAgICAgICBwYXJ0ICs9IHBhcnRzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmxvZyhcIkNETiBUdW5lLWluIGFnZTogXCIgKyBkZXRhaWxzLmFnZUhlYWRlciArIFwicyBsYXN0IGFkdmFuY2VkIFwiICsgbGFzdEFkdmFuY2VkLnRvRml4ZWQoMikgKyBcInMgZ29hbDogXCIgKyBjdXJyZW50R29hbCArIFwiIHNraXAgc24gXCIgKyBzZWdtZW50cyArIFwiIHRvIHBhcnQgXCIgKyBwYXJ0KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkZXRhaWxzLnR1bmVJbkdvYWwgPSBjdXJyZW50R29hbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlbGl2ZXJ5RGlyZWN0aXZlcyA9IHRoaXMuZ2V0RGVsaXZlcnlEaXJlY3RpdmVzKGRldGFpbHMsIGRhdGEuZGVsaXZlcnlEaXJlY3RpdmVzLCBtc24sIHBhcnQpO1xuXG4gICAgICAgIGlmIChsb3dMYXRlbmN5TW9kZSB8fCAhbGFzdFBhcnQpIHtcbiAgICAgICAgICB0aGlzLmxvYWRQbGF5bGlzdChkZWxpdmVyeURpcmVjdGl2ZXMpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsaXZlcnlEaXJlY3RpdmVzID0gdGhpcy5nZXREZWxpdmVyeURpcmVjdGl2ZXMoZGV0YWlscywgZGF0YS5kZWxpdmVyeURpcmVjdGl2ZXMsIG1zbiwgcGFydCk7XG4gICAgICB9XG5cbiAgICAgIHZhciByZWxvYWRJbnRlcnZhbCA9IE9iamVjdChfbGV2ZWxfaGVscGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJjb21wdXRlUmVsb2FkSW50ZXJ2YWxcIl0pKGRldGFpbHMsIHN0YXRzKTtcblxuICAgICAgaWYgKG1zbiAhPT0gdW5kZWZpbmVkICYmIGRldGFpbHMuY2FuQmxvY2tSZWxvYWQpIHtcbiAgICAgICAgcmVsb2FkSW50ZXJ2YWwgLT0gZGV0YWlscy5wYXJ0VGFyZ2V0IHx8IDE7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubG9nKFwicmVsb2FkIGxpdmUgcGxheWxpc3QgXCIgKyBpbmRleCArIFwiIGluIFwiICsgTWF0aC5yb3VuZChyZWxvYWRJbnRlcnZhbCkgKyBcIiBtc1wiKTtcbiAgICAgIHRoaXMudGltZXIgPSBzZWxmLnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3RoaXMubG9hZFBsYXlsaXN0KGRlbGl2ZXJ5RGlyZWN0aXZlcyk7XG4gICAgICB9LCByZWxvYWRJbnRlcnZhbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY2xlYXJUaW1lcigpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uZ2V0RGVsaXZlcnlEaXJlY3RpdmVzID0gZnVuY3Rpb24gZ2V0RGVsaXZlcnlEaXJlY3RpdmVzKGRldGFpbHMsIHByZXZpb3VzRGVsaXZlcnlEaXJlY3RpdmVzLCBtc24sIHBhcnQpIHtcbiAgICB2YXIgc2tpcCA9IE9iamVjdChfdHlwZXNfbGV2ZWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImdldFNraXBWYWx1ZVwiXSkoZGV0YWlscywgbXNuKTtcblxuICAgIGlmIChwcmV2aW91c0RlbGl2ZXJ5RGlyZWN0aXZlcyAhPT0gbnVsbCAmJiBwcmV2aW91c0RlbGl2ZXJ5RGlyZWN0aXZlcyAhPT0gdm9pZCAwICYmIHByZXZpb3VzRGVsaXZlcnlEaXJlY3RpdmVzLnNraXAgJiYgZGV0YWlscy5kZWx0YVVwZGF0ZUZhaWxlZCkge1xuICAgICAgbXNuID0gcHJldmlvdXNEZWxpdmVyeURpcmVjdGl2ZXMubXNuO1xuICAgICAgcGFydCA9IHByZXZpb3VzRGVsaXZlcnlEaXJlY3RpdmVzLnBhcnQ7XG4gICAgICBza2lwID0gX3R5cGVzX2xldmVsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJIbHNTa2lwXCJdLk5vO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgX3R5cGVzX2xldmVsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJIbHNVcmxQYXJhbWV0ZXJzXCJdKG1zbiwgcGFydCwgc2tpcCk7XG4gIH07XG5cbiAgX3Byb3RvLnJldHJ5TG9hZGluZ09yRmFpbCA9IGZ1bmN0aW9uIHJldHJ5TG9hZGluZ09yRmFpbChlcnJvckV2ZW50KSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICB2YXIgY29uZmlnID0gdGhpcy5obHMuY29uZmlnO1xuICAgIHZhciByZXRyeSA9IHRoaXMucmV0cnlDb3VudCA8IGNvbmZpZy5sZXZlbExvYWRpbmdNYXhSZXRyeTtcblxuICAgIGlmIChyZXRyeSkge1xuICAgICAgdmFyIF9lcnJvckV2ZW50JGNvbnRleHQ7XG5cbiAgICAgIHRoaXMucmV0cnlDb3VudCsrO1xuXG4gICAgICBpZiAoZXJyb3JFdmVudC5kZXRhaWxzLmluZGV4T2YoJ0xvYWRUaW1lT3V0JykgPiAtMSAmJiAoX2Vycm9yRXZlbnQkY29udGV4dCA9IGVycm9yRXZlbnQuY29udGV4dCkgIT09IG51bGwgJiYgX2Vycm9yRXZlbnQkY29udGV4dCAhPT0gdm9pZCAwICYmIF9lcnJvckV2ZW50JGNvbnRleHQuZGVsaXZlcnlEaXJlY3RpdmVzKSB7XG4gICAgICAgIC8vIFRoZSBMTC1ITFMgcmVxdWVzdCBhbHJlYWR5IHRpbWVkIG91dCBzbyByZXRyeSBpbW1lZGlhdGVseVxuICAgICAgICB0aGlzLndhcm4oXCJyZXRyeSBwbGF5bGlzdCBsb2FkaW5nICNcIiArIHRoaXMucmV0cnlDb3VudCArIFwiIGFmdGVyIFxcXCJcIiArIGVycm9yRXZlbnQuZGV0YWlscyArIFwiXFxcIlwiKTtcbiAgICAgICAgdGhpcy5sb2FkUGxheWxpc3QoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGV4cG9uZW50aWFsIGJhY2tvZmYgY2FwcGVkIHRvIG1heCByZXRyeSB0aW1lb3V0XG4gICAgICAgIHZhciBkZWxheSA9IE1hdGgubWluKE1hdGgucG93KDIsIHRoaXMucmV0cnlDb3VudCkgKiBjb25maWcubGV2ZWxMb2FkaW5nUmV0cnlEZWxheSwgY29uZmlnLmxldmVsTG9hZGluZ01heFJldHJ5VGltZW91dCk7IC8vIFNjaGVkdWxlIGxldmVsL3RyYWNrIHJlbG9hZFxuXG4gICAgICAgIHRoaXMudGltZXIgPSBzZWxmLnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBfdGhpczIubG9hZFBsYXlsaXN0KCk7XG4gICAgICAgIH0sIGRlbGF5KTtcbiAgICAgICAgdGhpcy53YXJuKFwicmV0cnkgcGxheWxpc3QgbG9hZGluZyAjXCIgKyB0aGlzLnJldHJ5Q291bnQgKyBcIiBpbiBcIiArIGRlbGF5ICsgXCIgbXMgYWZ0ZXIgXFxcIlwiICsgZXJyb3JFdmVudC5kZXRhaWxzICsgXCJcXFwiXCIpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLndhcm4oXCJjYW5ub3QgcmVjb3ZlciBmcm9tIGVycm9yIFxcXCJcIiArIGVycm9yRXZlbnQuZGV0YWlscyArIFwiXFxcIlwiKTsgLy8gc3RvcHBpbmcgbGl2ZSByZWxvYWRpbmcgdGltZXIgaWYgYW55XG5cbiAgICAgIHRoaXMuY2xlYXJUaW1lcigpOyAvLyBzd2l0Y2ggZXJyb3IgdG8gZmF0YWxcblxuICAgICAgZXJyb3JFdmVudC5mYXRhbCA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldHJ5O1xuICB9O1xuXG4gIHJldHVybiBCYXNlUGxheWxpc3RDb250cm9sbGVyO1xufSgpO1xuXG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY29udHJvbGxlci9iYXNlLXN0cmVhbS1jb250cm9sbGVyLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9jb250cm9sbGVyL2Jhc2Utc3RyZWFtLWNvbnRyb2xsZXIudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IFN0YXRlLCBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlN0YXRlXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gU3RhdGU7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImRlZmF1bHRcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBCYXNlU3RyZWFtQ29udHJvbGxlcjsgfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2hvbWVfcnVubmVyX3dvcmtfaGxzX2pzX2hsc19qc19zcmNfcG9seWZpbGxzX251bWJlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zcmMvcG9seWZpbGxzL251bWJlciAqLyBcIi4vc3JjL3BvbHlmaWxscy9udW1iZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3Rhc2tfbG9vcF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdGFzay1sb29wICovIFwiLi9zcmMvdGFzay1sb29wLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9mcmFnbWVudF90cmFja2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ZyYWdtZW50LXRyYWNrZXIgKi8gXCIuL3NyYy9jb250cm9sbGVyL2ZyYWdtZW50LXRyYWNrZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2J1ZmZlcl9oZWxwZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL2J1ZmZlci1oZWxwZXIgKi8gXCIuL3NyYy91dGlscy9idWZmZXItaGVscGVyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL2xvZ2dlciAqLyBcIi4vc3JjL3V0aWxzL2xvZ2dlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9ldmVudHMgKi8gXCIuL3NyYy9ldmVudHMudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZXJyb3JzICovIFwiLi9zcmMvZXJyb3JzLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF90eXBlc190cmFuc211eGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi90eXBlcy90cmFuc211eGVyICovIFwiLi9zcmMvdHlwZXMvdHJhbnNtdXhlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfbXA0X3Rvb2xzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV84X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9tcDQtdG9vbHMgKi8gXCIuL3NyYy91dGlscy9tcDQtdG9vbHMudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2Rpc2NvbnRpbnVpdGllc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvZGlzY29udGludWl0aWVzICovIFwiLi9zcmMvdXRpbHMvZGlzY29udGludWl0aWVzLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9mcmFnbWVudF9maW5kZXJzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9mcmFnbWVudC1maW5kZXJzICovIFwiLi9zcmMvY29udHJvbGxlci9mcmFnbWVudC1maW5kZXJzLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9sZXZlbF9oZWxwZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzExX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2xldmVsLWhlbHBlciAqLyBcIi4vc3JjL2NvbnRyb2xsZXIvbGV2ZWwtaGVscGVyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9sb2FkZXJfZnJhZ21lbnRfbG9hZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vbG9hZGVyL2ZyYWdtZW50LWxvYWRlciAqLyBcIi4vc3JjL2xvYWRlci9mcmFnbWVudC1sb2FkZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2NyeXB0X2RlY3J5cHRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2NyeXB0L2RlY3J5cHRlciAqLyBcIi4vc3JjL2NyeXB0L2RlY3J5cHRlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfdGltZV9yYW5nZXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzE0X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy90aW1lLXJhbmdlcyAqLyBcIi4vc3JjL3V0aWxzL3RpbWUtcmFuZ2VzLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF90eXBlc19sb2FkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzE1X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi90eXBlcy9sb2FkZXIgKi8gXCIuL3NyYy90eXBlcy9sb2FkZXIudHNcIik7XG5cblxuXG5cblxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTsgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7IF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxudmFyIFN0YXRlID0ge1xuICBTVE9QUEVEOiAnU1RPUFBFRCcsXG4gIElETEU6ICdJRExFJyxcbiAgS0VZX0xPQURJTkc6ICdLRVlfTE9BRElORycsXG4gIEZSQUdfTE9BRElORzogJ0ZSQUdfTE9BRElORycsXG4gIEZSQUdfTE9BRElOR19XQUlUSU5HX1JFVFJZOiAnRlJBR19MT0FESU5HX1dBSVRJTkdfUkVUUlknLFxuICBXQUlUSU5HX1RSQUNLOiAnV0FJVElOR19UUkFDSycsXG4gIFBBUlNJTkc6ICdQQVJTSU5HJyxcbiAgUEFSU0VEOiAnUEFSU0VEJyxcbiAgQkFDS1RSQUNLSU5HOiAnQkFDS1RSQUNLSU5HJyxcbiAgRU5ERUQ6ICdFTkRFRCcsXG4gIEVSUk9SOiAnRVJST1InLFxuICBXQUlUSU5HX0lOSVRfUFRTOiAnV0FJVElOR19JTklUX1BUUycsXG4gIFdBSVRJTkdfTEVWRUw6ICdXQUlUSU5HX0xFVkVMJ1xufTtcblxudmFyIEJhc2VTdHJlYW1Db250cm9sbGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfVGFza0xvb3ApIHtcbiAgX2luaGVyaXRzTG9vc2UoQmFzZVN0cmVhbUNvbnRyb2xsZXIsIF9UYXNrTG9vcCk7XG5cbiAgZnVuY3Rpb24gQmFzZVN0cmVhbUNvbnRyb2xsZXIoaGxzLCBmcmFnbWVudFRyYWNrZXIsIGxvZ1ByZWZpeCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIF90aGlzID0gX1Rhc2tMb29wLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICBfdGhpcy5obHMgPSB2b2lkIDA7XG4gICAgX3RoaXMuZnJhZ1ByZXZpb3VzID0gbnVsbDtcbiAgICBfdGhpcy5mcmFnQ3VycmVudCA9IG51bGw7XG4gICAgX3RoaXMuZnJhZ21lbnRUcmFja2VyID0gdm9pZCAwO1xuICAgIF90aGlzLnRyYW5zbXV4ZXIgPSBudWxsO1xuICAgIF90aGlzLl9zdGF0ZSA9IFN0YXRlLlNUT1BQRUQ7XG4gICAgX3RoaXMubWVkaWEgPSB2b2lkIDA7XG4gICAgX3RoaXMubWVkaWFCdWZmZXIgPSB2b2lkIDA7XG4gICAgX3RoaXMuY29uZmlnID0gdm9pZCAwO1xuICAgIF90aGlzLmJpdHJhdGVUZXN0ID0gZmFsc2U7XG4gICAgX3RoaXMubGFzdEN1cnJlbnRUaW1lID0gMDtcbiAgICBfdGhpcy5uZXh0TG9hZFBvc2l0aW9uID0gMDtcbiAgICBfdGhpcy5zdGFydFBvc2l0aW9uID0gMDtcbiAgICBfdGhpcy5sb2FkZWRtZXRhZGF0YSA9IGZhbHNlO1xuICAgIF90aGlzLmZyYWdMb2FkRXJyb3IgPSAwO1xuICAgIF90aGlzLnJldHJ5RGF0ZSA9IDA7XG4gICAgX3RoaXMubGV2ZWxzID0gbnVsbDtcbiAgICBfdGhpcy5mcmFnbWVudExvYWRlciA9IHZvaWQgMDtcbiAgICBfdGhpcy5sZXZlbExhc3RMb2FkZWQgPSBudWxsO1xuICAgIF90aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCA9IGZhbHNlO1xuICAgIF90aGlzLmRlY3J5cHRlciA9IHZvaWQgMDtcbiAgICBfdGhpcy5pbml0UFRTID0gW107XG4gICAgX3RoaXMub252c2Vla2luZyA9IG51bGw7XG4gICAgX3RoaXMub252ZW5kZWQgPSBudWxsO1xuICAgIF90aGlzLmxvZ1ByZWZpeCA9ICcnO1xuICAgIF90aGlzLmxvZyA9IHZvaWQgMDtcbiAgICBfdGhpcy53YXJuID0gdm9pZCAwO1xuICAgIF90aGlzLmxvZ1ByZWZpeCA9IGxvZ1ByZWZpeDtcbiAgICBfdGhpcy5sb2cgPSBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXCJsb2dnZXJcIl0ubG9nLmJpbmQoX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fW1wibG9nZ2VyXCJdLCBsb2dQcmVmaXggKyBcIjpcIik7XG4gICAgX3RoaXMud2FybiA9IF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1tcImxvZ2dlclwiXS53YXJuLmJpbmQoX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fW1wibG9nZ2VyXCJdLCBsb2dQcmVmaXggKyBcIjpcIik7XG4gICAgX3RoaXMuaGxzID0gaGxzO1xuICAgIF90aGlzLmZyYWdtZW50TG9hZGVyID0gbmV3IF9sb2FkZXJfZnJhZ21lbnRfbG9hZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMl9fW1wiZGVmYXVsdFwiXShobHMuY29uZmlnKTtcbiAgICBfdGhpcy5mcmFnbWVudFRyYWNrZXIgPSBmcmFnbWVudFRyYWNrZXI7XG4gICAgX3RoaXMuY29uZmlnID0gaGxzLmNvbmZpZztcbiAgICBfdGhpcy5kZWNyeXB0ZXIgPSBuZXcgX2NyeXB0X2RlY3J5cHRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTNfX1tcImRlZmF1bHRcIl0oaGxzLCBobHMuY29uZmlnKTtcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1wiRXZlbnRzXCJdLktFWV9MT0FERUQsIF90aGlzLm9uS2V5TG9hZGVkLCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IEJhc2VTdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZTtcblxuICBfcHJvdG8uZG9UaWNrID0gZnVuY3Rpb24gZG9UaWNrKCkge1xuICAgIHRoaXMub25UaWNrRW5kKCk7XG4gIH07XG5cbiAgX3Byb3RvLm9uVGlja0VuZCA9IGZ1bmN0aW9uIG9uVGlja0VuZCgpIHt9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgO1xuXG4gIF9wcm90by5zdGFydExvYWQgPSBmdW5jdGlvbiBzdGFydExvYWQoc3RhcnRQb3NpdGlvbikge307XG5cbiAgX3Byb3RvLnN0b3BMb2FkID0gZnVuY3Rpb24gc3RvcExvYWQoKSB7XG4gICAgdGhpcy5mcmFnbWVudExvYWRlci5hYm9ydCgpO1xuICAgIHZhciBmcmFnID0gdGhpcy5mcmFnQ3VycmVudDtcblxuICAgIGlmIChmcmFnKSB7XG4gICAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5yZW1vdmVGcmFnbWVudChmcmFnKTtcbiAgICB9XG5cbiAgICB0aGlzLnJlc2V0VHJhbnNtdXhlcigpO1xuICAgIHRoaXMuZnJhZ0N1cnJlbnQgPSBudWxsO1xuICAgIHRoaXMuZnJhZ1ByZXZpb3VzID0gbnVsbDtcbiAgICB0aGlzLmNsZWFySW50ZXJ2YWwoKTtcbiAgICB0aGlzLmNsZWFyTmV4dFRpY2soKTtcbiAgICB0aGlzLnN0YXRlID0gU3RhdGUuU1RPUFBFRDtcbiAgfTtcblxuICBfcHJvdG8uX3N0cmVhbUVuZGVkID0gZnVuY3Rpb24gX3N0cmVhbUVuZGVkKGJ1ZmZlckluZm8sIGxldmVsRGV0YWlscykge1xuICAgIHZhciBmcmFnQ3VycmVudCA9IHRoaXMuZnJhZ0N1cnJlbnQsXG4gICAgICAgIGZyYWdtZW50VHJhY2tlciA9IHRoaXMuZnJhZ21lbnRUcmFja2VyOyAvLyB3ZSBqdXN0IGdvdCBkb25lIGxvYWRpbmcgdGhlIGZpbmFsIGZyYWdtZW50IGFuZCB0aGVyZSBpcyBubyBvdGhlciBidWZmZXJlZCByYW5nZSBhZnRlciAuLi5cbiAgICAvLyByYXRpb25hbGUgaXMgdGhhdCBpbiBjYXNlIHRoZXJlIGFyZSBhbnkgYnVmZmVyZWQgcmFuZ2VzIGFmdGVyLCBpdCBtZWFucyB0aGF0IHRoZXJlIGFyZSB1bmJ1ZmZlcmVkIHBvcnRpb24gaW4gYmV0d2VlblxuICAgIC8vIHNvIHdlIHNob3VsZCBub3Qgc3dpdGNoIHRvIEVOREVEIGluIHRoYXQgY2FzZSwgdG8gYmUgYWJsZSB0byBidWZmZXIgdGhlbVxuXG4gICAgaWYgKCFsZXZlbERldGFpbHMubGl2ZSAmJiBmcmFnQ3VycmVudCAmJiAvLyBOT1RFOiBCZWNhdXNlIG9mIHRoZSB3YXkgcGFydHMgYXJlIGN1cnJlbnRseSBwYXJzZWQvcmVwcmVzZW50ZWQgaW4gdGhlIHBsYXlsaXN0LCB3ZSBjYW4gZW5kIHVwXG4gICAgLy8gaW4gc2l0dWF0aW9ucyB3aGVyZSB0aGUgY3VycmVudCBmcmFnbWVudCBpcyBhY3R1YWxseSBncmVhdGVyIHRoYW4gbGV2ZWxEZXRhaWxzLmVuZFNOLiBXaGlsZVxuICAgIC8vIHRoaXMgZmVlbHMgbGlrZSB0aGUgXCJ3cm9uZyBwbGFjZVwiIHRvIGFjY291bnQgZm9yIHRoYXQsIHRoaXMgaXMgYSBuYXJyb3dlci9zYWZlciBjaGFuZ2UgdGhhblxuICAgIC8vIHVwZGF0aW5nIGUuZy4gTTNVOFBhcnNlcjo6cGFyc2VMZXZlbFBsYXlsaXN0KCkuXG4gICAgZnJhZ0N1cnJlbnQuc24gPj0gbGV2ZWxEZXRhaWxzLmVuZFNOICYmICFidWZmZXJJbmZvLm5leHRTdGFydCkge1xuICAgICAgdmFyIHBhcnRMaXN0ID0gbGV2ZWxEZXRhaWxzLnBhcnRMaXN0OyAvLyBTaW5jZSB0aGUgbGFzdCBwYXJ0IGlzbid0IGd1YXJhbnRlZWQgdG8gY29ycmVzcG9uZCB0byBmcmFnQ3VycmVudCBmb3IgbGwtaGxzLCBjaGVjayBpbnN0ZWFkIGlmIHRoZSBsYXN0IHBhcnQgaXMgYnVmZmVyZWQuXG5cbiAgICAgIGlmIChwYXJ0TGlzdCAhPT0gbnVsbCAmJiBwYXJ0TGlzdCAhPT0gdm9pZCAwICYmIHBhcnRMaXN0Lmxlbmd0aCkge1xuICAgICAgICB2YXIgbGFzdFBhcnQgPSBwYXJ0TGlzdFtwYXJ0TGlzdC5sZW5ndGggLSAxXTsgLy8gQ2hlY2tpbmcgdGhlIG1pZHBvaW50IG9mIHRoZSBwYXJ0IGZvciBwb3RlbnRpYWwgbWFyZ2luIG9mIGVycm9yIGFuZCByZWxhdGVkIGlzc3Vlcy5cbiAgICAgICAgLy8gTk9URTogVGVjaG5pY2FsbHkgSSBiZWxpZXZlIHBhcnRzIGNvdWxkIHlpZWxkIGNvbnRlbnQgdGhhdCBpcyA8IHRoZSBjb21wdXRlZCBkdXJhdGlvbiAoaW5jbHVkaW5nIHBvdGVudGlhbCBhIGR1cmF0aW9uIG9mIDApXG4gICAgICAgIC8vIGFuZCBzdGlsbCBiZSBzcGVjLWNvbXBsaWFudCwgc28gdGhlcmUgbWF5IHN0aWxsIGJlIGVkZ2UgY2FzZXMgaGVyZS4gTGlrZXdpc2UsIHRoZXJlIGNvdWxkIGJlIGlzc3VlcyBpbiBlbmQgb2Ygc3RyZWFtXG4gICAgICAgIC8vIHBhcnQgbWlzbWF0Y2hlcyBmb3IgaW5kZXBlbmRlbnQgYXVkaW8gYW5kIHZpZGVvIHBsYXlsaXN0cy9zZWdtZW50cy5cblxuICAgICAgICB2YXIgbGFzdFBhcnRCdWZmZXJlZCA9IF91dGlsc19idWZmZXJfaGVscGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJCdWZmZXJIZWxwZXJcIl0uaXNCdWZmZXJlZCh0aGlzLm1lZGlhLCBsYXN0UGFydC5zdGFydCArIGxhc3RQYXJ0LmR1cmF0aW9uIC8gMik7XG4gICAgICAgIHJldHVybiBsYXN0UGFydEJ1ZmZlcmVkO1xuICAgICAgfVxuXG4gICAgICB2YXIgZnJhZ1N0YXRlID0gZnJhZ21lbnRUcmFja2VyLmdldFN0YXRlKGZyYWdDdXJyZW50KTtcbiAgICAgIHJldHVybiBmcmFnU3RhdGUgPT09IF9mcmFnbWVudF90cmFja2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJGcmFnbWVudFN0YXRlXCJdLlBBUlRJQUwgfHwgZnJhZ1N0YXRlID09PSBfZnJhZ21lbnRfdHJhY2tlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiRnJhZ21lbnRTdGF0ZVwiXS5PSztcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgX3Byb3RvLm9uTWVkaWFBdHRhY2hlZCA9IGZ1bmN0aW9uIG9uTWVkaWFBdHRhY2hlZChldmVudCwgZGF0YSkge1xuICAgIHZhciBtZWRpYSA9IHRoaXMubWVkaWEgPSB0aGlzLm1lZGlhQnVmZmVyID0gZGF0YS5tZWRpYTtcbiAgICB0aGlzLm9udnNlZWtpbmcgPSB0aGlzLm9uTWVkaWFTZWVraW5nLmJpbmQodGhpcyk7XG4gICAgdGhpcy5vbnZlbmRlZCA9IHRoaXMub25NZWRpYUVuZGVkLmJpbmQodGhpcyk7XG4gICAgbWVkaWEuYWRkRXZlbnRMaXN0ZW5lcignc2Vla2luZycsIHRoaXMub252c2Vla2luZyk7XG4gICAgbWVkaWEuYWRkRXZlbnRMaXN0ZW5lcignZW5kZWQnLCB0aGlzLm9udmVuZGVkKTtcbiAgICB2YXIgY29uZmlnID0gdGhpcy5jb25maWc7XG5cbiAgICBpZiAodGhpcy5sZXZlbHMgJiYgY29uZmlnLmF1dG9TdGFydExvYWQgJiYgdGhpcy5zdGF0ZSA9PT0gU3RhdGUuU1RPUFBFRCkge1xuICAgICAgdGhpcy5zdGFydExvYWQoY29uZmlnLnN0YXJ0UG9zaXRpb24pO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8ub25NZWRpYURldGFjaGluZyA9IGZ1bmN0aW9uIG9uTWVkaWFEZXRhY2hpbmcoKSB7XG4gICAgdmFyIG1lZGlhID0gdGhpcy5tZWRpYTtcblxuICAgIGlmIChtZWRpYSAhPT0gbnVsbCAmJiBtZWRpYSAhPT0gdm9pZCAwICYmIG1lZGlhLmVuZGVkKSB7XG4gICAgICB0aGlzLmxvZygnTVNFIGRldGFjaGluZyBhbmQgdmlkZW8gZW5kZWQsIHJlc2V0IHN0YXJ0UG9zaXRpb24nKTtcbiAgICAgIHRoaXMuc3RhcnRQb3NpdGlvbiA9IHRoaXMubGFzdEN1cnJlbnRUaW1lID0gMDtcbiAgICB9IC8vIHJlbW92ZSB2aWRlbyBsaXN0ZW5lcnNcblxuXG4gICAgaWYgKG1lZGlhKSB7XG4gICAgICBtZWRpYS5yZW1vdmVFdmVudExpc3RlbmVyKCdzZWVraW5nJywgdGhpcy5vbnZzZWVraW5nKTtcbiAgICAgIG1lZGlhLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2VuZGVkJywgdGhpcy5vbnZlbmRlZCk7XG4gICAgICB0aGlzLm9udnNlZWtpbmcgPSB0aGlzLm9udmVuZGVkID0gbnVsbDtcbiAgICB9XG5cbiAgICB0aGlzLm1lZGlhID0gdGhpcy5tZWRpYUJ1ZmZlciA9IG51bGw7XG4gICAgdGhpcy5sb2FkZWRtZXRhZGF0YSA9IGZhbHNlO1xuICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyLnJlbW92ZUFsbEZyYWdtZW50cygpO1xuICAgIHRoaXMuc3RvcExvYWQoKTtcbiAgfTtcblxuICBfcHJvdG8ub25NZWRpYVNlZWtpbmcgPSBmdW5jdGlvbiBvbk1lZGlhU2Vla2luZygpIHtcbiAgICB2YXIgY29uZmlnID0gdGhpcy5jb25maWcsXG4gICAgICAgIGZyYWdDdXJyZW50ID0gdGhpcy5mcmFnQ3VycmVudCxcbiAgICAgICAgbWVkaWEgPSB0aGlzLm1lZGlhLFxuICAgICAgICBtZWRpYUJ1ZmZlciA9IHRoaXMubWVkaWFCdWZmZXIsXG4gICAgICAgIHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICB2YXIgY3VycmVudFRpbWUgPSBtZWRpYSA/IG1lZGlhLmN1cnJlbnRUaW1lIDogMDtcbiAgICB2YXIgYnVmZmVySW5mbyA9IF91dGlsc19idWZmZXJfaGVscGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJCdWZmZXJIZWxwZXJcIl0uYnVmZmVySW5mbyhtZWRpYUJ1ZmZlciB8fCBtZWRpYSwgY3VycmVudFRpbWUsIGNvbmZpZy5tYXhCdWZmZXJIb2xlKTtcbiAgICB0aGlzLmxvZyhcIm1lZGlhIHNlZWtpbmcgdG8gXCIgKyAoT2JqZWN0KF9ob21lX3J1bm5lcl93b3JrX2hsc19qc19obHNfanNfc3JjX3BvbHlmaWxsc19udW1iZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImlzRmluaXRlTnVtYmVyXCJdKShjdXJyZW50VGltZSkgPyBjdXJyZW50VGltZS50b0ZpeGVkKDMpIDogY3VycmVudFRpbWUpICsgXCIsIHN0YXRlOiBcIiArIHN0YXRlKTtcblxuICAgIGlmIChzdGF0ZSA9PT0gU3RhdGUuRU5ERUQpIHtcbiAgICAgIHRoaXMucmVzZXRMb2FkaW5nU3RhdGUoKTtcbiAgICB9IGVsc2UgaWYgKGZyYWdDdXJyZW50ICYmICFidWZmZXJJbmZvLmxlbikge1xuICAgICAgLy8gY2hlY2sgaWYgd2UgYXJlIHNlZWtpbmcgdG8gYSB1bmJ1ZmZlcmVkIGFyZWEgQU5EIGlmIGZyYWcgbG9hZGluZyBpcyBpbiBwcm9ncmVzc1xuICAgICAgdmFyIHRvbGVyYW5jZSA9IGNvbmZpZy5tYXhGcmFnTG9va1VwVG9sZXJhbmNlO1xuICAgICAgdmFyIGZyYWdTdGFydE9mZnNldCA9IGZyYWdDdXJyZW50LnN0YXJ0IC0gdG9sZXJhbmNlO1xuICAgICAgdmFyIGZyYWdFbmRPZmZzZXQgPSBmcmFnQ3VycmVudC5zdGFydCArIGZyYWdDdXJyZW50LmR1cmF0aW9uICsgdG9sZXJhbmNlO1xuICAgICAgdmFyIHBhc3RGcmFnbWVudCA9IGN1cnJlbnRUaW1lID4gZnJhZ0VuZE9mZnNldDsgLy8gY2hlY2sgaWYgdGhlIHNlZWsgcG9zaXRpb24gaXMgcGFzdCBjdXJyZW50IGZyYWdtZW50LCBhbmQgaWYgc28gYWJvcnQgbG9hZGluZ1xuXG4gICAgICBpZiAoY3VycmVudFRpbWUgPCBmcmFnU3RhcnRPZmZzZXQgfHwgcGFzdEZyYWdtZW50KSB7XG4gICAgICAgIGlmIChwYXN0RnJhZ21lbnQgJiYgZnJhZ0N1cnJlbnQubG9hZGVyKSB7XG4gICAgICAgICAgdGhpcy5sb2coJ3NlZWtpbmcgb3V0c2lkZSBvZiBidWZmZXIgd2hpbGUgZnJhZ21lbnQgbG9hZCBpbiBwcm9ncmVzcywgY2FuY2VsIGZyYWdtZW50IGxvYWQnKTtcbiAgICAgICAgICBmcmFnQ3VycmVudC5sb2FkZXIuYWJvcnQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucmVzZXRMb2FkaW5nU3RhdGUoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobWVkaWEpIHtcbiAgICAgIHRoaXMubGFzdEN1cnJlbnRUaW1lID0gY3VycmVudFRpbWU7XG4gICAgfSAvLyBpbiBjYXNlIHNlZWtpbmcgb2NjdXJzIGFsdGhvdWdoIG5vIG1lZGlhIGJ1ZmZlcmVkLCBhZGp1c3Qgc3RhcnRQb3NpdGlvbiBhbmQgbmV4dExvYWRQb3NpdGlvbiB0byBzZWVrIHRhcmdldFxuXG5cbiAgICBpZiAoIXRoaXMubG9hZGVkbWV0YWRhdGEgJiYgIWJ1ZmZlckluZm8ubGVuKSB7XG4gICAgICB0aGlzLm5leHRMb2FkUG9zaXRpb24gPSB0aGlzLnN0YXJ0UG9zaXRpb24gPSBjdXJyZW50VGltZTtcbiAgICB9IC8vIEFzeW5jIHRpY2sgdG8gc3BlZWQgdXAgcHJvY2Vzc2luZ1xuXG5cbiAgICB0aGlzLnRpY2tJbW1lZGlhdGUoKTtcbiAgfTtcblxuICBfcHJvdG8ub25NZWRpYUVuZGVkID0gZnVuY3Rpb24gb25NZWRpYUVuZGVkKCkge1xuICAgIC8vIHJlc2V0IHN0YXJ0UG9zaXRpb24gYW5kIGxhc3RDdXJyZW50VGltZSB0byByZXN0YXJ0IHBsYXliYWNrIEAgc3RyZWFtIGJlZ2lubmluZ1xuICAgIHRoaXMuc3RhcnRQb3NpdGlvbiA9IHRoaXMubGFzdEN1cnJlbnRUaW1lID0gMDtcbiAgfTtcblxuICBfcHJvdG8ub25LZXlMb2FkZWQgPSBmdW5jdGlvbiBvbktleUxvYWRlZChldmVudCwgZGF0YSkge1xuICAgIGlmICh0aGlzLnN0YXRlICE9PSBTdGF0ZS5LRVlfTE9BRElORyB8fCBkYXRhLmZyYWcgIT09IHRoaXMuZnJhZ0N1cnJlbnQgfHwgIXRoaXMubGV2ZWxzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgdmFyIGxldmVsRGV0YWlscyA9IHRoaXMubGV2ZWxzW2RhdGEuZnJhZy5sZXZlbF0uZGV0YWlscztcblxuICAgIGlmIChsZXZlbERldGFpbHMpIHtcbiAgICAgIHRoaXMubG9hZEZyYWdtZW50KGRhdGEuZnJhZywgbGV2ZWxEZXRhaWxzLCBkYXRhLmZyYWcuc3RhcnQpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8ub25IYW5kbGVyRGVzdHJveWluZyA9IGZ1bmN0aW9uIG9uSGFuZGxlckRlc3Ryb3lpbmcoKSB7XG4gICAgdGhpcy5zdG9wTG9hZCgpO1xuXG4gICAgX1Rhc2tMb29wLnByb3RvdHlwZS5vbkhhbmRsZXJEZXN0cm95aW5nLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgX3Byb3RvLm9uSGFuZGxlckRlc3Ryb3llZCA9IGZ1bmN0aW9uIG9uSGFuZGxlckRlc3Ryb3llZCgpIHtcbiAgICB0aGlzLnN0YXRlID0gU3RhdGUuU1RPUFBFRDtcbiAgICB0aGlzLmhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1wiRXZlbnRzXCJdLktFWV9MT0FERUQsIHRoaXMub25LZXlMb2FkZWQsIHRoaXMpO1xuXG4gICAgaWYgKHRoaXMuZnJhZ21lbnRMb2FkZXIpIHtcbiAgICAgIHRoaXMuZnJhZ21lbnRMb2FkZXIuZGVzdHJveSgpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmRlY3J5cHRlcikge1xuICAgICAgdGhpcy5kZWNyeXB0ZXIuZGVzdHJveSgpO1xuICAgIH1cblxuICAgIHRoaXMuaGxzID0gdGhpcy5sb2cgPSB0aGlzLndhcm4gPSB0aGlzLmRlY3J5cHRlciA9IHRoaXMuZnJhZ21lbnRMb2FkZXIgPSB0aGlzLmZyYWdtZW50VHJhY2tlciA9IG51bGw7XG5cbiAgICBfVGFza0xvb3AucHJvdG90eXBlLm9uSGFuZGxlckRlc3Ryb3llZC5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIF9wcm90by5sb2FkS2V5ID0gZnVuY3Rpb24gbG9hZEtleShmcmFnLCBkZXRhaWxzKSB7XG4gICAgdGhpcy5sb2coXCJMb2FkaW5nIGtleSBmb3IgXCIgKyBmcmFnLnNuICsgXCIgb2YgW1wiICsgZGV0YWlscy5zdGFydFNOICsgXCItXCIgKyBkZXRhaWxzLmVuZFNOICsgXCJdLCBcIiArICh0aGlzLmxvZ1ByZWZpeCA9PT0gJ1tzdHJlYW0tY29udHJvbGxlcl0nID8gJ2xldmVsJyA6ICd0cmFjaycpICsgXCIgXCIgKyBmcmFnLmxldmVsKTtcbiAgICB0aGlzLnN0YXRlID0gU3RhdGUuS0VZX0xPQURJTkc7XG4gICAgdGhpcy5mcmFnQ3VycmVudCA9IGZyYWc7XG4gICAgdGhpcy5obHMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXCJFdmVudHNcIl0uS0VZX0xPQURJTkcsIHtcbiAgICAgIGZyYWc6IGZyYWdcbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG8ubG9hZEZyYWdtZW50ID0gZnVuY3Rpb24gbG9hZEZyYWdtZW50KGZyYWcsIGxldmVsRGV0YWlscywgdGFyZ2V0QnVmZmVyVGltZSkge1xuICAgIHRoaXMuX2xvYWRGcmFnRm9yUGxheWJhY2soZnJhZywgbGV2ZWxEZXRhaWxzLCB0YXJnZXRCdWZmZXJUaW1lKTtcbiAgfTtcblxuICBfcHJvdG8uX2xvYWRGcmFnRm9yUGxheWJhY2sgPSBmdW5jdGlvbiBfbG9hZEZyYWdGb3JQbGF5YmFjayhmcmFnLCBsZXZlbERldGFpbHMsIHRhcmdldEJ1ZmZlclRpbWUpIHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgIHZhciBwcm9ncmVzc0NhbGxiYWNrID0gZnVuY3Rpb24gcHJvZ3Jlc3NDYWxsYmFjayhkYXRhKSB7XG4gICAgICBpZiAoX3RoaXMyLmZyYWdDb250ZXh0Q2hhbmdlZChmcmFnKSkge1xuICAgICAgICBfdGhpczIud2FybihcIkZyYWdtZW50IFwiICsgZnJhZy5zbiArIChkYXRhLnBhcnQgPyAnIHA6ICcgKyBkYXRhLnBhcnQuaW5kZXggOiAnJykgKyBcIiBvZiBsZXZlbCBcIiArIGZyYWcubGV2ZWwgKyBcIiB3YXMgZHJvcHBlZCBkdXJpbmcgZG93bmxvYWQuXCIpO1xuXG4gICAgICAgIF90aGlzMi5mcmFnbWVudFRyYWNrZXIucmVtb3ZlRnJhZ21lbnQoZnJhZyk7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBmcmFnLnN0YXRzLmNodW5rQ291bnQrKztcblxuICAgICAgX3RoaXMyLl9oYW5kbGVGcmFnbWVudExvYWRQcm9ncmVzcyhkYXRhKTtcbiAgICB9O1xuXG4gICAgdGhpcy5fZG9GcmFnTG9hZChmcmFnLCBsZXZlbERldGFpbHMsIHRhcmdldEJ1ZmZlclRpbWUsIHByb2dyZXNzQ2FsbGJhY2spLnRoZW4oZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAvLyBpZiB3ZSdyZSBoZXJlIHdlIHByb2JhYmx5IG5lZWRlZCB0byBiYWNrdHJhY2sgb3IgYXJlIHdhaXRpbmcgZm9yIG1vcmUgcGFydHNcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBfdGhpczIuZnJhZ0xvYWRFcnJvciA9IDA7XG4gICAgICB2YXIgc3RhdGUgPSBfdGhpczIuc3RhdGU7XG5cbiAgICAgIGlmIChfdGhpczIuZnJhZ0NvbnRleHRDaGFuZ2VkKGZyYWcpKSB7XG4gICAgICAgIGlmIChzdGF0ZSA9PT0gU3RhdGUuRlJBR19MT0FESU5HIHx8IHN0YXRlID09PSBTdGF0ZS5CQUNLVFJBQ0tJTkcgfHwgIV90aGlzMi5mcmFnQ3VycmVudCAmJiBzdGF0ZSA9PT0gU3RhdGUuUEFSU0lORykge1xuICAgICAgICAgIF90aGlzMi5mcmFnbWVudFRyYWNrZXIucmVtb3ZlRnJhZ21lbnQoZnJhZyk7XG5cbiAgICAgICAgICBfdGhpczIuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoJ3BheWxvYWQnIGluIGRhdGEpIHtcbiAgICAgICAgX3RoaXMyLmxvZyhcIkxvYWRlZCBmcmFnbWVudCBcIiArIGZyYWcuc24gKyBcIiBvZiBsZXZlbCBcIiArIGZyYWcubGV2ZWwpO1xuXG4gICAgICAgIF90aGlzMi5obHMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXCJFdmVudHNcIl0uRlJBR19MT0FERUQsIGRhdGEpOyAvLyBUcmFja2VyIGJhY2t0cmFjayBtdXN0IGJlIGNhbGxlZCBhZnRlciBvbkZyYWdMb2FkZWQgdG8gdXBkYXRlIHRoZSBmcmFnbWVudCBlbnRpdHkgc3RhdGUgdG8gQkFDS1RSQUNLRURcbiAgICAgICAgLy8gVGhpcyBoYXBwZW5zIGFmdGVyIGhhbmRsZVRyYW5zbXV4Q29tcGxldGUgd2hlbiB0aGUgd29ya2VyIG9yIHByb2dyZXNzaXZlIGlzIGRpc2FibGVkXG5cblxuICAgICAgICBpZiAoX3RoaXMyLnN0YXRlID09PSBTdGF0ZS5CQUNLVFJBQ0tJTkcpIHtcbiAgICAgICAgICBfdGhpczIuZnJhZ21lbnRUcmFja2VyLmJhY2t0cmFjayhmcmFnLCBkYXRhKTtcblxuICAgICAgICAgIF90aGlzMi5yZXNldEZyYWdtZW50TG9hZGluZyhmcmFnKTtcblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfSAvLyBQYXNzIHRocm91Z2ggdGhlIHdob2xlIHBheWxvYWQ7IGNvbnRyb2xsZXJzIG5vdCBpbXBsZW1lbnRpbmcgcHJvZ3Jlc3NpdmUgbG9hZGluZyByZWNlaXZlIGRhdGEgZnJvbSB0aGlzIGNhbGxiYWNrXG5cblxuICAgICAgX3RoaXMyLl9oYW5kbGVGcmFnbWVudExvYWRDb21wbGV0ZShkYXRhKTtcbiAgICB9KS5jYXRjaChmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICBfdGhpczIud2FybihyZWFzb24pO1xuXG4gICAgICBfdGhpczIucmVzZXRGcmFnbWVudExvYWRpbmcoZnJhZyk7XG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLmZsdXNoTWFpbkJ1ZmZlciA9IGZ1bmN0aW9uIGZsdXNoTWFpbkJ1ZmZlcihzdGFydE9mZnNldCwgZW5kT2Zmc2V0LCB0eXBlKSB7XG4gICAgaWYgKHR5cGUgPT09IHZvaWQgMCkge1xuICAgICAgdHlwZSA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKCEoc3RhcnRPZmZzZXQgLSBlbmRPZmZzZXQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBXaGVuIGFsdGVybmF0ZSBhdWRpbyBpcyBwbGF5aW5nLCB0aGUgYXVkaW8tc3RyZWFtLWNvbnRyb2xsZXIgaXMgcmVzcG9uc2libGUgZm9yIHRoZSBhdWRpbyBidWZmZXIuIE90aGVyd2lzZSxcbiAgICAvLyBwYXNzaW5nIGEgbnVsbCB0eXBlIGZsdXNoZXMgYm90aCBidWZmZXJzXG5cblxuICAgIHZhciBmbHVzaFNjb3BlID0ge1xuICAgICAgc3RhcnRPZmZzZXQ6IHN0YXJ0T2Zmc2V0LFxuICAgICAgZW5kT2Zmc2V0OiBlbmRPZmZzZXQsXG4gICAgICB0eXBlOiB0eXBlXG4gICAgfTsgLy8gUmVzZXQgbG9hZCBlcnJvcnMgb24gZmx1c2hcblxuICAgIHRoaXMuZnJhZ0xvYWRFcnJvciA9IDA7XG4gICAgdGhpcy5obHMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXCJFdmVudHNcIl0uQlVGRkVSX0ZMVVNISU5HLCBmbHVzaFNjb3BlKTtcbiAgfTtcblxuICBfcHJvdG8uX2xvYWRJbml0U2VnbWVudCA9IGZ1bmN0aW9uIF9sb2FkSW5pdFNlZ21lbnQoZnJhZykge1xuICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgdGhpcy5fZG9GcmFnTG9hZChmcmFnKS50aGVuKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICBpZiAoIWRhdGEgfHwgX3RoaXMzLmZyYWdDb250ZXh0Q2hhbmdlZChmcmFnKSB8fCAhX3RoaXMzLmxldmVscykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2luaXQgbG9hZCBhYm9ydGVkJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH0pLnRoZW4oZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgIHZhciBobHMgPSBfdGhpczMuaGxzO1xuICAgICAgdmFyIHBheWxvYWQgPSBkYXRhLnBheWxvYWQ7XG4gICAgICB2YXIgZGVjcnlwdERhdGEgPSBmcmFnLmRlY3J5cHRkYXRhOyAvLyBjaGVjayB0byBzZWUgaWYgdGhlIHBheWxvYWQgbmVlZHMgdG8gYmUgZGVjcnlwdGVkXG5cbiAgICAgIGlmIChwYXlsb2FkICYmIHBheWxvYWQuYnl0ZUxlbmd0aCA+IDAgJiYgZGVjcnlwdERhdGEgJiYgZGVjcnlwdERhdGEua2V5ICYmIGRlY3J5cHREYXRhLml2ICYmIGRlY3J5cHREYXRhLm1ldGhvZCA9PT0gJ0FFUy0xMjgnKSB7XG4gICAgICAgIHZhciBzdGFydFRpbWUgPSBzZWxmLnBlcmZvcm1hbmNlLm5vdygpOyAvLyBkZWNyeXB0IHRoZSBzdWJ0aXRsZXNcblxuICAgICAgICByZXR1cm4gX3RoaXMzLmRlY3J5cHRlci53ZWJDcnlwdG9EZWNyeXB0KG5ldyBVaW50OEFycmF5KHBheWxvYWQpLCBkZWNyeXB0RGF0YS5rZXkuYnVmZmVyLCBkZWNyeXB0RGF0YS5pdi5idWZmZXIpLnRoZW4oZnVuY3Rpb24gKGRlY3J5cHRlZERhdGEpIHtcbiAgICAgICAgICB2YXIgZW5kVGltZSA9IHNlbGYucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgICAgaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1wiRXZlbnRzXCJdLkZSQUdfREVDUllQVEVELCB7XG4gICAgICAgICAgICBmcmFnOiBmcmFnLFxuICAgICAgICAgICAgcGF5bG9hZDogZGVjcnlwdGVkRGF0YSxcbiAgICAgICAgICAgIHN0YXRzOiB7XG4gICAgICAgICAgICAgIHRzdGFydDogc3RhcnRUaW1lLFxuICAgICAgICAgICAgICB0ZGVjcnlwdDogZW5kVGltZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGRhdGEucGF5bG9hZCA9IGRlY3J5cHRlZERhdGE7XG4gICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9KS50aGVuKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICB2YXIgZnJhZ0N1cnJlbnQgPSBfdGhpczMuZnJhZ0N1cnJlbnQsXG4gICAgICAgICAgaGxzID0gX3RoaXMzLmhscyxcbiAgICAgICAgICBsZXZlbHMgPSBfdGhpczMubGV2ZWxzO1xuXG4gICAgICBpZiAoIWxldmVscykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2luaXQgbG9hZCBhYm9ydGVkLCBtaXNzaW5nIGxldmVscycpO1xuICAgICAgfVxuXG4gICAgICB2YXIgZGV0YWlscyA9IGxldmVsc1tmcmFnLmxldmVsXS5kZXRhaWxzO1xuICAgICAgY29uc29sZS5hc3NlcnQoZGV0YWlscywgJ0xldmVsIGRldGFpbHMgYXJlIGRlZmluZWQgd2hlbiBpbml0IHNlZ21lbnQgaXMgbG9hZGVkJyk7XG4gICAgICB2YXIgc3RhdHMgPSBmcmFnLnN0YXRzO1xuICAgICAgX3RoaXMzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgIF90aGlzMy5mcmFnTG9hZEVycm9yID0gMDtcbiAgICAgIGZyYWcuZGF0YSA9IG5ldyBVaW50OEFycmF5KGRhdGEucGF5bG9hZCk7XG4gICAgICBzdGF0cy5wYXJzaW5nLnN0YXJ0ID0gc3RhdHMuYnVmZmVyaW5nLnN0YXJ0ID0gc2VsZi5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIHN0YXRzLnBhcnNpbmcuZW5kID0gc3RhdHMuYnVmZmVyaW5nLmVuZCA9IHNlbGYucGVyZm9ybWFuY2Uubm93KCk7IC8vIFNpbGVuY2UgRlJBR19CVUZGRVJFRCBldmVudCBpZiBmcmFnQ3VycmVudCBpcyBudWxsXG5cbiAgICAgIGlmIChkYXRhLmZyYWcgPT09IGZyYWdDdXJyZW50KSB7XG4gICAgICAgIGhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcIkV2ZW50c1wiXS5GUkFHX0JVRkZFUkVELCB7XG4gICAgICAgICAgc3RhdHM6IHN0YXRzLFxuICAgICAgICAgIGZyYWc6IGZyYWdDdXJyZW50LFxuICAgICAgICAgIHBhcnQ6IG51bGwsXG4gICAgICAgICAgaWQ6IGZyYWcudHlwZVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgX3RoaXMzLnRpY2soKTtcbiAgICB9KS5jYXRjaChmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICBfdGhpczMud2FybihyZWFzb24pO1xuXG4gICAgICBfdGhpczMucmVzZXRGcmFnbWVudExvYWRpbmcoZnJhZyk7XG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLmZyYWdDb250ZXh0Q2hhbmdlZCA9IGZ1bmN0aW9uIGZyYWdDb250ZXh0Q2hhbmdlZChmcmFnKSB7XG4gICAgdmFyIGZyYWdDdXJyZW50ID0gdGhpcy5mcmFnQ3VycmVudDtcbiAgICByZXR1cm4gIWZyYWcgfHwgIWZyYWdDdXJyZW50IHx8IGZyYWcubGV2ZWwgIT09IGZyYWdDdXJyZW50LmxldmVsIHx8IGZyYWcuc24gIT09IGZyYWdDdXJyZW50LnNuIHx8IGZyYWcudXJsSWQgIT09IGZyYWdDdXJyZW50LnVybElkO1xuICB9O1xuXG4gIF9wcm90by5mcmFnQnVmZmVyZWRDb21wbGV0ZSA9IGZ1bmN0aW9uIGZyYWdCdWZmZXJlZENvbXBsZXRlKGZyYWcsIHBhcnQpIHtcbiAgICB2YXIgbWVkaWEgPSB0aGlzLm1lZGlhQnVmZmVyID8gdGhpcy5tZWRpYUJ1ZmZlciA6IHRoaXMubWVkaWE7XG4gICAgdGhpcy5sb2coXCJCdWZmZXJlZCBcIiArIGZyYWcudHlwZSArIFwiIHNuOiBcIiArIGZyYWcuc24gKyAocGFydCA/ICcgcGFydDogJyArIHBhcnQuaW5kZXggOiAnJykgKyBcIiBvZiBcIiArICh0aGlzLmxvZ1ByZWZpeCA9PT0gJ1tzdHJlYW0tY29udHJvbGxlcl0nID8gJ2xldmVsJyA6ICd0cmFjaycpICsgXCIgXCIgKyBmcmFnLmxldmVsICsgXCIgXCIgKyBfdXRpbHNfdGltZV9yYW5nZXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzE0X19bXCJkZWZhdWx0XCJdLnRvU3RyaW5nKF91dGlsc19idWZmZXJfaGVscGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJCdWZmZXJIZWxwZXJcIl0uZ2V0QnVmZmVyZWQobWVkaWEpKSk7XG4gICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgdGhpcy50aWNrKCk7XG4gIH07XG5cbiAgX3Byb3RvLl9oYW5kbGVGcmFnbWVudExvYWRDb21wbGV0ZSA9IGZ1bmN0aW9uIF9oYW5kbGVGcmFnbWVudExvYWRDb21wbGV0ZShmcmFnTG9hZGVkRW5kRGF0YSkge1xuICAgIHZhciB0cmFuc211eGVyID0gdGhpcy50cmFuc211eGVyO1xuXG4gICAgaWYgKCF0cmFuc211eGVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGZyYWcgPSBmcmFnTG9hZGVkRW5kRGF0YS5mcmFnLFxuICAgICAgICBwYXJ0ID0gZnJhZ0xvYWRlZEVuZERhdGEucGFydCxcbiAgICAgICAgcGFydHNMb2FkZWQgPSBmcmFnTG9hZGVkRW5kRGF0YS5wYXJ0c0xvYWRlZDsgLy8gSWYgd2UgZGlkIG5vdCBsb2FkIHBhcnRzLCBvciBsb2FkZWQgYWxsIHBhcnRzLCB3ZSBoYXZlIGNvbXBsZXRlIChub3QgcGFydGlhbCkgZnJhZ21lbnQgZGF0YVxuXG4gICAgdmFyIGNvbXBsZXRlID0gIXBhcnRzTG9hZGVkIHx8IHBhcnRzTG9hZGVkLmxlbmd0aCA9PT0gMCB8fCBwYXJ0c0xvYWRlZC5zb21lKGZ1bmN0aW9uIChmcmFnTG9hZGVkKSB7XG4gICAgICByZXR1cm4gIWZyYWdMb2FkZWQ7XG4gICAgfSk7XG4gICAgdmFyIGNodW5rTWV0YSA9IG5ldyBfdHlwZXNfdHJhbnNtdXhlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fW1wiQ2h1bmtNZXRhZGF0YVwiXShmcmFnLmxldmVsLCBmcmFnLnNuLCBmcmFnLnN0YXRzLmNodW5rQ291bnQgKyAxLCAwLCBwYXJ0ID8gcGFydC5pbmRleCA6IC0xLCAhY29tcGxldGUpO1xuICAgIHRyYW5zbXV4ZXIuZmx1c2goY2h1bmtNZXRhKTtcbiAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gIDtcblxuICBfcHJvdG8uX2hhbmRsZUZyYWdtZW50TG9hZFByb2dyZXNzID0gZnVuY3Rpb24gX2hhbmRsZUZyYWdtZW50TG9hZFByb2dyZXNzKGZyYWcpIHt9O1xuXG4gIF9wcm90by5fZG9GcmFnTG9hZCA9IGZ1bmN0aW9uIF9kb0ZyYWdMb2FkKGZyYWcsIGRldGFpbHMsIHRhcmdldEJ1ZmZlclRpbWUsIHByb2dyZXNzQ2FsbGJhY2spIHtcbiAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgIGlmICh0YXJnZXRCdWZmZXJUaW1lID09PSB2b2lkIDApIHtcbiAgICAgIHRhcmdldEJ1ZmZlclRpbWUgPSBudWxsO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5sZXZlbHMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZnJhZyBsb2FkIGFib3J0ZWQsIG1pc3NpbmcgbGV2ZWxzJyk7XG4gICAgfVxuXG4gICAgdGFyZ2V0QnVmZmVyVGltZSA9IE1hdGgubWF4KGZyYWcuc3RhcnQsIHRhcmdldEJ1ZmZlclRpbWUgfHwgMCk7XG5cbiAgICBpZiAodGhpcy5jb25maWcubG93TGF0ZW5jeU1vZGUgJiYgZGV0YWlscykge1xuICAgICAgdmFyIHBhcnRMaXN0ID0gZGV0YWlscy5wYXJ0TGlzdDtcblxuICAgICAgaWYgKHBhcnRMaXN0ICYmIHByb2dyZXNzQ2FsbGJhY2spIHtcbiAgICAgICAgaWYgKHRhcmdldEJ1ZmZlclRpbWUgPiBmcmFnLmVuZCAmJiBkZXRhaWxzLmZyYWdtZW50SGludCkge1xuICAgICAgICAgIGZyYWcgPSBkZXRhaWxzLmZyYWdtZW50SGludDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwYXJ0SW5kZXggPSB0aGlzLmdldE5leHRQYXJ0KHBhcnRMaXN0LCBmcmFnLCB0YXJnZXRCdWZmZXJUaW1lKTtcblxuICAgICAgICBpZiAocGFydEluZGV4ID4gLTEpIHtcbiAgICAgICAgICB2YXIgcGFydCA9IHBhcnRMaXN0W3BhcnRJbmRleF07XG4gICAgICAgICAgdGhpcy5sb2coXCJMb2FkaW5nIHBhcnQgc246IFwiICsgZnJhZy5zbiArIFwiIHA6IFwiICsgcGFydC5pbmRleCArIFwiIGNjOiBcIiArIGZyYWcuY2MgKyBcIiBvZiBwbGF5bGlzdCBbXCIgKyBkZXRhaWxzLnN0YXJ0U04gKyBcIi1cIiArIGRldGFpbHMuZW5kU04gKyBcIl0gcGFydHMgWzAtXCIgKyBwYXJ0SW5kZXggKyBcIi1cIiArIChwYXJ0TGlzdC5sZW5ndGggLSAxKSArIFwiXSBcIiArICh0aGlzLmxvZ1ByZWZpeCA9PT0gJ1tzdHJlYW0tY29udHJvbGxlcl0nID8gJ2xldmVsJyA6ICd0cmFjaycpICsgXCI6IFwiICsgZnJhZy5sZXZlbCArIFwiLCB0YXJnZXQ6IFwiICsgcGFyc2VGbG9hdCh0YXJnZXRCdWZmZXJUaW1lLnRvRml4ZWQoMykpKTtcbiAgICAgICAgICB0aGlzLm5leHRMb2FkUG9zaXRpb24gPSBwYXJ0LnN0YXJ0ICsgcGFydC5kdXJhdGlvbjtcbiAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuRlJBR19MT0FESU5HO1xuICAgICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1wiRXZlbnRzXCJdLkZSQUdfTE9BRElORywge1xuICAgICAgICAgICAgZnJhZzogZnJhZyxcbiAgICAgICAgICAgIHBhcnQ6IHBhcnRMaXN0W3BhcnRJbmRleF0sXG4gICAgICAgICAgICB0YXJnZXRCdWZmZXJUaW1lOiB0YXJnZXRCdWZmZXJUaW1lXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZG9GcmFnUGFydHNMb2FkKGZyYWcsIHBhcnRMaXN0LCBwYXJ0SW5kZXgsIHByb2dyZXNzQ2FsbGJhY2spLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzNC5oYW5kbGVGcmFnTG9hZEVycm9yKGVycm9yKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmICghZnJhZy51cmwgfHwgdGhpcy5sb2FkZWRFbmRPZlBhcnRzKHBhcnRMaXN0LCB0YXJnZXRCdWZmZXJUaW1lKSkge1xuICAgICAgICAgIC8vIEZyYWdtZW50IGhpbnQgaGFzIG5vIHBhcnRzXG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMubG9nKFwiTG9hZGluZyBmcmFnbWVudCBcIiArIGZyYWcuc24gKyBcIiBjYzogXCIgKyBmcmFnLmNjICsgXCIgXCIgKyAoZGV0YWlscyA/ICdvZiBbJyArIGRldGFpbHMuc3RhcnRTTiArICctJyArIGRldGFpbHMuZW5kU04gKyAnXSAnIDogJycpICsgKHRoaXMubG9nUHJlZml4ID09PSAnW3N0cmVhbS1jb250cm9sbGVyXScgPyAnbGV2ZWwnIDogJ3RyYWNrJykgKyBcIjogXCIgKyBmcmFnLmxldmVsICsgXCIsIHRhcmdldDogXCIgKyBwYXJzZUZsb2F0KHRhcmdldEJ1ZmZlclRpbWUudG9GaXhlZCgzKSkpOyAvLyBEb24ndCB1cGRhdGUgbmV4dExvYWRQb3NpdGlvbiBmb3IgZnJhZ21lbnRzIHdoaWNoIGFyZSBub3QgYnVmZmVyZWRcblxuICAgIGlmIChPYmplY3QoX2hvbWVfcnVubmVyX3dvcmtfaGxzX2pzX2hsc19qc19zcmNfcG9seWZpbGxzX251bWJlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiaXNGaW5pdGVOdW1iZXJcIl0pKGZyYWcuc24pICYmICF0aGlzLmJpdHJhdGVUZXN0KSB7XG4gICAgICB0aGlzLm5leHRMb2FkUG9zaXRpb24gPSBmcmFnLnN0YXJ0ICsgZnJhZy5kdXJhdGlvbjtcbiAgICB9XG5cbiAgICB0aGlzLnN0YXRlID0gU3RhdGUuRlJBR19MT0FESU5HO1xuICAgIHRoaXMuaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1wiRXZlbnRzXCJdLkZSQUdfTE9BRElORywge1xuICAgICAgZnJhZzogZnJhZyxcbiAgICAgIHRhcmdldEJ1ZmZlclRpbWU6IHRhcmdldEJ1ZmZlclRpbWVcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy5mcmFnbWVudExvYWRlci5sb2FkKGZyYWcsIHByb2dyZXNzQ2FsbGJhY2spLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgcmV0dXJuIF90aGlzNC5oYW5kbGVGcmFnTG9hZEVycm9yKGVycm9yKTtcbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG8uZG9GcmFnUGFydHNMb2FkID0gZnVuY3Rpb24gZG9GcmFnUGFydHNMb2FkKGZyYWcsIHBhcnRMaXN0LCBwYXJ0SW5kZXgsIHByb2dyZXNzQ2FsbGJhY2spIHtcbiAgICB2YXIgX3RoaXM1ID0gdGhpcztcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgcGFydHNMb2FkZWQgPSBbXTtcblxuICAgICAgdmFyIGxvYWRQYXJ0SW5kZXggPSBmdW5jdGlvbiBsb2FkUGFydEluZGV4KGluZGV4KSB7XG4gICAgICAgIHZhciBwYXJ0ID0gcGFydExpc3RbaW5kZXhdO1xuXG4gICAgICAgIF90aGlzNS5mcmFnbWVudExvYWRlci5sb2FkUGFydChmcmFnLCBwYXJ0LCBwcm9ncmVzc0NhbGxiYWNrKS50aGVuKGZ1bmN0aW9uIChwYXJ0TG9hZGVkRGF0YSkge1xuICAgICAgICAgIHBhcnRzTG9hZGVkW3BhcnQuaW5kZXhdID0gcGFydExvYWRlZERhdGE7XG4gICAgICAgICAgdmFyIGxvYWRlZFBhcnQgPSBwYXJ0TG9hZGVkRGF0YS5wYXJ0O1xuXG4gICAgICAgICAgX3RoaXM1Lmhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcIkV2ZW50c1wiXS5GUkFHX0xPQURFRCwgcGFydExvYWRlZERhdGEpO1xuXG4gICAgICAgICAgdmFyIG5leHRQYXJ0ID0gcGFydExpc3RbaW5kZXggKyAxXTtcblxuICAgICAgICAgIGlmIChuZXh0UGFydCAmJiBuZXh0UGFydC5mcmFnbWVudCA9PT0gZnJhZykge1xuICAgICAgICAgICAgbG9hZFBhcnRJbmRleChpbmRleCArIDEpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZSh7XG4gICAgICAgICAgICAgIGZyYWc6IGZyYWcsXG4gICAgICAgICAgICAgIHBhcnQ6IGxvYWRlZFBhcnQsXG4gICAgICAgICAgICAgIHBhcnRzTG9hZGVkOiBwYXJ0c0xvYWRlZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KS5jYXRjaChyZWplY3QpO1xuICAgICAgfTtcblxuICAgICAgbG9hZFBhcnRJbmRleChwYXJ0SW5kZXgpO1xuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90by5oYW5kbGVGcmFnTG9hZEVycm9yID0gZnVuY3Rpb24gaGFuZGxlRnJhZ0xvYWRFcnJvcihfcmVmKSB7XG4gICAgdmFyIGRhdGEgPSBfcmVmLmRhdGE7XG5cbiAgICBpZiAoZGF0YSAmJiBkYXRhLmRldGFpbHMgPT09IF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcIkVycm9yRGV0YWlsc1wiXS5JTlRFUk5BTF9BQk9SVEVEKSB7XG4gICAgICB0aGlzLmhhbmRsZUZyYWdMb2FkQWJvcnRlZChkYXRhLmZyYWcsIGRhdGEucGFydCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1wiRXZlbnRzXCJdLkVSUk9SLCBkYXRhKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICBfcHJvdG8uX2hhbmRsZVRyYW5zbXV4ZXJGbHVzaCA9IGZ1bmN0aW9uIF9oYW5kbGVUcmFuc211eGVyRmx1c2goY2h1bmtNZXRhKSB7XG4gICAgdmFyIGNvbnRleHQgPSB0aGlzLmdldEN1cnJlbnRDb250ZXh0KGNodW5rTWV0YSk7XG5cbiAgICBpZiAoIWNvbnRleHQgfHwgdGhpcy5zdGF0ZSAhPT0gU3RhdGUuUEFSU0lORykge1xuICAgICAgaWYgKCF0aGlzLmZyYWdDdXJyZW50KSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgfVxuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGZyYWcgPSBjb250ZXh0LmZyYWcsXG4gICAgICAgIHBhcnQgPSBjb250ZXh0LnBhcnQsXG4gICAgICAgIGxldmVsID0gY29udGV4dC5sZXZlbDtcbiAgICB2YXIgbm93ID0gc2VsZi5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICBmcmFnLnN0YXRzLnBhcnNpbmcuZW5kID0gbm93O1xuXG4gICAgaWYgKHBhcnQpIHtcbiAgICAgIHBhcnQuc3RhdHMucGFyc2luZy5lbmQgPSBub3c7XG4gICAgfVxuXG4gICAgdGhpcy51cGRhdGVMZXZlbFRpbWluZyhmcmFnLCBwYXJ0LCBsZXZlbCwgY2h1bmtNZXRhLnBhcnRpYWwpO1xuICB9O1xuXG4gIF9wcm90by5nZXRDdXJyZW50Q29udGV4dCA9IGZ1bmN0aW9uIGdldEN1cnJlbnRDb250ZXh0KGNodW5rTWV0YSkge1xuICAgIHZhciBsZXZlbHMgPSB0aGlzLmxldmVscztcbiAgICB2YXIgbGV2ZWxJbmRleCA9IGNodW5rTWV0YS5sZXZlbCxcbiAgICAgICAgc24gPSBjaHVua01ldGEuc24sXG4gICAgICAgIHBhcnRJbmRleCA9IGNodW5rTWV0YS5wYXJ0O1xuXG4gICAgaWYgKCFsZXZlbHMgfHwgIWxldmVsc1tsZXZlbEluZGV4XSkge1xuICAgICAgdGhpcy53YXJuKFwiTGV2ZWxzIG9iamVjdCB3YXMgdW5zZXQgd2hpbGUgYnVmZmVyaW5nIGZyYWdtZW50IFwiICsgc24gKyBcIiBvZiBsZXZlbCBcIiArIGxldmVsSW5kZXggKyBcIi4gVGhlIGN1cnJlbnQgY2h1bmsgd2lsbCBub3QgYmUgYnVmZmVyZWQuXCIpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIGxldmVsID0gbGV2ZWxzW2xldmVsSW5kZXhdO1xuICAgIHZhciBwYXJ0ID0gcGFydEluZGV4ID4gLTEgPyBPYmplY3QoX2xldmVsX2hlbHBlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTFfX1tcImdldFBhcnRXaXRoXCJdKShsZXZlbCwgc24sIHBhcnRJbmRleCkgOiBudWxsO1xuICAgIHZhciBmcmFnID0gcGFydCA/IHBhcnQuZnJhZ21lbnQgOiBPYmplY3QoX2xldmVsX2hlbHBlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTFfX1tcImdldEZyYWdtZW50V2l0aFNOXCJdKShsZXZlbCwgc24sIHRoaXMuZnJhZ0N1cnJlbnQpO1xuXG4gICAgaWYgKCFmcmFnKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgZnJhZzogZnJhZyxcbiAgICAgIHBhcnQ6IHBhcnQsXG4gICAgICBsZXZlbDogbGV2ZWxcbiAgICB9O1xuICB9O1xuXG4gIF9wcm90by5idWZmZXJGcmFnbWVudERhdGEgPSBmdW5jdGlvbiBidWZmZXJGcmFnbWVudERhdGEoZGF0YSwgZnJhZywgcGFydCwgY2h1bmtNZXRhKSB7XG4gICAgaWYgKCFkYXRhIHx8IHRoaXMuc3RhdGUgIT09IFN0YXRlLlBBUlNJTkcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZGF0YTEgPSBkYXRhLmRhdGExLFxuICAgICAgICBkYXRhMiA9IGRhdGEuZGF0YTI7XG4gICAgdmFyIGJ1ZmZlciA9IGRhdGExO1xuXG4gICAgaWYgKGRhdGExICYmIGRhdGEyKSB7XG4gICAgICAvLyBDb21iaW5lIHRoZSBtb29mICsgbWRhdCBzbyB0aGF0IHdlIGJ1ZmZlciB3aXRoIGEgc2luZ2xlIGFwcGVuZFxuICAgICAgYnVmZmVyID0gT2JqZWN0KF91dGlsc19tcDRfdG9vbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzhfX1tcImFwcGVuZFVpbnQ4QXJyYXlcIl0pKGRhdGExLCBkYXRhMik7XG4gICAgfVxuXG4gICAgaWYgKCFidWZmZXIgfHwgIWJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgc2VnbWVudCA9IHtcbiAgICAgIHR5cGU6IGRhdGEudHlwZSxcbiAgICAgIGZyYWc6IGZyYWcsXG4gICAgICBwYXJ0OiBwYXJ0LFxuICAgICAgY2h1bmtNZXRhOiBjaHVua01ldGEsXG4gICAgICBwYXJlbnQ6IGZyYWcudHlwZSxcbiAgICAgIGRhdGE6IGJ1ZmZlclxuICAgIH07XG4gICAgdGhpcy5obHMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXCJFdmVudHNcIl0uQlVGRkVSX0FQUEVORElORywgc2VnbWVudCk7XG5cbiAgICBpZiAoZGF0YS5kcm9wcGVkICYmIGRhdGEuaW5kZXBlbmRlbnQgJiYgIXBhcnQpIHtcbiAgICAgIC8vIENsZWFyIGJ1ZmZlciBzbyB0aGF0IHdlIHJlbG9hZCBwcmV2aW91cyBzZWdtZW50cyBzZXF1ZW50aWFsbHkgaWYgcmVxdWlyZWRcbiAgICAgIHRoaXMuZmx1c2hCdWZmZXJHYXAoZnJhZyk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5mbHVzaEJ1ZmZlckdhcCA9IGZ1bmN0aW9uIGZsdXNoQnVmZmVyR2FwKGZyYWcpIHtcbiAgICB2YXIgbWVkaWEgPSB0aGlzLm1lZGlhO1xuXG4gICAgaWYgKCFtZWRpYSkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gSWYgY3VycmVudFRpbWUgaXMgbm90IGJ1ZmZlcmVkLCBjbGVhciB0aGUgYmFjayBidWZmZXIgc28gdGhhdCB3ZSBjYW4gYmFja3RyYWNrIGFzIG11Y2ggYXMgbmVlZGVkXG5cblxuICAgIGlmICghX3V0aWxzX2J1ZmZlcl9oZWxwZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcIkJ1ZmZlckhlbHBlclwiXS5pc0J1ZmZlcmVkKG1lZGlhLCBtZWRpYS5jdXJyZW50VGltZSkpIHtcbiAgICAgIHRoaXMuZmx1c2hNYWluQnVmZmVyKDAsIGZyYWcuc3RhcnQpO1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gUmVtb3ZlIGJhY2stYnVmZmVyIHdpdGhvdXQgaW50ZXJydXB0aW5nIHBsYXliYWNrIHRvIGFsbG93IGJhY2sgdHJhY2tpbmdcblxuXG4gICAgdmFyIGN1cnJlbnRUaW1lID0gbWVkaWEuY3VycmVudFRpbWU7XG4gICAgdmFyIGJ1ZmZlckluZm8gPSBfdXRpbHNfYnVmZmVyX2hlbHBlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiQnVmZmVySGVscGVyXCJdLmJ1ZmZlckluZm8obWVkaWEsIGN1cnJlbnRUaW1lLCAwKTtcbiAgICB2YXIgZnJhZ0R1cmF0aW9uID0gZnJhZy5kdXJhdGlvbjtcbiAgICB2YXIgc2VnbWVudEZyYWN0aW9uID0gTWF0aC5taW4odGhpcy5jb25maWcubWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSAqIDIsIGZyYWdEdXJhdGlvbiAqIDAuMjUpO1xuICAgIHZhciBzdGFydCA9IE1hdGgubWF4KE1hdGgubWluKGZyYWcuc3RhcnQgLSBzZWdtZW50RnJhY3Rpb24sIGJ1ZmZlckluZm8uZW5kIC0gc2VnbWVudEZyYWN0aW9uKSwgY3VycmVudFRpbWUgKyBzZWdtZW50RnJhY3Rpb24pO1xuXG4gICAgaWYgKGZyYWcuc3RhcnQgLSBzdGFydCA+IHNlZ21lbnRGcmFjdGlvbikge1xuICAgICAgdGhpcy5mbHVzaE1haW5CdWZmZXIoc3RhcnQsIGZyYWcuc3RhcnQpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uZ2V0RndkQnVmZmVySW5mbyA9IGZ1bmN0aW9uIGdldEZ3ZEJ1ZmZlckluZm8oYnVmZmVyYWJsZSwgdHlwZSkge1xuICAgIHZhciBjb25maWcgPSB0aGlzLmNvbmZpZztcbiAgICB2YXIgcG9zID0gdGhpcy5nZXRMb2FkUG9zaXRpb24oKTtcblxuICAgIGlmICghT2JqZWN0KF9ob21lX3J1bm5lcl93b3JrX2hsc19qc19obHNfanNfc3JjX3BvbHlmaWxsc19udW1iZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImlzRmluaXRlTnVtYmVyXCJdKShwb3MpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgYnVmZmVySW5mbyA9IF91dGlsc19idWZmZXJfaGVscGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJCdWZmZXJIZWxwZXJcIl0uYnVmZmVySW5mbyhidWZmZXJhYmxlLCBwb3MsIGNvbmZpZy5tYXhCdWZmZXJIb2xlKTsgLy8gV29ya2Fyb3VuZCBmbGF3IGluIGdldHRpbmcgZm9yd2FyZCBidWZmZXIgd2hlbiBtYXhCdWZmZXJIb2xlIGlzIHNtYWxsZXIgdGhhbiBnYXAgYXQgY3VycmVudCBwb3NcblxuICAgIGlmIChidWZmZXJJbmZvLmxlbiA9PT0gMCAmJiBidWZmZXJJbmZvLm5leHRTdGFydCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgYnVmZmVyZWRGcmFnQXRQb3MgPSB0aGlzLmZyYWdtZW50VHJhY2tlci5nZXRCdWZmZXJlZEZyYWcocG9zLCB0eXBlKTtcblxuICAgICAgaWYgKGJ1ZmZlcmVkRnJhZ0F0UG9zICYmIGJ1ZmZlckluZm8ubmV4dFN0YXJ0IDwgYnVmZmVyZWRGcmFnQXRQb3MuZW5kKSB7XG4gICAgICAgIHJldHVybiBfdXRpbHNfYnVmZmVyX2hlbHBlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiQnVmZmVySGVscGVyXCJdLmJ1ZmZlckluZm8oYnVmZmVyYWJsZSwgcG9zLCBNYXRoLm1heChidWZmZXJJbmZvLm5leHRTdGFydCwgY29uZmlnLm1heEJ1ZmZlckhvbGUpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYnVmZmVySW5mbztcbiAgfTtcblxuICBfcHJvdG8uZ2V0TWF4QnVmZmVyTGVuZ3RoID0gZnVuY3Rpb24gZ2V0TWF4QnVmZmVyTGVuZ3RoKGxldmVsQml0cmF0ZSkge1xuICAgIHZhciBjb25maWcgPSB0aGlzLmNvbmZpZztcbiAgICB2YXIgbWF4QnVmTGVuO1xuXG4gICAgaWYgKGxldmVsQml0cmF0ZSkge1xuICAgICAgbWF4QnVmTGVuID0gTWF0aC5tYXgoOCAqIGNvbmZpZy5tYXhCdWZmZXJTaXplIC8gbGV2ZWxCaXRyYXRlLCBjb25maWcubWF4QnVmZmVyTGVuZ3RoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWF4QnVmTGVuID0gY29uZmlnLm1heEJ1ZmZlckxlbmd0aDtcbiAgICB9XG5cbiAgICByZXR1cm4gTWF0aC5taW4obWF4QnVmTGVuLCBjb25maWcubWF4TWF4QnVmZmVyTGVuZ3RoKTtcbiAgfTtcblxuICBfcHJvdG8ucmVkdWNlTWF4QnVmZmVyTGVuZ3RoID0gZnVuY3Rpb24gcmVkdWNlTWF4QnVmZmVyTGVuZ3RoKHRocmVzaG9sZCkge1xuICAgIHZhciBjb25maWcgPSB0aGlzLmNvbmZpZztcbiAgICB2YXIgbWluTGVuZ3RoID0gdGhyZXNob2xkIHx8IGNvbmZpZy5tYXhCdWZmZXJMZW5ndGg7XG5cbiAgICBpZiAoY29uZmlnLm1heE1heEJ1ZmZlckxlbmd0aCA+PSBtaW5MZW5ndGgpIHtcbiAgICAgIC8vIHJlZHVjZSBtYXggYnVmZmVyIGxlbmd0aCBhcyBpdCBtaWdodCBiZSB0b28gaGlnaC4gd2UgZG8gdGhpcyB0byBhdm9pZCBsb29wIGZsdXNoaW5nIC4uLlxuICAgICAgY29uZmlnLm1heE1heEJ1ZmZlckxlbmd0aCAvPSAyO1xuICAgICAgdGhpcy53YXJuKFwiUmVkdWNlIG1heCBidWZmZXIgbGVuZ3RoIHRvIFwiICsgY29uZmlnLm1heE1heEJ1ZmZlckxlbmd0aCArIFwic1wiKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICBfcHJvdG8uZ2V0TmV4dEZyYWdtZW50ID0gZnVuY3Rpb24gZ2V0TmV4dEZyYWdtZW50KHBvcywgbGV2ZWxEZXRhaWxzKSB7XG4gICAgdmFyIF9mcmFnLCBfZnJhZzI7XG5cbiAgICB2YXIgZnJhZ21lbnRzID0gbGV2ZWxEZXRhaWxzLmZyYWdtZW50cztcbiAgICB2YXIgZnJhZ0xlbiA9IGZyYWdtZW50cy5sZW5ndGg7XG5cbiAgICBpZiAoIWZyYWdMZW4pIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gLy8gZmluZCBmcmFnbWVudCBpbmRleCwgY29udGlndW91cyB3aXRoIGVuZCBvZiBidWZmZXIgcG9zaXRpb25cblxuXG4gICAgdmFyIGNvbmZpZyA9IHRoaXMuY29uZmlnO1xuICAgIHZhciBzdGFydCA9IGZyYWdtZW50c1swXS5zdGFydDtcbiAgICB2YXIgZnJhZztcblxuICAgIGlmIChsZXZlbERldGFpbHMubGl2ZSkge1xuICAgICAgdmFyIGluaXRpYWxMaXZlTWFuaWZlc3RTaXplID0gY29uZmlnLmluaXRpYWxMaXZlTWFuaWZlc3RTaXplO1xuXG4gICAgICBpZiAoZnJhZ0xlbiA8IGluaXRpYWxMaXZlTWFuaWZlc3RTaXplKSB7XG4gICAgICAgIHRoaXMud2FybihcIk5vdCBlbm91Z2ggZnJhZ21lbnRzIHRvIHN0YXJ0IHBsYXliYWNrIChoYXZlOiBcIiArIGZyYWdMZW4gKyBcIiwgbmVlZDogXCIgKyBpbml0aWFsTGl2ZU1hbmlmZXN0U2l6ZSArIFwiKVwiKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9IC8vIFRoZSByZWFsIGZyYWdtZW50IHN0YXJ0IHRpbWVzIGZvciBhIGxpdmUgc3RyZWFtIGFyZSBvbmx5IGtub3duIGFmdGVyIHRoZSBQVFMgcmFuZ2UgZm9yIHRoYXQgbGV2ZWwgaXMga25vd24uXG4gICAgICAvLyBJbiBvcmRlciB0byBkaXNjb3ZlciB0aGUgcmFuZ2UsIHdlIGxvYWQgdGhlIGJlc3QgbWF0Y2hpbmcgZnJhZ21lbnQgZm9yIHRoYXQgbGV2ZWwgYW5kIGRlbXV4IGl0LlxuICAgICAgLy8gRG8gbm90IGxvYWQgdXNpbmcgbGl2ZSBsb2dpYyBpZiB0aGUgc3RhcnRpbmcgZnJhZyBpcyByZXF1ZXN0ZWQgLSB3ZSB3YW50IHRvIHVzZSBnZXRGcmFnbWVudEF0UG9zaXRpb24oKSBzbyB0aGF0XG4gICAgICAvLyB3ZSBnZXQgdGhlIGZyYWdtZW50IG1hdGNoaW5nIHRoYXQgc3RhcnQgdGltZVxuXG5cbiAgICAgIGlmICghbGV2ZWxEZXRhaWxzLlBUU0tub3duICYmICF0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCAmJiB0aGlzLnN0YXJ0UG9zaXRpb24gPT09IC0xKSB7XG4gICAgICAgIGZyYWcgPSB0aGlzLmdldEluaXRpYWxMaXZlRnJhZ21lbnQobGV2ZWxEZXRhaWxzLCBmcmFnbWVudHMpO1xuICAgICAgICB0aGlzLnN0YXJ0UG9zaXRpb24gPSBmcmFnID8gdGhpcy5obHMubGl2ZVN5bmNQb3NpdGlvbiB8fCBmcmFnLnN0YXJ0IDogcG9zO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocG9zIDw9IHN0YXJ0KSB7XG4gICAgICAvLyBWb0QgcGxheWxpc3Q6IGlmIGxvYWRQb3NpdGlvbiBiZWZvcmUgc3RhcnQgb2YgcGxheWxpc3QsIGxvYWQgZmlyc3QgZnJhZ21lbnRcbiAgICAgIGZyYWcgPSBmcmFnbWVudHNbMF07XG4gICAgfSAvLyBJZiB3ZSBoYXZlbid0IHJ1biBpbnRvIGFueSBzcGVjaWFsIGNhc2VzIGFscmVhZHksIGp1c3QgbG9hZCB0aGUgZnJhZ21lbnQgbW9zdCBjbG9zZWx5IG1hdGNoaW5nIHRoZSByZXF1ZXN0ZWQgcG9zaXRpb25cblxuXG4gICAgaWYgKCFmcmFnKSB7XG4gICAgICB2YXIgZW5kID0gY29uZmlnLmxvd0xhdGVuY3lNb2RlID8gbGV2ZWxEZXRhaWxzLnBhcnRFbmQgOiBsZXZlbERldGFpbHMuZnJhZ21lbnRFbmQ7XG4gICAgICBmcmFnID0gdGhpcy5nZXRGcmFnbWVudEF0UG9zaXRpb24ocG9zLCBlbmQsIGxldmVsRGV0YWlscyk7XG4gICAgfSAvLyBJZiBhbiBpbml0U2VnbWVudCBpcyBwcmVzZW50LCBpdCBtdXN0IGJlIGJ1ZmZlcmVkIGZpcnN0XG5cblxuICAgIGlmICgoX2ZyYWcgPSBmcmFnKSAhPT0gbnVsbCAmJiBfZnJhZyAhPT0gdm9pZCAwICYmIF9mcmFnLmluaXRTZWdtZW50ICYmICEoKF9mcmFnMiA9IGZyYWcpICE9PSBudWxsICYmIF9mcmFnMiAhPT0gdm9pZCAwICYmIF9mcmFnMi5pbml0U2VnbWVudC5kYXRhKSAmJiAhdGhpcy5iaXRyYXRlVGVzdCkge1xuICAgICAgZnJhZyA9IGZyYWcuaW5pdFNlZ21lbnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZyYWc7XG4gIH07XG5cbiAgX3Byb3RvLmdldE5leHRQYXJ0ID0gZnVuY3Rpb24gZ2V0TmV4dFBhcnQocGFydExpc3QsIGZyYWcsIHRhcmdldEJ1ZmZlclRpbWUpIHtcbiAgICB2YXIgbmV4dFBhcnQgPSAtMTtcbiAgICB2YXIgY29udGlndW91cyA9IGZhbHNlO1xuICAgIHZhciBpbmRlcGVuZGVudEF0dHJPbWl0dGVkID0gdHJ1ZTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBwYXJ0TGlzdC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgdmFyIHBhcnQgPSBwYXJ0TGlzdFtpXTtcbiAgICAgIGluZGVwZW5kZW50QXR0ck9taXR0ZWQgPSBpbmRlcGVuZGVudEF0dHJPbWl0dGVkICYmICFwYXJ0LmluZGVwZW5kZW50O1xuXG4gICAgICBpZiAobmV4dFBhcnQgPiAtMSAmJiB0YXJnZXRCdWZmZXJUaW1lIDwgcGFydC5zdGFydCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgdmFyIGxvYWRlZCA9IHBhcnQubG9hZGVkO1xuXG4gICAgICBpZiAoIWxvYWRlZCAmJiAoY29udGlndW91cyB8fCBwYXJ0LmluZGVwZW5kZW50IHx8IGluZGVwZW5kZW50QXR0ck9taXR0ZWQpICYmIHBhcnQuZnJhZ21lbnQgPT09IGZyYWcpIHtcbiAgICAgICAgbmV4dFBhcnQgPSBpO1xuICAgICAgfVxuXG4gICAgICBjb250aWd1b3VzID0gbG9hZGVkO1xuICAgIH1cblxuICAgIHJldHVybiBuZXh0UGFydDtcbiAgfTtcblxuICBfcHJvdG8ubG9hZGVkRW5kT2ZQYXJ0cyA9IGZ1bmN0aW9uIGxvYWRlZEVuZE9mUGFydHMocGFydExpc3QsIHRhcmdldEJ1ZmZlclRpbWUpIHtcbiAgICB2YXIgbGFzdFBhcnQgPSBwYXJ0TGlzdFtwYXJ0TGlzdC5sZW5ndGggLSAxXTtcbiAgICByZXR1cm4gbGFzdFBhcnQgJiYgdGFyZ2V0QnVmZmVyVGltZSA+IGxhc3RQYXJ0LnN0YXJ0ICYmIGxhc3RQYXJ0LmxvYWRlZDtcbiAgfVxuICAvKlxuICAgVGhpcyBtZXRob2QgaXMgdXNlZCBmaW5kIHRoZSBiZXN0IG1hdGNoaW5nIGZpcnN0IGZyYWdtZW50IGZvciBhIGxpdmUgcGxheWxpc3QuIFRoaXMgZnJhZ21lbnQgaXMgdXNlZCB0byBjYWxjdWxhdGUgdGhlXG4gICBcInNsaWRpbmdcIiBvZiB0aGUgcGxheWxpc3QsIHdoaWNoIGlzIGl0cyBvZmZzZXQgZnJvbSB0aGUgc3RhcnQgb2YgcGxheWJhY2suIEFmdGVyIHNsaWRpbmcgd2UgY2FuIGNvbXB1dGUgdGhlIHJlYWxcbiAgIHN0YXJ0IGFuZCBlbmQgdGltZXMgZm9yIGVhY2ggZnJhZ21lbnQgaW4gdGhlIHBsYXlsaXN0IChhZnRlciB3aGljaCB0aGlzIG1ldGhvZCB3aWxsIG5vdCBuZWVkIHRvIGJlIGNhbGxlZCkuXG4gICovXG4gIDtcblxuICBfcHJvdG8uZ2V0SW5pdGlhbExpdmVGcmFnbWVudCA9IGZ1bmN0aW9uIGdldEluaXRpYWxMaXZlRnJhZ21lbnQobGV2ZWxEZXRhaWxzLCBmcmFnbWVudHMpIHtcbiAgICB2YXIgZnJhZ1ByZXZpb3VzID0gdGhpcy5mcmFnUHJldmlvdXM7XG4gICAgdmFyIGZyYWcgPSBudWxsO1xuXG4gICAgaWYgKGZyYWdQcmV2aW91cykge1xuICAgICAgaWYgKGxldmVsRGV0YWlscy5oYXNQcm9ncmFtRGF0ZVRpbWUpIHtcbiAgICAgICAgLy8gUHJlZmVyIHVzaW5nIFBEVCwgYmVjYXVzZSBpdCBjYW4gYmUgYWNjdXJhdGUgZW5vdWdoIHRvIGNob29zZSB0aGUgY29ycmVjdCBmcmFnbWVudCB3aXRob3V0IGtub3dpbmcgdGhlIGxldmVsIHNsaWRpbmdcbiAgICAgICAgdGhpcy5sb2coXCJMaXZlIHBsYXlsaXN0LCBzd2l0Y2hpbmcgcGxheWxpc3QsIGxvYWQgZnJhZyB3aXRoIHNhbWUgUERUOiBcIiArIGZyYWdQcmV2aW91cy5wcm9ncmFtRGF0ZVRpbWUpO1xuICAgICAgICBmcmFnID0gT2JqZWN0KF9mcmFnbWVudF9maW5kZXJzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMF9fW1wiZmluZEZyYWdtZW50QnlQRFRcIl0pKGZyYWdtZW50cywgZnJhZ1ByZXZpb3VzLmVuZFByb2dyYW1EYXRlVGltZSwgdGhpcy5jb25maWcubWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghZnJhZykge1xuICAgICAgICAvLyBTTiBkb2VzIG5vdCBuZWVkIHRvIGJlIGFjY3VyYXRlIGJldHdlZW4gcmVuZGl0aW9ucywgYnV0IGRlcGVuZGluZyBvbiB0aGUgcGFja2FnaW5nIGl0IG1heSBiZSBzby5cbiAgICAgICAgdmFyIHRhcmdldFNOID0gZnJhZ1ByZXZpb3VzLnNuICsgMTtcblxuICAgICAgICBpZiAodGFyZ2V0U04gPj0gbGV2ZWxEZXRhaWxzLnN0YXJ0U04gJiYgdGFyZ2V0U04gPD0gbGV2ZWxEZXRhaWxzLmVuZFNOKSB7XG4gICAgICAgICAgdmFyIGZyYWdOZXh0ID0gZnJhZ21lbnRzW3RhcmdldFNOIC0gbGV2ZWxEZXRhaWxzLnN0YXJ0U05dOyAvLyBFbnN1cmUgdGhhdCB3ZSdyZSBzdGF5aW5nIHdpdGhpbiB0aGUgY29udGludWl0eSByYW5nZSwgc2luY2UgUFRTIHJlc2V0cyB1cG9uIGEgbmV3IHJhbmdlXG5cbiAgICAgICAgICBpZiAoZnJhZ1ByZXZpb3VzLmNjID09PSBmcmFnTmV4dC5jYykge1xuICAgICAgICAgICAgZnJhZyA9IGZyYWdOZXh0O1xuICAgICAgICAgICAgdGhpcy5sb2coXCJMaXZlIHBsYXlsaXN0LCBzd2l0Y2hpbmcgcGxheWxpc3QsIGxvYWQgZnJhZyB3aXRoIG5leHQgU046IFwiICsgZnJhZy5zbik7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIEl0J3MgaW1wb3J0YW50IHRvIHN0YXkgd2l0aGluIHRoZSBjb250aW51aXR5IHJhbmdlIGlmIGF2YWlsYWJsZTsgb3RoZXJ3aXNlIHRoZSBmcmFnbWVudHMgaW4gdGhlIHBsYXlsaXN0XG4gICAgICAgIC8vIHdpbGwgaGF2ZSB0aGUgd3Jvbmcgc3RhcnQgdGltZXNcblxuXG4gICAgICAgIGlmICghZnJhZykge1xuICAgICAgICAgIGZyYWcgPSBPYmplY3QoX2ZyYWdtZW50X2ZpbmRlcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEwX19bXCJmaW5kRnJhZ1dpdGhDQ1wiXSkoZnJhZ21lbnRzLCBmcmFnUHJldmlvdXMuY2MpO1xuXG4gICAgICAgICAgaWYgKGZyYWcpIHtcbiAgICAgICAgICAgIHRoaXMubG9nKFwiTGl2ZSBwbGF5bGlzdCwgc3dpdGNoaW5nIHBsYXlsaXN0LCBsb2FkIGZyYWcgd2l0aCBzYW1lIENDOiBcIiArIGZyYWcuc24pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGaW5kIGEgbmV3IHN0YXJ0IGZyYWdtZW50IHdoZW4gZnJhZ1ByZXZpb3VzIGlzIG51bGxcbiAgICAgIHZhciBsaXZlU3RhcnQgPSB0aGlzLmhscy5saXZlU3luY1Bvc2l0aW9uO1xuXG4gICAgICBpZiAobGl2ZVN0YXJ0ICE9PSBudWxsKSB7XG4gICAgICAgIGZyYWcgPSB0aGlzLmdldEZyYWdtZW50QXRQb3NpdGlvbihsaXZlU3RhcnQsIHRoaXMuYml0cmF0ZVRlc3QgPyBsZXZlbERldGFpbHMuZnJhZ21lbnRFbmQgOiBsZXZlbERldGFpbHMuZWRnZSwgbGV2ZWxEZXRhaWxzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZnJhZztcbiAgfVxuICAvKlxuICBUaGlzIG1ldGhvZCBmaW5kcyB0aGUgYmVzdCBtYXRjaGluZyBmcmFnbWVudCBnaXZlbiB0aGUgcHJvdmlkZWQgcG9zaXRpb24uXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmdldEZyYWdtZW50QXRQb3NpdGlvbiA9IGZ1bmN0aW9uIGdldEZyYWdtZW50QXRQb3NpdGlvbihidWZmZXJFbmQsIGVuZCwgbGV2ZWxEZXRhaWxzKSB7XG4gICAgdmFyIGNvbmZpZyA9IHRoaXMuY29uZmlnLFxuICAgICAgICBmcmFnUHJldmlvdXMgPSB0aGlzLmZyYWdQcmV2aW91cztcbiAgICB2YXIgZnJhZ21lbnRzID0gbGV2ZWxEZXRhaWxzLmZyYWdtZW50cyxcbiAgICAgICAgZW5kU04gPSBsZXZlbERldGFpbHMuZW5kU047XG4gICAgdmFyIGZyYWdtZW50SGludCA9IGxldmVsRGV0YWlscy5mcmFnbWVudEhpbnQ7XG4gICAgdmFyIHRvbGVyYW5jZSA9IGNvbmZpZy5tYXhGcmFnTG9va1VwVG9sZXJhbmNlO1xuICAgIHZhciBsb2FkaW5nUGFydHMgPSAhIShjb25maWcubG93TGF0ZW5jeU1vZGUgJiYgbGV2ZWxEZXRhaWxzLnBhcnRMaXN0ICYmIGZyYWdtZW50SGludCk7XG5cbiAgICBpZiAobG9hZGluZ1BhcnRzICYmIGZyYWdtZW50SGludCAmJiAhdGhpcy5iaXRyYXRlVGVzdCkge1xuICAgICAgLy8gSW5jbHVkZSBpbmNvbXBsZXRlIGZyYWdtZW50IHdpdGggcGFydHMgYXQgZW5kXG4gICAgICBmcmFnbWVudHMgPSBmcmFnbWVudHMuY29uY2F0KGZyYWdtZW50SGludCk7XG4gICAgICBlbmRTTiA9IGZyYWdtZW50SGludC5zbjtcbiAgICB9XG5cbiAgICB2YXIgZnJhZztcblxuICAgIGlmIChidWZmZXJFbmQgPCBlbmQpIHtcbiAgICAgIHZhciBsb29rdXBUb2xlcmFuY2UgPSBidWZmZXJFbmQgPiBlbmQgLSB0b2xlcmFuY2UgPyAwIDogdG9sZXJhbmNlOyAvLyBSZW1vdmUgdGhlIHRvbGVyYW5jZSBpZiBpdCB3b3VsZCBwdXQgdGhlIGJ1ZmZlckVuZCBwYXN0IHRoZSBhY3R1YWwgZW5kIG9mIHN0cmVhbVxuICAgICAgLy8gVXNlcyBidWZmZXIgYW5kIHNlcXVlbmNlIG51bWJlciB0byBjYWxjdWxhdGUgc3dpdGNoIHNlZ21lbnQgKHJlcXVpcmVkIGlmIHVzaW5nIEVYVC1YLURJU0NPTlRJTlVJVFktU0VRVUVOQ0UpXG5cbiAgICAgIGZyYWcgPSBPYmplY3QoX2ZyYWdtZW50X2ZpbmRlcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEwX19bXCJmaW5kRnJhZ21lbnRCeVBUU1wiXSkoZnJhZ1ByZXZpb3VzLCBmcmFnbWVudHMsIGJ1ZmZlckVuZCwgbG9va3VwVG9sZXJhbmNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gcmVhY2ggZW5kIG9mIHBsYXlsaXN0XG4gICAgICBmcmFnID0gZnJhZ21lbnRzW2ZyYWdtZW50cy5sZW5ndGggLSAxXTtcbiAgICB9XG5cbiAgICBpZiAoZnJhZykge1xuICAgICAgdmFyIGN1clNOSWR4ID0gZnJhZy5zbiAtIGxldmVsRGV0YWlscy5zdGFydFNOO1xuICAgICAgdmFyIHNhbWVMZXZlbCA9IGZyYWdQcmV2aW91cyAmJiBmcmFnLmxldmVsID09PSBmcmFnUHJldmlvdXMubGV2ZWw7XG4gICAgICB2YXIgbmV4dEZyYWcgPSBmcmFnbWVudHNbY3VyU05JZHggKyAxXTtcbiAgICAgIHZhciBmcmFnU3RhdGUgPSB0aGlzLmZyYWdtZW50VHJhY2tlci5nZXRTdGF0ZShmcmFnKTtcblxuICAgICAgaWYgKGZyYWdTdGF0ZSA9PT0gX2ZyYWdtZW50X3RyYWNrZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcIkZyYWdtZW50U3RhdGVcIl0uQkFDS1RSQUNLRUQpIHtcbiAgICAgICAgZnJhZyA9IG51bGw7XG4gICAgICAgIHZhciBpID0gY3VyU05JZHg7XG5cbiAgICAgICAgd2hpbGUgKGZyYWdtZW50c1tpXSAmJiB0aGlzLmZyYWdtZW50VHJhY2tlci5nZXRTdGF0ZShmcmFnbWVudHNbaV0pID09PSBfZnJhZ21lbnRfdHJhY2tlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiRnJhZ21lbnRTdGF0ZVwiXS5CQUNLVFJBQ0tFRCkge1xuICAgICAgICAgIC8vIFdoZW4gZnJhZ1ByZXZpb3VzIGlzIG51bGwsIGJhY2t0cmFjayB0byBmaXJzdCB0aGUgZmlyc3QgZnJhZ21lbnQgaXMgbm90IEJBQ0tUUkFDS0VEIGZvciBsb2FkaW5nXG4gICAgICAgICAgLy8gV2hlbiBmcmFnUHJldmlvdXMgaXMgc2V0LCB3ZSB3YW50IHRoZSBmaXJzdCBCQUNLVFJBQ0tFRCBmcmFnbWVudCBmb3IgcGFyc2luZyBhbmQgYnVmZmVyaW5nXG4gICAgICAgICAgaWYgKCFmcmFnUHJldmlvdXMpIHtcbiAgICAgICAgICAgIGZyYWcgPSBmcmFnbWVudHNbLS1pXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZnJhZyA9IGZyYWdtZW50c1tpLS1dO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghZnJhZykge1xuICAgICAgICAgIGZyYWcgPSBuZXh0RnJhZztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChmcmFnUHJldmlvdXMgJiYgZnJhZy5zbiA9PT0gZnJhZ1ByZXZpb3VzLnNuICYmICFsb2FkaW5nUGFydHMpIHtcbiAgICAgICAgLy8gRm9yY2UgdGhlIG5leHQgZnJhZ21lbnQgdG8gbG9hZCBpZiB0aGUgcHJldmlvdXMgb25lIHdhcyBhbHJlYWR5IHNlbGVjdGVkLiBUaGlzIGNhbiBvY2Nhc2lvbmFsbHkgaGFwcGVuIHdpdGhcbiAgICAgICAgLy8gbm9uLXVuaWZvcm0gZnJhZ21lbnQgZHVyYXRpb25zXG4gICAgICAgIGlmIChzYW1lTGV2ZWwpIHtcbiAgICAgICAgICBpZiAoZnJhZy5zbiA8IGVuZFNOICYmIHRoaXMuZnJhZ21lbnRUcmFja2VyLmdldFN0YXRlKG5leHRGcmFnKSAhPT0gX2ZyYWdtZW50X3RyYWNrZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcIkZyYWdtZW50U3RhdGVcIl0uT0spIHtcbiAgICAgICAgICAgIHRoaXMubG9nKFwiU04gXCIgKyBmcmFnLnNuICsgXCIganVzdCBsb2FkZWQsIGxvYWQgbmV4dCBvbmU6IFwiICsgbmV4dEZyYWcuc24pO1xuICAgICAgICAgICAgZnJhZyA9IG5leHRGcmFnO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmcmFnID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZnJhZztcbiAgfTtcblxuICBfcHJvdG8uc3luY2hyb25pemVUb0xpdmVFZGdlID0gZnVuY3Rpb24gc3luY2hyb25pemVUb0xpdmVFZGdlKGxldmVsRGV0YWlscykge1xuICAgIHZhciBjb25maWcgPSB0aGlzLmNvbmZpZyxcbiAgICAgICAgbWVkaWEgPSB0aGlzLm1lZGlhO1xuXG4gICAgaWYgKCFtZWRpYSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBsaXZlU3luY1Bvc2l0aW9uID0gdGhpcy5obHMubGl2ZVN5bmNQb3NpdGlvbjtcbiAgICB2YXIgY3VycmVudFRpbWUgPSBtZWRpYS5jdXJyZW50VGltZTtcbiAgICB2YXIgc3RhcnQgPSBsZXZlbERldGFpbHMuZnJhZ21lbnRzWzBdLnN0YXJ0O1xuICAgIHZhciBlbmQgPSBsZXZlbERldGFpbHMuZWRnZTtcbiAgICB2YXIgd2l0aGluU2xpZGluZ1dpbmRvdyA9IGN1cnJlbnRUaW1lID49IHN0YXJ0IC0gY29uZmlnLm1heEZyYWdMb29rVXBUb2xlcmFuY2UgJiYgY3VycmVudFRpbWUgPD0gZW5kOyAvLyBDb250aW51ZSBpZiB3ZSBjYW4gc2VlayBmb3J3YXJkIHRvIHN5bmMgcG9zaXRpb24gb3IgaWYgY3VycmVudCB0aW1lIGlzIG91dHNpZGUgb2Ygc2xpZGluZyB3aW5kb3dcblxuICAgIGlmIChsaXZlU3luY1Bvc2l0aW9uICE9PSBudWxsICYmIG1lZGlhLmR1cmF0aW9uID4gbGl2ZVN5bmNQb3NpdGlvbiAmJiAoY3VycmVudFRpbWUgPCBsaXZlU3luY1Bvc2l0aW9uIHx8ICF3aXRoaW5TbGlkaW5nV2luZG93KSkge1xuICAgICAgLy8gQ29udGludWUgaWYgYnVmZmVyIGlzIHN0YXJ2aW5nIG9yIGlmIGN1cnJlbnQgdGltZSBpcyBiZWhpbmQgbWF4IGxhdGVuY3lcbiAgICAgIHZhciBtYXhMYXRlbmN5ID0gY29uZmlnLmxpdmVNYXhMYXRlbmN5RHVyYXRpb24gIT09IHVuZGVmaW5lZCA/IGNvbmZpZy5saXZlTWF4TGF0ZW5jeUR1cmF0aW9uIDogY29uZmlnLmxpdmVNYXhMYXRlbmN5RHVyYXRpb25Db3VudCAqIGxldmVsRGV0YWlscy50YXJnZXRkdXJhdGlvbjtcblxuICAgICAgaWYgKCF3aXRoaW5TbGlkaW5nV2luZG93ICYmIG1lZGlhLnJlYWR5U3RhdGUgPCA0IHx8IGN1cnJlbnRUaW1lIDwgZW5kIC0gbWF4TGF0ZW5jeSkge1xuICAgICAgICBpZiAoIXRoaXMubG9hZGVkbWV0YWRhdGEpIHtcbiAgICAgICAgICB0aGlzLm5leHRMb2FkUG9zaXRpb24gPSBsaXZlU3luY1Bvc2l0aW9uO1xuICAgICAgICB9IC8vIE9ubHkgc2VlayBpZiByZWFkeSBhbmQgdGhlcmUgaXMgbm90IGEgc2lnbmlmaWNhbnQgZm9yd2FyZCBidWZmZXIgYXZhaWxhYmxlIGZvciBwbGF5YmFja1xuXG5cbiAgICAgICAgaWYgKG1lZGlhLnJlYWR5U3RhdGUpIHtcbiAgICAgICAgICB0aGlzLndhcm4oXCJQbGF5YmFjazogXCIgKyBjdXJyZW50VGltZS50b0ZpeGVkKDMpICsgXCIgaXMgbG9jYXRlZCB0b28gZmFyIGZyb20gdGhlIGVuZCBvZiBsaXZlIHNsaWRpbmcgcGxheWxpc3Q6IFwiICsgZW5kICsgXCIsIHJlc2V0IGN1cnJlbnRUaW1lIHRvIDogXCIgKyBsaXZlU3luY1Bvc2l0aW9uLnRvRml4ZWQoMykpO1xuICAgICAgICAgIG1lZGlhLmN1cnJlbnRUaW1lID0gbGl2ZVN5bmNQb3NpdGlvbjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uYWxpZ25QbGF5bGlzdHMgPSBmdW5jdGlvbiBhbGlnblBsYXlsaXN0cyhkZXRhaWxzLCBwcmV2aW91c0RldGFpbHMpIHtcbiAgICB2YXIgbGV2ZWxzID0gdGhpcy5sZXZlbHMsXG4gICAgICAgIGxldmVsTGFzdExvYWRlZCA9IHRoaXMubGV2ZWxMYXN0TG9hZGVkLFxuICAgICAgICBmcmFnUHJldmlvdXMgPSB0aGlzLmZyYWdQcmV2aW91cztcbiAgICB2YXIgbGFzdExldmVsID0gbGV2ZWxMYXN0TG9hZGVkICE9PSBudWxsID8gbGV2ZWxzW2xldmVsTGFzdExvYWRlZF0gOiBudWxsOyAvLyBGSVhNRTogSWYgbm90IGZvciBgc2hvdWxkQWxpZ25PbkRpc2NvbnRpbnVpdGllc2AgcmVxdWlyaW5nIGZyYWdQcmV2aW91cy5jYyxcbiAgICAvLyAgdGhpcyBjb3VsZCBhbGwgZ28gaW4gbGV2ZWwtaGVscGVyIG1lcmdlRGV0YWlscygpXG5cbiAgICB2YXIgbGVuZ3RoID0gZGV0YWlscy5mcmFnbWVudHMubGVuZ3RoO1xuXG4gICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgIHRoaXMud2FybihcIk5vIGZyYWdtZW50cyBpbiBsaXZlIHBsYXlsaXN0XCIpO1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgdmFyIHNsaWRpbmdTdGFydCA9IGRldGFpbHMuZnJhZ21lbnRzWzBdLnN0YXJ0O1xuICAgIHZhciBmaXJzdExldmVsTG9hZCA9ICFwcmV2aW91c0RldGFpbHM7XG5cbiAgICB2YXIgYWxpZ25lZCA9IGRldGFpbHMuYWxpZ25lZFNsaWRpbmcgJiYgT2JqZWN0KF9ob21lX3J1bm5lcl93b3JrX2hsc19qc19obHNfanNfc3JjX3BvbHlmaWxsc19udW1iZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImlzRmluaXRlTnVtYmVyXCJdKShzbGlkaW5nU3RhcnQpO1xuXG4gICAgaWYgKGZpcnN0TGV2ZWxMb2FkIHx8ICFhbGlnbmVkICYmICFzbGlkaW5nU3RhcnQpIHtcbiAgICAgIE9iamVjdChfdXRpbHNfZGlzY29udGludWl0aWVzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV85X19bXCJhbGlnblN0cmVhbVwiXSkoZnJhZ1ByZXZpb3VzLCBsYXN0TGV2ZWwsIGRldGFpbHMpO1xuICAgICAgdmFyIGFsaWduZWRTbGlkaW5nU3RhcnQgPSBkZXRhaWxzLmZyYWdtZW50c1swXS5zdGFydDtcbiAgICAgIHRoaXMubG9nKFwiTGl2ZSBwbGF5bGlzdCBzbGlkaW5nOiBcIiArIGFsaWduZWRTbGlkaW5nU3RhcnQudG9GaXhlZCgyKSArIFwiIHN0YXJ0LXNuOiBcIiArIChwcmV2aW91c0RldGFpbHMgPyBwcmV2aW91c0RldGFpbHMuc3RhcnRTTiA6ICduYScpICsgXCItPlwiICsgZGV0YWlscy5zdGFydFNOICsgXCIgcHJldi1zbjogXCIgKyAoZnJhZ1ByZXZpb3VzID8gZnJhZ1ByZXZpb3VzLnNuIDogJ25hJykgKyBcIiBmcmFnbWVudHM6IFwiICsgbGVuZ3RoKTtcbiAgICAgIHJldHVybiBhbGlnbmVkU2xpZGluZ1N0YXJ0O1xuICAgIH1cblxuICAgIHJldHVybiBzbGlkaW5nU3RhcnQ7XG4gIH07XG5cbiAgX3Byb3RvLndhaXRGb3JDZG5UdW5lSW4gPSBmdW5jdGlvbiB3YWl0Rm9yQ2RuVHVuZUluKGRldGFpbHMpIHtcbiAgICAvLyBXYWl0IGZvciBMb3ctTGF0ZW5jeSBDRE4gVHVuZS1pbiB0byBnZXQgYW4gdXBkYXRlZCBwbGF5bGlzdFxuICAgIHZhciBhZHZhbmNlUGFydExpbWl0ID0gMztcbiAgICByZXR1cm4gZGV0YWlscy5saXZlICYmIGRldGFpbHMuY2FuQmxvY2tSZWxvYWQgJiYgZGV0YWlscy50dW5lSW5Hb2FsID4gTWF0aC5tYXgoZGV0YWlscy5wYXJ0SG9sZEJhY2ssIGRldGFpbHMucGFydFRhcmdldCAqIGFkdmFuY2VQYXJ0TGltaXQpO1xuICB9O1xuXG4gIF9wcm90by5zZXRTdGFydFBvc2l0aW9uID0gZnVuY3Rpb24gc2V0U3RhcnRQb3NpdGlvbihkZXRhaWxzLCBzbGlkaW5nKSB7XG4gICAgLy8gY29tcHV0ZSBzdGFydCBwb3NpdGlvbiBpZiBzZXQgdG8gLTEuIHVzZSBpdCBzdHJhaWdodCBhd2F5IGlmIHZhbHVlIGlzIGRlZmluZWRcbiAgICB2YXIgc3RhcnRQb3NpdGlvbiA9IHRoaXMuc3RhcnRQb3NpdGlvbjtcblxuICAgIGlmIChzdGFydFBvc2l0aW9uIDwgc2xpZGluZykge1xuICAgICAgc3RhcnRQb3NpdGlvbiA9IC0xO1xuICAgIH1cblxuICAgIGlmIChzdGFydFBvc2l0aW9uID09PSAtMSB8fCB0aGlzLmxhc3RDdXJyZW50VGltZSA9PT0gLTEpIHtcbiAgICAgIC8vIGZpcnN0LCBjaGVjayBpZiBzdGFydCB0aW1lIG9mZnNldCBoYXMgYmVlbiBzZXQgaW4gcGxheWxpc3QsIGlmIHllcywgdXNlIHRoaXMgdmFsdWVcbiAgICAgIHZhciBzdGFydFRpbWVPZmZzZXQgPSBkZXRhaWxzLnN0YXJ0VGltZU9mZnNldDtcblxuICAgICAgaWYgKE9iamVjdChfaG9tZV9ydW5uZXJfd29ya19obHNfanNfaGxzX2pzX3NyY19wb2x5ZmlsbHNfbnVtYmVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJpc0Zpbml0ZU51bWJlclwiXSkoc3RhcnRUaW1lT2Zmc2V0KSkge1xuICAgICAgICBzdGFydFBvc2l0aW9uID0gc2xpZGluZyArIHN0YXJ0VGltZU9mZnNldDtcblxuICAgICAgICBpZiAoc3RhcnRUaW1lT2Zmc2V0IDwgMCkge1xuICAgICAgICAgIHN0YXJ0UG9zaXRpb24gKz0gZGV0YWlscy50b3RhbGR1cmF0aW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhcnRQb3NpdGlvbiA9IE1hdGgubWluKE1hdGgubWF4KHNsaWRpbmcsIHN0YXJ0UG9zaXRpb24pLCBzbGlkaW5nICsgZGV0YWlscy50b3RhbGR1cmF0aW9uKTtcbiAgICAgICAgdGhpcy5sb2coXCJTdGFydCB0aW1lIG9mZnNldCBcIiArIHN0YXJ0VGltZU9mZnNldCArIFwiIGZvdW5kIGluIHBsYXlsaXN0LCBhZGp1c3Qgc3RhcnRQb3NpdGlvbiB0byBcIiArIHN0YXJ0UG9zaXRpb24pO1xuICAgICAgICB0aGlzLnN0YXJ0UG9zaXRpb24gPSBzdGFydFBvc2l0aW9uO1xuICAgICAgfSBlbHNlIGlmIChkZXRhaWxzLmxpdmUpIHtcbiAgICAgICAgLy8gTGVhdmUgdGhpcy5zdGFydFBvc2l0aW9uIGF0IC0xLCBzbyB0aGF0IHdlIGNhbiB1c2UgYGdldEluaXRpYWxMaXZlRnJhZ21lbnRgIGxvZ2ljIHdoZW4gc3RhcnRQb3NpdGlvbiBoYXNcbiAgICAgICAgLy8gbm90IGJlZW4gc3BlY2lmaWVkIHZpYSB0aGUgY29uZmlnIG9yIGFuIGFzIGFuIGFyZ3VtZW50IHRvIHN0YXJ0TG9hZCAoIzM3MzYpLlxuICAgICAgICBzdGFydFBvc2l0aW9uID0gdGhpcy5obHMubGl2ZVN5bmNQb3NpdGlvbiB8fCBzbGlkaW5nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zdGFydFBvc2l0aW9uID0gc3RhcnRQb3NpdGlvbiA9IDA7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubGFzdEN1cnJlbnRUaW1lID0gc3RhcnRQb3NpdGlvbjtcbiAgICB9XG5cbiAgICB0aGlzLm5leHRMb2FkUG9zaXRpb24gPSBzdGFydFBvc2l0aW9uO1xuICB9O1xuXG4gIF9wcm90by5nZXRMb2FkUG9zaXRpb24gPSBmdW5jdGlvbiBnZXRMb2FkUG9zaXRpb24oKSB7XG4gICAgdmFyIG1lZGlhID0gdGhpcy5tZWRpYTsgLy8gaWYgd2UgaGF2ZSBub3QgeWV0IGxvYWRlZCBhbnkgZnJhZ21lbnQsIHN0YXJ0IGxvYWRpbmcgZnJvbSBzdGFydCBwb3NpdGlvblxuXG4gICAgdmFyIHBvcyA9IDA7XG5cbiAgICBpZiAodGhpcy5sb2FkZWRtZXRhZGF0YSAmJiBtZWRpYSkge1xuICAgICAgcG9zID0gbWVkaWEuY3VycmVudFRpbWU7XG4gICAgfSBlbHNlIGlmICh0aGlzLm5leHRMb2FkUG9zaXRpb24pIHtcbiAgICAgIHBvcyA9IHRoaXMubmV4dExvYWRQb3NpdGlvbjtcbiAgICB9XG5cbiAgICByZXR1cm4gcG9zO1xuICB9O1xuXG4gIF9wcm90by5oYW5kbGVGcmFnTG9hZEFib3J0ZWQgPSBmdW5jdGlvbiBoYW5kbGVGcmFnTG9hZEFib3J0ZWQoZnJhZywgcGFydCkge1xuICAgIGlmICh0aGlzLnRyYW5zbXV4ZXIgJiYgZnJhZy5zbiAhPT0gJ2luaXRTZWdtZW50JyAmJiBmcmFnLnN0YXRzLmFib3J0ZWQpIHtcbiAgICAgIHRoaXMud2FybihcIkZyYWdtZW50IFwiICsgZnJhZy5zbiArIChwYXJ0ID8gJyBwYXJ0JyArIHBhcnQuaW5kZXggOiAnJykgKyBcIiBvZiBsZXZlbCBcIiArIGZyYWcubGV2ZWwgKyBcIiB3YXMgYWJvcnRlZFwiKTtcbiAgICAgIHRoaXMucmVzZXRGcmFnbWVudExvYWRpbmcoZnJhZyk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5yZXNldEZyYWdtZW50TG9hZGluZyA9IGZ1bmN0aW9uIHJlc2V0RnJhZ21lbnRMb2FkaW5nKGZyYWcpIHtcbiAgICBpZiAoIXRoaXMuZnJhZ0N1cnJlbnQgfHwgIXRoaXMuZnJhZ0NvbnRleHRDaGFuZ2VkKGZyYWcpKSB7XG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLm9uRnJhZ21lbnRPcktleUxvYWRFcnJvciA9IGZ1bmN0aW9uIG9uRnJhZ21lbnRPcktleUxvYWRFcnJvcihmaWx0ZXJUeXBlLCBkYXRhKSB7XG4gICAgaWYgKGRhdGEuZmF0YWwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZnJhZyA9IGRhdGEuZnJhZzsgLy8gSGFuZGxlIGZyYWcgZXJyb3IgcmVsYXRlZCB0byBjYWxsZXIncyBmaWx0ZXJUeXBlXG5cbiAgICBpZiAoIWZyYWcgfHwgZnJhZy50eXBlICE9PSBmaWx0ZXJUeXBlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGZyYWdDdXJyZW50ID0gdGhpcy5mcmFnQ3VycmVudDtcbiAgICBjb25zb2xlLmFzc2VydChmcmFnQ3VycmVudCAmJiBmcmFnLnNuID09PSBmcmFnQ3VycmVudC5zbiAmJiBmcmFnLmxldmVsID09PSBmcmFnQ3VycmVudC5sZXZlbCAmJiBmcmFnLnVybElkID09PSBmcmFnQ3VycmVudC51cmxJZCwgJ0ZyYWcgbG9hZCBlcnJvciBtdXN0IG1hdGNoIGN1cnJlbnQgZnJhZyB0byByZXRyeScpO1xuICAgIHZhciBjb25maWcgPSB0aGlzLmNvbmZpZzsgLy8ga2VlcCByZXRyeWluZyB1bnRpbCB0aGUgbGltaXQgd2lsbCBiZSByZWFjaGVkXG5cbiAgICBpZiAodGhpcy5mcmFnTG9hZEVycm9yICsgMSA8PSBjb25maWcuZnJhZ0xvYWRpbmdNYXhSZXRyeSkge1xuICAgICAgaWYgKHRoaXMucmVzZXRMaXZlU3RhcnRXaGVuTm90TG9hZGVkKGZyYWcubGV2ZWwpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gZXhwb25lbnRpYWwgYmFja29mZiBjYXBwZWQgdG8gY29uZmlnLmZyYWdMb2FkaW5nTWF4UmV0cnlUaW1lb3V0XG5cblxuICAgICAgdmFyIGRlbGF5ID0gTWF0aC5taW4oTWF0aC5wb3coMiwgdGhpcy5mcmFnTG9hZEVycm9yKSAqIGNvbmZpZy5mcmFnTG9hZGluZ1JldHJ5RGVsYXksIGNvbmZpZy5mcmFnTG9hZGluZ01heFJldHJ5VGltZW91dCk7XG4gICAgICB0aGlzLndhcm4oXCJGcmFnbWVudCBcIiArIGZyYWcuc24gKyBcIiBvZiBcIiArIGZpbHRlclR5cGUgKyBcIiBcIiArIGZyYWcubGV2ZWwgKyBcIiBmYWlsZWQgdG8gbG9hZCwgcmV0cnlpbmcgaW4gXCIgKyBkZWxheSArIFwibXNcIik7XG4gICAgICB0aGlzLnJldHJ5RGF0ZSA9IHNlbGYucGVyZm9ybWFuY2Uubm93KCkgKyBkZWxheTtcbiAgICAgIHRoaXMuZnJhZ0xvYWRFcnJvcisrO1xuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkZSQUdfTE9BRElOR19XQUlUSU5HX1JFVFJZO1xuICAgIH0gZWxzZSBpZiAoZGF0YS5sZXZlbFJldHJ5KSB7XG4gICAgICBpZiAoZmlsdGVyVHlwZSA9PT0gX3R5cGVzX2xvYWRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTVfX1tcIlBsYXlsaXN0TGV2ZWxUeXBlXCJdLkFVRElPKSB7XG4gICAgICAgIC8vIFJlc2V0IGN1cnJlbnQgZnJhZ21lbnQgc2luY2UgYXVkaW8gdHJhY2sgYXVkaW8gaXMgZXNzZW50aWFsIGFuZCBtYXkgbm90IGhhdmUgYSBmYWlsLW92ZXIgdHJhY2tcbiAgICAgICAgdGhpcy5mcmFnQ3VycmVudCA9IG51bGw7XG4gICAgICB9IC8vIEZyYWdtZW50IGVycm9ycyB0aGF0IHJlc3VsdCBpbiBhIGxldmVsIHN3aXRjaCBvciByZWR1bmRhbnQgZmFpbC1vdmVyXG4gICAgICAvLyBzaG91bGQgcmVzZXQgdGhlIHN0cmVhbSBjb250cm9sbGVyIHN0YXRlIHRvIGlkbGVcblxuXG4gICAgICB0aGlzLmZyYWdMb2FkRXJyb3IgPSAwO1xuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgfSBlbHNlIHtcbiAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1tcImxvZ2dlclwiXS5lcnJvcihkYXRhLmRldGFpbHMgKyBcIiByZWFjaGVzIG1heCByZXRyeSwgcmVkaXNwYXRjaCBhcyBmYXRhbCAuLi5cIik7IC8vIHN3aXRjaCBlcnJvciB0byBmYXRhbFxuXG4gICAgICBkYXRhLmZhdGFsID0gdHJ1ZTtcbiAgICAgIHRoaXMuaGxzLnN0b3BMb2FkKCk7XG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuRVJST1I7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5hZnRlckJ1ZmZlckZsdXNoZWQgPSBmdW5jdGlvbiBhZnRlckJ1ZmZlckZsdXNoZWQobWVkaWEsIGJ1ZmZlclR5cGUsIHBsYXlsaXN0VHlwZSkge1xuICAgIGlmICghbWVkaWEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIEFmdGVyIHN1Y2Nlc3NmdWwgYnVmZmVyIGZsdXNoaW5nLCBmaWx0ZXIgZmx1c2hlZCBmcmFnbWVudHMgZnJvbSBidWZmZXJlZEZyYWdzIHVzZSBtZWRpYUJ1ZmZlcmVkIGluc3RlYWQgb2YgbWVkaWFcbiAgICAvLyAoc28gdGhhdCB3ZSB3aWxsIGNoZWNrIGFnYWluc3QgdmlkZW8uYnVmZmVyZWQgcmFuZ2VzIGluIGNhc2Ugb2YgYWx0IGF1ZGlvIHRyYWNrKVxuXG5cbiAgICB2YXIgYnVmZmVyZWRUaW1lUmFuZ2VzID0gX3V0aWxzX2J1ZmZlcl9oZWxwZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcIkJ1ZmZlckhlbHBlclwiXS5nZXRCdWZmZXJlZChtZWRpYSk7XG4gICAgdGhpcy5mcmFnbWVudFRyYWNrZXIuZGV0ZWN0RXZpY3RlZEZyYWdtZW50cyhidWZmZXJUeXBlLCBidWZmZXJlZFRpbWVSYW5nZXMsIHBsYXlsaXN0VHlwZSk7XG5cbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuRU5ERUQpIHtcbiAgICAgIHRoaXMucmVzZXRMb2FkaW5nU3RhdGUoKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLnJlc2V0TG9hZGluZ1N0YXRlID0gZnVuY3Rpb24gcmVzZXRMb2FkaW5nU3RhdGUoKSB7XG4gICAgdGhpcy5mcmFnQ3VycmVudCA9IG51bGw7XG4gICAgdGhpcy5mcmFnUHJldmlvdXMgPSBudWxsO1xuICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICB9O1xuXG4gIF9wcm90by5yZXNldExpdmVTdGFydFdoZW5Ob3RMb2FkZWQgPSBmdW5jdGlvbiByZXNldExpdmVTdGFydFdoZW5Ob3RMb2FkZWQobGV2ZWwpIHtcbiAgICAvLyBpZiBsb2FkZWRtZXRhZGF0YSBpcyBub3Qgc2V0LCBpdCBtZWFucyB0aGF0IHdlIGFyZSBlbWVyZ2VuY3kgc3dpdGNoIGRvd24gb24gZmlyc3QgZnJhZ1xuICAgIC8vIGluIHRoYXQgY2FzZSwgcmVzZXQgc3RhcnRGcmFnUmVxdWVzdGVkIGZsYWdcbiAgICBpZiAoIXRoaXMubG9hZGVkbWV0YWRhdGEpIHtcbiAgICAgIHRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkID0gZmFsc2U7XG4gICAgICB2YXIgZGV0YWlscyA9IHRoaXMubGV2ZWxzID8gdGhpcy5sZXZlbHNbbGV2ZWxdLmRldGFpbHMgOiBudWxsO1xuXG4gICAgICBpZiAoZGV0YWlscyAhPT0gbnVsbCAmJiBkZXRhaWxzICE9PSB2b2lkIDAgJiYgZGV0YWlscy5saXZlKSB7XG4gICAgICAgIC8vIFdlIGNhbid0IGFmZm9yZCB0byByZXRyeSBhZnRlciBhIGRlbGF5IGluIGEgbGl2ZSBzY2VuYXJpby4gVXBkYXRlIHRoZSBzdGFydCBwb3NpdGlvbiBhbmQgcmV0dXJuIHRvIElETEUuXG4gICAgICAgIHRoaXMuc3RhcnRQb3NpdGlvbiA9IC0xO1xuICAgICAgICB0aGlzLnNldFN0YXJ0UG9zaXRpb24oZGV0YWlscywgMCk7XG4gICAgICAgIHRoaXMucmVzZXRMb2FkaW5nU3RhdGUoKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubmV4dExvYWRQb3NpdGlvbiA9IHRoaXMuc3RhcnRQb3NpdGlvbjtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgX3Byb3RvLnVwZGF0ZUxldmVsVGltaW5nID0gZnVuY3Rpb24gdXBkYXRlTGV2ZWxUaW1pbmcoZnJhZywgcGFydCwgbGV2ZWwsIHBhcnRpYWwpIHtcbiAgICB2YXIgX3RoaXM2ID0gdGhpcztcblxuICAgIHZhciBkZXRhaWxzID0gbGV2ZWwuZGV0YWlscztcbiAgICBjb25zb2xlLmFzc2VydCghIWRldGFpbHMsICdsZXZlbC5kZXRhaWxzIG11c3QgYmUgZGVmaW5lZCcpO1xuICAgIHZhciBwYXJzZWQgPSBPYmplY3Qua2V5cyhmcmFnLmVsZW1lbnRhcnlTdHJlYW1zKS5yZWR1Y2UoZnVuY3Rpb24gKHJlc3VsdCwgdHlwZSkge1xuICAgICAgdmFyIGluZm8gPSBmcmFnLmVsZW1lbnRhcnlTdHJlYW1zW3R5cGVdO1xuXG4gICAgICBpZiAoaW5mbykge1xuICAgICAgICB2YXIgcGFyc2VkRHVyYXRpb24gPSBpbmZvLmVuZFBUUyAtIGluZm8uc3RhcnRQVFM7XG5cbiAgICAgICAgaWYgKHBhcnNlZER1cmF0aW9uIDw9IDApIHtcbiAgICAgICAgICAvLyBEZXN0cm95IHRoZSB0cmFuc211eGVyIGFmdGVyIGl0J3MgbmV4dCB0aW1lIG9mZnNldCBmYWlsZWQgdG8gYWR2YW5jZSBiZWNhdXNlIGR1cmF0aW9uIHdhcyA8PSAwLlxuICAgICAgICAgIC8vIFRoZSBuZXcgdHJhbnNtdXhlciB3aWxsIGJlIGNvbmZpZ3VyZWQgd2l0aCBhIHRpbWUgb2Zmc2V0IG1hdGNoaW5nIHRoZSBuZXh0IGZyYWdtZW50IHN0YXJ0LFxuICAgICAgICAgIC8vIHByZXZlbnRpbmcgdGhlIHRpbWVsaW5lIGZyb20gc2hpZnRpbmcuXG4gICAgICAgICAgX3RoaXM2Lndhcm4oXCJDb3VsZCBub3QgcGFyc2UgZnJhZ21lbnQgXCIgKyBmcmFnLnNuICsgXCIgXCIgKyB0eXBlICsgXCIgZHVyYXRpb24gcmVsaWFibHkgKFwiICsgcGFyc2VkRHVyYXRpb24gKyBcIikgcmVzZXR0aW5nIHRyYW5zbXV4ZXIgdG8gZmFsbGJhY2sgdG8gcGxheWxpc3QgdGltaW5nXCIpO1xuXG4gICAgICAgICAgX3RoaXM2LnJlc2V0VHJhbnNtdXhlcigpO1xuXG4gICAgICAgICAgcmV0dXJuIHJlc3VsdCB8fCBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkcmlmdCA9IHBhcnRpYWwgPyAwIDogT2JqZWN0KF9sZXZlbF9oZWxwZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzExX19bXCJ1cGRhdGVGcmFnUFRTRFRTXCJdKShkZXRhaWxzLCBmcmFnLCBpbmZvLnN0YXJ0UFRTLCBpbmZvLmVuZFBUUywgaW5mby5zdGFydERUUywgaW5mby5lbmREVFMpO1xuXG4gICAgICAgIF90aGlzNi5obHMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXCJFdmVudHNcIl0uTEVWRUxfUFRTX1VQREFURUQsIHtcbiAgICAgICAgICBkZXRhaWxzOiBkZXRhaWxzLFxuICAgICAgICAgIGxldmVsOiBsZXZlbCxcbiAgICAgICAgICBkcmlmdDogZHJpZnQsXG4gICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICBmcmFnOiBmcmFnLFxuICAgICAgICAgIHN0YXJ0OiBpbmZvLnN0YXJ0UFRTLFxuICAgICAgICAgIGVuZDogaW5mby5lbmRQVFNcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSwgZmFsc2UpO1xuXG4gICAgaWYgKHBhcnNlZCkge1xuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLlBBUlNFRDtcbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1wiRXZlbnRzXCJdLkZSQUdfUEFSU0VELCB7XG4gICAgICAgIGZyYWc6IGZyYWcsXG4gICAgICAgIHBhcnQ6IHBhcnRcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlc2V0TG9hZGluZ1N0YXRlKCk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5yZXNldFRyYW5zbXV4ZXIgPSBmdW5jdGlvbiByZXNldFRyYW5zbXV4ZXIoKSB7XG4gICAgaWYgKHRoaXMudHJhbnNtdXhlcikge1xuICAgICAgdGhpcy50cmFuc211eGVyLmRlc3Ryb3koKTtcbiAgICAgIHRoaXMudHJhbnNtdXhlciA9IG51bGw7XG4gICAgfVxuICB9O1xuXG4gIF9jcmVhdGVDbGFzcyhCYXNlU3RyZWFtQ29udHJvbGxlciwgW3tcbiAgICBrZXk6IFwic3RhdGVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zdGF0ZTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KG5leHRTdGF0ZSkge1xuICAgICAgdmFyIHByZXZpb3VzU3RhdGUgPSB0aGlzLl9zdGF0ZTtcblxuICAgICAgaWYgKHByZXZpb3VzU3RhdGUgIT09IG5leHRTdGF0ZSkge1xuICAgICAgICB0aGlzLl9zdGF0ZSA9IG5leHRTdGF0ZTtcbiAgICAgICAgdGhpcy5sb2cocHJldmlvdXNTdGF0ZSArIFwiLT5cIiArIG5leHRTdGF0ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEJhc2VTdHJlYW1Db250cm9sbGVyO1xufShfdGFza19sb29wX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJkZWZhdWx0XCJdKTtcblxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NvbnRyb2xsZXIvYnVmZmVyLWNvbnRyb2xsZXIudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9jb250cm9sbGVyL2J1ZmZlci1jb250cm9sbGVyLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJkZWZhdWx0XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gQnVmZmVyQ29udHJvbGxlcjsgfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2hvbWVfcnVubmVyX3dvcmtfaGxzX2pzX2hsc19qc19zcmNfcG9seWZpbGxzX251bWJlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zcmMvcG9seWZpbGxzL251bWJlciAqLyBcIi4vc3JjL3BvbHlmaWxscy9udW1iZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZXZlbnRzICovIFwiLi9zcmMvZXZlbnRzLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL2xvZ2dlciAqLyBcIi4vc3JjL3V0aWxzL2xvZ2dlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9lcnJvcnMgKi8gXCIuL3NyYy9lcnJvcnMudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2J1ZmZlcl9oZWxwZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL2J1ZmZlci1oZWxwZXIgKi8gXCIuL3NyYy91dGlscy9idWZmZXItaGVscGVyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19tZWRpYXNvdXJjZV9oZWxwZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL21lZGlhc291cmNlLWhlbHBlciAqLyBcIi4vc3JjL3V0aWxzL21lZGlhc291cmNlLWhlbHBlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbG9hZGVyX2ZyYWdtZW50X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9sb2FkZXIvZnJhZ21lbnQgKi8gXCIuL3NyYy9sb2FkZXIvZnJhZ21lbnQudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2J1ZmZlcl9vcGVyYXRpb25fcXVldWVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vYnVmZmVyLW9wZXJhdGlvbi1xdWV1ZSAqLyBcIi4vc3JjL2NvbnRyb2xsZXIvYnVmZmVyLW9wZXJhdGlvbi1xdWV1ZS50c1wiKTtcblxuXG5cblxuXG5cblxuXG5cblxuXG5cbnZhciBNZWRpYVNvdXJjZSA9IE9iamVjdChfdXRpbHNfbWVkaWFzb3VyY2VfaGVscGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXCJnZXRNZWRpYVNvdXJjZVwiXSkoKTtcbnZhciBWSURFT19DT0RFQ19QUk9GSUxFX1JFUEFDRSA9IC8oW2hhXXZjLikoPzpcXC5bXi4sXSspKy87XG5cbnZhciBCdWZmZXJDb250cm9sbGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLy8gVGhlIGxldmVsIGRldGFpbHMgdXNlZCB0byBkZXRlcm1pbmUgZHVyYXRpb24sIHRhcmdldC1kdXJhdGlvbiBhbmQgbGl2ZVxuICAvLyBjYWNoZSB0aGUgc2VsZiBnZW5lcmF0ZWQgb2JqZWN0IHVybCB0byBkZXRlY3QgaGlqYWNrIG9mIHZpZGVvIHRhZ1xuICAvLyBBIHF1ZXVlIG9mIGJ1ZmZlciBvcGVyYXRpb25zIHdoaWNoIHJlcXVpcmUgdGhlIFNvdXJjZUJ1ZmZlciB0byBub3QgYmUgdXBkYXRpbmcgdXBvbiBleGVjdXRpb25cbiAgLy8gUmVmZXJlbmNlcyB0byBldmVudCBsaXN0ZW5lcnMgZm9yIGVhY2ggU291cmNlQnVmZmVyLCBzbyB0aGF0IHRoZXkgY2FuIGJlIHJlZmVyZW5jZWQgZm9yIGV2ZW50IHJlbW92YWxcbiAgLy8gVGhlIG51bWJlciBvZiBCVUZGRVJfQ09ERUMgZXZlbnRzIHJlY2VpdmVkIGJlZm9yZSBhbnkgc291cmNlQnVmZmVycyBhcmUgY3JlYXRlZFxuICAvLyBUaGUgdG90YWwgbnVtYmVyIG9mIEJVRkZFUl9DT0RFQyBldmVudHMgcmVjZWl2ZWRcbiAgLy8gQSByZWZlcmVuY2UgdG8gdGhlIGF0dGFjaGVkIG1lZGlhIGVsZW1lbnRcbiAgLy8gQSByZWZlcmVuY2UgdG8gdGhlIGFjdGl2ZSBtZWRpYSBzb3VyY2VcbiAgLy8gY291bnRlcnNcbiAgZnVuY3Rpb24gQnVmZmVyQ29udHJvbGxlcihfaGxzKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHRoaXMuZGV0YWlscyA9IG51bGw7XG4gICAgdGhpcy5fb2JqZWN0VXJsID0gbnVsbDtcbiAgICB0aGlzLm9wZXJhdGlvblF1ZXVlID0gdm9pZCAwO1xuICAgIHRoaXMubGlzdGVuZXJzID0gdm9pZCAwO1xuICAgIHRoaXMuaGxzID0gdm9pZCAwO1xuICAgIHRoaXMuYnVmZmVyQ29kZWNFdmVudHNFeHBlY3RlZCA9IDA7XG4gICAgdGhpcy5fYnVmZmVyQ29kZWNFdmVudHNUb3RhbCA9IDA7XG4gICAgdGhpcy5tZWRpYSA9IG51bGw7XG4gICAgdGhpcy5tZWRpYVNvdXJjZSA9IG51bGw7XG4gICAgdGhpcy5hcHBlbmRFcnJvciA9IDA7XG4gICAgdGhpcy50cmFja3MgPSB7fTtcbiAgICB0aGlzLnBlbmRpbmdUcmFja3MgPSB7fTtcbiAgICB0aGlzLnNvdXJjZUJ1ZmZlciA9IHZvaWQgMDtcblxuICAgIHRoaXMuX29uTWVkaWFTb3VyY2VPcGVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGhscyA9IF90aGlzLmhscyxcbiAgICAgICAgICBtZWRpYSA9IF90aGlzLm1lZGlhLFxuICAgICAgICAgIG1lZGlhU291cmNlID0gX3RoaXMubWVkaWFTb3VyY2U7XG4gICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJsb2dnZXJcIl0ubG9nKCdbYnVmZmVyLWNvbnRyb2xsZXJdOiBNZWRpYSBzb3VyY2Ugb3BlbmVkJyk7XG5cbiAgICAgIGlmIChtZWRpYSkge1xuICAgICAgICBfdGhpcy51cGRhdGVNZWRpYUVsZW1lbnREdXJhdGlvbigpO1xuXG4gICAgICAgIGhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkV2ZW50c1wiXS5NRURJQV9BVFRBQ0hFRCwge1xuICAgICAgICAgIG1lZGlhOiBtZWRpYVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKG1lZGlhU291cmNlKSB7XG4gICAgICAgIC8vIG9uY2UgcmVjZWl2ZWQsIGRvbid0IGxpc3RlbiBhbnltb3JlIHRvIHNvdXJjZW9wZW4gZXZlbnRcbiAgICAgICAgbWVkaWFTb3VyY2UucmVtb3ZlRXZlbnRMaXN0ZW5lcignc291cmNlb3BlbicsIF90aGlzLl9vbk1lZGlhU291cmNlT3Blbik7XG4gICAgICB9XG5cbiAgICAgIF90aGlzLmNoZWNrUGVuZGluZ1RyYWNrcygpO1xuICAgIH07XG5cbiAgICB0aGlzLl9vbk1lZGlhU291cmNlQ2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJsb2dnZXJcIl0ubG9nKCdbYnVmZmVyLWNvbnRyb2xsZXJdOiBNZWRpYSBzb3VyY2UgY2xvc2VkJyk7XG4gICAgfTtcblxuICAgIHRoaXMuX29uTWVkaWFTb3VyY2VFbmRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImxvZ2dlclwiXS5sb2coJ1tidWZmZXItY29udHJvbGxlcl06IE1lZGlhIHNvdXJjZSBlbmRlZCcpO1xuICAgIH07XG5cbiAgICB0aGlzLmhscyA9IF9obHM7XG5cbiAgICB0aGlzLl9pbml0U291cmNlQnVmZmVyKCk7XG5cbiAgICB0aGlzLnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gQnVmZmVyQ29udHJvbGxlci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmhhc1NvdXJjZVR5cGVzID0gZnVuY3Rpb24gaGFzU291cmNlVHlwZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0U291cmNlQnVmZmVyVHlwZXMoKS5sZW5ndGggPiAwIHx8IE9iamVjdC5rZXlzKHRoaXMucGVuZGluZ1RyYWNrcykubGVuZ3RoID4gMDtcbiAgfTtcblxuICBfcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgdGhpcy51bnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gICAgdGhpcy5kZXRhaWxzID0gbnVsbDtcbiAgfTtcblxuICBfcHJvdG8ucmVnaXN0ZXJMaXN0ZW5lcnMgPSBmdW5jdGlvbiByZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICB2YXIgaGxzID0gdGhpcy5obHM7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkV2ZW50c1wiXS5NRURJQV9BVFRBQ0hJTkcsIHRoaXMub25NZWRpYUF0dGFjaGluZywgdGhpcyk7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkV2ZW50c1wiXS5NRURJQV9ERVRBQ0hJTkcsIHRoaXMub25NZWRpYURldGFjaGluZywgdGhpcyk7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkV2ZW50c1wiXS5NQU5JRkVTVF9QQVJTRUQsIHRoaXMub25NYW5pZmVzdFBhcnNlZCwgdGhpcyk7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkV2ZW50c1wiXS5CVUZGRVJfUkVTRVQsIHRoaXMub25CdWZmZXJSZXNldCwgdGhpcyk7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkV2ZW50c1wiXS5CVUZGRVJfQVBQRU5ESU5HLCB0aGlzLm9uQnVmZmVyQXBwZW5kaW5nLCB0aGlzKTtcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXZlbnRzXCJdLkJVRkZFUl9DT0RFQ1MsIHRoaXMub25CdWZmZXJDb2RlY3MsIHRoaXMpO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFdmVudHNcIl0uQlVGRkVSX0VPUywgdGhpcy5vbkJ1ZmZlckVvcywgdGhpcyk7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkV2ZW50c1wiXS5CVUZGRVJfRkxVU0hJTkcsIHRoaXMub25CdWZmZXJGbHVzaGluZywgdGhpcyk7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkV2ZW50c1wiXS5MRVZFTF9VUERBVEVELCB0aGlzLm9uTGV2ZWxVcGRhdGVkLCB0aGlzKTtcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXZlbnRzXCJdLkZSQUdfUEFSU0VELCB0aGlzLm9uRnJhZ1BhcnNlZCwgdGhpcyk7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkV2ZW50c1wiXS5GUkFHX0NIQU5HRUQsIHRoaXMub25GcmFnQ2hhbmdlZCwgdGhpcyk7XG4gIH07XG5cbiAgX3Byb3RvLnVucmVnaXN0ZXJMaXN0ZW5lcnMgPSBmdW5jdGlvbiB1bnJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIHZhciBobHMgPSB0aGlzLmhscztcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkV2ZW50c1wiXS5NRURJQV9BVFRBQ0hJTkcsIHRoaXMub25NZWRpYUF0dGFjaGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFdmVudHNcIl0uTUVESUFfREVUQUNISU5HLCB0aGlzLm9uTWVkaWFEZXRhY2hpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXZlbnRzXCJdLk1BTklGRVNUX1BBUlNFRCwgdGhpcy5vbk1hbmlmZXN0UGFyc2VkLCB0aGlzKTtcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkV2ZW50c1wiXS5CVUZGRVJfUkVTRVQsIHRoaXMub25CdWZmZXJSZXNldCwgdGhpcyk7XG4gICAgaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFdmVudHNcIl0uQlVGRkVSX0FQUEVORElORywgdGhpcy5vbkJ1ZmZlckFwcGVuZGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFdmVudHNcIl0uQlVGRkVSX0NPREVDUywgdGhpcy5vbkJ1ZmZlckNvZGVjcywgdGhpcyk7XG4gICAgaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFdmVudHNcIl0uQlVGRkVSX0VPUywgdGhpcy5vbkJ1ZmZlckVvcywgdGhpcyk7XG4gICAgaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFdmVudHNcIl0uQlVGRkVSX0ZMVVNISU5HLCB0aGlzLm9uQnVmZmVyRmx1c2hpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXZlbnRzXCJdLkxFVkVMX1VQREFURUQsIHRoaXMub25MZXZlbFVwZGF0ZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXZlbnRzXCJdLkZSQUdfUEFSU0VELCB0aGlzLm9uRnJhZ1BhcnNlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFdmVudHNcIl0uRlJBR19DSEFOR0VELCB0aGlzLm9uRnJhZ0NoYW5nZWQsIHRoaXMpO1xuICB9O1xuXG4gIF9wcm90by5faW5pdFNvdXJjZUJ1ZmZlciA9IGZ1bmN0aW9uIF9pbml0U291cmNlQnVmZmVyKCkge1xuICAgIHRoaXMuc291cmNlQnVmZmVyID0ge307XG4gICAgdGhpcy5vcGVyYXRpb25RdWV1ZSA9IG5ldyBfYnVmZmVyX29wZXJhdGlvbl9xdWV1ZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fW1wiZGVmYXVsdFwiXSh0aGlzLnNvdXJjZUJ1ZmZlcik7XG4gICAgdGhpcy5saXN0ZW5lcnMgPSB7XG4gICAgICBhdWRpbzogW10sXG4gICAgICB2aWRlbzogW10sXG4gICAgICBhdWRpb3ZpZGVvOiBbXVxuICAgIH07XG4gIH07XG5cbiAgX3Byb3RvLm9uTWFuaWZlc3RQYXJzZWQgPSBmdW5jdGlvbiBvbk1hbmlmZXN0UGFyc2VkKGV2ZW50LCBkYXRhKSB7XG4gICAgLy8gaW4gY2FzZSBvZiBhbHQgYXVkaW8gMiBCVUZGRVJfQ09ERUNTIGV2ZW50cyB3aWxsIGJlIHRyaWdnZXJlZCwgb25lIHBlciBzdHJlYW0gY29udHJvbGxlclxuICAgIC8vIHNvdXJjZWJ1ZmZlcnMgd2lsbCBiZSBjcmVhdGVkIGFsbCBhdCBvbmNlIHdoZW4gdGhlIGV4cGVjdGVkIG5iIG9mIHRyYWNrcyB3aWxsIGJlIHJlYWNoZWRcbiAgICAvLyBpbiBjYXNlIGFsdCBhdWRpbyBpcyBub3QgdXNlZCwgb25seSBvbmUgQlVGRkVSX0NPREVDIGV2ZW50IHdpbGwgYmUgZmlyZWQgZnJvbSBtYWluIHN0cmVhbSBjb250cm9sbGVyXG4gICAgLy8gaXQgd2lsbCBjb250YWluIHRoZSBleHBlY3RlZCBuYiBvZiBzb3VyY2UgYnVmZmVycywgbm8gbmVlZCB0byBjb21wdXRlIGl0XG4gICAgdmFyIGNvZGVjRXZlbnRzID0gMjtcblxuICAgIGlmIChkYXRhLmF1ZGlvICYmICFkYXRhLnZpZGVvIHx8ICFkYXRhLmFsdEF1ZGlvKSB7XG4gICAgICBjb2RlY0V2ZW50cyA9IDE7XG4gICAgfVxuXG4gICAgdGhpcy5idWZmZXJDb2RlY0V2ZW50c0V4cGVjdGVkID0gdGhpcy5fYnVmZmVyQ29kZWNFdmVudHNUb3RhbCA9IGNvZGVjRXZlbnRzO1xuICAgIHRoaXMuZGV0YWlscyA9IG51bGw7XG4gICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wibG9nZ2VyXCJdLmxvZyh0aGlzLmJ1ZmZlckNvZGVjRXZlbnRzRXhwZWN0ZWQgKyBcIiBidWZmZXJDb2RlYyBldmVudChzKSBleHBlY3RlZFwiKTtcbiAgfTtcblxuICBfcHJvdG8ub25NZWRpYUF0dGFjaGluZyA9IGZ1bmN0aW9uIG9uTWVkaWFBdHRhY2hpbmcoZXZlbnQsIGRhdGEpIHtcbiAgICB2YXIgbWVkaWEgPSB0aGlzLm1lZGlhID0gZGF0YS5tZWRpYTtcblxuICAgIGlmIChtZWRpYSAmJiBNZWRpYVNvdXJjZSkge1xuICAgICAgdmFyIG1zID0gdGhpcy5tZWRpYVNvdXJjZSA9IG5ldyBNZWRpYVNvdXJjZSgpOyAvLyBNZWRpYVNvdXJjZSBsaXN0ZW5lcnMgYXJlIGFycm93IGZ1bmN0aW9ucyB3aXRoIGEgbGV4aWNhbCBzY29wZSwgYW5kIGRvIG5vdCBuZWVkIHRvIGJlIGJvdW5kXG5cbiAgICAgIG1zLmFkZEV2ZW50TGlzdGVuZXIoJ3NvdXJjZW9wZW4nLCB0aGlzLl9vbk1lZGlhU291cmNlT3Blbik7XG4gICAgICBtcy5hZGRFdmVudExpc3RlbmVyKCdzb3VyY2VlbmRlZCcsIHRoaXMuX29uTWVkaWFTb3VyY2VFbmRlZCk7XG4gICAgICBtcy5hZGRFdmVudExpc3RlbmVyKCdzb3VyY2VjbG9zZScsIHRoaXMuX29uTWVkaWFTb3VyY2VDbG9zZSk7IC8vIGxpbmsgdmlkZW8gYW5kIG1lZGlhIFNvdXJjZVxuXG4gICAgICBtZWRpYS5zcmMgPSBzZWxmLlVSTC5jcmVhdGVPYmplY3RVUkwobXMpOyAvLyBjYWNoZSB0aGUgbG9jYWxseSBnZW5lcmF0ZWQgb2JqZWN0IHVybFxuXG4gICAgICB0aGlzLl9vYmplY3RVcmwgPSBtZWRpYS5zcmM7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5vbk1lZGlhRGV0YWNoaW5nID0gZnVuY3Rpb24gb25NZWRpYURldGFjaGluZygpIHtcbiAgICB2YXIgbWVkaWEgPSB0aGlzLm1lZGlhLFxuICAgICAgICBtZWRpYVNvdXJjZSA9IHRoaXMubWVkaWFTb3VyY2UsXG4gICAgICAgIF9vYmplY3RVcmwgPSB0aGlzLl9vYmplY3RVcmw7XG5cbiAgICBpZiAobWVkaWFTb3VyY2UpIHtcbiAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImxvZ2dlclwiXS5sb2coJ1tidWZmZXItY29udHJvbGxlcl06IG1lZGlhIHNvdXJjZSBkZXRhY2hpbmcnKTtcblxuICAgICAgaWYgKG1lZGlhU291cmNlLnJlYWR5U3RhdGUgPT09ICdvcGVuJykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIGVuZE9mU3RyZWFtIGNvdWxkIHRyaWdnZXIgZXhjZXB0aW9uIGlmIGFueSBzb3VyY2VidWZmZXIgaXMgaW4gdXBkYXRpbmcgc3RhdGVcbiAgICAgICAgICAvLyB3ZSBkb24ndCByZWFsbHkgY2FyZSBhYm91dCBjaGVja2luZyBzb3VyY2VidWZmZXIgc3RhdGUgaGVyZSxcbiAgICAgICAgICAvLyBhcyB3ZSBhcmUgYW55d2F5IGRldGFjaGluZyB0aGUgTWVkaWFTb3VyY2VcbiAgICAgICAgICAvLyBsZXQncyBqdXN0IGF2b2lkIHRoaXMgZXhjZXB0aW9uIHRvIHByb3BhZ2F0ZVxuICAgICAgICAgIG1lZGlhU291cmNlLmVuZE9mU3RyZWFtKCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImxvZ2dlclwiXS53YXJuKFwiW2J1ZmZlci1jb250cm9sbGVyXTogb25NZWRpYURldGFjaGluZzogXCIgKyBlcnIubWVzc2FnZSArIFwiIHdoaWxlIGNhbGxpbmcgZW5kT2ZTdHJlYW1cIik7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gQ2xlYW4gdXAgdGhlIFNvdXJjZUJ1ZmZlcnMgYnkgaW52b2tpbmcgb25CdWZmZXJSZXNldFxuXG5cbiAgICAgIHRoaXMub25CdWZmZXJSZXNldCgpO1xuICAgICAgbWVkaWFTb3VyY2UucmVtb3ZlRXZlbnRMaXN0ZW5lcignc291cmNlb3BlbicsIHRoaXMuX29uTWVkaWFTb3VyY2VPcGVuKTtcbiAgICAgIG1lZGlhU291cmNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3NvdXJjZWVuZGVkJywgdGhpcy5fb25NZWRpYVNvdXJjZUVuZGVkKTtcbiAgICAgIG1lZGlhU291cmNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3NvdXJjZWNsb3NlJywgdGhpcy5fb25NZWRpYVNvdXJjZUNsb3NlKTsgLy8gRGV0YWNoIHByb3Blcmx5IHRoZSBNZWRpYVNvdXJjZSBmcm9tIHRoZSBIVE1MTWVkaWFFbGVtZW50IGFzXG4gICAgICAvLyBzdWdnZXN0ZWQgaW4gaHR0cHM6Ly9naXRodWIuY29tL3czYy9tZWRpYS1zb3VyY2UvaXNzdWVzLzUzLlxuXG4gICAgICBpZiAobWVkaWEpIHtcbiAgICAgICAgaWYgKF9vYmplY3RVcmwpIHtcbiAgICAgICAgICBzZWxmLlVSTC5yZXZva2VPYmplY3RVUkwoX29iamVjdFVybCk7XG4gICAgICAgIH0gLy8gY2xlYW4gdXAgdmlkZW8gdGFnIHNyYyBvbmx5IGlmIGl0J3Mgb3VyIG93biB1cmwuIHNvbWUgZXh0ZXJuYWwgbGlicmFyaWVzIG1pZ2h0XG4gICAgICAgIC8vIGhpamFjayB0aGUgdmlkZW8gdGFnIGFuZCBjaGFuZ2UgaXRzICdzcmMnIHdpdGhvdXQgZGVzdHJveWluZyB0aGUgSGxzIGluc3RhbmNlIGZpcnN0XG5cblxuICAgICAgICBpZiAobWVkaWEuc3JjID09PSBfb2JqZWN0VXJsKSB7XG4gICAgICAgICAgbWVkaWEucmVtb3ZlQXR0cmlidXRlKCdzcmMnKTtcbiAgICAgICAgICBtZWRpYS5sb2FkKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wibG9nZ2VyXCJdLndhcm4oJ1tidWZmZXItY29udHJvbGxlcl06IG1lZGlhLnNyYyB3YXMgY2hhbmdlZCBieSBhIHRoaXJkIHBhcnR5IC0gc2tpcCBjbGVhbnVwJyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5tZWRpYVNvdXJjZSA9IG51bGw7XG4gICAgICB0aGlzLm1lZGlhID0gbnVsbDtcbiAgICAgIHRoaXMuX29iamVjdFVybCA9IG51bGw7XG4gICAgICB0aGlzLmJ1ZmZlckNvZGVjRXZlbnRzRXhwZWN0ZWQgPSB0aGlzLl9idWZmZXJDb2RlY0V2ZW50c1RvdGFsO1xuICAgICAgdGhpcy5wZW5kaW5nVHJhY2tzID0ge307XG4gICAgICB0aGlzLnRyYWNrcyA9IHt9O1xuICAgIH1cblxuICAgIHRoaXMuaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXZlbnRzXCJdLk1FRElBX0RFVEFDSEVELCB1bmRlZmluZWQpO1xuICB9O1xuXG4gIF9wcm90by5vbkJ1ZmZlclJlc2V0ID0gZnVuY3Rpb24gb25CdWZmZXJSZXNldCgpIHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgIHRoaXMuZ2V0U291cmNlQnVmZmVyVHlwZXMoKS5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICB2YXIgc2IgPSBfdGhpczIuc291cmNlQnVmZmVyW3R5cGVdO1xuXG4gICAgICB0cnkge1xuICAgICAgICBpZiAoc2IpIHtcbiAgICAgICAgICBfdGhpczIucmVtb3ZlQnVmZmVyTGlzdGVuZXJzKHR5cGUpO1xuXG4gICAgICAgICAgaWYgKF90aGlzMi5tZWRpYVNvdXJjZSkge1xuICAgICAgICAgICAgX3RoaXMyLm1lZGlhU291cmNlLnJlbW92ZVNvdXJjZUJ1ZmZlcihzYik7XG4gICAgICAgICAgfSAvLyBTeW5jaHJvbm91c2x5IHJlbW92ZSB0aGUgU0IgZnJvbSB0aGUgbWFwIGJlZm9yZSB0aGUgbmV4dCBjYWxsIGluIG9yZGVyIHRvIHByZXZlbnQgYW4gYXN5bmMgZnVuY3Rpb24gZnJvbVxuICAgICAgICAgIC8vIGFjY2Vzc2luZyBpdFxuXG5cbiAgICAgICAgICBfdGhpczIuc291cmNlQnVmZmVyW3R5cGVdID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wibG9nZ2VyXCJdLndhcm4oXCJbYnVmZmVyLWNvbnRyb2xsZXJdOiBGYWlsZWQgdG8gcmVzZXQgdGhlIFwiICsgdHlwZSArIFwiIGJ1ZmZlclwiLCBlcnIpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGhpcy5faW5pdFNvdXJjZUJ1ZmZlcigpO1xuICB9O1xuXG4gIF9wcm90by5vbkJ1ZmZlckNvZGVjcyA9IGZ1bmN0aW9uIG9uQnVmZmVyQ29kZWNzKGV2ZW50LCBkYXRhKSB7XG4gICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICB2YXIgc291cmNlQnVmZmVyQ291bnQgPSB0aGlzLmdldFNvdXJjZUJ1ZmZlclR5cGVzKCkubGVuZ3RoO1xuICAgIE9iamVjdC5rZXlzKGRhdGEpLmZvckVhY2goZnVuY3Rpb24gKHRyYWNrTmFtZSkge1xuICAgICAgaWYgKHNvdXJjZUJ1ZmZlckNvdW50KSB7XG4gICAgICAgIC8vIGNoZWNrIGlmIFNvdXJjZUJ1ZmZlciBjb2RlYyBuZWVkcyB0byBjaGFuZ2VcbiAgICAgICAgdmFyIHRyYWNrID0gX3RoaXMzLnRyYWNrc1t0cmFja05hbWVdO1xuXG4gICAgICAgIGlmICh0cmFjayAmJiB0eXBlb2YgdHJhY2suYnVmZmVyLmNoYW5nZVR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB2YXIgX2RhdGEkdHJhY2tOYW1lID0gZGF0YVt0cmFja05hbWVdLFxuICAgICAgICAgICAgICBjb2RlYyA9IF9kYXRhJHRyYWNrTmFtZS5jb2RlYyxcbiAgICAgICAgICAgICAgbGV2ZWxDb2RlYyA9IF9kYXRhJHRyYWNrTmFtZS5sZXZlbENvZGVjLFxuICAgICAgICAgICAgICBjb250YWluZXIgPSBfZGF0YSR0cmFja05hbWUuY29udGFpbmVyO1xuICAgICAgICAgIHZhciBjdXJyZW50Q29kZWMgPSAodHJhY2subGV2ZWxDb2RlYyB8fCB0cmFjay5jb2RlYykucmVwbGFjZShWSURFT19DT0RFQ19QUk9GSUxFX1JFUEFDRSwgJyQxJyk7XG4gICAgICAgICAgdmFyIG5leHRDb2RlYyA9IChsZXZlbENvZGVjIHx8IGNvZGVjKS5yZXBsYWNlKFZJREVPX0NPREVDX1BST0ZJTEVfUkVQQUNFLCAnJDEnKTtcblxuICAgICAgICAgIGlmIChjdXJyZW50Q29kZWMgIT09IG5leHRDb2RlYykge1xuICAgICAgICAgICAgdmFyIG1pbWVUeXBlID0gY29udGFpbmVyICsgXCI7Y29kZWNzPVwiICsgKGxldmVsQ29kZWMgfHwgY29kZWMpO1xuXG4gICAgICAgICAgICBfdGhpczMuYXBwZW5kQ2hhbmdlVHlwZSh0cmFja05hbWUsIG1pbWVUeXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGlmIHNvdXJjZSBidWZmZXIocykgbm90IGNyZWF0ZWQgeWV0LCBhcHBlbmRlZCBidWZmZXIgdHJhY2tzIGluIHRoaXMucGVuZGluZ1RyYWNrc1xuICAgICAgICBfdGhpczMucGVuZGluZ1RyYWNrc1t0cmFja05hbWVdID0gZGF0YVt0cmFja05hbWVdO1xuICAgICAgfVxuICAgIH0pOyAvLyBpZiBzb3VyY2VidWZmZXJzIGFscmVhZHkgY3JlYXRlZCwgZG8gbm90aGluZyAuLi5cblxuICAgIGlmIChzb3VyY2VCdWZmZXJDb3VudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuYnVmZmVyQ29kZWNFdmVudHNFeHBlY3RlZCA9IE1hdGgubWF4KHRoaXMuYnVmZmVyQ29kZWNFdmVudHNFeHBlY3RlZCAtIDEsIDApO1xuXG4gICAgaWYgKHRoaXMubWVkaWFTb3VyY2UgJiYgdGhpcy5tZWRpYVNvdXJjZS5yZWFkeVN0YXRlID09PSAnb3BlbicpIHtcbiAgICAgIHRoaXMuY2hlY2tQZW5kaW5nVHJhY2tzKCk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5hcHBlbmRDaGFuZ2VUeXBlID0gZnVuY3Rpb24gYXBwZW5kQ2hhbmdlVHlwZSh0eXBlLCBtaW1lVHlwZSkge1xuICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgdmFyIG9wZXJhdGlvblF1ZXVlID0gdGhpcy5vcGVyYXRpb25RdWV1ZTtcbiAgICB2YXIgb3BlcmF0aW9uID0ge1xuICAgICAgZXhlY3V0ZTogZnVuY3Rpb24gZXhlY3V0ZSgpIHtcbiAgICAgICAgdmFyIHNiID0gX3RoaXM0LnNvdXJjZUJ1ZmZlclt0eXBlXTtcblxuICAgICAgICBpZiAoc2IpIHtcbiAgICAgICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJsb2dnZXJcIl0ubG9nKFwiW2J1ZmZlci1jb250cm9sbGVyXTogY2hhbmdpbmcgXCIgKyB0eXBlICsgXCIgc291cmNlQnVmZmVyIHR5cGUgdG8gXCIgKyBtaW1lVHlwZSk7XG4gICAgICAgICAgc2IuY2hhbmdlVHlwZShtaW1lVHlwZSk7XG4gICAgICAgIH1cblxuICAgICAgICBvcGVyYXRpb25RdWV1ZS5zaGlmdEFuZEV4ZWN1dGVOZXh0KHR5cGUpO1xuICAgICAgfSxcbiAgICAgIG9uU3RhcnQ6IGZ1bmN0aW9uIG9uU3RhcnQoKSB7fSxcbiAgICAgIG9uQ29tcGxldGU6IGZ1bmN0aW9uIG9uQ29tcGxldGUoKSB7fSxcbiAgICAgIG9uRXJyb3I6IGZ1bmN0aW9uIG9uRXJyb3IoZSkge1xuICAgICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJsb2dnZXJcIl0ud2FybihcIltidWZmZXItY29udHJvbGxlcl06IEZhaWxlZCB0byBjaGFuZ2UgXCIgKyB0eXBlICsgXCIgU291cmNlQnVmZmVyIHR5cGVcIiwgZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBvcGVyYXRpb25RdWV1ZS5hcHBlbmQob3BlcmF0aW9uLCB0eXBlKTtcbiAgfTtcblxuICBfcHJvdG8ub25CdWZmZXJBcHBlbmRpbmcgPSBmdW5jdGlvbiBvbkJ1ZmZlckFwcGVuZGluZyhldmVudCwgZXZlbnREYXRhKSB7XG4gICAgdmFyIF90aGlzNSA9IHRoaXM7XG5cbiAgICB2YXIgaGxzID0gdGhpcy5obHMsXG4gICAgICAgIG9wZXJhdGlvblF1ZXVlID0gdGhpcy5vcGVyYXRpb25RdWV1ZSxcbiAgICAgICAgdHJhY2tzID0gdGhpcy50cmFja3M7XG4gICAgdmFyIGRhdGEgPSBldmVudERhdGEuZGF0YSxcbiAgICAgICAgdHlwZSA9IGV2ZW50RGF0YS50eXBlLFxuICAgICAgICBmcmFnID0gZXZlbnREYXRhLmZyYWcsXG4gICAgICAgIHBhcnQgPSBldmVudERhdGEucGFydCxcbiAgICAgICAgY2h1bmtNZXRhID0gZXZlbnREYXRhLmNodW5rTWV0YTtcbiAgICB2YXIgY2h1bmtTdGF0cyA9IGNodW5rTWV0YS5idWZmZXJpbmdbdHlwZV07XG4gICAgdmFyIGJ1ZmZlckFwcGVuZGluZ1N0YXJ0ID0gc2VsZi5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICBjaHVua1N0YXRzLnN0YXJ0ID0gYnVmZmVyQXBwZW5kaW5nU3RhcnQ7XG4gICAgdmFyIGZyYWdCdWZmZXJpbmcgPSBmcmFnLnN0YXRzLmJ1ZmZlcmluZztcbiAgICB2YXIgcGFydEJ1ZmZlcmluZyA9IHBhcnQgPyBwYXJ0LnN0YXRzLmJ1ZmZlcmluZyA6IG51bGw7XG5cbiAgICBpZiAoZnJhZ0J1ZmZlcmluZy5zdGFydCA9PT0gMCkge1xuICAgICAgZnJhZ0J1ZmZlcmluZy5zdGFydCA9IGJ1ZmZlckFwcGVuZGluZ1N0YXJ0O1xuICAgIH1cblxuICAgIGlmIChwYXJ0QnVmZmVyaW5nICYmIHBhcnRCdWZmZXJpbmcuc3RhcnQgPT09IDApIHtcbiAgICAgIHBhcnRCdWZmZXJpbmcuc3RhcnQgPSBidWZmZXJBcHBlbmRpbmdTdGFydDtcbiAgICB9IC8vIFRPRE86IE9ubHkgdXBkYXRlIHRpbWVzdGFtcE9mZnNldCB3aGVuIGF1ZGlvL21wZWcgZnJhZ21lbnQgb3IgcGFydCBpcyBub3QgY29udGlndW91cyB3aXRoIHByZXZpb3VzbHkgYXBwZW5kZWRcbiAgICAvLyBBZGp1c3RpbmcgYFNvdXJjZUJ1ZmZlci50aW1lc3RhbXBPZmZzZXRgIChkZXNpcmVkIHBvaW50IGluIHRoZSB0aW1lbGluZSB3aGVyZSB0aGUgbmV4dCBmcmFtZXMgc2hvdWxkIGJlIGFwcGVuZGVkKVxuICAgIC8vIGluIENocm9tZSBicm93c2VyIHdoZW4gd2UgZGV0ZWN0IE1QRUcgYXVkaW8gY29udGFpbmVyIGFuZCB0aW1lIGRlbHRhIGJldHdlZW4gbGV2ZWwgUFRTIGFuZCBgU291cmNlQnVmZmVyLnRpbWVzdGFtcE9mZnNldGBcbiAgICAvLyBpcyBncmVhdGVyIHRoYW4gMTAwbXMgKHRoaXMgaXMgZW5vdWdoIHRvIGhhbmRsZSBzZWVrIGZvciBWT0Qgb3IgbGV2ZWwgY2hhbmdlIGZvciBMSVZFIHZpZGVvcykuXG4gICAgLy8gTW9yZSBpbmZvIGhlcmU6IGh0dHBzOi8vZ2l0aHViLmNvbS92aWRlby1kZXYvaGxzLmpzL2lzc3Vlcy8zMzIjaXNzdWVjb21tZW50LTI1Nzk4NjQ4NlxuXG5cbiAgICB2YXIgYXVkaW9UcmFjayA9IHRyYWNrcy5hdWRpbztcbiAgICB2YXIgY2hlY2tUaW1lc3RhbXBPZmZzZXQgPSB0eXBlID09PSAnYXVkaW8nICYmIGNodW5rTWV0YS5pZCA9PT0gMSAmJiAoYXVkaW9UcmFjayA9PT0gbnVsbCB8fCBhdWRpb1RyYWNrID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhdWRpb1RyYWNrLmNvbnRhaW5lcikgPT09ICdhdWRpby9tcGVnJztcbiAgICB2YXIgb3BlcmF0aW9uID0ge1xuICAgICAgZXhlY3V0ZTogZnVuY3Rpb24gZXhlY3V0ZSgpIHtcbiAgICAgICAgY2h1bmtTdGF0cy5leGVjdXRlU3RhcnQgPSBzZWxmLnBlcmZvcm1hbmNlLm5vdygpO1xuXG4gICAgICAgIGlmIChjaGVja1RpbWVzdGFtcE9mZnNldCkge1xuICAgICAgICAgIHZhciBzYiA9IF90aGlzNS5zb3VyY2VCdWZmZXJbdHlwZV07XG5cbiAgICAgICAgICBpZiAoc2IpIHtcbiAgICAgICAgICAgIHZhciBkZWx0YSA9IGZyYWcuc3RhcnQgLSBzYi50aW1lc3RhbXBPZmZzZXQ7XG5cbiAgICAgICAgICAgIGlmIChNYXRoLmFicyhkZWx0YSkgPj0gMC4xKSB7XG4gICAgICAgICAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImxvZ2dlclwiXS5sb2coXCJbYnVmZmVyLWNvbnRyb2xsZXJdOiBVcGRhdGluZyBhdWRpbyBTb3VyY2VCdWZmZXIgdGltZXN0YW1wT2Zmc2V0IHRvIFwiICsgZnJhZy5zdGFydCArIFwiIChkZWx0YTogXCIgKyBkZWx0YSArIFwiKSBzbjogXCIgKyBmcmFnLnNuICsgXCIpXCIpO1xuICAgICAgICAgICAgICBzYi50aW1lc3RhbXBPZmZzZXQgPSBmcmFnLnN0YXJ0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIF90aGlzNS5hcHBlbmRFeGVjdXRvcihkYXRhLCB0eXBlKTtcbiAgICAgIH0sXG4gICAgICBvblN0YXJ0OiBmdW5jdGlvbiBvblN0YXJ0KCkgey8vIGxvZ2dlci5kZWJ1ZyhgW2J1ZmZlci1jb250cm9sbGVyXTogJHt0eXBlfSBTb3VyY2VCdWZmZXIgdXBkYXRlc3RhcnRgKTtcbiAgICAgIH0sXG4gICAgICBvbkNvbXBsZXRlOiBmdW5jdGlvbiBvbkNvbXBsZXRlKCkge1xuICAgICAgICAvLyBsb2dnZXIuZGVidWcoYFtidWZmZXItY29udHJvbGxlcl06ICR7dHlwZX0gU291cmNlQnVmZmVyIHVwZGF0ZWVuZGApO1xuICAgICAgICB2YXIgZW5kID0gc2VsZi5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgY2h1bmtTdGF0cy5leGVjdXRlRW5kID0gY2h1bmtTdGF0cy5lbmQgPSBlbmQ7XG5cbiAgICAgICAgaWYgKGZyYWdCdWZmZXJpbmcuZmlyc3QgPT09IDApIHtcbiAgICAgICAgICBmcmFnQnVmZmVyaW5nLmZpcnN0ID0gZW5kO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhcnRCdWZmZXJpbmcgJiYgcGFydEJ1ZmZlcmluZy5maXJzdCA9PT0gMCkge1xuICAgICAgICAgIHBhcnRCdWZmZXJpbmcuZmlyc3QgPSBlbmQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc291cmNlQnVmZmVyID0gX3RoaXM1LnNvdXJjZUJ1ZmZlcjtcbiAgICAgICAgdmFyIHRpbWVSYW5nZXMgPSB7fTtcblxuICAgICAgICBmb3IgKHZhciBfdHlwZSBpbiBzb3VyY2VCdWZmZXIpIHtcbiAgICAgICAgICB0aW1lUmFuZ2VzW190eXBlXSA9IF91dGlsc19idWZmZXJfaGVscGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXCJCdWZmZXJIZWxwZXJcIl0uZ2V0QnVmZmVyZWQoc291cmNlQnVmZmVyW190eXBlXSk7XG4gICAgICAgIH1cblxuICAgICAgICBfdGhpczUuYXBwZW5kRXJyb3IgPSAwO1xuXG4gICAgICAgIF90aGlzNS5obHMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFdmVudHNcIl0uQlVGRkVSX0FQUEVOREVELCB7XG4gICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICBmcmFnOiBmcmFnLFxuICAgICAgICAgIHBhcnQ6IHBhcnQsXG4gICAgICAgICAgY2h1bmtNZXRhOiBjaHVua01ldGEsXG4gICAgICAgICAgcGFyZW50OiBmcmFnLnR5cGUsXG4gICAgICAgICAgdGltZVJhbmdlczogdGltZVJhbmdlc1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBvbkVycm9yOiBmdW5jdGlvbiBvbkVycm9yKGVycikge1xuICAgICAgICAvLyBpbiBjYXNlIGFueSBlcnJvciBvY2N1cmVkIHdoaWxlIGFwcGVuZGluZywgcHV0IGJhY2sgc2VnbWVudCBpbiBzZWdtZW50cyB0YWJsZVxuICAgICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJsb2dnZXJcIl0uZXJyb3IoXCJbYnVmZmVyLWNvbnRyb2xsZXJdOiBFcnJvciBlbmNvdW50ZXJlZCB3aGlsZSB0cnlpbmcgdG8gYXBwZW5kIHRvIHRoZSBcIiArIHR5cGUgKyBcIiBTb3VyY2VCdWZmZXJcIiwgZXJyKTtcbiAgICAgICAgdmFyIGV2ZW50ID0ge1xuICAgICAgICAgIHR5cGU6IF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcIkVycm9yVHlwZXNcIl0uTUVESUFfRVJST1IsXG4gICAgICAgICAgcGFyZW50OiBmcmFnLnR5cGUsXG4gICAgICAgICAgZGV0YWlsczogX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiRXJyb3JEZXRhaWxzXCJdLkJVRkZFUl9BUFBFTkRfRVJST1IsXG4gICAgICAgICAgZXJyOiBlcnIsXG4gICAgICAgICAgZmF0YWw6IGZhbHNlXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGVyci5jb2RlID09PSBET01FeGNlcHRpb24uUVVPVEFfRVhDRUVERURfRVJSKSB7XG4gICAgICAgICAgLy8gUXVvdGFFeGNlZWRlZEVycm9yOiBodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNS9pbmZyYXN0cnVjdHVyZS5odG1sI3F1b3RhZXhjZWVkZWRlcnJvclxuICAgICAgICAgIC8vIGxldCdzIHN0b3AgYXBwZW5kaW5nIGFueSBzZWdtZW50cywgYW5kIHJlcG9ydCBCVUZGRVJfRlVMTF9FUlJPUiBlcnJvclxuICAgICAgICAgIGV2ZW50LmRldGFpbHMgPSBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJFcnJvckRldGFpbHNcIl0uQlVGRkVSX0ZVTExfRVJST1I7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX3RoaXM1LmFwcGVuZEVycm9yKys7XG4gICAgICAgICAgZXZlbnQuZGV0YWlscyA9IF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcIkVycm9yRGV0YWlsc1wiXS5CVUZGRVJfQVBQRU5EX0VSUk9SO1xuICAgICAgICAgIC8qIHdpdGggVUhEIGNvbnRlbnQsIHdlIGNvdWxkIGdldCBsb29wIG9mIHF1b3RhIGV4Y2VlZGVkIGVycm9yIHVudGlsXG4gICAgICAgICAgICBicm93c2VyIGlzIGFibGUgdG8gZXZpY3Qgc29tZSBkYXRhIGZyb20gc291cmNlYnVmZmVyLiBSZXRyeWluZyBjYW4gaGVscCByZWNvdmVyLlxuICAgICAgICAgICovXG5cbiAgICAgICAgICBpZiAoX3RoaXM1LmFwcGVuZEVycm9yID4gaGxzLmNvbmZpZy5hcHBlbmRFcnJvck1heFJldHJ5KSB7XG4gICAgICAgICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJsb2dnZXJcIl0uZXJyb3IoXCJbYnVmZmVyLWNvbnRyb2xsZXJdOiBGYWlsZWQgXCIgKyBobHMuY29uZmlnLmFwcGVuZEVycm9yTWF4UmV0cnkgKyBcIiB0aW1lcyB0byBhcHBlbmQgc2VnbWVudCBpbiBzb3VyY2VCdWZmZXJcIik7XG4gICAgICAgICAgICBldmVudC5mYXRhbCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXZlbnRzXCJdLkVSUk9SLCBldmVudCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBvcGVyYXRpb25RdWV1ZS5hcHBlbmQob3BlcmF0aW9uLCB0eXBlKTtcbiAgfTtcblxuICBfcHJvdG8ub25CdWZmZXJGbHVzaGluZyA9IGZ1bmN0aW9uIG9uQnVmZmVyRmx1c2hpbmcoZXZlbnQsIGRhdGEpIHtcbiAgICB2YXIgX3RoaXM2ID0gdGhpcztcblxuICAgIHZhciBvcGVyYXRpb25RdWV1ZSA9IHRoaXMub3BlcmF0aW9uUXVldWU7XG5cbiAgICB2YXIgZmx1c2hPcGVyYXRpb24gPSBmdW5jdGlvbiBmbHVzaE9wZXJhdGlvbih0eXBlKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBleGVjdXRlOiBfdGhpczYucmVtb3ZlRXhlY3V0b3IuYmluZChfdGhpczYsIHR5cGUsIGRhdGEuc3RhcnRPZmZzZXQsIGRhdGEuZW5kT2Zmc2V0KSxcbiAgICAgICAgb25TdGFydDogZnVuY3Rpb24gb25TdGFydCgpIHsvLyBsb2dnZXIuZGVidWcoYFtidWZmZXItY29udHJvbGxlcl06IFN0YXJ0ZWQgZmx1c2hpbmcgJHtkYXRhLnN0YXJ0T2Zmc2V0fSAtPiAke2RhdGEuZW5kT2Zmc2V0fSBmb3IgJHt0eXBlfSBTb3VyY2UgQnVmZmVyYCk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uQ29tcGxldGU6IGZ1bmN0aW9uIG9uQ29tcGxldGUoKSB7XG4gICAgICAgICAgLy8gbG9nZ2VyLmRlYnVnKGBbYnVmZmVyLWNvbnRyb2xsZXJdOiBGaW5pc2hlZCBmbHVzaGluZyAke2RhdGEuc3RhcnRPZmZzZXR9IC0+ICR7ZGF0YS5lbmRPZmZzZXR9IGZvciAke3R5cGV9IFNvdXJjZSBCdWZmZXJgKTtcbiAgICAgICAgICBfdGhpczYuaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXZlbnRzXCJdLkJVRkZFUl9GTFVTSEVELCB7XG4gICAgICAgICAgICB0eXBlOiB0eXBlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uRXJyb3I6IGZ1bmN0aW9uIG9uRXJyb3IoZSkge1xuICAgICAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImxvZ2dlclwiXS53YXJuKFwiW2J1ZmZlci1jb250cm9sbGVyXTogRmFpbGVkIHRvIHJlbW92ZSBmcm9tIFwiICsgdHlwZSArIFwiIFNvdXJjZUJ1ZmZlclwiLCBlKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgaWYgKGRhdGEudHlwZSkge1xuICAgICAgb3BlcmF0aW9uUXVldWUuYXBwZW5kKGZsdXNoT3BlcmF0aW9uKGRhdGEudHlwZSksIGRhdGEudHlwZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZ2V0U291cmNlQnVmZmVyVHlwZXMoKS5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIG9wZXJhdGlvblF1ZXVlLmFwcGVuZChmbHVzaE9wZXJhdGlvbih0eXBlKSwgdHlwZSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLm9uRnJhZ1BhcnNlZCA9IGZ1bmN0aW9uIG9uRnJhZ1BhcnNlZChldmVudCwgZGF0YSkge1xuICAgIHZhciBfdGhpczcgPSB0aGlzO1xuXG4gICAgdmFyIGZyYWcgPSBkYXRhLmZyYWcsXG4gICAgICAgIHBhcnQgPSBkYXRhLnBhcnQ7XG4gICAgdmFyIGJ1ZmZlcnNBcHBlbmRlZFRvID0gW107XG4gICAgdmFyIGVsZW1lbnRhcnlTdHJlYW1zID0gcGFydCA/IHBhcnQuZWxlbWVudGFyeVN0cmVhbXMgOiBmcmFnLmVsZW1lbnRhcnlTdHJlYW1zO1xuXG4gICAgaWYgKGVsZW1lbnRhcnlTdHJlYW1zW19sb2FkZXJfZnJhZ21lbnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcIkVsZW1lbnRhcnlTdHJlYW1UeXBlc1wiXS5BVURJT1ZJREVPXSkge1xuICAgICAgYnVmZmVyc0FwcGVuZGVkVG8ucHVzaCgnYXVkaW92aWRlbycpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZWxlbWVudGFyeVN0cmVhbXNbX2xvYWRlcl9mcmFnbWVudF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fW1wiRWxlbWVudGFyeVN0cmVhbVR5cGVzXCJdLkFVRElPXSkge1xuICAgICAgICBidWZmZXJzQXBwZW5kZWRUby5wdXNoKCdhdWRpbycpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZWxlbWVudGFyeVN0cmVhbXNbX2xvYWRlcl9mcmFnbWVudF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fW1wiRWxlbWVudGFyeVN0cmVhbVR5cGVzXCJdLlZJREVPXSkge1xuICAgICAgICBidWZmZXJzQXBwZW5kZWRUby5wdXNoKCd2aWRlbycpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBvblVuYmxvY2tlZCA9IGZ1bmN0aW9uIG9uVW5ibG9ja2VkKCkge1xuICAgICAgdmFyIG5vdyA9IHNlbGYucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBmcmFnLnN0YXRzLmJ1ZmZlcmluZy5lbmQgPSBub3c7XG5cbiAgICAgIGlmIChwYXJ0KSB7XG4gICAgICAgIHBhcnQuc3RhdHMuYnVmZmVyaW5nLmVuZCA9IG5vdztcbiAgICAgIH1cblxuICAgICAgdmFyIHN0YXRzID0gcGFydCA/IHBhcnQuc3RhdHMgOiBmcmFnLnN0YXRzO1xuXG4gICAgICBfdGhpczcuaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXZlbnRzXCJdLkZSQUdfQlVGRkVSRUQsIHtcbiAgICAgICAgZnJhZzogZnJhZyxcbiAgICAgICAgcGFydDogcGFydCxcbiAgICAgICAgc3RhdHM6IHN0YXRzLFxuICAgICAgICBpZDogZnJhZy50eXBlXG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgaWYgKGJ1ZmZlcnNBcHBlbmRlZFRvLmxlbmd0aCA9PT0gMCkge1xuICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wibG9nZ2VyXCJdLndhcm4oXCJGcmFnbWVudHMgbXVzdCBoYXZlIGF0IGxlYXN0IG9uZSBFbGVtZW50YXJ5U3RyZWFtVHlwZSBzZXQuIHR5cGU6IFwiICsgZnJhZy50eXBlICsgXCIgbGV2ZWw6IFwiICsgZnJhZy5sZXZlbCArIFwiIHNuOiBcIiArIGZyYWcuc24pO1xuICAgIH1cblxuICAgIHRoaXMuYmxvY2tCdWZmZXJzKG9uVW5ibG9ja2VkLCBidWZmZXJzQXBwZW5kZWRUbyk7XG4gIH07XG5cbiAgX3Byb3RvLm9uRnJhZ0NoYW5nZWQgPSBmdW5jdGlvbiBvbkZyYWdDaGFuZ2VkKGV2ZW50LCBkYXRhKSB7XG4gICAgdGhpcy5mbHVzaEJhY2tCdWZmZXIoKTtcbiAgfSAvLyBvbiBCVUZGRVJfRU9TIG1hcmsgbWF0Y2hpbmcgc291cmNlYnVmZmVyKHMpIGFzIGVuZGVkIGFuZCB0cmlnZ2VyIGNoZWNrRW9zKClcbiAgLy8gYW4gdW5kZWZpbmVkIGRhdGEudHlwZSB3aWxsIG1hcmsgYWxsIGJ1ZmZlcnMgYXMgRU9TLlxuICA7XG5cbiAgX3Byb3RvLm9uQnVmZmVyRW9zID0gZnVuY3Rpb24gb25CdWZmZXJFb3MoZXZlbnQsIGRhdGEpIHtcbiAgICB2YXIgX3RoaXM4ID0gdGhpcztcblxuICAgIHZhciBlbmRlZCA9IHRoaXMuZ2V0U291cmNlQnVmZmVyVHlwZXMoKS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgdHlwZSkge1xuICAgICAgdmFyIHNiID0gX3RoaXM4LnNvdXJjZUJ1ZmZlclt0eXBlXTtcblxuICAgICAgaWYgKCFkYXRhLnR5cGUgfHwgZGF0YS50eXBlID09PSB0eXBlKSB7XG4gICAgICAgIGlmIChzYiAmJiAhc2IuZW5kZWQpIHtcbiAgICAgICAgICBzYi5lbmRlZCA9IHRydWU7XG4gICAgICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wibG9nZ2VyXCJdLmxvZyhcIltidWZmZXItY29udHJvbGxlcl06IFwiICsgdHlwZSArIFwiIHNvdXJjZUJ1ZmZlciBub3cgRU9TXCIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhY2MgJiYgISEoIXNiIHx8IHNiLmVuZGVkKTtcbiAgICB9LCB0cnVlKTtcblxuICAgIGlmIChlbmRlZCkge1xuICAgICAgdGhpcy5ibG9ja0J1ZmZlcnMoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbWVkaWFTb3VyY2UgPSBfdGhpczgubWVkaWFTb3VyY2U7XG5cbiAgICAgICAgaWYgKCFtZWRpYVNvdXJjZSB8fCBtZWRpYVNvdXJjZS5yZWFkeVN0YXRlICE9PSAnb3BlbicpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gLy8gQWxsb3cgdGhpcyB0byB0aHJvdyBhbmQgYmUgY2F1Z2h0IGJ5IHRoZSBlbnF1ZXVlaW5nIGZ1bmN0aW9uXG5cblxuICAgICAgICBtZWRpYVNvdXJjZS5lbmRPZlN0cmVhbSgpO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5vbkxldmVsVXBkYXRlZCA9IGZ1bmN0aW9uIG9uTGV2ZWxVcGRhdGVkKGV2ZW50LCBfcmVmKSB7XG4gICAgdmFyIGRldGFpbHMgPSBfcmVmLmRldGFpbHM7XG5cbiAgICBpZiAoIWRldGFpbHMuZnJhZ21lbnRzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuZGV0YWlscyA9IGRldGFpbHM7XG5cbiAgICBpZiAodGhpcy5nZXRTb3VyY2VCdWZmZXJUeXBlcygpLmxlbmd0aCkge1xuICAgICAgdGhpcy5ibG9ja0J1ZmZlcnModGhpcy51cGRhdGVNZWRpYUVsZW1lbnREdXJhdGlvbi5iaW5kKHRoaXMpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy51cGRhdGVNZWRpYUVsZW1lbnREdXJhdGlvbigpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uZmx1c2hCYWNrQnVmZmVyID0gZnVuY3Rpb24gZmx1c2hCYWNrQnVmZmVyKCkge1xuICAgIHZhciBobHMgPSB0aGlzLmhscyxcbiAgICAgICAgZGV0YWlscyA9IHRoaXMuZGV0YWlscyxcbiAgICAgICAgbWVkaWEgPSB0aGlzLm1lZGlhLFxuICAgICAgICBzb3VyY2VCdWZmZXIgPSB0aGlzLnNvdXJjZUJ1ZmZlcjtcblxuICAgIGlmICghbWVkaWEgfHwgZGV0YWlscyA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBzb3VyY2VCdWZmZXJUeXBlcyA9IHRoaXMuZ2V0U291cmNlQnVmZmVyVHlwZXMoKTtcblxuICAgIGlmICghc291cmNlQnVmZmVyVHlwZXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBTdXBwb3J0IGZvciBkZXByZWNhdGVkIGxpdmVCYWNrQnVmZmVyTGVuZ3RoXG5cblxuICAgIHZhciBiYWNrQnVmZmVyTGVuZ3RoID0gZGV0YWlscy5saXZlICYmIGhscy5jb25maWcubGl2ZUJhY2tCdWZmZXJMZW5ndGggIT09IG51bGwgPyBobHMuY29uZmlnLmxpdmVCYWNrQnVmZmVyTGVuZ3RoIDogaGxzLmNvbmZpZy5iYWNrQnVmZmVyTGVuZ3RoO1xuXG4gICAgaWYgKCFPYmplY3QoX2hvbWVfcnVubmVyX3dvcmtfaGxzX2pzX2hsc19qc19zcmNfcG9seWZpbGxzX251bWJlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiaXNGaW5pdGVOdW1iZXJcIl0pKGJhY2tCdWZmZXJMZW5ndGgpIHx8IGJhY2tCdWZmZXJMZW5ndGggPCAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGN1cnJlbnRUaW1lID0gbWVkaWEuY3VycmVudFRpbWU7XG4gICAgdmFyIHRhcmdldER1cmF0aW9uID0gZGV0YWlscy5sZXZlbFRhcmdldER1cmF0aW9uO1xuICAgIHZhciBtYXhCYWNrQnVmZmVyTGVuZ3RoID0gTWF0aC5tYXgoYmFja0J1ZmZlckxlbmd0aCwgdGFyZ2V0RHVyYXRpb24pO1xuICAgIHZhciB0YXJnZXRCYWNrQnVmZmVyUG9zaXRpb24gPSBNYXRoLmZsb29yKGN1cnJlbnRUaW1lIC8gdGFyZ2V0RHVyYXRpb24pICogdGFyZ2V0RHVyYXRpb24gLSBtYXhCYWNrQnVmZmVyTGVuZ3RoO1xuICAgIHNvdXJjZUJ1ZmZlclR5cGVzLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgIHZhciBzYiA9IHNvdXJjZUJ1ZmZlclt0eXBlXTtcblxuICAgICAgaWYgKHNiKSB7XG4gICAgICAgIHZhciBidWZmZXJlZCA9IF91dGlsc19idWZmZXJfaGVscGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXCJCdWZmZXJIZWxwZXJcIl0uZ2V0QnVmZmVyZWQoc2IpOyAvLyB3aGVuIHRhcmdldCBidWZmZXIgc3RhcnQgZXhjZWVkcyBhY3R1YWwgYnVmZmVyIHN0YXJ0XG5cbiAgICAgICAgaWYgKGJ1ZmZlcmVkLmxlbmd0aCA+IDAgJiYgdGFyZ2V0QmFja0J1ZmZlclBvc2l0aW9uID4gYnVmZmVyZWQuc3RhcnQoMCkpIHtcbiAgICAgICAgICBobHMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFdmVudHNcIl0uQkFDS19CVUZGRVJfUkVBQ0hFRCwge1xuICAgICAgICAgICAgYnVmZmVyRW5kOiB0YXJnZXRCYWNrQnVmZmVyUG9zaXRpb25cbiAgICAgICAgICB9KTsgLy8gU3VwcG9ydCBmb3IgZGVwcmVjYXRlZCBldmVudDpcblxuICAgICAgICAgIGlmIChkZXRhaWxzLmxpdmUpIHtcbiAgICAgICAgICAgIGhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkV2ZW50c1wiXS5MSVZFX0JBQ0tfQlVGRkVSX1JFQUNIRUQsIHtcbiAgICAgICAgICAgICAgYnVmZmVyRW5kOiB0YXJnZXRCYWNrQnVmZmVyUG9zaXRpb25cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkV2ZW50c1wiXS5CVUZGRVJfRkxVU0hJTkcsIHtcbiAgICAgICAgICAgIHN0YXJ0T2Zmc2V0OiAwLFxuICAgICAgICAgICAgZW5kT2Zmc2V0OiB0YXJnZXRCYWNrQnVmZmVyUG9zaXRpb24sXG4gICAgICAgICAgICB0eXBlOiB0eXBlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogVXBkYXRlIE1lZGlhIFNvdXJjZSBkdXJhdGlvbiB0byBjdXJyZW50IGxldmVsIGR1cmF0aW9uIG9yIG92ZXJyaWRlIHRvIEluZmluaXR5IGlmIGNvbmZpZ3VyYXRpb24gcGFyYW1ldGVyXG4gICAqICdsaXZlRHVyYXRpb25JbmZpbml0eWAgaXMgc2V0IHRvIGB0cnVlYFxuICAgKiBNb3JlIGRldGFpbHM6IGh0dHBzOi8vZ2l0aHViLmNvbS92aWRlby1kZXYvaGxzLmpzL2lzc3Vlcy8zNTVcbiAgICovXG4gIDtcblxuICBfcHJvdG8udXBkYXRlTWVkaWFFbGVtZW50RHVyYXRpb24gPSBmdW5jdGlvbiB1cGRhdGVNZWRpYUVsZW1lbnREdXJhdGlvbigpIHtcbiAgICBpZiAoIXRoaXMuZGV0YWlscyB8fCAhdGhpcy5tZWRpYSB8fCAhdGhpcy5tZWRpYVNvdXJjZSB8fCB0aGlzLm1lZGlhU291cmNlLnJlYWR5U3RhdGUgIT09ICdvcGVuJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBkZXRhaWxzID0gdGhpcy5kZXRhaWxzLFxuICAgICAgICBobHMgPSB0aGlzLmhscyxcbiAgICAgICAgbWVkaWEgPSB0aGlzLm1lZGlhLFxuICAgICAgICBtZWRpYVNvdXJjZSA9IHRoaXMubWVkaWFTb3VyY2U7XG4gICAgdmFyIGxldmVsRHVyYXRpb24gPSBkZXRhaWxzLmZyYWdtZW50c1swXS5zdGFydCArIGRldGFpbHMudG90YWxkdXJhdGlvbjtcbiAgICB2YXIgbWVkaWFEdXJhdGlvbiA9IG1lZGlhLmR1cmF0aW9uO1xuICAgIHZhciBtc0R1cmF0aW9uID0gT2JqZWN0KF9ob21lX3J1bm5lcl93b3JrX2hsc19qc19obHNfanNfc3JjX3BvbHlmaWxsc19udW1iZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImlzRmluaXRlTnVtYmVyXCJdKShtZWRpYVNvdXJjZS5kdXJhdGlvbikgPyBtZWRpYVNvdXJjZS5kdXJhdGlvbiA6IDA7XG5cbiAgICBpZiAoZGV0YWlscy5saXZlICYmIGhscy5jb25maWcubGl2ZUR1cmF0aW9uSW5maW5pdHkpIHtcbiAgICAgIC8vIE92ZXJyaWRlIGR1cmF0aW9uIHRvIEluZmluaXR5XG4gICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJsb2dnZXJcIl0ubG9nKCdbYnVmZmVyLWNvbnRyb2xsZXJdOiBNZWRpYSBTb3VyY2UgZHVyYXRpb24gaXMgc2V0IHRvIEluZmluaXR5Jyk7XG4gICAgICBtZWRpYVNvdXJjZS5kdXJhdGlvbiA9IEluZmluaXR5O1xuICAgICAgdGhpcy51cGRhdGVTZWVrYWJsZVJhbmdlKGRldGFpbHMpO1xuICAgIH0gZWxzZSBpZiAobGV2ZWxEdXJhdGlvbiA+IG1zRHVyYXRpb24gJiYgbGV2ZWxEdXJhdGlvbiA+IG1lZGlhRHVyYXRpb24gfHwgIU9iamVjdChfaG9tZV9ydW5uZXJfd29ya19obHNfanNfaGxzX2pzX3NyY19wb2x5ZmlsbHNfbnVtYmVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJpc0Zpbml0ZU51bWJlclwiXSkobWVkaWFEdXJhdGlvbikpIHtcbiAgICAgIC8vIGxldmVsRHVyYXRpb24gd2FzIHRoZSBsYXN0IHZhbHVlIHdlIHNldC5cbiAgICAgIC8vIG5vdCB1c2luZyBtZWRpYVNvdXJjZS5kdXJhdGlvbiBhcyB0aGUgYnJvd3NlciBtYXkgdHdlYWsgdGhpcyB2YWx1ZVxuICAgICAgLy8gb25seSB1cGRhdGUgTWVkaWEgU291cmNlIGR1cmF0aW9uIGlmIGl0cyB2YWx1ZSBpbmNyZWFzZSwgdGhpcyBpcyB0byBhdm9pZFxuICAgICAgLy8gZmx1c2hpbmcgYWxyZWFkeSBidWZmZXJlZCBwb3J0aW9uIHdoZW4gc3dpdGNoaW5nIGJldHdlZW4gcXVhbGl0eSBsZXZlbFxuICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wibG9nZ2VyXCJdLmxvZyhcIltidWZmZXItY29udHJvbGxlcl06IFVwZGF0aW5nIE1lZGlhIFNvdXJjZSBkdXJhdGlvbiB0byBcIiArIGxldmVsRHVyYXRpb24udG9GaXhlZCgzKSk7XG4gICAgICBtZWRpYVNvdXJjZS5kdXJhdGlvbiA9IGxldmVsRHVyYXRpb247XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by51cGRhdGVTZWVrYWJsZVJhbmdlID0gZnVuY3Rpb24gdXBkYXRlU2Vla2FibGVSYW5nZShsZXZlbERldGFpbHMpIHtcbiAgICB2YXIgbWVkaWFTb3VyY2UgPSB0aGlzLm1lZGlhU291cmNlO1xuICAgIHZhciBmcmFnbWVudHMgPSBsZXZlbERldGFpbHMuZnJhZ21lbnRzO1xuICAgIHZhciBsZW4gPSBmcmFnbWVudHMubGVuZ3RoO1xuXG4gICAgaWYgKGxlbiAmJiBsZXZlbERldGFpbHMubGl2ZSAmJiBtZWRpYVNvdXJjZSAhPT0gbnVsbCAmJiBtZWRpYVNvdXJjZSAhPT0gdm9pZCAwICYmIG1lZGlhU291cmNlLnNldExpdmVTZWVrYWJsZVJhbmdlKSB7XG4gICAgICB2YXIgc3RhcnQgPSBNYXRoLm1heCgwLCBmcmFnbWVudHNbMF0uc3RhcnQpO1xuICAgICAgdmFyIGVuZCA9IE1hdGgubWF4KHN0YXJ0LCBzdGFydCArIGxldmVsRGV0YWlscy50b3RhbGR1cmF0aW9uKTtcbiAgICAgIG1lZGlhU291cmNlLnNldExpdmVTZWVrYWJsZVJhbmdlKHN0YXJ0LCBlbmQpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uY2hlY2tQZW5kaW5nVHJhY2tzID0gZnVuY3Rpb24gY2hlY2tQZW5kaW5nVHJhY2tzKCkge1xuICAgIHZhciBidWZmZXJDb2RlY0V2ZW50c0V4cGVjdGVkID0gdGhpcy5idWZmZXJDb2RlY0V2ZW50c0V4cGVjdGVkLFxuICAgICAgICBvcGVyYXRpb25RdWV1ZSA9IHRoaXMub3BlcmF0aW9uUXVldWUsXG4gICAgICAgIHBlbmRpbmdUcmFja3MgPSB0aGlzLnBlbmRpbmdUcmFja3M7IC8vIENoZWNrIGlmIHdlJ3ZlIHJlY2VpdmVkIGFsbCBvZiB0aGUgZXhwZWN0ZWQgYnVmZmVyQ29kZWMgZXZlbnRzLiBXaGVuIG5vbmUgcmVtYWluLCBjcmVhdGUgYWxsIHRoZSBzb3VyY2VCdWZmZXJzIGF0IG9uY2UuXG4gICAgLy8gVGhpcyBpcyBpbXBvcnRhbnQgYmVjYXVzZSB0aGUgTVNFIHNwZWMgYWxsb3dzIGltcGxlbWVudGF0aW9ucyB0byB0aHJvdyBRdW90YUV4Y2VlZGVkRXJyb3JzIGlmIGNyZWF0aW5nIG5ldyBzb3VyY2VCdWZmZXJzIGFmdGVyXG4gICAgLy8gZGF0YSBoYXMgYmVlbiBhcHBlbmRlZCB0byBleGlzdGluZyBvbmVzLlxuICAgIC8vIDIgdHJhY2tzIGlzIHRoZSBtYXggKG9uZSBmb3IgYXVkaW8sIG9uZSBmb3IgdmlkZW8pLiBJZiB3ZSd2ZSByZWFjaCB0aGlzIG1heCBnbyBhaGVhZCBhbmQgY3JlYXRlIHRoZSBidWZmZXJzLlxuXG4gICAgdmFyIHBlbmRpbmdUcmFja3NDb3VudCA9IE9iamVjdC5rZXlzKHBlbmRpbmdUcmFja3MpLmxlbmd0aDtcblxuICAgIGlmIChwZW5kaW5nVHJhY2tzQ291bnQgJiYgIWJ1ZmZlckNvZGVjRXZlbnRzRXhwZWN0ZWQgfHwgcGVuZGluZ1RyYWNrc0NvdW50ID09PSAyKSB7XG4gICAgICAvLyBvaywgbGV0J3MgY3JlYXRlIHRoZW0gbm93ICFcbiAgICAgIHRoaXMuY3JlYXRlU291cmNlQnVmZmVycyhwZW5kaW5nVHJhY2tzKTtcbiAgICAgIHRoaXMucGVuZGluZ1RyYWNrcyA9IHt9OyAvLyBhcHBlbmQgYW55IHBlbmRpbmcgc2VnbWVudHMgbm93ICFcblxuICAgICAgdmFyIGJ1ZmZlcnMgPSB0aGlzLmdldFNvdXJjZUJ1ZmZlclR5cGVzKCk7XG5cbiAgICAgIGlmIChidWZmZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkV2ZW50c1wiXS5FUlJPUiwge1xuICAgICAgICAgIHR5cGU6IF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcIkVycm9yVHlwZXNcIl0uTUVESUFfRVJST1IsXG4gICAgICAgICAgZGV0YWlsczogX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiRXJyb3JEZXRhaWxzXCJdLkJVRkZFUl9JTkNPTVBBVElCTEVfQ09ERUNTX0VSUk9SLFxuICAgICAgICAgIGZhdGFsOiB0cnVlLFxuICAgICAgICAgIHJlYXNvbjogJ2NvdWxkIG5vdCBjcmVhdGUgc291cmNlIGJ1ZmZlciBmb3IgbWVkaWEgY29kZWMocyknXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGJ1ZmZlcnMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICBvcGVyYXRpb25RdWV1ZS5leGVjdXRlTmV4dCh0eXBlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uY3JlYXRlU291cmNlQnVmZmVycyA9IGZ1bmN0aW9uIGNyZWF0ZVNvdXJjZUJ1ZmZlcnModHJhY2tzKSB7XG4gICAgdmFyIHNvdXJjZUJ1ZmZlciA9IHRoaXMuc291cmNlQnVmZmVyLFxuICAgICAgICBtZWRpYVNvdXJjZSA9IHRoaXMubWVkaWFTb3VyY2U7XG5cbiAgICBpZiAoIW1lZGlhU291cmNlKSB7XG4gICAgICB0aHJvdyBFcnJvcignY3JlYXRlU291cmNlQnVmZmVycyBjYWxsZWQgd2hlbiBtZWRpYVNvdXJjZSB3YXMgbnVsbCcpO1xuICAgIH1cblxuICAgIHZhciB0cmFja3NDcmVhdGVkID0gMDtcblxuICAgIGZvciAodmFyIHRyYWNrTmFtZSBpbiB0cmFja3MpIHtcbiAgICAgIGlmICghc291cmNlQnVmZmVyW3RyYWNrTmFtZV0pIHtcbiAgICAgICAgdmFyIHRyYWNrID0gdHJhY2tzW3RyYWNrTmFtZV07XG5cbiAgICAgICAgaWYgKCF0cmFjaykge1xuICAgICAgICAgIHRocm93IEVycm9yKFwic291cmNlIGJ1ZmZlciBleGlzdHMgZm9yIHRyYWNrIFwiICsgdHJhY2tOYW1lICsgXCIsIGhvd2V2ZXIgdHJhY2sgZG9lcyBub3RcIik7XG4gICAgICAgIH0gLy8gdXNlIGxldmVsQ29kZWMgYXMgZmlyc3QgcHJpb3JpdHlcblxuXG4gICAgICAgIHZhciBjb2RlYyA9IHRyYWNrLmxldmVsQ29kZWMgfHwgdHJhY2suY29kZWM7XG4gICAgICAgIHZhciBtaW1lVHlwZSA9IHRyYWNrLmNvbnRhaW5lciArIFwiO2NvZGVjcz1cIiArIGNvZGVjO1xuICAgICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJsb2dnZXJcIl0ubG9nKFwiW2J1ZmZlci1jb250cm9sbGVyXTogY3JlYXRpbmcgc291cmNlQnVmZmVyKFwiICsgbWltZVR5cGUgKyBcIilcIik7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2YXIgc2IgPSBzb3VyY2VCdWZmZXJbdHJhY2tOYW1lXSA9IG1lZGlhU291cmNlLmFkZFNvdXJjZUJ1ZmZlcihtaW1lVHlwZSk7XG4gICAgICAgICAgdmFyIHNiTmFtZSA9IHRyYWNrTmFtZTtcbiAgICAgICAgICB0aGlzLmFkZEJ1ZmZlckxpc3RlbmVyKHNiTmFtZSwgJ3VwZGF0ZXN0YXJ0JywgdGhpcy5fb25TQlVwZGF0ZVN0YXJ0KTtcbiAgICAgICAgICB0aGlzLmFkZEJ1ZmZlckxpc3RlbmVyKHNiTmFtZSwgJ3VwZGF0ZWVuZCcsIHRoaXMuX29uU0JVcGRhdGVFbmQpO1xuICAgICAgICAgIHRoaXMuYWRkQnVmZmVyTGlzdGVuZXIoc2JOYW1lLCAnZXJyb3InLCB0aGlzLl9vblNCVXBkYXRlRXJyb3IpO1xuICAgICAgICAgIHRoaXMudHJhY2tzW3RyYWNrTmFtZV0gPSB7XG4gICAgICAgICAgICBidWZmZXI6IHNiLFxuICAgICAgICAgICAgY29kZWM6IGNvZGVjLFxuICAgICAgICAgICAgY29udGFpbmVyOiB0cmFjay5jb250YWluZXIsXG4gICAgICAgICAgICBsZXZlbENvZGVjOiB0cmFjay5sZXZlbENvZGVjLFxuICAgICAgICAgICAgaWQ6IHRyYWNrLmlkXG4gICAgICAgICAgfTtcbiAgICAgICAgICB0cmFja3NDcmVhdGVkKys7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImxvZ2dlclwiXS5lcnJvcihcIltidWZmZXItY29udHJvbGxlcl06IGVycm9yIHdoaWxlIHRyeWluZyB0byBhZGQgc291cmNlQnVmZmVyOiBcIiArIGVyci5tZXNzYWdlKTtcbiAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkV2ZW50c1wiXS5FUlJPUiwge1xuICAgICAgICAgICAgdHlwZTogX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiRXJyb3JUeXBlc1wiXS5NRURJQV9FUlJPUixcbiAgICAgICAgICAgIGRldGFpbHM6IF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcIkVycm9yRGV0YWlsc1wiXS5CVUZGRVJfQUREX0NPREVDX0VSUk9SLFxuICAgICAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICAgICAgZXJyb3I6IGVycixcbiAgICAgICAgICAgIG1pbWVUeXBlOiBtaW1lVHlwZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRyYWNrc0NyZWF0ZWQpIHtcbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXZlbnRzXCJdLkJVRkZFUl9DUkVBVEVELCB7XG4gICAgICAgIHRyYWNrczogdGhpcy50cmFja3NcbiAgICAgIH0pO1xuICAgIH1cbiAgfSAvLyBLZWVwIGFzIGFycm93IGZ1bmN0aW9ucyBzbyB0aGF0IHdlIGNhbiBkaXJlY3RseSByZWZlcmVuY2UgdGhlc2UgZnVuY3Rpb25zIGRpcmVjdGx5IGFzIGV2ZW50IGxpc3RlbmVyc1xuICA7XG5cbiAgX3Byb3RvLl9vblNCVXBkYXRlU3RhcnQgPSBmdW5jdGlvbiBfb25TQlVwZGF0ZVN0YXJ0KHR5cGUpIHtcbiAgICB2YXIgb3BlcmF0aW9uUXVldWUgPSB0aGlzLm9wZXJhdGlvblF1ZXVlO1xuICAgIHZhciBvcGVyYXRpb24gPSBvcGVyYXRpb25RdWV1ZS5jdXJyZW50KHR5cGUpO1xuICAgIG9wZXJhdGlvbi5vblN0YXJ0KCk7XG4gIH07XG5cbiAgX3Byb3RvLl9vblNCVXBkYXRlRW5kID0gZnVuY3Rpb24gX29uU0JVcGRhdGVFbmQodHlwZSkge1xuICAgIHZhciBvcGVyYXRpb25RdWV1ZSA9IHRoaXMub3BlcmF0aW9uUXVldWU7XG4gICAgdmFyIG9wZXJhdGlvbiA9IG9wZXJhdGlvblF1ZXVlLmN1cnJlbnQodHlwZSk7XG4gICAgb3BlcmF0aW9uLm9uQ29tcGxldGUoKTtcbiAgICBvcGVyYXRpb25RdWV1ZS5zaGlmdEFuZEV4ZWN1dGVOZXh0KHR5cGUpO1xuICB9O1xuXG4gIF9wcm90by5fb25TQlVwZGF0ZUVycm9yID0gZnVuY3Rpb24gX29uU0JVcGRhdGVFcnJvcih0eXBlLCBldmVudCkge1xuICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImxvZ2dlclwiXS5lcnJvcihcIltidWZmZXItY29udHJvbGxlcl06IFwiICsgdHlwZSArIFwiIFNvdXJjZUJ1ZmZlciBlcnJvclwiLCBldmVudCk7IC8vIGFjY29yZGluZyB0byBodHRwOi8vd3d3LnczLm9yZy9UUi9tZWRpYS1zb3VyY2UvI3NvdXJjZWJ1ZmZlci1hcHBlbmQtZXJyb3JcbiAgICAvLyBTb3VyY2VCdWZmZXIgZXJyb3JzIGFyZSBub3QgbmVjZXNzYXJpbHkgZmF0YWw7IGlmIHNvLCB0aGUgSFRNTE1lZGlhRWxlbWVudCB3aWxsIGZpcmUgYW4gZXJyb3IgZXZlbnRcblxuICAgIHRoaXMuaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXZlbnRzXCJdLkVSUk9SLCB7XG4gICAgICB0eXBlOiBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJFcnJvclR5cGVzXCJdLk1FRElBX0VSUk9SLFxuICAgICAgZGV0YWlsczogX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiRXJyb3JEZXRhaWxzXCJdLkJVRkZFUl9BUFBFTkRJTkdfRVJST1IsXG4gICAgICBmYXRhbDogZmFsc2VcbiAgICB9KTsgLy8gdXBkYXRlZW5kIGlzIGFsd2F5cyBmaXJlZCBhZnRlciBlcnJvciwgc28gd2UnbGwgYWxsb3cgdGhhdCB0byBzaGlmdCB0aGUgY3VycmVudCBvcGVyYXRpb24gb2ZmIG9mIHRoZSBxdWV1ZVxuXG4gICAgdmFyIG9wZXJhdGlvbiA9IHRoaXMub3BlcmF0aW9uUXVldWUuY3VycmVudCh0eXBlKTtcblxuICAgIGlmIChvcGVyYXRpb24pIHtcbiAgICAgIG9wZXJhdGlvbi5vbkVycm9yKGV2ZW50KTtcbiAgICB9XG4gIH0gLy8gVGhpcyBtZXRob2QgbXVzdCByZXN1bHQgaW4gYW4gdXBkYXRlZW5kIGV2ZW50OyBpZiByZW1vdmUgaXMgbm90IGNhbGxlZCwgX29uU0JVcGRhdGVFbmQgbXVzdCBiZSBjYWxsZWQgbWFudWFsbHlcbiAgO1xuXG4gIF9wcm90by5yZW1vdmVFeGVjdXRvciA9IGZ1bmN0aW9uIHJlbW92ZUV4ZWN1dG9yKHR5cGUsIHN0YXJ0T2Zmc2V0LCBlbmRPZmZzZXQpIHtcbiAgICB2YXIgbWVkaWEgPSB0aGlzLm1lZGlhLFxuICAgICAgICBtZWRpYVNvdXJjZSA9IHRoaXMubWVkaWFTb3VyY2UsXG4gICAgICAgIG9wZXJhdGlvblF1ZXVlID0gdGhpcy5vcGVyYXRpb25RdWV1ZSxcbiAgICAgICAgc291cmNlQnVmZmVyID0gdGhpcy5zb3VyY2VCdWZmZXI7XG4gICAgdmFyIHNiID0gc291cmNlQnVmZmVyW3R5cGVdO1xuXG4gICAgaWYgKCFtZWRpYSB8fCAhbWVkaWFTb3VyY2UgfHwgIXNiKSB7XG4gICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJsb2dnZXJcIl0ud2FybihcIltidWZmZXItY29udHJvbGxlcl06IEF0dGVtcHRpbmcgdG8gcmVtb3ZlIGZyb20gdGhlIFwiICsgdHlwZSArIFwiIFNvdXJjZUJ1ZmZlciwgYnV0IGl0IGRvZXMgbm90IGV4aXN0XCIpO1xuICAgICAgb3BlcmF0aW9uUXVldWUuc2hpZnRBbmRFeGVjdXRlTmV4dCh0eXBlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbWVkaWFEdXJhdGlvbiA9IE9iamVjdChfaG9tZV9ydW5uZXJfd29ya19obHNfanNfaGxzX2pzX3NyY19wb2x5ZmlsbHNfbnVtYmVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJpc0Zpbml0ZU51bWJlclwiXSkobWVkaWEuZHVyYXRpb24pID8gbWVkaWEuZHVyYXRpb24gOiBJbmZpbml0eTtcbiAgICB2YXIgbXNEdXJhdGlvbiA9IE9iamVjdChfaG9tZV9ydW5uZXJfd29ya19obHNfanNfaGxzX2pzX3NyY19wb2x5ZmlsbHNfbnVtYmVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJpc0Zpbml0ZU51bWJlclwiXSkobWVkaWFTb3VyY2UuZHVyYXRpb24pID8gbWVkaWFTb3VyY2UuZHVyYXRpb24gOiBJbmZpbml0eTtcbiAgICB2YXIgcmVtb3ZlU3RhcnQgPSBNYXRoLm1heCgwLCBzdGFydE9mZnNldCk7XG4gICAgdmFyIHJlbW92ZUVuZCA9IE1hdGgubWluKGVuZE9mZnNldCwgbWVkaWFEdXJhdGlvbiwgbXNEdXJhdGlvbik7XG5cbiAgICBpZiAocmVtb3ZlRW5kID4gcmVtb3ZlU3RhcnQpIHtcbiAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImxvZ2dlclwiXS5sb2coXCJbYnVmZmVyLWNvbnRyb2xsZXJdOiBSZW1vdmluZyBbXCIgKyByZW1vdmVTdGFydCArIFwiLFwiICsgcmVtb3ZlRW5kICsgXCJdIGZyb20gdGhlIFwiICsgdHlwZSArIFwiIFNvdXJjZUJ1ZmZlclwiKTtcbiAgICAgIGNvbnNvbGUuYXNzZXJ0KCFzYi51cGRhdGluZywgdHlwZSArIFwiIHNvdXJjZUJ1ZmZlciBtdXN0IG5vdCBiZSB1cGRhdGluZ1wiKTtcbiAgICAgIHNiLnJlbW92ZShyZW1vdmVTdGFydCwgcmVtb3ZlRW5kKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQ3ljbGUgdGhlIHF1ZXVlXG4gICAgICBvcGVyYXRpb25RdWV1ZS5zaGlmdEFuZEV4ZWN1dGVOZXh0KHR5cGUpO1xuICAgIH1cbiAgfSAvLyBUaGlzIG1ldGhvZCBtdXN0IHJlc3VsdCBpbiBhbiB1cGRhdGVlbmQgZXZlbnQ7IGlmIGFwcGVuZCBpcyBub3QgY2FsbGVkLCBfb25TQlVwZGF0ZUVuZCBtdXN0IGJlIGNhbGxlZCBtYW51YWxseVxuICA7XG5cbiAgX3Byb3RvLmFwcGVuZEV4ZWN1dG9yID0gZnVuY3Rpb24gYXBwZW5kRXhlY3V0b3IoZGF0YSwgdHlwZSkge1xuICAgIHZhciBvcGVyYXRpb25RdWV1ZSA9IHRoaXMub3BlcmF0aW9uUXVldWUsXG4gICAgICAgIHNvdXJjZUJ1ZmZlciA9IHRoaXMuc291cmNlQnVmZmVyO1xuICAgIHZhciBzYiA9IHNvdXJjZUJ1ZmZlclt0eXBlXTtcblxuICAgIGlmICghc2IpIHtcbiAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImxvZ2dlclwiXS53YXJuKFwiW2J1ZmZlci1jb250cm9sbGVyXTogQXR0ZW1wdGluZyB0byBhcHBlbmQgdG8gdGhlIFwiICsgdHlwZSArIFwiIFNvdXJjZUJ1ZmZlciwgYnV0IGl0IGRvZXMgbm90IGV4aXN0XCIpO1xuICAgICAgb3BlcmF0aW9uUXVldWUuc2hpZnRBbmRFeGVjdXRlTmV4dCh0eXBlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzYi5lbmRlZCA9IGZhbHNlO1xuICAgIGNvbnNvbGUuYXNzZXJ0KCFzYi51cGRhdGluZywgdHlwZSArIFwiIHNvdXJjZUJ1ZmZlciBtdXN0IG5vdCBiZSB1cGRhdGluZ1wiKTtcbiAgICBzYi5hcHBlbmRCdWZmZXIoZGF0YSk7XG4gIH0gLy8gRW5xdWV1ZXMgYW4gb3BlcmF0aW9uIHRvIGVhY2ggU291cmNlQnVmZmVyIHF1ZXVlIHdoaWNoLCB1cG9uIGV4ZWN1dGlvbiwgcmVzb2x2ZXMgYSBwcm9taXNlLiBXaGVuIGFsbCBwcm9taXNlc1xuICAvLyByZXNvbHZlLCB0aGUgb25VbmJsb2NrZWQgZnVuY3Rpb24gaXMgZXhlY3V0ZWQuIEZ1bmN0aW9ucyBjYWxsaW5nIHRoaXMgbWV0aG9kIGRvIG5vdCBuZWVkIHRvIHVuYmxvY2sgdGhlIHF1ZXVlXG4gIC8vIHVwb24gY29tcGxldGlvbiwgc2luY2Ugd2UgYWxyZWFkeSBkbyBpdCBoZXJlXG4gIDtcblxuICBfcHJvdG8uYmxvY2tCdWZmZXJzID0gZnVuY3Rpb24gYmxvY2tCdWZmZXJzKG9uVW5ibG9ja2VkLCBidWZmZXJzKSB7XG4gICAgdmFyIF90aGlzOSA9IHRoaXM7XG5cbiAgICBpZiAoYnVmZmVycyA9PT0gdm9pZCAwKSB7XG4gICAgICBidWZmZXJzID0gdGhpcy5nZXRTb3VyY2VCdWZmZXJUeXBlcygpO1xuICAgIH1cblxuICAgIGlmICghYnVmZmVycy5sZW5ndGgpIHtcbiAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImxvZ2dlclwiXS5sb2coJ1tidWZmZXItY29udHJvbGxlcl06IEJsb2NraW5nIG9wZXJhdGlvbiByZXF1ZXN0ZWQsIGJ1dCBubyBTb3VyY2VCdWZmZXJzIGV4aXN0Jyk7XG4gICAgICBQcm9taXNlLnJlc29sdmUob25VbmJsb2NrZWQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBvcGVyYXRpb25RdWV1ZSA9IHRoaXMub3BlcmF0aW9uUXVldWU7IC8vIGxvZ2dlci5kZWJ1ZyhgW2J1ZmZlci1jb250cm9sbGVyXTogQmxvY2tpbmcgJHtidWZmZXJzfSBTb3VyY2VCdWZmZXJgKTtcblxuICAgIHZhciBibG9ja2luZ09wZXJhdGlvbnMgPSBidWZmZXJzLm1hcChmdW5jdGlvbiAodHlwZSkge1xuICAgICAgcmV0dXJuIG9wZXJhdGlvblF1ZXVlLmFwcGVuZEJsb2NrZXIodHlwZSk7XG4gICAgfSk7XG4gICAgUHJvbWlzZS5hbGwoYmxvY2tpbmdPcGVyYXRpb25zKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIGxvZ2dlci5kZWJ1ZyhgW2J1ZmZlci1jb250cm9sbGVyXTogQmxvY2tpbmcgb3BlcmF0aW9uIHJlc29sdmVkOyB1bmJsb2NraW5nICR7YnVmZmVyc30gU291cmNlQnVmZmVyYCk7XG4gICAgICBvblVuYmxvY2tlZCgpO1xuICAgICAgYnVmZmVycy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIHZhciBzYiA9IF90aGlzOS5zb3VyY2VCdWZmZXJbdHlwZV07IC8vIE9ubHkgY3ljbGUgdGhlIHF1ZXVlIGlmIHRoZSBTQiBpcyBub3QgdXBkYXRpbmcuIFRoZXJlJ3MgYSBidWcgaW4gQ2hyb21lIHdoaWNoIHNldHMgdGhlIFNCIHVwZGF0aW5nIGZsYWcgdG9cbiAgICAgICAgLy8gdHJ1ZSB3aGVuIGNoYW5naW5nIHRoZSBNZWRpYVNvdXJjZSBkdXJhdGlvbiAoaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9OTU5MzU5JmNhbj0yJnE9bWVkaWFzb3VyY2UlMjBkdXJhdGlvbilcbiAgICAgICAgLy8gV2hpbGUgdGhpcyBpcyBhIHdvcmthcm91bmQsIGl0J3MgcHJvYmFibHkgdXNlZnVsIHRvIGhhdmUgYXJvdW5kXG5cbiAgICAgICAgaWYgKCFzYiB8fCAhc2IudXBkYXRpbmcpIHtcbiAgICAgICAgICBvcGVyYXRpb25RdWV1ZS5zaGlmdEFuZEV4ZWN1dGVOZXh0KHR5cGUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG8uZ2V0U291cmNlQnVmZmVyVHlwZXMgPSBmdW5jdGlvbiBnZXRTb3VyY2VCdWZmZXJUeXBlcygpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5zb3VyY2VCdWZmZXIpO1xuICB9O1xuXG4gIF9wcm90by5hZGRCdWZmZXJMaXN0ZW5lciA9IGZ1bmN0aW9uIGFkZEJ1ZmZlckxpc3RlbmVyKHR5cGUsIGV2ZW50LCBmbikge1xuICAgIHZhciBidWZmZXIgPSB0aGlzLnNvdXJjZUJ1ZmZlclt0eXBlXTtcblxuICAgIGlmICghYnVmZmVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGxpc3RlbmVyID0gZm4uYmluZCh0aGlzLCB0eXBlKTtcbiAgICB0aGlzLmxpc3RlbmVyc1t0eXBlXS5wdXNoKHtcbiAgICAgIGV2ZW50OiBldmVudCxcbiAgICAgIGxpc3RlbmVyOiBsaXN0ZW5lclxuICAgIH0pO1xuICAgIGJ1ZmZlci5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcik7XG4gIH07XG5cbiAgX3Byb3RvLnJlbW92ZUJ1ZmZlckxpc3RlbmVycyA9IGZ1bmN0aW9uIHJlbW92ZUJ1ZmZlckxpc3RlbmVycyh0eXBlKSB7XG4gICAgdmFyIGJ1ZmZlciA9IHRoaXMuc291cmNlQnVmZmVyW3R5cGVdO1xuXG4gICAgaWYgKCFidWZmZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmxpc3RlbmVyc1t0eXBlXS5mb3JFYWNoKGZ1bmN0aW9uIChsKSB7XG4gICAgICBidWZmZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihsLmV2ZW50LCBsLmxpc3RlbmVyKTtcbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gQnVmZmVyQ29udHJvbGxlcjtcbn0oKTtcblxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NvbnRyb2xsZXIvYnVmZmVyLW9wZXJhdGlvbi1xdWV1ZS50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvY29udHJvbGxlci9idWZmZXItb3BlcmF0aW9uLXF1ZXVlLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImRlZmF1bHRcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBCdWZmZXJPcGVyYXRpb25RdWV1ZTsgfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvbG9nZ2VyICovIFwiLi9zcmMvdXRpbHMvbG9nZ2VyLnRzXCIpO1xuXG5cbnZhciBCdWZmZXJPcGVyYXRpb25RdWV1ZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEJ1ZmZlck9wZXJhdGlvblF1ZXVlKHNvdXJjZUJ1ZmZlclJlZmVyZW5jZSkge1xuICAgIHRoaXMuYnVmZmVycyA9IHZvaWQgMDtcbiAgICB0aGlzLnF1ZXVlcyA9IHtcbiAgICAgIHZpZGVvOiBbXSxcbiAgICAgIGF1ZGlvOiBbXSxcbiAgICAgIGF1ZGlvdmlkZW86IFtdXG4gICAgfTtcbiAgICB0aGlzLmJ1ZmZlcnMgPSBzb3VyY2VCdWZmZXJSZWZlcmVuY2U7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gQnVmZmVyT3BlcmF0aW9uUXVldWUucHJvdG90eXBlO1xuXG4gIF9wcm90by5hcHBlbmQgPSBmdW5jdGlvbiBhcHBlbmQob3BlcmF0aW9uLCB0eXBlKSB7XG4gICAgdmFyIHF1ZXVlID0gdGhpcy5xdWV1ZXNbdHlwZV07XG4gICAgcXVldWUucHVzaChvcGVyYXRpb24pO1xuXG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiB0aGlzLmJ1ZmZlcnNbdHlwZV0pIHtcbiAgICAgIHRoaXMuZXhlY3V0ZU5leHQodHlwZSk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5pbnNlcnRBYm9ydCA9IGZ1bmN0aW9uIGluc2VydEFib3J0KG9wZXJhdGlvbiwgdHlwZSkge1xuICAgIHZhciBxdWV1ZSA9IHRoaXMucXVldWVzW3R5cGVdO1xuICAgIHF1ZXVlLnVuc2hpZnQob3BlcmF0aW9uKTtcbiAgICB0aGlzLmV4ZWN1dGVOZXh0KHR5cGUpO1xuICB9O1xuXG4gIF9wcm90by5hcHBlbmRCbG9ja2VyID0gZnVuY3Rpb24gYXBwZW5kQmxvY2tlcih0eXBlKSB7XG4gICAgdmFyIGV4ZWN1dGU7XG4gICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgZXhlY3V0ZSA9IHJlc29sdmU7XG4gICAgfSk7XG4gICAgdmFyIG9wZXJhdGlvbiA9IHtcbiAgICAgIGV4ZWN1dGU6IGV4ZWN1dGUsXG4gICAgICBvblN0YXJ0OiBmdW5jdGlvbiBvblN0YXJ0KCkge30sXG4gICAgICBvbkNvbXBsZXRlOiBmdW5jdGlvbiBvbkNvbXBsZXRlKCkge30sXG4gICAgICBvbkVycm9yOiBmdW5jdGlvbiBvbkVycm9yKCkge31cbiAgICB9O1xuICAgIHRoaXMuYXBwZW5kKG9wZXJhdGlvbiwgdHlwZSk7XG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH07XG5cbiAgX3Byb3RvLmV4ZWN1dGVOZXh0ID0gZnVuY3Rpb24gZXhlY3V0ZU5leHQodHlwZSkge1xuICAgIHZhciBidWZmZXJzID0gdGhpcy5idWZmZXJzLFxuICAgICAgICBxdWV1ZXMgPSB0aGlzLnF1ZXVlcztcbiAgICB2YXIgc2IgPSBidWZmZXJzW3R5cGVdO1xuICAgIHZhciBxdWV1ZSA9IHF1ZXVlc1t0eXBlXTtcblxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgIHZhciBvcGVyYXRpb24gPSBxdWV1ZVswXTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gT3BlcmF0aW9ucyBhcmUgZXhwZWN0ZWQgdG8gcmVzdWx0IGluIGFuICd1cGRhdGVlbmQnIGV2ZW50IGJlaW5nIGZpcmVkLiBJZiBub3QsIHRoZSBxdWV1ZSB3aWxsIGxvY2suIE9wZXJhdGlvbnNcbiAgICAgICAgLy8gd2hpY2ggZG8gbm90IGVuZCB3aXRoIHRoaXMgZXZlbnQgbXVzdCBjYWxsIF9vblNCVXBkYXRlRW5kIG1hbnVhbGx5XG4gICAgICAgIG9wZXJhdGlvbi5leGVjdXRlKCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImxvZ2dlclwiXS53YXJuKCdbYnVmZmVyLW9wZXJhdGlvbi1xdWV1ZV06IFVuaGFuZGxlZCBleGNlcHRpb24gZXhlY3V0aW5nIHRoZSBjdXJyZW50IG9wZXJhdGlvbicpO1xuICAgICAgICBvcGVyYXRpb24ub25FcnJvcihlKTsgLy8gT25seSBzaGlmdCB0aGUgY3VycmVudCBvcGVyYXRpb24gb2ZmLCBvdGhlcndpc2UgdGhlIHVwZGF0ZWVuZCBoYW5kbGVyIHdpbGwgZG8gdGhpcyBmb3IgdXNcblxuICAgICAgICBpZiAoIXNiIHx8ICFzYi51cGRhdGluZykge1xuICAgICAgICAgIHF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgICAgdGhpcy5leGVjdXRlTmV4dCh0eXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uc2hpZnRBbmRFeGVjdXRlTmV4dCA9IGZ1bmN0aW9uIHNoaWZ0QW5kRXhlY3V0ZU5leHQodHlwZSkge1xuICAgIHRoaXMucXVldWVzW3R5cGVdLnNoaWZ0KCk7XG4gICAgdGhpcy5leGVjdXRlTmV4dCh0eXBlKTtcbiAgfTtcblxuICBfcHJvdG8uY3VycmVudCA9IGZ1bmN0aW9uIGN1cnJlbnQodHlwZSkge1xuICAgIHJldHVybiB0aGlzLnF1ZXVlc1t0eXBlXVswXTtcbiAgfTtcblxuICByZXR1cm4gQnVmZmVyT3BlcmF0aW9uUXVldWU7XG59KCk7XG5cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9jb250cm9sbGVyL2NhcC1sZXZlbC1jb250cm9sbGVyLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvY29udHJvbGxlci9jYXAtbGV2ZWwtY29udHJvbGxlci50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZXZlbnRzICovIFwiLi9zcmMvZXZlbnRzLnRzXCIpO1xuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG4vKlxuICogY2FwIHN0cmVhbSBsZXZlbCB0byBtZWRpYSBzaXplIGRpbWVuc2lvbiBjb250cm9sbGVyXG4gKi9cblxuXG52YXIgQ2FwTGV2ZWxDb250cm9sbGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQ2FwTGV2ZWxDb250cm9sbGVyKGhscykge1xuICAgIHRoaXMuYXV0b0xldmVsQ2FwcGluZyA9IHZvaWQgMDtcbiAgICB0aGlzLmZpcnN0TGV2ZWwgPSB2b2lkIDA7XG4gICAgdGhpcy5tZWRpYSA9IHZvaWQgMDtcbiAgICB0aGlzLnJlc3RyaWN0ZWRMZXZlbHMgPSB2b2lkIDA7XG4gICAgdGhpcy50aW1lciA9IHZvaWQgMDtcbiAgICB0aGlzLmhscyA9IHZvaWQgMDtcbiAgICB0aGlzLnN0cmVhbUNvbnRyb2xsZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5jbGllbnRSZWN0ID0gdm9pZCAwO1xuICAgIHRoaXMuaGxzID0gaGxzO1xuICAgIHRoaXMuYXV0b0xldmVsQ2FwcGluZyA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICB0aGlzLmZpcnN0TGV2ZWwgPSAtMTtcbiAgICB0aGlzLm1lZGlhID0gbnVsbDtcbiAgICB0aGlzLnJlc3RyaWN0ZWRMZXZlbHMgPSBbXTtcbiAgICB0aGlzLnRpbWVyID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuY2xpZW50UmVjdCA9IG51bGw7XG4gICAgdGhpcy5yZWdpc3Rlckxpc3RlbmVycygpO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IENhcExldmVsQ29udHJvbGxlci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLnNldFN0cmVhbUNvbnRyb2xsZXIgPSBmdW5jdGlvbiBzZXRTdHJlYW1Db250cm9sbGVyKHN0cmVhbUNvbnRyb2xsZXIpIHtcbiAgICB0aGlzLnN0cmVhbUNvbnRyb2xsZXIgPSBzdHJlYW1Db250cm9sbGVyO1xuICB9O1xuXG4gIF9wcm90by5kZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICB0aGlzLnVucmVnaXN0ZXJMaXN0ZW5lcigpO1xuXG4gICAgaWYgKHRoaXMuaGxzLmNvbmZpZy5jYXBMZXZlbFRvUGxheWVyU2l6ZSkge1xuICAgICAgdGhpcy5zdG9wQ2FwcGluZygpO1xuICAgIH1cblxuICAgIHRoaXMubWVkaWEgPSBudWxsO1xuICAgIHRoaXMuY2xpZW50UmVjdCA9IG51bGw7IC8vIEB0cy1pZ25vcmVcblxuICAgIHRoaXMuaGxzID0gdGhpcy5zdHJlYW1Db250cm9sbGVyID0gbnVsbDtcbiAgfTtcblxuICBfcHJvdG8ucmVnaXN0ZXJMaXN0ZW5lcnMgPSBmdW5jdGlvbiByZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICB2YXIgaGxzID0gdGhpcy5obHM7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIkV2ZW50c1wiXS5GUFNfRFJPUF9MRVZFTF9DQVBQSU5HLCB0aGlzLm9uRnBzRHJvcExldmVsQ2FwcGluZywgdGhpcyk7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIkV2ZW50c1wiXS5NRURJQV9BVFRBQ0hJTkcsIHRoaXMub25NZWRpYUF0dGFjaGluZywgdGhpcyk7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIkV2ZW50c1wiXS5NQU5JRkVTVF9QQVJTRUQsIHRoaXMub25NYW5pZmVzdFBhcnNlZCwgdGhpcyk7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIkV2ZW50c1wiXS5CVUZGRVJfQ09ERUNTLCB0aGlzLm9uQnVmZmVyQ29kZWNzLCB0aGlzKTtcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiRXZlbnRzXCJdLk1FRElBX0RFVEFDSElORywgdGhpcy5vbk1lZGlhRGV0YWNoaW5nLCB0aGlzKTtcbiAgfTtcblxuICBfcHJvdG8udW5yZWdpc3Rlckxpc3RlbmVyID0gZnVuY3Rpb24gdW5yZWdpc3Rlckxpc3RlbmVyKCkge1xuICAgIHZhciBobHMgPSB0aGlzLmhscztcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIkV2ZW50c1wiXS5GUFNfRFJPUF9MRVZFTF9DQVBQSU5HLCB0aGlzLm9uRnBzRHJvcExldmVsQ2FwcGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJFdmVudHNcIl0uTUVESUFfQVRUQUNISU5HLCB0aGlzLm9uTWVkaWFBdHRhY2hpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiRXZlbnRzXCJdLk1BTklGRVNUX1BBUlNFRCwgdGhpcy5vbk1hbmlmZXN0UGFyc2VkLCB0aGlzKTtcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIkV2ZW50c1wiXS5CVUZGRVJfQ09ERUNTLCB0aGlzLm9uQnVmZmVyQ29kZWNzLCB0aGlzKTtcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIkV2ZW50c1wiXS5NRURJQV9ERVRBQ0hJTkcsIHRoaXMub25NZWRpYURldGFjaGluZywgdGhpcyk7XG4gIH07XG5cbiAgX3Byb3RvLm9uRnBzRHJvcExldmVsQ2FwcGluZyA9IGZ1bmN0aW9uIG9uRnBzRHJvcExldmVsQ2FwcGluZyhldmVudCwgZGF0YSkge1xuICAgIC8vIERvbid0IGFkZCBhIHJlc3RyaWN0ZWQgbGV2ZWwgbW9yZSB0aGFuIG9uY2VcbiAgICBpZiAoQ2FwTGV2ZWxDb250cm9sbGVyLmlzTGV2ZWxBbGxvd2VkKGRhdGEuZHJvcHBlZExldmVsLCB0aGlzLnJlc3RyaWN0ZWRMZXZlbHMpKSB7XG4gICAgICB0aGlzLnJlc3RyaWN0ZWRMZXZlbHMucHVzaChkYXRhLmRyb3BwZWRMZXZlbCk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5vbk1lZGlhQXR0YWNoaW5nID0gZnVuY3Rpb24gb25NZWRpYUF0dGFjaGluZyhldmVudCwgZGF0YSkge1xuICAgIHRoaXMubWVkaWEgPSBkYXRhLm1lZGlhIGluc3RhbmNlb2YgSFRNTFZpZGVvRWxlbWVudCA/IGRhdGEubWVkaWEgOiBudWxsO1xuICB9O1xuXG4gIF9wcm90by5vbk1hbmlmZXN0UGFyc2VkID0gZnVuY3Rpb24gb25NYW5pZmVzdFBhcnNlZChldmVudCwgZGF0YSkge1xuICAgIHZhciBobHMgPSB0aGlzLmhscztcbiAgICB0aGlzLnJlc3RyaWN0ZWRMZXZlbHMgPSBbXTtcbiAgICB0aGlzLmZpcnN0TGV2ZWwgPSBkYXRhLmZpcnN0TGV2ZWw7XG5cbiAgICBpZiAoaGxzLmNvbmZpZy5jYXBMZXZlbFRvUGxheWVyU2l6ZSAmJiBkYXRhLnZpZGVvKSB7XG4gICAgICAvLyBTdGFydCBjYXBwaW5nIGltbWVkaWF0ZWx5IGlmIHRoZSBtYW5pZmVzdCBoYXMgc2lnbmFsZWQgdmlkZW8gY29kZWNzXG4gICAgICB0aGlzLnN0YXJ0Q2FwcGluZygpO1xuICAgIH1cbiAgfSAvLyBPbmx5IGFjdGl2YXRlIGNhcHBpbmcgd2hlbiBwbGF5aW5nIGEgdmlkZW8gc3RyZWFtOyBvdGhlcndpc2UsIG11bHRpLWJpdHJhdGUgYXVkaW8tb25seSBzdHJlYW1zIHdpbGwgYmUgcmVzdHJpY3RlZFxuICAvLyB0byB0aGUgZmlyc3QgbGV2ZWxcbiAgO1xuXG4gIF9wcm90by5vbkJ1ZmZlckNvZGVjcyA9IGZ1bmN0aW9uIG9uQnVmZmVyQ29kZWNzKGV2ZW50LCBkYXRhKSB7XG4gICAgdmFyIGhscyA9IHRoaXMuaGxzO1xuXG4gICAgaWYgKGhscy5jb25maWcuY2FwTGV2ZWxUb1BsYXllclNpemUgJiYgZGF0YS52aWRlbykge1xuICAgICAgLy8gSWYgdGhlIG1hbmlmZXN0IGRpZCBub3Qgc2lnbmFsIGEgdmlkZW8gY29kZWMgY2FwcGluZyBoYXMgYmVlbiBkZWZlcnJlZCB1bnRpbCB3ZSdyZSBjZXJ0YWluIHZpZGVvIGlzIHByZXNlbnRcbiAgICAgIHRoaXMuc3RhcnRDYXBwaW5nKCk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5vbk1lZGlhRGV0YWNoaW5nID0gZnVuY3Rpb24gb25NZWRpYURldGFjaGluZygpIHtcbiAgICB0aGlzLnN0b3BDYXBwaW5nKCk7XG4gIH07XG5cbiAgX3Byb3RvLmRldGVjdFBsYXllclNpemUgPSBmdW5jdGlvbiBkZXRlY3RQbGF5ZXJTaXplKCkge1xuICAgIGlmICh0aGlzLm1lZGlhICYmIHRoaXMubWVkaWFIZWlnaHQgPiAwICYmIHRoaXMubWVkaWFXaWR0aCA+IDApIHtcbiAgICAgIHZhciBsZXZlbHMgPSB0aGlzLmhscy5sZXZlbHM7XG5cbiAgICAgIGlmIChsZXZlbHMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBobHMgPSB0aGlzLmhscztcbiAgICAgICAgaGxzLmF1dG9MZXZlbENhcHBpbmcgPSB0aGlzLmdldE1heExldmVsKGxldmVscy5sZW5ndGggLSAxKTtcblxuICAgICAgICBpZiAoaGxzLmF1dG9MZXZlbENhcHBpbmcgPiB0aGlzLmF1dG9MZXZlbENhcHBpbmcgJiYgdGhpcy5zdHJlYW1Db250cm9sbGVyKSB7XG4gICAgICAgICAgLy8gaWYgYXV0byBsZXZlbCBjYXBwaW5nIGhhcyBhIGhpZ2hlciB2YWx1ZSBmb3IgdGhlIHByZXZpb3VzIG9uZSwgZmx1c2ggdGhlIGJ1ZmZlciB1c2luZyBuZXh0TGV2ZWxTd2l0Y2hcbiAgICAgICAgICAvLyB1c3VhbGx5IGhhcHBlbiB3aGVuIHRoZSB1c2VyIGdvIHRvIHRoZSBmdWxsc2NyZWVuIG1vZGUuXG4gICAgICAgICAgdGhpcy5zdHJlYW1Db250cm9sbGVyLm5leHRMZXZlbFN3aXRjaCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5hdXRvTGV2ZWxDYXBwaW5nID0gaGxzLmF1dG9MZXZlbENhcHBpbmc7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qXG4gICAqIHJldHVybnMgbGV2ZWwgc2hvdWxkIGJlIHRoZSBvbmUgd2l0aCB0aGUgZGltZW5zaW9ucyBlcXVhbCBvciBncmVhdGVyIHRoYW4gdGhlIG1lZGlhIChwbGF5ZXIpIGRpbWVuc2lvbnMgKHNvIHRoZSB2aWRlbyB3aWxsIGJlIGRvd25zY2FsZWQpXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmdldE1heExldmVsID0gZnVuY3Rpb24gZ2V0TWF4TGV2ZWwoY2FwTGV2ZWxJbmRleCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgbGV2ZWxzID0gdGhpcy5obHMubGV2ZWxzO1xuXG4gICAgaWYgKCFsZXZlbHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgdmFyIHZhbGlkTGV2ZWxzID0gbGV2ZWxzLmZpbHRlcihmdW5jdGlvbiAobGV2ZWwsIGluZGV4KSB7XG4gICAgICByZXR1cm4gQ2FwTGV2ZWxDb250cm9sbGVyLmlzTGV2ZWxBbGxvd2VkKGluZGV4LCBfdGhpcy5yZXN0cmljdGVkTGV2ZWxzKSAmJiBpbmRleCA8PSBjYXBMZXZlbEluZGV4O1xuICAgIH0pO1xuICAgIHRoaXMuY2xpZW50UmVjdCA9IG51bGw7XG4gICAgcmV0dXJuIENhcExldmVsQ29udHJvbGxlci5nZXRNYXhMZXZlbEJ5TWVkaWFTaXplKHZhbGlkTGV2ZWxzLCB0aGlzLm1lZGlhV2lkdGgsIHRoaXMubWVkaWFIZWlnaHQpO1xuICB9O1xuXG4gIF9wcm90by5zdGFydENhcHBpbmcgPSBmdW5jdGlvbiBzdGFydENhcHBpbmcoKSB7XG4gICAgaWYgKHRoaXMudGltZXIpIHtcbiAgICAgIC8vIERvbid0IHJlc2V0IGNhcHBpbmcgaWYgc3RhcnRlZCB0d2ljZTsgdGhpcyBjYW4gaGFwcGVuIGlmIHRoZSBtYW5pZmVzdCBzaWduYWxzIGEgdmlkZW8gY29kZWNcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmF1dG9MZXZlbENhcHBpbmcgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgdGhpcy5obHMuZmlyc3RMZXZlbCA9IHRoaXMuZ2V0TWF4TGV2ZWwodGhpcy5maXJzdExldmVsKTtcbiAgICBzZWxmLmNsZWFySW50ZXJ2YWwodGhpcy50aW1lcik7XG4gICAgdGhpcy50aW1lciA9IHNlbGYuc2V0SW50ZXJ2YWwodGhpcy5kZXRlY3RQbGF5ZXJTaXplLmJpbmQodGhpcyksIDEwMDApO1xuICAgIHRoaXMuZGV0ZWN0UGxheWVyU2l6ZSgpO1xuICB9O1xuXG4gIF9wcm90by5zdG9wQ2FwcGluZyA9IGZ1bmN0aW9uIHN0b3BDYXBwaW5nKCkge1xuICAgIHRoaXMucmVzdHJpY3RlZExldmVscyA9IFtdO1xuICAgIHRoaXMuZmlyc3RMZXZlbCA9IC0xO1xuICAgIHRoaXMuYXV0b0xldmVsQ2FwcGluZyA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcblxuICAgIGlmICh0aGlzLnRpbWVyKSB7XG4gICAgICBzZWxmLmNsZWFySW50ZXJ2YWwodGhpcy50aW1lcik7XG4gICAgICB0aGlzLnRpbWVyID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uZ2V0RGltZW5zaW9ucyA9IGZ1bmN0aW9uIGdldERpbWVuc2lvbnMoKSB7XG4gICAgaWYgKHRoaXMuY2xpZW50UmVjdCkge1xuICAgICAgcmV0dXJuIHRoaXMuY2xpZW50UmVjdDtcbiAgICB9XG5cbiAgICB2YXIgbWVkaWEgPSB0aGlzLm1lZGlhO1xuICAgIHZhciBib3VuZHNSZWN0ID0ge1xuICAgICAgd2lkdGg6IDAsXG4gICAgICBoZWlnaHQ6IDBcbiAgICB9O1xuXG4gICAgaWYgKG1lZGlhKSB7XG4gICAgICB2YXIgY2xpZW50UmVjdCA9IG1lZGlhLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgYm91bmRzUmVjdC53aWR0aCA9IGNsaWVudFJlY3Qud2lkdGg7XG4gICAgICBib3VuZHNSZWN0LmhlaWdodCA9IGNsaWVudFJlY3QuaGVpZ2h0O1xuXG4gICAgICBpZiAoIWJvdW5kc1JlY3Qud2lkdGggJiYgIWJvdW5kc1JlY3QuaGVpZ2h0KSB7XG4gICAgICAgIC8vIFdoZW4gdGhlIG1lZGlhIGVsZW1lbnQgaGFzIG5vIHdpZHRoIG9yIGhlaWdodCAoZXF1aXZhbGVudCB0byBub3QgYmVpbmcgaW4gdGhlIERPTSksXG4gICAgICAgIC8vIHRoZW4gdXNlIGl0cyB3aWR0aCBhbmQgaGVpZ2h0IGF0dHJpYnV0ZXMgKG1lZGlhLndpZHRoLCBtZWRpYS5oZWlnaHQpXG4gICAgICAgIGJvdW5kc1JlY3Qud2lkdGggPSBjbGllbnRSZWN0LnJpZ2h0IC0gY2xpZW50UmVjdC5sZWZ0IHx8IG1lZGlhLndpZHRoIHx8IDA7XG4gICAgICAgIGJvdW5kc1JlY3QuaGVpZ2h0ID0gY2xpZW50UmVjdC5ib3R0b20gLSBjbGllbnRSZWN0LnRvcCB8fCBtZWRpYS5oZWlnaHQgfHwgMDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmNsaWVudFJlY3QgPSBib3VuZHNSZWN0O1xuICAgIHJldHVybiBib3VuZHNSZWN0O1xuICB9O1xuXG4gIENhcExldmVsQ29udHJvbGxlci5pc0xldmVsQWxsb3dlZCA9IGZ1bmN0aW9uIGlzTGV2ZWxBbGxvd2VkKGxldmVsLCByZXN0cmljdGVkTGV2ZWxzKSB7XG4gICAgaWYgKHJlc3RyaWN0ZWRMZXZlbHMgPT09IHZvaWQgMCkge1xuICAgICAgcmVzdHJpY3RlZExldmVscyA9IFtdO1xuICAgIH1cblxuICAgIHJldHVybiByZXN0cmljdGVkTGV2ZWxzLmluZGV4T2YobGV2ZWwpID09PSAtMTtcbiAgfTtcblxuICBDYXBMZXZlbENvbnRyb2xsZXIuZ2V0TWF4TGV2ZWxCeU1lZGlhU2l6ZSA9IGZ1bmN0aW9uIGdldE1heExldmVsQnlNZWRpYVNpemUobGV2ZWxzLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgaWYgKCFsZXZlbHMgfHwgIWxldmVscy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9IC8vIExldmVscyBjYW4gaGF2ZSB0aGUgc2FtZSBkaW1lbnNpb25zIGJ1dCBkaWZmZXJpbmcgYmFuZHdpZHRocyAtIHNpbmNlIGxldmVscyBhcmUgb3JkZXJlZCwgd2UgY2FuIGxvb2sgdG8gdGhlIG5leHRcbiAgICAvLyB0byBkZXRlcm1pbmUgd2hldGhlciB3ZSd2ZSBjaG9zZW4gdGhlIGdyZWF0ZXN0IGJhbmR3aWR0aCBmb3IgdGhlIG1lZGlhJ3MgZGltZW5zaW9uc1xuXG5cbiAgICB2YXIgYXRHcmVhdGVzdEJhbmRpd2R0aCA9IGZ1bmN0aW9uIGF0R3JlYXRlc3RCYW5kaXdkdGgoY3VyTGV2ZWwsIG5leHRMZXZlbCkge1xuICAgICAgaWYgKCFuZXh0TGV2ZWwpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjdXJMZXZlbC53aWR0aCAhPT0gbmV4dExldmVsLndpZHRoIHx8IGN1ckxldmVsLmhlaWdodCAhPT0gbmV4dExldmVsLmhlaWdodDtcbiAgICB9OyAvLyBJZiB3ZSBydW4gdGhyb3VnaCB0aGUgbG9vcCB3aXRob3V0IGJyZWFraW5nLCB0aGUgbWVkaWEncyBkaW1lbnNpb25zIGFyZSBncmVhdGVyIHRoYW4gZXZlcnkgbGV2ZWwsIHNvIGRlZmF1bHQgdG9cbiAgICAvLyB0aGUgbWF4IGxldmVsXG5cblxuICAgIHZhciBtYXhMZXZlbEluZGV4ID0gbGV2ZWxzLmxlbmd0aCAtIDE7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxldmVscy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgdmFyIGxldmVsID0gbGV2ZWxzW2ldO1xuXG4gICAgICBpZiAoKGxldmVsLndpZHRoID49IHdpZHRoIHx8IGxldmVsLmhlaWdodCA+PSBoZWlnaHQpICYmIGF0R3JlYXRlc3RCYW5kaXdkdGgobGV2ZWwsIGxldmVsc1tpICsgMV0pKSB7XG4gICAgICAgIG1heExldmVsSW5kZXggPSBpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbWF4TGV2ZWxJbmRleDtcbiAgfTtcblxuICBfY3JlYXRlQ2xhc3MoQ2FwTGV2ZWxDb250cm9sbGVyLCBbe1xuICAgIGtleTogXCJtZWRpYVdpZHRoXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXREaW1lbnNpb25zKCkud2lkdGggKiBDYXBMZXZlbENvbnRyb2xsZXIuY29udGVudFNjYWxlRmFjdG9yO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtZWRpYUhlaWdodFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0RGltZW5zaW9ucygpLmhlaWdodCAqIENhcExldmVsQ29udHJvbGxlci5jb250ZW50U2NhbGVGYWN0b3I7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwiY29udGVudFNjYWxlRmFjdG9yXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgcGl4ZWxSYXRpbyA9IDE7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHBpeGVsUmF0aW8gPSBzZWxmLmRldmljZVBpeGVsUmF0aW87XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8qIG5vLW9wICovXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwaXhlbFJhdGlvO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBDYXBMZXZlbENvbnRyb2xsZXI7XG59KCk7XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoQ2FwTGV2ZWxDb250cm9sbGVyKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY29udHJvbGxlci9jbWNkLWNvbnRyb2xsZXIudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvY29udHJvbGxlci9jbWNkLWNvbnRyb2xsZXIudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJkZWZhdWx0XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gQ01DRENvbnRyb2xsZXI7IH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2V2ZW50cyAqLyBcIi4vc3JjL2V2ZW50cy50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdHlwZXNfY21jZF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdHlwZXMvY21jZCAqLyBcIi4vc3JjL3R5cGVzL2NtY2QudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2J1ZmZlcl9oZWxwZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL2J1ZmZlci1oZWxwZXIgKi8gXCIuL3NyYy91dGlscy9idWZmZXItaGVscGVyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL2xvZ2dlciAqLyBcIi4vc3JjL3V0aWxzL2xvZ2dlci50c1wiKTtcbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXJMb29zZShvLCBhbGxvd0FycmF5TGlrZSkgeyB2YXIgaXQgPSB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSB8fCBvW1wiQEBpdGVyYXRvclwiXTsgaWYgKGl0KSByZXR1cm4gKGl0ID0gaXQuY2FsbChvKSkubmV4dC5iaW5kKGl0KTsgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKGl0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgeyBpZiAoaXQpIG8gPSBpdDsgdmFyIGkgPSAwOyByZXR1cm4gZnVuY3Rpb24gKCkgeyBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9OyByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IG9baSsrXSB9OyB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9XG5cbmZ1bmN0aW9uIF9leHRlbmRzKCkgeyBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07IHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9XG5cblxuXG5cblxuLyoqXG4gKiBDb250cm9sbGVyIHRvIGRlYWwgd2l0aCBDb21tb24gTWVkaWEgQ2xpZW50IERhdGEgKENNQ0QpXG4gKiBAc2VlIGh0dHBzOi8vY2RuLmN0YS50ZWNoL2N0YS9tZWRpYS9tZWRpYS9yZXNvdXJjZXMvc3RhbmRhcmRzL3BkZnMvY3RhLTUwMDQtZmluYWwucGRmXG4gKi9cblxudmFyIENNQ0RDb250cm9sbGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1yZXN0cmljdGVkLWdsb2JhbHNcbiAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1yZXN0cmljdGVkLWdsb2JhbHNcbiAgZnVuY3Rpb24gQ01DRENvbnRyb2xsZXIoaGxzKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHRoaXMuaGxzID0gdm9pZCAwO1xuICAgIHRoaXMuY29uZmlnID0gdm9pZCAwO1xuICAgIHRoaXMubWVkaWEgPSB2b2lkIDA7XG4gICAgdGhpcy5zaWQgPSB2b2lkIDA7XG4gICAgdGhpcy5jaWQgPSB2b2lkIDA7XG4gICAgdGhpcy51c2VIZWFkZXJzID0gZmFsc2U7XG4gICAgdGhpcy5pbml0aWFsaXplZCA9IGZhbHNlO1xuICAgIHRoaXMuc3RhcnZlZCA9IGZhbHNlO1xuICAgIHRoaXMuYnVmZmVyaW5nID0gdHJ1ZTtcbiAgICB0aGlzLmF1ZGlvQnVmZmVyID0gdm9pZCAwO1xuICAgIHRoaXMudmlkZW9CdWZmZXIgPSB2b2lkIDA7XG5cbiAgICB0aGlzLm9uV2FpdGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChfdGhpcy5pbml0aWFsaXplZCkge1xuICAgICAgICBfdGhpcy5zdGFydmVkID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgX3RoaXMuYnVmZmVyaW5nID0gdHJ1ZTtcbiAgICB9O1xuXG4gICAgdGhpcy5vblBsYXlpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIV90aGlzLmluaXRpYWxpemVkKSB7XG4gICAgICAgIF90aGlzLmluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgX3RoaXMuYnVmZmVyaW5nID0gZmFsc2U7XG4gICAgfTtcblxuICAgIHRoaXMuYXBwbHlQbGF5bGlzdERhdGEgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgX3RoaXMuYXBwbHkoY29udGV4dCwge1xuICAgICAgICAgIG90OiBfdHlwZXNfY21jZF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiQ01DRE9iamVjdFR5cGVcIl0uTUFOSUZFU1QsXG4gICAgICAgICAgc3U6ICFfdGhpcy5pbml0aWFsaXplZFxuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcImxvZ2dlclwiXS53YXJuKCdDb3VsZCBub3QgZ2VuZXJhdGUgbWFuaWZlc3QgQ01DRCBkYXRhLicsIGVycm9yKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5hcHBseUZyYWdtZW50RGF0YSA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgZnJhZ21lbnQgPSBjb250ZXh0LmZyYWc7XG4gICAgICAgIHZhciBsZXZlbCA9IF90aGlzLmhscy5sZXZlbHNbZnJhZ21lbnQubGV2ZWxdO1xuXG4gICAgICAgIHZhciBvdCA9IF90aGlzLmdldE9iamVjdFR5cGUoZnJhZ21lbnQpO1xuXG4gICAgICAgIHZhciBkYXRhID0ge1xuICAgICAgICAgIGQ6IGZyYWdtZW50LmR1cmF0aW9uICogMTAwMCxcbiAgICAgICAgICBvdDogb3RcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAob3QgPT09IF90eXBlc19jbWNkX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJDTUNET2JqZWN0VHlwZVwiXS5WSURFTyB8fCBvdCA9PT0gX3R5cGVzX2NtY2RfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkNNQ0RPYmplY3RUeXBlXCJdLkFVRElPIHx8IG90ID09IF90eXBlc19jbWNkX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJDTUNET2JqZWN0VHlwZVwiXS5NVVhFRCkge1xuICAgICAgICAgIGRhdGEuYnIgPSBsZXZlbC5iaXRyYXRlIC8gMTAwMDtcbiAgICAgICAgICBkYXRhLnRiID0gX3RoaXMuZ2V0VG9wQmFuZHdpZHRoKG90KSAvIDEwMDA7XG4gICAgICAgICAgZGF0YS5ibCA9IF90aGlzLmdldEJ1ZmZlckxlbmd0aChvdCk7XG4gICAgICAgIH1cblxuICAgICAgICBfdGhpcy5hcHBseShjb250ZXh0LCBkYXRhKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcImxvZ2dlclwiXS53YXJuKCdDb3VsZCBub3QgZ2VuZXJhdGUgc2VnbWVudCBDTUNEIGRhdGEuJywgZXJyb3IpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLmhscyA9IGhscztcbiAgICB2YXIgY29uZmlnID0gdGhpcy5jb25maWcgPSBobHMuY29uZmlnO1xuICAgIHZhciBjbWNkID0gY29uZmlnLmNtY2Q7XG5cbiAgICBpZiAoY21jZCAhPSBudWxsKSB7XG4gICAgICBjb25maWcucExvYWRlciA9IHRoaXMuY3JlYXRlUGxheWxpc3RMb2FkZXIoKTtcbiAgICAgIGNvbmZpZy5mTG9hZGVyID0gdGhpcy5jcmVhdGVGcmFnbWVudExvYWRlcigpO1xuICAgICAgdGhpcy5zaWQgPSBjbWNkLnNlc3Npb25JZCB8fCBDTUNEQ29udHJvbGxlci51dWlkKCk7XG4gICAgICB0aGlzLmNpZCA9IGNtY2QuY29udGVudElkO1xuICAgICAgdGhpcy51c2VIZWFkZXJzID0gY21jZC51c2VIZWFkZXJzID09PSB0cnVlO1xuICAgICAgdGhpcy5yZWdpc3Rlckxpc3RlbmVycygpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBDTUNEQ29udHJvbGxlci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLnJlZ2lzdGVyTGlzdGVuZXJzID0gZnVuY3Rpb24gcmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgdmFyIGhscyA9IHRoaXMuaGxzO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJFdmVudHNcIl0uTUVESUFfQVRUQUNIRUQsIHRoaXMub25NZWRpYUF0dGFjaGVkLCB0aGlzKTtcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiRXZlbnRzXCJdLk1FRElBX0RFVEFDSEVELCB0aGlzLm9uTWVkaWFEZXRhY2hlZCwgdGhpcyk7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIkV2ZW50c1wiXS5CVUZGRVJfQ1JFQVRFRCwgdGhpcy5vbkJ1ZmZlckNyZWF0ZWQsIHRoaXMpO1xuICB9O1xuXG4gIF9wcm90by51bnJlZ2lzdGVyTGlzdGVuZXJzID0gZnVuY3Rpb24gdW5yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICB2YXIgaGxzID0gdGhpcy5obHM7XG4gICAgaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJFdmVudHNcIl0uTUVESUFfQVRUQUNIRUQsIHRoaXMub25NZWRpYUF0dGFjaGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIkV2ZW50c1wiXS5NRURJQV9ERVRBQ0hFRCwgdGhpcy5vbk1lZGlhRGV0YWNoZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiRXZlbnRzXCJdLkJVRkZFUl9DUkVBVEVELCB0aGlzLm9uQnVmZmVyQ3JlYXRlZCwgdGhpcyk7XG4gICAgdGhpcy5vbk1lZGlhRGV0YWNoZWQoKTtcbiAgfTtcblxuICBfcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgdGhpcy51bnJlZ2lzdGVyTGlzdGVuZXJzKCk7IC8vIEB0cy1pZ25vcmVcblxuICAgIHRoaXMuaGxzID0gdGhpcy5jb25maWcgPSB0aGlzLmF1ZGlvQnVmZmVyID0gdGhpcy52aWRlb0J1ZmZlciA9IG51bGw7XG4gIH07XG5cbiAgX3Byb3RvLm9uTWVkaWFBdHRhY2hlZCA9IGZ1bmN0aW9uIG9uTWVkaWFBdHRhY2hlZChldmVudCwgZGF0YSkge1xuICAgIHRoaXMubWVkaWEgPSBkYXRhLm1lZGlhO1xuICAgIHRoaXMubWVkaWEuYWRkRXZlbnRMaXN0ZW5lcignd2FpdGluZycsIHRoaXMub25XYWl0aW5nKTtcbiAgICB0aGlzLm1lZGlhLmFkZEV2ZW50TGlzdGVuZXIoJ3BsYXlpbmcnLCB0aGlzLm9uUGxheWluZyk7XG4gIH07XG5cbiAgX3Byb3RvLm9uTWVkaWFEZXRhY2hlZCA9IGZ1bmN0aW9uIG9uTWVkaWFEZXRhY2hlZCgpIHtcbiAgICBpZiAoIXRoaXMubWVkaWEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLm1lZGlhLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3dhaXRpbmcnLCB0aGlzLm9uV2FpdGluZyk7XG4gICAgdGhpcy5tZWRpYS5yZW1vdmVFdmVudExpc3RlbmVyKCdwbGF5aW5nJywgdGhpcy5vblBsYXlpbmcpOyAvLyBAdHMtaWdub3JlXG5cbiAgICB0aGlzLm1lZGlhID0gbnVsbDtcbiAgfTtcblxuICBfcHJvdG8ub25CdWZmZXJDcmVhdGVkID0gZnVuY3Rpb24gb25CdWZmZXJDcmVhdGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgdmFyIF9kYXRhJHRyYWNrcyRhdWRpbywgX2RhdGEkdHJhY2tzJHZpZGVvO1xuXG4gICAgdGhpcy5hdWRpb0J1ZmZlciA9IChfZGF0YSR0cmFja3MkYXVkaW8gPSBkYXRhLnRyYWNrcy5hdWRpbykgPT09IG51bGwgfHwgX2RhdGEkdHJhY2tzJGF1ZGlvID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZGF0YSR0cmFja3MkYXVkaW8uYnVmZmVyO1xuICAgIHRoaXMudmlkZW9CdWZmZXIgPSAoX2RhdGEkdHJhY2tzJHZpZGVvID0gZGF0YS50cmFja3MudmlkZW8pID09PSBudWxsIHx8IF9kYXRhJHRyYWNrcyR2aWRlbyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2RhdGEkdHJhY2tzJHZpZGVvLmJ1ZmZlcjtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIGJhc2VsaW5lIENNQ0QgZGF0YVxuICAgKi9cbiAgX3Byb3RvLmNyZWF0ZURhdGEgPSBmdW5jdGlvbiBjcmVhdGVEYXRhKCkge1xuICAgIHZhciBfdGhpcyRtZWRpYTtcblxuICAgIHJldHVybiB7XG4gICAgICB2OiBfdHlwZXNfY21jZF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiQ01DRFZlcnNpb25cIl0sXG4gICAgICBzZjogX3R5cGVzX2NtY2RfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkNNQ0RTdHJlYW1pbmdGb3JtYXRcIl0uSExTLFxuICAgICAgc2lkOiB0aGlzLnNpZCxcbiAgICAgIGNpZDogdGhpcy5jaWQsXG4gICAgICBwcjogKF90aGlzJG1lZGlhID0gdGhpcy5tZWRpYSkgPT09IG51bGwgfHwgX3RoaXMkbWVkaWEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzJG1lZGlhLnBsYXliYWNrUmF0ZSxcbiAgICAgIG10cDogdGhpcy5obHMuYmFuZHdpZHRoRXN0aW1hdGUgLyAxMDAwXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogQXBwbHkgQ01DRCBkYXRhIHRvIGEgcmVxdWVzdC5cbiAgICovXG4gIDtcblxuICBfcHJvdG8uYXBwbHkgPSBmdW5jdGlvbiBhcHBseShjb250ZXh0LCBkYXRhKSB7XG4gICAgaWYgKGRhdGEgPT09IHZvaWQgMCkge1xuICAgICAgZGF0YSA9IHt9O1xuICAgIH1cblxuICAgIC8vIGFwcGx5IGJhc2VsaW5lIGRhdGFcbiAgICBfZXh0ZW5kcyhkYXRhLCB0aGlzLmNyZWF0ZURhdGEoKSk7XG5cbiAgICB2YXIgaXNWaWRlbyA9IGRhdGEub3QgPT09IF90eXBlc19jbWNkX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJDTUNET2JqZWN0VHlwZVwiXS5JTklUIHx8IGRhdGEub3QgPT09IF90eXBlc19jbWNkX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJDTUNET2JqZWN0VHlwZVwiXS5WSURFTyB8fCBkYXRhLm90ID09PSBfdHlwZXNfY21jZF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiQ01DRE9iamVjdFR5cGVcIl0uTVVYRUQ7XG5cbiAgICBpZiAodGhpcy5zdGFydmVkICYmIGlzVmlkZW8pIHtcbiAgICAgIGRhdGEuYnMgPSB0cnVlO1xuICAgICAgZGF0YS5zdSA9IHRydWU7XG4gICAgICB0aGlzLnN0YXJ2ZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoZGF0YS5zdSA9PSBudWxsKSB7XG4gICAgICBkYXRhLnN1ID0gdGhpcy5idWZmZXJpbmc7XG4gICAgfSAvLyBUT0RPOiBJbXBsZW1lbnQgcnRwLCBucnIsIG5vciwgZGxcblxuXG4gICAgaWYgKHRoaXMudXNlSGVhZGVycykge1xuICAgICAgdmFyIGhlYWRlcnMgPSBDTUNEQ29udHJvbGxlci50b0hlYWRlcnMoZGF0YSk7XG5cbiAgICAgIGlmICghT2JqZWN0LmtleXMoaGVhZGVycykubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKCFjb250ZXh0LmhlYWRlcnMpIHtcbiAgICAgICAgY29udGV4dC5oZWFkZXJzID0ge307XG4gICAgICB9XG5cbiAgICAgIF9leHRlbmRzKGNvbnRleHQuaGVhZGVycywgaGVhZGVycyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBxdWVyeSA9IENNQ0RDb250cm9sbGVyLnRvUXVlcnkoZGF0YSk7XG5cbiAgICAgIGlmICghcXVlcnkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb250ZXh0LnVybCA9IENNQ0RDb250cm9sbGVyLmFwcGVuZFF1ZXJ5VG9VcmkoY29udGV4dC51cmwsIHF1ZXJ5KTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEFwcGx5IENNQ0QgZGF0YSB0byBhIG1hbmlmZXN0IHJlcXVlc3QuXG4gICAqL1xuICA7XG5cbiAgLyoqXG4gICAqIFRoZSBDTUNEIG9iamVjdCB0eXBlLlxuICAgKi9cbiAgX3Byb3RvLmdldE9iamVjdFR5cGUgPSBmdW5jdGlvbiBnZXRPYmplY3RUeXBlKGZyYWdtZW50KSB7XG4gICAgdmFyIHR5cGUgPSBmcmFnbWVudC50eXBlO1xuXG4gICAgaWYgKHR5cGUgPT09ICdzdWJ0aXRsZScpIHtcbiAgICAgIHJldHVybiBfdHlwZXNfY21jZF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiQ01DRE9iamVjdFR5cGVcIl0uVElNRURfVEVYVDtcbiAgICB9XG5cbiAgICBpZiAoZnJhZ21lbnQuc24gPT09ICdpbml0U2VnbWVudCcpIHtcbiAgICAgIHJldHVybiBfdHlwZXNfY21jZF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiQ01DRE9iamVjdFR5cGVcIl0uSU5JVDtcbiAgICB9XG5cbiAgICBpZiAodHlwZSA9PT0gJ2F1ZGlvJykge1xuICAgICAgcmV0dXJuIF90eXBlc19jbWNkX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJDTUNET2JqZWN0VHlwZVwiXS5BVURJTztcbiAgICB9XG5cbiAgICBpZiAodHlwZSA9PT0gJ21haW4nKSB7XG4gICAgICBpZiAoIXRoaXMuaGxzLmF1ZGlvVHJhY2tzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gX3R5cGVzX2NtY2RfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkNNQ0RPYmplY3RUeXBlXCJdLk1VWEVEO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX3R5cGVzX2NtY2RfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkNNQ0RPYmplY3RUeXBlXCJdLlZJREVPO1xuICAgIH1cblxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgaGlnaGVzdCBiaXRyYXRlLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5nZXRUb3BCYW5kd2lkdGggPSBmdW5jdGlvbiBnZXRUb3BCYW5kd2lkdGgodHlwZSkge1xuICAgIHZhciBiaXRyYXRlID0gMDtcbiAgICB2YXIgbGV2ZWxzO1xuICAgIHZhciBobHMgPSB0aGlzLmhscztcblxuICAgIGlmICh0eXBlID09PSBfdHlwZXNfY21jZF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiQ01DRE9iamVjdFR5cGVcIl0uQVVESU8pIHtcbiAgICAgIGxldmVscyA9IGhscy5hdWRpb1RyYWNrcztcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG1heCA9IGhscy5tYXhBdXRvTGV2ZWw7XG4gICAgICB2YXIgbGVuID0gbWF4ID4gLTEgPyBtYXggKyAxIDogaGxzLmxldmVscy5sZW5ndGg7XG4gICAgICBsZXZlbHMgPSBobHMubGV2ZWxzLnNsaWNlKDAsIGxlbik7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXJMb29zZShsZXZlbHMpLCBfc3RlcDsgIShfc3RlcCA9IF9pdGVyYXRvcigpKS5kb25lOykge1xuICAgICAgdmFyIGxldmVsID0gX3N0ZXAudmFsdWU7XG5cbiAgICAgIGlmIChsZXZlbC5iaXRyYXRlID4gYml0cmF0ZSkge1xuICAgICAgICBiaXRyYXRlID0gbGV2ZWwuYml0cmF0ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYml0cmF0ZSA+IDAgPyBiaXRyYXRlIDogTmFOO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIGJ1ZmZlciBsZW5ndGggZm9yIGEgbWVkaWEgdHlwZSBpbiBtaWxsaXNlY29uZHNcbiAgICovXG4gIDtcblxuICBfcHJvdG8uZ2V0QnVmZmVyTGVuZ3RoID0gZnVuY3Rpb24gZ2V0QnVmZmVyTGVuZ3RoKHR5cGUpIHtcbiAgICB2YXIgbWVkaWEgPSB0aGlzLmhscy5tZWRpYTtcbiAgICB2YXIgYnVmZmVyID0gdHlwZSA9PT0gX3R5cGVzX2NtY2RfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkNNQ0RPYmplY3RUeXBlXCJdLkFVRElPID8gdGhpcy5hdWRpb0J1ZmZlciA6IHRoaXMudmlkZW9CdWZmZXI7XG5cbiAgICBpZiAoIWJ1ZmZlciB8fCAhbWVkaWEpIHtcbiAgICAgIHJldHVybiBOYU47XG4gICAgfVxuXG4gICAgdmFyIGluZm8gPSBfdXRpbHNfYnVmZmVyX2hlbHBlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiQnVmZmVySGVscGVyXCJdLmJ1ZmZlckluZm8oYnVmZmVyLCBtZWRpYS5jdXJyZW50VGltZSwgdGhpcy5jb25maWcubWF4QnVmZmVySG9sZSk7XG4gICAgcmV0dXJuIGluZm8ubGVuICogMTAwMDtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGEgcGxheWxpc3QgbG9hZGVyXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmNyZWF0ZVBsYXlsaXN0TG9hZGVyID0gZnVuY3Rpb24gY3JlYXRlUGxheWxpc3RMb2FkZXIoKSB7XG4gICAgdmFyIHBMb2FkZXIgPSB0aGlzLmNvbmZpZy5wTG9hZGVyO1xuICAgIHZhciBhcHBseSA9IHRoaXMuYXBwbHlQbGF5bGlzdERhdGE7XG4gICAgdmFyIEN0b3IgPSBwTG9hZGVyIHx8IHRoaXMuY29uZmlnLmxvYWRlcjtcbiAgICByZXR1cm4gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIENtY2RQbGF5bGlzdExvYWRlcihjb25maWcpIHtcbiAgICAgICAgdGhpcy5sb2FkZXIgPSB2b2lkIDA7XG4gICAgICAgIHRoaXMubG9hZGVyID0gbmV3IEN0b3IoY29uZmlnKTtcbiAgICAgIH1cblxuICAgICAgdmFyIF9wcm90bzIgPSBDbWNkUGxheWxpc3RMb2FkZXIucHJvdG90eXBlO1xuXG4gICAgICBfcHJvdG8yLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmxvYWRlci5kZXN0cm95KCk7XG4gICAgICB9O1xuXG4gICAgICBfcHJvdG8yLmFib3J0ID0gZnVuY3Rpb24gYWJvcnQoKSB7XG4gICAgICAgIHRoaXMubG9hZGVyLmFib3J0KCk7XG4gICAgICB9O1xuXG4gICAgICBfcHJvdG8yLmxvYWQgPSBmdW5jdGlvbiBsb2FkKGNvbnRleHQsIGNvbmZpZywgY2FsbGJhY2tzKSB7XG4gICAgICAgIGFwcGx5KGNvbnRleHQpO1xuICAgICAgICB0aGlzLmxvYWRlci5sb2FkKGNvbnRleHQsIGNvbmZpZywgY2FsbGJhY2tzKTtcbiAgICAgIH07XG5cbiAgICAgIF9jcmVhdGVDbGFzcyhDbWNkUGxheWxpc3RMb2FkZXIsIFt7XG4gICAgICAgIGtleTogXCJzdGF0c1wiLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5sb2FkZXIuc3RhdHM7XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiBcImNvbnRleHRcIixcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMubG9hZGVyLmNvbnRleHQ7XG4gICAgICAgIH1cbiAgICAgIH1dKTtcblxuICAgICAgcmV0dXJuIENtY2RQbGF5bGlzdExvYWRlcjtcbiAgICB9KCk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBhIHBsYXlsaXN0IGxvYWRlclxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5jcmVhdGVGcmFnbWVudExvYWRlciA9IGZ1bmN0aW9uIGNyZWF0ZUZyYWdtZW50TG9hZGVyKCkge1xuICAgIHZhciBmTG9hZGVyID0gdGhpcy5jb25maWcuZkxvYWRlcjtcbiAgICB2YXIgYXBwbHkgPSB0aGlzLmFwcGx5RnJhZ21lbnREYXRhO1xuICAgIHZhciBDdG9yID0gZkxvYWRlciB8fCB0aGlzLmNvbmZpZy5sb2FkZXI7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBDbWNkRnJhZ21lbnRMb2FkZXIoY29uZmlnKSB7XG4gICAgICAgIHRoaXMubG9hZGVyID0gdm9pZCAwO1xuICAgICAgICB0aGlzLmxvYWRlciA9IG5ldyBDdG9yKGNvbmZpZyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBfcHJvdG8zID0gQ21jZEZyYWdtZW50TG9hZGVyLnByb3RvdHlwZTtcblxuICAgICAgX3Byb3RvMy5kZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5sb2FkZXIuZGVzdHJveSgpO1xuICAgICAgfTtcblxuICAgICAgX3Byb3RvMy5hYm9ydCA9IGZ1bmN0aW9uIGFib3J0KCkge1xuICAgICAgICB0aGlzLmxvYWRlci5hYm9ydCgpO1xuICAgICAgfTtcblxuICAgICAgX3Byb3RvMy5sb2FkID0gZnVuY3Rpb24gbG9hZChjb250ZXh0LCBjb25maWcsIGNhbGxiYWNrcykge1xuICAgICAgICBhcHBseShjb250ZXh0KTtcbiAgICAgICAgdGhpcy5sb2FkZXIubG9hZChjb250ZXh0LCBjb25maWcsIGNhbGxiYWNrcyk7XG4gICAgICB9O1xuXG4gICAgICBfY3JlYXRlQ2xhc3MoQ21jZEZyYWdtZW50TG9hZGVyLCBbe1xuICAgICAgICBrZXk6IFwic3RhdHNcIixcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMubG9hZGVyLnN0YXRzO1xuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIGtleTogXCJjb250ZXh0XCIsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmxvYWRlci5jb250ZXh0O1xuICAgICAgICB9XG4gICAgICB9XSk7XG5cbiAgICAgIHJldHVybiBDbWNkRnJhZ21lbnRMb2FkZXI7XG4gICAgfSgpO1xuICB9XG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIHJhbmRvbSB2NCBVVUlcbiAgICpcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG4gIDtcblxuICBDTUNEQ29udHJvbGxlci51dWlkID0gZnVuY3Rpb24gdXVpZCgpIHtcbiAgICB2YXIgdXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTChuZXcgQmxvYigpKTtcbiAgICB2YXIgdXVpZCA9IHVybC50b1N0cmluZygpO1xuICAgIFVSTC5yZXZva2VPYmplY3RVUkwodXJsKTtcbiAgICByZXR1cm4gdXVpZC5zdWJzdHIodXVpZC5sYXN0SW5kZXhPZignLycpICsgMSk7XG4gIH1cbiAgLyoqXG4gICAqIFNlcmlhbGl6ZSBhIENNQ0QgZGF0YSBvYmplY3QgYWNjb3JkaW5nIHRvIHRoZSBydWxlcyBkZWZpbmVkIGluIHRoZVxuICAgKiBzZWN0aW9uIDMuMiBvZlxuICAgKiBbQ1RBLTUwMDRdKGh0dHBzOi8vY2RuLmN0YS50ZWNoL2N0YS9tZWRpYS9tZWRpYS9yZXNvdXJjZXMvc3RhbmRhcmRzL3BkZnMvY3RhLTUwMDQtZmluYWwucGRmKS5cbiAgICovXG4gIDtcblxuICBDTUNEQ29udHJvbGxlci5zZXJpYWxpemUgPSBmdW5jdGlvbiBzZXJpYWxpemUoZGF0YSkge1xuICAgIHZhciByZXN1bHRzID0gW107XG5cbiAgICB2YXIgaXNWYWxpZCA9IGZ1bmN0aW9uIGlzVmFsaWQodmFsdWUpIHtcbiAgICAgIHJldHVybiAhTnVtYmVyLmlzTmFOKHZhbHVlKSAmJiB2YWx1ZSAhPSBudWxsICYmIHZhbHVlICE9PSAnJyAmJiB2YWx1ZSAhPT0gZmFsc2U7XG4gICAgfTtcblxuICAgIHZhciB0b1JvdW5kZWQgPSBmdW5jdGlvbiB0b1JvdW5kZWQodmFsdWUpIHtcbiAgICAgIHJldHVybiBNYXRoLnJvdW5kKHZhbHVlKTtcbiAgICB9O1xuXG4gICAgdmFyIHRvSHVuZHJlZCA9IGZ1bmN0aW9uIHRvSHVuZHJlZCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRvUm91bmRlZCh2YWx1ZSAvIDEwMCkgKiAxMDA7XG4gICAgfTtcblxuICAgIHZhciB0b1VybFNhZmUgPSBmdW5jdGlvbiB0b1VybFNhZmUodmFsdWUpIHtcbiAgICAgIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQodmFsdWUpO1xuICAgIH07XG5cbiAgICB2YXIgZm9ybWF0dGVycyA9IHtcbiAgICAgIGJyOiB0b1JvdW5kZWQsXG4gICAgICBkOiB0b1JvdW5kZWQsXG4gICAgICBibDogdG9IdW5kcmVkLFxuICAgICAgZGw6IHRvSHVuZHJlZCxcbiAgICAgIG10cDogdG9IdW5kcmVkLFxuICAgICAgbm9yOiB0b1VybFNhZmUsXG4gICAgICBydHA6IHRvSHVuZHJlZCxcbiAgICAgIHRiOiB0b1JvdW5kZWRcbiAgICB9O1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZGF0YSB8fCB7fSkuc29ydCgpO1xuXG4gICAgZm9yICh2YXIgX2l0ZXJhdG9yMiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyTG9vc2Uoa2V5cyksIF9zdGVwMjsgIShfc3RlcDIgPSBfaXRlcmF0b3IyKCkpLmRvbmU7KSB7XG4gICAgICB2YXIga2V5ID0gX3N0ZXAyLnZhbHVlO1xuICAgICAgdmFyIHZhbHVlID0gZGF0YVtrZXldOyAvLyBpZ25vcmUgaW52YWxpZCB2YWx1ZXNcblxuICAgICAgaWYgKCFpc1ZhbGlkKHZhbHVlKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gLy8gVmVyc2lvbiBzaG91bGQgb25seSBiZSByZXBvcnRlZCBpZiBub3QgZXF1YWwgdG8gMS5cblxuXG4gICAgICBpZiAoa2V5ID09PSAndicgJiYgdmFsdWUgPT09IDEpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IC8vIFBsYXliYWNrIHJhdGUgc2hvdWxkIG9ubHkgYmUgc2VudCBpZiBub3QgZXF1YWwgdG8gMS5cblxuXG4gICAgICBpZiAoa2V5ID09ICdwcicgJiYgdmFsdWUgPT09IDEpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IC8vIENlcnRhaW4gdmFsdWVzIHJlcXVpcmUgc3BlY2lhbCBmb3JtYXR0aW5nXG5cblxuICAgICAgdmFyIGZvcm1hdHRlciA9IGZvcm1hdHRlcnNba2V5XTtcblxuICAgICAgaWYgKGZvcm1hdHRlcikge1xuICAgICAgICB2YWx1ZSA9IGZvcm1hdHRlcih2YWx1ZSk7XG4gICAgICB9IC8vIFNlcmlhbGl6ZSB0aGUga2V5L3ZhbHVlIHBhaXJcblxuXG4gICAgICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgICAgIHZhciByZXN1bHQgPSB2b2lkIDA7XG5cbiAgICAgIGlmIChrZXkgPT09ICdvdCcgfHwga2V5ID09PSAnc2YnIHx8IGtleSA9PT0gJ3N0Jykge1xuICAgICAgICByZXN1bHQgPSBrZXkgKyBcIj1cIiArIHZhbHVlO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgcmVzdWx0ID0ga2V5O1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnbnVtYmVyJykge1xuICAgICAgICByZXN1bHQgPSBrZXkgKyBcIj1cIiArIHZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0ga2V5ICsgXCI9XCIgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIHJlc3VsdHMucHVzaChyZXN1bHQpO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRzLmpvaW4oJywnKTtcbiAgfVxuICAvKipcbiAgICogQ29udmVydCBhIENNQ0QgZGF0YSBvYmplY3QgdG8gcmVxdWVzdCBoZWFkZXJzIGFjY29yZGluZyB0byB0aGUgcnVsZXNcbiAgICogZGVmaW5lZCBpbiB0aGUgc2VjdGlvbiAyLjEgYW5kIDMuMiBvZlxuICAgKiBbQ1RBLTUwMDRdKGh0dHBzOi8vY2RuLmN0YS50ZWNoL2N0YS9tZWRpYS9tZWRpYS9yZXNvdXJjZXMvc3RhbmRhcmRzL3BkZnMvY3RhLTUwMDQtZmluYWwucGRmKS5cbiAgICovXG4gIDtcblxuICBDTUNEQ29udHJvbGxlci50b0hlYWRlcnMgPSBmdW5jdGlvbiB0b0hlYWRlcnMoZGF0YSkge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZGF0YSk7XG4gICAgdmFyIGhlYWRlcnMgPSB7fTtcbiAgICB2YXIgaGVhZGVyTmFtZXMgPSBbJ09iamVjdCcsICdSZXF1ZXN0JywgJ1Nlc3Npb24nLCAnU3RhdHVzJ107XG4gICAgdmFyIGhlYWRlckdyb3VwcyA9IFt7fSwge30sIHt9LCB7fV07XG4gICAgdmFyIGhlYWRlck1hcCA9IHtcbiAgICAgIGJyOiAwLFxuICAgICAgZDogMCxcbiAgICAgIG90OiAwLFxuICAgICAgdGI6IDAsXG4gICAgICBibDogMSxcbiAgICAgIGRsOiAxLFxuICAgICAgbXRwOiAxLFxuICAgICAgbm9yOiAxLFxuICAgICAgbnJyOiAxLFxuICAgICAgc3U6IDEsXG4gICAgICBjaWQ6IDIsXG4gICAgICBwcjogMixcbiAgICAgIHNmOiAyLFxuICAgICAgc2lkOiAyLFxuICAgICAgc3Q6IDIsXG4gICAgICB2OiAyLFxuICAgICAgYnM6IDMsXG4gICAgICBydHA6IDNcbiAgICB9O1xuXG4gICAgZm9yICh2YXIgX2kgPSAwLCBfa2V5cyA9IGtleXM7IF9pIDwgX2tleXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIga2V5ID0gX2tleXNbX2ldO1xuICAgICAgLy8gVW5tYXBwZWQgZmllbGRzIGFyZSBtYXBwZWQgdG8gdGhlIFJlcXVlc3QgaGVhZGVyXG4gICAgICB2YXIgaW5kZXggPSBoZWFkZXJNYXBba2V5XSAhPSBudWxsID8gaGVhZGVyTWFwW2tleV0gOiAxO1xuICAgICAgaGVhZGVyR3JvdXBzW2luZGV4XVtrZXldID0gZGF0YVtrZXldO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGVhZGVyR3JvdXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdmFsdWUgPSBDTUNEQ29udHJvbGxlci5zZXJpYWxpemUoaGVhZGVyR3JvdXBzW2ldKTtcblxuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIGhlYWRlcnNbXCJDTUNELVwiICsgaGVhZGVyTmFtZXNbaV1dID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGhlYWRlcnM7XG4gIH1cbiAgLyoqXG4gICAqIENvbnZlcnQgYSBDTUNEIGRhdGEgb2JqZWN0IHRvIHF1ZXJ5IGFyZ3MgYWNjb3JkaW5nIHRvIHRoZSBydWxlc1xuICAgKiBkZWZpbmVkIGluIHRoZSBzZWN0aW9uIDIuMiBhbmQgMy4yIG9mXG4gICAqIFtDVEEtNTAwNF0oaHR0cHM6Ly9jZG4uY3RhLnRlY2gvY3RhL21lZGlhL21lZGlhL3Jlc291cmNlcy9zdGFuZGFyZHMvcGRmcy9jdGEtNTAwNC1maW5hbC5wZGYpLlxuICAgKi9cbiAgO1xuXG4gIENNQ0RDb250cm9sbGVyLnRvUXVlcnkgPSBmdW5jdGlvbiB0b1F1ZXJ5KGRhdGEpIHtcbiAgICByZXR1cm4gXCJDTUNEPVwiICsgZW5jb2RlVVJJQ29tcG9uZW50KENNQ0RDb250cm9sbGVyLnNlcmlhbGl6ZShkYXRhKSk7XG4gIH1cbiAgLyoqXG4gICAqIEFwcGVuZCBxdWVyeSBhcmdzIHRvIGEgdXJpLlxuICAgKi9cbiAgO1xuXG4gIENNQ0RDb250cm9sbGVyLmFwcGVuZFF1ZXJ5VG9VcmkgPSBmdW5jdGlvbiBhcHBlbmRRdWVyeVRvVXJpKHVyaSwgcXVlcnkpIHtcbiAgICBpZiAoIXF1ZXJ5KSB7XG4gICAgICByZXR1cm4gdXJpO1xuICAgIH1cblxuICAgIHZhciBzZXBhcmF0b3IgPSB1cmkuaW5jbHVkZXMoJz8nKSA/ICcmJyA6ICc/JztcbiAgICByZXR1cm4gXCJcIiArIHVyaSArIHNlcGFyYXRvciArIHF1ZXJ5O1xuICB9O1xuXG4gIHJldHVybiBDTUNEQ29udHJvbGxlcjtcbn0oKTtcblxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NvbnRyb2xsZXIvZW1lLWNvbnRyb2xsZXIudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9jb250cm9sbGVyL2VtZS1jb250cm9sbGVyLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9ldmVudHMgKi8gXCIuL3NyYy9ldmVudHMudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZXJyb3JzICovIFwiLi9zcmMvZXJyb3JzLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL2xvZ2dlciAqLyBcIi4vc3JjL3V0aWxzL2xvZ2dlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfbWVkaWFrZXlzX2hlbHBlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvbWVkaWFrZXlzLWhlbHBlciAqLyBcIi4vc3JjL3V0aWxzL21lZGlha2V5cy1oZWxwZXIudHNcIik7XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbi8qKlxuICogQGF1dGhvciBTdGVwaGFuIEhlc3NlIDxkaXNwYXJhdEBnbWFpbC5jb20+IHwgPHRjaGFrYWJhbUBnbWFpbC5jb20+XG4gKlxuICogRFJNIHN1cHBvcnQgZm9yIEhscy5qc1xuICovXG5cblxuXG5cbnZhciBNQVhfTElDRU5TRV9SRVFVRVNUX0ZBSUxVUkVTID0gMztcbi8qKlxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTWVkaWFLZXlTeXN0ZW1Db25maWd1cmF0aW9uXG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IGF1ZGlvQ29kZWNzIExpc3Qgb2YgcmVxdWlyZWQgYXVkaW8gY29kZWNzIHRvIHN1cHBvcnRcbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gdmlkZW9Db2RlY3MgTGlzdCBvZiByZXF1aXJlZCB2aWRlbyBjb2RlY3MgdG8gc3VwcG9ydFxuICogQHBhcmFtIHtvYmplY3R9IGRybVN5c3RlbU9wdGlvbnMgT3B0aW9uYWwgcGFyYW1ldGVycy9yZXF1aXJlbWVudHMgZm9yIHRoZSBrZXktc3lzdGVtXG4gKiBAcmV0dXJucyB7QXJyYXk8TWVkaWFTeXN0ZW1Db25maWd1cmF0aW9uPn0gQW4gYXJyYXkgb2Ygc3VwcG9ydGVkIGNvbmZpZ3VyYXRpb25zXG4gKi9cblxudmFyIGNyZWF0ZVdpZGV2aW5lTWVkaWFLZXlTeXN0ZW1Db25maWd1cmF0aW9ucyA9IGZ1bmN0aW9uIGNyZWF0ZVdpZGV2aW5lTWVkaWFLZXlTeXN0ZW1Db25maWd1cmF0aW9ucyhhdWRpb0NvZGVjcywgdmlkZW9Db2RlY3MsIGRybVN5c3RlbU9wdGlvbnMpIHtcbiAgLyoganNoaW50IGlnbm9yZTpsaW5lICovXG4gIHZhciBiYXNlQ29uZmlnID0ge1xuICAgIC8vIGluaXREYXRhVHlwZXM6IFsna2V5aWRzJywgJ21wNCddLFxuICAgIC8vIGxhYmVsOiBcIlwiLFxuICAgIC8vIHBlcnNpc3RlbnRTdGF0ZTogXCJub3QtYWxsb3dlZFwiLCAvLyBvciBcInJlcXVpcmVkXCIgP1xuICAgIC8vIGRpc3RpbmN0aXZlSWRlbnRpZmllcjogXCJub3QtYWxsb3dlZFwiLCAvLyBvciBcInJlcXVpcmVkXCIgP1xuICAgIC8vIHNlc3Npb25UeXBlczogWyd0ZW1wb3JhcnknXSxcbiAgICBhdWRpb0NhcGFiaWxpdGllczogW10sXG4gICAgLy8geyBjb250ZW50VHlwZTogJ2F1ZGlvL21wNDsgY29kZWNzPVwibXA0YS40MC4yXCInIH1cbiAgICB2aWRlb0NhcGFiaWxpdGllczogW10gLy8geyBjb250ZW50VHlwZTogJ3ZpZGVvL21wNDsgY29kZWNzPVwiYXZjMS40MkUwMUVcIicgfVxuXG4gIH07XG4gIGF1ZGlvQ29kZWNzLmZvckVhY2goZnVuY3Rpb24gKGNvZGVjKSB7XG4gICAgYmFzZUNvbmZpZy5hdWRpb0NhcGFiaWxpdGllcy5wdXNoKHtcbiAgICAgIGNvbnRlbnRUeXBlOiBcImF1ZGlvL21wNDsgY29kZWNzPVxcXCJcIiArIGNvZGVjICsgXCJcXFwiXCIsXG4gICAgICByb2J1c3RuZXNzOiBkcm1TeXN0ZW1PcHRpb25zLmF1ZGlvUm9idXN0bmVzcyB8fCAnJ1xuICAgIH0pO1xuICB9KTtcbiAgdmlkZW9Db2RlY3MuZm9yRWFjaChmdW5jdGlvbiAoY29kZWMpIHtcbiAgICBiYXNlQ29uZmlnLnZpZGVvQ2FwYWJpbGl0aWVzLnB1c2goe1xuICAgICAgY29udGVudFR5cGU6IFwidmlkZW8vbXA0OyBjb2RlY3M9XFxcIlwiICsgY29kZWMgKyBcIlxcXCJcIixcbiAgICAgIHJvYnVzdG5lc3M6IGRybVN5c3RlbU9wdGlvbnMudmlkZW9Sb2J1c3RuZXNzIHx8ICcnXG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gW2Jhc2VDb25maWddO1xufTtcbi8qKlxuICogVGhlIGlkZWEgaGVyZSBpcyB0byBoYW5kbGUga2V5LXN5c3RlbSAoYW5kIHRoZWlyIHJlc3BlY3RpdmUgcGxhdGZvcm1zKSBzcGVjaWZpYyBjb25maWd1cmF0aW9uIGRpZmZlcmVuY2VzXG4gKiBpbiBvcmRlciB0byB3b3JrIHdpdGggdGhlIGxvY2FsIHJlcXVlc3RNZWRpYUtleVN5c3RlbUFjY2VzcyBtZXRob2QuXG4gKlxuICogV2UgY2FuIGFsc28gcnVsZS1vdXQgcGxhdGZvcm0tcmVsYXRlZCBrZXktc3lzdGVtIHN1cHBvcnQgYXQgdGhpcyBwb2ludCBieSB0aHJvd2luZyBhbiBlcnJvci5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5U3lzdGVtIElkZW50aWZpZXIgZm9yIHRoZSBrZXktc3lzdGVtLCBzZWUgYEtleVN5c3RlbXNgIGVudW1cbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gYXVkaW9Db2RlY3MgTGlzdCBvZiByZXF1aXJlZCBhdWRpbyBjb2RlY3MgdG8gc3VwcG9ydFxuICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSB2aWRlb0NvZGVjcyBMaXN0IG9mIHJlcXVpcmVkIHZpZGVvIGNvZGVjcyB0byBzdXBwb3J0XG4gKiBAdGhyb3dzIHdpbGwgdGhyb3cgYW4gZXJyb3IgaWYgYSB1bmtub3duIGtleSBzeXN0ZW0gaXMgcGFzc2VkXG4gKiBAcmV0dXJucyB7QXJyYXk8TWVkaWFTeXN0ZW1Db25maWd1cmF0aW9uPn0gQSBub24tZW1wdHkgQXJyYXkgb2YgTWVkaWFLZXlTeXN0ZW1Db25maWd1cmF0aW9uIG9iamVjdHNcbiAqL1xuXG5cbnZhciBnZXRTdXBwb3J0ZWRNZWRpYUtleVN5c3RlbUNvbmZpZ3VyYXRpb25zID0gZnVuY3Rpb24gZ2V0U3VwcG9ydGVkTWVkaWFLZXlTeXN0ZW1Db25maWd1cmF0aW9ucyhrZXlTeXN0ZW0sIGF1ZGlvQ29kZWNzLCB2aWRlb0NvZGVjcywgZHJtU3lzdGVtT3B0aW9ucykge1xuICBzd2l0Y2ggKGtleVN5c3RlbSkge1xuICAgIGNhc2UgX3V0aWxzX21lZGlha2V5c19oZWxwZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcIktleVN5c3RlbXNcIl0uV0lERVZJTkU6XG4gICAgICByZXR1cm4gY3JlYXRlV2lkZXZpbmVNZWRpYUtleVN5c3RlbUNvbmZpZ3VyYXRpb25zKGF1ZGlvQ29kZWNzLCB2aWRlb0NvZGVjcywgZHJtU3lzdGVtT3B0aW9ucyk7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBrZXktc3lzdGVtOiBcIiArIGtleVN5c3RlbSk7XG4gIH1cbn07XG5cbi8qKlxuICogQ29udHJvbGxlciB0byBkZWFsIHdpdGggZW5jcnlwdGVkIG1lZGlhIGV4dGVuc2lvbnMgKEVNRSlcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0VuY3J5cHRlZF9NZWRpYV9FeHRlbnNpb25zX0FQSVxuICpcbiAqIEBjbGFzc1xuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBFTUVDb250cm9sbGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RzXG4gICAqIEBwYXJhbSB7SGxzfSBobHMgT3VyIEhscy5qcyBpbnN0YW5jZVxuICAgKi9cbiAgZnVuY3Rpb24gRU1FQ29udHJvbGxlcihobHMpIHtcbiAgICB0aGlzLmhscyA9IHZvaWQgMDtcbiAgICB0aGlzLl93aWRldmluZUxpY2Vuc2VVcmwgPSB2b2lkIDA7XG4gICAgdGhpcy5fbGljZW5zZVhoclNldHVwID0gdm9pZCAwO1xuICAgIHRoaXMuX2xpY2Vuc2VSZXNwb25zZUNhbGxiYWNrID0gdm9pZCAwO1xuICAgIHRoaXMuX2VtZUVuYWJsZWQgPSB2b2lkIDA7XG4gICAgdGhpcy5fcmVxdWVzdE1lZGlhS2V5U3lzdGVtQWNjZXNzID0gdm9pZCAwO1xuICAgIHRoaXMuX2RybVN5c3RlbU9wdGlvbnMgPSB2b2lkIDA7XG4gICAgdGhpcy5fY29uZmlnID0gdm9pZCAwO1xuICAgIHRoaXMuX21lZGlhS2V5c0xpc3QgPSBbXTtcbiAgICB0aGlzLl9tZWRpYSA9IG51bGw7XG4gICAgdGhpcy5faGFzU2V0TWVkaWFLZXlzID0gZmFsc2U7XG4gICAgdGhpcy5fcmVxdWVzdExpY2Vuc2VGYWlsdXJlQ291bnQgPSAwO1xuICAgIHRoaXMubWVkaWFLZXlzUHJvbWlzZSA9IG51bGw7XG4gICAgdGhpcy5fb25NZWRpYUVuY3J5cHRlZCA9IHRoaXMub25NZWRpYUVuY3J5cHRlZC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuaGxzID0gaGxzO1xuICAgIHRoaXMuX2NvbmZpZyA9IGhscy5jb25maWc7XG4gICAgdGhpcy5fd2lkZXZpbmVMaWNlbnNlVXJsID0gdGhpcy5fY29uZmlnLndpZGV2aW5lTGljZW5zZVVybDtcbiAgICB0aGlzLl9saWNlbnNlWGhyU2V0dXAgPSB0aGlzLl9jb25maWcubGljZW5zZVhoclNldHVwO1xuICAgIHRoaXMuX2xpY2Vuc2VSZXNwb25zZUNhbGxiYWNrID0gdGhpcy5fY29uZmlnLmxpY2Vuc2VSZXNwb25zZUNhbGxiYWNrO1xuICAgIHRoaXMuX2VtZUVuYWJsZWQgPSB0aGlzLl9jb25maWcuZW1lRW5hYmxlZDtcbiAgICB0aGlzLl9yZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3MgPSB0aGlzLl9jb25maWcucmVxdWVzdE1lZGlhS2V5U3lzdGVtQWNjZXNzRnVuYztcbiAgICB0aGlzLl9kcm1TeXN0ZW1PcHRpb25zID0gdGhpcy5fY29uZmlnLmRybVN5c3RlbU9wdGlvbnM7XG5cbiAgICB0aGlzLl9yZWdpc3Rlckxpc3RlbmVycygpO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IEVNRUNvbnRyb2xsZXIucHJvdG90eXBlO1xuXG4gIF9wcm90by5kZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICB0aGlzLl91bnJlZ2lzdGVyTGlzdGVuZXJzKCk7IC8vIEB0cy1pZ25vcmVcblxuXG4gICAgdGhpcy5obHMgPSB0aGlzLl9vbk1lZGlhRW5jcnlwdGVkID0gbnVsbDtcbiAgICB0aGlzLl9yZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3MgPSBudWxsO1xuICB9O1xuXG4gIF9wcm90by5fcmVnaXN0ZXJMaXN0ZW5lcnMgPSBmdW5jdGlvbiBfcmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgdGhpcy5obHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiRXZlbnRzXCJdLk1FRElBX0FUVEFDSEVELCB0aGlzLm9uTWVkaWFBdHRhY2hlZCwgdGhpcyk7XG4gICAgdGhpcy5obHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiRXZlbnRzXCJdLk1FRElBX0RFVEFDSEVELCB0aGlzLm9uTWVkaWFEZXRhY2hlZCwgdGhpcyk7XG4gICAgdGhpcy5obHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiRXZlbnRzXCJdLk1BTklGRVNUX1BBUlNFRCwgdGhpcy5vbk1hbmlmZXN0UGFyc2VkLCB0aGlzKTtcbiAgfTtcblxuICBfcHJvdG8uX3VucmVnaXN0ZXJMaXN0ZW5lcnMgPSBmdW5jdGlvbiBfdW5yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICB0aGlzLmhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiRXZlbnRzXCJdLk1FRElBX0FUVEFDSEVELCB0aGlzLm9uTWVkaWFBdHRhY2hlZCwgdGhpcyk7XG4gICAgdGhpcy5obHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIkV2ZW50c1wiXS5NRURJQV9ERVRBQ0hFRCwgdGhpcy5vbk1lZGlhRGV0YWNoZWQsIHRoaXMpO1xuICAgIHRoaXMuaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJFdmVudHNcIl0uTUFOSUZFU1RfUEFSU0VELCB0aGlzLm9uTWFuaWZlc3RQYXJzZWQsIHRoaXMpO1xuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5U3lzdGVtIElkZW50aWZpZXIgZm9yIHRoZSBrZXktc3lzdGVtLCBzZWUgYEtleVN5c3RlbXNgIGVudW1cbiAgICogQHJldHVybnMge3N0cmluZ30gTGljZW5zZSBzZXJ2ZXIgVVJMIGZvciBrZXktc3lzdGVtIChpZiBhbnkgY29uZmlndXJlZCwgb3RoZXJ3aXNlIGNhdXNlcyBlcnJvcilcbiAgICogQHRocm93cyBpZiBhIHVuc3VwcG9ydGVkIGtleXN5c3RlbSBpcyBwYXNzZWRcbiAgICovXG4gIDtcblxuICBfcHJvdG8uZ2V0TGljZW5zZVNlcnZlclVybCA9IGZ1bmN0aW9uIGdldExpY2Vuc2VTZXJ2ZXJVcmwoa2V5U3lzdGVtKSB7XG4gICAgc3dpdGNoIChrZXlTeXN0ZW0pIHtcbiAgICAgIGNhc2UgX3V0aWxzX21lZGlha2V5c19oZWxwZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcIktleVN5c3RlbXNcIl0uV0lERVZJTkU6XG4gICAgICAgIGlmICghdGhpcy5fd2lkZXZpbmVMaWNlbnNlVXJsKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5fd2lkZXZpbmVMaWNlbnNlVXJsO1xuICAgIH1cblxuICAgIHRocm93IG5ldyBFcnJvcihcIm5vIGxpY2Vuc2Ugc2VydmVyIFVSTCBjb25maWd1cmVkIGZvciBrZXktc3lzdGVtIFxcXCJcIiArIGtleVN5c3RlbSArIFwiXFxcIlwiKTtcbiAgfVxuICAvKipcbiAgICogUmVxdWVzdHMgYWNjZXNzIG9iamVjdCBhbmQgYWRkcyBpdCB0byBvdXIgbGlzdCB1cG9uIHN1Y2Nlc3NcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleVN5c3RlbSBTeXN0ZW0gSUQgKHNlZSBgS2V5U3lzdGVtc2ApXG4gICAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gYXVkaW9Db2RlY3MgTGlzdCBvZiByZXF1aXJlZCBhdWRpbyBjb2RlY3MgdG8gc3VwcG9ydFxuICAgKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IHZpZGVvQ29kZWNzIExpc3Qgb2YgcmVxdWlyZWQgdmlkZW8gY29kZWNzIHRvIHN1cHBvcnRcbiAgICogQHRocm93cyBXaGVuIGEgdW5zdXBwb3J0ZWQgS2V5U3lzdGVtIGlzIHBhc3NlZFxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5fYXR0ZW1wdEtleVN5c3RlbUFjY2VzcyA9IGZ1bmN0aW9uIF9hdHRlbXB0S2V5U3lzdGVtQWNjZXNzKGtleVN5c3RlbSwgYXVkaW9Db2RlY3MsIHZpZGVvQ29kZWNzKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIC8vIFRoaXMgY2FuIHRocm93LCBidXQgaXMgY2F1Z2h0IGluIGV2ZW50IGhhbmRsZXIgY2FsbHBhdGhcbiAgICB2YXIgbWVkaWFLZXlTeXN0ZW1Db25maWdzID0gZ2V0U3VwcG9ydGVkTWVkaWFLZXlTeXN0ZW1Db25maWd1cmF0aW9ucyhrZXlTeXN0ZW0sIGF1ZGlvQ29kZWNzLCB2aWRlb0NvZGVjcywgdGhpcy5fZHJtU3lzdGVtT3B0aW9ucyk7XG4gICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wibG9nZ2VyXCJdLmxvZygnUmVxdWVzdGluZyBlbmNyeXB0ZWQgbWVkaWEga2V5LXN5c3RlbSBhY2Nlc3MnKTsgLy8gZXhwZWN0aW5nIGludGVyZmFjZSBsaWtlIHdpbmRvdy5uYXZpZ2F0b3IucmVxdWVzdE1lZGlhS2V5U3lzdGVtQWNjZXNzXG5cbiAgICB2YXIga2V5U3lzdGVtQWNjZXNzUHJvbWlzZSA9IHRoaXMucmVxdWVzdE1lZGlhS2V5U3lzdGVtQWNjZXNzKGtleVN5c3RlbSwgbWVkaWFLZXlTeXN0ZW1Db25maWdzKTtcbiAgICB0aGlzLm1lZGlhS2V5c1Byb21pc2UgPSBrZXlTeXN0ZW1BY2Nlc3NQcm9taXNlLnRoZW4oZnVuY3Rpb24gKG1lZGlhS2V5U3lzdGVtQWNjZXNzKSB7XG4gICAgICByZXR1cm4gX3RoaXMuX29uTWVkaWFLZXlTeXN0ZW1BY2Nlc3NPYnRhaW5lZChrZXlTeXN0ZW0sIG1lZGlhS2V5U3lzdGVtQWNjZXNzKTtcbiAgICB9KTtcbiAgICBrZXlTeXN0ZW1BY2Nlc3NQcm9taXNlLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImxvZ2dlclwiXS5lcnJvcihcIkZhaWxlZCB0byBvYnRhaW4ga2V5LXN5c3RlbSBcXFwiXCIgKyBrZXlTeXN0ZW0gKyBcIlxcXCIgYWNjZXNzOlwiLCBlcnIpO1xuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBIYW5kbGVzIG9idGFpbmluZyBhY2Nlc3MgdG8gYSBrZXktc3lzdGVtXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlTeXN0ZW1cbiAgICogQHBhcmFtIHtNZWRpYUtleVN5c3RlbUFjY2Vzc30gbWVkaWFLZXlTeXN0ZW1BY2Nlc3MgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL01lZGlhS2V5U3lzdGVtQWNjZXNzXG4gICAqL1xuICBfcHJvdG8uX29uTWVkaWFLZXlTeXN0ZW1BY2Nlc3NPYnRhaW5lZCA9IGZ1bmN0aW9uIF9vbk1lZGlhS2V5U3lzdGVtQWNjZXNzT2J0YWluZWQoa2V5U3lzdGVtLCBtZWRpYUtleVN5c3RlbUFjY2Vzcykge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wibG9nZ2VyXCJdLmxvZyhcIkFjY2VzcyBmb3Iga2V5LXN5c3RlbSBcXFwiXCIgKyBrZXlTeXN0ZW0gKyBcIlxcXCIgb2J0YWluZWRcIik7XG4gICAgdmFyIG1lZGlhS2V5c0xpc3RJdGVtID0ge1xuICAgICAgbWVkaWFLZXlzU2Vzc2lvbkluaXRpYWxpemVkOiBmYWxzZSxcbiAgICAgIG1lZGlhS2V5U3lzdGVtQWNjZXNzOiBtZWRpYUtleVN5c3RlbUFjY2VzcyxcbiAgICAgIG1lZGlhS2V5U3lzdGVtRG9tYWluOiBrZXlTeXN0ZW1cbiAgICB9O1xuXG4gICAgdGhpcy5fbWVkaWFLZXlzTGlzdC5wdXNoKG1lZGlhS2V5c0xpc3RJdGVtKTtcblxuICAgIHZhciBtZWRpYUtleXNQcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbWVkaWFLZXlTeXN0ZW1BY2Nlc3MuY3JlYXRlTWVkaWFLZXlzKCk7XG4gICAgfSkudGhlbihmdW5jdGlvbiAobWVkaWFLZXlzKSB7XG4gICAgICBtZWRpYUtleXNMaXN0SXRlbS5tZWRpYUtleXMgPSBtZWRpYUtleXM7XG4gICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJsb2dnZXJcIl0ubG9nKFwiTWVkaWEta2V5cyBjcmVhdGVkIGZvciBrZXktc3lzdGVtIFxcXCJcIiArIGtleVN5c3RlbSArIFwiXFxcIlwiKTtcblxuICAgICAgX3RoaXMyLl9vbk1lZGlhS2V5c0NyZWF0ZWQoKTtcblxuICAgICAgcmV0dXJuIG1lZGlhS2V5cztcbiAgICB9KTtcbiAgICBtZWRpYUtleXNQcm9taXNlLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImxvZ2dlclwiXS5lcnJvcignRmFpbGVkIHRvIGNyZWF0ZSBtZWRpYS1rZXlzOicsIGVycik7XG4gICAgfSk7XG4gICAgcmV0dXJuIG1lZGlhS2V5c1Byb21pc2U7XG4gIH1cbiAgLyoqXG4gICAqIEhhbmRsZXMga2V5LWNyZWF0aW9uIChyZXByZXNlbnRzIGFjY2VzcyB0byBDRE0pLiBXZSBhcmUgZ29pbmcgdG8gY3JlYXRlIGtleS1zZXNzaW9ucyB1cG9uIHRoaXNcbiAgICogZm9yIGFsbCBleGlzdGluZyBrZXlzIHdoZXJlIG5vIHNlc3Npb24gZXhpc3RzIHlldC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIDtcblxuICBfcHJvdG8uX29uTWVkaWFLZXlzQ3JlYXRlZCA9IGZ1bmN0aW9uIF9vbk1lZGlhS2V5c0NyZWF0ZWQoKSB7XG4gICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAvLyBjaGVjayBmb3IgYWxsIGtleS1saXN0IGl0ZW1zIGlmIGEgc2Vzc2lvbiBleGlzdHMsIG90aGVyd2lzZSwgY3JlYXRlIG9uZVxuICAgIHRoaXMuX21lZGlhS2V5c0xpc3QuZm9yRWFjaChmdW5jdGlvbiAobWVkaWFLZXlzTGlzdEl0ZW0pIHtcbiAgICAgIGlmICghbWVkaWFLZXlzTGlzdEl0ZW0ubWVkaWFLZXlzU2Vzc2lvbikge1xuICAgICAgICAvLyBtZWRpYUtleXMgaXMgZGVmaW5pdGVseSBpbml0aWFsaXplZCBoZXJlXG4gICAgICAgIG1lZGlhS2V5c0xpc3RJdGVtLm1lZGlhS2V5c1Nlc3Npb24gPSBtZWRpYUtleXNMaXN0SXRlbS5tZWRpYUtleXMuY3JlYXRlU2Vzc2lvbigpO1xuXG4gICAgICAgIF90aGlzMy5fb25OZXdNZWRpYUtleVNlc3Npb24obWVkaWFLZXlzTGlzdEl0ZW0ubWVkaWFLZXlzU2Vzc2lvbik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7Kn0ga2V5U2Vzc2lvblxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5fb25OZXdNZWRpYUtleVNlc3Npb24gPSBmdW5jdGlvbiBfb25OZXdNZWRpYUtleVNlc3Npb24oa2V5U2Vzc2lvbikge1xuICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wibG9nZ2VyXCJdLmxvZyhcIk5ldyBrZXktc3lzdGVtIHNlc3Npb24gXCIgKyBrZXlTZXNzaW9uLnNlc3Npb25JZCk7XG4gICAga2V5U2Vzc2lvbi5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBfdGhpczQuX29uS2V5U2Vzc2lvbk1lc3NhZ2Uoa2V5U2Vzc2lvbiwgZXZlbnQubWVzc2FnZSk7XG4gICAgfSwgZmFsc2UpO1xuICB9XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge01lZGlhS2V5U2Vzc2lvbn0ga2V5U2Vzc2lvblxuICAgKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBtZXNzYWdlXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLl9vbktleVNlc3Npb25NZXNzYWdlID0gZnVuY3Rpb24gX29uS2V5U2Vzc2lvbk1lc3NhZ2Uoa2V5U2Vzc2lvbiwgbWVzc2FnZSkge1xuICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImxvZ2dlclwiXS5sb2coJ0dvdCBFTUUgbWVzc2FnZSBldmVudCwgY3JlYXRpbmcgbGljZW5zZSByZXF1ZXN0Jyk7XG5cbiAgICB0aGlzLl9yZXF1ZXN0TGljZW5zZShtZXNzYWdlLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wibG9nZ2VyXCJdLmxvZyhcIlJlY2VpdmVkIGxpY2Vuc2UgZGF0YSAobGVuZ3RoOiBcIiArIChkYXRhID8gZGF0YS5ieXRlTGVuZ3RoIDogZGF0YSkgKyBcIiksIHVwZGF0aW5nIGtleS1zZXNzaW9uXCIpO1xuICAgICAga2V5U2Vzc2lvbi51cGRhdGUoZGF0YSk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSBlIHtNZWRpYUVuY3J5cHRlZEV2ZW50fVxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5vbk1lZGlhRW5jcnlwdGVkID0gZnVuY3Rpb24gb25NZWRpYUVuY3J5cHRlZChlKSB7XG4gICAgdmFyIF90aGlzNSA9IHRoaXM7XG5cbiAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJsb2dnZXJcIl0ubG9nKFwiTWVkaWEgaXMgZW5jcnlwdGVkIHVzaW5nIFxcXCJcIiArIGUuaW5pdERhdGFUeXBlICsgXCJcXFwiIGluaXQgZGF0YSB0eXBlXCIpO1xuXG4gICAgaWYgKCF0aGlzLm1lZGlhS2V5c1Byb21pc2UpIHtcbiAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImxvZ2dlclwiXS5lcnJvcignRmF0YWw6IE1lZGlhIGlzIGVuY3J5cHRlZCBidXQgbm8gQ0RNIGFjY2VzcyBvciBubyBrZXlzIGhhdmUgYmVlbiByZXF1ZXN0ZWQnKTtcbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiRXZlbnRzXCJdLkVSUk9SLCB7XG4gICAgICAgIHR5cGU6IF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkVycm9yVHlwZXNcIl0uS0VZX1NZU1RFTV9FUlJPUixcbiAgICAgICAgZGV0YWlsczogX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXJyb3JEZXRhaWxzXCJdLktFWV9TWVNURU1fTk9fS0VZUyxcbiAgICAgICAgZmF0YWw6IHRydWVcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBmaW5hbGx5U2V0S2V5QW5kU3RhcnRTZXNzaW9uID0gZnVuY3Rpb24gZmluYWxseVNldEtleUFuZFN0YXJ0U2Vzc2lvbihtZWRpYUtleXMpIHtcbiAgICAgIGlmICghX3RoaXM1Ll9tZWRpYSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIF90aGlzNS5fYXR0ZW1wdFNldE1lZGlhS2V5cyhtZWRpYUtleXMpO1xuXG4gICAgICBfdGhpczUuX2dlbmVyYXRlUmVxdWVzdFdpdGhQcmVmZXJyZWRLZXlTZXNzaW9uKGUuaW5pdERhdGFUeXBlLCBlLmluaXREYXRhKTtcbiAgICB9OyAvLyBDb3VsZCB1c2UgYFByb21pc2UuZmluYWxseWAgYnV0IHNvbWUgUHJvbWlzZSBwb2x5ZmlsbHMgYXJlIG1pc3NpbmcgaXRcblxuXG4gICAgdGhpcy5tZWRpYUtleXNQcm9taXNlLnRoZW4oZmluYWxseVNldEtleUFuZFN0YXJ0U2Vzc2lvbikuY2F0Y2goZmluYWxseVNldEtleUFuZFN0YXJ0U2Vzc2lvbik7XG4gIH1cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLl9hdHRlbXB0U2V0TWVkaWFLZXlzID0gZnVuY3Rpb24gX2F0dGVtcHRTZXRNZWRpYUtleXMobWVkaWFLZXlzKSB7XG4gICAgaWYgKCF0aGlzLl9tZWRpYSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBdHRlbXB0ZWQgdG8gc2V0IG1lZGlhS2V5cyB3aXRob3V0IGZpcnN0IGF0dGFjaGluZyBhIG1lZGlhIGVsZW1lbnQnKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuX2hhc1NldE1lZGlhS2V5cykge1xuICAgICAgLy8gRklYTUU6IHNlZSBpZiB3ZSBjYW4vd2FudC9uZWVkLXRvIHJlYWxseSB0byBkZWFsIHdpdGggc2V2ZXJhbCBwb3RlbnRpYWwga2V5LXNlc3Npb25zP1xuICAgICAgdmFyIGtleXNMaXN0SXRlbSA9IHRoaXMuX21lZGlhS2V5c0xpc3RbMF07XG5cbiAgICAgIGlmICgha2V5c0xpc3RJdGVtIHx8ICFrZXlzTGlzdEl0ZW0ubWVkaWFLZXlzKSB7XG4gICAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImxvZ2dlclwiXS5lcnJvcignRmF0YWw6IE1lZGlhIGlzIGVuY3J5cHRlZCBidXQgbm8gQ0RNIGFjY2VzcyBvciBubyBrZXlzIGhhdmUgYmVlbiBvYnRhaW5lZCB5ZXQnKTtcbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJFdmVudHNcIl0uRVJST1IsIHtcbiAgICAgICAgICB0eXBlOiBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFcnJvclR5cGVzXCJdLktFWV9TWVNURU1fRVJST1IsXG4gICAgICAgICAgZGV0YWlsczogX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXJyb3JEZXRhaWxzXCJdLktFWV9TWVNURU1fTk9fS0VZUyxcbiAgICAgICAgICBmYXRhbDogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJsb2dnZXJcIl0ubG9nKCdTZXR0aW5nIGtleXMgZm9yIGVuY3J5cHRlZCBtZWRpYScpO1xuXG4gICAgICB0aGlzLl9tZWRpYS5zZXRNZWRpYUtleXMoa2V5c0xpc3RJdGVtLm1lZGlhS2V5cyk7XG5cbiAgICAgIHRoaXMuX2hhc1NldE1lZGlhS2V5cyA9IHRydWU7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5fZ2VuZXJhdGVSZXF1ZXN0V2l0aFByZWZlcnJlZEtleVNlc3Npb24gPSBmdW5jdGlvbiBfZ2VuZXJhdGVSZXF1ZXN0V2l0aFByZWZlcnJlZEtleVNlc3Npb24oaW5pdERhdGFUeXBlLCBpbml0RGF0YSkge1xuICAgIHZhciBfdGhpczYgPSB0aGlzO1xuXG4gICAgLy8gRklYTUU6IHNlZSBpZiB3ZSBjYW4vd2FudC9uZWVkLXRvIHJlYWxseSB0byBkZWFsIHdpdGggc2V2ZXJhbCBwb3RlbnRpYWwga2V5LXNlc3Npb25zP1xuICAgIHZhciBrZXlzTGlzdEl0ZW0gPSB0aGlzLl9tZWRpYUtleXNMaXN0WzBdO1xuXG4gICAgaWYgKCFrZXlzTGlzdEl0ZW0pIHtcbiAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImxvZ2dlclwiXS5lcnJvcignRmF0YWw6IE1lZGlhIGlzIGVuY3J5cHRlZCBidXQgbm90IGFueSBrZXktc3lzdGVtIGFjY2VzcyBoYXMgYmVlbiBvYnRhaW5lZCB5ZXQnKTtcbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiRXZlbnRzXCJdLkVSUk9SLCB7XG4gICAgICAgIHR5cGU6IF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkVycm9yVHlwZXNcIl0uS0VZX1NZU1RFTV9FUlJPUixcbiAgICAgICAgZGV0YWlsczogX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXJyb3JEZXRhaWxzXCJdLktFWV9TWVNURU1fTk9fQUNDRVNTLFxuICAgICAgICBmYXRhbDogdHJ1ZVxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGtleXNMaXN0SXRlbS5tZWRpYUtleXNTZXNzaW9uSW5pdGlhbGl6ZWQpIHtcbiAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImxvZ2dlclwiXS53YXJuKCdLZXktU2Vzc2lvbiBhbHJlYWR5IGluaXRpYWxpemVkIGJ1dCByZXF1ZXN0ZWQgYWdhaW4nKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIga2V5U2Vzc2lvbiA9IGtleXNMaXN0SXRlbS5tZWRpYUtleXNTZXNzaW9uO1xuXG4gICAgaWYgKCFrZXlTZXNzaW9uKSB7XG4gICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJsb2dnZXJcIl0uZXJyb3IoJ0ZhdGFsOiBNZWRpYSBpcyBlbmNyeXB0ZWQgYnV0IG5vIGtleS1zZXNzaW9uIGV4aXN0aW5nJyk7XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIkV2ZW50c1wiXS5FUlJPUiwge1xuICAgICAgICB0eXBlOiBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFcnJvclR5cGVzXCJdLktFWV9TWVNURU1fRVJST1IsXG4gICAgICAgIGRldGFpbHM6IF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkVycm9yRGV0YWlsc1wiXS5LRVlfU1lTVEVNX05PX1NFU1NJT04sXG4gICAgICAgIGZhdGFsOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIGluaXREYXRhIGlzIG51bGwgaWYgdGhlIG1lZGlhIGlzIG5vdCBDT1JTLXNhbWUtb3JpZ2luXG5cblxuICAgIGlmICghaW5pdERhdGEpIHtcbiAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImxvZ2dlclwiXS53YXJuKCdGYXRhbDogaW5pdERhdGEgcmVxdWlyZWQgZm9yIGdlbmVyYXRpbmcgYSBrZXkgc2Vzc2lvbiBpcyBudWxsJyk7XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIkV2ZW50c1wiXS5FUlJPUiwge1xuICAgICAgICB0eXBlOiBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFcnJvclR5cGVzXCJdLktFWV9TWVNURU1fRVJST1IsXG4gICAgICAgIGRldGFpbHM6IF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkVycm9yRGV0YWlsc1wiXS5LRVlfU1lTVEVNX05PX0lOSVRfREFUQSxcbiAgICAgICAgZmF0YWw6IHRydWVcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImxvZ2dlclwiXS5sb2coXCJHZW5lcmF0aW5nIGtleS1zZXNzaW9uIHJlcXVlc3QgZm9yIFxcXCJcIiArIGluaXREYXRhVHlwZSArIFwiXFxcIiBpbml0IGRhdGEgdHlwZVwiKTtcbiAgICBrZXlzTGlzdEl0ZW0ubWVkaWFLZXlzU2Vzc2lvbkluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICBrZXlTZXNzaW9uLmdlbmVyYXRlUmVxdWVzdChpbml0RGF0YVR5cGUsIGluaXREYXRhKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImxvZ2dlclwiXS5kZWJ1ZygnS2V5LXNlc3Npb24gZ2VuZXJhdGlvbiBzdWNjZWVkZWQnKTtcbiAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJsb2dnZXJcIl0uZXJyb3IoJ0Vycm9yIGdlbmVyYXRpbmcga2V5LXNlc3Npb24gcmVxdWVzdDonLCBlcnIpO1xuXG4gICAgICBfdGhpczYuaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiRXZlbnRzXCJdLkVSUk9SLCB7XG4gICAgICAgIHR5cGU6IF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkVycm9yVHlwZXNcIl0uS0VZX1NZU1RFTV9FUlJPUixcbiAgICAgICAgZGV0YWlsczogX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXJyb3JEZXRhaWxzXCJdLktFWV9TWVNURU1fTk9fU0VTU0lPTixcbiAgICAgICAgZmF0YWw6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHVybCBMaWNlbnNlIHNlcnZlciBVUkxcbiAgICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0ga2V5TWVzc2FnZSBNZXNzYWdlIGRhdGEgaXNzdWVkIGJ5IGtleS1zeXN0ZW1cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIHdoZW4gWEhSIGhhcyBzdWNjZWVkZWRcbiAgICogQHJldHVybnMge1hNTEh0dHBSZXF1ZXN0fSBVbnNlbnQgKGJ1dCBvcGVuZWQgc3RhdGUpIFhIUiBvYmplY3RcbiAgICogQHRocm93cyBpZiBYTUxIdHRwUmVxdWVzdCBjb25zdHJ1Y3Rpb24gZmFpbGVkXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLl9jcmVhdGVMaWNlbnNlWGhyID0gZnVuY3Rpb24gX2NyZWF0ZUxpY2Vuc2VYaHIodXJsLCBrZXlNZXNzYWdlLCBjYWxsYmFjaykge1xuICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJztcbiAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gdGhpcy5fb25MaWNlbnNlUmVxdWVzdFJlYWR5U3RhZ2VDaGFuZ2UuYmluZCh0aGlzLCB4aHIsIHVybCwga2V5TWVzc2FnZSwgY2FsbGJhY2spO1xuICAgIHZhciBsaWNlbnNlWGhyU2V0dXAgPSB0aGlzLl9saWNlbnNlWGhyU2V0dXA7XG5cbiAgICBpZiAobGljZW5zZVhoclNldHVwKSB7XG4gICAgICB0cnkge1xuICAgICAgICBsaWNlbnNlWGhyU2V0dXAuY2FsbCh0aGlzLmhscywgeGhyLCB1cmwpO1xuICAgICAgICBsaWNlbnNlWGhyU2V0dXAgPSB1bmRlZmluZWQ7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImxvZ2dlclwiXS5lcnJvcihlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgLy8gaWYgbGljZW5zZVhoclNldHVwIGRpZCBub3QgeWV0IGNhbGwgb3BlbiwgbGV0J3MgZG8gaXQgbm93XG4gICAgICBpZiAoIXhoci5yZWFkeVN0YXRlKSB7XG4gICAgICAgIHhoci5vcGVuKCdQT1NUJywgdXJsLCB0cnVlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGxpY2Vuc2VYaHJTZXR1cCkge1xuICAgICAgICBsaWNlbnNlWGhyU2V0dXAuY2FsbCh0aGlzLmhscywgeGhyLCB1cmwpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIElFMTEgdGhyb3dzIGFuIGV4Y2VwdGlvbiBvbiB4aHIub3BlbiBpZiBhdHRlbXB0aW5nIHRvIGFjY2VzcyBhbiBIVFRQIHJlc291cmNlIG92ZXIgSFRUUFNcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImlzc3VlIHNldHRpbmcgdXAgS2V5U3lzdGVtIGxpY2Vuc2UgWEhSIFwiICsgZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHhocjtcbiAgfVxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtYTUxIdHRwUmVxdWVzdH0geGhyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgTGljZW5zZSBzZXJ2ZXIgVVJMXG4gICAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGtleU1lc3NhZ2UgTWVzc2FnZSBkYXRhIGlzc3VlZCBieSBrZXktc3lzdGVtXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCB3aGVuIFhIUiBoYXMgc3VjY2VlZGVkXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLl9vbkxpY2Vuc2VSZXF1ZXN0UmVhZHlTdGFnZUNoYW5nZSA9IGZ1bmN0aW9uIF9vbkxpY2Vuc2VSZXF1ZXN0UmVhZHlTdGFnZUNoYW5nZSh4aHIsIHVybCwga2V5TWVzc2FnZSwgY2FsbGJhY2spIHtcbiAgICBzd2l0Y2ggKHhoci5yZWFkeVN0YXRlKSB7XG4gICAgICBjYXNlIDQ6XG4gICAgICAgIGlmICh4aHIuc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgICB0aGlzLl9yZXF1ZXN0TGljZW5zZUZhaWx1cmVDb3VudCA9IDA7XG4gICAgICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wibG9nZ2VyXCJdLmxvZygnTGljZW5zZSByZXF1ZXN0IHN1Y2NlZWRlZCcpO1xuICAgICAgICAgIHZhciBfZGF0YSA9IHhoci5yZXNwb25zZTtcbiAgICAgICAgICB2YXIgbGljZW5zZVJlc3BvbnNlQ2FsbGJhY2sgPSB0aGlzLl9saWNlbnNlUmVzcG9uc2VDYWxsYmFjaztcblxuICAgICAgICAgIGlmIChsaWNlbnNlUmVzcG9uc2VDYWxsYmFjaykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgX2RhdGEgPSBsaWNlbnNlUmVzcG9uc2VDYWxsYmFjay5jYWxsKHRoaXMuaGxzLCB4aHIsIHVybCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImxvZ2dlclwiXS5lcnJvcihlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjYWxsYmFjayhfZGF0YSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wibG9nZ2VyXCJdLmVycm9yKFwiTGljZW5zZSBSZXF1ZXN0IFhIUiBmYWlsZWQgKFwiICsgdXJsICsgXCIpLiBTdGF0dXM6IFwiICsgeGhyLnN0YXR1cyArIFwiIChcIiArIHhoci5zdGF0dXNUZXh0ICsgXCIpXCIpO1xuICAgICAgICAgIHRoaXMuX3JlcXVlc3RMaWNlbnNlRmFpbHVyZUNvdW50Kys7XG5cbiAgICAgICAgICBpZiAodGhpcy5fcmVxdWVzdExpY2Vuc2VGYWlsdXJlQ291bnQgPiBNQVhfTElDRU5TRV9SRVFVRVNUX0ZBSUxVUkVTKSB7XG4gICAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIkV2ZW50c1wiXS5FUlJPUiwge1xuICAgICAgICAgICAgICB0eXBlOiBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFcnJvclR5cGVzXCJdLktFWV9TWVNURU1fRVJST1IsXG4gICAgICAgICAgICAgIGRldGFpbHM6IF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkVycm9yRGV0YWlsc1wiXS5LRVlfU1lTVEVNX0xJQ0VOU0VfUkVRVUVTVF9GQUlMRUQsXG4gICAgICAgICAgICAgIGZhdGFsOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgYXR0ZW1wdHNMZWZ0ID0gTUFYX0xJQ0VOU0VfUkVRVUVTVF9GQUlMVVJFUyAtIHRoaXMuX3JlcXVlc3RMaWNlbnNlRmFpbHVyZUNvdW50ICsgMTtcbiAgICAgICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJsb2dnZXJcIl0ud2FybihcIlJldHJ5aW5nIGxpY2Vuc2UgcmVxdWVzdCwgXCIgKyBhdHRlbXB0c0xlZnQgKyBcIiBhdHRlbXB0cyBsZWZ0XCIpO1xuXG4gICAgICAgICAgdGhpcy5fcmVxdWVzdExpY2Vuc2Uoa2V5TWVzc2FnZSwgY2FsbGJhY2spO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge01lZGlhS2V5c0xpc3RJdGVtfSBrZXlzTGlzdEl0ZW1cbiAgICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0ga2V5TWVzc2FnZVxuICAgKiBAcmV0dXJucyB7QXJyYXlCdWZmZXJ9IENoYWxsZW5nZSBkYXRhIHBvc3RlZCB0byBsaWNlbnNlIHNlcnZlclxuICAgKiBAdGhyb3dzIGlmIEtleVN5c3RlbSBpcyB1bnN1cHBvcnRlZFxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5fZ2VuZXJhdGVMaWNlbnNlUmVxdWVzdENoYWxsZW5nZSA9IGZ1bmN0aW9uIF9nZW5lcmF0ZUxpY2Vuc2VSZXF1ZXN0Q2hhbGxlbmdlKGtleXNMaXN0SXRlbSwga2V5TWVzc2FnZSkge1xuICAgIHN3aXRjaCAoa2V5c0xpc3RJdGVtLm1lZGlhS2V5U3lzdGVtRG9tYWluKSB7XG4gICAgICAvLyBjYXNlIEtleVN5c3RlbXMuUExBWVJFQURZOlxuICAgICAgLy8gZnJvbSBodHRwczovL2dpdGh1Yi5jb20vTWljcm9zb2Z0RWRnZS9EZW1vcy9ibG9iL21hc3Rlci9lbWUvc2NyaXB0cy9kZW1vLmpzXG5cbiAgICAgIC8qXG4gICAgICBpZiAodGhpcy5saWNlbnNlVHlwZSAhPT0gdGhpcy5MSUNFTlNFX1RZUEVfV0lERVZJTkUpIHtcbiAgICAgICAgLy8gRm9yIFBsYXlSZWFkeSBDRE1zLCB3ZSBuZWVkIHRvIGRpZyB0aGUgQ2hhbGxlbmdlIG91dCBvZiB0aGUgWE1MLlxuICAgICAgICB2YXIga2V5TWVzc2FnZVhtbCA9IG5ldyBET01QYXJzZXIoKS5wYXJzZUZyb21TdHJpbmcoU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBuZXcgVWludDE2QXJyYXkoa2V5TWVzc2FnZSkpLCAnYXBwbGljYXRpb24veG1sJyk7XG4gICAgICAgIGlmIChrZXlNZXNzYWdlWG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdDaGFsbGVuZ2UnKVswXSkge1xuICAgICAgICAgICAgY2hhbGxlbmdlID0gYXRvYihrZXlNZXNzYWdlWG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdDaGFsbGVuZ2UnKVswXS5jaGlsZE5vZGVzWzBdLm5vZGVWYWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyAnQ2Fubm90IGZpbmQgPENoYWxsZW5nZT4gaW4ga2V5IG1lc3NhZ2UnO1xuICAgICAgICB9XG4gICAgICAgIHZhciBoZWFkZXJOYW1lcyA9IGtleU1lc3NhZ2VYbWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ25hbWUnKTtcbiAgICAgICAgdmFyIGhlYWRlclZhbHVlcyA9IGtleU1lc3NhZ2VYbWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3ZhbHVlJyk7XG4gICAgICAgIGlmIChoZWFkZXJOYW1lcy5sZW5ndGggIT09IGhlYWRlclZhbHVlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93ICdNaXNtYXRjaGVkIGhlYWRlciA8bmFtZT4vPHZhbHVlPiBwYWlyIGluIGtleSBtZXNzYWdlJztcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhlYWRlck5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihoZWFkZXJOYW1lc1tpXS5jaGlsZE5vZGVzWzBdLm5vZGVWYWx1ZSwgaGVhZGVyVmFsdWVzW2ldLmNoaWxkTm9kZXNbMF0ubm9kZVZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgICAqL1xuICAgICAgY2FzZSBfdXRpbHNfbWVkaWFrZXlzX2hlbHBlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiS2V5U3lzdGVtc1wiXS5XSURFVklORTpcbiAgICAgICAgLy8gRm9yIFdpZGV2aW5lIENETXMsIHRoZSBjaGFsbGVuZ2UgaXMgdGhlIGtleU1lc3NhZ2UuXG4gICAgICAgIHJldHVybiBrZXlNZXNzYWdlO1xuICAgIH1cblxuICAgIHRocm93IG5ldyBFcnJvcihcInVuc3VwcG9ydGVkIGtleS1zeXN0ZW06IFwiICsga2V5c0xpc3RJdGVtLm1lZGlhS2V5U3lzdGVtRG9tYWluKTtcbiAgfVxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIGtleU1lc3NhZ2VcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLl9yZXF1ZXN0TGljZW5zZSA9IGZ1bmN0aW9uIF9yZXF1ZXN0TGljZW5zZShrZXlNZXNzYWdlLCBjYWxsYmFjaykge1xuICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImxvZ2dlclwiXS5sb2coJ1JlcXVlc3RpbmcgY29udGVudCBsaWNlbnNlIGZvciBrZXktc3lzdGVtJyk7XG4gICAgdmFyIGtleXNMaXN0SXRlbSA9IHRoaXMuX21lZGlhS2V5c0xpc3RbMF07XG5cbiAgICBpZiAoIWtleXNMaXN0SXRlbSkge1xuICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wibG9nZ2VyXCJdLmVycm9yKCdGYXRhbCBlcnJvcjogTWVkaWEgaXMgZW5jcnlwdGVkIGJ1dCBubyBrZXktc3lzdGVtIGFjY2VzcyBoYXMgYmVlbiBvYnRhaW5lZCB5ZXQnKTtcbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiRXZlbnRzXCJdLkVSUk9SLCB7XG4gICAgICAgIHR5cGU6IF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkVycm9yVHlwZXNcIl0uS0VZX1NZU1RFTV9FUlJPUixcbiAgICAgICAgZGV0YWlsczogX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXJyb3JEZXRhaWxzXCJdLktFWV9TWVNURU1fTk9fQUNDRVNTLFxuICAgICAgICBmYXRhbDogdHJ1ZVxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHZhciBfdXJsID0gdGhpcy5nZXRMaWNlbnNlU2VydmVyVXJsKGtleXNMaXN0SXRlbS5tZWRpYUtleVN5c3RlbURvbWFpbik7XG5cbiAgICAgIHZhciBfeGhyID0gdGhpcy5fY3JlYXRlTGljZW5zZVhocihfdXJsLCBrZXlNZXNzYWdlLCBjYWxsYmFjayk7XG5cbiAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImxvZ2dlclwiXS5sb2coXCJTZW5kaW5nIGxpY2Vuc2UgcmVxdWVzdCB0byBVUkw6IFwiICsgX3VybCk7XG5cbiAgICAgIHZhciBjaGFsbGVuZ2UgPSB0aGlzLl9nZW5lcmF0ZUxpY2Vuc2VSZXF1ZXN0Q2hhbGxlbmdlKGtleXNMaXN0SXRlbSwga2V5TWVzc2FnZSk7XG5cbiAgICAgIF94aHIuc2VuZChjaGFsbGVuZ2UpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImxvZ2dlclwiXS5lcnJvcihcIkZhaWx1cmUgcmVxdWVzdGluZyBEUk0gbGljZW5zZTogXCIgKyBlKTtcbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiRXZlbnRzXCJdLkVSUk9SLCB7XG4gICAgICAgIHR5cGU6IF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkVycm9yVHlwZXNcIl0uS0VZX1NZU1RFTV9FUlJPUixcbiAgICAgICAgZGV0YWlsczogX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXJyb3JEZXRhaWxzXCJdLktFWV9TWVNURU1fTElDRU5TRV9SRVFVRVNUX0ZBSUxFRCxcbiAgICAgICAgZmF0YWw6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8ub25NZWRpYUF0dGFjaGVkID0gZnVuY3Rpb24gb25NZWRpYUF0dGFjaGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgaWYgKCF0aGlzLl9lbWVFbmFibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG1lZGlhID0gZGF0YS5tZWRpYTsgLy8ga2VlcCByZWZlcmVuY2Ugb2YgbWVkaWFcblxuICAgIHRoaXMuX21lZGlhID0gbWVkaWE7XG4gICAgbWVkaWEuYWRkRXZlbnRMaXN0ZW5lcignZW5jcnlwdGVkJywgdGhpcy5fb25NZWRpYUVuY3J5cHRlZCk7XG4gIH07XG5cbiAgX3Byb3RvLm9uTWVkaWFEZXRhY2hlZCA9IGZ1bmN0aW9uIG9uTWVkaWFEZXRhY2hlZCgpIHtcbiAgICB2YXIgbWVkaWEgPSB0aGlzLl9tZWRpYTtcbiAgICB2YXIgbWVkaWFLZXlzTGlzdCA9IHRoaXMuX21lZGlhS2V5c0xpc3Q7XG5cbiAgICBpZiAoIW1lZGlhKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbWVkaWEucmVtb3ZlRXZlbnRMaXN0ZW5lcignZW5jcnlwdGVkJywgdGhpcy5fb25NZWRpYUVuY3J5cHRlZCk7XG4gICAgdGhpcy5fbWVkaWEgPSBudWxsO1xuICAgIHRoaXMuX21lZGlhS2V5c0xpc3QgPSBbXTsgLy8gQ2xvc2UgYWxsIHNlc3Npb25zIGFuZCByZW1vdmUgbWVkaWEga2V5cyBmcm9tIHRoZSB2aWRlbyBlbGVtZW50LlxuXG4gICAgUHJvbWlzZS5hbGwobWVkaWFLZXlzTGlzdC5tYXAoZnVuY3Rpb24gKG1lZGlhS2V5c0xpc3RJdGVtKSB7XG4gICAgICBpZiAobWVkaWFLZXlzTGlzdEl0ZW0ubWVkaWFLZXlzU2Vzc2lvbikge1xuICAgICAgICByZXR1cm4gbWVkaWFLZXlzTGlzdEl0ZW0ubWVkaWFLZXlzU2Vzc2lvbi5jbG9zZSgpLmNhdGNoKGZ1bmN0aW9uICgpIHsvLyBJZ25vcmUgZXJyb3JzIHdoZW4gY2xvc2luZyB0aGUgc2Vzc2lvbnMuIENsb3NpbmcgYSBzZXNzaW9uIHRoYXRcbiAgICAgICAgICAvLyBnZW5lcmF0ZWQgbm8ga2V5IHJlcXVlc3RzIHdpbGwgdGhyb3cgYW4gZXJyb3IuXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBtZWRpYS5zZXRNZWRpYUtleXMobnVsbCk7XG4gICAgfSkuY2F0Y2goZnVuY3Rpb24gKCkgey8vIElnbm9yZSBhbnkgZmFpbHVyZXMgd2hpbGUgcmVtb3ZpbmcgbWVkaWEga2V5cyBmcm9tIHRoZSB2aWRlbyBlbGVtZW50LlxuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90by5vbk1hbmlmZXN0UGFyc2VkID0gZnVuY3Rpb24gb25NYW5pZmVzdFBhcnNlZChldmVudCwgZGF0YSkge1xuICAgIGlmICghdGhpcy5fZW1lRW5hYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBhdWRpb0NvZGVjcyA9IGRhdGEubGV2ZWxzLm1hcChmdW5jdGlvbiAobGV2ZWwpIHtcbiAgICAgIHJldHVybiBsZXZlbC5hdWRpb0NvZGVjO1xuICAgIH0pLmZpbHRlcihmdW5jdGlvbiAoYXVkaW9Db2RlYykge1xuICAgICAgcmV0dXJuICEhYXVkaW9Db2RlYztcbiAgICB9KTtcbiAgICB2YXIgdmlkZW9Db2RlY3MgPSBkYXRhLmxldmVscy5tYXAoZnVuY3Rpb24gKGxldmVsKSB7XG4gICAgICByZXR1cm4gbGV2ZWwudmlkZW9Db2RlYztcbiAgICB9KS5maWx0ZXIoZnVuY3Rpb24gKHZpZGVvQ29kZWMpIHtcbiAgICAgIHJldHVybiAhIXZpZGVvQ29kZWM7XG4gICAgfSk7XG5cbiAgICB0aGlzLl9hdHRlbXB0S2V5U3lzdGVtQWNjZXNzKF91dGlsc19tZWRpYWtleXNfaGVscGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJLZXlTeXN0ZW1zXCJdLldJREVWSU5FLCBhdWRpb0NvZGVjcywgdmlkZW9Db2RlY3MpO1xuICB9O1xuXG4gIF9jcmVhdGVDbGFzcyhFTUVDb250cm9sbGVyLCBbe1xuICAgIGtleTogXCJyZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3NcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIGlmICghdGhpcy5fcmVxdWVzdE1lZGlhS2V5U3lzdGVtQWNjZXNzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gcmVxdWVzdE1lZGlhS2V5U3lzdGVtQWNjZXNzIGZ1bmN0aW9uIGNvbmZpZ3VyZWQnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3RNZWRpYUtleVN5c3RlbUFjY2VzcztcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRU1FQ29udHJvbGxlcjtcbn0oKTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChFTUVDb250cm9sbGVyKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY29udHJvbGxlci9mcHMtY29udHJvbGxlci50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbnRyb2xsZXIvZnBzLWNvbnRyb2xsZXIudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2V2ZW50cyAqLyBcIi4vc3JjL2V2ZW50cy50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9sb2dnZXIgKi8gXCIuL3NyYy91dGlscy9sb2dnZXIudHNcIik7XG5cblxuXG52YXIgRlBTQ29udHJvbGxlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8vIHN0cmVhbSBjb250cm9sbGVyIG11c3QgYmUgcHJvdmlkZWQgYXMgYSBkZXBlbmRlbmN5IVxuICBmdW5jdGlvbiBGUFNDb250cm9sbGVyKGhscykge1xuICAgIHRoaXMuaGxzID0gdm9pZCAwO1xuICAgIHRoaXMuaXNWaWRlb1BsYXliYWNrUXVhbGl0eUF2YWlsYWJsZSA9IGZhbHNlO1xuICAgIHRoaXMudGltZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5tZWRpYSA9IG51bGw7XG4gICAgdGhpcy5sYXN0VGltZSA9IHZvaWQgMDtcbiAgICB0aGlzLmxhc3REcm9wcGVkRnJhbWVzID0gMDtcbiAgICB0aGlzLmxhc3REZWNvZGVkRnJhbWVzID0gMDtcbiAgICB0aGlzLnN0cmVhbUNvbnRyb2xsZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5obHMgPSBobHM7XG4gICAgdGhpcy5yZWdpc3Rlckxpc3RlbmVycygpO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IEZQU0NvbnRyb2xsZXIucHJvdG90eXBlO1xuXG4gIF9wcm90by5zZXRTdHJlYW1Db250cm9sbGVyID0gZnVuY3Rpb24gc2V0U3RyZWFtQ29udHJvbGxlcihzdHJlYW1Db250cm9sbGVyKSB7XG4gICAgdGhpcy5zdHJlYW1Db250cm9sbGVyID0gc3RyZWFtQ29udHJvbGxlcjtcbiAgfTtcblxuICBfcHJvdG8ucmVnaXN0ZXJMaXN0ZW5lcnMgPSBmdW5jdGlvbiByZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICB0aGlzLmhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJFdmVudHNcIl0uTUVESUFfQVRUQUNISU5HLCB0aGlzLm9uTWVkaWFBdHRhY2hpbmcsIHRoaXMpO1xuICB9O1xuXG4gIF9wcm90by51bnJlZ2lzdGVyTGlzdGVuZXJzID0gZnVuY3Rpb24gdW5yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICB0aGlzLmhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiRXZlbnRzXCJdLk1FRElBX0FUVEFDSElORywgdGhpcy5vbk1lZGlhQXR0YWNoaW5nKTtcbiAgfTtcblxuICBfcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMudGltZXIpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy50aW1lcik7XG4gICAgfVxuXG4gICAgdGhpcy51bnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gICAgdGhpcy5pc1ZpZGVvUGxheWJhY2tRdWFsaXR5QXZhaWxhYmxlID0gZmFsc2U7XG4gICAgdGhpcy5tZWRpYSA9IG51bGw7XG4gIH07XG5cbiAgX3Byb3RvLm9uTWVkaWFBdHRhY2hpbmcgPSBmdW5jdGlvbiBvbk1lZGlhQXR0YWNoaW5nKGV2ZW50LCBkYXRhKSB7XG4gICAgdmFyIGNvbmZpZyA9IHRoaXMuaGxzLmNvbmZpZztcblxuICAgIGlmIChjb25maWcuY2FwTGV2ZWxPbkZQU0Ryb3ApIHtcbiAgICAgIHZhciBtZWRpYSA9IGRhdGEubWVkaWEgaW5zdGFuY2VvZiBzZWxmLkhUTUxWaWRlb0VsZW1lbnQgPyBkYXRhLm1lZGlhIDogbnVsbDtcbiAgICAgIHRoaXMubWVkaWEgPSBtZWRpYTtcblxuICAgICAgaWYgKG1lZGlhICYmIHR5cGVvZiBtZWRpYS5nZXRWaWRlb1BsYXliYWNrUXVhbGl0eSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLmlzVmlkZW9QbGF5YmFja1F1YWxpdHlBdmFpbGFibGUgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBzZWxmLmNsZWFySW50ZXJ2YWwodGhpcy50aW1lcik7XG4gICAgICB0aGlzLnRpbWVyID0gc2VsZi5zZXRJbnRlcnZhbCh0aGlzLmNoZWNrRlBTSW50ZXJ2YWwuYmluZCh0aGlzKSwgY29uZmlnLmZwc0Ryb3BwZWRNb25pdG9yaW5nUGVyaW9kKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmNoZWNrRlBTID0gZnVuY3Rpb24gY2hlY2tGUFModmlkZW8sIGRlY29kZWRGcmFtZXMsIGRyb3BwZWRGcmFtZXMpIHtcbiAgICB2YXIgY3VycmVudFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcblxuICAgIGlmIChkZWNvZGVkRnJhbWVzKSB7XG4gICAgICBpZiAodGhpcy5sYXN0VGltZSkge1xuICAgICAgICB2YXIgY3VycmVudFBlcmlvZCA9IGN1cnJlbnRUaW1lIC0gdGhpcy5sYXN0VGltZTtcbiAgICAgICAgdmFyIGN1cnJlbnREcm9wcGVkID0gZHJvcHBlZEZyYW1lcyAtIHRoaXMubGFzdERyb3BwZWRGcmFtZXM7XG4gICAgICAgIHZhciBjdXJyZW50RGVjb2RlZCA9IGRlY29kZWRGcmFtZXMgLSB0aGlzLmxhc3REZWNvZGVkRnJhbWVzO1xuICAgICAgICB2YXIgZHJvcHBlZEZQUyA9IDEwMDAgKiBjdXJyZW50RHJvcHBlZCAvIGN1cnJlbnRQZXJpb2Q7XG4gICAgICAgIHZhciBobHMgPSB0aGlzLmhscztcbiAgICAgICAgaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiRXZlbnRzXCJdLkZQU19EUk9QLCB7XG4gICAgICAgICAgY3VycmVudERyb3BwZWQ6IGN1cnJlbnREcm9wcGVkLFxuICAgICAgICAgIGN1cnJlbnREZWNvZGVkOiBjdXJyZW50RGVjb2RlZCxcbiAgICAgICAgICB0b3RhbERyb3BwZWRGcmFtZXM6IGRyb3BwZWRGcmFtZXNcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGRyb3BwZWRGUFMgPiAwKSB7XG4gICAgICAgICAgLy8gbG9nZ2VyLmxvZygnY2hlY2tGUFMgOiBkcm9wcGVkRlBTL2RlY29kZWRGUFM6JyArIGRyb3BwZWRGUFMvKDEwMDAgKiBjdXJyZW50RGVjb2RlZCAvIGN1cnJlbnRQZXJpb2QpKTtcbiAgICAgICAgICBpZiAoY3VycmVudERyb3BwZWQgPiBobHMuY29uZmlnLmZwc0Ryb3BwZWRNb25pdG9yaW5nVGhyZXNob2xkICogY3VycmVudERlY29kZWQpIHtcbiAgICAgICAgICAgIHZhciBjdXJyZW50TGV2ZWwgPSBobHMuY3VycmVudExldmVsO1xuICAgICAgICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wibG9nZ2VyXCJdLndhcm4oJ2Ryb3AgRlBTIHJhdGlvIGdyZWF0ZXIgdGhhbiBtYXggYWxsb3dlZCB2YWx1ZSBmb3IgY3VycmVudExldmVsOiAnICsgY3VycmVudExldmVsKTtcblxuICAgICAgICAgICAgaWYgKGN1cnJlbnRMZXZlbCA+IDAgJiYgKGhscy5hdXRvTGV2ZWxDYXBwaW5nID09PSAtMSB8fCBobHMuYXV0b0xldmVsQ2FwcGluZyA+PSBjdXJyZW50TGV2ZWwpKSB7XG4gICAgICAgICAgICAgIGN1cnJlbnRMZXZlbCA9IGN1cnJlbnRMZXZlbCAtIDE7XG4gICAgICAgICAgICAgIGhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIkV2ZW50c1wiXS5GUFNfRFJPUF9MRVZFTF9DQVBQSU5HLCB7XG4gICAgICAgICAgICAgICAgbGV2ZWw6IGN1cnJlbnRMZXZlbCxcbiAgICAgICAgICAgICAgICBkcm9wcGVkTGV2ZWw6IGhscy5jdXJyZW50TGV2ZWxcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGhscy5hdXRvTGV2ZWxDYXBwaW5nID0gY3VycmVudExldmVsO1xuICAgICAgICAgICAgICB0aGlzLnN0cmVhbUNvbnRyb2xsZXIubmV4dExldmVsU3dpdGNoKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMubGFzdFRpbWUgPSBjdXJyZW50VGltZTtcbiAgICAgIHRoaXMubGFzdERyb3BwZWRGcmFtZXMgPSBkcm9wcGVkRnJhbWVzO1xuICAgICAgdGhpcy5sYXN0RGVjb2RlZEZyYW1lcyA9IGRlY29kZWRGcmFtZXM7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5jaGVja0ZQU0ludGVydmFsID0gZnVuY3Rpb24gY2hlY2tGUFNJbnRlcnZhbCgpIHtcbiAgICB2YXIgdmlkZW8gPSB0aGlzLm1lZGlhO1xuXG4gICAgaWYgKHZpZGVvKSB7XG4gICAgICBpZiAodGhpcy5pc1ZpZGVvUGxheWJhY2tRdWFsaXR5QXZhaWxhYmxlKSB7XG4gICAgICAgIHZhciB2aWRlb1BsYXliYWNrUXVhbGl0eSA9IHZpZGVvLmdldFZpZGVvUGxheWJhY2tRdWFsaXR5KCk7XG4gICAgICAgIHRoaXMuY2hlY2tGUFModmlkZW8sIHZpZGVvUGxheWJhY2tRdWFsaXR5LnRvdGFsVmlkZW9GcmFtZXMsIHZpZGVvUGxheWJhY2tRdWFsaXR5LmRyb3BwZWRWaWRlb0ZyYW1lcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBIVE1MVmlkZW9FbGVtZW50IGRvZXNuJ3QgaW5jbHVkZSB0aGUgd2Via2l0IHR5cGVzXG4gICAgICAgIHRoaXMuY2hlY2tGUFModmlkZW8sIHZpZGVvLndlYmtpdERlY29kZWRGcmFtZUNvdW50LCB2aWRlby53ZWJraXREcm9wcGVkRnJhbWVDb3VudCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBGUFNDb250cm9sbGVyO1xufSgpO1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKEZQU0NvbnRyb2xsZXIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9jb250cm9sbGVyL2ZyYWdtZW50LWZpbmRlcnMudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbnRyb2xsZXIvZnJhZ21lbnQtZmluZGVycy50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZmluZEZyYWdtZW50QnlQRFQsIGZpbmRGcmFnbWVudEJ5UFRTLCBmcmFnbWVudFdpdGhpblRvbGVyYW5jZVRlc3QsIHBkdFdpdGhpblRvbGVyYW5jZVRlc3QsIGZpbmRGcmFnV2l0aENDICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImZpbmRGcmFnbWVudEJ5UERUXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZmluZEZyYWdtZW50QnlQRFQ7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImZpbmRGcmFnbWVudEJ5UFRTXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZmluZEZyYWdtZW50QnlQVFM7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImZyYWdtZW50V2l0aGluVG9sZXJhbmNlVGVzdFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGZyYWdtZW50V2l0aGluVG9sZXJhbmNlVGVzdDsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwicGR0V2l0aGluVG9sZXJhbmNlVGVzdFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHBkdFdpdGhpblRvbGVyYW5jZVRlc3Q7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImZpbmRGcmFnV2l0aENDXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZmluZEZyYWdXaXRoQ0M7IH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9ob21lX3J1bm5lcl93b3JrX2hsc19qc19obHNfanNfc3JjX3BvbHlmaWxsc19udW1iZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc3JjL3BvbHlmaWxscy9udW1iZXIgKi8gXCIuL3NyYy9wb2x5ZmlsbHMvbnVtYmVyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19iaW5hcnlfc2VhcmNoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9iaW5hcnktc2VhcmNoICovIFwiLi9zcmMvdXRpbHMvYmluYXJ5LXNlYXJjaC50c1wiKTtcblxuXG5cbi8qKlxuICogUmV0dXJucyBmaXJzdCBmcmFnbWVudCB3aG9zZSBlbmRQZHQgdmFsdWUgZXhjZWVkcyB0aGUgZ2l2ZW4gUERULlxuICogQHBhcmFtIHtBcnJheTxGcmFnbWVudD59IGZyYWdtZW50cyAtIFRoZSBhcnJheSBvZiBjYW5kaWRhdGUgZnJhZ21lbnRzXG4gKiBAcGFyYW0ge251bWJlcnxudWxsfSBbUERUVmFsdWUgPSBudWxsXSAtIFRoZSBQRFQgdmFsdWUgd2hpY2ggbXVzdCBiZSBleGNlZWRlZFxuICogQHBhcmFtIHtudW1iZXJ9IFttYXhGcmFnTG9va1VwVG9sZXJhbmNlID0gMF0gLSBUaGUgYW1vdW50IG9mIHRpbWUgdGhhdCBhIGZyYWdtZW50J3Mgc3RhcnQvZW5kIGNhbiBiZSB3aXRoaW4gaW4gb3JkZXIgdG8gYmUgY29uc2lkZXJlZCBjb250aWd1b3VzXG4gKiBAcmV0dXJucyB7KnxudWxsfSBmcmFnbWVudCAtIFRoZSBiZXN0IG1hdGNoaW5nIGZyYWdtZW50XG4gKi9cbmZ1bmN0aW9uIGZpbmRGcmFnbWVudEJ5UERUKGZyYWdtZW50cywgUERUVmFsdWUsIG1heEZyYWdMb29rVXBUb2xlcmFuY2UpIHtcbiAgaWYgKFBEVFZhbHVlID09PSBudWxsIHx8ICFBcnJheS5pc0FycmF5KGZyYWdtZW50cykgfHwgIWZyYWdtZW50cy5sZW5ndGggfHwgIU9iamVjdChfaG9tZV9ydW5uZXJfd29ya19obHNfanNfaGxzX2pzX3NyY19wb2x5ZmlsbHNfbnVtYmVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJpc0Zpbml0ZU51bWJlclwiXSkoUERUVmFsdWUpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0gLy8gaWYgbGVzcyB0aGFuIHN0YXJ0XG5cblxuICB2YXIgc3RhcnRQRFQgPSBmcmFnbWVudHNbMF0ucHJvZ3JhbURhdGVUaW1lO1xuXG4gIGlmIChQRFRWYWx1ZSA8IChzdGFydFBEVCB8fCAwKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGVuZFBEVCA9IGZyYWdtZW50c1tmcmFnbWVudHMubGVuZ3RoIC0gMV0uZW5kUHJvZ3JhbURhdGVUaW1lO1xuXG4gIGlmIChQRFRWYWx1ZSA+PSAoZW5kUERUIHx8IDApKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBtYXhGcmFnTG9va1VwVG9sZXJhbmNlID0gbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSB8fCAwO1xuXG4gIGZvciAodmFyIHNlZyA9IDA7IHNlZyA8IGZyYWdtZW50cy5sZW5ndGg7ICsrc2VnKSB7XG4gICAgdmFyIGZyYWcgPSBmcmFnbWVudHNbc2VnXTtcblxuICAgIGlmIChwZHRXaXRoaW5Ub2xlcmFuY2VUZXN0KFBEVFZhbHVlLCBtYXhGcmFnTG9va1VwVG9sZXJhbmNlLCBmcmFnKSkge1xuICAgICAgcmV0dXJuIGZyYWc7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG4vKipcbiAqIEZpbmRzIGEgZnJhZ21lbnQgYmFzZWQgb24gdGhlIFNOIG9mIHRoZSBwcmV2aW91cyBmcmFnbWVudDsgb3IgYmFzZWQgb24gdGhlIG5lZWRzIG9mIHRoZSBjdXJyZW50IGJ1ZmZlci5cbiAqIFRoaXMgbWV0aG9kIGNvbXBlbnNhdGVzIGZvciBzbWFsbCBidWZmZXIgZ2FwcyBieSBhcHBseWluZyBhIHRvbGVyYW5jZSB0byB0aGUgc3RhcnQgb2YgYW55IGNhbmRpZGF0ZSBmcmFnbWVudCwgdGh1c1xuICogYnJlYWtpbmcgYW55IHRyYXBzIHdoaWNoIHdvdWxkIGNhdXNlIHRoZSBzYW1lIGZyYWdtZW50IHRvIGJlIGNvbnRpbnVvdXNseSBzZWxlY3RlZCB3aXRoaW4gYSBzbWFsbCByYW5nZS5cbiAqIEBwYXJhbSB7Kn0gZnJhZ1ByZXZpb3VzIC0gVGhlIGxhc3QgZnJhZyBzdWNjZXNzZnVsbHkgYXBwZW5kZWRcbiAqIEBwYXJhbSB7QXJyYXl9IGZyYWdtZW50cyAtIFRoZSBhcnJheSBvZiBjYW5kaWRhdGUgZnJhZ21lbnRzXG4gKiBAcGFyYW0ge251bWJlcn0gW2J1ZmZlckVuZCA9IDBdIC0gVGhlIGVuZCBvZiB0aGUgY29udGlndW91cyBidWZmZXJlZCByYW5nZSB0aGUgcGxheWhlYWQgaXMgY3VycmVudGx5IHdpdGhpblxuICogQHBhcmFtIHtudW1iZXJ9IG1heEZyYWdMb29rVXBUb2xlcmFuY2UgLSBUaGUgYW1vdW50IG9mIHRpbWUgdGhhdCBhIGZyYWdtZW50J3Mgc3RhcnQvZW5kIGNhbiBiZSB3aXRoaW4gaW4gb3JkZXIgdG8gYmUgY29uc2lkZXJlZCBjb250aWd1b3VzXG4gKiBAcmV0dXJucyB7Kn0gZm91bmRGcmFnIC0gVGhlIGJlc3QgbWF0Y2hpbmcgZnJhZ21lbnRcbiAqL1xuXG5mdW5jdGlvbiBmaW5kRnJhZ21lbnRCeVBUUyhmcmFnUHJldmlvdXMsIGZyYWdtZW50cywgYnVmZmVyRW5kLCBtYXhGcmFnTG9va1VwVG9sZXJhbmNlKSB7XG4gIGlmIChidWZmZXJFbmQgPT09IHZvaWQgMCkge1xuICAgIGJ1ZmZlckVuZCA9IDA7XG4gIH1cblxuICBpZiAobWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSA9PT0gdm9pZCAwKSB7XG4gICAgbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSA9IDA7XG4gIH1cblxuICB2YXIgZnJhZ05leHQgPSBudWxsO1xuXG4gIGlmIChmcmFnUHJldmlvdXMpIHtcbiAgICBmcmFnTmV4dCA9IGZyYWdtZW50c1tmcmFnUHJldmlvdXMuc24gLSBmcmFnbWVudHNbMF0uc24gKyAxXSB8fCBudWxsO1xuICB9IGVsc2UgaWYgKGJ1ZmZlckVuZCA9PT0gMCAmJiBmcmFnbWVudHNbMF0uc3RhcnQgPT09IDApIHtcbiAgICBmcmFnTmV4dCA9IGZyYWdtZW50c1swXTtcbiAgfSAvLyBQcmVmZXIgdGhlIG5leHQgZnJhZ21lbnQgaWYgaXQncyB3aXRoaW4gdG9sZXJhbmNlXG5cblxuICBpZiAoZnJhZ05leHQgJiYgZnJhZ21lbnRXaXRoaW5Ub2xlcmFuY2VUZXN0KGJ1ZmZlckVuZCwgbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSwgZnJhZ05leHQpID09PSAwKSB7XG4gICAgcmV0dXJuIGZyYWdOZXh0O1xuICB9IC8vIFdlIG1pZ2h0IGJlIHNlZWtpbmcgcGFzdCB0aGUgdG9sZXJhbmNlIHNvIGZpbmQgdGhlIGJlc3QgbWF0Y2hcblxuXG4gIHZhciBmb3VuZEZyYWdtZW50ID0gX3V0aWxzX2JpbmFyeV9zZWFyY2hfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImRlZmF1bHRcIl0uc2VhcmNoKGZyYWdtZW50cywgZnJhZ21lbnRXaXRoaW5Ub2xlcmFuY2VUZXN0LmJpbmQobnVsbCwgYnVmZmVyRW5kLCBtYXhGcmFnTG9va1VwVG9sZXJhbmNlKSk7XG5cbiAgaWYgKGZvdW5kRnJhZ21lbnQpIHtcbiAgICByZXR1cm4gZm91bmRGcmFnbWVudDtcbiAgfSAvLyBJZiBubyBtYXRjaCB3YXMgZm91bmQgcmV0dXJuIHRoZSBuZXh0IGZyYWdtZW50IGFmdGVyIGZyYWdQcmV2aW91cywgb3IgbnVsbFxuXG5cbiAgcmV0dXJuIGZyYWdOZXh0O1xufVxuLyoqXG4gKiBUaGUgdGVzdCBmdW5jdGlvbiB1c2VkIGJ5IHRoZSBmaW5kRnJhZ21lbnRCeVNuJ3MgQmluYXJ5U2VhcmNoIHRvIGxvb2sgZm9yIHRoZSBiZXN0IG1hdGNoIHRvIHRoZSBjdXJyZW50IGJ1ZmZlciBjb25kaXRpb25zLlxuICogQHBhcmFtIHsqfSBjYW5kaWRhdGUgLSBUaGUgZnJhZ21lbnQgdG8gdGVzdFxuICogQHBhcmFtIHtudW1iZXJ9IFtidWZmZXJFbmQgPSAwXSAtIFRoZSBlbmQgb2YgdGhlIGN1cnJlbnQgYnVmZmVyZWQgcmFuZ2UgdGhlIHBsYXloZWFkIGlzIGN1cnJlbnRseSB3aXRoaW5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSA9IDBdIC0gVGhlIGFtb3VudCBvZiB0aW1lIHRoYXQgYSBmcmFnbWVudCdzIHN0YXJ0IGNhbiBiZSB3aXRoaW4gaW4gb3JkZXIgdG8gYmUgY29uc2lkZXJlZCBjb250aWd1b3VzXG4gKiBAcmV0dXJucyB7bnVtYmVyfSAtIDAgaWYgaXQgbWF0Y2hlcywgMSBpZiB0b28gbG93LCAtMSBpZiB0b28gaGlnaFxuICovXG5cbmZ1bmN0aW9uIGZyYWdtZW50V2l0aGluVG9sZXJhbmNlVGVzdChidWZmZXJFbmQsIG1heEZyYWdMb29rVXBUb2xlcmFuY2UsIGNhbmRpZGF0ZSkge1xuICBpZiAoYnVmZmVyRW5kID09PSB2b2lkIDApIHtcbiAgICBidWZmZXJFbmQgPSAwO1xuICB9XG5cbiAgaWYgKG1heEZyYWdMb29rVXBUb2xlcmFuY2UgPT09IHZvaWQgMCkge1xuICAgIG1heEZyYWdMb29rVXBUb2xlcmFuY2UgPSAwO1xuICB9XG5cbiAgLy8gb2Zmc2V0IHNob3VsZCBiZSB3aXRoaW4gZnJhZ21lbnQgYm91bmRhcnkgLSBjb25maWcubWF4RnJhZ0xvb2tVcFRvbGVyYW5jZVxuICAvLyB0aGlzIGlzIHRvIGNvcGUgd2l0aCBzaXR1YXRpb25zIGxpa2VcbiAgLy8gYnVmZmVyRW5kID0gOS45OTFcbiAgLy8gZnJhZ1vDmF0gOiBbMCwxMF1cbiAgLy8gZnJhZ1sxXSA6IFsxMCwyMF1cbiAgLy8gYnVmZmVyRW5kIGlzIHdpdGhpbiBmcmFnWzBdIHJhbmdlIC4uLiBhbHRob3VnaCB3aGF0IHdlIGFyZSBleHBlY3RpbmcgaXMgdG8gcmV0dXJuIGZyYWdbMV0gaGVyZVxuICAvLyAgICAgICAgICAgICAgZnJhZyBzdGFydCAgICAgICAgICAgICAgIGZyYWcgc3RhcnQrZHVyYXRpb25cbiAgLy8gICAgICAgICAgICAgICAgICB8LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18XG4gIC8vICAgICAgICAgICAgICA8LS0tPiAgICAgICAgICAgICAgICAgICAgICAgICA8LS0tPlxuICAvLyAgLi4uLS0tLS0tLS0+PC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tPjwtLS0tLS0tLS0uLi4uXG4gIC8vIHByZXZpb3VzIGZyYWcgICAgICAgICBtYXRjaGluZyBmcmFnbWVudCAgICAgICAgIG5leHQgZnJhZ1xuICAvLyAgcmV0dXJuIC0xICAgICAgICAgICAgIHJldHVybiAwICAgICAgICAgICAgICAgICByZXR1cm4gMVxuICAvLyBsb2dnZXIubG9nKGBsZXZlbC9zbi9zdGFydC9lbmQvYnVmRW5kOiR7bGV2ZWx9LyR7Y2FuZGlkYXRlLnNufS8ke2NhbmRpZGF0ZS5zdGFydH0vJHsoY2FuZGlkYXRlLnN0YXJ0K2NhbmRpZGF0ZS5kdXJhdGlvbil9LyR7YnVmZmVyRW5kfWApO1xuICAvLyBTZXQgdGhlIGxvb2t1cCB0b2xlcmFuY2UgdG8gYmUgc21hbGwgZW5vdWdoIHRvIGRldGVjdCB0aGUgY3VycmVudCBzZWdtZW50IC0gZW5zdXJlcyB3ZSBkb24ndCBza2lwIG92ZXIgdmVyeSBzbWFsbCBzZWdtZW50c1xuICB2YXIgY2FuZGlkYXRlTG9va3VwVG9sZXJhbmNlID0gTWF0aC5taW4obWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSwgY2FuZGlkYXRlLmR1cmF0aW9uICsgKGNhbmRpZGF0ZS5kZWx0YVBUUyA/IGNhbmRpZGF0ZS5kZWx0YVBUUyA6IDApKTtcblxuICBpZiAoY2FuZGlkYXRlLnN0YXJ0ICsgY2FuZGlkYXRlLmR1cmF0aW9uIC0gY2FuZGlkYXRlTG9va3VwVG9sZXJhbmNlIDw9IGJ1ZmZlckVuZCkge1xuICAgIHJldHVybiAxO1xuICB9IGVsc2UgaWYgKGNhbmRpZGF0ZS5zdGFydCAtIGNhbmRpZGF0ZUxvb2t1cFRvbGVyYW5jZSA+IGJ1ZmZlckVuZCAmJiBjYW5kaWRhdGUuc3RhcnQpIHtcbiAgICAvLyBpZiBtYXhGcmFnTG9va1VwVG9sZXJhbmNlIHdpbGwgaGF2ZSBuZWdhdGl2ZSB2YWx1ZSB0aGVuIGRvbid0IHJldHVybiAtMSBmb3IgZmlyc3QgZWxlbWVudFxuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIHJldHVybiAwO1xufVxuLyoqXG4gKiBUaGUgdGVzdCBmdW5jdGlvbiB1c2VkIGJ5IHRoZSBmaW5kRnJhZ21lbnRCeVBkdCdzIEJpbmFyeVNlYXJjaCB0byBsb29rIGZvciB0aGUgYmVzdCBtYXRjaCB0byB0aGUgY3VycmVudCBidWZmZXIgY29uZGl0aW9ucy5cbiAqIFRoaXMgZnVuY3Rpb24gdGVzdHMgdGhlIGNhbmRpZGF0ZSdzIHByb2dyYW0gZGF0ZSB0aW1lIHZhbHVlcywgYXMgcmVwcmVzZW50ZWQgaW4gVW5peCB0aW1lXG4gKiBAcGFyYW0geyp9IGNhbmRpZGF0ZSAtIFRoZSBmcmFnbWVudCB0byB0ZXN0XG4gKiBAcGFyYW0ge251bWJlcn0gW3BkdEJ1ZmZlckVuZCA9IDBdIC0gVGhlIFVuaXggdGltZSByZXByZXNlbnRpbmcgdGhlIGVuZCBvZiB0aGUgY3VycmVudCBidWZmZXJlZCByYW5nZVxuICogQHBhcmFtIHtudW1iZXJ9IFttYXhGcmFnTG9va1VwVG9sZXJhbmNlID0gMF0gLSBUaGUgYW1vdW50IG9mIHRpbWUgdGhhdCBhIGZyYWdtZW50J3Mgc3RhcnQgY2FuIGJlIHdpdGhpbiBpbiBvcmRlciB0byBiZSBjb25zaWRlcmVkIGNvbnRpZ3VvdXNcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIGNvbnRpZ3VvdXMsIGZhbHNlIG90aGVyd2lzZVxuICovXG5cbmZ1bmN0aW9uIHBkdFdpdGhpblRvbGVyYW5jZVRlc3QocGR0QnVmZmVyRW5kLCBtYXhGcmFnTG9va1VwVG9sZXJhbmNlLCBjYW5kaWRhdGUpIHtcbiAgdmFyIGNhbmRpZGF0ZUxvb2t1cFRvbGVyYW5jZSA9IE1hdGgubWluKG1heEZyYWdMb29rVXBUb2xlcmFuY2UsIGNhbmRpZGF0ZS5kdXJhdGlvbiArIChjYW5kaWRhdGUuZGVsdGFQVFMgPyBjYW5kaWRhdGUuZGVsdGFQVFMgOiAwKSkgKiAxMDAwOyAvLyBlbmRQcm9ncmFtRGF0ZVRpbWUgY2FuIGJlIG51bGwsIGRlZmF1bHQgdG8gemVyb1xuXG4gIHZhciBlbmRQcm9ncmFtRGF0ZVRpbWUgPSBjYW5kaWRhdGUuZW5kUHJvZ3JhbURhdGVUaW1lIHx8IDA7XG4gIHJldHVybiBlbmRQcm9ncmFtRGF0ZVRpbWUgLSBjYW5kaWRhdGVMb29rdXBUb2xlcmFuY2UgPiBwZHRCdWZmZXJFbmQ7XG59XG5mdW5jdGlvbiBmaW5kRnJhZ1dpdGhDQyhmcmFnbWVudHMsIGNjKSB7XG4gIHJldHVybiBfdXRpbHNfYmluYXJ5X3NlYXJjaF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiZGVmYXVsdFwiXS5zZWFyY2goZnJhZ21lbnRzLCBmdW5jdGlvbiAoY2FuZGlkYXRlKSB7XG4gICAgaWYgKGNhbmRpZGF0ZS5jYyA8IGNjKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9IGVsc2UgaWYgKGNhbmRpZGF0ZS5jYyA+IGNjKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NvbnRyb2xsZXIvZnJhZ21lbnQtdHJhY2tlci50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvY29udHJvbGxlci9mcmFnbWVudC10cmFja2VyLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBGcmFnbWVudFN0YXRlLCBGcmFnbWVudFRyYWNrZXIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiRnJhZ21lbnRTdGF0ZVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIEZyYWdtZW50U3RhdGU7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIkZyYWdtZW50VHJhY2tlclwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIEZyYWdtZW50VHJhY2tlcjsgfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZXZlbnRzICovIFwiLi9zcmMvZXZlbnRzLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF90eXBlc19sb2FkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3R5cGVzL2xvYWRlciAqLyBcIi4vc3JjL3R5cGVzL2xvYWRlci50c1wiKTtcblxuXG52YXIgRnJhZ21lbnRTdGF0ZTtcblxuKGZ1bmN0aW9uIChGcmFnbWVudFN0YXRlKSB7XG4gIEZyYWdtZW50U3RhdGVbXCJOT1RfTE9BREVEXCJdID0gXCJOT1RfTE9BREVEXCI7XG4gIEZyYWdtZW50U3RhdGVbXCJCQUNLVFJBQ0tFRFwiXSA9IFwiQkFDS1RSQUNLRURcIjtcbiAgRnJhZ21lbnRTdGF0ZVtcIkFQUEVORElOR1wiXSA9IFwiQVBQRU5ESU5HXCI7XG4gIEZyYWdtZW50U3RhdGVbXCJQQVJUSUFMXCJdID0gXCJQQVJUSUFMXCI7XG4gIEZyYWdtZW50U3RhdGVbXCJPS1wiXSA9IFwiT0tcIjtcbn0pKEZyYWdtZW50U3RhdGUgfHwgKEZyYWdtZW50U3RhdGUgPSB7fSkpO1xuXG52YXIgRnJhZ21lbnRUcmFja2VyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRnJhZ21lbnRUcmFja2VyKGhscykge1xuICAgIHRoaXMuYWN0aXZlRnJhZ21lbnQgPSBudWxsO1xuICAgIHRoaXMuYWN0aXZlUGFydHMgPSBudWxsO1xuICAgIHRoaXMuZnJhZ21lbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLnRpbWVSYW5nZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuYnVmZmVyUGFkZGluZyA9IDAuMjtcbiAgICB0aGlzLmhscyA9IHZvaWQgMDtcbiAgICB0aGlzLmhscyA9IGhscztcblxuICAgIHRoaXMuX3JlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gRnJhZ21lbnRUcmFja2VyLnByb3RvdHlwZTtcblxuICBfcHJvdG8uX3JlZ2lzdGVyTGlzdGVuZXJzID0gZnVuY3Rpb24gX3JlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIHZhciBobHMgPSB0aGlzLmhscztcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiRXZlbnRzXCJdLkJVRkZFUl9BUFBFTkRFRCwgdGhpcy5vbkJ1ZmZlckFwcGVuZGVkLCB0aGlzKTtcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiRXZlbnRzXCJdLkZSQUdfQlVGRkVSRUQsIHRoaXMub25GcmFnQnVmZmVyZWQsIHRoaXMpO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJFdmVudHNcIl0uRlJBR19MT0FERUQsIHRoaXMub25GcmFnTG9hZGVkLCB0aGlzKTtcbiAgfTtcblxuICBfcHJvdG8uX3VucmVnaXN0ZXJMaXN0ZW5lcnMgPSBmdW5jdGlvbiBfdW5yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICB2YXIgaGxzID0gdGhpcy5obHM7XG4gICAgaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJFdmVudHNcIl0uQlVGRkVSX0FQUEVOREVELCB0aGlzLm9uQnVmZmVyQXBwZW5kZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiRXZlbnRzXCJdLkZSQUdfQlVGRkVSRUQsIHRoaXMub25GcmFnQnVmZmVyZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiRXZlbnRzXCJdLkZSQUdfTE9BREVELCB0aGlzLm9uRnJhZ0xvYWRlZCwgdGhpcyk7XG4gIH07XG5cbiAgX3Byb3RvLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgIHRoaXMuX3VucmVnaXN0ZXJMaXN0ZW5lcnMoKTsgLy8gQHRzLWlnbm9yZVxuXG5cbiAgICB0aGlzLmZyYWdtZW50cyA9IHRoaXMudGltZVJhbmdlcyA9IG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiBhIEZyYWdtZW50IHdpdGggYW4gYXBwZW5kZWQgcmFuZ2UgdGhhdCBtYXRjaGVzIHRoZSBwb3NpdGlvbiBhbmQgbGV2ZWxUeXBlLlxuICAgKiBJZiBub3QgZm91bmQgYW55IEZyYWdtZW50LCByZXR1cm4gbnVsbFxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5nZXRBcHBlbmRlZEZyYWcgPSBmdW5jdGlvbiBnZXRBcHBlbmRlZEZyYWcocG9zaXRpb24sIGxldmVsVHlwZSkge1xuICAgIGlmIChsZXZlbFR5cGUgPT09IF90eXBlc19sb2FkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIlBsYXlsaXN0TGV2ZWxUeXBlXCJdLk1BSU4pIHtcbiAgICAgIHZhciBhY3RpdmVGcmFnbWVudCA9IHRoaXMuYWN0aXZlRnJhZ21lbnQsXG4gICAgICAgICAgYWN0aXZlUGFydHMgPSB0aGlzLmFjdGl2ZVBhcnRzO1xuXG4gICAgICBpZiAoIWFjdGl2ZUZyYWdtZW50KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBpZiAoYWN0aXZlUGFydHMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IGFjdGl2ZVBhcnRzLmxlbmd0aDsgaS0tOykge1xuICAgICAgICAgIHZhciBhY3RpdmVQYXJ0ID0gYWN0aXZlUGFydHNbaV07XG4gICAgICAgICAgdmFyIGFwcGVuZGVkUFRTID0gYWN0aXZlUGFydCA/IGFjdGl2ZVBhcnQuZW5kIDogYWN0aXZlRnJhZ21lbnQuYXBwZW5kZWRQVFM7XG5cbiAgICAgICAgICBpZiAoYWN0aXZlUGFydC5zdGFydCA8PSBwb3NpdGlvbiAmJiBhcHBlbmRlZFBUUyAhPT0gdW5kZWZpbmVkICYmIHBvc2l0aW9uIDw9IGFwcGVuZGVkUFRTKSB7XG4gICAgICAgICAgICAvLyA5IGlzIGEgbWFnaWMgbnVtYmVyLiByZW1vdmUgcGFydHMgZnJvbSBsb29rdXAgYWZ0ZXIgYSBtYXRjaCBidXQga2VlcCBzb21lIHNob3J0IHNlZWtzIGJhY2suXG4gICAgICAgICAgICBpZiAoaSA+IDkpIHtcbiAgICAgICAgICAgICAgdGhpcy5hY3RpdmVQYXJ0cyA9IGFjdGl2ZVBhcnRzLnNsaWNlKGkgLSA5KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGFjdGl2ZVBhcnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGFjdGl2ZUZyYWdtZW50LnN0YXJ0IDw9IHBvc2l0aW9uICYmIGFjdGl2ZUZyYWdtZW50LmFwcGVuZGVkUFRTICE9PSB1bmRlZmluZWQgJiYgcG9zaXRpb24gPD0gYWN0aXZlRnJhZ21lbnQuYXBwZW5kZWRQVFMpIHtcbiAgICAgICAgcmV0dXJuIGFjdGl2ZUZyYWdtZW50O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmdldEJ1ZmZlcmVkRnJhZyhwb3NpdGlvbiwgbGV2ZWxUeXBlKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIGEgYnVmZmVyZWQgRnJhZ21lbnQgdGhhdCBtYXRjaGVzIHRoZSBwb3NpdGlvbiBhbmQgbGV2ZWxUeXBlLlxuICAgKiBBIGJ1ZmZlcmVkIEZyYWdtZW50IGlzIG9uZSB3aG9zZSBsb2FkaW5nLCBwYXJzaW5nIGFuZCBhcHBlbmRpbmcgaXMgZG9uZSAoY29tcGxldGVkIG9yIFwicGFydGlhbFwiIG1lYW5pbmcgYWJvcnRlZCkuXG4gICAqIElmIG5vdCBmb3VuZCBhbnkgRnJhZ21lbnQsIHJldHVybiBudWxsXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmdldEJ1ZmZlcmVkRnJhZyA9IGZ1bmN0aW9uIGdldEJ1ZmZlcmVkRnJhZyhwb3NpdGlvbiwgbGV2ZWxUeXBlKSB7XG4gICAgdmFyIGZyYWdtZW50cyA9IHRoaXMuZnJhZ21lbnRzO1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZnJhZ21lbnRzKTtcblxuICAgIGZvciAodmFyIGkgPSBrZXlzLmxlbmd0aDsgaS0tOykge1xuICAgICAgdmFyIGZyYWdtZW50RW50aXR5ID0gZnJhZ21lbnRzW2tleXNbaV1dO1xuXG4gICAgICBpZiAoKGZyYWdtZW50RW50aXR5ID09PSBudWxsIHx8IGZyYWdtZW50RW50aXR5ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmcmFnbWVudEVudGl0eS5ib2R5LnR5cGUpID09PSBsZXZlbFR5cGUgJiYgZnJhZ21lbnRFbnRpdHkuYnVmZmVyZWQpIHtcbiAgICAgICAgdmFyIGZyYWcgPSBmcmFnbWVudEVudGl0eS5ib2R5O1xuXG4gICAgICAgIGlmIChmcmFnLnN0YXJ0IDw9IHBvc2l0aW9uICYmIHBvc2l0aW9uIDw9IGZyYWcuZW5kKSB7XG4gICAgICAgICAgcmV0dXJuIGZyYWc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICAvKipcbiAgICogUGFydGlhbCBmcmFnbWVudHMgZWZmZWN0ZWQgYnkgY29kZWQgZnJhbWUgZXZpY3Rpb24gd2lsbCBiZSByZW1vdmVkXG4gICAqIFRoZSBicm93c2VyIHdpbGwgdW5sb2FkIHBhcnRzIG9mIHRoZSBidWZmZXIgdG8gZnJlZSB1cCBtZW1vcnkgZm9yIG5ldyBidWZmZXIgZGF0YVxuICAgKiBGcmFnbWVudHMgd2lsbCBuZWVkIHRvIGJlIHJlbG9hZGVkIHdoZW4gdGhlIGJ1ZmZlciBpcyBmcmVlZCB1cCwgcmVtb3ZpbmcgcGFydGlhbCBmcmFnbWVudHMgd2lsbCBhbGxvdyB0aGVtIHRvIHJlbG9hZChzaW5jZSB0aGVyZSBtaWdodCBiZSBwYXJ0cyB0aGF0IGFyZSBzdGlsbCBwbGF5YWJsZSlcbiAgICovXG4gIDtcblxuICBfcHJvdG8uZGV0ZWN0RXZpY3RlZEZyYWdtZW50cyA9IGZ1bmN0aW9uIGRldGVjdEV2aWN0ZWRGcmFnbWVudHMoZWxlbWVudGFyeVN0cmVhbSwgdGltZVJhbmdlLCBwbGF5bGlzdFR5cGUpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgLy8gQ2hlY2sgaWYgYW55IGZsYWdnZWQgZnJhZ21lbnRzIGhhdmUgYmVlbiB1bmxvYWRlZFxuICAgIE9iamVjdC5rZXlzKHRoaXMuZnJhZ21lbnRzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHZhciBmcmFnbWVudEVudGl0eSA9IF90aGlzLmZyYWdtZW50c1trZXldO1xuXG4gICAgICBpZiAoIWZyYWdtZW50RW50aXR5KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKCFmcmFnbWVudEVudGl0eS5idWZmZXJlZCkge1xuICAgICAgICBpZiAoZnJhZ21lbnRFbnRpdHkuYm9keS50eXBlID09PSBwbGF5bGlzdFR5cGUpIHtcbiAgICAgICAgICBfdGhpcy5yZW1vdmVGcmFnbWVudChmcmFnbWVudEVudGl0eS5ib2R5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGVzRGF0YSA9IGZyYWdtZW50RW50aXR5LnJhbmdlW2VsZW1lbnRhcnlTdHJlYW1dO1xuXG4gICAgICBpZiAoIWVzRGF0YSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGVzRGF0YS50aW1lLnNvbWUoZnVuY3Rpb24gKHRpbWUpIHtcbiAgICAgICAgdmFyIGlzTm90QnVmZmVyZWQgPSAhX3RoaXMuaXNUaW1lQnVmZmVyZWQodGltZS5zdGFydFBUUywgdGltZS5lbmRQVFMsIHRpbWVSYW5nZSk7XG5cbiAgICAgICAgaWYgKGlzTm90QnVmZmVyZWQpIHtcbiAgICAgICAgICAvLyBVbnJlZ2lzdGVyIHBhcnRpYWwgZnJhZ21lbnQgYXMgaXQgbmVlZHMgdG8gbG9hZCBhZ2FpbiB0byBiZSByZXVzZWRcbiAgICAgICAgICBfdGhpcy5yZW1vdmVGcmFnbWVudChmcmFnbWVudEVudGl0eS5ib2R5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpc05vdEJ1ZmZlcmVkO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgZnJhZ21lbnQgcGFzc2VkIGluIGlzIGxvYWRlZCBpbiB0aGUgYnVmZmVyIHByb3Blcmx5XG4gICAqIFBhcnRpYWxseSBsb2FkZWQgZnJhZ21lbnRzIHdpbGwgYmUgcmVnaXN0ZXJlZCBhcyBhIHBhcnRpYWwgZnJhZ21lbnRcbiAgICovXG4gIDtcblxuICBfcHJvdG8uZGV0ZWN0UGFydGlhbEZyYWdtZW50cyA9IGZ1bmN0aW9uIGRldGVjdFBhcnRpYWxGcmFnbWVudHMoZGF0YSkge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgdmFyIHRpbWVSYW5nZXMgPSB0aGlzLnRpbWVSYW5nZXM7XG4gICAgdmFyIGZyYWcgPSBkYXRhLmZyYWcsXG4gICAgICAgIHBhcnQgPSBkYXRhLnBhcnQ7XG5cbiAgICBpZiAoIXRpbWVSYW5nZXMgfHwgZnJhZy5zbiA9PT0gJ2luaXRTZWdtZW50Jykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBmcmFnS2V5ID0gZ2V0RnJhZ21lbnRLZXkoZnJhZyk7XG4gICAgdmFyIGZyYWdtZW50RW50aXR5ID0gdGhpcy5mcmFnbWVudHNbZnJhZ0tleV07XG5cbiAgICBpZiAoIWZyYWdtZW50RW50aXR5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgT2JqZWN0LmtleXModGltZVJhbmdlcykuZm9yRWFjaChmdW5jdGlvbiAoZWxlbWVudGFyeVN0cmVhbSkge1xuICAgICAgdmFyIHN0cmVhbUluZm8gPSBmcmFnLmVsZW1lbnRhcnlTdHJlYW1zW2VsZW1lbnRhcnlTdHJlYW1dO1xuXG4gICAgICBpZiAoIXN0cmVhbUluZm8pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgdGltZVJhbmdlID0gdGltZVJhbmdlc1tlbGVtZW50YXJ5U3RyZWFtXTtcbiAgICAgIHZhciBwYXJ0aWFsID0gcGFydCAhPT0gbnVsbCB8fCBzdHJlYW1JbmZvLnBhcnRpYWwgPT09IHRydWU7XG4gICAgICBmcmFnbWVudEVudGl0eS5yYW5nZVtlbGVtZW50YXJ5U3RyZWFtXSA9IF90aGlzMi5nZXRCdWZmZXJlZFRpbWVzKGZyYWcsIHBhcnQsIHBhcnRpYWwsIHRpbWVSYW5nZSk7XG4gICAgfSk7XG4gICAgZnJhZ21lbnRFbnRpdHkuYmFja3RyYWNrID0gZnJhZ21lbnRFbnRpdHkubG9hZGVkID0gbnVsbDtcblxuICAgIGlmIChPYmplY3Qua2V5cyhmcmFnbWVudEVudGl0eS5yYW5nZSkubGVuZ3RoKSB7XG4gICAgICBmcmFnbWVudEVudGl0eS5idWZmZXJlZCA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHJlbW92ZSBmcmFnbWVudCBpZiBub3RoaW5nIHdhcyBhcHBlbmRlZFxuICAgICAgdGhpcy5yZW1vdmVGcmFnbWVudChmcmFnbWVudEVudGl0eS5ib2R5KTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmZyYWdCdWZmZXJlZCA9IGZ1bmN0aW9uIGZyYWdCdWZmZXJlZChmcmFnKSB7XG4gICAgdmFyIGZyYWdLZXkgPSBnZXRGcmFnbWVudEtleShmcmFnKTtcbiAgICB2YXIgZnJhZ21lbnRFbnRpdHkgPSB0aGlzLmZyYWdtZW50c1tmcmFnS2V5XTtcblxuICAgIGlmIChmcmFnbWVudEVudGl0eSkge1xuICAgICAgZnJhZ21lbnRFbnRpdHkuYmFja3RyYWNrID0gZnJhZ21lbnRFbnRpdHkubG9hZGVkID0gbnVsbDtcbiAgICAgIGZyYWdtZW50RW50aXR5LmJ1ZmZlcmVkID0gdHJ1ZTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmdldEJ1ZmZlcmVkVGltZXMgPSBmdW5jdGlvbiBnZXRCdWZmZXJlZFRpbWVzKGZyYWdtZW50LCBwYXJ0LCBwYXJ0aWFsLCB0aW1lUmFuZ2UpIHtcbiAgICB2YXIgYnVmZmVyZWQgPSB7XG4gICAgICB0aW1lOiBbXSxcbiAgICAgIHBhcnRpYWw6IHBhcnRpYWxcbiAgICB9O1xuICAgIHZhciBzdGFydFBUUyA9IHBhcnQgPyBwYXJ0LnN0YXJ0IDogZnJhZ21lbnQuc3RhcnQ7XG4gICAgdmFyIGVuZFBUUyA9IHBhcnQgPyBwYXJ0LmVuZCA6IGZyYWdtZW50LmVuZDtcbiAgICB2YXIgbWluRW5kUFRTID0gZnJhZ21lbnQubWluRW5kUFRTIHx8IGVuZFBUUztcbiAgICB2YXIgbWF4U3RhcnRQVFMgPSBmcmFnbWVudC5tYXhTdGFydFBUUyB8fCBzdGFydFBUUztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGltZVJhbmdlLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc3RhcnRUaW1lID0gdGltZVJhbmdlLnN0YXJ0KGkpIC0gdGhpcy5idWZmZXJQYWRkaW5nO1xuICAgICAgdmFyIGVuZFRpbWUgPSB0aW1lUmFuZ2UuZW5kKGkpICsgdGhpcy5idWZmZXJQYWRkaW5nO1xuXG4gICAgICBpZiAobWF4U3RhcnRQVFMgPj0gc3RhcnRUaW1lICYmIG1pbkVuZFBUUyA8PSBlbmRUaW1lKSB7XG4gICAgICAgIC8vIEZyYWdtZW50IGlzIGVudGlyZWx5IGNvbnRhaW5lZCBpbiBidWZmZXJcbiAgICAgICAgLy8gTm8gbmVlZCB0byBjaGVjayB0aGUgb3RoZXIgdGltZVJhbmdlIHRpbWVzIHNpbmNlIGl0J3MgY29tcGxldGVseSBwbGF5YWJsZVxuICAgICAgICBidWZmZXJlZC50aW1lLnB1c2goe1xuICAgICAgICAgIHN0YXJ0UFRTOiBNYXRoLm1heChzdGFydFBUUywgdGltZVJhbmdlLnN0YXJ0KGkpKSxcbiAgICAgICAgICBlbmRQVFM6IE1hdGgubWluKGVuZFBUUywgdGltZVJhbmdlLmVuZChpKSlcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIGlmIChzdGFydFBUUyA8IGVuZFRpbWUgJiYgZW5kUFRTID4gc3RhcnRUaW1lKSB7XG4gICAgICAgIGJ1ZmZlcmVkLnBhcnRpYWwgPSB0cnVlOyAvLyBDaGVjayBmb3IgaW50ZXJzZWN0aW9uIHdpdGggYnVmZmVyXG4gICAgICAgIC8vIEdldCBwbGF5YWJsZSBzZWN0aW9ucyBvZiB0aGUgZnJhZ21lbnRcblxuICAgICAgICBidWZmZXJlZC50aW1lLnB1c2goe1xuICAgICAgICAgIHN0YXJ0UFRTOiBNYXRoLm1heChzdGFydFBUUywgdGltZVJhbmdlLnN0YXJ0KGkpKSxcbiAgICAgICAgICBlbmRQVFM6IE1hdGgubWluKGVuZFBUUywgdGltZVJhbmdlLmVuZChpKSlcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKGVuZFBUUyA8PSBzdGFydFRpbWUpIHtcbiAgICAgICAgLy8gTm8gbmVlZCB0byBjaGVjayB0aGUgcmVzdCBvZiB0aGUgdGltZVJhbmdlIGFzIGl0IGlzIGluIG9yZGVyXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBidWZmZXJlZDtcbiAgfVxuICAvKipcbiAgICogR2V0cyB0aGUgcGFydGlhbCBmcmFnbWVudCBmb3IgYSBjZXJ0YWluIHRpbWVcbiAgICovXG4gIDtcblxuICBfcHJvdG8uZ2V0UGFydGlhbEZyYWdtZW50ID0gZnVuY3Rpb24gZ2V0UGFydGlhbEZyYWdtZW50KHRpbWUpIHtcbiAgICB2YXIgYmVzdEZyYWdtZW50ID0gbnVsbDtcbiAgICB2YXIgdGltZVBhZGRpbmc7XG4gICAgdmFyIHN0YXJ0VGltZTtcbiAgICB2YXIgZW5kVGltZTtcbiAgICB2YXIgYmVzdE92ZXJsYXAgPSAwO1xuICAgIHZhciBidWZmZXJQYWRkaW5nID0gdGhpcy5idWZmZXJQYWRkaW5nLFxuICAgICAgICBmcmFnbWVudHMgPSB0aGlzLmZyYWdtZW50cztcbiAgICBPYmplY3Qua2V5cyhmcmFnbWVudHMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgdmFyIGZyYWdtZW50RW50aXR5ID0gZnJhZ21lbnRzW2tleV07XG5cbiAgICAgIGlmICghZnJhZ21lbnRFbnRpdHkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNQYXJ0aWFsKGZyYWdtZW50RW50aXR5KSkge1xuICAgICAgICBzdGFydFRpbWUgPSBmcmFnbWVudEVudGl0eS5ib2R5LnN0YXJ0IC0gYnVmZmVyUGFkZGluZztcbiAgICAgICAgZW5kVGltZSA9IGZyYWdtZW50RW50aXR5LmJvZHkuZW5kICsgYnVmZmVyUGFkZGluZztcblxuICAgICAgICBpZiAodGltZSA+PSBzdGFydFRpbWUgJiYgdGltZSA8PSBlbmRUaW1lKSB7XG4gICAgICAgICAgLy8gVXNlIHRoZSBmcmFnbWVudCB0aGF0IGhhcyB0aGUgbW9zdCBwYWRkaW5nIGZyb20gc3RhcnQgYW5kIGVuZCB0aW1lXG4gICAgICAgICAgdGltZVBhZGRpbmcgPSBNYXRoLm1pbih0aW1lIC0gc3RhcnRUaW1lLCBlbmRUaW1lIC0gdGltZSk7XG5cbiAgICAgICAgICBpZiAoYmVzdE92ZXJsYXAgPD0gdGltZVBhZGRpbmcpIHtcbiAgICAgICAgICAgIGJlc3RGcmFnbWVudCA9IGZyYWdtZW50RW50aXR5LmJvZHk7XG4gICAgICAgICAgICBiZXN0T3ZlcmxhcCA9IHRpbWVQYWRkaW5nO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBiZXN0RnJhZ21lbnQ7XG4gIH07XG5cbiAgX3Byb3RvLmdldFN0YXRlID0gZnVuY3Rpb24gZ2V0U3RhdGUoZnJhZ21lbnQpIHtcbiAgICB2YXIgZnJhZ0tleSA9IGdldEZyYWdtZW50S2V5KGZyYWdtZW50KTtcbiAgICB2YXIgZnJhZ21lbnRFbnRpdHkgPSB0aGlzLmZyYWdtZW50c1tmcmFnS2V5XTtcblxuICAgIGlmIChmcmFnbWVudEVudGl0eSkge1xuICAgICAgaWYgKCFmcmFnbWVudEVudGl0eS5idWZmZXJlZCkge1xuICAgICAgICBpZiAoZnJhZ21lbnRFbnRpdHkuYmFja3RyYWNrKSB7XG4gICAgICAgICAgcmV0dXJuIEZyYWdtZW50U3RhdGUuQkFDS1RSQUNLRUQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gRnJhZ21lbnRTdGF0ZS5BUFBFTkRJTkc7XG4gICAgICB9IGVsc2UgaWYgKGlzUGFydGlhbChmcmFnbWVudEVudGl0eSkpIHtcbiAgICAgICAgcmV0dXJuIEZyYWdtZW50U3RhdGUuUEFSVElBTDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBGcmFnbWVudFN0YXRlLk9LO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBGcmFnbWVudFN0YXRlLk5PVF9MT0FERUQ7XG4gIH07XG5cbiAgX3Byb3RvLmJhY2t0cmFjayA9IGZ1bmN0aW9uIGJhY2t0cmFjayhmcmFnLCBkYXRhKSB7XG4gICAgdmFyIGZyYWdLZXkgPSBnZXRGcmFnbWVudEtleShmcmFnKTtcbiAgICB2YXIgZnJhZ21lbnRFbnRpdHkgPSB0aGlzLmZyYWdtZW50c1tmcmFnS2V5XTtcblxuICAgIGlmICghZnJhZ21lbnRFbnRpdHkgfHwgZnJhZ21lbnRFbnRpdHkuYmFja3RyYWNrKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgYmFja3RyYWNrID0gZnJhZ21lbnRFbnRpdHkuYmFja3RyYWNrID0gZGF0YSA/IGRhdGEgOiBmcmFnbWVudEVudGl0eS5sb2FkZWQ7XG4gICAgZnJhZ21lbnRFbnRpdHkubG9hZGVkID0gbnVsbDtcbiAgICByZXR1cm4gYmFja3RyYWNrO1xuICB9O1xuXG4gIF9wcm90by5nZXRCYWNrdHJhY2tEYXRhID0gZnVuY3Rpb24gZ2V0QmFja3RyYWNrRGF0YShmcmFnbWVudCkge1xuICAgIHZhciBmcmFnS2V5ID0gZ2V0RnJhZ21lbnRLZXkoZnJhZ21lbnQpO1xuICAgIHZhciBmcmFnbWVudEVudGl0eSA9IHRoaXMuZnJhZ21lbnRzW2ZyYWdLZXldO1xuXG4gICAgaWYgKGZyYWdtZW50RW50aXR5KSB7XG4gICAgICB2YXIgX2JhY2t0cmFjayRwYXlsb2FkO1xuXG4gICAgICB2YXIgYmFja3RyYWNrID0gZnJhZ21lbnRFbnRpdHkuYmFja3RyYWNrOyAvLyBJZiBkYXRhIHdhcyBhbHJlYWR5IHNlbnQgdG8gV29ya2VyIGl0IGlzIGRldGFjaGVkIG5vIGxvbmdlciBhdmFpbGFibGVcblxuICAgICAgaWYgKGJhY2t0cmFjayAhPT0gbnVsbCAmJiBiYWNrdHJhY2sgIT09IHZvaWQgMCAmJiAoX2JhY2t0cmFjayRwYXlsb2FkID0gYmFja3RyYWNrLnBheWxvYWQpICE9PSBudWxsICYmIF9iYWNrdHJhY2skcGF5bG9hZCAhPT0gdm9pZCAwICYmIF9iYWNrdHJhY2skcGF5bG9hZC5ieXRlTGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBiYWNrdHJhY2s7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJlbW92ZUZyYWdtZW50KGZyYWdtZW50KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICBfcHJvdG8uaXNUaW1lQnVmZmVyZWQgPSBmdW5jdGlvbiBpc1RpbWVCdWZmZXJlZChzdGFydFBUUywgZW5kUFRTLCB0aW1lUmFuZ2UpIHtcbiAgICB2YXIgc3RhcnRUaW1lO1xuICAgIHZhciBlbmRUaW1lO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aW1lUmFuZ2UubGVuZ3RoOyBpKyspIHtcbiAgICAgIHN0YXJ0VGltZSA9IHRpbWVSYW5nZS5zdGFydChpKSAtIHRoaXMuYnVmZmVyUGFkZGluZztcbiAgICAgIGVuZFRpbWUgPSB0aW1lUmFuZ2UuZW5kKGkpICsgdGhpcy5idWZmZXJQYWRkaW5nO1xuXG4gICAgICBpZiAoc3RhcnRQVFMgPj0gc3RhcnRUaW1lICYmIGVuZFBUUyA8PSBlbmRUaW1lKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoZW5kUFRTIDw9IHN0YXJ0VGltZSkge1xuICAgICAgICAvLyBObyBuZWVkIHRvIGNoZWNrIHRoZSByZXN0IG9mIHRoZSB0aW1lUmFuZ2UgYXMgaXQgaXMgaW4gb3JkZXJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICBfcHJvdG8ub25GcmFnTG9hZGVkID0gZnVuY3Rpb24gb25GcmFnTG9hZGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgdmFyIGZyYWcgPSBkYXRhLmZyYWcsXG4gICAgICAgIHBhcnQgPSBkYXRhLnBhcnQ7IC8vIGRvbid0IHRyYWNrIGluaXRzZWdtZW50IChmb3Igd2hpY2ggc24gaXMgbm90IGEgbnVtYmVyKVxuICAgIC8vIGRvbid0IHRyYWNrIGZyYWdzIHVzZWQgZm9yIGJpdHJhdGVUZXN0LCB0aGV5J3JlIGlycmVsZXZhbnQuXG4gICAgLy8gZG9uJ3QgdHJhY2sgcGFydHMgZm9yIG1lbW9yeSBlZmZpY2llbmN5XG5cbiAgICBpZiAoZnJhZy5zbiA9PT0gJ2luaXRTZWdtZW50JyB8fCBmcmFnLmJpdHJhdGVUZXN0IHx8IHBhcnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZnJhZ0tleSA9IGdldEZyYWdtZW50S2V5KGZyYWcpO1xuICAgIHRoaXMuZnJhZ21lbnRzW2ZyYWdLZXldID0ge1xuICAgICAgYm9keTogZnJhZyxcbiAgICAgIGxvYWRlZDogZGF0YSxcbiAgICAgIGJhY2t0cmFjazogbnVsbCxcbiAgICAgIGJ1ZmZlcmVkOiBmYWxzZSxcbiAgICAgIHJhbmdlOiBPYmplY3QuY3JlYXRlKG51bGwpXG4gICAgfTtcbiAgfTtcblxuICBfcHJvdG8ub25CdWZmZXJBcHBlbmRlZCA9IGZ1bmN0aW9uIG9uQnVmZmVyQXBwZW5kZWQoZXZlbnQsIGRhdGEpIHtcbiAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgIHZhciBmcmFnID0gZGF0YS5mcmFnLFxuICAgICAgICBwYXJ0ID0gZGF0YS5wYXJ0LFxuICAgICAgICB0aW1lUmFuZ2VzID0gZGF0YS50aW1lUmFuZ2VzO1xuXG4gICAgaWYgKGZyYWcudHlwZSA9PT0gX3R5cGVzX2xvYWRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiUGxheWxpc3RMZXZlbFR5cGVcIl0uTUFJTikge1xuICAgICAgdGhpcy5hY3RpdmVGcmFnbWVudCA9IGZyYWc7XG5cbiAgICAgIGlmIChwYXJ0KSB7XG4gICAgICAgIHZhciBhY3RpdmVQYXJ0cyA9IHRoaXMuYWN0aXZlUGFydHM7XG5cbiAgICAgICAgaWYgKCFhY3RpdmVQYXJ0cykge1xuICAgICAgICAgIHRoaXMuYWN0aXZlUGFydHMgPSBhY3RpdmVQYXJ0cyA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgYWN0aXZlUGFydHMucHVzaChwYXJ0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYWN0aXZlUGFydHMgPSBudWxsO1xuICAgICAgfVxuICAgIH0gLy8gU3RvcmUgdGhlIGxhdGVzdCB0aW1lUmFuZ2VzIGxvYWRlZCBpbiB0aGUgYnVmZmVyXG5cblxuICAgIHRoaXMudGltZVJhbmdlcyA9IHRpbWVSYW5nZXM7XG4gICAgT2JqZWN0LmtleXModGltZVJhbmdlcykuZm9yRWFjaChmdW5jdGlvbiAoZWxlbWVudGFyeVN0cmVhbSkge1xuICAgICAgdmFyIHRpbWVSYW5nZSA9IHRpbWVSYW5nZXNbZWxlbWVudGFyeVN0cmVhbV07XG5cbiAgICAgIF90aGlzMy5kZXRlY3RFdmljdGVkRnJhZ21lbnRzKGVsZW1lbnRhcnlTdHJlYW0sIHRpbWVSYW5nZSk7XG5cbiAgICAgIGlmICghcGFydCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRpbWVSYW5nZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGZyYWcuYXBwZW5kZWRQVFMgPSBNYXRoLm1heCh0aW1lUmFuZ2UuZW5kKGkpLCBmcmFnLmFwcGVuZGVkUFRTIHx8IDApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLm9uRnJhZ0J1ZmZlcmVkID0gZnVuY3Rpb24gb25GcmFnQnVmZmVyZWQoZXZlbnQsIGRhdGEpIHtcbiAgICB0aGlzLmRldGVjdFBhcnRpYWxGcmFnbWVudHMoZGF0YSk7XG4gIH07XG5cbiAgX3Byb3RvLmhhc0ZyYWdtZW50ID0gZnVuY3Rpb24gaGFzRnJhZ21lbnQoZnJhZ21lbnQpIHtcbiAgICB2YXIgZnJhZ0tleSA9IGdldEZyYWdtZW50S2V5KGZyYWdtZW50KTtcbiAgICByZXR1cm4gISF0aGlzLmZyYWdtZW50c1tmcmFnS2V5XTtcbiAgfTtcblxuICBfcHJvdG8ucmVtb3ZlRnJhZ21lbnRzSW5SYW5nZSA9IGZ1bmN0aW9uIHJlbW92ZUZyYWdtZW50c0luUmFuZ2Uoc3RhcnQsIGVuZCwgcGxheWxpc3RUeXBlKSB7XG4gICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICBPYmplY3Qua2V5cyh0aGlzLmZyYWdtZW50cykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICB2YXIgZnJhZ21lbnRFbnRpdHkgPSBfdGhpczQuZnJhZ21lbnRzW2tleV07XG5cbiAgICAgIGlmICghZnJhZ21lbnRFbnRpdHkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoZnJhZ21lbnRFbnRpdHkuYnVmZmVyZWQpIHtcbiAgICAgICAgdmFyIGZyYWcgPSBmcmFnbWVudEVudGl0eS5ib2R5O1xuXG4gICAgICAgIGlmIChmcmFnLnR5cGUgPT09IHBsYXlsaXN0VHlwZSAmJiBmcmFnLnN0YXJ0IDwgZW5kICYmIGZyYWcuZW5kID4gc3RhcnQpIHtcbiAgICAgICAgICBfdGhpczQucmVtb3ZlRnJhZ21lbnQoZnJhZyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG8ucmVtb3ZlRnJhZ21lbnQgPSBmdW5jdGlvbiByZW1vdmVGcmFnbWVudChmcmFnbWVudCkge1xuICAgIHZhciBmcmFnS2V5ID0gZ2V0RnJhZ21lbnRLZXkoZnJhZ21lbnQpO1xuICAgIGZyYWdtZW50LnN0YXRzLmxvYWRlZCA9IDA7XG4gICAgZnJhZ21lbnQuY2xlYXJFbGVtZW50YXJ5U3RyZWFtSW5mbygpO1xuICAgIGRlbGV0ZSB0aGlzLmZyYWdtZW50c1tmcmFnS2V5XTtcbiAgfTtcblxuICBfcHJvdG8ucmVtb3ZlQWxsRnJhZ21lbnRzID0gZnVuY3Rpb24gcmVtb3ZlQWxsRnJhZ21lbnRzKCkge1xuICAgIHRoaXMuZnJhZ21lbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLmFjdGl2ZUZyYWdtZW50ID0gbnVsbDtcbiAgICB0aGlzLmFjdGl2ZVBhcnRzID0gbnVsbDtcbiAgfTtcblxuICByZXR1cm4gRnJhZ21lbnRUcmFja2VyO1xufSgpO1xuXG5mdW5jdGlvbiBpc1BhcnRpYWwoZnJhZ21lbnRFbnRpdHkpIHtcbiAgdmFyIF9mcmFnbWVudEVudGl0eSRyYW5nZSwgX2ZyYWdtZW50RW50aXR5JHJhbmdlMjtcblxuICByZXR1cm4gZnJhZ21lbnRFbnRpdHkuYnVmZmVyZWQgJiYgKCgoX2ZyYWdtZW50RW50aXR5JHJhbmdlID0gZnJhZ21lbnRFbnRpdHkucmFuZ2UudmlkZW8pID09PSBudWxsIHx8IF9mcmFnbWVudEVudGl0eSRyYW5nZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2ZyYWdtZW50RW50aXR5JHJhbmdlLnBhcnRpYWwpIHx8ICgoX2ZyYWdtZW50RW50aXR5JHJhbmdlMiA9IGZyYWdtZW50RW50aXR5LnJhbmdlLmF1ZGlvKSA9PT0gbnVsbCB8fCBfZnJhZ21lbnRFbnRpdHkkcmFuZ2UyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZnJhZ21lbnRFbnRpdHkkcmFuZ2UyLnBhcnRpYWwpKTtcbn1cblxuZnVuY3Rpb24gZ2V0RnJhZ21lbnRLZXkoZnJhZ21lbnQpIHtcbiAgcmV0dXJuIGZyYWdtZW50LnR5cGUgKyBcIl9cIiArIGZyYWdtZW50LmxldmVsICsgXCJfXCIgKyBmcmFnbWVudC51cmxJZCArIFwiX1wiICsgZnJhZ21lbnQuc247XG59XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NvbnRyb2xsZXIvZ2FwLWNvbnRyb2xsZXIudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9jb250cm9sbGVyL2dhcC1jb250cm9sbGVyLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogU1RBTExfTUlOSU1VTV9EVVJBVElPTl9NUywgTUFYX1NUQVJUX0dBUF9KVU1QLCBTS0lQX0JVRkZFUl9IT0xFX1NURVBfU0VDT05EUywgU0tJUF9CVUZGRVJfUkFOR0VfU1RBUlQsIGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiU1RBTExfTUlOSU1VTV9EVVJBVElPTl9NU1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIFNUQUxMX01JTklNVU1fRFVSQVRJT05fTVM7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIk1BWF9TVEFSVF9HQVBfSlVNUFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIE1BWF9TVEFSVF9HQVBfSlVNUDsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiU0tJUF9CVUZGRVJfSE9MRV9TVEVQX1NFQ09ORFNcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBTS0lQX0JVRkZFUl9IT0xFX1NURVBfU0VDT05EUzsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiU0tJUF9CVUZGRVJfUkFOR0VfU1RBUlRcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBTS0lQX0JVRkZFUl9SQU5HRV9TVEFSVDsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZGVmYXVsdFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIEdhcENvbnRyb2xsZXI7IH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19idWZmZXJfaGVscGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9idWZmZXItaGVscGVyICovIFwiLi9zcmMvdXRpbHMvYnVmZmVyLWhlbHBlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9lcnJvcnMgKi8gXCIuL3NyYy9lcnJvcnMudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZXZlbnRzICovIFwiLi9zcmMvZXZlbnRzLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL2xvZ2dlciAqLyBcIi4vc3JjL3V0aWxzL2xvZ2dlci50c1wiKTtcblxuXG5cblxudmFyIFNUQUxMX01JTklNVU1fRFVSQVRJT05fTVMgPSAyNTA7XG52YXIgTUFYX1NUQVJUX0dBUF9KVU1QID0gMi4wO1xudmFyIFNLSVBfQlVGRkVSX0hPTEVfU1RFUF9TRUNPTkRTID0gMC4xO1xudmFyIFNLSVBfQlVGRkVSX1JBTkdFX1NUQVJUID0gMC4wNTtcblxudmFyIEdhcENvbnRyb2xsZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBHYXBDb250cm9sbGVyKGNvbmZpZywgbWVkaWEsIGZyYWdtZW50VHJhY2tlciwgaGxzKSB7XG4gICAgdGhpcy5jb25maWcgPSB2b2lkIDA7XG4gICAgdGhpcy5tZWRpYSA9IHZvaWQgMDtcbiAgICB0aGlzLmZyYWdtZW50VHJhY2tlciA9IHZvaWQgMDtcbiAgICB0aGlzLmhscyA9IHZvaWQgMDtcbiAgICB0aGlzLm51ZGdlUmV0cnkgPSAwO1xuICAgIHRoaXMuc3RhbGxSZXBvcnRlZCA9IGZhbHNlO1xuICAgIHRoaXMuc3RhbGxlZCA9IG51bGw7XG4gICAgdGhpcy5tb3ZlZCA9IGZhbHNlO1xuICAgIHRoaXMuc2Vla2luZyA9IGZhbHNlO1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgIHRoaXMubWVkaWEgPSBtZWRpYTtcbiAgICB0aGlzLmZyYWdtZW50VHJhY2tlciA9IGZyYWdtZW50VHJhY2tlcjtcbiAgICB0aGlzLmhscyA9IGhscztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBHYXBDb250cm9sbGVyLnByb3RvdHlwZTtcblxuICBfcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHRoaXMuaGxzID0gdGhpcy5mcmFnbWVudFRyYWNrZXIgPSB0aGlzLm1lZGlhID0gbnVsbDtcbiAgfVxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBwbGF5aGVhZCBpcyBzdHVjayB3aXRoaW4gYSBnYXAsIGFuZCBpZiBzbywgYXR0ZW1wdHMgdG8gZnJlZSBpdC5cbiAgICogQSBnYXAgaXMgYW4gdW5idWZmZXJlZCByYW5nZSBiZXR3ZWVuIHR3byBidWZmZXJlZCByYW5nZXMgKG9yIHRoZSBzdGFydCBhbmQgdGhlIGZpcnN0IGJ1ZmZlcmVkIHJhbmdlKS5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IGxhc3RDdXJyZW50VGltZSBQcmV2aW91c2x5IHJlYWQgcGxheWhlYWQgcG9zaXRpb25cbiAgICovXG4gIDtcblxuICBfcHJvdG8ucG9sbCA9IGZ1bmN0aW9uIHBvbGwobGFzdEN1cnJlbnRUaW1lKSB7XG4gICAgdmFyIGNvbmZpZyA9IHRoaXMuY29uZmlnLFxuICAgICAgICBtZWRpYSA9IHRoaXMubWVkaWEsXG4gICAgICAgIHN0YWxsZWQgPSB0aGlzLnN0YWxsZWQ7XG4gICAgdmFyIGN1cnJlbnRUaW1lID0gbWVkaWEuY3VycmVudFRpbWUsXG4gICAgICAgIHNlZWtpbmcgPSBtZWRpYS5zZWVraW5nO1xuICAgIHZhciBzZWVrZWQgPSB0aGlzLnNlZWtpbmcgJiYgIXNlZWtpbmc7XG4gICAgdmFyIGJlZ2luU2VlayA9ICF0aGlzLnNlZWtpbmcgJiYgc2Vla2luZztcbiAgICB0aGlzLnNlZWtpbmcgPSBzZWVraW5nOyAvLyBUaGUgcGxheWhlYWQgaXMgbW92aW5nLCBuby1vcFxuXG4gICAgaWYgKGN1cnJlbnRUaW1lICE9PSBsYXN0Q3VycmVudFRpbWUpIHtcbiAgICAgIHRoaXMubW92ZWQgPSB0cnVlO1xuXG4gICAgICBpZiAoc3RhbGxlZCAhPT0gbnVsbCkge1xuICAgICAgICAvLyBUaGUgcGxheWhlYWQgaXMgbm93IG1vdmluZywgYnV0IHdhcyBwcmV2aW91c2x5IHN0YWxsZWRcbiAgICAgICAgaWYgKHRoaXMuc3RhbGxSZXBvcnRlZCkge1xuICAgICAgICAgIHZhciBfc3RhbGxlZER1cmF0aW9uID0gc2VsZi5wZXJmb3JtYW5jZS5ub3coKSAtIHN0YWxsZWQ7XG5cbiAgICAgICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJsb2dnZXJcIl0ud2FybihcInBsYXliYWNrIG5vdCBzdHVjayBhbnltb3JlIEBcIiArIGN1cnJlbnRUaW1lICsgXCIsIGFmdGVyIFwiICsgTWF0aC5yb3VuZChfc3RhbGxlZER1cmF0aW9uKSArIFwibXNcIik7XG4gICAgICAgICAgdGhpcy5zdGFsbFJlcG9ydGVkID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnN0YWxsZWQgPSBudWxsO1xuICAgICAgICB0aGlzLm51ZGdlUmV0cnkgPSAwO1xuICAgICAgfVxuXG4gICAgICByZXR1cm47XG4gICAgfSAvLyBDbGVhciBzdGFsbGVkIHN0YXRlIHdoZW4gYmVnaW5uaW5nIG9yIGZpbmlzaGluZyBzZWVraW5nIHNvIHRoYXQgd2UgZG9uJ3QgcmVwb3J0IHN0YWxscyBjb21pbmcgb3V0IG9mIGEgc2Vla1xuXG5cbiAgICBpZiAoYmVnaW5TZWVrIHx8IHNlZWtlZCkge1xuICAgICAgdGhpcy5zdGFsbGVkID0gbnVsbDtcbiAgICB9IC8vIFRoZSBwbGF5aGVhZCBzaG91bGQgbm90IGJlIG1vdmluZ1xuXG5cbiAgICBpZiAobWVkaWEucGF1c2VkIHx8IG1lZGlhLmVuZGVkIHx8IG1lZGlhLnBsYXliYWNrUmF0ZSA9PT0gMCB8fCAhX3V0aWxzX2J1ZmZlcl9oZWxwZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIkJ1ZmZlckhlbHBlclwiXS5nZXRCdWZmZXJlZChtZWRpYSkubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGJ1ZmZlckluZm8gPSBfdXRpbHNfYnVmZmVyX2hlbHBlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiQnVmZmVySGVscGVyXCJdLmJ1ZmZlckluZm8obWVkaWEsIGN1cnJlbnRUaW1lLCAwKTtcbiAgICB2YXIgaXNCdWZmZXJlZCA9IGJ1ZmZlckluZm8ubGVuID4gMDtcbiAgICB2YXIgbmV4dFN0YXJ0ID0gYnVmZmVySW5mby5uZXh0U3RhcnQgfHwgMDsgLy8gVGhlcmUgaXMgbm8gcGxheWFibGUgYnVmZmVyIChzZWVrZWQsIHdhaXRpbmcgZm9yIGJ1ZmZlcilcblxuICAgIGlmICghaXNCdWZmZXJlZCAmJiAhbmV4dFN0YXJ0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHNlZWtpbmcpIHtcbiAgICAgIC8vIFdhaXRpbmcgZm9yIHNlZWtpbmcgaW4gYSBidWZmZXJlZCByYW5nZSB0byBjb21wbGV0ZVxuICAgICAgdmFyIGhhc0Vub3VnaEJ1ZmZlciA9IGJ1ZmZlckluZm8ubGVuID4gTUFYX1NUQVJUX0dBUF9KVU1QOyAvLyBOZXh0IGJ1ZmZlcmVkIHJhbmdlIGlzIHRvbyBmYXIgYWhlYWQgdG8ganVtcCB0byB3aGlsZSBzdGlsbCBzZWVraW5nXG5cbiAgICAgIHZhciBub0J1ZmZlckdhcCA9ICFuZXh0U3RhcnQgfHwgbmV4dFN0YXJ0IC0gY3VycmVudFRpbWUgPiBNQVhfU1RBUlRfR0FQX0pVTVAgJiYgIXRoaXMuZnJhZ21lbnRUcmFja2VyLmdldFBhcnRpYWxGcmFnbWVudChjdXJyZW50VGltZSk7XG5cbiAgICAgIGlmIChoYXNFbm91Z2hCdWZmZXIgfHwgbm9CdWZmZXJHYXApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBSZXNldCBtb3ZlZCBzdGF0ZSB3aGVuIHNlZWtpbmcgdG8gYSBwb2ludCBpbiBvciBiZWZvcmUgYSBnYXBcblxuXG4gICAgICB0aGlzLm1vdmVkID0gZmFsc2U7XG4gICAgfSAvLyBTa2lwIHN0YXJ0IGdhcHMgaWYgd2UgaGF2ZW4ndCBwbGF5ZWQsIGJ1dCB0aGUgbGFzdCBwb2xsIGRldGVjdGVkIHRoZSBzdGFydCBvZiBhIHN0YWxsXG4gICAgLy8gVGhlIGFkZGl0aW9uIHBvbGwgZ2l2ZXMgdGhlIGJyb3dzZXIgYSBjaGFuY2UgdG8ganVtcCB0aGUgZ2FwIGZvciB1c1xuXG5cbiAgICBpZiAoIXRoaXMubW92ZWQgJiYgdGhpcy5zdGFsbGVkICE9PSBudWxsKSB7XG4gICAgICB2YXIgX2xldmVsJGRldGFpbHM7XG5cbiAgICAgIC8vIEp1bXAgc3RhcnQgZ2FwcyB3aXRoaW4ganVtcCB0aHJlc2hvbGRcbiAgICAgIHZhciBzdGFydEp1bXAgPSBNYXRoLm1heChuZXh0U3RhcnQsIGJ1ZmZlckluZm8uc3RhcnQgfHwgMCkgLSBjdXJyZW50VGltZTsgLy8gV2hlbiBqb2luaW5nIGEgbGl2ZSBzdHJlYW0gd2l0aCBhdWRpbyB0cmFja3MsIGFjY291bnQgZm9yIGxpdmUgcGxheWxpc3Qgd2luZG93IHNsaWRpbmcgYnkgYWxsb3dpbmdcbiAgICAgIC8vIGEgbGFyZ2VyIGp1bXAgb3ZlciBzdGFydCBnYXBzIGNhdXNlZCBieSB0aGUgYXVkaW8tc3RyZWFtLWNvbnRyb2xsZXIgYnVmZmVyaW5nIGEgc3RhcnQgZnJhZ21lbnRcbiAgICAgIC8vIHRoYXQgYmVnaW5zIG92ZXIgMSB0YXJnZXQgZHVyYXRpb24gYWZ0ZXIgdGhlIHZpZGVvIHN0YXJ0IHBvc2l0aW9uLlxuXG4gICAgICB2YXIgbGV2ZWwgPSB0aGlzLmhscy5sZXZlbHMgPyB0aGlzLmhscy5sZXZlbHNbdGhpcy5obHMuY3VycmVudExldmVsXSA6IG51bGw7XG4gICAgICB2YXIgaXNMaXZlID0gbGV2ZWwgPT09IG51bGwgfHwgbGV2ZWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfbGV2ZWwkZGV0YWlscyA9IGxldmVsLmRldGFpbHMpID09PSBudWxsIHx8IF9sZXZlbCRkZXRhaWxzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfbGV2ZWwkZGV0YWlscy5saXZlO1xuICAgICAgdmFyIG1heFN0YXJ0R2FwSnVtcCA9IGlzTGl2ZSA/IGxldmVsLmRldGFpbHMudGFyZ2V0ZHVyYXRpb24gKiAyIDogTUFYX1NUQVJUX0dBUF9KVU1QO1xuXG4gICAgICBpZiAoc3RhcnRKdW1wID4gMCAmJiBzdGFydEp1bXAgPD0gbWF4U3RhcnRHYXBKdW1wKSB7XG4gICAgICAgIHRoaXMuX3RyeVNraXBCdWZmZXJIb2xlKG51bGwpO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9IC8vIFN0YXJ0IHRyYWNraW5nIHN0YWxsIHRpbWVcblxuXG4gICAgdmFyIHRub3cgPSBzZWxmLnBlcmZvcm1hbmNlLm5vdygpO1xuXG4gICAgaWYgKHN0YWxsZWQgPT09IG51bGwpIHtcbiAgICAgIHRoaXMuc3RhbGxlZCA9IHRub3c7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHN0YWxsZWREdXJhdGlvbiA9IHRub3cgLSBzdGFsbGVkO1xuXG4gICAgaWYgKCFzZWVraW5nICYmIHN0YWxsZWREdXJhdGlvbiA+PSBTVEFMTF9NSU5JTVVNX0RVUkFUSU9OX01TKSB7XG4gICAgICAvLyBSZXBvcnQgc3RhbGxpbmcgYWZ0ZXIgdHJ5aW5nIHRvIGZpeFxuICAgICAgdGhpcy5fcmVwb3J0U3RhbGwoYnVmZmVySW5mby5sZW4pO1xuICAgIH1cblxuICAgIHZhciBidWZmZXJlZFdpdGhIb2xlcyA9IF91dGlsc19idWZmZXJfaGVscGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJCdWZmZXJIZWxwZXJcIl0uYnVmZmVySW5mbyhtZWRpYSwgY3VycmVudFRpbWUsIGNvbmZpZy5tYXhCdWZmZXJIb2xlKTtcblxuICAgIHRoaXMuX3RyeUZpeEJ1ZmZlclN0YWxsKGJ1ZmZlcmVkV2l0aEhvbGVzLCBzdGFsbGVkRHVyYXRpb24pO1xuICB9XG4gIC8qKlxuICAgKiBEZXRlY3RzIGFuZCBhdHRlbXB0cyB0byBmaXgga25vd24gYnVmZmVyIHN0YWxsaW5nIGlzc3Vlcy5cbiAgICogQHBhcmFtIGJ1ZmZlckluZm8gLSBUaGUgcHJvcGVydGllcyBvZiB0aGUgY3VycmVudCBidWZmZXIuXG4gICAqIEBwYXJhbSBzdGFsbGVkRHVyYXRpb25NcyAtIFRoZSBhbW91bnQgb2YgdGltZSBIbHMuanMgaGFzIGJlZW4gc3RhbGxpbmcgZm9yLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5fdHJ5Rml4QnVmZmVyU3RhbGwgPSBmdW5jdGlvbiBfdHJ5Rml4QnVmZmVyU3RhbGwoYnVmZmVySW5mbywgc3RhbGxlZER1cmF0aW9uTXMpIHtcbiAgICB2YXIgY29uZmlnID0gdGhpcy5jb25maWcsXG4gICAgICAgIGZyYWdtZW50VHJhY2tlciA9IHRoaXMuZnJhZ21lbnRUcmFja2VyLFxuICAgICAgICBtZWRpYSA9IHRoaXMubWVkaWE7XG4gICAgdmFyIGN1cnJlbnRUaW1lID0gbWVkaWEuY3VycmVudFRpbWU7XG4gICAgdmFyIHBhcnRpYWwgPSBmcmFnbWVudFRyYWNrZXIuZ2V0UGFydGlhbEZyYWdtZW50KGN1cnJlbnRUaW1lKTtcblxuICAgIGlmIChwYXJ0aWFsKSB7XG4gICAgICAvLyBUcnkgdG8gc2tpcCBvdmVyIHRoZSBidWZmZXIgaG9sZSBjYXVzZWQgYnkgYSBwYXJ0aWFsIGZyYWdtZW50XG4gICAgICAvLyBUaGlzIG1ldGhvZCBpc24ndCBsaW1pdGVkIGJ5IHRoZSBzaXplIG9mIHRoZSBnYXAgYmV0d2VlbiBidWZmZXJlZCByYW5nZXNcbiAgICAgIHZhciB0YXJnZXRUaW1lID0gdGhpcy5fdHJ5U2tpcEJ1ZmZlckhvbGUocGFydGlhbCk7IC8vIHdlIHJldHVybiBoZXJlIGluIHRoaXMgY2FzZSwgbWVhbmluZ1xuICAgICAgLy8gdGhlIGJyYW5jaCBiZWxvdyBvbmx5IGV4ZWN1dGVzIHdoZW4gd2UgZG9uJ3QgaGFuZGxlIGEgcGFydGlhbCBmcmFnbWVudFxuXG5cbiAgICAgIGlmICh0YXJnZXRUaW1lKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9IC8vIGlmIHdlIGhhdmVuJ3QgaGFkIHRvIHNraXAgb3ZlciBhIGJ1ZmZlciBob2xlIG9mIGEgcGFydGlhbCBmcmFnbWVudFxuICAgIC8vIHdlIG1heSBqdXN0IGhhdmUgdG8gXCJudWRnZVwiIHRoZSBwbGF5bGlzdCBhcyB0aGUgYnJvd3NlciBkZWNvZGluZy9yZW5kZXJpbmcgZW5naW5lXG4gICAgLy8gbmVlZHMgdG8gY3Jvc3Mgc29tZSBzb3J0IG9mIHRocmVzaG9sZCBjb3ZlcmluZyBhbGwgc291cmNlLWJ1ZmZlcnMgY29udGVudFxuICAgIC8vIHRvIHN0YXJ0IHBsYXlpbmcgcHJvcGVybHkuXG5cblxuICAgIGlmIChidWZmZXJJbmZvLmxlbiA+IGNvbmZpZy5tYXhCdWZmZXJIb2xlICYmIHN0YWxsZWREdXJhdGlvbk1zID4gY29uZmlnLmhpZ2hCdWZmZXJXYXRjaGRvZ1BlcmlvZCAqIDEwMDApIHtcbiAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcImxvZ2dlclwiXS53YXJuKCdUcnlpbmcgdG8gbnVkZ2UgcGxheWhlYWQgb3ZlciBidWZmZXItaG9sZScpOyAvLyBUcnkgdG8gbnVkZ2UgY3VycmVudFRpbWUgb3ZlciBhIGJ1ZmZlciBob2xlIGlmIHdlJ3ZlIGJlZW4gc3RhbGxpbmcgZm9yIHRoZSBjb25maWd1cmVkIGFtb3VudCBvZiBzZWNvbmRzXG4gICAgICAvLyBXZSBvbmx5IHRyeSB0byBqdW1wIHRoZSBob2xlIGlmIGl0J3MgdW5kZXIgdGhlIGNvbmZpZ3VyZWQgc2l6ZVxuICAgICAgLy8gUmVzZXQgc3RhbGxlZCBzbyB0byByZWFybSB3YXRjaGRvZyB0aW1lclxuXG4gICAgICB0aGlzLnN0YWxsZWQgPSBudWxsO1xuXG4gICAgICB0aGlzLl90cnlOdWRnZUJ1ZmZlcigpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogVHJpZ2dlcnMgYSBCVUZGRVJfU1RBTExFRF9FUlJPUiBldmVudCwgYnV0IG9ubHkgb25jZSBwZXIgc3RhbGwgcGVyaW9kLlxuICAgKiBAcGFyYW0gYnVmZmVyTGVuIC0gVGhlIHBsYXloZWFkIGRpc3RhbmNlIGZyb20gdGhlIGVuZCBvZiB0aGUgY3VycmVudCBidWZmZXIgc2VnbWVudC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIDtcblxuICBfcHJvdG8uX3JlcG9ydFN0YWxsID0gZnVuY3Rpb24gX3JlcG9ydFN0YWxsKGJ1ZmZlckxlbikge1xuICAgIHZhciBobHMgPSB0aGlzLmhscyxcbiAgICAgICAgbWVkaWEgPSB0aGlzLm1lZGlhLFxuICAgICAgICBzdGFsbFJlcG9ydGVkID0gdGhpcy5zdGFsbFJlcG9ydGVkO1xuXG4gICAgaWYgKCFzdGFsbFJlcG9ydGVkKSB7XG4gICAgICAvLyBSZXBvcnQgc3RhbGxlZCBlcnJvciBvbmNlXG4gICAgICB0aGlzLnN0YWxsUmVwb3J0ZWQgPSB0cnVlO1xuICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wibG9nZ2VyXCJdLndhcm4oXCJQbGF5YmFjayBzdGFsbGluZyBhdCBAXCIgKyBtZWRpYS5jdXJyZW50VGltZSArIFwiIGR1ZSB0byBsb3cgYnVmZmVyIChidWZmZXI9XCIgKyBidWZmZXJMZW4gKyBcIilcIik7XG4gICAgICBobHMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJFdmVudHNcIl0uRVJST1IsIHtcbiAgICAgICAgdHlwZTogX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXJyb3JUeXBlc1wiXS5NRURJQV9FUlJPUixcbiAgICAgICAgZGV0YWlsczogX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXJyb3JEZXRhaWxzXCJdLkJVRkZFUl9TVEFMTEVEX0VSUk9SLFxuICAgICAgICBmYXRhbDogZmFsc2UsXG4gICAgICAgIGJ1ZmZlcjogYnVmZmVyTGVuXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEF0dGVtcHRzIHRvIGZpeCBidWZmZXIgc3RhbGxzIGJ5IGp1bXBpbmcgb3ZlciBrbm93biBnYXBzIGNhdXNlZCBieSBwYXJ0aWFsIGZyYWdtZW50c1xuICAgKiBAcGFyYW0gcGFydGlhbCAtIFRoZSBwYXJ0aWFsIGZyYWdtZW50IGZvdW5kIGF0IHRoZSBjdXJyZW50IHRpbWUgKHdoZXJlIHBsYXliYWNrIGlzIHN0YWxsaW5nKS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIDtcblxuICBfcHJvdG8uX3RyeVNraXBCdWZmZXJIb2xlID0gZnVuY3Rpb24gX3RyeVNraXBCdWZmZXJIb2xlKHBhcnRpYWwpIHtcbiAgICB2YXIgY29uZmlnID0gdGhpcy5jb25maWcsXG4gICAgICAgIGhscyA9IHRoaXMuaGxzLFxuICAgICAgICBtZWRpYSA9IHRoaXMubWVkaWE7XG4gICAgdmFyIGN1cnJlbnRUaW1lID0gbWVkaWEuY3VycmVudFRpbWU7XG4gICAgdmFyIGxhc3RFbmRUaW1lID0gMDsgLy8gQ2hlY2sgaWYgY3VycmVudFRpbWUgaXMgYmV0d2VlbiB1bmJ1ZmZlcmVkIHJlZ2lvbnMgb2YgcGFydGlhbCBmcmFnbWVudHNcblxuICAgIHZhciBidWZmZXJlZCA9IF91dGlsc19idWZmZXJfaGVscGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJCdWZmZXJIZWxwZXJcIl0uZ2V0QnVmZmVyZWQobWVkaWEpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBidWZmZXJlZC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHN0YXJ0VGltZSA9IGJ1ZmZlcmVkLnN0YXJ0KGkpO1xuXG4gICAgICBpZiAoY3VycmVudFRpbWUgKyBjb25maWcubWF4QnVmZmVySG9sZSA+PSBsYXN0RW5kVGltZSAmJiBjdXJyZW50VGltZSA8IHN0YXJ0VGltZSkge1xuICAgICAgICB2YXIgdGFyZ2V0VGltZSA9IE1hdGgubWF4KHN0YXJ0VGltZSArIFNLSVBfQlVGRkVSX1JBTkdFX1NUQVJULCBtZWRpYS5jdXJyZW50VGltZSArIFNLSVBfQlVGRkVSX0hPTEVfU1RFUF9TRUNPTkRTKTtcbiAgICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wibG9nZ2VyXCJdLndhcm4oXCJza2lwcGluZyBob2xlLCBhZGp1c3RpbmcgY3VycmVudFRpbWUgZnJvbSBcIiArIGN1cnJlbnRUaW1lICsgXCIgdG8gXCIgKyB0YXJnZXRUaW1lKTtcbiAgICAgICAgdGhpcy5tb3ZlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuc3RhbGxlZCA9IG51bGw7XG4gICAgICAgIG1lZGlhLmN1cnJlbnRUaW1lID0gdGFyZ2V0VGltZTtcblxuICAgICAgICBpZiAocGFydGlhbCkge1xuICAgICAgICAgIGhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcIkV2ZW50c1wiXS5FUlJPUiwge1xuICAgICAgICAgICAgdHlwZTogX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXJyb3JUeXBlc1wiXS5NRURJQV9FUlJPUixcbiAgICAgICAgICAgIGRldGFpbHM6IF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkVycm9yRGV0YWlsc1wiXS5CVUZGRVJfU0VFS19PVkVSX0hPTEUsXG4gICAgICAgICAgICBmYXRhbDogZmFsc2UsXG4gICAgICAgICAgICByZWFzb246IFwiZnJhZ21lbnQgbG9hZGVkIHdpdGggYnVmZmVyIGhvbGVzLCBzZWVraW5nIGZyb20gXCIgKyBjdXJyZW50VGltZSArIFwiIHRvIFwiICsgdGFyZ2V0VGltZSxcbiAgICAgICAgICAgIGZyYWc6IHBhcnRpYWxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0YXJnZXRUaW1lO1xuICAgICAgfVxuXG4gICAgICBsYXN0RW5kVGltZSA9IGJ1ZmZlcmVkLmVuZChpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gMDtcbiAgfVxuICAvKipcbiAgICogQXR0ZW1wdHMgdG8gZml4IGJ1ZmZlciBzdGFsbHMgYnkgYWR2YW5jaW5nIHRoZSBtZWRpYUVsZW1lbnQncyBjdXJyZW50IHRpbWUgYnkgYSBzbWFsbCBhbW91bnQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLl90cnlOdWRnZUJ1ZmZlciA9IGZ1bmN0aW9uIF90cnlOdWRnZUJ1ZmZlcigpIHtcbiAgICB2YXIgY29uZmlnID0gdGhpcy5jb25maWcsXG4gICAgICAgIGhscyA9IHRoaXMuaGxzLFxuICAgICAgICBtZWRpYSA9IHRoaXMubWVkaWE7XG4gICAgdmFyIGN1cnJlbnRUaW1lID0gbWVkaWEuY3VycmVudFRpbWU7XG4gICAgdmFyIG51ZGdlUmV0cnkgPSAodGhpcy5udWRnZVJldHJ5IHx8IDApICsgMTtcbiAgICB0aGlzLm51ZGdlUmV0cnkgPSBudWRnZVJldHJ5O1xuXG4gICAgaWYgKG51ZGdlUmV0cnkgPCBjb25maWcubnVkZ2VNYXhSZXRyeSkge1xuICAgICAgdmFyIHRhcmdldFRpbWUgPSBjdXJyZW50VGltZSArIG51ZGdlUmV0cnkgKiBjb25maWcubnVkZ2VPZmZzZXQ7IC8vIHBsYXliYWNrIHN0YWxsZWQgaW4gYnVmZmVyZWQgYXJlYSAuLi4gbGV0J3MgbnVkZ2UgY3VycmVudFRpbWUgdG8gdHJ5IHRvIG92ZXJjb21lIHRoaXNcblxuICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wibG9nZ2VyXCJdLndhcm4oXCJOdWRnaW5nICdjdXJyZW50VGltZScgZnJvbSBcIiArIGN1cnJlbnRUaW1lICsgXCIgdG8gXCIgKyB0YXJnZXRUaW1lKTtcbiAgICAgIG1lZGlhLmN1cnJlbnRUaW1lID0gdGFyZ2V0VGltZTtcbiAgICAgIGhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcIkV2ZW50c1wiXS5FUlJPUiwge1xuICAgICAgICB0eXBlOiBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFcnJvclR5cGVzXCJdLk1FRElBX0VSUk9SLFxuICAgICAgICBkZXRhaWxzOiBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFcnJvckRldGFpbHNcIl0uQlVGRkVSX05VREdFX09OX1NUQUxMLFxuICAgICAgICBmYXRhbDogZmFsc2VcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJsb2dnZXJcIl0uZXJyb3IoXCJQbGF5aGVhZCBzdGlsbCBub3QgbW92aW5nIHdoaWxlIGVub3VnaCBkYXRhIGJ1ZmZlcmVkIEBcIiArIGN1cnJlbnRUaW1lICsgXCIgYWZ0ZXIgXCIgKyBjb25maWcubnVkZ2VNYXhSZXRyeSArIFwiIG51ZGdlc1wiKTtcbiAgICAgIGhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcIkV2ZW50c1wiXS5FUlJPUiwge1xuICAgICAgICB0eXBlOiBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFcnJvclR5cGVzXCJdLk1FRElBX0VSUk9SLFxuICAgICAgICBkZXRhaWxzOiBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFcnJvckRldGFpbHNcIl0uQlVGRkVSX1NUQUxMRURfRVJST1IsXG4gICAgICAgIGZhdGFsOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIEdhcENvbnRyb2xsZXI7XG59KCk7XG5cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9jb250cm9sbGVyL2lkMy10cmFjay1jb250cm9sbGVyLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvY29udHJvbGxlci9pZDMtdHJhY2stY29udHJvbGxlci50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZXZlbnRzICovIFwiLi9zcmMvZXZlbnRzLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc190ZXh0dHJhY2tfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL3RleHR0cmFjay11dGlscyAqLyBcIi4vc3JjL3V0aWxzL3RleHR0cmFjay11dGlscy50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZGVtdXhfaWQzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9kZW11eC9pZDMgKi8gXCIuL3NyYy9kZW11eC9pZDMudHNcIik7XG5cblxuXG52YXIgTUlOX0NVRV9EVVJBVElPTiA9IDAuMjU7XG5cbnZhciBJRDNUcmFja0NvbnRyb2xsZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBJRDNUcmFja0NvbnRyb2xsZXIoaGxzKSB7XG4gICAgdGhpcy5obHMgPSB2b2lkIDA7XG4gICAgdGhpcy5pZDNUcmFjayA9IG51bGw7XG4gICAgdGhpcy5tZWRpYSA9IG51bGw7XG4gICAgdGhpcy5obHMgPSBobHM7XG5cbiAgICB0aGlzLl9yZWdpc3Rlckxpc3RlbmVycygpO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IElEM1RyYWNrQ29udHJvbGxlci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgIHRoaXMuX3VucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgfTtcblxuICBfcHJvdG8uX3JlZ2lzdGVyTGlzdGVuZXJzID0gZnVuY3Rpb24gX3JlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIHZhciBobHMgPSB0aGlzLmhscztcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiRXZlbnRzXCJdLk1FRElBX0FUVEFDSEVELCB0aGlzLm9uTWVkaWFBdHRhY2hlZCwgdGhpcyk7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIkV2ZW50c1wiXS5NRURJQV9ERVRBQ0hJTkcsIHRoaXMub25NZWRpYURldGFjaGluZywgdGhpcyk7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIkV2ZW50c1wiXS5GUkFHX1BBUlNJTkdfTUVUQURBVEEsIHRoaXMub25GcmFnUGFyc2luZ01ldGFkYXRhLCB0aGlzKTtcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiRXZlbnRzXCJdLkJVRkZFUl9GTFVTSElORywgdGhpcy5vbkJ1ZmZlckZsdXNoaW5nLCB0aGlzKTtcbiAgfTtcblxuICBfcHJvdG8uX3VucmVnaXN0ZXJMaXN0ZW5lcnMgPSBmdW5jdGlvbiBfdW5yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICB2YXIgaGxzID0gdGhpcy5obHM7XG4gICAgaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJFdmVudHNcIl0uTUVESUFfQVRUQUNIRUQsIHRoaXMub25NZWRpYUF0dGFjaGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIkV2ZW50c1wiXS5NRURJQV9ERVRBQ0hJTkcsIHRoaXMub25NZWRpYURldGFjaGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJFdmVudHNcIl0uRlJBR19QQVJTSU5HX01FVEFEQVRBLCB0aGlzLm9uRnJhZ1BhcnNpbmdNZXRhZGF0YSwgdGhpcyk7XG4gICAgaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJFdmVudHNcIl0uQlVGRkVSX0ZMVVNISU5HLCB0aGlzLm9uQnVmZmVyRmx1c2hpbmcsIHRoaXMpO1xuICB9IC8vIEFkZCBJRDMgbWV0YXRhZGF0YSB0ZXh0IHRyYWNrLlxuICA7XG5cbiAgX3Byb3RvLm9uTWVkaWFBdHRhY2hlZCA9IGZ1bmN0aW9uIG9uTWVkaWFBdHRhY2hlZChldmVudCwgZGF0YSkge1xuICAgIHRoaXMubWVkaWEgPSBkYXRhLm1lZGlhO1xuICB9O1xuXG4gIF9wcm90by5vbk1lZGlhRGV0YWNoaW5nID0gZnVuY3Rpb24gb25NZWRpYURldGFjaGluZygpIHtcbiAgICBpZiAoIXRoaXMuaWQzVHJhY2spIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBPYmplY3QoX3V0aWxzX3RleHR0cmFja191dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiY2xlYXJDdXJyZW50Q3Vlc1wiXSkodGhpcy5pZDNUcmFjayk7XG4gICAgdGhpcy5pZDNUcmFjayA9IG51bGw7XG4gICAgdGhpcy5tZWRpYSA9IG51bGw7XG4gIH07XG5cbiAgX3Byb3RvLmdldElEM1RyYWNrID0gZnVuY3Rpb24gZ2V0SUQzVHJhY2sodGV4dFRyYWNrcykge1xuICAgIGlmICghdGhpcy5tZWRpYSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGV4dFRyYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHRleHRUcmFjayA9IHRleHRUcmFja3NbaV07XG5cbiAgICAgIGlmICh0ZXh0VHJhY2sua2luZCA9PT0gJ21ldGFkYXRhJyAmJiB0ZXh0VHJhY2subGFiZWwgPT09ICdpZDMnKSB7XG4gICAgICAgIC8vIHNlbmQgJ2FkZHRyYWNrJyB3aGVuIHJldXNpbmcgdGhlIHRleHRUcmFjayBmb3IgbWV0YWRhdGEsXG4gICAgICAgIC8vIHNhbWUgYXMgd2hhdCB3ZSBkbyBmb3IgY2FwdGlvbnNcbiAgICAgICAgT2JqZWN0KF91dGlsc190ZXh0dHJhY2tfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcInNlbmRBZGRUcmFja0V2ZW50XCJdKSh0ZXh0VHJhY2ssIHRoaXMubWVkaWEpO1xuICAgICAgICByZXR1cm4gdGV4dFRyYWNrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLm1lZGlhLmFkZFRleHRUcmFjaygnbWV0YWRhdGEnLCAnaWQzJyk7XG4gIH07XG5cbiAgX3Byb3RvLm9uRnJhZ1BhcnNpbmdNZXRhZGF0YSA9IGZ1bmN0aW9uIG9uRnJhZ1BhcnNpbmdNZXRhZGF0YShldmVudCwgZGF0YSkge1xuICAgIGlmICghdGhpcy5tZWRpYSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBmcmFnbWVudCA9IGRhdGEuZnJhZztcbiAgICB2YXIgc2FtcGxlcyA9IGRhdGEuc2FtcGxlczsgLy8gY3JlYXRlIHRyYWNrIGR5bmFtaWNhbGx5XG5cbiAgICBpZiAoIXRoaXMuaWQzVHJhY2spIHtcbiAgICAgIHRoaXMuaWQzVHJhY2sgPSB0aGlzLmdldElEM1RyYWNrKHRoaXMubWVkaWEudGV4dFRyYWNrcyk7XG4gICAgICB0aGlzLmlkM1RyYWNrLm1vZGUgPSAnaGlkZGVuJztcbiAgICB9IC8vIEF0dGVtcHQgdG8gcmVjcmVhdGUgU2FmYXJpIGZ1bmN0aW9uYWxpdHkgYnkgY3JlYXRpbmdcbiAgICAvLyBXZWJLaXREYXRhQ3VlIG9iamVjdHMgd2hlbiBhdmFpbGFibGUgYW5kIHN0b3JlIHRoZSBkZWNvZGVkXG4gICAgLy8gSUQzIGRhdGEgaW4gdGhlIHZhbHVlIHByb3BlcnR5IG9mIHRoZSBjdWVcblxuXG4gICAgdmFyIEN1ZSA9IHNlbGYuV2ViS2l0RGF0YUN1ZSB8fCBzZWxmLlZUVEN1ZSB8fCBzZWxmLlRleHRUcmFja0N1ZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2FtcGxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGZyYW1lcyA9IF9kZW11eF9pZDNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImdldElEM0ZyYW1lc1wiXShzYW1wbGVzW2ldLmRhdGEpO1xuXG4gICAgICBpZiAoZnJhbWVzKSB7XG4gICAgICAgIHZhciBzdGFydFRpbWUgPSBzYW1wbGVzW2ldLnB0cztcbiAgICAgICAgdmFyIGVuZFRpbWUgPSBpIDwgc2FtcGxlcy5sZW5ndGggLSAxID8gc2FtcGxlc1tpICsgMV0ucHRzIDogZnJhZ21lbnQuZW5kO1xuICAgICAgICB2YXIgdGltZURpZmYgPSBlbmRUaW1lIC0gc3RhcnRUaW1lO1xuXG4gICAgICAgIGlmICh0aW1lRGlmZiA8PSAwKSB7XG4gICAgICAgICAgZW5kVGltZSA9IHN0YXJ0VGltZSArIE1JTl9DVUVfRFVSQVRJT047XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGZyYW1lcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIHZhciBmcmFtZSA9IGZyYW1lc1tqXTsgLy8gU2FmYXJpIGRvZXNuJ3QgcHV0IHRoZSB0aW1lc3RhbXAgZnJhbWUgaW4gdGhlIFRleHRUcmFja1xuXG4gICAgICAgICAgaWYgKCFfZGVtdXhfaWQzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJpc1RpbWVTdGFtcEZyYW1lXCJdKGZyYW1lKSkge1xuICAgICAgICAgICAgdmFyIGN1ZSA9IG5ldyBDdWUoc3RhcnRUaW1lLCBlbmRUaW1lLCAnJyk7XG4gICAgICAgICAgICBjdWUudmFsdWUgPSBmcmFtZTtcbiAgICAgICAgICAgIHRoaXMuaWQzVHJhY2suYWRkQ3VlKGN1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5vbkJ1ZmZlckZsdXNoaW5nID0gZnVuY3Rpb24gb25CdWZmZXJGbHVzaGluZyhldmVudCwgX3JlZikge1xuICAgIHZhciBzdGFydE9mZnNldCA9IF9yZWYuc3RhcnRPZmZzZXQsXG4gICAgICAgIGVuZE9mZnNldCA9IF9yZWYuZW5kT2Zmc2V0LFxuICAgICAgICB0eXBlID0gX3JlZi50eXBlO1xuXG4gICAgaWYgKCF0eXBlIHx8IHR5cGUgPT09ICdhdWRpbycpIHtcbiAgICAgIC8vIGlkMyBjdWVzIGNvbWUgZnJvbSBwYXJzZWQgYXVkaW8gb25seSByZW1vdmUgY3VlcyB3aGVuIGF1ZGlvIGJ1ZmZlciBpcyBjbGVhcmVkXG4gICAgICB2YXIgaWQzVHJhY2sgPSB0aGlzLmlkM1RyYWNrO1xuXG4gICAgICBpZiAoaWQzVHJhY2spIHtcbiAgICAgICAgT2JqZWN0KF91dGlsc190ZXh0dHJhY2tfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcInJlbW92ZUN1ZXNJblJhbmdlXCJdKShpZDNUcmFjaywgc3RhcnRPZmZzZXQsIGVuZE9mZnNldCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBJRDNUcmFja0NvbnRyb2xsZXI7XG59KCk7XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoSUQzVHJhY2tDb250cm9sbGVyKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY29udHJvbGxlci9sYXRlbmN5LWNvbnRyb2xsZXIudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvY29udHJvbGxlci9sYXRlbmN5LWNvbnRyb2xsZXIudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJkZWZhdWx0XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gTGF0ZW5jeUNvbnRyb2xsZXI7IH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2Vycm9ycyAqLyBcIi4vc3JjL2Vycm9ycy50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9ldmVudHMgKi8gXCIuL3NyYy9ldmVudHMudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvbG9nZ2VyICovIFwiLi9zcmMvdXRpbHMvbG9nZ2VyLnRzXCIpO1xuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5cblxuXG5cbnZhciBMYXRlbmN5Q29udHJvbGxlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIExhdGVuY3lDb250cm9sbGVyKGhscykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB0aGlzLmhscyA9IHZvaWQgMDtcbiAgICB0aGlzLmNvbmZpZyA9IHZvaWQgMDtcbiAgICB0aGlzLm1lZGlhID0gbnVsbDtcbiAgICB0aGlzLmxldmVsRGV0YWlscyA9IG51bGw7XG4gICAgdGhpcy5jdXJyZW50VGltZSA9IDA7XG4gICAgdGhpcy5zdGFsbENvdW50ID0gMDtcbiAgICB0aGlzLl9sYXRlbmN5ID0gbnVsbDtcblxuICAgIHRoaXMudGltZXVwZGF0ZUhhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX3RoaXMudGltZXVwZGF0ZSgpO1xuICAgIH07XG5cbiAgICB0aGlzLmhscyA9IGhscztcbiAgICB0aGlzLmNvbmZpZyA9IGhscy5jb25maWc7XG4gICAgdGhpcy5yZWdpc3Rlckxpc3RlbmVycygpO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IExhdGVuY3lDb250cm9sbGVyLnByb3RvdHlwZTtcblxuICBfcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgdGhpcy51bnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gICAgdGhpcy5vbk1lZGlhRGV0YWNoaW5nKCk7XG4gICAgdGhpcy5sZXZlbERldGFpbHMgPSBudWxsOyAvLyBAdHMtaWdub3JlXG5cbiAgICB0aGlzLmhscyA9IHRoaXMudGltZXVwZGF0ZUhhbmRsZXIgPSBudWxsO1xuICB9O1xuXG4gIF9wcm90by5yZWdpc3Rlckxpc3RlbmVycyA9IGZ1bmN0aW9uIHJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIHRoaXMuaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkV2ZW50c1wiXS5NRURJQV9BVFRBQ0hFRCwgdGhpcy5vbk1lZGlhQXR0YWNoZWQsIHRoaXMpO1xuICAgIHRoaXMuaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkV2ZW50c1wiXS5NRURJQV9ERVRBQ0hJTkcsIHRoaXMub25NZWRpYURldGFjaGluZywgdGhpcyk7XG4gICAgdGhpcy5obHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXZlbnRzXCJdLk1BTklGRVNUX0xPQURJTkcsIHRoaXMub25NYW5pZmVzdExvYWRpbmcsIHRoaXMpO1xuICAgIHRoaXMuaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkV2ZW50c1wiXS5MRVZFTF9VUERBVEVELCB0aGlzLm9uTGV2ZWxVcGRhdGVkLCB0aGlzKTtcbiAgICB0aGlzLmhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFdmVudHNcIl0uRVJST1IsIHRoaXMub25FcnJvciwgdGhpcyk7XG4gIH07XG5cbiAgX3Byb3RvLnVucmVnaXN0ZXJMaXN0ZW5lcnMgPSBmdW5jdGlvbiB1bnJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIHRoaXMuaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFdmVudHNcIl0uTUVESUFfQVRUQUNIRUQsIHRoaXMub25NZWRpYUF0dGFjaGVkKTtcbiAgICB0aGlzLmhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXZlbnRzXCJdLk1FRElBX0RFVEFDSElORywgdGhpcy5vbk1lZGlhRGV0YWNoaW5nKTtcbiAgICB0aGlzLmhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXZlbnRzXCJdLk1BTklGRVNUX0xPQURJTkcsIHRoaXMub25NYW5pZmVzdExvYWRpbmcpO1xuICAgIHRoaXMuaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFdmVudHNcIl0uTEVWRUxfVVBEQVRFRCwgdGhpcy5vbkxldmVsVXBkYXRlZCk7XG4gICAgdGhpcy5obHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkV2ZW50c1wiXS5FUlJPUiwgdGhpcy5vbkVycm9yKTtcbiAgfTtcblxuICBfcHJvdG8ub25NZWRpYUF0dGFjaGVkID0gZnVuY3Rpb24gb25NZWRpYUF0dGFjaGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgdGhpcy5tZWRpYSA9IGRhdGEubWVkaWE7XG4gICAgdGhpcy5tZWRpYS5hZGRFdmVudExpc3RlbmVyKCd0aW1ldXBkYXRlJywgdGhpcy50aW1ldXBkYXRlSGFuZGxlcik7XG4gIH07XG5cbiAgX3Byb3RvLm9uTWVkaWFEZXRhY2hpbmcgPSBmdW5jdGlvbiBvbk1lZGlhRGV0YWNoaW5nKCkge1xuICAgIGlmICh0aGlzLm1lZGlhKSB7XG4gICAgICB0aGlzLm1lZGlhLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RpbWV1cGRhdGUnLCB0aGlzLnRpbWV1cGRhdGVIYW5kbGVyKTtcbiAgICAgIHRoaXMubWVkaWEgPSBudWxsO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8ub25NYW5pZmVzdExvYWRpbmcgPSBmdW5jdGlvbiBvbk1hbmlmZXN0TG9hZGluZygpIHtcbiAgICB0aGlzLmxldmVsRGV0YWlscyA9IG51bGw7XG4gICAgdGhpcy5fbGF0ZW5jeSA9IG51bGw7XG4gICAgdGhpcy5zdGFsbENvdW50ID0gMDtcbiAgfTtcblxuICBfcHJvdG8ub25MZXZlbFVwZGF0ZWQgPSBmdW5jdGlvbiBvbkxldmVsVXBkYXRlZChldmVudCwgX3JlZikge1xuICAgIHZhciBkZXRhaWxzID0gX3JlZi5kZXRhaWxzO1xuICAgIHRoaXMubGV2ZWxEZXRhaWxzID0gZGV0YWlscztcblxuICAgIGlmIChkZXRhaWxzLmFkdmFuY2VkKSB7XG4gICAgICB0aGlzLnRpbWV1cGRhdGUoKTtcbiAgICB9XG5cbiAgICBpZiAoIWRldGFpbHMubGl2ZSAmJiB0aGlzLm1lZGlhKSB7XG4gICAgICB0aGlzLm1lZGlhLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RpbWV1cGRhdGUnLCB0aGlzLnRpbWV1cGRhdGVIYW5kbGVyKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLm9uRXJyb3IgPSBmdW5jdGlvbiBvbkVycm9yKGV2ZW50LCBkYXRhKSB7XG4gICAgaWYgKGRhdGEuZGV0YWlscyAhPT0gX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiRXJyb3JEZXRhaWxzXCJdLkJVRkZFUl9TVEFMTEVEX0VSUk9SKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5zdGFsbENvdW50Kys7XG4gICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wibG9nZ2VyXCJdLndhcm4oJ1twbGF5YmFjay1yYXRlLWNvbnRyb2xsZXJdOiBTdGFsbCBkZXRlY3RlZCwgYWRqdXN0aW5nIHRhcmdldCBsYXRlbmN5Jyk7XG4gIH07XG5cbiAgX3Byb3RvLnRpbWV1cGRhdGUgPSBmdW5jdGlvbiB0aW1ldXBkYXRlKCkge1xuICAgIHZhciBtZWRpYSA9IHRoaXMubWVkaWEsXG4gICAgICAgIGxldmVsRGV0YWlscyA9IHRoaXMubGV2ZWxEZXRhaWxzO1xuXG4gICAgaWYgKCFtZWRpYSB8fCAhbGV2ZWxEZXRhaWxzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5jdXJyZW50VGltZSA9IG1lZGlhLmN1cnJlbnRUaW1lO1xuICAgIHZhciBsYXRlbmN5ID0gdGhpcy5jb21wdXRlTGF0ZW5jeSgpO1xuXG4gICAgaWYgKGxhdGVuY3kgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9sYXRlbmN5ID0gbGF0ZW5jeTsgLy8gQWRhcHQgcGxheWJhY2tSYXRlIHRvIG1lZXQgdGFyZ2V0IGxhdGVuY3kgaW4gbG93LWxhdGVuY3kgbW9kZVxuXG4gICAgdmFyIF90aGlzJGNvbmZpZyA9IHRoaXMuY29uZmlnLFxuICAgICAgICBsb3dMYXRlbmN5TW9kZSA9IF90aGlzJGNvbmZpZy5sb3dMYXRlbmN5TW9kZSxcbiAgICAgICAgbWF4TGl2ZVN5bmNQbGF5YmFja1JhdGUgPSBfdGhpcyRjb25maWcubWF4TGl2ZVN5bmNQbGF5YmFja1JhdGU7XG5cbiAgICBpZiAoIWxvd0xhdGVuY3lNb2RlIHx8IG1heExpdmVTeW5jUGxheWJhY2tSYXRlID09PSAxKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHRhcmdldExhdGVuY3kgPSB0aGlzLnRhcmdldExhdGVuY3k7XG5cbiAgICBpZiAodGFyZ2V0TGF0ZW5jeSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBkaXN0YW5jZUZyb21UYXJnZXQgPSBsYXRlbmN5IC0gdGFyZ2V0TGF0ZW5jeTsgLy8gT25seSBhZGp1c3QgcGxheWJhY2tSYXRlIHdoZW4gd2l0aGluIG9uZSB0YXJnZXQgZHVyYXRpb24gb2YgdGFyZ2V0TGF0ZW5jeVxuICAgIC8vIGFuZCBtb3JlIHRoYW4gb25lIHNlY29uZCBmcm9tIHVuZGVyLWJ1ZmZlcmluZy5cbiAgICAvLyBQbGF5YmFjayBmdXJ0aGVyIHRoYW4gb25lIHRhcmdldCBkdXJhdGlvbiBmcm9tIHRhcmdldCBjYW4gYmUgY29uc2lkZXJlZCBEVlIgcGxheWJhY2suXG5cbiAgICB2YXIgbGl2ZU1pbkxhdGVuY3lEdXJhdGlvbiA9IE1hdGgubWluKHRoaXMubWF4TGF0ZW5jeSwgdGFyZ2V0TGF0ZW5jeSArIGxldmVsRGV0YWlscy50YXJnZXRkdXJhdGlvbik7XG4gICAgdmFyIGluTGl2ZVJhbmdlID0gZGlzdGFuY2VGcm9tVGFyZ2V0IDwgbGl2ZU1pbkxhdGVuY3lEdXJhdGlvbjtcblxuICAgIGlmIChsZXZlbERldGFpbHMubGl2ZSAmJiBpbkxpdmVSYW5nZSAmJiBkaXN0YW5jZUZyb21UYXJnZXQgPiAwLjA1ICYmIHRoaXMuZm9yd2FyZEJ1ZmZlckxlbmd0aCA+IDEpIHtcbiAgICAgIHZhciBtYXggPSBNYXRoLm1pbigyLCBNYXRoLm1heCgxLjAsIG1heExpdmVTeW5jUGxheWJhY2tSYXRlKSk7XG4gICAgICB2YXIgcmF0ZSA9IE1hdGgucm91bmQoMiAvICgxICsgTWF0aC5leHAoLTAuNzUgKiBkaXN0YW5jZUZyb21UYXJnZXQgLSB0aGlzLmVkZ2VTdGFsbGVkKSkgKiAyMCkgLyAyMDtcbiAgICAgIG1lZGlhLnBsYXliYWNrUmF0ZSA9IE1hdGgubWluKG1heCwgTWF0aC5tYXgoMSwgcmF0ZSkpO1xuICAgIH0gZWxzZSBpZiAobWVkaWEucGxheWJhY2tSYXRlICE9PSAxICYmIG1lZGlhLnBsYXliYWNrUmF0ZSAhPT0gMCkge1xuICAgICAgbWVkaWEucGxheWJhY2tSYXRlID0gMTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmVzdGltYXRlTGl2ZUVkZ2UgPSBmdW5jdGlvbiBlc3RpbWF0ZUxpdmVFZGdlKCkge1xuICAgIHZhciBsZXZlbERldGFpbHMgPSB0aGlzLmxldmVsRGV0YWlscztcblxuICAgIGlmIChsZXZlbERldGFpbHMgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBsZXZlbERldGFpbHMuZWRnZSArIGxldmVsRGV0YWlscy5hZ2U7XG4gIH07XG5cbiAgX3Byb3RvLmNvbXB1dGVMYXRlbmN5ID0gZnVuY3Rpb24gY29tcHV0ZUxhdGVuY3koKSB7XG4gICAgdmFyIGxpdmVFZGdlID0gdGhpcy5lc3RpbWF0ZUxpdmVFZGdlKCk7XG5cbiAgICBpZiAobGl2ZUVkZ2UgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBsaXZlRWRnZSAtIHRoaXMuY3VycmVudFRpbWU7XG4gIH07XG5cbiAgX2NyZWF0ZUNsYXNzKExhdGVuY3lDb250cm9sbGVyLCBbe1xuICAgIGtleTogXCJsYXRlbmN5XCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbGF0ZW5jeSB8fCAwO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtYXhMYXRlbmN5XCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgY29uZmlnID0gdGhpcy5jb25maWcsXG4gICAgICAgICAgbGV2ZWxEZXRhaWxzID0gdGhpcy5sZXZlbERldGFpbHM7XG5cbiAgICAgIGlmIChjb25maWcubGl2ZU1heExhdGVuY3lEdXJhdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBjb25maWcubGl2ZU1heExhdGVuY3lEdXJhdGlvbjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGxldmVsRGV0YWlscyA/IGNvbmZpZy5saXZlTWF4TGF0ZW5jeUR1cmF0aW9uQ291bnQgKiBsZXZlbERldGFpbHMudGFyZ2V0ZHVyYXRpb24gOiAwO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0YXJnZXRMYXRlbmN5XCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgbGV2ZWxEZXRhaWxzID0gdGhpcy5sZXZlbERldGFpbHM7XG5cbiAgICAgIGlmIChsZXZlbERldGFpbHMgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciBob2xkQmFjayA9IGxldmVsRGV0YWlscy5ob2xkQmFjayxcbiAgICAgICAgICBwYXJ0SG9sZEJhY2sgPSBsZXZlbERldGFpbHMucGFydEhvbGRCYWNrLFxuICAgICAgICAgIHRhcmdldGR1cmF0aW9uID0gbGV2ZWxEZXRhaWxzLnRhcmdldGR1cmF0aW9uO1xuICAgICAgdmFyIF90aGlzJGNvbmZpZzIgPSB0aGlzLmNvbmZpZyxcbiAgICAgICAgICBsaXZlU3luY0R1cmF0aW9uID0gX3RoaXMkY29uZmlnMi5saXZlU3luY0R1cmF0aW9uLFxuICAgICAgICAgIGxpdmVTeW5jRHVyYXRpb25Db3VudCA9IF90aGlzJGNvbmZpZzIubGl2ZVN5bmNEdXJhdGlvbkNvdW50LFxuICAgICAgICAgIGxvd0xhdGVuY3lNb2RlID0gX3RoaXMkY29uZmlnMi5sb3dMYXRlbmN5TW9kZTtcbiAgICAgIHZhciB1c2VyQ29uZmlnID0gdGhpcy5obHMudXNlckNvbmZpZztcbiAgICAgIHZhciB0YXJnZXRMYXRlbmN5ID0gbG93TGF0ZW5jeU1vZGUgPyBwYXJ0SG9sZEJhY2sgfHwgaG9sZEJhY2sgOiBob2xkQmFjaztcblxuICAgICAgaWYgKHVzZXJDb25maWcubGl2ZVN5bmNEdXJhdGlvbiB8fCB1c2VyQ29uZmlnLmxpdmVTeW5jRHVyYXRpb25Db3VudCB8fCB0YXJnZXRMYXRlbmN5ID09PSAwKSB7XG4gICAgICAgIHRhcmdldExhdGVuY3kgPSBsaXZlU3luY0R1cmF0aW9uICE9PSB1bmRlZmluZWQgPyBsaXZlU3luY0R1cmF0aW9uIDogbGl2ZVN5bmNEdXJhdGlvbkNvdW50ICogdGFyZ2V0ZHVyYXRpb247XG4gICAgICB9XG5cbiAgICAgIHZhciBtYXhMaXZlU3luY09uU3RhbGxJbmNyZWFzZSA9IHRhcmdldGR1cmF0aW9uO1xuICAgICAgdmFyIGxpdmVTeW5jT25TdGFsbEluY3JlYXNlID0gMS4wO1xuICAgICAgcmV0dXJuIHRhcmdldExhdGVuY3kgKyBNYXRoLm1pbih0aGlzLnN0YWxsQ291bnQgKiBsaXZlU3luY09uU3RhbGxJbmNyZWFzZSwgbWF4TGl2ZVN5bmNPblN0YWxsSW5jcmVhc2UpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJsaXZlU3luY1Bvc2l0aW9uXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgbGl2ZUVkZ2UgPSB0aGlzLmVzdGltYXRlTGl2ZUVkZ2UoKTtcbiAgICAgIHZhciB0YXJnZXRMYXRlbmN5ID0gdGhpcy50YXJnZXRMYXRlbmN5O1xuICAgICAgdmFyIGxldmVsRGV0YWlscyA9IHRoaXMubGV2ZWxEZXRhaWxzO1xuXG4gICAgICBpZiAobGl2ZUVkZ2UgPT09IG51bGwgfHwgdGFyZ2V0TGF0ZW5jeSA9PT0gbnVsbCB8fCBsZXZlbERldGFpbHMgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciBlZGdlID0gbGV2ZWxEZXRhaWxzLmVkZ2U7XG4gICAgICB2YXIgc3luY1Bvc2l0aW9uID0gbGl2ZUVkZ2UgLSB0YXJnZXRMYXRlbmN5IC0gdGhpcy5lZGdlU3RhbGxlZDtcbiAgICAgIHZhciBtaW4gPSBlZGdlIC0gbGV2ZWxEZXRhaWxzLnRvdGFsZHVyYXRpb247XG4gICAgICB2YXIgbWF4ID0gZWRnZSAtICh0aGlzLmNvbmZpZy5sb3dMYXRlbmN5TW9kZSAmJiBsZXZlbERldGFpbHMucGFydFRhcmdldCB8fCBsZXZlbERldGFpbHMudGFyZ2V0ZHVyYXRpb24pO1xuICAgICAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KG1pbiwgc3luY1Bvc2l0aW9uKSwgbWF4KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZHJpZnRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciBsZXZlbERldGFpbHMgPSB0aGlzLmxldmVsRGV0YWlscztcblxuICAgICAgaWYgKGxldmVsRGV0YWlscyA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGxldmVsRGV0YWlscy5kcmlmdDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZWRnZVN0YWxsZWRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciBsZXZlbERldGFpbHMgPSB0aGlzLmxldmVsRGV0YWlscztcblxuICAgICAgaWYgKGxldmVsRGV0YWlscyA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cblxuICAgICAgdmFyIG1heExldmVsVXBkYXRlQWdlID0gKHRoaXMuY29uZmlnLmxvd0xhdGVuY3lNb2RlICYmIGxldmVsRGV0YWlscy5wYXJ0VGFyZ2V0IHx8IGxldmVsRGV0YWlscy50YXJnZXRkdXJhdGlvbikgKiAzO1xuICAgICAgcmV0dXJuIE1hdGgubWF4KGxldmVsRGV0YWlscy5hZ2UgLSBtYXhMZXZlbFVwZGF0ZUFnZSwgMCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZvcndhcmRCdWZmZXJMZW5ndGhcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciBtZWRpYSA9IHRoaXMubWVkaWEsXG4gICAgICAgICAgbGV2ZWxEZXRhaWxzID0gdGhpcy5sZXZlbERldGFpbHM7XG5cbiAgICAgIGlmICghbWVkaWEgfHwgIWxldmVsRGV0YWlscykge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cblxuICAgICAgdmFyIGJ1ZmZlcmVkUmFuZ2VzID0gbWVkaWEuYnVmZmVyZWQubGVuZ3RoO1xuICAgICAgcmV0dXJuIGJ1ZmZlcmVkUmFuZ2VzID8gbWVkaWEuYnVmZmVyZWQuZW5kKGJ1ZmZlcmVkUmFuZ2VzIC0gMSkgOiBsZXZlbERldGFpbHMuZWRnZSAtIHRoaXMuY3VycmVudFRpbWU7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIExhdGVuY3lDb250cm9sbGVyO1xufSgpO1xuXG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY29udHJvbGxlci9sZXZlbC1jb250cm9sbGVyLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9jb250cm9sbGVyL2xldmVsLWNvbnRyb2xsZXIudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZGVmYXVsdFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIExldmVsQ29udHJvbGxlcjsgfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3R5cGVzX2xldmVsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi90eXBlcy9sZXZlbCAqLyBcIi4vc3JjL3R5cGVzL2xldmVsLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2V2ZW50cyAqLyBcIi4vc3JjL2V2ZW50cy50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9lcnJvcnMgKi8gXCIuL3NyYy9lcnJvcnMudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2NvZGVjc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvY29kZWNzICovIFwiLi9zcmMvdXRpbHMvY29kZWNzLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9sZXZlbF9oZWxwZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbGV2ZWwtaGVscGVyICovIFwiLi9zcmMvY29udHJvbGxlci9sZXZlbC1oZWxwZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2Jhc2VfcGxheWxpc3RfY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9iYXNlLXBsYXlsaXN0LWNvbnRyb2xsZXIgKi8gXCIuL3NyYy9jb250cm9sbGVyL2Jhc2UtcGxheWxpc3QtY29udHJvbGxlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdHlwZXNfbG9hZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi90eXBlcy9sb2FkZXIgKi8gXCIuL3NyYy90eXBlcy9sb2FkZXIudHNcIik7XG5mdW5jdGlvbiBfZXh0ZW5kcygpIHsgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpOyBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzczsgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG4vKlxuICogTGV2ZWwgQ29udHJvbGxlclxuICovXG5cblxuXG5cblxuXG5cbnZhciBjaHJvbWVPckZpcmVmb3ggPSAvY2hyb21lfGZpcmVmb3gvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpKTtcblxudmFyIExldmVsQ29udHJvbGxlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0Jhc2VQbGF5bGlzdENvbnRyb2xsKSB7XG4gIF9pbmhlcml0c0xvb3NlKExldmVsQ29udHJvbGxlciwgX0Jhc2VQbGF5bGlzdENvbnRyb2xsKTtcblxuICBmdW5jdGlvbiBMZXZlbENvbnRyb2xsZXIoaGxzKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX3RoaXMgPSBfQmFzZVBsYXlsaXN0Q29udHJvbGwuY2FsbCh0aGlzLCBobHMsICdbbGV2ZWwtY29udHJvbGxlcl0nKSB8fCB0aGlzO1xuICAgIF90aGlzLl9sZXZlbHMgPSBbXTtcbiAgICBfdGhpcy5fZmlyc3RMZXZlbCA9IC0xO1xuICAgIF90aGlzLl9zdGFydExldmVsID0gdm9pZCAwO1xuICAgIF90aGlzLmN1cnJlbnRMZXZlbEluZGV4ID0gLTE7XG4gICAgX3RoaXMubWFudWFsTGV2ZWxJbmRleCA9IC0xO1xuICAgIF90aGlzLm9uUGFyc2VkQ29tcGxldGUgPSB2b2lkIDA7XG5cbiAgICBfdGhpcy5fcmVnaXN0ZXJMaXN0ZW5lcnMoKTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBMZXZlbENvbnRyb2xsZXIucHJvdG90eXBlO1xuXG4gIF9wcm90by5fcmVnaXN0ZXJMaXN0ZW5lcnMgPSBmdW5jdGlvbiBfcmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgdmFyIGhscyA9IHRoaXMuaGxzO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFdmVudHNcIl0uTUFOSUZFU1RfTE9BREVELCB0aGlzLm9uTWFuaWZlc3RMb2FkZWQsIHRoaXMpO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFdmVudHNcIl0uTEVWRUxfTE9BREVELCB0aGlzLm9uTGV2ZWxMb2FkZWQsIHRoaXMpO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFdmVudHNcIl0uQVVESU9fVFJBQ0tfU1dJVENIRUQsIHRoaXMub25BdWRpb1RyYWNrU3dpdGNoZWQsIHRoaXMpO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFdmVudHNcIl0uRlJBR19MT0FERUQsIHRoaXMub25GcmFnTG9hZGVkLCB0aGlzKTtcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXZlbnRzXCJdLkVSUk9SLCB0aGlzLm9uRXJyb3IsIHRoaXMpO1xuICB9O1xuXG4gIF9wcm90by5fdW5yZWdpc3Rlckxpc3RlbmVycyA9IGZ1bmN0aW9uIF91bnJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIHZhciBobHMgPSB0aGlzLmhscztcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkV2ZW50c1wiXS5NQU5JRkVTVF9MT0FERUQsIHRoaXMub25NYW5pZmVzdExvYWRlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFdmVudHNcIl0uTEVWRUxfTE9BREVELCB0aGlzLm9uTGV2ZWxMb2FkZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXZlbnRzXCJdLkFVRElPX1RSQUNLX1NXSVRDSEVELCB0aGlzLm9uQXVkaW9UcmFja1N3aXRjaGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkV2ZW50c1wiXS5GUkFHX0xPQURFRCwgdGhpcy5vbkZyYWdMb2FkZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXZlbnRzXCJdLkVSUk9SLCB0aGlzLm9uRXJyb3IsIHRoaXMpO1xuICB9O1xuXG4gIF9wcm90by5kZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICB0aGlzLl91bnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG5cbiAgICB0aGlzLm1hbnVhbExldmVsSW5kZXggPSAtMTtcbiAgICB0aGlzLl9sZXZlbHMubGVuZ3RoID0gMDtcblxuICAgIF9CYXNlUGxheWxpc3RDb250cm9sbC5wcm90b3R5cGUuZGVzdHJveS5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIF9wcm90by5zdGFydExvYWQgPSBmdW5jdGlvbiBzdGFydExvYWQoKSB7XG4gICAgdmFyIGxldmVscyA9IHRoaXMuX2xldmVsczsgLy8gY2xlYW4gdXAgbGl2ZSBsZXZlbCBkZXRhaWxzIHRvIGZvcmNlIHJlbG9hZCB0aGVtLCBhbmQgcmVzZXQgbG9hZCBlcnJvcnNcblxuICAgIGxldmVscy5mb3JFYWNoKGZ1bmN0aW9uIChsZXZlbCkge1xuICAgICAgbGV2ZWwubG9hZEVycm9yID0gMDtcbiAgICB9KTtcblxuICAgIF9CYXNlUGxheWxpc3RDb250cm9sbC5wcm90b3R5cGUuc3RhcnRMb2FkLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgX3Byb3RvLm9uTWFuaWZlc3RMb2FkZWQgPSBmdW5jdGlvbiBvbk1hbmlmZXN0TG9hZGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgdmFyIGxldmVscyA9IFtdO1xuICAgIHZhciBhdWRpb1RyYWNrcyA9IFtdO1xuICAgIHZhciBzdWJ0aXRsZVRyYWNrcyA9IFtdO1xuICAgIHZhciBiaXRyYXRlU3RhcnQ7XG4gICAgdmFyIGxldmVsU2V0ID0ge307XG4gICAgdmFyIGxldmVsRnJvbVNldDtcbiAgICB2YXIgcmVzb2x1dGlvbkZvdW5kID0gZmFsc2U7XG4gICAgdmFyIHZpZGVvQ29kZWNGb3VuZCA9IGZhbHNlO1xuICAgIHZhciBhdWRpb0NvZGVjRm91bmQgPSBmYWxzZTsgLy8gcmVncm91cCByZWR1bmRhbnQgbGV2ZWxzIHRvZ2V0aGVyXG5cbiAgICBkYXRhLmxldmVscy5mb3JFYWNoKGZ1bmN0aW9uIChsZXZlbFBhcnNlZCkge1xuICAgICAgdmFyIGF0dHJpYnV0ZXMgPSBsZXZlbFBhcnNlZC5hdHRycztcbiAgICAgIHJlc29sdXRpb25Gb3VuZCA9IHJlc29sdXRpb25Gb3VuZCB8fCAhIShsZXZlbFBhcnNlZC53aWR0aCAmJiBsZXZlbFBhcnNlZC5oZWlnaHQpO1xuICAgICAgdmlkZW9Db2RlY0ZvdW5kID0gdmlkZW9Db2RlY0ZvdW5kIHx8ICEhbGV2ZWxQYXJzZWQudmlkZW9Db2RlYztcbiAgICAgIGF1ZGlvQ29kZWNGb3VuZCA9IGF1ZGlvQ29kZWNGb3VuZCB8fCAhIWxldmVsUGFyc2VkLmF1ZGlvQ29kZWM7IC8vIGVyYXNlIGF1ZGlvIGNvZGVjIGluZm8gaWYgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IG1wNGEuNDAuMzQuXG4gICAgICAvLyBkZW11eGVyIHdpbGwgYXV0b2RldGVjdCBjb2RlYyBhbmQgZmFsbGJhY2sgdG8gbXBlZy9hdWRpb1xuXG4gICAgICBpZiAoY2hyb21lT3JGaXJlZm94ICYmIGxldmVsUGFyc2VkLmF1ZGlvQ29kZWMgJiYgbGV2ZWxQYXJzZWQuYXVkaW9Db2RlYy5pbmRleE9mKCdtcDRhLjQwLjM0JykgIT09IC0xKSB7XG4gICAgICAgIGxldmVsUGFyc2VkLmF1ZGlvQ29kZWMgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIHZhciBsZXZlbEtleSA9IGxldmVsUGFyc2VkLmJpdHJhdGUgKyBcIi1cIiArIGxldmVsUGFyc2VkLmF0dHJzLlJFU09MVVRJT04gKyBcIi1cIiArIGxldmVsUGFyc2VkLmF0dHJzLkNPREVDUztcbiAgICAgIGxldmVsRnJvbVNldCA9IGxldmVsU2V0W2xldmVsS2V5XTtcblxuICAgICAgaWYgKCFsZXZlbEZyb21TZXQpIHtcbiAgICAgICAgbGV2ZWxGcm9tU2V0ID0gbmV3IF90eXBlc19sZXZlbF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiTGV2ZWxcIl0obGV2ZWxQYXJzZWQpO1xuICAgICAgICBsZXZlbFNldFtsZXZlbEtleV0gPSBsZXZlbEZyb21TZXQ7XG4gICAgICAgIGxldmVscy5wdXNoKGxldmVsRnJvbVNldCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXZlbEZyb21TZXQudXJsLnB1c2gobGV2ZWxQYXJzZWQudXJsKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgaWYgKGF0dHJpYnV0ZXMuQVVESU8pIHtcbiAgICAgICAgICBPYmplY3QoX2xldmVsX2hlbHBlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fW1wiYWRkR3JvdXBJZFwiXSkobGV2ZWxGcm9tU2V0LCAnYXVkaW8nLCBhdHRyaWJ1dGVzLkFVRElPKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhdHRyaWJ1dGVzLlNVQlRJVExFUykge1xuICAgICAgICAgIE9iamVjdChfbGV2ZWxfaGVscGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXCJhZGRHcm91cElkXCJdKShsZXZlbEZyb21TZXQsICd0ZXh0JywgYXR0cmlidXRlcy5TVUJUSVRMRVMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7IC8vIHJlbW92ZSBhdWRpby1vbmx5IGxldmVsIGlmIHdlIGFsc28gaGF2ZSBsZXZlbHMgd2l0aCB2aWRlbyBjb2RlY3Mgb3IgUkVTT0xVVElPTiBzaWduYWxsZWRcblxuICAgIGlmICgocmVzb2x1dGlvbkZvdW5kIHx8IHZpZGVvQ29kZWNGb3VuZCkgJiYgYXVkaW9Db2RlY0ZvdW5kKSB7XG4gICAgICBsZXZlbHMgPSBsZXZlbHMuZmlsdGVyKGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICAgIHZhciB2aWRlb0NvZGVjID0gX3JlZi52aWRlb0NvZGVjLFxuICAgICAgICAgICAgd2lkdGggPSBfcmVmLndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0ID0gX3JlZi5oZWlnaHQ7XG4gICAgICAgIHJldHVybiAhIXZpZGVvQ29kZWMgfHwgISEod2lkdGggJiYgaGVpZ2h0KTtcbiAgICAgIH0pO1xuICAgIH0gLy8gb25seSBrZWVwIGxldmVscyB3aXRoIHN1cHBvcnRlZCBhdWRpby92aWRlbyBjb2RlY3NcblxuXG4gICAgbGV2ZWxzID0gbGV2ZWxzLmZpbHRlcihmdW5jdGlvbiAoX3JlZjIpIHtcbiAgICAgIHZhciBhdWRpb0NvZGVjID0gX3JlZjIuYXVkaW9Db2RlYyxcbiAgICAgICAgICB2aWRlb0NvZGVjID0gX3JlZjIudmlkZW9Db2RlYztcbiAgICAgIHJldHVybiAoIWF1ZGlvQ29kZWMgfHwgT2JqZWN0KF91dGlsc19jb2RlY3NfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcImlzQ29kZWNTdXBwb3J0ZWRJbk1wNFwiXSkoYXVkaW9Db2RlYywgJ2F1ZGlvJykpICYmICghdmlkZW9Db2RlYyB8fCBPYmplY3QoX3V0aWxzX2NvZGVjc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiaXNDb2RlY1N1cHBvcnRlZEluTXA0XCJdKSh2aWRlb0NvZGVjLCAndmlkZW8nKSk7XG4gICAgfSk7XG5cbiAgICBpZiAoZGF0YS5hdWRpb1RyYWNrcykge1xuICAgICAgYXVkaW9UcmFja3MgPSBkYXRhLmF1ZGlvVHJhY2tzLmZpbHRlcihmdW5jdGlvbiAodHJhY2spIHtcbiAgICAgICAgcmV0dXJuICF0cmFjay5hdWRpb0NvZGVjIHx8IE9iamVjdChfdXRpbHNfY29kZWNzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJpc0NvZGVjU3VwcG9ydGVkSW5NcDRcIl0pKHRyYWNrLmF1ZGlvQ29kZWMsICdhdWRpbycpO1xuICAgICAgfSk7IC8vIEFzc2lnbiBpZHMgYWZ0ZXIgZmlsdGVyaW5nIGFzIGFycmF5IGluZGljZXMgYnkgZ3JvdXAtaWRcblxuICAgICAgT2JqZWN0KF9sZXZlbF9oZWxwZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1tcImFzc2lnblRyYWNrSWRzQnlHcm91cFwiXSkoYXVkaW9UcmFja3MpO1xuICAgIH1cblxuICAgIGlmIChkYXRhLnN1YnRpdGxlcykge1xuICAgICAgc3VidGl0bGVUcmFja3MgPSBkYXRhLnN1YnRpdGxlcztcbiAgICAgIE9iamVjdChfbGV2ZWxfaGVscGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXCJhc3NpZ25UcmFja0lkc0J5R3JvdXBcIl0pKHN1YnRpdGxlVHJhY2tzKTtcbiAgICB9XG5cbiAgICBpZiAobGV2ZWxzLmxlbmd0aCA+IDApIHtcbiAgICAgIC8vIHN0YXJ0IGJpdHJhdGUgaXMgdGhlIGZpcnN0IGJpdHJhdGUgb2YgdGhlIG1hbmlmZXN0XG4gICAgICBiaXRyYXRlU3RhcnQgPSBsZXZlbHNbMF0uYml0cmF0ZTsgLy8gc29ydCBsZXZlbCBvbiBiaXRyYXRlXG5cbiAgICAgIGxldmVscy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiBhLmJpdHJhdGUgLSBiLmJpdHJhdGU7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuX2xldmVscyA9IGxldmVsczsgLy8gZmluZCBpbmRleCBvZiBmaXJzdCBsZXZlbCBpbiBzb3J0ZWQgbGV2ZWxzXG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGV2ZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChsZXZlbHNbaV0uYml0cmF0ZSA9PT0gYml0cmF0ZVN0YXJ0KSB7XG4gICAgICAgICAgdGhpcy5fZmlyc3RMZXZlbCA9IGk7XG4gICAgICAgICAgdGhpcy5sb2coXCJtYW5pZmVzdCBsb2FkZWQsIFwiICsgbGV2ZWxzLmxlbmd0aCArIFwiIGxldmVsKHMpIGZvdW5kLCBmaXJzdCBiaXRyYXRlOiBcIiArIGJpdHJhdGVTdGFydCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gQXVkaW8gaXMgb25seSBhbHRlcm5hdGUgaWYgbWFuaWZlc3QgaW5jbHVkZSBhIFVSSSBhbG9uZyB3aXRoIHRoZSBhdWRpbyBncm91cCB0YWcsXG4gICAgICAvLyBhbmQgdGhpcyBpcyBub3QgYW4gYXVkaW8tb25seSBzdHJlYW0gd2hlcmUgbGV2ZWxzIGNvbnRhaW4gYXVkaW8tb25seVxuXG5cbiAgICAgIHZhciBhdWRpb09ubHkgPSBhdWRpb0NvZGVjRm91bmQgJiYgIXZpZGVvQ29kZWNGb3VuZDtcbiAgICAgIHZhciBlZGF0YSA9IHtcbiAgICAgICAgbGV2ZWxzOiBsZXZlbHMsXG4gICAgICAgIGF1ZGlvVHJhY2tzOiBhdWRpb1RyYWNrcyxcbiAgICAgICAgc3VidGl0bGVUcmFja3M6IHN1YnRpdGxlVHJhY2tzLFxuICAgICAgICBmaXJzdExldmVsOiB0aGlzLl9maXJzdExldmVsLFxuICAgICAgICBzdGF0czogZGF0YS5zdGF0cyxcbiAgICAgICAgYXVkaW86IGF1ZGlvQ29kZWNGb3VuZCxcbiAgICAgICAgdmlkZW86IHZpZGVvQ29kZWNGb3VuZCxcbiAgICAgICAgYWx0QXVkaW86ICFhdWRpb09ubHkgJiYgYXVkaW9UcmFja3Muc29tZShmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHJldHVybiAhIXQudXJsO1xuICAgICAgICB9KVxuICAgICAgfTtcbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXZlbnRzXCJdLk1BTklGRVNUX1BBUlNFRCwgZWRhdGEpOyAvLyBJbml0aWF0ZSBsb2FkaW5nIGFmdGVyIGFsbCBjb250cm9sbGVycyBoYXZlIHJlY2VpdmVkIE1BTklGRVNUX1BBUlNFRFxuXG4gICAgICBpZiAodGhpcy5obHMuY29uZmlnLmF1dG9TdGFydExvYWQgfHwgdGhpcy5obHMuZm9yY2VTdGFydExvYWQpIHtcbiAgICAgICAgdGhpcy5obHMuc3RhcnRMb2FkKHRoaXMuaGxzLmNvbmZpZy5zdGFydFBvc2l0aW9uKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5obHMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFdmVudHNcIl0uRVJST1IsIHtcbiAgICAgICAgdHlwZTogX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiRXJyb3JUeXBlc1wiXS5NRURJQV9FUlJPUixcbiAgICAgICAgZGV0YWlsczogX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiRXJyb3JEZXRhaWxzXCJdLk1BTklGRVNUX0lOQ09NUEFUSUJMRV9DT0RFQ1NfRVJST1IsXG4gICAgICAgIGZhdGFsOiB0cnVlLFxuICAgICAgICB1cmw6IGRhdGEudXJsLFxuICAgICAgICByZWFzb246ICdubyBsZXZlbCB3aXRoIGNvbXBhdGlibGUgY29kZWNzIGZvdW5kIGluIG1hbmlmZXN0J1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5vbkVycm9yID0gZnVuY3Rpb24gb25FcnJvcihldmVudCwgZGF0YSkge1xuICAgIF9CYXNlUGxheWxpc3RDb250cm9sbC5wcm90b3R5cGUub25FcnJvci5jYWxsKHRoaXMsIGV2ZW50LCBkYXRhKTtcblxuICAgIGlmIChkYXRhLmZhdGFsKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBTd2l0Y2ggdG8gcmVkdW5kYW50IGxldmVsIHdoZW4gdHJhY2sgZmFpbHMgdG8gbG9hZFxuXG5cbiAgICB2YXIgY29udGV4dCA9IGRhdGEuY29udGV4dDtcbiAgICB2YXIgbGV2ZWwgPSB0aGlzLl9sZXZlbHNbdGhpcy5jdXJyZW50TGV2ZWxJbmRleF07XG5cbiAgICBpZiAoY29udGV4dCAmJiAoY29udGV4dC50eXBlID09PSBfdHlwZXNfbG9hZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXCJQbGF5bGlzdENvbnRleHRUeXBlXCJdLkFVRElPX1RSQUNLICYmIGxldmVsLmF1ZGlvR3JvdXBJZHMgJiYgY29udGV4dC5ncm91cElkID09PSBsZXZlbC5hdWRpb0dyb3VwSWRzW2xldmVsLnVybElkXSB8fCBjb250ZXh0LnR5cGUgPT09IF90eXBlc19sb2FkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcIlBsYXlsaXN0Q29udGV4dFR5cGVcIl0uU1VCVElUTEVfVFJBQ0sgJiYgbGV2ZWwudGV4dEdyb3VwSWRzICYmIGNvbnRleHQuZ3JvdXBJZCA9PT0gbGV2ZWwudGV4dEdyb3VwSWRzW2xldmVsLnVybElkXSkpIHtcbiAgICAgIHRoaXMucmVkdW5kYW50RmFpbG92ZXIodGhpcy5jdXJyZW50TGV2ZWxJbmRleCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGxldmVsRXJyb3IgPSBmYWxzZTtcbiAgICB2YXIgbGV2ZWxTd2l0Y2ggPSB0cnVlO1xuICAgIHZhciBsZXZlbEluZGV4OyAvLyB0cnkgdG8gcmVjb3ZlciBub3QgZmF0YWwgZXJyb3JzXG5cbiAgICBzd2l0Y2ggKGRhdGEuZGV0YWlscykge1xuICAgICAgY2FzZSBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJFcnJvckRldGFpbHNcIl0uRlJBR19MT0FEX0VSUk9SOlxuICAgICAgY2FzZSBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJFcnJvckRldGFpbHNcIl0uRlJBR19MT0FEX1RJTUVPVVQ6XG4gICAgICBjYXNlIF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcIkVycm9yRGV0YWlsc1wiXS5LRVlfTE9BRF9FUlJPUjpcbiAgICAgIGNhc2UgX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiRXJyb3JEZXRhaWxzXCJdLktFWV9MT0FEX1RJTUVPVVQ6XG4gICAgICAgIGlmIChkYXRhLmZyYWcpIHtcbiAgICAgICAgICB2YXIgX2xldmVsID0gdGhpcy5fbGV2ZWxzW2RhdGEuZnJhZy5sZXZlbF07IC8vIFNldCBsZXZlbEluZGV4IHdoZW4gd2UncmUgb3V0IG9mIGZyYWdtZW50IHJldHJpZXNcblxuICAgICAgICAgIGlmIChfbGV2ZWwpIHtcbiAgICAgICAgICAgIF9sZXZlbC5mcmFnbWVudEVycm9yKys7XG5cbiAgICAgICAgICAgIGlmIChfbGV2ZWwuZnJhZ21lbnRFcnJvciA+IHRoaXMuaGxzLmNvbmZpZy5mcmFnTG9hZGluZ01heFJldHJ5KSB7XG4gICAgICAgICAgICAgIGxldmVsSW5kZXggPSBkYXRhLmZyYWcubGV2ZWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldmVsSW5kZXggPSBkYXRhLmZyYWcubGV2ZWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiRXJyb3JEZXRhaWxzXCJdLkxFVkVMX0xPQURfRVJST1I6XG4gICAgICBjYXNlIF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcIkVycm9yRGV0YWlsc1wiXS5MRVZFTF9MT0FEX1RJTUVPVVQ6XG4gICAgICAgIC8vIERvIG5vdCBwZXJmb3JtIGxldmVsIHN3aXRjaCBpZiBhbiBlcnJvciBvY2N1cnJlZCB1c2luZyBkZWxpdmVyeSBkaXJlY3RpdmVzXG4gICAgICAgIC8vIEF0dGVtcHQgdG8gcmVsb2FkIGxldmVsIHdpdGhvdXQgZGlyZWN0aXZlcyBmaXJzdFxuICAgICAgICBpZiAoY29udGV4dCkge1xuICAgICAgICAgIGlmIChjb250ZXh0LmRlbGl2ZXJ5RGlyZWN0aXZlcykge1xuICAgICAgICAgICAgbGV2ZWxTd2l0Y2ggPSBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsZXZlbEluZGV4ID0gY29udGV4dC5sZXZlbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldmVsRXJyb3IgPSB0cnVlO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJFcnJvckRldGFpbHNcIl0uUkVNVVhfQUxMT0NfRVJST1I6XG4gICAgICAgIGxldmVsSW5kZXggPSBkYXRhLmxldmVsO1xuICAgICAgICBsZXZlbEVycm9yID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKGxldmVsSW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5yZWNvdmVyTGV2ZWwoZGF0YSwgbGV2ZWxJbmRleCwgbGV2ZWxFcnJvciwgbGV2ZWxTd2l0Y2gpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogU3dpdGNoIHRvIGEgcmVkdW5kYW50IHN0cmVhbSBpZiBhbnkgYXZhaWxhYmxlLlxuICAgKiBJZiByZWR1bmRhbnQgc3RyZWFtIGlzIG5vdCBhdmFpbGFibGUsIGVtZXJnZW5jeSBzd2l0Y2ggZG93biBpZiBBQlIgbW9kZSBpcyBlbmFibGVkLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5yZWNvdmVyTGV2ZWwgPSBmdW5jdGlvbiByZWNvdmVyTGV2ZWwoZXJyb3JFdmVudCwgbGV2ZWxJbmRleCwgbGV2ZWxFcnJvciwgbGV2ZWxTd2l0Y2gpIHtcbiAgICB2YXIgZXJyb3JEZXRhaWxzID0gZXJyb3JFdmVudC5kZXRhaWxzO1xuICAgIHZhciBsZXZlbCA9IHRoaXMuX2xldmVsc1tsZXZlbEluZGV4XTtcbiAgICBsZXZlbC5sb2FkRXJyb3IrKztcblxuICAgIGlmIChsZXZlbEVycm9yKSB7XG4gICAgICB2YXIgcmV0cnlpbmcgPSB0aGlzLnJldHJ5TG9hZGluZ09yRmFpbChlcnJvckV2ZW50KTtcblxuICAgICAgaWYgKHJldHJ5aW5nKSB7XG4gICAgICAgIC8vIGJvb2xlYW4gdXNlZCB0byBpbmZvcm0gc3RyZWFtIGNvbnRyb2xsZXIgbm90IHRvIHN3aXRjaCBiYWNrIHRvIElETEUgb24gbm9uIGZhdGFsIGVycm9yXG4gICAgICAgIGVycm9yRXZlbnQubGV2ZWxSZXRyeSA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmN1cnJlbnRMZXZlbEluZGV4ID0gLTE7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobGV2ZWxTd2l0Y2gpIHtcbiAgICAgIHZhciByZWR1bmRhbnRMZXZlbHMgPSBsZXZlbC51cmwubGVuZ3RoOyAvLyBUcnkgcmVkdW5kYW50IGZhaWwtb3ZlciB1bnRpbCBsZXZlbC5sb2FkRXJyb3IgcmVhY2hlcyByZWR1bmRhbnRMZXZlbHNcblxuICAgICAgaWYgKHJlZHVuZGFudExldmVscyA+IDEgJiYgbGV2ZWwubG9hZEVycm9yIDwgcmVkdW5kYW50TGV2ZWxzKSB7XG4gICAgICAgIGVycm9yRXZlbnQubGV2ZWxSZXRyeSA9IHRydWU7XG4gICAgICAgIHRoaXMucmVkdW5kYW50RmFpbG92ZXIobGV2ZWxJbmRleCk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMubWFudWFsTGV2ZWxJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgLy8gU2VhcmNoIGZvciBhdmFpbGFibGUgbGV2ZWwgaW4gYXV0byBsZXZlbCBzZWxlY3Rpb24gbW9kZSwgY3ljbGluZyBmcm9tIGhpZ2hlc3QgdG8gbG93ZXN0IGJpdHJhdGVcbiAgICAgICAgdmFyIG5leHRMZXZlbCA9IGxldmVsSW5kZXggPT09IDAgPyB0aGlzLl9sZXZlbHMubGVuZ3RoIC0gMSA6IGxldmVsSW5kZXggLSAxO1xuXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRMZXZlbEluZGV4ICE9PSBuZXh0TGV2ZWwgJiYgdGhpcy5fbGV2ZWxzW25leHRMZXZlbF0ubG9hZEVycm9yID09PSAwKSB7XG4gICAgICAgICAgdGhpcy53YXJuKGVycm9yRGV0YWlscyArIFwiOiBzd2l0Y2ggdG8gXCIgKyBuZXh0TGV2ZWwpO1xuICAgICAgICAgIGVycm9yRXZlbnQubGV2ZWxSZXRyeSA9IHRydWU7XG4gICAgICAgICAgdGhpcy5obHMubmV4dEF1dG9MZXZlbCA9IG5leHRMZXZlbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBfcHJvdG8ucmVkdW5kYW50RmFpbG92ZXIgPSBmdW5jdGlvbiByZWR1bmRhbnRGYWlsb3ZlcihsZXZlbEluZGV4KSB7XG4gICAgdmFyIGxldmVsID0gdGhpcy5fbGV2ZWxzW2xldmVsSW5kZXhdO1xuICAgIHZhciByZWR1bmRhbnRMZXZlbHMgPSBsZXZlbC51cmwubGVuZ3RoO1xuXG4gICAgaWYgKHJlZHVuZGFudExldmVscyA+IDEpIHtcbiAgICAgIC8vIFVwZGF0ZSB0aGUgdXJsIGlkIG9mIGFsbCBsZXZlbHMgc28gdGhhdCB3ZSBzdGF5IG9uIHRoZSBzYW1lIHNldCBvZiB2YXJpYW50cyB3aGVuIGxldmVsIHN3aXRjaGluZ1xuICAgICAgdmFyIG5ld1VybElkID0gKGxldmVsLnVybElkICsgMSkgJSByZWR1bmRhbnRMZXZlbHM7XG4gICAgICB0aGlzLndhcm4oXCJTd2l0Y2hpbmcgdG8gcmVkdW5kYW50IFVSTC1pZCBcIiArIG5ld1VybElkKTtcblxuICAgICAgdGhpcy5fbGV2ZWxzLmZvckVhY2goZnVuY3Rpb24gKGxldmVsKSB7XG4gICAgICAgIGxldmVsLnVybElkID0gbmV3VXJsSWQ7XG4gICAgICB9KTtcblxuICAgICAgdGhpcy5sZXZlbCA9IGxldmVsSW5kZXg7XG4gICAgfVxuICB9IC8vIHJlc2V0IGVycm9ycyBvbiB0aGUgc3VjY2Vzc2Z1bCBsb2FkIG9mIGEgZnJhZ21lbnRcbiAgO1xuXG4gIF9wcm90by5vbkZyYWdMb2FkZWQgPSBmdW5jdGlvbiBvbkZyYWdMb2FkZWQoZXZlbnQsIF9yZWYzKSB7XG4gICAgdmFyIGZyYWcgPSBfcmVmMy5mcmFnO1xuXG4gICAgaWYgKGZyYWcgIT09IHVuZGVmaW5lZCAmJiBmcmFnLnR5cGUgPT09IF90eXBlc19sb2FkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcIlBsYXlsaXN0TGV2ZWxUeXBlXCJdLk1BSU4pIHtcbiAgICAgIHZhciBsZXZlbCA9IHRoaXMuX2xldmVsc1tmcmFnLmxldmVsXTtcblxuICAgICAgaWYgKGxldmVsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV2ZWwuZnJhZ21lbnRFcnJvciA9IDA7XG4gICAgICAgIGxldmVsLmxvYWRFcnJvciA9IDA7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5vbkxldmVsTG9hZGVkID0gZnVuY3Rpb24gb25MZXZlbExvYWRlZChldmVudCwgZGF0YSkge1xuICAgIHZhciBfZGF0YSRkZWxpdmVyeURpcmVjdGkyO1xuXG4gICAgdmFyIGxldmVsID0gZGF0YS5sZXZlbCxcbiAgICAgICAgZGV0YWlscyA9IGRhdGEuZGV0YWlscztcbiAgICB2YXIgY3VyTGV2ZWwgPSB0aGlzLl9sZXZlbHNbbGV2ZWxdO1xuXG4gICAgaWYgKCFjdXJMZXZlbCkge1xuICAgICAgdmFyIF9kYXRhJGRlbGl2ZXJ5RGlyZWN0aTtcblxuICAgICAgdGhpcy53YXJuKFwiSW52YWxpZCBsZXZlbCBpbmRleCBcIiArIGxldmVsKTtcblxuICAgICAgaWYgKChfZGF0YSRkZWxpdmVyeURpcmVjdGkgPSBkYXRhLmRlbGl2ZXJ5RGlyZWN0aXZlcykgIT09IG51bGwgJiYgX2RhdGEkZGVsaXZlcnlEaXJlY3RpICE9PSB2b2lkIDAgJiYgX2RhdGEkZGVsaXZlcnlEaXJlY3RpLnNraXApIHtcbiAgICAgICAgZGV0YWlscy5kZWx0YVVwZGF0ZUZhaWxlZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybjtcbiAgICB9IC8vIG9ubHkgcHJvY2VzcyBsZXZlbCBsb2FkZWQgZXZlbnRzIG1hdGNoaW5nIHdpdGggZXhwZWN0ZWQgbGV2ZWxcblxuXG4gICAgaWYgKGxldmVsID09PSB0aGlzLmN1cnJlbnRMZXZlbEluZGV4KSB7XG4gICAgICAvLyByZXNldCBsZXZlbCBsb2FkIGVycm9yIGNvdW50ZXIgb24gc3VjY2Vzc2Z1bCBsZXZlbCBsb2FkZWQgb25seSBpZiB0aGVyZSBpcyBubyBpc3N1ZXMgd2l0aCBmcmFnbWVudHNcbiAgICAgIGlmIChjdXJMZXZlbC5mcmFnbWVudEVycm9yID09PSAwKSB7XG4gICAgICAgIGN1ckxldmVsLmxvYWRFcnJvciA9IDA7XG4gICAgICAgIHRoaXMucmV0cnlDb3VudCA9IDA7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucGxheWxpc3RMb2FkZWQobGV2ZWwsIGRhdGEsIGN1ckxldmVsLmRldGFpbHMpO1xuICAgIH0gZWxzZSBpZiAoKF9kYXRhJGRlbGl2ZXJ5RGlyZWN0aTIgPSBkYXRhLmRlbGl2ZXJ5RGlyZWN0aXZlcykgIT09IG51bGwgJiYgX2RhdGEkZGVsaXZlcnlEaXJlY3RpMiAhPT0gdm9pZCAwICYmIF9kYXRhJGRlbGl2ZXJ5RGlyZWN0aTIuc2tpcCkge1xuICAgICAgLy8gcmVjZWl2ZWQgYSBkZWx0YSBwbGF5bGlzdCB1cGRhdGUgdGhhdCBjYW5ub3QgYmUgbWVyZ2VkXG4gICAgICBkZXRhaWxzLmRlbHRhVXBkYXRlRmFpbGVkID0gdHJ1ZTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLm9uQXVkaW9UcmFja1N3aXRjaGVkID0gZnVuY3Rpb24gb25BdWRpb1RyYWNrU3dpdGNoZWQoZXZlbnQsIGRhdGEpIHtcbiAgICB2YXIgY3VycmVudExldmVsID0gdGhpcy5obHMubGV2ZWxzW3RoaXMuY3VycmVudExldmVsSW5kZXhdO1xuXG4gICAgaWYgKCFjdXJyZW50TGV2ZWwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoY3VycmVudExldmVsLmF1ZGlvR3JvdXBJZHMpIHtcbiAgICAgIHZhciB1cmxJZCA9IC0xO1xuICAgICAgdmFyIGF1ZGlvR3JvdXBJZCA9IHRoaXMuaGxzLmF1ZGlvVHJhY2tzW2RhdGEuaWRdLmdyb3VwSWQ7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY3VycmVudExldmVsLmF1ZGlvR3JvdXBJZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGN1cnJlbnRMZXZlbC5hdWRpb0dyb3VwSWRzW2ldID09PSBhdWRpb0dyb3VwSWQpIHtcbiAgICAgICAgICB1cmxJZCA9IGk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHVybElkICE9PSBjdXJyZW50TGV2ZWwudXJsSWQpIHtcbiAgICAgICAgY3VycmVudExldmVsLnVybElkID0gdXJsSWQ7XG4gICAgICAgIHRoaXMuc3RhcnRMb2FkKCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5sb2FkUGxheWxpc3QgPSBmdW5jdGlvbiBsb2FkUGxheWxpc3QoaGxzVXJsUGFyYW1ldGVycykge1xuICAgIHZhciBsZXZlbCA9IHRoaXMuY3VycmVudExldmVsSW5kZXg7XG4gICAgdmFyIGN1cnJlbnRMZXZlbCA9IHRoaXMuX2xldmVsc1tsZXZlbF07XG5cbiAgICBpZiAodGhpcy5jYW5Mb2FkICYmIGN1cnJlbnRMZXZlbCAmJiBjdXJyZW50TGV2ZWwudXJsLmxlbmd0aCA+IDApIHtcbiAgICAgIHZhciBpZCA9IGN1cnJlbnRMZXZlbC51cmxJZDtcbiAgICAgIHZhciB1cmwgPSBjdXJyZW50TGV2ZWwudXJsW2lkXTtcblxuICAgICAgaWYgKGhsc1VybFBhcmFtZXRlcnMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB1cmwgPSBobHNVcmxQYXJhbWV0ZXJzLmFkZERpcmVjdGl2ZXModXJsKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICB0aGlzLndhcm4oXCJDb3VsZCBub3QgY29uc3RydWN0IG5ldyBVUkwgd2l0aCBITFMgRGVsaXZlcnkgRGlyZWN0aXZlczogXCIgKyBlcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5sb2coXCJBdHRlbXB0IGxvYWRpbmcgbGV2ZWwgaW5kZXggXCIgKyBsZXZlbCArIChobHNVcmxQYXJhbWV0ZXJzID8gJyBhdCBzbiAnICsgaGxzVXJsUGFyYW1ldGVycy5tc24gKyAnIHBhcnQgJyArIGhsc1VybFBhcmFtZXRlcnMucGFydCA6ICcnKSArIFwiIHdpdGggVVJMLWlkIFwiICsgaWQgKyBcIiBcIiArIHVybCk7IC8vIGNvbnNvbGUubG9nKCdDdXJyZW50IGF1ZGlvIHRyYWNrIGdyb3VwIElEOicsIHRoaXMuaGxzLmF1ZGlvVHJhY2tzW3RoaXMuaGxzLmF1ZGlvVHJhY2tdLmdyb3VwSWQpO1xuICAgICAgLy8gY29uc29sZS5sb2coJ05ldyB2aWRlbyBxdWFsaXR5IGxldmVsIGF1ZGlvIGdyb3VwIGlkOicsIGxldmVsT2JqZWN0LmF0dHJzLkFVRElPLCBsZXZlbCk7XG5cbiAgICAgIHRoaXMuY2xlYXJUaW1lcigpO1xuICAgICAgdGhpcy5obHMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFdmVudHNcIl0uTEVWRUxfTE9BRElORywge1xuICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgbGV2ZWw6IGxldmVsLFxuICAgICAgICBpZDogaWQsXG4gICAgICAgIGRlbGl2ZXJ5RGlyZWN0aXZlczogaGxzVXJsUGFyYW1ldGVycyB8fCBudWxsXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLnJlbW92ZUxldmVsID0gZnVuY3Rpb24gcmVtb3ZlTGV2ZWwobGV2ZWxJbmRleCwgdXJsSWQpIHtcbiAgICB2YXIgZmlsdGVyTGV2ZWxBbmRHcm91cEJ5SWRJbmRleCA9IGZ1bmN0aW9uIGZpbHRlckxldmVsQW5kR3JvdXBCeUlkSW5kZXgodXJsLCBpZCkge1xuICAgICAgcmV0dXJuIGlkICE9PSB1cmxJZDtcbiAgICB9O1xuXG4gICAgdmFyIGxldmVscyA9IHRoaXMuX2xldmVscy5maWx0ZXIoZnVuY3Rpb24gKGxldmVsLCBpbmRleCkge1xuICAgICAgaWYgKGluZGV4ICE9PSBsZXZlbEluZGV4KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAobGV2ZWwudXJsLmxlbmd0aCA+IDEgJiYgdXJsSWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXZlbC51cmwgPSBsZXZlbC51cmwuZmlsdGVyKGZpbHRlckxldmVsQW5kR3JvdXBCeUlkSW5kZXgpO1xuXG4gICAgICAgIGlmIChsZXZlbC5hdWRpb0dyb3VwSWRzKSB7XG4gICAgICAgICAgbGV2ZWwuYXVkaW9Hcm91cElkcyA9IGxldmVsLmF1ZGlvR3JvdXBJZHMuZmlsdGVyKGZpbHRlckxldmVsQW5kR3JvdXBCeUlkSW5kZXgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxldmVsLnRleHRHcm91cElkcykge1xuICAgICAgICAgIGxldmVsLnRleHRHcm91cElkcyA9IGxldmVsLnRleHRHcm91cElkcy5maWx0ZXIoZmlsdGVyTGV2ZWxBbmRHcm91cEJ5SWRJbmRleCk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXZlbC51cmxJZCA9IDA7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSkubWFwKGZ1bmN0aW9uIChsZXZlbCwgaW5kZXgpIHtcbiAgICAgIHZhciBkZXRhaWxzID0gbGV2ZWwuZGV0YWlscztcblxuICAgICAgaWYgKGRldGFpbHMgIT09IG51bGwgJiYgZGV0YWlscyAhPT0gdm9pZCAwICYmIGRldGFpbHMuZnJhZ21lbnRzKSB7XG4gICAgICAgIGRldGFpbHMuZnJhZ21lbnRzLmZvckVhY2goZnVuY3Rpb24gKGZyYWdtZW50KSB7XG4gICAgICAgICAgZnJhZ21lbnQubGV2ZWwgPSBpbmRleDtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBsZXZlbDtcbiAgICB9KTtcblxuICAgIHRoaXMuX2xldmVscyA9IGxldmVscztcbiAgICB0aGlzLmhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkV2ZW50c1wiXS5MRVZFTFNfVVBEQVRFRCwge1xuICAgICAgbGV2ZWxzOiBsZXZlbHNcbiAgICB9KTtcbiAgfTtcblxuICBfY3JlYXRlQ2xhc3MoTGV2ZWxDb250cm9sbGVyLCBbe1xuICAgIGtleTogXCJsZXZlbHNcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIGlmICh0aGlzLl9sZXZlbHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5fbGV2ZWxzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJsZXZlbFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuY3VycmVudExldmVsSW5kZXg7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldChuZXdMZXZlbCkge1xuICAgICAgdmFyIF9sZXZlbHMkbmV3TGV2ZWw7XG5cbiAgICAgIHZhciBsZXZlbHMgPSB0aGlzLl9sZXZlbHM7XG5cbiAgICAgIGlmIChsZXZlbHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuY3VycmVudExldmVsSW5kZXggPT09IG5ld0xldmVsICYmIChfbGV2ZWxzJG5ld0xldmVsID0gbGV2ZWxzW25ld0xldmVsXSkgIT09IG51bGwgJiYgX2xldmVscyRuZXdMZXZlbCAhPT0gdm9pZCAwICYmIF9sZXZlbHMkbmV3TGV2ZWwuZGV0YWlscykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIGNoZWNrIGlmIGxldmVsIGlkeCBpcyB2YWxpZFxuXG5cbiAgICAgIGlmIChuZXdMZXZlbCA8IDAgfHwgbmV3TGV2ZWwgPj0gbGV2ZWxzLmxlbmd0aCkge1xuICAgICAgICAvLyBpbnZhbGlkIGxldmVsIGlkIGdpdmVuLCB0cmlnZ2VyIGVycm9yXG4gICAgICAgIHZhciBmYXRhbCA9IG5ld0xldmVsIDwgMDtcbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFdmVudHNcIl0uRVJST1IsIHtcbiAgICAgICAgICB0eXBlOiBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJFcnJvclR5cGVzXCJdLk9USEVSX0VSUk9SLFxuICAgICAgICAgIGRldGFpbHM6IF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcIkVycm9yRGV0YWlsc1wiXS5MRVZFTF9TV0lUQ0hfRVJST1IsXG4gICAgICAgICAgbGV2ZWw6IG5ld0xldmVsLFxuICAgICAgICAgIGZhdGFsOiBmYXRhbCxcbiAgICAgICAgICByZWFzb246ICdpbnZhbGlkIGxldmVsIGlkeCdcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGZhdGFsKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbmV3TGV2ZWwgPSBNYXRoLm1pbihuZXdMZXZlbCwgbGV2ZWxzLmxlbmd0aCAtIDEpO1xuICAgICAgfSAvLyBzdG9wcGluZyBsaXZlIHJlbG9hZGluZyB0aW1lciBpZiBhbnlcblxuXG4gICAgICB0aGlzLmNsZWFyVGltZXIoKTtcbiAgICAgIHZhciBsYXN0TGV2ZWxJbmRleCA9IHRoaXMuY3VycmVudExldmVsSW5kZXg7XG4gICAgICB2YXIgbGFzdExldmVsID0gbGV2ZWxzW2xhc3RMZXZlbEluZGV4XTtcbiAgICAgIHZhciBsZXZlbCA9IGxldmVsc1tuZXdMZXZlbF07XG4gICAgICB0aGlzLmxvZyhcInN3aXRjaGluZyB0byBsZXZlbCBcIiArIG5ld0xldmVsICsgXCIgZnJvbSBcIiArIGxhc3RMZXZlbEluZGV4KTtcbiAgICAgIHRoaXMuY3VycmVudExldmVsSW5kZXggPSBuZXdMZXZlbDtcblxuICAgICAgdmFyIGxldmVsU3dpdGNoaW5nRGF0YSA9IF9leHRlbmRzKHt9LCBsZXZlbCwge1xuICAgICAgICBsZXZlbDogbmV3TGV2ZWwsXG4gICAgICAgIG1heEJpdHJhdGU6IGxldmVsLm1heEJpdHJhdGUsXG4gICAgICAgIHVyaTogbGV2ZWwudXJpLFxuICAgICAgICB1cmxJZDogbGV2ZWwudXJsSWRcbiAgICAgIH0pOyAvLyBAdHMtaWdub3JlXG5cblxuICAgICAgZGVsZXRlIGxldmVsU3dpdGNoaW5nRGF0YS5fdXJsSWQ7XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkV2ZW50c1wiXS5MRVZFTF9TV0lUQ0hJTkcsIGxldmVsU3dpdGNoaW5nRGF0YSk7IC8vIGNoZWNrIGlmIHdlIG5lZWQgdG8gbG9hZCBwbGF5bGlzdCBmb3IgdGhpcyBsZXZlbFxuXG4gICAgICB2YXIgbGV2ZWxEZXRhaWxzID0gbGV2ZWwuZGV0YWlscztcblxuICAgICAgaWYgKCFsZXZlbERldGFpbHMgfHwgbGV2ZWxEZXRhaWxzLmxpdmUpIHtcbiAgICAgICAgLy8gbGV2ZWwgbm90IHJldHJpZXZlZCB5ZXQsIG9yIGxpdmUgcGxheWxpc3Qgd2UgbmVlZCB0byAocmUpbG9hZCBpdFxuICAgICAgICB2YXIgaGxzVXJsUGFyYW1ldGVycyA9IHRoaXMuc3dpdGNoUGFyYW1zKGxldmVsLnVyaSwgbGFzdExldmVsID09PSBudWxsIHx8IGxhc3RMZXZlbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGFzdExldmVsLmRldGFpbHMpO1xuICAgICAgICB0aGlzLmxvYWRQbGF5bGlzdChobHNVcmxQYXJhbWV0ZXJzKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibWFudWFsTGV2ZWxcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1hbnVhbExldmVsSW5kZXg7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldChuZXdMZXZlbCkge1xuICAgICAgdGhpcy5tYW51YWxMZXZlbEluZGV4ID0gbmV3TGV2ZWw7XG5cbiAgICAgIGlmICh0aGlzLl9zdGFydExldmVsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5fc3RhcnRMZXZlbCA9IG5ld0xldmVsO1xuICAgICAgfVxuXG4gICAgICBpZiAobmV3TGV2ZWwgIT09IC0xKSB7XG4gICAgICAgIHRoaXMubGV2ZWwgPSBuZXdMZXZlbDtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZmlyc3RMZXZlbFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2ZpcnN0TGV2ZWw7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldChuZXdMZXZlbCkge1xuICAgICAgdGhpcy5fZmlyc3RMZXZlbCA9IG5ld0xldmVsO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzdGFydExldmVsXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAvLyBobHMuc3RhcnRMZXZlbCB0YWtlcyBwcmVjZWRlbmNlIG92ZXIgY29uZmlnLnN0YXJ0TGV2ZWxcbiAgICAgIC8vIGlmIG5vbmUgb2YgdGhlc2UgdmFsdWVzIGFyZSBkZWZpbmVkLCBmYWxsYmFjayBvbiB0aGlzLl9maXJzdExldmVsIChmaXJzdCBxdWFsaXR5IGxldmVsIGFwcGVhcmluZyBpbiB2YXJpYW50IG1hbmlmZXN0KVxuICAgICAgaWYgKHRoaXMuX3N0YXJ0TGV2ZWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgY29uZmlnU3RhcnRMZXZlbCA9IHRoaXMuaGxzLmNvbmZpZy5zdGFydExldmVsO1xuXG4gICAgICAgIGlmIChjb25maWdTdGFydExldmVsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4gY29uZmlnU3RhcnRMZXZlbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fZmlyc3RMZXZlbDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXJ0TGV2ZWw7XG4gICAgICB9XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldChuZXdMZXZlbCkge1xuICAgICAgdGhpcy5fc3RhcnRMZXZlbCA9IG5ld0xldmVsO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJuZXh0TG9hZExldmVsXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICBpZiAodGhpcy5tYW51YWxMZXZlbEluZGV4ICE9PSAtMSkge1xuICAgICAgICByZXR1cm4gdGhpcy5tYW51YWxMZXZlbEluZGV4O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGxzLm5leHRBdXRvTGV2ZWw7XG4gICAgICB9XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldChuZXh0TGV2ZWwpIHtcbiAgICAgIHRoaXMubGV2ZWwgPSBuZXh0TGV2ZWw7XG5cbiAgICAgIGlmICh0aGlzLm1hbnVhbExldmVsSW5kZXggPT09IC0xKSB7XG4gICAgICAgIHRoaXMuaGxzLm5leHRBdXRvTGV2ZWwgPSBuZXh0TGV2ZWw7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIExldmVsQ29udHJvbGxlcjtcbn0oX2Jhc2VfcGxheWxpc3RfY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1wiZGVmYXVsdFwiXSk7XG5cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9jb250cm9sbGVyL2xldmVsLWhlbHBlci50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9jb250cm9sbGVyL2xldmVsLWhlbHBlci50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBhZGRHcm91cElkLCBhc3NpZ25UcmFja0lkc0J5R3JvdXAsIHVwZGF0ZVBUUywgdXBkYXRlRnJhZ1BUU0RUUywgbWVyZ2VEZXRhaWxzLCBtYXBQYXJ0SW50ZXJzZWN0aW9uLCBtYXBGcmFnbWVudEludGVyc2VjdGlvbiwgYWRqdXN0U2xpZGluZywgYWRkU2xpZGluZywgY29tcHV0ZVJlbG9hZEludGVydmFsLCBnZXRGcmFnbWVudFdpdGhTTiwgZ2V0UGFydFdpdGggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiYWRkR3JvdXBJZFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGFkZEdyb3VwSWQ7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImFzc2lnblRyYWNrSWRzQnlHcm91cFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGFzc2lnblRyYWNrSWRzQnlHcm91cDsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwidXBkYXRlUFRTXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gdXBkYXRlUFRTOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJ1cGRhdGVGcmFnUFRTRFRTXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gdXBkYXRlRnJhZ1BUU0RUUzsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwibWVyZ2VEZXRhaWxzXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gbWVyZ2VEZXRhaWxzOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJtYXBQYXJ0SW50ZXJzZWN0aW9uXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gbWFwUGFydEludGVyc2VjdGlvbjsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwibWFwRnJhZ21lbnRJbnRlcnNlY3Rpb25cIiwgZnVuY3Rpb24oKSB7IHJldHVybiBtYXBGcmFnbWVudEludGVyc2VjdGlvbjsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiYWRqdXN0U2xpZGluZ1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGFkanVzdFNsaWRpbmc7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImFkZFNsaWRpbmdcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBhZGRTbGlkaW5nOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJjb21wdXRlUmVsb2FkSW50ZXJ2YWxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBjb21wdXRlUmVsb2FkSW50ZXJ2YWw7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImdldEZyYWdtZW50V2l0aFNOXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZ2V0RnJhZ21lbnRXaXRoU047IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImdldFBhcnRXaXRoXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZ2V0UGFydFdpdGg7IH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9ob21lX3J1bm5lcl93b3JrX2hsc19qc19obHNfanNfc3JjX3BvbHlmaWxsc19udW1iZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc3JjL3BvbHlmaWxscy9udW1iZXIgKi8gXCIuL3NyYy9wb2x5ZmlsbHMvbnVtYmVyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL2xvZ2dlciAqLyBcIi4vc3JjL3V0aWxzL2xvZ2dlci50c1wiKTtcblxuXG5cblxuXG5cbi8qKlxuICogQG1vZHVsZSBMZXZlbEhlbHBlclxuICogUHJvdmlkaW5nIG1ldGhvZHMgZGVhbGluZyB3aXRoIHBsYXlsaXN0IHNsaWRpbmcgYW5kIGRyaWZ0XG4gKiAqL1xuXG5mdW5jdGlvbiBhZGRHcm91cElkKGxldmVsLCB0eXBlLCBpZCkge1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdhdWRpbyc6XG4gICAgICBpZiAoIWxldmVsLmF1ZGlvR3JvdXBJZHMpIHtcbiAgICAgICAgbGV2ZWwuYXVkaW9Hcm91cElkcyA9IFtdO1xuICAgICAgfVxuXG4gICAgICBsZXZlbC5hdWRpb0dyb3VwSWRzLnB1c2goaWQpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICd0ZXh0JzpcbiAgICAgIGlmICghbGV2ZWwudGV4dEdyb3VwSWRzKSB7XG4gICAgICAgIGxldmVsLnRleHRHcm91cElkcyA9IFtdO1xuICAgICAgfVxuXG4gICAgICBsZXZlbC50ZXh0R3JvdXBJZHMucHVzaChpZCk7XG4gICAgICBicmVhaztcbiAgfVxufVxuZnVuY3Rpb24gYXNzaWduVHJhY2tJZHNCeUdyb3VwKHRyYWNrcykge1xuICB2YXIgZ3JvdXBzID0ge307XG4gIHRyYWNrcy5mb3JFYWNoKGZ1bmN0aW9uICh0cmFjaykge1xuICAgIHZhciBncm91cElkID0gdHJhY2suZ3JvdXBJZCB8fCAnJztcbiAgICB0cmFjay5pZCA9IGdyb3Vwc1tncm91cElkXSA9IGdyb3Vwc1tncm91cElkXSB8fCAwO1xuICAgIGdyb3Vwc1tncm91cElkXSsrO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZVBUUyhmcmFnbWVudHMsIGZyb21JZHgsIHRvSWR4KSB7XG4gIHZhciBmcmFnRnJvbSA9IGZyYWdtZW50c1tmcm9tSWR4XTtcbiAgdmFyIGZyYWdUbyA9IGZyYWdtZW50c1t0b0lkeF07XG4gIHVwZGF0ZUZyb21Ub1BUUyhmcmFnRnJvbSwgZnJhZ1RvKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlRnJvbVRvUFRTKGZyYWdGcm9tLCBmcmFnVG8pIHtcbiAgdmFyIGZyYWdUb1BUUyA9IGZyYWdUby5zdGFydFBUUzsgLy8gaWYgd2Uga25vdyBzdGFydFBUU1t0b0lkeF1cblxuICBpZiAoT2JqZWN0KF9ob21lX3J1bm5lcl93b3JrX2hsc19qc19obHNfanNfc3JjX3BvbHlmaWxsc19udW1iZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImlzRmluaXRlTnVtYmVyXCJdKShmcmFnVG9QVFMpKSB7XG4gICAgLy8gdXBkYXRlIGZyYWdtZW50IGR1cmF0aW9uLlxuICAgIC8vIGl0IGhlbHBzIHRvIGZpeCBkcmlmdHMgYmV0d2VlbiBwbGF5bGlzdCByZXBvcnRlZCBkdXJhdGlvbiBhbmQgZnJhZ21lbnQgcmVhbCBkdXJhdGlvblxuICAgIHZhciBkdXJhdGlvbiA9IDA7XG4gICAgdmFyIGZyYWc7XG5cbiAgICBpZiAoZnJhZ1RvLnNuID4gZnJhZ0Zyb20uc24pIHtcbiAgICAgIGR1cmF0aW9uID0gZnJhZ1RvUFRTIC0gZnJhZ0Zyb20uc3RhcnQ7XG4gICAgICBmcmFnID0gZnJhZ0Zyb207XG4gICAgfSBlbHNlIHtcbiAgICAgIGR1cmF0aW9uID0gZnJhZ0Zyb20uc3RhcnQgLSBmcmFnVG9QVFM7XG4gICAgICBmcmFnID0gZnJhZ1RvO1xuICAgIH0gLy8gVE9ETz8gRHJpZnQgY2FuIGdvIGVpdGhlciB3YXksIG9yIHRoZSBwbGF5bGlzdCBjb3VsZCBiZSBjb21wbGV0ZWx5IGFjY3VyYXRlXG4gICAgLy8gY29uc29sZS5hc3NlcnQoZHVyYXRpb24gPiAwLFxuICAgIC8vICAgYGR1cmF0aW9uIG9mICR7ZHVyYXRpb259IGNvbXB1dGVkIGZvciBmcmFnICR7ZnJhZy5zbn0sIGxldmVsICR7ZnJhZy5sZXZlbH0sIHRoZXJlIHNob3VsZCBiZSBzb21lIGR1cmF0aW9uIGRyaWZ0IGJldHdlZW4gcGxheWxpc3QgYW5kIGZyYWdtZW50IWApO1xuXG5cbiAgICBpZiAoZnJhZy5kdXJhdGlvbiAhPT0gZHVyYXRpb24pIHtcbiAgICAgIGZyYWcuZHVyYXRpb24gPSBkdXJhdGlvbjtcbiAgICB9IC8vIHdlIGRvbnQga25vdyBzdGFydFBUU1t0b0lkeF1cblxuICB9IGVsc2UgaWYgKGZyYWdUby5zbiA+IGZyYWdGcm9tLnNuKSB7XG4gICAgdmFyIGNvbnRpZ3VvdXMgPSBmcmFnRnJvbS5jYyA9PT0gZnJhZ1RvLmNjOyAvLyBUT0RPOiBXaXRoIHBhcnQtbG9hZGluZyBlbmQvZHVyYXRpb25zIHdlIG5lZWQgdG8gY29uZmlybSB0aGUgd2hvbGUgZnJhZ21lbnQgaXMgbG9hZGVkIGJlZm9yZSB1c2luZyAob3Igc2V0dGluZykgbWluRW5kUFRTXG5cbiAgICBpZiAoY29udGlndW91cyAmJiBmcmFnRnJvbS5taW5FbmRQVFMpIHtcbiAgICAgIGZyYWdUby5zdGFydCA9IGZyYWdGcm9tLnN0YXJ0ICsgKGZyYWdGcm9tLm1pbkVuZFBUUyAtIGZyYWdGcm9tLnN0YXJ0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZnJhZ1RvLnN0YXJ0ID0gZnJhZ0Zyb20uc3RhcnQgKyBmcmFnRnJvbS5kdXJhdGlvbjtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZnJhZ1RvLnN0YXJ0ID0gTWF0aC5tYXgoZnJhZ0Zyb20uc3RhcnQgLSBmcmFnVG8uZHVyYXRpb24sIDApO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUZyYWdQVFNEVFMoZGV0YWlscywgZnJhZywgc3RhcnRQVFMsIGVuZFBUUywgc3RhcnREVFMsIGVuZERUUykge1xuICB2YXIgcGFyc2VkTWVkaWFEdXJhdGlvbiA9IGVuZFBUUyAtIHN0YXJ0UFRTO1xuXG4gIGlmIChwYXJzZWRNZWRpYUR1cmF0aW9uIDw9IDApIHtcbiAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJsb2dnZXJcIl0ud2FybignRnJhZ21lbnQgc2hvdWxkIGhhdmUgYSBwb3NpdGl2ZSBkdXJhdGlvbicsIGZyYWcpO1xuICAgIGVuZFBUUyA9IHN0YXJ0UFRTICsgZnJhZy5kdXJhdGlvbjtcbiAgICBlbmREVFMgPSBzdGFydERUUyArIGZyYWcuZHVyYXRpb247XG4gIH1cblxuICB2YXIgbWF4U3RhcnRQVFMgPSBzdGFydFBUUztcbiAgdmFyIG1pbkVuZFBUUyA9IGVuZFBUUztcbiAgdmFyIGZyYWdTdGFydFB0cyA9IGZyYWcuc3RhcnRQVFM7XG4gIHZhciBmcmFnRW5kUHRzID0gZnJhZy5lbmRQVFM7XG5cbiAgaWYgKE9iamVjdChfaG9tZV9ydW5uZXJfd29ya19obHNfanNfaGxzX2pzX3NyY19wb2x5ZmlsbHNfbnVtYmVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJpc0Zpbml0ZU51bWJlclwiXSkoZnJhZ1N0YXJ0UHRzKSkge1xuICAgIC8vIGRlbHRhIFBUUyBiZXR3ZWVuIGF1ZGlvIGFuZCB2aWRlb1xuICAgIHZhciBkZWx0YVBUUyA9IE1hdGguYWJzKGZyYWdTdGFydFB0cyAtIHN0YXJ0UFRTKTtcblxuICAgIGlmICghT2JqZWN0KF9ob21lX3J1bm5lcl93b3JrX2hsc19qc19obHNfanNfc3JjX3BvbHlmaWxsc19udW1iZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImlzRmluaXRlTnVtYmVyXCJdKShmcmFnLmRlbHRhUFRTKSkge1xuICAgICAgZnJhZy5kZWx0YVBUUyA9IGRlbHRhUFRTO1xuICAgIH0gZWxzZSB7XG4gICAgICBmcmFnLmRlbHRhUFRTID0gTWF0aC5tYXgoZGVsdGFQVFMsIGZyYWcuZGVsdGFQVFMpO1xuICAgIH1cblxuICAgIG1heFN0YXJ0UFRTID0gTWF0aC5tYXgoc3RhcnRQVFMsIGZyYWdTdGFydFB0cyk7XG4gICAgc3RhcnRQVFMgPSBNYXRoLm1pbihzdGFydFBUUywgZnJhZ1N0YXJ0UHRzKTtcbiAgICBzdGFydERUUyA9IE1hdGgubWluKHN0YXJ0RFRTLCBmcmFnLnN0YXJ0RFRTKTtcbiAgICBtaW5FbmRQVFMgPSBNYXRoLm1pbihlbmRQVFMsIGZyYWdFbmRQdHMpO1xuICAgIGVuZFBUUyA9IE1hdGgubWF4KGVuZFBUUywgZnJhZ0VuZFB0cyk7XG4gICAgZW5kRFRTID0gTWF0aC5tYXgoZW5kRFRTLCBmcmFnLmVuZERUUyk7XG4gIH1cblxuICBmcmFnLmR1cmF0aW9uID0gZW5kUFRTIC0gc3RhcnRQVFM7XG4gIHZhciBkcmlmdCA9IHN0YXJ0UFRTIC0gZnJhZy5zdGFydDtcbiAgZnJhZy5hcHBlbmRlZFBUUyA9IGVuZFBUUztcbiAgZnJhZy5zdGFydCA9IGZyYWcuc3RhcnRQVFMgPSBzdGFydFBUUztcbiAgZnJhZy5tYXhTdGFydFBUUyA9IG1heFN0YXJ0UFRTO1xuICBmcmFnLnN0YXJ0RFRTID0gc3RhcnREVFM7XG4gIGZyYWcuZW5kUFRTID0gZW5kUFRTO1xuICBmcmFnLm1pbkVuZFBUUyA9IG1pbkVuZFBUUztcbiAgZnJhZy5lbmREVFMgPSBlbmREVFM7XG4gIHZhciBzbiA9IGZyYWcuc247IC8vICdpbml0U2VnbWVudCdcbiAgLy8gZXhpdCBpZiBzbiBvdXQgb2YgcmFuZ2VcblxuICBpZiAoIWRldGFpbHMgfHwgc24gPCBkZXRhaWxzLnN0YXJ0U04gfHwgc24gPiBkZXRhaWxzLmVuZFNOKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICB2YXIgaTtcbiAgdmFyIGZyYWdJZHggPSBzbiAtIGRldGFpbHMuc3RhcnRTTjtcbiAgdmFyIGZyYWdtZW50cyA9IGRldGFpbHMuZnJhZ21lbnRzOyAvLyB1cGRhdGUgZnJhZyByZWZlcmVuY2UgaW4gZnJhZ21lbnRzIGFycmF5XG4gIC8vIHJhdGlvbmFsZSBpcyB0aGF0IGZyYWdtZW50cyBhcnJheSBtaWdodCBub3QgY29udGFpbiB0aGlzIGZyYWcgb2JqZWN0LlxuICAvLyB0aGlzIHdpbGwgaGFwcGVuIGlmIHBsYXlsaXN0IGhhcyBiZWVuIHJlZnJlc2hlZCBiZXR3ZWVuIGZyYWcgbG9hZGluZyBhbmQgY2FsbCB0byB1cGRhdGVGcmFnUFRTRFRTKClcbiAgLy8gaWYgd2UgZG9uJ3QgdXBkYXRlIGZyYWcsIHdlIHdvbid0IGJlIGFibGUgdG8gcHJvcGFnYXRlIFBUUyBpbmZvIG9uIHRoZSBwbGF5bGlzdFxuICAvLyByZXN1bHRpbmcgaW4gaW52YWxpZCBzbGlkaW5nIGNvbXB1dGF0aW9uXG5cbiAgZnJhZ21lbnRzW2ZyYWdJZHhdID0gZnJhZzsgLy8gYWRqdXN0IGZyYWdtZW50IFBUUy9kdXJhdGlvbiBmcm9tIHNlcW51bS0xIHRvIGZyYWcgMFxuXG4gIGZvciAoaSA9IGZyYWdJZHg7IGkgPiAwOyBpLS0pIHtcbiAgICB1cGRhdGVGcm9tVG9QVFMoZnJhZ21lbnRzW2ldLCBmcmFnbWVudHNbaSAtIDFdKTtcbiAgfSAvLyBhZGp1c3QgZnJhZ21lbnQgUFRTL2R1cmF0aW9uIGZyb20gc2VxbnVtIHRvIGxhc3QgZnJhZ1xuXG5cbiAgZm9yIChpID0gZnJhZ0lkeDsgaSA8IGZyYWdtZW50cy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICB1cGRhdGVGcm9tVG9QVFMoZnJhZ21lbnRzW2ldLCBmcmFnbWVudHNbaSArIDFdKTtcbiAgfVxuXG4gIGlmIChkZXRhaWxzLmZyYWdtZW50SGludCkge1xuICAgIHVwZGF0ZUZyb21Ub1BUUyhmcmFnbWVudHNbZnJhZ21lbnRzLmxlbmd0aCAtIDFdLCBkZXRhaWxzLmZyYWdtZW50SGludCk7XG4gIH1cblxuICBkZXRhaWxzLlBUU0tub3duID0gZGV0YWlscy5hbGlnbmVkU2xpZGluZyA9IHRydWU7XG4gIHJldHVybiBkcmlmdDtcbn1cbmZ1bmN0aW9uIG1lcmdlRGV0YWlscyhvbGREZXRhaWxzLCBuZXdEZXRhaWxzKSB7XG4gIC8vIFRyYWNrIHRoZSBsYXN0IGluaXRTZWdtZW50IHByb2Nlc3NlZC4gSW5pdGlhbGl6ZSBpdCB0byB0aGUgbGFzdCBvbmUgb24gdGhlIHRpbWVsaW5lLlxuICB2YXIgY3VycmVudEluaXRTZWdtZW50ID0gbnVsbDtcbiAgdmFyIG9sZEZyYWdtZW50cyA9IG9sZERldGFpbHMuZnJhZ21lbnRzO1xuXG4gIGZvciAodmFyIGkgPSBvbGRGcmFnbWVudHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgb2xkSW5pdCA9IG9sZEZyYWdtZW50c1tpXS5pbml0U2VnbWVudDtcblxuICAgIGlmIChvbGRJbml0KSB7XG4gICAgICBjdXJyZW50SW5pdFNlZ21lbnQgPSBvbGRJbml0O1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgaWYgKG9sZERldGFpbHMuZnJhZ21lbnRIaW50KSB7XG4gICAgLy8gcHJldmVudCBQVFMgYW5kIGR1cmF0aW9uIGZyb20gYmVpbmcgYWRqdXN0ZWQgb24gdGhlIG5leHQgaGludFxuICAgIGRlbGV0ZSBvbGREZXRhaWxzLmZyYWdtZW50SGludC5lbmRQVFM7XG4gIH0gLy8gY2hlY2sgaWYgb2xkL25ldyBwbGF5bGlzdHMgaGF2ZSBmcmFnbWVudHMgaW4gY29tbW9uXG4gIC8vIGxvb3AgdGhyb3VnaCBvdmVybGFwcGluZyBTTiBhbmQgdXBkYXRlIHN0YXJ0UFRTICwgY2MsIGFuZCBkdXJhdGlvbiBpZiBhbnkgZm91bmRcblxuXG4gIHZhciBjY09mZnNldCA9IDA7XG4gIHZhciBQVFNGcmFnO1xuICBtYXBGcmFnbWVudEludGVyc2VjdGlvbihvbGREZXRhaWxzLCBuZXdEZXRhaWxzLCBmdW5jdGlvbiAob2xkRnJhZywgbmV3RnJhZykge1xuICAgIGlmIChvbGRGcmFnLnJlbHVybCkge1xuICAgICAgLy8gRG8gbm90IGNvbXBhcmUgQ0MgaWYgdGhlIG9sZCBmcmFnbWVudCBoYXMgbm8gdXJsLiBUaGlzIGlzIGEgbGV2ZWwuZnJhZ21lbnRIaW50IHVzZWQgYnkgTEwtSExTIHBhcnRzLlxuICAgICAgLy8gSXQgbWF5YmUgYmUgb2ZmIGJ5IDEgaWYgaXQgd2FzIGNyZWF0ZWQgYmVmb3JlIGFueSBwYXJ0cyBvciBkaXNjb250aW51aXR5IHRhZ3Mgd2VyZSBhcHBlbmRlZCB0byB0aGUgZW5kXG4gICAgICAvLyBvZiB0aGUgcGxheWxpc3QuXG4gICAgICBjY09mZnNldCA9IG9sZEZyYWcuY2MgLSBuZXdGcmFnLmNjO1xuICAgIH1cblxuICAgIGlmIChPYmplY3QoX2hvbWVfcnVubmVyX3dvcmtfaGxzX2pzX2hsc19qc19zcmNfcG9seWZpbGxzX251bWJlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiaXNGaW5pdGVOdW1iZXJcIl0pKG9sZEZyYWcuc3RhcnRQVFMpICYmIE9iamVjdChfaG9tZV9ydW5uZXJfd29ya19obHNfanNfaGxzX2pzX3NyY19wb2x5ZmlsbHNfbnVtYmVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJpc0Zpbml0ZU51bWJlclwiXSkob2xkRnJhZy5lbmRQVFMpKSB7XG4gICAgICBuZXdGcmFnLnN0YXJ0ID0gbmV3RnJhZy5zdGFydFBUUyA9IG9sZEZyYWcuc3RhcnRQVFM7XG4gICAgICBuZXdGcmFnLnN0YXJ0RFRTID0gb2xkRnJhZy5zdGFydERUUztcbiAgICAgIG5ld0ZyYWcuYXBwZW5kZWRQVFMgPSBvbGRGcmFnLmFwcGVuZGVkUFRTO1xuICAgICAgbmV3RnJhZy5tYXhTdGFydFBUUyA9IG9sZEZyYWcubWF4U3RhcnRQVFM7XG4gICAgICBuZXdGcmFnLmVuZFBUUyA9IG9sZEZyYWcuZW5kUFRTO1xuICAgICAgbmV3RnJhZy5lbmREVFMgPSBvbGRGcmFnLmVuZERUUztcbiAgICAgIG5ld0ZyYWcubWluRW5kUFRTID0gb2xkRnJhZy5taW5FbmRQVFM7XG4gICAgICBuZXdGcmFnLmR1cmF0aW9uID0gb2xkRnJhZy5lbmRQVFMgLSBvbGRGcmFnLnN0YXJ0UFRTO1xuXG4gICAgICBpZiAobmV3RnJhZy5kdXJhdGlvbikge1xuICAgICAgICBQVFNGcmFnID0gbmV3RnJhZztcbiAgICAgIH0gLy8gUFRTIGlzIGtub3duIHdoZW4gYW55IHNlZ21lbnQgaGFzIHN0YXJ0UFRTIGFuZCBlbmRQVFNcblxuXG4gICAgICBuZXdEZXRhaWxzLlBUU0tub3duID0gbmV3RGV0YWlscy5hbGlnbmVkU2xpZGluZyA9IHRydWU7XG4gICAgfVxuXG4gICAgbmV3RnJhZy5lbGVtZW50YXJ5U3RyZWFtcyA9IG9sZEZyYWcuZWxlbWVudGFyeVN0cmVhbXM7XG4gICAgbmV3RnJhZy5sb2FkZXIgPSBvbGRGcmFnLmxvYWRlcjtcbiAgICBuZXdGcmFnLnN0YXRzID0gb2xkRnJhZy5zdGF0cztcbiAgICBuZXdGcmFnLnVybElkID0gb2xkRnJhZy51cmxJZDtcblxuICAgIGlmIChvbGRGcmFnLmluaXRTZWdtZW50KSB7XG4gICAgICBuZXdGcmFnLmluaXRTZWdtZW50ID0gb2xkRnJhZy5pbml0U2VnbWVudDtcbiAgICAgIGN1cnJlbnRJbml0U2VnbWVudCA9IG9sZEZyYWcuaW5pdFNlZ21lbnQ7XG4gICAgfVxuICB9KTtcblxuICBpZiAoY3VycmVudEluaXRTZWdtZW50KSB7XG4gICAgdmFyIGZyYWdtZW50c1RvQ2hlY2sgPSBuZXdEZXRhaWxzLmZyYWdtZW50SGludCA/IG5ld0RldGFpbHMuZnJhZ21lbnRzLmNvbmNhdChuZXdEZXRhaWxzLmZyYWdtZW50SGludCkgOiBuZXdEZXRhaWxzLmZyYWdtZW50cztcbiAgICBmcmFnbWVudHNUb0NoZWNrLmZvckVhY2goZnVuY3Rpb24gKGZyYWcpIHtcbiAgICAgIHZhciBfY3VycmVudEluaXRTZWdtZW50O1xuXG4gICAgICBpZiAoIWZyYWcuaW5pdFNlZ21lbnQgfHwgZnJhZy5pbml0U2VnbWVudC5yZWx1cmwgPT09ICgoX2N1cnJlbnRJbml0U2VnbWVudCA9IGN1cnJlbnRJbml0U2VnbWVudCkgPT09IG51bGwgfHwgX2N1cnJlbnRJbml0U2VnbWVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2N1cnJlbnRJbml0U2VnbWVudC5yZWx1cmwpKSB7XG4gICAgICAgIGZyYWcuaW5pdFNlZ21lbnQgPSBjdXJyZW50SW5pdFNlZ21lbnQ7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBpZiAobmV3RGV0YWlscy5za2lwcGVkU2VnbWVudHMpIHtcbiAgICBuZXdEZXRhaWxzLmRlbHRhVXBkYXRlRmFpbGVkID0gbmV3RGV0YWlscy5mcmFnbWVudHMuc29tZShmdW5jdGlvbiAoZnJhZykge1xuICAgICAgcmV0dXJuICFmcmFnO1xuICAgIH0pO1xuXG4gICAgaWYgKG5ld0RldGFpbHMuZGVsdGFVcGRhdGVGYWlsZWQpIHtcbiAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImxvZ2dlclwiXS53YXJuKCdbbGV2ZWwtaGVscGVyXSBQcmV2aW91cyBwbGF5bGlzdCBtaXNzaW5nIHNlZ21lbnRzIHNraXBwZWQgaW4gZGVsdGEgcGxheWxpc3QnKTtcblxuICAgICAgZm9yICh2YXIgX2kgPSBuZXdEZXRhaWxzLnNraXBwZWRTZWdtZW50czsgX2ktLTspIHtcbiAgICAgICAgbmV3RGV0YWlscy5mcmFnbWVudHMuc2hpZnQoKTtcbiAgICAgIH1cblxuICAgICAgbmV3RGV0YWlscy5zdGFydFNOID0gbmV3RGV0YWlscy5mcmFnbWVudHNbMF0uc247XG4gICAgICBuZXdEZXRhaWxzLnN0YXJ0Q0MgPSBuZXdEZXRhaWxzLmZyYWdtZW50c1swXS5jYztcbiAgICB9XG4gIH1cblxuICB2YXIgbmV3RnJhZ21lbnRzID0gbmV3RGV0YWlscy5mcmFnbWVudHM7XG5cbiAgaWYgKGNjT2Zmc2V0KSB7XG4gICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wibG9nZ2VyXCJdLndhcm4oJ2Rpc2NvbnRpbnVpdHkgc2xpZGluZyBmcm9tIHBsYXlsaXN0LCB0YWtlIGRyaWZ0IGludG8gYWNjb3VudCcpO1xuXG4gICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgbmV3RnJhZ21lbnRzLmxlbmd0aDsgX2kyKyspIHtcbiAgICAgIG5ld0ZyYWdtZW50c1tfaTJdLmNjICs9IGNjT2Zmc2V0O1xuICAgIH1cbiAgfVxuXG4gIGlmIChuZXdEZXRhaWxzLnNraXBwZWRTZWdtZW50cykge1xuICAgIG5ld0RldGFpbHMuc3RhcnRDQyA9IG5ld0RldGFpbHMuZnJhZ21lbnRzWzBdLmNjO1xuICB9IC8vIE1lcmdlIHBhcnRzXG5cblxuICBtYXBQYXJ0SW50ZXJzZWN0aW9uKG9sZERldGFpbHMucGFydExpc3QsIG5ld0RldGFpbHMucGFydExpc3QsIGZ1bmN0aW9uIChvbGRQYXJ0LCBuZXdQYXJ0KSB7XG4gICAgbmV3UGFydC5lbGVtZW50YXJ5U3RyZWFtcyA9IG9sZFBhcnQuZWxlbWVudGFyeVN0cmVhbXM7XG4gICAgbmV3UGFydC5zdGF0cyA9IG9sZFBhcnQuc3RhdHM7XG4gIH0pOyAvLyBpZiBhdCBsZWFzdCBvbmUgZnJhZ21lbnQgY29udGFpbnMgUFRTIGluZm8sIHJlY29tcHV0ZSBQVFMgaW5mb3JtYXRpb24gZm9yIGFsbCBmcmFnbWVudHNcblxuICBpZiAoUFRTRnJhZykge1xuICAgIHVwZGF0ZUZyYWdQVFNEVFMobmV3RGV0YWlscywgUFRTRnJhZywgUFRTRnJhZy5zdGFydFBUUywgUFRTRnJhZy5lbmRQVFMsIFBUU0ZyYWcuc3RhcnREVFMsIFBUU0ZyYWcuZW5kRFRTKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBlbnN1cmUgdGhhdCBkZWx0YSBpcyB3aXRoaW4gb2xkRnJhZ21lbnRzIHJhbmdlXG4gICAgLy8gYWxzbyBhZGp1c3Qgc2xpZGluZyBpbiBjYXNlIGRlbHRhIGlzIDAgKHdlIGNvdWxkIGhhdmUgb2xkPVs1MC02MF0gYW5kIG5ldz1vbGQ9WzUwLTYxXSlcbiAgICAvLyBpbiB0aGF0IGNhc2Ugd2UgYWxzbyBuZWVkIHRvIGFkanVzdCBzdGFydCBvZmZzZXQgb2YgYWxsIGZyYWdtZW50c1xuICAgIGFkanVzdFNsaWRpbmcob2xkRGV0YWlscywgbmV3RGV0YWlscyk7XG4gIH1cblxuICBpZiAobmV3RnJhZ21lbnRzLmxlbmd0aCkge1xuICAgIG5ld0RldGFpbHMudG90YWxkdXJhdGlvbiA9IG5ld0RldGFpbHMuZWRnZSAtIG5ld0ZyYWdtZW50c1swXS5zdGFydDtcbiAgfVxuXG4gIG5ld0RldGFpbHMuZHJpZnRTdGFydFRpbWUgPSBvbGREZXRhaWxzLmRyaWZ0U3RhcnRUaW1lO1xuICBuZXdEZXRhaWxzLmRyaWZ0U3RhcnQgPSBvbGREZXRhaWxzLmRyaWZ0U3RhcnQ7XG4gIHZhciBhZHZhbmNlZERhdGVUaW1lID0gbmV3RGV0YWlscy5hZHZhbmNlZERhdGVUaW1lO1xuXG4gIGlmIChuZXdEZXRhaWxzLmFkdmFuY2VkICYmIGFkdmFuY2VkRGF0ZVRpbWUpIHtcbiAgICB2YXIgZWRnZSA9IG5ld0RldGFpbHMuZWRnZTtcblxuICAgIGlmICghbmV3RGV0YWlscy5kcmlmdFN0YXJ0KSB7XG4gICAgICBuZXdEZXRhaWxzLmRyaWZ0U3RhcnRUaW1lID0gYWR2YW5jZWREYXRlVGltZTtcbiAgICAgIG5ld0RldGFpbHMuZHJpZnRTdGFydCA9IGVkZ2U7XG4gICAgfVxuXG4gICAgbmV3RGV0YWlscy5kcmlmdEVuZFRpbWUgPSBhZHZhbmNlZERhdGVUaW1lO1xuICAgIG5ld0RldGFpbHMuZHJpZnRFbmQgPSBlZGdlO1xuICB9IGVsc2Uge1xuICAgIG5ld0RldGFpbHMuZHJpZnRFbmRUaW1lID0gb2xkRGV0YWlscy5kcmlmdEVuZFRpbWU7XG4gICAgbmV3RGV0YWlscy5kcmlmdEVuZCA9IG9sZERldGFpbHMuZHJpZnRFbmQ7XG4gICAgbmV3RGV0YWlscy5hZHZhbmNlZERhdGVUaW1lID0gb2xkRGV0YWlscy5hZHZhbmNlZERhdGVUaW1lO1xuICB9XG59XG5mdW5jdGlvbiBtYXBQYXJ0SW50ZXJzZWN0aW9uKG9sZFBhcnRzLCBuZXdQYXJ0cywgaW50ZXJzZWN0aW9uRm4pIHtcbiAgaWYgKG9sZFBhcnRzICYmIG5ld1BhcnRzKSB7XG4gICAgdmFyIGRlbHRhID0gMDtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBvbGRQYXJ0cy5sZW5ndGg7IGkgPD0gbGVuOyBpKyspIHtcbiAgICAgIHZhciBfb2xkUGFydCA9IG9sZFBhcnRzW2ldO1xuICAgICAgdmFyIF9uZXdQYXJ0ID0gbmV3UGFydHNbaSArIGRlbHRhXTtcblxuICAgICAgaWYgKF9vbGRQYXJ0ICYmIF9uZXdQYXJ0ICYmIF9vbGRQYXJ0LmluZGV4ID09PSBfbmV3UGFydC5pbmRleCAmJiBfb2xkUGFydC5mcmFnbWVudC5zbiA9PT0gX25ld1BhcnQuZnJhZ21lbnQuc24pIHtcbiAgICAgICAgaW50ZXJzZWN0aW9uRm4oX29sZFBhcnQsIF9uZXdQYXJ0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbHRhLS07XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBtYXBGcmFnbWVudEludGVyc2VjdGlvbihvbGREZXRhaWxzLCBuZXdEZXRhaWxzLCBpbnRlcnNlY3Rpb25Gbikge1xuICB2YXIgc2tpcHBlZFNlZ21lbnRzID0gbmV3RGV0YWlscy5za2lwcGVkU2VnbWVudHM7XG4gIHZhciBzdGFydCA9IE1hdGgubWF4KG9sZERldGFpbHMuc3RhcnRTTiwgbmV3RGV0YWlscy5zdGFydFNOKSAtIG5ld0RldGFpbHMuc3RhcnRTTjtcbiAgdmFyIGVuZCA9IChvbGREZXRhaWxzLmZyYWdtZW50SGludCA/IDEgOiAwKSArIChza2lwcGVkU2VnbWVudHMgPyBuZXdEZXRhaWxzLmVuZFNOIDogTWF0aC5taW4ob2xkRGV0YWlscy5lbmRTTiwgbmV3RGV0YWlscy5lbmRTTikpIC0gbmV3RGV0YWlscy5zdGFydFNOO1xuICB2YXIgZGVsdGEgPSBuZXdEZXRhaWxzLnN0YXJ0U04gLSBvbGREZXRhaWxzLnN0YXJ0U047XG4gIHZhciBuZXdGcmFncyA9IG5ld0RldGFpbHMuZnJhZ21lbnRIaW50ID8gbmV3RGV0YWlscy5mcmFnbWVudHMuY29uY2F0KG5ld0RldGFpbHMuZnJhZ21lbnRIaW50KSA6IG5ld0RldGFpbHMuZnJhZ21lbnRzO1xuICB2YXIgb2xkRnJhZ3MgPSBvbGREZXRhaWxzLmZyYWdtZW50SGludCA/IG9sZERldGFpbHMuZnJhZ21lbnRzLmNvbmNhdChvbGREZXRhaWxzLmZyYWdtZW50SGludCkgOiBvbGREZXRhaWxzLmZyYWdtZW50cztcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPD0gZW5kOyBpKyspIHtcbiAgICB2YXIgX29sZEZyYWcgPSBvbGRGcmFnc1tkZWx0YSArIGldO1xuICAgIHZhciBfbmV3RnJhZyA9IG5ld0ZyYWdzW2ldO1xuXG4gICAgaWYgKHNraXBwZWRTZWdtZW50cyAmJiAhX25ld0ZyYWcgJiYgaSA8IHNraXBwZWRTZWdtZW50cykge1xuICAgICAgLy8gRmlsbCBpbiBza2lwcGVkIHNlZ21lbnRzIGluIGRlbHRhIHBsYXlsaXN0XG4gICAgICBfbmV3RnJhZyA9IG5ld0RldGFpbHMuZnJhZ21lbnRzW2ldID0gX29sZEZyYWc7XG4gICAgfVxuXG4gICAgaWYgKF9vbGRGcmFnICYmIF9uZXdGcmFnKSB7XG4gICAgICBpbnRlcnNlY3Rpb25Gbihfb2xkRnJhZywgX25ld0ZyYWcpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gYWRqdXN0U2xpZGluZyhvbGREZXRhaWxzLCBuZXdEZXRhaWxzKSB7XG4gIHZhciBkZWx0YSA9IG5ld0RldGFpbHMuc3RhcnRTTiArIG5ld0RldGFpbHMuc2tpcHBlZFNlZ21lbnRzIC0gb2xkRGV0YWlscy5zdGFydFNOO1xuICB2YXIgb2xkRnJhZ21lbnRzID0gb2xkRGV0YWlscy5mcmFnbWVudHM7XG5cbiAgaWYgKGRlbHRhIDwgMCB8fCBkZWx0YSA+PSBvbGRGcmFnbWVudHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgYWRkU2xpZGluZyhuZXdEZXRhaWxzLCBvbGRGcmFnbWVudHNbZGVsdGFdLnN0YXJ0KTtcbn1cbmZ1bmN0aW9uIGFkZFNsaWRpbmcoZGV0YWlscywgc3RhcnQpIHtcbiAgaWYgKHN0YXJ0KSB7XG4gICAgdmFyIGZyYWdtZW50cyA9IGRldGFpbHMuZnJhZ21lbnRzO1xuXG4gICAgZm9yICh2YXIgaSA9IGRldGFpbHMuc2tpcHBlZFNlZ21lbnRzOyBpIDwgZnJhZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBmcmFnbWVudHNbaV0uc3RhcnQgKz0gc3RhcnQ7XG4gICAgfVxuXG4gICAgaWYgKGRldGFpbHMuZnJhZ21lbnRIaW50KSB7XG4gICAgICBkZXRhaWxzLmZyYWdtZW50SGludC5zdGFydCArPSBzdGFydDtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGNvbXB1dGVSZWxvYWRJbnRlcnZhbChuZXdEZXRhaWxzLCBzdGF0cykge1xuICB2YXIgcmVsb2FkSW50ZXJ2YWwgPSAxMDAwICogbmV3RGV0YWlscy5sZXZlbFRhcmdldER1cmF0aW9uO1xuICB2YXIgcmVsb2FkSW50ZXJ2YWxBZnRlck1pc3MgPSByZWxvYWRJbnRlcnZhbCAvIDI7XG4gIHZhciB0aW1lU2luY2VMYXN0TW9kaWZpZWQgPSBuZXdEZXRhaWxzLmFnZTtcbiAgdmFyIHVzZUxhc3RNb2RpZmllZCA9IHRpbWVTaW5jZUxhc3RNb2RpZmllZCA+IDAgJiYgdGltZVNpbmNlTGFzdE1vZGlmaWVkIDwgcmVsb2FkSW50ZXJ2YWwgKiAzO1xuICB2YXIgcm91bmRUcmlwID0gc3RhdHMubG9hZGluZy5lbmQgLSBzdGF0cy5sb2FkaW5nLnN0YXJ0O1xuICB2YXIgZXN0aW1hdGVkVGltZVVudGlsVXBkYXRlO1xuICB2YXIgYXZhaWxhYmlsaXR5RGVsYXkgPSBuZXdEZXRhaWxzLmF2YWlsYWJpbGl0eURlbGF5OyAvLyBsZXQgZXN0aW1hdGUgPSAnYXZlcmFnZSc7XG5cbiAgaWYgKG5ld0RldGFpbHMudXBkYXRlZCA9PT0gZmFsc2UpIHtcbiAgICBpZiAodXNlTGFzdE1vZGlmaWVkKSB7XG4gICAgICAvLyBlc3RpbWF0ZSA9ICdtaXNzIHJvdW5kIHRyaXAnO1xuICAgICAgLy8gV2Ugc2hvdWxkIGhhdmUgaGFkIGEgaGl0IHNvIHRyeSBhZ2FpbiBpbiB0aGUgdGltZSBpdCB0YWtlcyB0byBnZXQgYSByZXNwb25zZSxcbiAgICAgIC8vIGJ1dCBubyBsZXNzIHRoYW4gMS8zIHNlY29uZC5cbiAgICAgIHZhciBtaW5SZXRyeSA9IDMzMyAqIG5ld0RldGFpbHMubWlzc2VzO1xuICAgICAgZXN0aW1hdGVkVGltZVVudGlsVXBkYXRlID0gTWF0aC5tYXgoTWF0aC5taW4ocmVsb2FkSW50ZXJ2YWxBZnRlck1pc3MsIHJvdW5kVHJpcCAqIDIpLCBtaW5SZXRyeSk7XG4gICAgICBuZXdEZXRhaWxzLmF2YWlsYWJpbGl0eURlbGF5ID0gKG5ld0RldGFpbHMuYXZhaWxhYmlsaXR5RGVsYXkgfHwgMCkgKyBlc3RpbWF0ZWRUaW1lVW50aWxVcGRhdGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGVzdGltYXRlID0gJ21pc3MgaGFsZiBhdmVyYWdlJztcbiAgICAgIC8vIGZvbGxvdyBITFMgU3BlYywgSWYgdGhlIGNsaWVudCByZWxvYWRzIGEgUGxheWxpc3QgZmlsZSBhbmQgZmluZHMgdGhhdCBpdCBoYXMgbm90XG4gICAgICAvLyBjaGFuZ2VkIHRoZW4gaXQgTVVTVCB3YWl0IGZvciBhIHBlcmlvZCBvZiBvbmUtaGFsZiB0aGUgdGFyZ2V0XG4gICAgICAvLyBkdXJhdGlvbiBiZWZvcmUgcmV0cnlpbmcuXG4gICAgICBlc3RpbWF0ZWRUaW1lVW50aWxVcGRhdGUgPSByZWxvYWRJbnRlcnZhbEFmdGVyTWlzcztcbiAgICB9XG4gIH0gZWxzZSBpZiAodXNlTGFzdE1vZGlmaWVkKSB7XG4gICAgLy8gZXN0aW1hdGUgPSAnbmV4dCBtb2RpZmllZCBkYXRlJztcbiAgICAvLyBHZXQgdGhlIGNsb3Nlc3Qgd2UndmUgYmVlbiB0byB0aW1lU2luY2VMYXN0TW9kaWZpZWQgb24gdXBkYXRlXG4gICAgYXZhaWxhYmlsaXR5RGVsYXkgPSBNYXRoLm1pbihhdmFpbGFiaWxpdHlEZWxheSB8fCByZWxvYWRJbnRlcnZhbCAvIDIsIHRpbWVTaW5jZUxhc3RNb2RpZmllZCk7XG4gICAgbmV3RGV0YWlscy5hdmFpbGFiaWxpdHlEZWxheSA9IGF2YWlsYWJpbGl0eURlbGF5O1xuICAgIGVzdGltYXRlZFRpbWVVbnRpbFVwZGF0ZSA9IGF2YWlsYWJpbGl0eURlbGF5ICsgcmVsb2FkSW50ZXJ2YWwgLSB0aW1lU2luY2VMYXN0TW9kaWZpZWQ7XG4gIH0gZWxzZSB7XG4gICAgZXN0aW1hdGVkVGltZVVudGlsVXBkYXRlID0gcmVsb2FkSW50ZXJ2YWwgLSByb3VuZFRyaXA7XG4gIH0gLy8gY29uc29sZS5sb2coYFtjb21wdXRlUmVsb2FkSW50ZXJ2YWxdIGxpdmUgcmVsb2FkICR7bmV3RGV0YWlscy51cGRhdGVkID8gJ1JFRlJFU0hFRCcgOiAnTUlTU0VEJ31gLFxuICAvLyAgICdcXG4gIG1ldGhvZCcsIGVzdGltYXRlLFxuICAvLyAgICdcXG4gIGVzdGltYXRlZCB0aW1lIHVudGlsIHVwZGF0ZSA9PicsIGVzdGltYXRlZFRpbWVVbnRpbFVwZGF0ZSxcbiAgLy8gICAnXFxuICBhdmVyYWdlIHRhcmdldCBkdXJhdGlvbicsIHJlbG9hZEludGVydmFsLFxuICAvLyAgICdcXG4gIHRpbWUgc2luY2UgbW9kaWZpZWQnLCB0aW1lU2luY2VMYXN0TW9kaWZpZWQsXG4gIC8vICAgJ1xcbiAgdGltZSByb3VuZCB0cmlwJywgcm91bmRUcmlwLFxuICAvLyAgICdcXG4gIGF2YWlsYWJpbGl0eSBkZWxheScsIGF2YWlsYWJpbGl0eURlbGF5KTtcblxuXG4gIHJldHVybiBNYXRoLnJvdW5kKGVzdGltYXRlZFRpbWVVbnRpbFVwZGF0ZSk7XG59XG5mdW5jdGlvbiBnZXRGcmFnbWVudFdpdGhTTihsZXZlbCwgc24sIGZyYWdDdXJyZW50KSB7XG4gIGlmICghbGV2ZWwgfHwgIWxldmVsLmRldGFpbHMpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBsZXZlbERldGFpbHMgPSBsZXZlbC5kZXRhaWxzO1xuICB2YXIgZnJhZ21lbnQgPSBsZXZlbERldGFpbHMuZnJhZ21lbnRzW3NuIC0gbGV2ZWxEZXRhaWxzLnN0YXJ0U05dO1xuXG4gIGlmIChmcmFnbWVudCkge1xuICAgIHJldHVybiBmcmFnbWVudDtcbiAgfVxuXG4gIGZyYWdtZW50ID0gbGV2ZWxEZXRhaWxzLmZyYWdtZW50SGludDtcblxuICBpZiAoZnJhZ21lbnQgJiYgZnJhZ21lbnQuc24gPT09IHNuKSB7XG4gICAgcmV0dXJuIGZyYWdtZW50O1xuICB9XG5cbiAgaWYgKHNuIDwgbGV2ZWxEZXRhaWxzLnN0YXJ0U04gJiYgZnJhZ0N1cnJlbnQgJiYgZnJhZ0N1cnJlbnQuc24gPT09IHNuKSB7XG4gICAgcmV0dXJuIGZyYWdDdXJyZW50O1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBnZXRQYXJ0V2l0aChsZXZlbCwgc24sIHBhcnRJbmRleCkge1xuICBpZiAoIWxldmVsIHx8ICFsZXZlbC5kZXRhaWxzKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgcGFydExpc3QgPSBsZXZlbC5kZXRhaWxzLnBhcnRMaXN0O1xuXG4gIGlmIChwYXJ0TGlzdCkge1xuICAgIGZvciAodmFyIGkgPSBwYXJ0TGlzdC5sZW5ndGg7IGktLTspIHtcbiAgICAgIHZhciBwYXJ0ID0gcGFydExpc3RbaV07XG5cbiAgICAgIGlmIChwYXJ0LmluZGV4ID09PSBwYXJ0SW5kZXggJiYgcGFydC5mcmFnbWVudC5zbiA9PT0gc24pIHtcbiAgICAgICAgcmV0dXJuIHBhcnQ7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NvbnRyb2xsZXIvc3RyZWFtLWNvbnRyb2xsZXIudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9jb250cm9sbGVyL3N0cmVhbS1jb250cm9sbGVyLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJkZWZhdWx0XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gU3RyZWFtQ29udHJvbGxlcjsgfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2hvbWVfcnVubmVyX3dvcmtfaGxzX2pzX2hsc19qc19zcmNfcG9seWZpbGxzX251bWJlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zcmMvcG9seWZpbGxzL251bWJlciAqLyBcIi4vc3JjL3BvbHlmaWxscy9udW1iZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2Jhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vYmFzZS1zdHJlYW0tY29udHJvbGxlciAqLyBcIi4vc3JjL2NvbnRyb2xsZXIvYmFzZS1zdHJlYW0tY29udHJvbGxlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfaXNfc3VwcG9ydGVkX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pcy1zdXBwb3J0ZWQgKi8gXCIuL3NyYy9pcy1zdXBwb3J0ZWQudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZXZlbnRzICovIFwiLi9zcmMvZXZlbnRzLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19idWZmZXJfaGVscGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9idWZmZXItaGVscGVyICovIFwiLi9zcmMvdXRpbHMvYnVmZmVyLWhlbHBlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZnJhZ21lbnRfdHJhY2tlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9mcmFnbWVudC10cmFja2VyICovIFwiLi9zcmMvY29udHJvbGxlci9mcmFnbWVudC10cmFja2VyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF90eXBlc19sb2FkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3R5cGVzL2xvYWRlciAqLyBcIi4vc3JjL3R5cGVzL2xvYWRlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbG9hZGVyX2ZyYWdtZW50X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9sb2FkZXIvZnJhZ21lbnQgKi8gXCIuL3NyYy9sb2FkZXIvZnJhZ21lbnQudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2RlbXV4X3RyYW5zbXV4ZXJfaW50ZXJmYWNlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV84X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9kZW11eC90cmFuc211eGVyLWludGVyZmFjZSAqLyBcIi4vc3JjL2RlbXV4L3RyYW5zbXV4ZXItaW50ZXJmYWNlLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF90eXBlc190cmFuc211eGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV85X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi90eXBlcy90cmFuc211eGVyICovIFwiLi9zcmMvdHlwZXMvdHJhbnNtdXhlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZ2FwX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEwX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2dhcC1jb250cm9sbGVyICovIFwiLi9zcmMvY29udHJvbGxlci9nYXAtY29udHJvbGxlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZXJyb3JzICovIFwiLi9zcmMvZXJyb3JzLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEyX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9sb2dnZXIgKi8gXCIuL3NyYy91dGlscy9sb2dnZXIudHNcIik7XG5cblxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpOyBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzczsgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG52YXIgVElDS19JTlRFUlZBTCA9IDEwMDsgLy8gaG93IG9mdGVuIHRvIHRpY2sgaW4gbXNcblxudmFyIFN0cmVhbUNvbnRyb2xsZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9CYXNlU3RyZWFtQ29udHJvbGxlcikge1xuICBfaW5oZXJpdHNMb29zZShTdHJlYW1Db250cm9sbGVyLCBfQmFzZVN0cmVhbUNvbnRyb2xsZXIpO1xuXG4gIGZ1bmN0aW9uIFN0cmVhbUNvbnRyb2xsZXIoaGxzLCBmcmFnbWVudFRyYWNrZXIpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfdGhpcyA9IF9CYXNlU3RyZWFtQ29udHJvbGxlci5jYWxsKHRoaXMsIGhscywgZnJhZ21lbnRUcmFja2VyLCAnW3N0cmVhbS1jb250cm9sbGVyXScpIHx8IHRoaXM7XG4gICAgX3RoaXMuYXVkaW9Db2RlY1N3YXAgPSBmYWxzZTtcbiAgICBfdGhpcy5nYXBDb250cm9sbGVyID0gbnVsbDtcbiAgICBfdGhpcy5sZXZlbCA9IC0xO1xuICAgIF90aGlzLl9mb3JjZVN0YXJ0TG9hZCA9IGZhbHNlO1xuICAgIF90aGlzLmFsdEF1ZGlvID0gZmFsc2U7XG4gICAgX3RoaXMuYXVkaW9Pbmx5ID0gZmFsc2U7XG4gICAgX3RoaXMuZnJhZ1BsYXlpbmcgPSBudWxsO1xuICAgIF90aGlzLm9udnBsYXlpbmcgPSBudWxsO1xuICAgIF90aGlzLm9udnNlZWtlZCA9IG51bGw7XG4gICAgX3RoaXMuZnJhZ0xhc3RLYnBzID0gMDtcbiAgICBfdGhpcy5zdGFsbGVkID0gZmFsc2U7XG4gICAgX3RoaXMuY291bGRCYWNrdHJhY2sgPSBmYWxzZTtcbiAgICBfdGhpcy5hdWRpb0NvZGVjU3dpdGNoID0gZmFsc2U7XG4gICAgX3RoaXMudmlkZW9CdWZmZXIgPSBudWxsO1xuXG4gICAgX3RoaXMuX3JlZ2lzdGVyTGlzdGVuZXJzKCk7XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gU3RyZWFtQ29udHJvbGxlci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLl9yZWdpc3Rlckxpc3RlbmVycyA9IGZ1bmN0aW9uIF9yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICB2YXIgaGxzID0gdGhpcy5obHM7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcIkV2ZW50c1wiXS5NRURJQV9BVFRBQ0hFRCwgdGhpcy5vbk1lZGlhQXR0YWNoZWQsIHRoaXMpO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJFdmVudHNcIl0uTUVESUFfREVUQUNISU5HLCB0aGlzLm9uTWVkaWFEZXRhY2hpbmcsIHRoaXMpO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJFdmVudHNcIl0uTUFOSUZFU1RfTE9BRElORywgdGhpcy5vbk1hbmlmZXN0TG9hZGluZywgdGhpcyk7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcIkV2ZW50c1wiXS5NQU5JRkVTVF9QQVJTRUQsIHRoaXMub25NYW5pZmVzdFBhcnNlZCwgdGhpcyk7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcIkV2ZW50c1wiXS5MRVZFTF9MT0FESU5HLCB0aGlzLm9uTGV2ZWxMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiRXZlbnRzXCJdLkxFVkVMX0xPQURFRCwgdGhpcy5vbkxldmVsTG9hZGVkLCB0aGlzKTtcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiRXZlbnRzXCJdLkZSQUdfTE9BRF9FTUVSR0VOQ1lfQUJPUlRFRCwgdGhpcy5vbkZyYWdMb2FkRW1lcmdlbmN5QWJvcnRlZCwgdGhpcyk7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcIkV2ZW50c1wiXS5FUlJPUiwgdGhpcy5vbkVycm9yLCB0aGlzKTtcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiRXZlbnRzXCJdLkFVRElPX1RSQUNLX1NXSVRDSElORywgdGhpcy5vbkF1ZGlvVHJhY2tTd2l0Y2hpbmcsIHRoaXMpO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJFdmVudHNcIl0uQVVESU9fVFJBQ0tfU1dJVENIRUQsIHRoaXMub25BdWRpb1RyYWNrU3dpdGNoZWQsIHRoaXMpO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJFdmVudHNcIl0uQlVGRkVSX0NSRUFURUQsIHRoaXMub25CdWZmZXJDcmVhdGVkLCB0aGlzKTtcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiRXZlbnRzXCJdLkJVRkZFUl9GTFVTSEVELCB0aGlzLm9uQnVmZmVyRmx1c2hlZCwgdGhpcyk7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcIkV2ZW50c1wiXS5MRVZFTFNfVVBEQVRFRCwgdGhpcy5vbkxldmVsc1VwZGF0ZWQsIHRoaXMpO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJFdmVudHNcIl0uRlJBR19CVUZGRVJFRCwgdGhpcy5vbkZyYWdCdWZmZXJlZCwgdGhpcyk7XG4gIH07XG5cbiAgX3Byb3RvLl91bnJlZ2lzdGVyTGlzdGVuZXJzID0gZnVuY3Rpb24gX3VucmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgdmFyIGhscyA9IHRoaXMuaGxzO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiRXZlbnRzXCJdLk1FRElBX0FUVEFDSEVELCB0aGlzLm9uTWVkaWFBdHRhY2hlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJFdmVudHNcIl0uTUVESUFfREVUQUNISU5HLCB0aGlzLm9uTWVkaWFEZXRhY2hpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiRXZlbnRzXCJdLk1BTklGRVNUX0xPQURJTkcsIHRoaXMub25NYW5pZmVzdExvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiRXZlbnRzXCJdLk1BTklGRVNUX1BBUlNFRCwgdGhpcy5vbk1hbmlmZXN0UGFyc2VkLCB0aGlzKTtcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcIkV2ZW50c1wiXS5MRVZFTF9MT0FERUQsIHRoaXMub25MZXZlbExvYWRlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJFdmVudHNcIl0uRlJBR19MT0FEX0VNRVJHRU5DWV9BQk9SVEVELCB0aGlzLm9uRnJhZ0xvYWRFbWVyZ2VuY3lBYm9ydGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcIkV2ZW50c1wiXS5FUlJPUiwgdGhpcy5vbkVycm9yLCB0aGlzKTtcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcIkV2ZW50c1wiXS5BVURJT19UUkFDS19TV0lUQ0hJTkcsIHRoaXMub25BdWRpb1RyYWNrU3dpdGNoaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcIkV2ZW50c1wiXS5BVURJT19UUkFDS19TV0lUQ0hFRCwgdGhpcy5vbkF1ZGlvVHJhY2tTd2l0Y2hlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJFdmVudHNcIl0uQlVGRkVSX0NSRUFURUQsIHRoaXMub25CdWZmZXJDcmVhdGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcIkV2ZW50c1wiXS5CVUZGRVJfRkxVU0hFRCwgdGhpcy5vbkJ1ZmZlckZsdXNoZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiRXZlbnRzXCJdLkxFVkVMU19VUERBVEVELCB0aGlzLm9uTGV2ZWxzVXBkYXRlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJFdmVudHNcIl0uRlJBR19CVUZGRVJFRCwgdGhpcy5vbkZyYWdCdWZmZXJlZCwgdGhpcyk7XG4gIH07XG5cbiAgX3Byb3RvLm9uSGFuZGxlckRlc3Ryb3lpbmcgPSBmdW5jdGlvbiBvbkhhbmRsZXJEZXN0cm95aW5nKCkge1xuICAgIHRoaXMuX3VucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcblxuICAgIHRoaXMub25NZWRpYURldGFjaGluZygpO1xuICB9O1xuXG4gIF9wcm90by5zdGFydExvYWQgPSBmdW5jdGlvbiBzdGFydExvYWQoc3RhcnRQb3NpdGlvbikge1xuICAgIGlmICh0aGlzLmxldmVscykge1xuICAgICAgdmFyIGxhc3RDdXJyZW50VGltZSA9IHRoaXMubGFzdEN1cnJlbnRUaW1lLFxuICAgICAgICAgIGhscyA9IHRoaXMuaGxzO1xuICAgICAgdGhpcy5zdG9wTG9hZCgpO1xuICAgICAgdGhpcy5zZXRJbnRlcnZhbChUSUNLX0lOVEVSVkFMKTtcbiAgICAgIHRoaXMubGV2ZWwgPSAtMTtcbiAgICAgIHRoaXMuZnJhZ0xvYWRFcnJvciA9IDA7XG5cbiAgICAgIGlmICghdGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQpIHtcbiAgICAgICAgLy8gZGV0ZXJtaW5lIGxvYWQgbGV2ZWxcbiAgICAgICAgdmFyIHN0YXJ0TGV2ZWwgPSBobHMuc3RhcnRMZXZlbDtcblxuICAgICAgICBpZiAoc3RhcnRMZXZlbCA9PT0gLTEpIHtcbiAgICAgICAgICBpZiAoaGxzLmNvbmZpZy50ZXN0QmFuZHdpZHRoKSB7XG4gICAgICAgICAgICAvLyAtMSA6IGd1ZXNzIHN0YXJ0IExldmVsIGJ5IGRvaW5nIGEgYml0cmF0ZSB0ZXN0IGJ5IGxvYWRpbmcgZmlyc3QgZnJhZ21lbnQgb2YgbG93ZXN0IHF1YWxpdHkgbGV2ZWxcbiAgICAgICAgICAgIHN0YXJ0TGV2ZWwgPSAwO1xuICAgICAgICAgICAgdGhpcy5iaXRyYXRlVGVzdCA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0YXJ0TGV2ZWwgPSBobHMubmV4dEF1dG9MZXZlbDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gc2V0IG5ldyBsZXZlbCB0byBwbGF5bGlzdCBsb2FkZXIgOiB0aGlzIHdpbGwgdHJpZ2dlciBzdGFydCBsZXZlbCBsb2FkXG4gICAgICAgIC8vIGhscy5uZXh0TG9hZExldmVsIHJlbWFpbnMgdW50aWwgaXQgaXMgc2V0IHRvIGEgbmV3IHZhbHVlIG9yIHVudGlsIGEgbmV3IGZyYWcgaXMgc3VjY2Vzc2Z1bGx5IGxvYWRlZFxuXG5cbiAgICAgICAgdGhpcy5sZXZlbCA9IGhscy5uZXh0TG9hZExldmVsID0gc3RhcnRMZXZlbDtcbiAgICAgICAgdGhpcy5sb2FkZWRtZXRhZGF0YSA9IGZhbHNlO1xuICAgICAgfSAvLyBpZiBzdGFydFBvc2l0aW9uIHVuZGVmaW5lZCBidXQgbGFzdEN1cnJlbnRUaW1lIHNldCwgc2V0IHN0YXJ0UG9zaXRpb24gdG8gbGFzdCBjdXJyZW50VGltZVxuXG5cbiAgICAgIGlmIChsYXN0Q3VycmVudFRpbWUgPiAwICYmIHN0YXJ0UG9zaXRpb24gPT09IC0xKSB7XG4gICAgICAgIHRoaXMubG9nKFwiT3ZlcnJpZGUgc3RhcnRQb3NpdGlvbiB3aXRoIGxhc3RDdXJyZW50VGltZSBAXCIgKyBsYXN0Q3VycmVudFRpbWUudG9GaXhlZCgzKSk7XG4gICAgICAgIHN0YXJ0UG9zaXRpb24gPSBsYXN0Q3VycmVudFRpbWU7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc3RhdGUgPSBfYmFzZV9zdHJlYW1fY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiU3RhdGVcIl0uSURMRTtcbiAgICAgIHRoaXMubmV4dExvYWRQb3NpdGlvbiA9IHRoaXMuc3RhcnRQb3NpdGlvbiA9IHRoaXMubGFzdEN1cnJlbnRUaW1lID0gc3RhcnRQb3NpdGlvbjtcbiAgICAgIHRoaXMudGljaygpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9mb3JjZVN0YXJ0TG9hZCA9IHRydWU7XG4gICAgICB0aGlzLnN0YXRlID0gX2Jhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIlN0YXRlXCJdLlNUT1BQRUQ7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5zdG9wTG9hZCA9IGZ1bmN0aW9uIHN0b3BMb2FkKCkge1xuICAgIHRoaXMuX2ZvcmNlU3RhcnRMb2FkID0gZmFsc2U7XG5cbiAgICBfQmFzZVN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLnN0b3BMb2FkLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgX3Byb3RvLmRvVGljayA9IGZ1bmN0aW9uIGRvVGljaygpIHtcbiAgICBzd2l0Y2ggKHRoaXMuc3RhdGUpIHtcbiAgICAgIGNhc2UgX2Jhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIlN0YXRlXCJdLklETEU6XG4gICAgICAgIHRoaXMuZG9UaWNrSWRsZSgpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBfYmFzZV9zdHJlYW1fY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiU3RhdGVcIl0uV0FJVElOR19MRVZFTDpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBfbGV2ZWxzJGxldmVsO1xuXG4gICAgICAgICAgdmFyIGxldmVscyA9IHRoaXMubGV2ZWxzLFxuICAgICAgICAgICAgICBsZXZlbCA9IHRoaXMubGV2ZWw7XG4gICAgICAgICAgdmFyIGRldGFpbHMgPSBsZXZlbHMgPT09IG51bGwgfHwgbGV2ZWxzID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX2xldmVscyRsZXZlbCA9IGxldmVsc1tsZXZlbF0pID09PSBudWxsIHx8IF9sZXZlbHMkbGV2ZWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9sZXZlbHMkbGV2ZWwuZGV0YWlscztcblxuICAgICAgICAgIGlmIChkZXRhaWxzICYmICghZGV0YWlscy5saXZlIHx8IHRoaXMubGV2ZWxMYXN0TG9hZGVkID09PSB0aGlzLmxldmVsKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMud2FpdEZvckNkblR1bmVJbihkZXRhaWxzKSkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IF9iYXNlX3N0cmVhbV9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJTdGF0ZVwiXS5JRExFO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBfYmFzZV9zdHJlYW1fY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiU3RhdGVcIl0uRlJBR19MT0FESU5HX1dBSVRJTkdfUkVUUlk6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgX3RoaXMkbWVkaWE7XG5cbiAgICAgICAgICB2YXIgbm93ID0gc2VsZi5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgICB2YXIgcmV0cnlEYXRlID0gdGhpcy5yZXRyeURhdGU7IC8vIGlmIGN1cnJlbnQgdGltZSBpcyBndCB0aGFuIHJldHJ5RGF0ZSwgb3IgaWYgbWVkaWEgc2Vla2luZyBsZXQncyBzd2l0Y2ggdG8gSURMRSBzdGF0ZSB0byByZXRyeSBsb2FkaW5nXG5cbiAgICAgICAgICBpZiAoIXJldHJ5RGF0ZSB8fCBub3cgPj0gcmV0cnlEYXRlIHx8IChfdGhpcyRtZWRpYSA9IHRoaXMubWVkaWEpICE9PSBudWxsICYmIF90aGlzJG1lZGlhICE9PSB2b2lkIDAgJiYgX3RoaXMkbWVkaWEuc2Vla2luZykge1xuICAgICAgICAgICAgdGhpcy5sb2coJ3JldHJ5RGF0ZSByZWFjaGVkLCBzd2l0Y2ggYmFjayB0byBJRExFIHN0YXRlJyk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gX2Jhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIlN0YXRlXCJdLklETEU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBicmVhaztcbiAgICB9IC8vIGNoZWNrIGJ1ZmZlclxuICAgIC8vIGNoZWNrL3VwZGF0ZSBjdXJyZW50IGZyYWdtZW50XG5cblxuICAgIHRoaXMub25UaWNrRW5kKCk7XG4gIH07XG5cbiAgX3Byb3RvLm9uVGlja0VuZCA9IGZ1bmN0aW9uIG9uVGlja0VuZCgpIHtcbiAgICBfQmFzZVN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLm9uVGlja0VuZC5jYWxsKHRoaXMpO1xuXG4gICAgdGhpcy5jaGVja0J1ZmZlcigpO1xuICAgIHRoaXMuY2hlY2tGcmFnbWVudENoYW5nZWQoKTtcbiAgfTtcblxuICBfcHJvdG8uZG9UaWNrSWRsZSA9IGZ1bmN0aW9uIGRvVGlja0lkbGUoKSB7XG4gICAgdmFyIF9mcmFnJGRlY3J5cHRkYXRhLCBfZnJhZyRkZWNyeXB0ZGF0YTI7XG5cbiAgICB2YXIgaGxzID0gdGhpcy5obHMsXG4gICAgICAgIGxldmVsTGFzdExvYWRlZCA9IHRoaXMubGV2ZWxMYXN0TG9hZGVkLFxuICAgICAgICBsZXZlbHMgPSB0aGlzLmxldmVscyxcbiAgICAgICAgbWVkaWEgPSB0aGlzLm1lZGlhO1xuICAgIHZhciBjb25maWcgPSBobHMuY29uZmlnLFxuICAgICAgICBsZXZlbCA9IGhscy5uZXh0TG9hZExldmVsOyAvLyBpZiBzdGFydCBsZXZlbCBub3QgcGFyc2VkIHlldCBPUlxuICAgIC8vIGlmIHZpZGVvIG5vdCBhdHRhY2hlZCBBTkQgc3RhcnQgZnJhZ21lbnQgYWxyZWFkeSByZXF1ZXN0ZWQgT1Igc3RhcnQgZnJhZyBwcmVmZXRjaCBub3QgZW5hYmxlZFxuICAgIC8vIGV4aXQgbG9vcCwgYXMgd2UgZWl0aGVyIG5lZWQgbW9yZSBpbmZvIChsZXZlbCBub3QgcGFyc2VkKSBvciB3ZSBuZWVkIG1lZGlhIHRvIGJlIGF0dGFjaGVkIHRvIGxvYWQgbmV3IGZyYWdtZW50XG5cbiAgICBpZiAobGV2ZWxMYXN0TG9hZGVkID09PSBudWxsIHx8ICFtZWRpYSAmJiAodGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgfHwgIWNvbmZpZy5zdGFydEZyYWdQcmVmZXRjaCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIElmIHRoZSBcIm1haW5cIiBsZXZlbCBpcyBhdWRpby1vbmx5IGJ1dCB3ZSBhcmUgbG9hZGluZyBhbiBhbHRlcm5hdGUgdHJhY2sgaW4gdGhlIHNhbWUgZ3JvdXAsIGRvIG5vdCBsb2FkIGFueXRoaW5nXG5cblxuICAgIGlmICh0aGlzLmFsdEF1ZGlvICYmIHRoaXMuYXVkaW9Pbmx5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCFsZXZlbHMgfHwgIWxldmVsc1tsZXZlbF0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbGV2ZWxJbmZvID0gbGV2ZWxzW2xldmVsXTsgLy8gaWYgYnVmZmVyIGxlbmd0aCBpcyBsZXNzIHRoYW4gbWF4QnVmTGVuIHRyeSB0byBsb2FkIGEgbmV3IGZyYWdtZW50XG4gICAgLy8gc2V0IG5leHQgbG9hZCBsZXZlbCA6IHRoaXMgd2lsbCB0cmlnZ2VyIGEgcGxheWxpc3QgbG9hZCBpZiBuZWVkZWRcblxuICAgIHRoaXMubGV2ZWwgPSBobHMubmV4dExvYWRMZXZlbCA9IGxldmVsO1xuICAgIHZhciBsZXZlbERldGFpbHMgPSBsZXZlbEluZm8uZGV0YWlsczsgLy8gaWYgbGV2ZWwgaW5mbyBub3QgcmV0cmlldmVkIHlldCwgc3dpdGNoIHN0YXRlIGFuZCB3YWl0IGZvciBsZXZlbCByZXRyaWV2YWxcbiAgICAvLyBpZiBsaXZlIHBsYXlsaXN0LCBlbnN1cmUgdGhhdCBuZXcgcGxheWxpc3QgaGFzIGJlZW4gcmVmcmVzaGVkIHRvIGF2b2lkIGxvYWRpbmcvdHJ5IHRvIGxvYWRcbiAgICAvLyBhIHVzZWxlc3MgYW5kIG91dGRhdGVkIGZyYWdtZW50ICh0aGF0IG1pZ2h0IGV2ZW4gaW50cm9kdWNlIGxvYWQgZXJyb3IgaWYgaXQgaXMgYWxyZWFkeSBvdXQgb2YgdGhlIGxpdmUgcGxheWxpc3QpXG5cbiAgICBpZiAoIWxldmVsRGV0YWlscyB8fCB0aGlzLnN0YXRlID09PSBfYmFzZV9zdHJlYW1fY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiU3RhdGVcIl0uV0FJVElOR19MRVZFTCB8fCBsZXZlbERldGFpbHMubGl2ZSAmJiB0aGlzLmxldmVsTGFzdExvYWRlZCAhPT0gbGV2ZWwpIHtcbiAgICAgIHRoaXMuc3RhdGUgPSBfYmFzZV9zdHJlYW1fY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiU3RhdGVcIl0uV0FJVElOR19MRVZFTDtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgYnVmZmVySW5mbyA9IHRoaXMuZ2V0RndkQnVmZmVySW5mbyh0aGlzLm1lZGlhQnVmZmVyID8gdGhpcy5tZWRpYUJ1ZmZlciA6IG1lZGlhLCBfdHlwZXNfbG9hZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXCJQbGF5bGlzdExldmVsVHlwZVwiXS5NQUlOKTtcblxuICAgIGlmIChidWZmZXJJbmZvID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGJ1ZmZlckxlbiA9IGJ1ZmZlckluZm8ubGVuOyAvLyBjb21wdXRlIG1heCBCdWZmZXIgTGVuZ3RoIHRoYXQgd2UgY291bGQgZ2V0IGZyb20gdGhpcyBsb2FkIGxldmVsLCBiYXNlZCBvbiBsZXZlbCBiaXRyYXRlLiBkb24ndCBidWZmZXIgbW9yZSB0aGFuIDYwIE1CIGFuZCBtb3JlIHRoYW4gMzBzXG5cbiAgICB2YXIgbWF4QnVmTGVuID0gdGhpcy5nZXRNYXhCdWZmZXJMZW5ndGgobGV2ZWxJbmZvLm1heEJpdHJhdGUpOyAvLyBTdGF5IGlkbGUgaWYgd2UgYXJlIHN0aWxsIHdpdGggYnVmZmVyIG1hcmdpbnNcblxuICAgIGlmIChidWZmZXJMZW4gPj0gbWF4QnVmTGVuKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3N0cmVhbUVuZGVkKGJ1ZmZlckluZm8sIGxldmVsRGV0YWlscykpIHtcbiAgICAgIHZhciBkYXRhID0ge307XG5cbiAgICAgIGlmICh0aGlzLmFsdEF1ZGlvKSB7XG4gICAgICAgIGRhdGEudHlwZSA9ICd2aWRlbyc7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiRXZlbnRzXCJdLkJVRkZFUl9FT1MsIGRhdGEpO1xuICAgICAgdGhpcy5zdGF0ZSA9IF9iYXNlX3N0cmVhbV9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJTdGF0ZVwiXS5FTkRFRDtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgdGFyZ2V0QnVmZmVyVGltZSA9IGJ1ZmZlckluZm8uZW5kO1xuICAgIHZhciBmcmFnID0gdGhpcy5nZXROZXh0RnJhZ21lbnQodGFyZ2V0QnVmZmVyVGltZSwgbGV2ZWxEZXRhaWxzKTsgLy8gQXZvaWQgYmFja3RyYWNraW5nIGFmdGVyIHNlZWtpbmcgb3Igc3dpdGNoaW5nIGJ5IGxvYWRpbmcgYW4gZWFybGllciBzZWdtZW50IGluIHN0cmVhbXMgdGhhdCBjb3VsZCBiYWNrdHJhY2tcblxuICAgIGlmICh0aGlzLmNvdWxkQmFja3RyYWNrICYmICF0aGlzLmZyYWdQcmV2aW91cyAmJiBmcmFnICYmIGZyYWcuc24gIT09ICdpbml0U2VnbWVudCcpIHtcbiAgICAgIHZhciBmcmFnSWR4ID0gZnJhZy5zbiAtIGxldmVsRGV0YWlscy5zdGFydFNOO1xuXG4gICAgICBpZiAoZnJhZ0lkeCA+IDEpIHtcbiAgICAgICAgZnJhZyA9IGxldmVsRGV0YWlscy5mcmFnbWVudHNbZnJhZ0lkeCAtIDFdO1xuICAgICAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5yZW1vdmVGcmFnbWVudChmcmFnKTtcbiAgICAgIH1cbiAgICB9IC8vIEF2b2lkIGxvb3AgbG9hZGluZyBieSB1c2luZyBuZXh0TG9hZFBvc2l0aW9uIHNldCBmb3IgYmFja3RyYWNraW5nXG5cblxuICAgIGlmIChmcmFnICYmIHRoaXMuZnJhZ21lbnRUcmFja2VyLmdldFN0YXRlKGZyYWcpID09PSBfZnJhZ21lbnRfdHJhY2tlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1wiRnJhZ21lbnRTdGF0ZVwiXS5PSyAmJiB0aGlzLm5leHRMb2FkUG9zaXRpb24gPiB0YXJnZXRCdWZmZXJUaW1lKSB7XG4gICAgICAvLyBDbGVhbnVwIHRoZSBmcmFnbWVudCB0cmFja2VyIGJlZm9yZSB0cnlpbmcgdG8gZmluZCB0aGUgbmV4dCB1bmJ1ZmZlcmVkIGZyYWdtZW50XG4gICAgICB2YXIgdHlwZSA9IHRoaXMuYXVkaW9Pbmx5ICYmICF0aGlzLmFsdEF1ZGlvID8gX2xvYWRlcl9mcmFnbWVudF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fW1wiRWxlbWVudGFyeVN0cmVhbVR5cGVzXCJdLkFVRElPIDogX2xvYWRlcl9mcmFnbWVudF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fW1wiRWxlbWVudGFyeVN0cmVhbVR5cGVzXCJdLlZJREVPO1xuICAgICAgdGhpcy5hZnRlckJ1ZmZlckZsdXNoZWQobWVkaWEsIHR5cGUsIF90eXBlc19sb2FkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcIlBsYXlsaXN0TGV2ZWxUeXBlXCJdLk1BSU4pO1xuICAgICAgZnJhZyA9IHRoaXMuZ2V0TmV4dEZyYWdtZW50KHRoaXMubmV4dExvYWRQb3NpdGlvbiwgbGV2ZWxEZXRhaWxzKTtcbiAgICB9XG5cbiAgICBpZiAoIWZyYWcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZnJhZy5pbml0U2VnbWVudCAmJiAhZnJhZy5pbml0U2VnbWVudC5kYXRhICYmICF0aGlzLmJpdHJhdGVUZXN0KSB7XG4gICAgICBmcmFnID0gZnJhZy5pbml0U2VnbWVudDtcbiAgICB9IC8vIFdlIHdhbnQgdG8gbG9hZCB0aGUga2V5IGlmIHdlJ3JlIGRlYWxpbmcgd2l0aCBhbiBpZGVudGl0eSBrZXksIGJlY2F1c2Ugd2Ugd2lsbCBkZWNyeXB0XG4gICAgLy8gdGhpcyBjb250ZW50IHVzaW5nIHRoZSBrZXkgd2UgZmV0Y2guIE90aGVyIGtleXMgd2lsbCBiZSBoYW5kbGVkIGJ5IHRoZSBEUk0gQ0RNIHZpYSBFTUUuXG5cblxuICAgIGlmICgoKF9mcmFnJGRlY3J5cHRkYXRhID0gZnJhZy5kZWNyeXB0ZGF0YSkgPT09IG51bGwgfHwgX2ZyYWckZGVjcnlwdGRhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9mcmFnJGRlY3J5cHRkYXRhLmtleUZvcm1hdCkgPT09ICdpZGVudGl0eScgJiYgISgoX2ZyYWckZGVjcnlwdGRhdGEyID0gZnJhZy5kZWNyeXB0ZGF0YSkgIT09IG51bGwgJiYgX2ZyYWckZGVjcnlwdGRhdGEyICE9PSB2b2lkIDAgJiYgX2ZyYWckZGVjcnlwdGRhdGEyLmtleSkpIHtcbiAgICAgIHRoaXMubG9hZEtleShmcmFnLCBsZXZlbERldGFpbHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmxvYWRGcmFnbWVudChmcmFnLCBsZXZlbERldGFpbHMsIHRhcmdldEJ1ZmZlclRpbWUpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8ubG9hZEZyYWdtZW50ID0gZnVuY3Rpb24gbG9hZEZyYWdtZW50KGZyYWcsIGxldmVsRGV0YWlscywgdGFyZ2V0QnVmZmVyVGltZSkge1xuICAgIHZhciBfdGhpcyRtZWRpYTI7XG5cbiAgICAvLyBDaGVjayBpZiBmcmFnbWVudCBpcyBub3QgbG9hZGVkXG4gICAgdmFyIGZyYWdTdGF0ZSA9IHRoaXMuZnJhZ21lbnRUcmFja2VyLmdldFN0YXRlKGZyYWcpO1xuICAgIHRoaXMuZnJhZ0N1cnJlbnQgPSBmcmFnOyAvLyBVc2UgZGF0YSBmcm9tIGxvYWRlZCBiYWNrdHJhY2tlZCBmcmFnbWVudCBpZiBhdmFpbGFibGVcblxuICAgIGlmIChmcmFnU3RhdGUgPT09IF9mcmFnbWVudF90cmFja2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXCJGcmFnbWVudFN0YXRlXCJdLkJBQ0tUUkFDS0VEKSB7XG4gICAgICB2YXIgZGF0YSA9IHRoaXMuZnJhZ21lbnRUcmFja2VyLmdldEJhY2t0cmFja0RhdGEoZnJhZyk7XG5cbiAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgIHRoaXMuX2hhbmRsZUZyYWdtZW50TG9hZFByb2dyZXNzKGRhdGEpO1xuXG4gICAgICAgIHRoaXMuX2hhbmRsZUZyYWdtZW50TG9hZENvbXBsZXRlKGRhdGEpO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZyYWdTdGF0ZSA9IF9mcmFnbWVudF90cmFja2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXCJGcmFnbWVudFN0YXRlXCJdLk5PVF9MT0FERUQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGZyYWdTdGF0ZSA9PT0gX2ZyYWdtZW50X3RyYWNrZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcIkZyYWdtZW50U3RhdGVcIl0uTk9UX0xPQURFRCB8fCBmcmFnU3RhdGUgPT09IF9mcmFnbWVudF90cmFja2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXCJGcmFnbWVudFN0YXRlXCJdLlBBUlRJQUwpIHtcbiAgICAgIGlmIChmcmFnLnNuID09PSAnaW5pdFNlZ21lbnQnKSB7XG4gICAgICAgIHRoaXMuX2xvYWRJbml0U2VnbWVudChmcmFnKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5iaXRyYXRlVGVzdCkge1xuICAgICAgICBmcmFnLmJpdHJhdGVUZXN0ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5sb2coXCJGcmFnbWVudCBcIiArIGZyYWcuc24gKyBcIiBvZiBsZXZlbCBcIiArIGZyYWcubGV2ZWwgKyBcIiBpcyBiZWluZyBkb3dubG9hZGVkIHRvIHRlc3QgYml0cmF0ZSBhbmQgd2lsbCBub3QgYmUgYnVmZmVyZWRcIik7XG5cbiAgICAgICAgdGhpcy5fbG9hZEJpdHJhdGVUZXN0RnJhZyhmcmFnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkID0gdHJ1ZTtcblxuICAgICAgICBfQmFzZVN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLmxvYWRGcmFnbWVudC5jYWxsKHRoaXMsIGZyYWcsIGxldmVsRGV0YWlscywgdGFyZ2V0QnVmZmVyVGltZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChmcmFnU3RhdGUgPT09IF9mcmFnbWVudF90cmFja2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXCJGcmFnbWVudFN0YXRlXCJdLkFQUEVORElORykge1xuICAgICAgLy8gTG93ZXIgdGhlIGJ1ZmZlciBzaXplIGFuZCB0cnkgYWdhaW5cbiAgICAgIGlmICh0aGlzLnJlZHVjZU1heEJ1ZmZlckxlbmd0aChmcmFnLmR1cmF0aW9uKSkge1xuICAgICAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5yZW1vdmVGcmFnbWVudChmcmFnKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCgoX3RoaXMkbWVkaWEyID0gdGhpcy5tZWRpYSkgPT09IG51bGwgfHwgX3RoaXMkbWVkaWEyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpcyRtZWRpYTIuYnVmZmVyZWQubGVuZ3RoKSA9PT0gMCkge1xuICAgICAgLy8gU3RvcCBnYXAgZm9yIGJhZCB0cmFja2VyIC8gYnVmZmVyIGZsdXNoIGJlaGF2aW9yXG4gICAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5yZW1vdmVBbGxGcmFnbWVudHMoKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmdldEFwcGVuZGVkRnJhZyA9IGZ1bmN0aW9uIGdldEFwcGVuZGVkRnJhZyhwb3NpdGlvbikge1xuICAgIHZhciBmcmFnT3JQYXJ0ID0gdGhpcy5mcmFnbWVudFRyYWNrZXIuZ2V0QXBwZW5kZWRGcmFnKHBvc2l0aW9uLCBfdHlwZXNfbG9hZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXCJQbGF5bGlzdExldmVsVHlwZVwiXS5NQUlOKTtcblxuICAgIGlmIChmcmFnT3JQYXJ0ICYmICdmcmFnbWVudCcgaW4gZnJhZ09yUGFydCkge1xuICAgICAgcmV0dXJuIGZyYWdPclBhcnQuZnJhZ21lbnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZyYWdPclBhcnQ7XG4gIH07XG5cbiAgX3Byb3RvLmdldEJ1ZmZlcmVkRnJhZyA9IGZ1bmN0aW9uIGdldEJ1ZmZlcmVkRnJhZyhwb3NpdGlvbikge1xuICAgIHJldHVybiB0aGlzLmZyYWdtZW50VHJhY2tlci5nZXRCdWZmZXJlZEZyYWcocG9zaXRpb24sIF90eXBlc19sb2FkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcIlBsYXlsaXN0TGV2ZWxUeXBlXCJdLk1BSU4pO1xuICB9O1xuXG4gIF9wcm90by5mb2xsb3dpbmdCdWZmZXJlZEZyYWcgPSBmdW5jdGlvbiBmb2xsb3dpbmdCdWZmZXJlZEZyYWcoZnJhZykge1xuICAgIGlmIChmcmFnKSB7XG4gICAgICAvLyB0cnkgdG8gZ2V0IHJhbmdlIG9mIG5leHQgZnJhZ21lbnQgKDUwMG1zIGFmdGVyIHRoaXMgcmFuZ2UpXG4gICAgICByZXR1cm4gdGhpcy5nZXRCdWZmZXJlZEZyYWcoZnJhZy5lbmQgKyAwLjUpO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIC8qXG4gICAgb24gaW1tZWRpYXRlIGxldmVsIHN3aXRjaCA6XG4gICAgIC0gcGF1c2UgcGxheWJhY2sgaWYgcGxheWluZ1xuICAgICAtIGNhbmNlbCBhbnkgcGVuZGluZyBsb2FkIHJlcXVlc3RcbiAgICAgLSBhbmQgdHJpZ2dlciBhIGJ1ZmZlciBmbHVzaFxuICAqL1xuICA7XG5cbiAgX3Byb3RvLmltbWVkaWF0ZUxldmVsU3dpdGNoID0gZnVuY3Rpb24gaW1tZWRpYXRlTGV2ZWxTd2l0Y2goKSB7XG4gICAgdGhpcy5hYm9ydEN1cnJlbnRGcmFnKCk7XG4gICAgdGhpcy5mbHVzaE1haW5CdWZmZXIoMCwgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKTtcbiAgfVxuICAvKipcbiAgICogdHJ5IHRvIHN3aXRjaCBBU0FQIHdpdGhvdXQgYnJlYWtpbmcgdmlkZW8gcGxheWJhY2s6XG4gICAqIGluIG9yZGVyIHRvIGVuc3VyZSBzbW9vdGggYnV0IHF1aWNrIGxldmVsIHN3aXRjaGluZyxcbiAgICogd2UgbmVlZCB0byBmaW5kIHRoZSBuZXh0IGZsdXNoYWJsZSBidWZmZXIgcmFuZ2VcbiAgICogd2Ugc2hvdWxkIHRha2UgaW50byBhY2NvdW50IG5ldyBzZWdtZW50IGZldGNoIHRpbWVcbiAgICovXG4gIDtcblxuICBfcHJvdG8ubmV4dExldmVsU3dpdGNoID0gZnVuY3Rpb24gbmV4dExldmVsU3dpdGNoKCkge1xuICAgIHZhciBsZXZlbHMgPSB0aGlzLmxldmVscyxcbiAgICAgICAgbWVkaWEgPSB0aGlzLm1lZGlhOyAvLyBlbnN1cmUgdGhhdCBtZWRpYSBpcyBkZWZpbmVkIGFuZCB0aGF0IG1ldGFkYXRhIGFyZSBhdmFpbGFibGUgKHRvIHJldHJpZXZlIGN1cnJlbnRUaW1lKVxuXG4gICAgaWYgKG1lZGlhICE9PSBudWxsICYmIG1lZGlhICE9PSB2b2lkIDAgJiYgbWVkaWEucmVhZHlTdGF0ZSkge1xuICAgICAgdmFyIGZldGNoZGVsYXk7XG4gICAgICB2YXIgZnJhZ1BsYXlpbmdDdXJyZW50ID0gdGhpcy5nZXRBcHBlbmRlZEZyYWcobWVkaWEuY3VycmVudFRpbWUpO1xuXG4gICAgICBpZiAoZnJhZ1BsYXlpbmdDdXJyZW50ICYmIGZyYWdQbGF5aW5nQ3VycmVudC5zdGFydCA+IDEpIHtcbiAgICAgICAgLy8gZmx1c2ggYnVmZmVyIHByZWNlZGluZyBjdXJyZW50IGZyYWdtZW50IChmbHVzaCB1bnRpbCBjdXJyZW50IGZyYWdtZW50IHN0YXJ0IG9mZnNldClcbiAgICAgICAgLy8gbWludXMgMXMgdG8gYXZvaWQgdmlkZW8gZnJlZXppbmcsIHRoYXQgY291bGQgaGFwcGVuIGlmIHdlIGZsdXNoIGtleWZyYW1lIG9mIGN1cnJlbnQgdmlkZW8gLi4uXG4gICAgICAgIHRoaXMuZmx1c2hNYWluQnVmZmVyKDAsIGZyYWdQbGF5aW5nQ3VycmVudC5zdGFydCAtIDEpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIW1lZGlhLnBhdXNlZCAmJiBsZXZlbHMpIHtcbiAgICAgICAgLy8gYWRkIGEgc2FmZXR5IGRlbGF5IG9mIDFzXG4gICAgICAgIHZhciBuZXh0TGV2ZWxJZCA9IHRoaXMuaGxzLm5leHRMb2FkTGV2ZWw7XG4gICAgICAgIHZhciBuZXh0TGV2ZWwgPSBsZXZlbHNbbmV4dExldmVsSWRdO1xuICAgICAgICB2YXIgZnJhZ0xhc3RLYnBzID0gdGhpcy5mcmFnTGFzdEticHM7XG5cbiAgICAgICAgaWYgKGZyYWdMYXN0S2JwcyAmJiB0aGlzLmZyYWdDdXJyZW50KSB7XG4gICAgICAgICAgZmV0Y2hkZWxheSA9IHRoaXMuZnJhZ0N1cnJlbnQuZHVyYXRpb24gKiBuZXh0TGV2ZWwubWF4Qml0cmF0ZSAvICgxMDAwICogZnJhZ0xhc3RLYnBzKSArIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZmV0Y2hkZWxheSA9IDA7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZldGNoZGVsYXkgPSAwO1xuICAgICAgfSAvLyB0aGlzLmxvZygnZmV0Y2hkZWxheTonK2ZldGNoZGVsYXkpO1xuICAgICAgLy8gZmluZCBidWZmZXIgcmFuZ2UgdGhhdCB3aWxsIGJlIHJlYWNoZWQgb25jZSBuZXcgZnJhZ21lbnQgd2lsbCBiZSBmZXRjaGVkXG5cblxuICAgICAgdmFyIGJ1ZmZlcmVkRnJhZyA9IHRoaXMuZ2V0QnVmZmVyZWRGcmFnKG1lZGlhLmN1cnJlbnRUaW1lICsgZmV0Y2hkZWxheSk7XG5cbiAgICAgIGlmIChidWZmZXJlZEZyYWcpIHtcbiAgICAgICAgLy8gd2UgY2FuIGZsdXNoIGJ1ZmZlciByYW5nZSBmb2xsb3dpbmcgdGhpcyBvbmUgd2l0aG91dCBzdGFsbGluZyBwbGF5YmFja1xuICAgICAgICB2YXIgbmV4dEJ1ZmZlcmVkRnJhZyA9IHRoaXMuZm9sbG93aW5nQnVmZmVyZWRGcmFnKGJ1ZmZlcmVkRnJhZyk7XG5cbiAgICAgICAgaWYgKG5leHRCdWZmZXJlZEZyYWcpIHtcbiAgICAgICAgICAvLyBpZiB3ZSBhcmUgaGVyZSwgd2UgY2FuIGFsc28gY2FuY2VsIGFueSBsb2FkaW5nL2RlbXV4aW5nIGluIHByb2dyZXNzLCBhcyB0aGV5IGFyZSB1c2VsZXNzXG4gICAgICAgICAgdGhpcy5hYm9ydEN1cnJlbnRGcmFnKCk7IC8vIHN0YXJ0IGZsdXNoIHBvc2l0aW9uIGlzIGluIG5leHQgYnVmZmVyZWQgZnJhZy4gTGVhdmUgc29tZSBwYWRkaW5nIGZvciBub24taW5kZXBlbmRlbnQgc2VnbWVudHMgYW5kIHNtb290aGVyIHBsYXliYWNrLlxuXG4gICAgICAgICAgdmFyIG1heFN0YXJ0ID0gbmV4dEJ1ZmZlcmVkRnJhZy5tYXhTdGFydFBUUyA/IG5leHRCdWZmZXJlZEZyYWcubWF4U3RhcnRQVFMgOiBuZXh0QnVmZmVyZWRGcmFnLnN0YXJ0O1xuICAgICAgICAgIHZhciBmcmFnRHVyYXRpb24gPSBuZXh0QnVmZmVyZWRGcmFnLmR1cmF0aW9uO1xuICAgICAgICAgIHZhciBzdGFydFB0cyA9IE1hdGgubWF4KGJ1ZmZlcmVkRnJhZy5lbmQsIG1heFN0YXJ0ICsgTWF0aC5taW4oTWF0aC5tYXgoZnJhZ0R1cmF0aW9uIC0gdGhpcy5jb25maWcubWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSwgZnJhZ0R1cmF0aW9uICogMC41KSwgZnJhZ0R1cmF0aW9uICogMC43NSkpO1xuICAgICAgICAgIHRoaXMuZmx1c2hNYWluQnVmZmVyKHN0YXJ0UHRzLCBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5hYm9ydEN1cnJlbnRGcmFnID0gZnVuY3Rpb24gYWJvcnRDdXJyZW50RnJhZygpIHtcbiAgICB2YXIgZnJhZ0N1cnJlbnQgPSB0aGlzLmZyYWdDdXJyZW50O1xuICAgIHRoaXMuZnJhZ0N1cnJlbnQgPSBudWxsO1xuXG4gICAgaWYgKGZyYWdDdXJyZW50ICE9PSBudWxsICYmIGZyYWdDdXJyZW50ICE9PSB2b2lkIDAgJiYgZnJhZ0N1cnJlbnQubG9hZGVyKSB7XG4gICAgICBmcmFnQ3VycmVudC5sb2FkZXIuYWJvcnQoKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gX2Jhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIlN0YXRlXCJdLktFWV9MT0FESU5HKSB7XG4gICAgICB0aGlzLnN0YXRlID0gX2Jhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIlN0YXRlXCJdLklETEU7XG4gICAgfVxuXG4gICAgdGhpcy5uZXh0TG9hZFBvc2l0aW9uID0gdGhpcy5nZXRMb2FkUG9zaXRpb24oKTtcbiAgfTtcblxuICBfcHJvdG8uZmx1c2hNYWluQnVmZmVyID0gZnVuY3Rpb24gZmx1c2hNYWluQnVmZmVyKHN0YXJ0T2Zmc2V0LCBlbmRPZmZzZXQpIHtcbiAgICBfQmFzZVN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLmZsdXNoTWFpbkJ1ZmZlci5jYWxsKHRoaXMsIHN0YXJ0T2Zmc2V0LCBlbmRPZmZzZXQsIHRoaXMuYWx0QXVkaW8gPyAndmlkZW8nIDogbnVsbCk7XG4gIH07XG5cbiAgX3Byb3RvLm9uTWVkaWFBdHRhY2hlZCA9IGZ1bmN0aW9uIG9uTWVkaWFBdHRhY2hlZChldmVudCwgZGF0YSkge1xuICAgIF9CYXNlU3RyZWFtQ29udHJvbGxlci5wcm90b3R5cGUub25NZWRpYUF0dGFjaGVkLmNhbGwodGhpcywgZXZlbnQsIGRhdGEpO1xuXG4gICAgdmFyIG1lZGlhID0gZGF0YS5tZWRpYTtcbiAgICB0aGlzLm9udnBsYXlpbmcgPSB0aGlzLm9uTWVkaWFQbGF5aW5nLmJpbmQodGhpcyk7XG4gICAgdGhpcy5vbnZzZWVrZWQgPSB0aGlzLm9uTWVkaWFTZWVrZWQuYmluZCh0aGlzKTtcbiAgICBtZWRpYS5hZGRFdmVudExpc3RlbmVyKCdwbGF5aW5nJywgdGhpcy5vbnZwbGF5aW5nKTtcbiAgICBtZWRpYS5hZGRFdmVudExpc3RlbmVyKCdzZWVrZWQnLCB0aGlzLm9udnNlZWtlZCk7XG4gICAgdGhpcy5nYXBDb250cm9sbGVyID0gbmV3IF9nYXBfY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTBfX1tcImRlZmF1bHRcIl0odGhpcy5jb25maWcsIG1lZGlhLCB0aGlzLmZyYWdtZW50VHJhY2tlciwgdGhpcy5obHMpO1xuICB9O1xuXG4gIF9wcm90by5vbk1lZGlhRGV0YWNoaW5nID0gZnVuY3Rpb24gb25NZWRpYURldGFjaGluZygpIHtcbiAgICB2YXIgbWVkaWEgPSB0aGlzLm1lZGlhO1xuXG4gICAgaWYgKG1lZGlhKSB7XG4gICAgICBtZWRpYS5yZW1vdmVFdmVudExpc3RlbmVyKCdwbGF5aW5nJywgdGhpcy5vbnZwbGF5aW5nKTtcbiAgICAgIG1lZGlhLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3NlZWtlZCcsIHRoaXMub252c2Vla2VkKTtcbiAgICAgIHRoaXMub252cGxheWluZyA9IHRoaXMub252c2Vla2VkID0gbnVsbDtcbiAgICAgIHRoaXMudmlkZW9CdWZmZXIgPSBudWxsO1xuICAgIH1cblxuICAgIHRoaXMuZnJhZ1BsYXlpbmcgPSBudWxsO1xuXG4gICAgaWYgKHRoaXMuZ2FwQ29udHJvbGxlcikge1xuICAgICAgdGhpcy5nYXBDb250cm9sbGVyLmRlc3Ryb3koKTtcbiAgICAgIHRoaXMuZ2FwQ29udHJvbGxlciA9IG51bGw7XG4gICAgfVxuXG4gICAgX0Jhc2VTdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZS5vbk1lZGlhRGV0YWNoaW5nLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgX3Byb3RvLm9uTWVkaWFQbGF5aW5nID0gZnVuY3Rpb24gb25NZWRpYVBsYXlpbmcoKSB7XG4gICAgLy8gdGljayB0byBzcGVlZCB1cCBGUkFHX0NIQU5HRUQgdHJpZ2dlcmluZ1xuICAgIHRoaXMudGljaygpO1xuICB9O1xuXG4gIF9wcm90by5vbk1lZGlhU2Vla2VkID0gZnVuY3Rpb24gb25NZWRpYVNlZWtlZCgpIHtcbiAgICB2YXIgbWVkaWEgPSB0aGlzLm1lZGlhO1xuICAgIHZhciBjdXJyZW50VGltZSA9IG1lZGlhID8gbWVkaWEuY3VycmVudFRpbWUgOiBudWxsO1xuXG4gICAgaWYgKE9iamVjdChfaG9tZV9ydW5uZXJfd29ya19obHNfanNfaGxzX2pzX3NyY19wb2x5ZmlsbHNfbnVtYmVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJpc0Zpbml0ZU51bWJlclwiXSkoY3VycmVudFRpbWUpKSB7XG4gICAgICB0aGlzLmxvZyhcIk1lZGlhIHNlZWtlZCB0byBcIiArIGN1cnJlbnRUaW1lLnRvRml4ZWQoMykpO1xuICAgIH0gLy8gdGljayB0byBzcGVlZCB1cCBGUkFHX0NIQU5HRUQgdHJpZ2dlcmluZ1xuXG5cbiAgICB0aGlzLnRpY2soKTtcbiAgfTtcblxuICBfcHJvdG8ub25NYW5pZmVzdExvYWRpbmcgPSBmdW5jdGlvbiBvbk1hbmlmZXN0TG9hZGluZygpIHtcbiAgICAvLyByZXNldCBidWZmZXIgb24gbWFuaWZlc3QgbG9hZGluZ1xuICAgIHRoaXMubG9nKCdUcmlnZ2VyIEJVRkZFUl9SRVNFVCcpO1xuICAgIHRoaXMuaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiRXZlbnRzXCJdLkJVRkZFUl9SRVNFVCwgdW5kZWZpbmVkKTtcbiAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5yZW1vdmVBbGxGcmFnbWVudHMoKTtcbiAgICB0aGlzLmNvdWxkQmFja3RyYWNrID0gdGhpcy5zdGFsbGVkID0gZmFsc2U7XG4gICAgdGhpcy5zdGFydFBvc2l0aW9uID0gdGhpcy5sYXN0Q3VycmVudFRpbWUgPSAwO1xuICAgIHRoaXMuZnJhZ1BsYXlpbmcgPSBudWxsO1xuICB9O1xuXG4gIF9wcm90by5vbk1hbmlmZXN0UGFyc2VkID0gZnVuY3Rpb24gb25NYW5pZmVzdFBhcnNlZChldmVudCwgZGF0YSkge1xuICAgIHZhciBhYWMgPSBmYWxzZTtcbiAgICB2YXIgaGVhYWMgPSBmYWxzZTtcbiAgICB2YXIgY29kZWM7XG4gICAgZGF0YS5sZXZlbHMuZm9yRWFjaChmdW5jdGlvbiAobGV2ZWwpIHtcbiAgICAgIC8vIGRldGVjdCBpZiB3ZSBoYXZlIGRpZmZlcmVudCBraW5kIG9mIGF1ZGlvIGNvZGVjcyB1c2VkIGFtb25nc3QgcGxheWxpc3RzXG4gICAgICBjb2RlYyA9IGxldmVsLmF1ZGlvQ29kZWM7XG5cbiAgICAgIGlmIChjb2RlYykge1xuICAgICAgICBpZiAoY29kZWMuaW5kZXhPZignbXA0YS40MC4yJykgIT09IC0xKSB7XG4gICAgICAgICAgYWFjID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb2RlYy5pbmRleE9mKCdtcDRhLjQwLjUnKSAhPT0gLTEpIHtcbiAgICAgICAgICBoZWFhYyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLmF1ZGlvQ29kZWNTd2l0Y2ggPSBhYWMgJiYgaGVhYWMgJiYgIU9iamVjdChfaXNfc3VwcG9ydGVkX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJjaGFuZ2VUeXBlU3VwcG9ydGVkXCJdKSgpO1xuXG4gICAgaWYgKHRoaXMuYXVkaW9Db2RlY1N3aXRjaCkge1xuICAgICAgdGhpcy5sb2coJ0JvdGggQUFDL0hFLUFBQyBhdWRpbyBmb3VuZCBpbiBsZXZlbHM7IGRlY2xhcmluZyBsZXZlbCBjb2RlYyBhcyBIRS1BQUMnKTtcbiAgICB9XG5cbiAgICB0aGlzLmxldmVscyA9IGRhdGEubGV2ZWxzO1xuICAgIHRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkID0gZmFsc2U7XG4gIH07XG5cbiAgX3Byb3RvLm9uTGV2ZWxMb2FkaW5nID0gZnVuY3Rpb24gb25MZXZlbExvYWRpbmcoZXZlbnQsIGRhdGEpIHtcbiAgICB2YXIgbGV2ZWxzID0gdGhpcy5sZXZlbHM7XG5cbiAgICBpZiAoIWxldmVscyB8fCB0aGlzLnN0YXRlICE9PSBfYmFzZV9zdHJlYW1fY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiU3RhdGVcIl0uSURMRSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBsZXZlbCA9IGxldmVsc1tkYXRhLmxldmVsXTtcblxuICAgIGlmICghbGV2ZWwuZGV0YWlscyB8fCBsZXZlbC5kZXRhaWxzLmxpdmUgJiYgdGhpcy5sZXZlbExhc3RMb2FkZWQgIT09IGRhdGEubGV2ZWwgfHwgdGhpcy53YWl0Rm9yQ2RuVHVuZUluKGxldmVsLmRldGFpbHMpKSB7XG4gICAgICB0aGlzLnN0YXRlID0gX2Jhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIlN0YXRlXCJdLldBSVRJTkdfTEVWRUw7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5vbkxldmVsTG9hZGVkID0gZnVuY3Rpb24gb25MZXZlbExvYWRlZChldmVudCwgZGF0YSkge1xuICAgIHZhciBfY3VyTGV2ZWwkZGV0YWlscztcblxuICAgIHZhciBsZXZlbHMgPSB0aGlzLmxldmVscztcbiAgICB2YXIgbmV3TGV2ZWxJZCA9IGRhdGEubGV2ZWw7XG4gICAgdmFyIG5ld0RldGFpbHMgPSBkYXRhLmRldGFpbHM7XG4gICAgdmFyIGR1cmF0aW9uID0gbmV3RGV0YWlscy50b3RhbGR1cmF0aW9uO1xuXG4gICAgaWYgKCFsZXZlbHMpIHtcbiAgICAgIHRoaXMud2FybihcIkxldmVscyB3ZXJlIHJlc2V0IHdoaWxlIGxvYWRpbmcgbGV2ZWwgXCIgKyBuZXdMZXZlbElkKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmxvZyhcIkxldmVsIFwiICsgbmV3TGV2ZWxJZCArIFwiIGxvYWRlZCBbXCIgKyBuZXdEZXRhaWxzLnN0YXJ0U04gKyBcIixcIiArIG5ld0RldGFpbHMuZW5kU04gKyBcIl0sIGNjIFtcIiArIG5ld0RldGFpbHMuc3RhcnRDQyArIFwiLCBcIiArIG5ld0RldGFpbHMuZW5kQ0MgKyBcIl0gZHVyYXRpb246XCIgKyBkdXJhdGlvbik7XG4gICAgdmFyIGZyYWdDdXJyZW50ID0gdGhpcy5mcmFnQ3VycmVudDtcblxuICAgIGlmIChmcmFnQ3VycmVudCAmJiAodGhpcy5zdGF0ZSA9PT0gX2Jhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIlN0YXRlXCJdLkZSQUdfTE9BRElORyB8fCB0aGlzLnN0YXRlID09PSBfYmFzZV9zdHJlYW1fY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiU3RhdGVcIl0uRlJBR19MT0FESU5HX1dBSVRJTkdfUkVUUlkpKSB7XG4gICAgICBpZiAoZnJhZ0N1cnJlbnQubGV2ZWwgIT09IGRhdGEubGV2ZWwgJiYgZnJhZ0N1cnJlbnQubG9hZGVyKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBfYmFzZV9zdHJlYW1fY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiU3RhdGVcIl0uSURMRTtcbiAgICAgICAgZnJhZ0N1cnJlbnQubG9hZGVyLmFib3J0KCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGN1ckxldmVsID0gbGV2ZWxzW25ld0xldmVsSWRdO1xuICAgIHZhciBzbGlkaW5nID0gMDtcblxuICAgIGlmIChuZXdEZXRhaWxzLmxpdmUgfHwgKF9jdXJMZXZlbCRkZXRhaWxzID0gY3VyTGV2ZWwuZGV0YWlscykgIT09IG51bGwgJiYgX2N1ckxldmVsJGRldGFpbHMgIT09IHZvaWQgMCAmJiBfY3VyTGV2ZWwkZGV0YWlscy5saXZlKSB7XG4gICAgICBpZiAoIW5ld0RldGFpbHMuZnJhZ21lbnRzWzBdKSB7XG4gICAgICAgIG5ld0RldGFpbHMuZGVsdGFVcGRhdGVGYWlsZWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAobmV3RGV0YWlscy5kZWx0YVVwZGF0ZUZhaWxlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHNsaWRpbmcgPSB0aGlzLmFsaWduUGxheWxpc3RzKG5ld0RldGFpbHMsIGN1ckxldmVsLmRldGFpbHMpO1xuICAgIH0gLy8gb3ZlcnJpZGUgbGV2ZWwgaW5mb1xuXG5cbiAgICBjdXJMZXZlbC5kZXRhaWxzID0gbmV3RGV0YWlscztcbiAgICB0aGlzLmxldmVsTGFzdExvYWRlZCA9IG5ld0xldmVsSWQ7XG4gICAgdGhpcy5obHMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJFdmVudHNcIl0uTEVWRUxfVVBEQVRFRCwge1xuICAgICAgZGV0YWlsczogbmV3RGV0YWlscyxcbiAgICAgIGxldmVsOiBuZXdMZXZlbElkXG4gICAgfSk7IC8vIG9ubHkgc3dpdGNoIGJhY2sgdG8gSURMRSBzdGF0ZSBpZiB3ZSB3ZXJlIHdhaXRpbmcgZm9yIGxldmVsIHRvIHN0YXJ0IGRvd25sb2FkaW5nIGEgbmV3IGZyYWdtZW50XG5cbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gX2Jhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIlN0YXRlXCJdLldBSVRJTkdfTEVWRUwpIHtcbiAgICAgIGlmICh0aGlzLndhaXRGb3JDZG5UdW5lSW4obmV3RGV0YWlscykpIHtcbiAgICAgICAgLy8gV2FpdCBmb3IgTG93LUxhdGVuY3kgQ0ROIFR1bmUtaW5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnN0YXRlID0gX2Jhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIlN0YXRlXCJdLklETEU7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCkge1xuICAgICAgdGhpcy5zZXRTdGFydFBvc2l0aW9uKG5ld0RldGFpbHMsIHNsaWRpbmcpO1xuICAgIH0gZWxzZSBpZiAobmV3RGV0YWlscy5saXZlKSB7XG4gICAgICB0aGlzLnN5bmNocm9uaXplVG9MaXZlRWRnZShuZXdEZXRhaWxzKTtcbiAgICB9IC8vIHRyaWdnZXIgaGFuZGxlciByaWdodCBub3dcblxuXG4gICAgdGhpcy50aWNrKCk7XG4gIH07XG5cbiAgX3Byb3RvLl9oYW5kbGVGcmFnbWVudExvYWRQcm9ncmVzcyA9IGZ1bmN0aW9uIF9oYW5kbGVGcmFnbWVudExvYWRQcm9ncmVzcyhkYXRhKSB7XG4gICAgdmFyIF9mcmFnJGluaXRTZWdtZW50O1xuXG4gICAgdmFyIGZyYWcgPSBkYXRhLmZyYWcsXG4gICAgICAgIHBhcnQgPSBkYXRhLnBhcnQsXG4gICAgICAgIHBheWxvYWQgPSBkYXRhLnBheWxvYWQ7XG4gICAgdmFyIGxldmVscyA9IHRoaXMubGV2ZWxzO1xuXG4gICAgaWYgKCFsZXZlbHMpIHtcbiAgICAgIHRoaXMud2FybihcIkxldmVscyB3ZXJlIHJlc2V0IHdoaWxlIGZyYWdtZW50IGxvYWQgd2FzIGluIHByb2dyZXNzLiBGcmFnbWVudCBcIiArIGZyYWcuc24gKyBcIiBvZiBsZXZlbCBcIiArIGZyYWcubGV2ZWwgKyBcIiB3aWxsIG5vdCBiZSBidWZmZXJlZFwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgY3VycmVudExldmVsID0gbGV2ZWxzW2ZyYWcubGV2ZWxdO1xuICAgIHZhciBkZXRhaWxzID0gY3VycmVudExldmVsLmRldGFpbHM7XG5cbiAgICBpZiAoIWRldGFpbHMpIHtcbiAgICAgIHRoaXMud2FybihcIkRyb3BwaW5nIGZyYWdtZW50IFwiICsgZnJhZy5zbiArIFwiIG9mIGxldmVsIFwiICsgZnJhZy5sZXZlbCArIFwiIGFmdGVyIGxldmVsIGRldGFpbHMgd2VyZSByZXNldFwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgdmlkZW9Db2RlYyA9IGN1cnJlbnRMZXZlbC52aWRlb0NvZGVjOyAvLyB0aW1lIE9mZnNldCBpcyBhY2N1cmF0ZSBpZiBsZXZlbCBQVFMgaXMga25vd24sIG9yIGlmIHBsYXlsaXN0IGlzIG5vdCBzbGlkaW5nIChub3QgbGl2ZSlcblxuICAgIHZhciBhY2N1cmF0ZVRpbWVPZmZzZXQgPSBkZXRhaWxzLlBUU0tub3duIHx8ICFkZXRhaWxzLmxpdmU7XG4gICAgdmFyIGluaXRTZWdtZW50RGF0YSA9IChfZnJhZyRpbml0U2VnbWVudCA9IGZyYWcuaW5pdFNlZ21lbnQpID09PSBudWxsIHx8IF9mcmFnJGluaXRTZWdtZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZnJhZyRpbml0U2VnbWVudC5kYXRhO1xuXG4gICAgdmFyIGF1ZGlvQ29kZWMgPSB0aGlzLl9nZXRBdWRpb0NvZGVjKGN1cnJlbnRMZXZlbCk7IC8vIHRyYW5zbXV4IHRoZSBNUEVHLVRTIGRhdGEgdG8gSVNPLUJNRkYgc2VnbWVudHNcbiAgICAvLyB0aGlzLmxvZyhgVHJhbnNtdXhpbmcgJHtmcmFnLnNufSBvZiBbJHtkZXRhaWxzLnN0YXJ0U059ICwke2RldGFpbHMuZW5kU059XSxsZXZlbCAke2ZyYWcubGV2ZWx9LCBjYyAke2ZyYWcuY2N9YCk7XG5cblxuICAgIHZhciB0cmFuc211eGVyID0gdGhpcy50cmFuc211eGVyID0gdGhpcy50cmFuc211eGVyIHx8IG5ldyBfZGVtdXhfdHJhbnNtdXhlcl9pbnRlcmZhY2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzhfX1tcImRlZmF1bHRcIl0odGhpcy5obHMsIF90eXBlc19sb2FkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcIlBsYXlsaXN0TGV2ZWxUeXBlXCJdLk1BSU4sIHRoaXMuX2hhbmRsZVRyYW5zbXV4Q29tcGxldGUuYmluZCh0aGlzKSwgdGhpcy5faGFuZGxlVHJhbnNtdXhlckZsdXNoLmJpbmQodGhpcykpO1xuICAgIHZhciBwYXJ0SW5kZXggPSBwYXJ0ID8gcGFydC5pbmRleCA6IC0xO1xuICAgIHZhciBwYXJ0aWFsID0gcGFydEluZGV4ICE9PSAtMTtcbiAgICB2YXIgY2h1bmtNZXRhID0gbmV3IF90eXBlc190cmFuc211eGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV85X19bXCJDaHVua01ldGFkYXRhXCJdKGZyYWcubGV2ZWwsIGZyYWcuc24sIGZyYWcuc3RhdHMuY2h1bmtDb3VudCwgcGF5bG9hZC5ieXRlTGVuZ3RoLCBwYXJ0SW5kZXgsIHBhcnRpYWwpO1xuICAgIHZhciBpbml0UFRTID0gdGhpcy5pbml0UFRTW2ZyYWcuY2NdO1xuICAgIHRyYW5zbXV4ZXIucHVzaChwYXlsb2FkLCBpbml0U2VnbWVudERhdGEsIGF1ZGlvQ29kZWMsIHZpZGVvQ29kZWMsIGZyYWcsIHBhcnQsIGRldGFpbHMudG90YWxkdXJhdGlvbiwgYWNjdXJhdGVUaW1lT2Zmc2V0LCBjaHVua01ldGEsIGluaXRQVFMpO1xuICB9O1xuXG4gIF9wcm90by5vbkF1ZGlvVHJhY2tTd2l0Y2hpbmcgPSBmdW5jdGlvbiBvbkF1ZGlvVHJhY2tTd2l0Y2hpbmcoZXZlbnQsIGRhdGEpIHtcbiAgICAvLyBpZiBhbnkgVVJMIGZvdW5kIG9uIG5ldyBhdWRpbyB0cmFjaywgaXQgaXMgYW4gYWx0ZXJuYXRlIGF1ZGlvIHRyYWNrXG4gICAgdmFyIGZyb21BbHRBdWRpbyA9IHRoaXMuYWx0QXVkaW87XG4gICAgdmFyIGFsdEF1ZGlvID0gISFkYXRhLnVybDtcbiAgICB2YXIgdHJhY2tJZCA9IGRhdGEuaWQ7IC8vIGlmIHdlIHN3aXRjaCBvbiBtYWluIGF1ZGlvLCBlbnN1cmUgdGhhdCBtYWluIGZyYWdtZW50IHNjaGVkdWxpbmcgaXMgc3luY2VkIHdpdGggbWVkaWEuYnVmZmVyZWRcbiAgICAvLyBkb24ndCBkbyBhbnl0aGluZyBpZiB3ZSBzd2l0Y2ggdG8gYWx0IGF1ZGlvOiBhdWRpbyBzdHJlYW0gY29udHJvbGxlciBpcyBoYW5kbGluZyBpdC5cbiAgICAvLyB3ZSB3aWxsIGp1c3QgaGF2ZSB0byBjaGFuZ2UgYnVmZmVyIHNjaGVkdWxpbmcgb24gYXVkaW9UcmFja1N3aXRjaGVkXG5cbiAgICBpZiAoIWFsdEF1ZGlvKSB7XG4gICAgICBpZiAodGhpcy5tZWRpYUJ1ZmZlciAhPT0gdGhpcy5tZWRpYSkge1xuICAgICAgICB0aGlzLmxvZygnU3dpdGNoaW5nIG9uIG1haW4gYXVkaW8sIHVzZSBtZWRpYS5idWZmZXJlZCB0byBzY2hlZHVsZSBtYWluIGZyYWdtZW50IGxvYWRpbmcnKTtcbiAgICAgICAgdGhpcy5tZWRpYUJ1ZmZlciA9IHRoaXMubWVkaWE7XG4gICAgICAgIHZhciBmcmFnQ3VycmVudCA9IHRoaXMuZnJhZ0N1cnJlbnQ7IC8vIHdlIG5lZWQgdG8gcmVmaWxsIGF1ZGlvIGJ1ZmZlciBmcm9tIG1haW46IGNhbmNlbCBhbnkgZnJhZyBsb2FkaW5nIHRvIHNwZWVkIHVwIGF1ZGlvIHN3aXRjaFxuXG4gICAgICAgIGlmIChmcmFnQ3VycmVudCAhPT0gbnVsbCAmJiBmcmFnQ3VycmVudCAhPT0gdm9pZCAwICYmIGZyYWdDdXJyZW50LmxvYWRlcikge1xuICAgICAgICAgIHRoaXMubG9nKCdTd2l0Y2hpbmcgdG8gbWFpbiBhdWRpbyB0cmFjaywgY2FuY2VsIG1haW4gZnJhZ21lbnQgbG9hZCcpO1xuICAgICAgICAgIGZyYWdDdXJyZW50LmxvYWRlci5hYm9ydCgpO1xuICAgICAgICB9IC8vIGRlc3Ryb3kgdHJhbnNtdXhlciB0byBmb3JjZSBpbml0IHNlZ21lbnQgZ2VuZXJhdGlvbiAoZm9sbG93aW5nIGF1ZGlvIHN3aXRjaClcblxuXG4gICAgICAgIHRoaXMucmVzZXRUcmFuc211eGVyKCk7IC8vIHN3aXRjaCB0byBJRExFIHN0YXRlIHRvIGxvYWQgbmV3IGZyYWdtZW50XG5cbiAgICAgICAgdGhpcy5yZXNldExvYWRpbmdTdGF0ZSgpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmF1ZGlvT25seSkge1xuICAgICAgICAvLyBSZXNldCBhdWRpbyB0cmFuc211eGVyIHNvIHdoZW4gc3dpdGNoaW5nIGJhY2sgdG8gbWFpbiBhdWRpbyB3ZSdyZSBub3Qgc3RpbGwgYXBwZW5kaW5nIHdoZXJlIHdlIGxlZnQgb2ZmXG4gICAgICAgIHRoaXMucmVzZXRUcmFuc211eGVyKCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBobHMgPSB0aGlzLmhsczsgLy8gSWYgc3dpdGNoaW5nIGZyb20gYWx0IHRvIG1haW4gYXVkaW8sIGZsdXNoIGFsbCBhdWRpbyBhbmQgdHJpZ2dlciB0cmFjayBzd2l0Y2hlZFxuXG4gICAgICBpZiAoZnJvbUFsdEF1ZGlvKSB7XG4gICAgICAgIGhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcIkV2ZW50c1wiXS5CVUZGRVJfRkxVU0hJTkcsIHtcbiAgICAgICAgICBzdGFydE9mZnNldDogMCxcbiAgICAgICAgICBlbmRPZmZzZXQ6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSxcbiAgICAgICAgICB0eXBlOiAnYXVkaW8nXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBobHMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJFdmVudHNcIl0uQVVESU9fVFJBQ0tfU1dJVENIRUQsIHtcbiAgICAgICAgaWQ6IHRyYWNrSWRcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8ub25BdWRpb1RyYWNrU3dpdGNoZWQgPSBmdW5jdGlvbiBvbkF1ZGlvVHJhY2tTd2l0Y2hlZChldmVudCwgZGF0YSkge1xuICAgIHZhciB0cmFja0lkID0gZGF0YS5pZDtcbiAgICB2YXIgYWx0QXVkaW8gPSAhIXRoaXMuaGxzLmF1ZGlvVHJhY2tzW3RyYWNrSWRdLnVybDtcblxuICAgIGlmIChhbHRBdWRpbykge1xuICAgICAgdmFyIHZpZGVvQnVmZmVyID0gdGhpcy52aWRlb0J1ZmZlcjsgLy8gaWYgd2Ugc3dpdGNoZWQgb24gYWx0ZXJuYXRlIGF1ZGlvLCBlbnN1cmUgdGhhdCBtYWluIGZyYWdtZW50IHNjaGVkdWxpbmcgaXMgc3luY2VkIHdpdGggdmlkZW8gc291cmNlYnVmZmVyIGJ1ZmZlcmVkXG5cbiAgICAgIGlmICh2aWRlb0J1ZmZlciAmJiB0aGlzLm1lZGlhQnVmZmVyICE9PSB2aWRlb0J1ZmZlcikge1xuICAgICAgICB0aGlzLmxvZygnU3dpdGNoaW5nIG9uIGFsdGVybmF0ZSBhdWRpbywgdXNlIHZpZGVvLmJ1ZmZlcmVkIHRvIHNjaGVkdWxlIG1haW4gZnJhZ21lbnQgbG9hZGluZycpO1xuICAgICAgICB0aGlzLm1lZGlhQnVmZmVyID0gdmlkZW9CdWZmZXI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5hbHRBdWRpbyA9IGFsdEF1ZGlvO1xuICAgIHRoaXMudGljaygpO1xuICB9O1xuXG4gIF9wcm90by5vbkJ1ZmZlckNyZWF0ZWQgPSBmdW5jdGlvbiBvbkJ1ZmZlckNyZWF0ZWQoZXZlbnQsIGRhdGEpIHtcbiAgICB2YXIgdHJhY2tzID0gZGF0YS50cmFja3M7XG4gICAgdmFyIG1lZGlhVHJhY2s7XG4gICAgdmFyIG5hbWU7XG4gICAgdmFyIGFsdGVybmF0ZSA9IGZhbHNlO1xuXG4gICAgZm9yICh2YXIgdHlwZSBpbiB0cmFja3MpIHtcbiAgICAgIHZhciB0cmFjayA9IHRyYWNrc1t0eXBlXTtcblxuICAgICAgaWYgKHRyYWNrLmlkID09PSAnbWFpbicpIHtcbiAgICAgICAgbmFtZSA9IHR5cGU7XG4gICAgICAgIG1lZGlhVHJhY2sgPSB0cmFjazsgLy8ga2VlcCB2aWRlbyBzb3VyY2UgYnVmZmVyIHJlZmVyZW5jZVxuXG4gICAgICAgIGlmICh0eXBlID09PSAndmlkZW8nKSB7XG4gICAgICAgICAgdmFyIHZpZGVvVHJhY2sgPSB0cmFja3NbdHlwZV07XG5cbiAgICAgICAgICBpZiAodmlkZW9UcmFjaykge1xuICAgICAgICAgICAgdGhpcy52aWRlb0J1ZmZlciA9IHZpZGVvVHJhY2suYnVmZmVyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWx0ZXJuYXRlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoYWx0ZXJuYXRlICYmIG1lZGlhVHJhY2spIHtcbiAgICAgIHRoaXMubG9nKFwiQWx0ZXJuYXRlIHRyYWNrIGZvdW5kLCB1c2UgXCIgKyBuYW1lICsgXCIuYnVmZmVyZWQgdG8gc2NoZWR1bGUgbWFpbiBmcmFnbWVudCBsb2FkaW5nXCIpO1xuICAgICAgdGhpcy5tZWRpYUJ1ZmZlciA9IG1lZGlhVHJhY2suYnVmZmVyO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm1lZGlhQnVmZmVyID0gdGhpcy5tZWRpYTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLm9uRnJhZ0J1ZmZlcmVkID0gZnVuY3Rpb24gb25GcmFnQnVmZmVyZWQoZXZlbnQsIGRhdGEpIHtcbiAgICB2YXIgZnJhZyA9IGRhdGEuZnJhZyxcbiAgICAgICAgcGFydCA9IGRhdGEucGFydDtcblxuICAgIGlmIChmcmFnICYmIGZyYWcudHlwZSAhPT0gX3R5cGVzX2xvYWRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fW1wiUGxheWxpc3RMZXZlbFR5cGVcIl0uTUFJTikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmZyYWdDb250ZXh0Q2hhbmdlZChmcmFnKSkge1xuICAgICAgLy8gSWYgYSBsZXZlbCBzd2l0Y2ggd2FzIHJlcXVlc3RlZCB3aGlsZSBhIGZyYWdtZW50IHdhcyBidWZmZXJpbmcsIGl0IHdpbGwgZW1pdCB0aGUgRlJBR19CVUZGRVJFRCBldmVudCB1cG9uIGNvbXBsZXRpb25cbiAgICAgIC8vIEF2b2lkIHNldHRpbmcgc3RhdGUgYmFjayB0byBJRExFLCBzaW5jZSB0aGF0IHdpbGwgaW50ZXJmZXJlIHdpdGggYSBsZXZlbCBzd2l0Y2hcbiAgICAgIHRoaXMud2FybihcIkZyYWdtZW50IFwiICsgZnJhZy5zbiArIChwYXJ0ID8gJyBwOiAnICsgcGFydC5pbmRleCA6ICcnKSArIFwiIG9mIGxldmVsIFwiICsgZnJhZy5sZXZlbCArIFwiIGZpbmlzaGVkIGJ1ZmZlcmluZywgYnV0IHdhcyBhYm9ydGVkLiBzdGF0ZTogXCIgKyB0aGlzLnN0YXRlKTtcblxuICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IF9iYXNlX3N0cmVhbV9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJTdGF0ZVwiXS5QQVJTRUQpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IF9iYXNlX3N0cmVhbV9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJTdGF0ZVwiXS5JRExFO1xuICAgICAgfVxuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHN0YXRzID0gcGFydCA/IHBhcnQuc3RhdHMgOiBmcmFnLnN0YXRzO1xuICAgIHRoaXMuZnJhZ0xhc3RLYnBzID0gTWF0aC5yb3VuZCg4ICogc3RhdHMudG90YWwgLyAoc3RhdHMuYnVmZmVyaW5nLmVuZCAtIHN0YXRzLmxvYWRpbmcuZmlyc3QpKTtcblxuICAgIGlmIChmcmFnLnNuICE9PSAnaW5pdFNlZ21lbnQnKSB7XG4gICAgICB0aGlzLmZyYWdQcmV2aW91cyA9IGZyYWc7XG4gICAgfVxuXG4gICAgdGhpcy5mcmFnQnVmZmVyZWRDb21wbGV0ZShmcmFnLCBwYXJ0KTtcbiAgfTtcblxuICBfcHJvdG8ub25FcnJvciA9IGZ1bmN0aW9uIG9uRXJyb3IoZXZlbnQsIGRhdGEpIHtcbiAgICBzd2l0Y2ggKGRhdGEuZGV0YWlscykge1xuICAgICAgY2FzZSBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMV9fW1wiRXJyb3JEZXRhaWxzXCJdLkZSQUdfTE9BRF9FUlJPUjpcbiAgICAgIGNhc2UgX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTFfX1tcIkVycm9yRGV0YWlsc1wiXS5GUkFHX0xPQURfVElNRU9VVDpcbiAgICAgIGNhc2UgX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTFfX1tcIkVycm9yRGV0YWlsc1wiXS5LRVlfTE9BRF9FUlJPUjpcbiAgICAgIGNhc2UgX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTFfX1tcIkVycm9yRGV0YWlsc1wiXS5LRVlfTE9BRF9USU1FT1VUOlxuICAgICAgICB0aGlzLm9uRnJhZ21lbnRPcktleUxvYWRFcnJvcihfdHlwZXNfbG9hZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXCJQbGF5bGlzdExldmVsVHlwZVwiXS5NQUlOLCBkYXRhKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTFfX1tcIkVycm9yRGV0YWlsc1wiXS5MRVZFTF9MT0FEX0VSUk9SOlxuICAgICAgY2FzZSBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMV9fW1wiRXJyb3JEZXRhaWxzXCJdLkxFVkVMX0xPQURfVElNRU9VVDpcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgIT09IF9iYXNlX3N0cmVhbV9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJTdGF0ZVwiXS5FUlJPUikge1xuICAgICAgICAgIGlmIChkYXRhLmZhdGFsKSB7XG4gICAgICAgICAgICAvLyBpZiBmYXRhbCBlcnJvciwgc3RvcCBwcm9jZXNzaW5nXG4gICAgICAgICAgICB0aGlzLndhcm4oXCJcIiArIGRhdGEuZGV0YWlscyk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gX2Jhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIlN0YXRlXCJdLkVSUk9SO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBpbiBjYXNlIG9mIG5vbiBmYXRhbCBlcnJvciB3aGlsZSBsb2FkaW5nIGxldmVsLCBpZiBsZXZlbCBjb250cm9sbGVyIGlzIG5vdCByZXRyeWluZyB0byBsb2FkIGxldmVsICwgc3dpdGNoIGJhY2sgdG8gSURMRVxuICAgICAgICAgICAgaWYgKCFkYXRhLmxldmVsUmV0cnkgJiYgdGhpcy5zdGF0ZSA9PT0gX2Jhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIlN0YXRlXCJdLldBSVRJTkdfTEVWRUwpIHtcbiAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IF9iYXNlX3N0cmVhbV9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJTdGF0ZVwiXS5JRExFO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzExX19bXCJFcnJvckRldGFpbHNcIl0uQlVGRkVSX0ZVTExfRVJST1I6XG4gICAgICAgIC8vIGlmIGluIGFwcGVuZGluZyBzdGF0ZVxuICAgICAgICBpZiAoZGF0YS5wYXJlbnQgPT09ICdtYWluJyAmJiAodGhpcy5zdGF0ZSA9PT0gX2Jhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIlN0YXRlXCJdLlBBUlNJTkcgfHwgdGhpcy5zdGF0ZSA9PT0gX2Jhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIlN0YXRlXCJdLlBBUlNFRCkpIHtcbiAgICAgICAgICB2YXIgZmx1c2hCdWZmZXIgPSB0cnVlO1xuICAgICAgICAgIHZhciBidWZmZXJlZEluZm8gPSB0aGlzLmdldEZ3ZEJ1ZmZlckluZm8odGhpcy5tZWRpYSwgX3R5cGVzX2xvYWRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fW1wiUGxheWxpc3RMZXZlbFR5cGVcIl0uTUFJTik7IC8vIDAuNSA6IHRvbGVyYW5jZSBuZWVkZWQgYXMgc29tZSBicm93c2VycyBzdGFsbHMgcGxheWJhY2sgYmVmb3JlIHJlYWNoaW5nIGJ1ZmZlcmVkIGVuZFxuICAgICAgICAgIC8vIHJlZHVjZSBtYXggYnVmIGxlbiBpZiBjdXJyZW50IHBvc2l0aW9uIGlzIGJ1ZmZlcmVkXG5cbiAgICAgICAgICBpZiAoYnVmZmVyZWRJbmZvICYmIGJ1ZmZlcmVkSW5mby5sZW4gPiAwLjUpIHtcbiAgICAgICAgICAgIGZsdXNoQnVmZmVyID0gIXRoaXMucmVkdWNlTWF4QnVmZmVyTGVuZ3RoKGJ1ZmZlcmVkSW5mby5sZW4pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChmbHVzaEJ1ZmZlcikge1xuICAgICAgICAgICAgLy8gY3VycmVudCBwb3NpdGlvbiBpcyBub3QgYnVmZmVyZWQsIGJ1dCBicm93c2VyIGlzIHN0aWxsIGNvbXBsYWluaW5nIGFib3V0IGJ1ZmZlciBmdWxsIGVycm9yXG4gICAgICAgICAgICAvLyB0aGlzIGhhcHBlbnMgb24gSUUvRWRnZSwgcmVmZXIgdG8gaHR0cHM6Ly9naXRodWIuY29tL3ZpZGVvLWRldi9obHMuanMvcHVsbC83MDhcbiAgICAgICAgICAgIC8vIGluIHRoYXQgY2FzZSBmbHVzaCB0aGUgd2hvbGUgYnVmZmVyIHRvIHJlY292ZXJcbiAgICAgICAgICAgIHRoaXMud2FybignYnVmZmVyIGZ1bGwgZXJyb3IgYWxzbyBtZWRpYS5jdXJyZW50VGltZSBpcyBub3QgYnVmZmVyZWQsIGZsdXNoIG1haW4nKTsgLy8gZmx1c2ggbWFpbiBidWZmZXJcblxuICAgICAgICAgICAgdGhpcy5pbW1lZGlhdGVMZXZlbFN3aXRjaCgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMucmVzZXRMb2FkaW5nU3RhdGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBicmVhaztcbiAgICB9XG4gIH0gLy8gQ2hlY2tzIHRoZSBoZWFsdGggb2YgdGhlIGJ1ZmZlciBhbmQgYXR0ZW1wdHMgdG8gcmVzb2x2ZSBwbGF5YmFjayBzdGFsbHMuXG4gIDtcblxuICBfcHJvdG8uY2hlY2tCdWZmZXIgPSBmdW5jdGlvbiBjaGVja0J1ZmZlcigpIHtcbiAgICB2YXIgbWVkaWEgPSB0aGlzLm1lZGlhLFxuICAgICAgICBnYXBDb250cm9sbGVyID0gdGhpcy5nYXBDb250cm9sbGVyO1xuXG4gICAgaWYgKCFtZWRpYSB8fCAhZ2FwQ29udHJvbGxlciB8fCAhbWVkaWEucmVhZHlTdGF0ZSkge1xuICAgICAgLy8gRXhpdCBlYXJseSBpZiB3ZSBkb24ndCBoYXZlIG1lZGlhIG9yIGlmIHRoZSBtZWRpYSBoYXNuJ3QgYnVmZmVyZWQgYW55dGhpbmcgeWV0IChyZWFkeVN0YXRlIDApXG4gICAgICByZXR1cm47XG4gICAgfSAvLyBDaGVjayBjb21iaW5lZCBidWZmZXJcblxuXG4gICAgdmFyIGJ1ZmZlcmVkID0gX3V0aWxzX2J1ZmZlcl9oZWxwZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1tcIkJ1ZmZlckhlbHBlclwiXS5nZXRCdWZmZXJlZChtZWRpYSk7XG5cbiAgICBpZiAoIXRoaXMubG9hZGVkbWV0YWRhdGEgJiYgYnVmZmVyZWQubGVuZ3RoKSB7XG4gICAgICB0aGlzLmxvYWRlZG1ldGFkYXRhID0gdHJ1ZTtcbiAgICAgIHRoaXMuc2Vla1RvU3RhcnRQb3MoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmVzb2x2ZSBnYXBzIHVzaW5nIHRoZSBtYWluIGJ1ZmZlciwgd2hvc2UgcmFuZ2VzIGFyZSB0aGUgaW50ZXJzZWN0aW9ucyBvZiB0aGUgQS9WIHNvdXJjZWJ1ZmZlcnNcbiAgICAgIGdhcENvbnRyb2xsZXIucG9sbCh0aGlzLmxhc3RDdXJyZW50VGltZSk7XG4gICAgfVxuXG4gICAgdGhpcy5sYXN0Q3VycmVudFRpbWUgPSBtZWRpYS5jdXJyZW50VGltZTtcbiAgfTtcblxuICBfcHJvdG8ub25GcmFnTG9hZEVtZXJnZW5jeUFib3J0ZWQgPSBmdW5jdGlvbiBvbkZyYWdMb2FkRW1lcmdlbmN5QWJvcnRlZCgpIHtcbiAgICB0aGlzLnN0YXRlID0gX2Jhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIlN0YXRlXCJdLklETEU7IC8vIGlmIGxvYWRlZG1ldGFkYXRhIGlzIG5vdCBzZXQsIGl0IG1lYW5zIHRoYXQgd2UgYXJlIGVtZXJnZW5jeSBzd2l0Y2ggZG93biBvbiBmaXJzdCBmcmFnXG4gICAgLy8gaW4gdGhhdCBjYXNlLCByZXNldCBzdGFydEZyYWdSZXF1ZXN0ZWQgZmxhZ1xuXG4gICAgaWYgKCF0aGlzLmxvYWRlZG1ldGFkYXRhKSB7XG4gICAgICB0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5uZXh0TG9hZFBvc2l0aW9uID0gdGhpcy5zdGFydFBvc2l0aW9uO1xuICAgIH1cblxuICAgIHRoaXMudGlja0ltbWVkaWF0ZSgpO1xuICB9O1xuXG4gIF9wcm90by5vbkJ1ZmZlckZsdXNoZWQgPSBmdW5jdGlvbiBvbkJ1ZmZlckZsdXNoZWQoZXZlbnQsIF9yZWYpIHtcbiAgICB2YXIgdHlwZSA9IF9yZWYudHlwZTtcblxuICAgIGlmICh0eXBlICE9PSBfbG9hZGVyX2ZyYWdtZW50X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bXCJFbGVtZW50YXJ5U3RyZWFtVHlwZXNcIl0uQVVESU8gfHwgdGhpcy5hdWRpb09ubHkgJiYgIXRoaXMuYWx0QXVkaW8pIHtcbiAgICAgIHZhciBtZWRpYSA9ICh0eXBlID09PSBfbG9hZGVyX2ZyYWdtZW50X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bXCJFbGVtZW50YXJ5U3RyZWFtVHlwZXNcIl0uVklERU8gPyB0aGlzLnZpZGVvQnVmZmVyIDogdGhpcy5tZWRpYUJ1ZmZlcikgfHwgdGhpcy5tZWRpYTtcbiAgICAgIHRoaXMuYWZ0ZXJCdWZmZXJGbHVzaGVkKG1lZGlhLCB0eXBlLCBfdHlwZXNfbG9hZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXCJQbGF5bGlzdExldmVsVHlwZVwiXS5NQUlOKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLm9uTGV2ZWxzVXBkYXRlZCA9IGZ1bmN0aW9uIG9uTGV2ZWxzVXBkYXRlZChldmVudCwgZGF0YSkge1xuICAgIHRoaXMubGV2ZWxzID0gZGF0YS5sZXZlbHM7XG4gIH07XG5cbiAgX3Byb3RvLnN3YXBBdWRpb0NvZGVjID0gZnVuY3Rpb24gc3dhcEF1ZGlvQ29kZWMoKSB7XG4gICAgdGhpcy5hdWRpb0NvZGVjU3dhcCA9ICF0aGlzLmF1ZGlvQ29kZWNTd2FwO1xuICB9XG4gIC8qKlxuICAgKiBTZWVrcyB0byB0aGUgc2V0IHN0YXJ0UG9zaXRpb24gaWYgbm90IGVxdWFsIHRvIHRoZSBtZWRpYUVsZW1lbnQncyBjdXJyZW50IHRpbWUuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnNlZWtUb1N0YXJ0UG9zID0gZnVuY3Rpb24gc2Vla1RvU3RhcnRQb3MoKSB7XG4gICAgdmFyIG1lZGlhID0gdGhpcy5tZWRpYTtcbiAgICB2YXIgY3VycmVudFRpbWUgPSBtZWRpYS5jdXJyZW50VGltZTtcbiAgICB2YXIgc3RhcnRQb3NpdGlvbiA9IHRoaXMuc3RhcnRQb3NpdGlvbjsgLy8gb25seSBhZGp1c3QgY3VycmVudFRpbWUgaWYgZGlmZmVyZW50IGZyb20gc3RhcnRQb3NpdGlvbiBvciBpZiBzdGFydFBvc2l0aW9uIG5vdCBidWZmZXJlZFxuICAgIC8vIGF0IHRoYXQgc3RhZ2UsIHRoZXJlIHNob3VsZCBiZSBvbmx5IG9uZSBidWZmZXJlZCByYW5nZSwgYXMgd2UgcmVhY2ggdGhhdCBjb2RlIGFmdGVyIGZpcnN0IGZyYWdtZW50IGhhcyBiZWVuIGJ1ZmZlcmVkXG5cbiAgICBpZiAoc3RhcnRQb3NpdGlvbiA+PSAwICYmIGN1cnJlbnRUaW1lIDwgc3RhcnRQb3NpdGlvbikge1xuICAgICAgaWYgKG1lZGlhLnNlZWtpbmcpIHtcbiAgICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTJfX1tcImxvZ2dlclwiXS5sb2coXCJjb3VsZCBub3Qgc2VlayB0byBcIiArIHN0YXJ0UG9zaXRpb24gKyBcIiwgYWxyZWFkeSBzZWVraW5nIGF0IFwiICsgY3VycmVudFRpbWUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBidWZmZXJlZCA9IF91dGlsc19idWZmZXJfaGVscGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXCJCdWZmZXJIZWxwZXJcIl0uZ2V0QnVmZmVyZWQobWVkaWEpO1xuICAgICAgdmFyIGJ1ZmZlclN0YXJ0ID0gYnVmZmVyZWQubGVuZ3RoID8gYnVmZmVyZWQuc3RhcnQoMCkgOiAwO1xuICAgICAgdmFyIGRlbHRhID0gYnVmZmVyU3RhcnQgLSBzdGFydFBvc2l0aW9uO1xuXG4gICAgICBpZiAoZGVsdGEgPiAwICYmIChkZWx0YSA8IHRoaXMuY29uZmlnLm1heEJ1ZmZlckhvbGUgfHwgZGVsdGEgPCB0aGlzLmNvbmZpZy5tYXhGcmFnTG9va1VwVG9sZXJhbmNlKSkge1xuICAgICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMl9fW1wibG9nZ2VyXCJdLmxvZyhcImFkanVzdGluZyBzdGFydCBwb3NpdGlvbiBieSBcIiArIGRlbHRhICsgXCIgdG8gbWF0Y2ggYnVmZmVyIHN0YXJ0XCIpO1xuICAgICAgICBzdGFydFBvc2l0aW9uICs9IGRlbHRhO1xuICAgICAgICB0aGlzLnN0YXJ0UG9zaXRpb24gPSBzdGFydFBvc2l0aW9uO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmxvZyhcInNlZWsgdG8gdGFyZ2V0IHN0YXJ0IHBvc2l0aW9uIFwiICsgc3RhcnRQb3NpdGlvbiArIFwiIGZyb20gY3VycmVudCB0aW1lIFwiICsgY3VycmVudFRpbWUpO1xuICAgICAgbWVkaWEuY3VycmVudFRpbWUgPSBzdGFydFBvc2l0aW9uO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uX2dldEF1ZGlvQ29kZWMgPSBmdW5jdGlvbiBfZ2V0QXVkaW9Db2RlYyhjdXJyZW50TGV2ZWwpIHtcbiAgICB2YXIgYXVkaW9Db2RlYyA9IHRoaXMuY29uZmlnLmRlZmF1bHRBdWRpb0NvZGVjIHx8IGN1cnJlbnRMZXZlbC5hdWRpb0NvZGVjO1xuXG4gICAgaWYgKHRoaXMuYXVkaW9Db2RlY1N3YXAgJiYgYXVkaW9Db2RlYykge1xuICAgICAgdGhpcy5sb2coJ1N3YXBwaW5nIGF1ZGlvIGNvZGVjJyk7XG5cbiAgICAgIGlmIChhdWRpb0NvZGVjLmluZGV4T2YoJ21wNGEuNDAuNScpICE9PSAtMSkge1xuICAgICAgICBhdWRpb0NvZGVjID0gJ21wNGEuNDAuMic7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhdWRpb0NvZGVjID0gJ21wNGEuNDAuNSc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGF1ZGlvQ29kZWM7XG4gIH07XG5cbiAgX3Byb3RvLl9sb2FkQml0cmF0ZVRlc3RGcmFnID0gZnVuY3Rpb24gX2xvYWRCaXRyYXRlVGVzdEZyYWcoZnJhZykge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgdGhpcy5fZG9GcmFnTG9hZChmcmFnKS50aGVuKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICB2YXIgaGxzID0gX3RoaXMyLmhscztcblxuICAgICAgaWYgKCFkYXRhIHx8IGhscy5uZXh0TG9hZExldmVsIHx8IF90aGlzMi5mcmFnQ29udGV4dENoYW5nZWQoZnJhZykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBfdGhpczIuZnJhZ0xvYWRFcnJvciA9IDA7XG4gICAgICBfdGhpczIuc3RhdGUgPSBfYmFzZV9zdHJlYW1fY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiU3RhdGVcIl0uSURMRTtcbiAgICAgIF90aGlzMi5zdGFydEZyYWdSZXF1ZXN0ZWQgPSBmYWxzZTtcbiAgICAgIF90aGlzMi5iaXRyYXRlVGVzdCA9IGZhbHNlO1xuICAgICAgdmFyIHN0YXRzID0gZnJhZy5zdGF0czsgLy8gQml0cmF0ZSB0ZXN0cyBmcmFnbWVudHMgYXJlIG5laXRoZXIgcGFyc2VkIG5vciBidWZmZXJlZFxuXG4gICAgICBzdGF0cy5wYXJzaW5nLnN0YXJ0ID0gc3RhdHMucGFyc2luZy5lbmQgPSBzdGF0cy5idWZmZXJpbmcuc3RhcnQgPSBzdGF0cy5idWZmZXJpbmcuZW5kID0gc2VsZi5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIGhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcIkV2ZW50c1wiXS5GUkFHX0xPQURFRCwgZGF0YSk7XG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLl9oYW5kbGVUcmFuc211eENvbXBsZXRlID0gZnVuY3Rpb24gX2hhbmRsZVRyYW5zbXV4Q29tcGxldGUodHJhbnNtdXhSZXN1bHQpIHtcbiAgICB2YXIgX2lkMyRzYW1wbGVzO1xuXG4gICAgdmFyIGlkID0gJ21haW4nO1xuICAgIHZhciBobHMgPSB0aGlzLmhscztcbiAgICB2YXIgcmVtdXhSZXN1bHQgPSB0cmFuc211eFJlc3VsdC5yZW11eFJlc3VsdCxcbiAgICAgICAgY2h1bmtNZXRhID0gdHJhbnNtdXhSZXN1bHQuY2h1bmtNZXRhO1xuICAgIHZhciBjb250ZXh0ID0gdGhpcy5nZXRDdXJyZW50Q29udGV4dChjaHVua01ldGEpO1xuXG4gICAgaWYgKCFjb250ZXh0KSB7XG4gICAgICB0aGlzLndhcm4oXCJUaGUgbG9hZGluZyBjb250ZXh0IGNoYW5nZWQgd2hpbGUgYnVmZmVyaW5nIGZyYWdtZW50IFwiICsgY2h1bmtNZXRhLnNuICsgXCIgb2YgbGV2ZWwgXCIgKyBjaHVua01ldGEubGV2ZWwgKyBcIi4gVGhpcyBjaHVuayB3aWxsIG5vdCBiZSBidWZmZXJlZC5cIik7XG4gICAgICB0aGlzLnJlc2V0TGl2ZVN0YXJ0V2hlbk5vdExvYWRlZChjaHVua01ldGEubGV2ZWwpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBmcmFnID0gY29udGV4dC5mcmFnLFxuICAgICAgICBwYXJ0ID0gY29udGV4dC5wYXJ0LFxuICAgICAgICBsZXZlbCA9IGNvbnRleHQubGV2ZWw7XG4gICAgdmFyIHZpZGVvID0gcmVtdXhSZXN1bHQudmlkZW8sXG4gICAgICAgIHRleHQgPSByZW11eFJlc3VsdC50ZXh0LFxuICAgICAgICBpZDMgPSByZW11eFJlc3VsdC5pZDMsXG4gICAgICAgIGluaXRTZWdtZW50ID0gcmVtdXhSZXN1bHQuaW5pdFNlZ21lbnQ7IC8vIFRoZSBhdWRpby1zdHJlYW0tY29udHJvbGxlciBoYW5kbGVzIGF1ZGlvIGJ1ZmZlcmluZyBpZiBIbHMuanMgaXMgcGxheWluZyBhbiBhbHRlcm5hdGUgYXVkaW8gdHJhY2tcblxuICAgIHZhciBhdWRpbyA9IHRoaXMuYWx0QXVkaW8gPyB1bmRlZmluZWQgOiByZW11eFJlc3VsdC5hdWRpbzsgLy8gQ2hlY2sgaWYgdGhlIGN1cnJlbnQgZnJhZ21lbnQgaGFzIGJlZW4gYWJvcnRlZC4gV2UgY2hlY2sgdGhpcyBieSBmaXJzdCBzZWVpbmcgaWYgd2UncmUgc3RpbGwgcGxheWluZyB0aGUgY3VycmVudCBsZXZlbC5cbiAgICAvLyBJZiB3ZSBhcmUsIHN1YnNlcXVlbnRseSBjaGVjayBpZiB0aGUgY3VycmVudGx5IGxvYWRpbmcgZnJhZ21lbnQgKGZyYWdDdXJyZW50KSBoYXMgY2hhbmdlZC5cblxuICAgIGlmICh0aGlzLmZyYWdDb250ZXh0Q2hhbmdlZChmcmFnKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuc3RhdGUgPSBfYmFzZV9zdHJlYW1fY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiU3RhdGVcIl0uUEFSU0lORztcblxuICAgIGlmIChpbml0U2VnbWVudCkge1xuICAgICAgaWYgKGluaXRTZWdtZW50LnRyYWNrcykge1xuICAgICAgICB0aGlzLl9idWZmZXJJbml0U2VnbWVudChsZXZlbCwgaW5pdFNlZ21lbnQudHJhY2tzLCBmcmFnLCBjaHVua01ldGEpO1xuXG4gICAgICAgIGhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcIkV2ZW50c1wiXS5GUkFHX1BBUlNJTkdfSU5JVF9TRUdNRU5ULCB7XG4gICAgICAgICAgZnJhZzogZnJhZyxcbiAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgdHJhY2tzOiBpbml0U2VnbWVudC50cmFja3NcbiAgICAgICAgfSk7XG4gICAgICB9IC8vIFRoaXMgd291bGQgYmUgbmljZSBpZiBOdW1iZXIuaXNGaW5pdGUgYWN0ZWQgYXMgYSB0eXBlZ3VhcmQsIGJ1dCBpdCBkb2Vzbid0LiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9NaWNyb3NvZnQvVHlwZVNjcmlwdC9pc3N1ZXMvMTAwMzhcblxuXG4gICAgICB2YXIgaW5pdFBUUyA9IGluaXRTZWdtZW50LmluaXRQVFM7XG4gICAgICB2YXIgdGltZXNjYWxlID0gaW5pdFNlZ21lbnQudGltZXNjYWxlO1xuXG4gICAgICBpZiAoT2JqZWN0KF9ob21lX3J1bm5lcl93b3JrX2hsc19qc19obHNfanNfc3JjX3BvbHlmaWxsc19udW1iZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImlzRmluaXRlTnVtYmVyXCJdKShpbml0UFRTKSkge1xuICAgICAgICB0aGlzLmluaXRQVFNbZnJhZy5jY10gPSBpbml0UFRTO1xuICAgICAgICBobHMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJFdmVudHNcIl0uSU5JVF9QVFNfRk9VTkQsIHtcbiAgICAgICAgICBmcmFnOiBmcmFnLFxuICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICBpbml0UFRTOiBpbml0UFRTLFxuICAgICAgICAgIHRpbWVzY2FsZTogdGltZXNjYWxlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gLy8gQXZvaWQgYnVmZmVyaW5nIGlmIGJhY2t0cmFja2luZyB0aGlzIGZyYWdtZW50XG5cblxuICAgIGlmICh2aWRlbyAmJiByZW11eFJlc3VsdC5pbmRlcGVuZGVudCAhPT0gZmFsc2UpIHtcbiAgICAgIGlmIChsZXZlbC5kZXRhaWxzKSB7XG4gICAgICAgIHZhciBzdGFydFBUUyA9IHZpZGVvLnN0YXJ0UFRTLFxuICAgICAgICAgICAgZW5kUFRTID0gdmlkZW8uZW5kUFRTLFxuICAgICAgICAgICAgc3RhcnREVFMgPSB2aWRlby5zdGFydERUUyxcbiAgICAgICAgICAgIGVuZERUUyA9IHZpZGVvLmVuZERUUztcblxuICAgICAgICBpZiAocGFydCkge1xuICAgICAgICAgIHBhcnQuZWxlbWVudGFyeVN0cmVhbXNbdmlkZW8udHlwZV0gPSB7XG4gICAgICAgICAgICBzdGFydFBUUzogc3RhcnRQVFMsXG4gICAgICAgICAgICBlbmRQVFM6IGVuZFBUUyxcbiAgICAgICAgICAgIHN0YXJ0RFRTOiBzdGFydERUUyxcbiAgICAgICAgICAgIGVuZERUUzogZW5kRFRTXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodmlkZW8uZmlyc3RLZXlGcmFtZSAmJiB2aWRlby5pbmRlcGVuZGVudCkge1xuICAgICAgICAgICAgdGhpcy5jb3VsZEJhY2t0cmFjayA9IHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHZpZGVvLmRyb3BwZWQgJiYgdmlkZW8uaW5kZXBlbmRlbnQpIHtcbiAgICAgICAgICAgIC8vIEJhY2t0cmFjayBpZiBkcm9wcGVkIGZyYW1lcyBjcmVhdGUgYSBnYXAgYWZ0ZXIgY3VycmVudFRpbWVcbiAgICAgICAgICAgIHZhciBwb3MgPSB0aGlzLmdldExvYWRQb3NpdGlvbigpICsgdGhpcy5jb25maWcubWF4QnVmZmVySG9sZTtcblxuICAgICAgICAgICAgaWYgKHBvcyA8IHN0YXJ0UFRTKSB7XG4gICAgICAgICAgICAgIHRoaXMuYmFja3RyYWNrKGZyYWcpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9IC8vIFNldCB2aWRlbyBzdHJlYW0gc3RhcnQgdG8gZnJhZ21lbnQgc3RhcnQgc28gdGhhdCB0cnVuY2F0ZWQgc2FtcGxlcyBkbyBub3QgZGlzdG9ydCB0aGUgdGltZWxpbmUsIGFuZCBtYXJrIGl0IHBhcnRpYWxcblxuXG4gICAgICAgICAgICBmcmFnLnNldEVsZW1lbnRhcnlTdHJlYW1JbmZvKHZpZGVvLnR5cGUsIGZyYWcuc3RhcnQsIGVuZFBUUywgZnJhZy5zdGFydCwgZW5kRFRTLCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmcmFnLnNldEVsZW1lbnRhcnlTdHJlYW1JbmZvKHZpZGVvLnR5cGUsIHN0YXJ0UFRTLCBlbmRQVFMsIHN0YXJ0RFRTLCBlbmREVFMpO1xuICAgICAgICB0aGlzLmJ1ZmZlckZyYWdtZW50RGF0YSh2aWRlbywgZnJhZywgcGFydCwgY2h1bmtNZXRhKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHJlbXV4UmVzdWx0LmluZGVwZW5kZW50ID09PSBmYWxzZSkge1xuICAgICAgdGhpcy5iYWNrdHJhY2soZnJhZyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGF1ZGlvKSB7XG4gICAgICB2YXIgX3N0YXJ0UFRTID0gYXVkaW8uc3RhcnRQVFMsXG4gICAgICAgICAgX2VuZFBUUyA9IGF1ZGlvLmVuZFBUUyxcbiAgICAgICAgICBfc3RhcnREVFMgPSBhdWRpby5zdGFydERUUyxcbiAgICAgICAgICBfZW5kRFRTID0gYXVkaW8uZW5kRFRTO1xuXG4gICAgICBpZiAocGFydCkge1xuICAgICAgICBwYXJ0LmVsZW1lbnRhcnlTdHJlYW1zW19sb2FkZXJfZnJhZ21lbnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1tcIkVsZW1lbnRhcnlTdHJlYW1UeXBlc1wiXS5BVURJT10gPSB7XG4gICAgICAgICAgc3RhcnRQVFM6IF9zdGFydFBUUyxcbiAgICAgICAgICBlbmRQVFM6IF9lbmRQVFMsXG4gICAgICAgICAgc3RhcnREVFM6IF9zdGFydERUUyxcbiAgICAgICAgICBlbmREVFM6IF9lbmREVFNcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgZnJhZy5zZXRFbGVtZW50YXJ5U3RyZWFtSW5mbyhfbG9hZGVyX2ZyYWdtZW50X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bXCJFbGVtZW50YXJ5U3RyZWFtVHlwZXNcIl0uQVVESU8sIF9zdGFydFBUUywgX2VuZFBUUywgX3N0YXJ0RFRTLCBfZW5kRFRTKTtcbiAgICAgIHRoaXMuYnVmZmVyRnJhZ21lbnREYXRhKGF1ZGlvLCBmcmFnLCBwYXJ0LCBjaHVua01ldGEpO1xuICAgIH1cblxuICAgIGlmIChpZDMgIT09IG51bGwgJiYgaWQzICE9PSB2b2lkIDAgJiYgKF9pZDMkc2FtcGxlcyA9IGlkMy5zYW1wbGVzKSAhPT0gbnVsbCAmJiBfaWQzJHNhbXBsZXMgIT09IHZvaWQgMCAmJiBfaWQzJHNhbXBsZXMubGVuZ3RoKSB7XG4gICAgICB2YXIgZW1pdHRlZElEMyA9IHtcbiAgICAgICAgZnJhZzogZnJhZyxcbiAgICAgICAgaWQ6IGlkLFxuICAgICAgICBzYW1wbGVzOiBpZDMuc2FtcGxlc1xuICAgICAgfTtcbiAgICAgIGhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcIkV2ZW50c1wiXS5GUkFHX1BBUlNJTkdfTUVUQURBVEEsIGVtaXR0ZWRJRDMpO1xuICAgIH1cblxuICAgIGlmICh0ZXh0KSB7XG4gICAgICB2YXIgZW1pdHRlZFRleHQgPSB7XG4gICAgICAgIGZyYWc6IGZyYWcsXG4gICAgICAgIGlkOiBpZCxcbiAgICAgICAgc2FtcGxlczogdGV4dC5zYW1wbGVzXG4gICAgICB9O1xuICAgICAgaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiRXZlbnRzXCJdLkZSQUdfUEFSU0lOR19VU0VSREFUQSwgZW1pdHRlZFRleHQpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uX2J1ZmZlckluaXRTZWdtZW50ID0gZnVuY3Rpb24gX2J1ZmZlckluaXRTZWdtZW50KGN1cnJlbnRMZXZlbCwgdHJhY2tzLCBmcmFnLCBjaHVua01ldGEpIHtcbiAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgIGlmICh0aGlzLnN0YXRlICE9PSBfYmFzZV9zdHJlYW1fY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiU3RhdGVcIl0uUEFSU0lORykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuYXVkaW9Pbmx5ID0gISF0cmFja3MuYXVkaW8gJiYgIXRyYWNrcy52aWRlbzsgLy8gaWYgYXVkaW8gdHJhY2sgaXMgZXhwZWN0ZWQgdG8gY29tZSBmcm9tIGF1ZGlvIHN0cmVhbSBjb250cm9sbGVyLCBkaXNjYXJkIGFueSBjb21pbmcgZnJvbSBtYWluXG5cbiAgICBpZiAodGhpcy5hbHRBdWRpbyAmJiAhdGhpcy5hdWRpb09ubHkpIHtcbiAgICAgIGRlbGV0ZSB0cmFja3MuYXVkaW87XG4gICAgfSAvLyBpbmNsdWRlIGxldmVsQ29kZWMgaW4gYXVkaW8gYW5kIHZpZGVvIHRyYWNrc1xuXG5cbiAgICB2YXIgYXVkaW8gPSB0cmFja3MuYXVkaW8sXG4gICAgICAgIHZpZGVvID0gdHJhY2tzLnZpZGVvLFxuICAgICAgICBhdWRpb3ZpZGVvID0gdHJhY2tzLmF1ZGlvdmlkZW87XG5cbiAgICBpZiAoYXVkaW8pIHtcbiAgICAgIHZhciBhdWRpb0NvZGVjID0gY3VycmVudExldmVsLmF1ZGlvQ29kZWM7XG4gICAgICB2YXIgdWEgPSBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgIGlmICh0aGlzLmF1ZGlvQ29kZWNTd2l0Y2gpIHtcbiAgICAgICAgaWYgKGF1ZGlvQ29kZWMpIHtcbiAgICAgICAgICBpZiAoYXVkaW9Db2RlYy5pbmRleE9mKCdtcDRhLjQwLjUnKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIGF1ZGlvQ29kZWMgPSAnbXA0YS40MC4yJztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXVkaW9Db2RlYyA9ICdtcDRhLjQwLjUnO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBJbiB0aGUgY2FzZSB0aGF0IEFBQyBhbmQgSEUtQUFDIGF1ZGlvIGNvZGVjcyBhcmUgc2lnbmFsbGVkIGluIG1hbmlmZXN0LFxuICAgICAgICAvLyBmb3JjZSBIRS1BQUMsIGFzIGl0IHNlZW1zIHRoYXQgbW9zdCBicm93c2VycyBwcmVmZXJzIGl0LlxuICAgICAgICAvLyBkb24ndCBmb3JjZSBIRS1BQUMgaWYgbW9ubyBzdHJlYW0sIG9yIGluIEZpcmVmb3hcblxuXG4gICAgICAgIGlmIChhdWRpby5tZXRhZGF0YS5jaGFubmVsQ291bnQgIT09IDEgJiYgdWEuaW5kZXhPZignZmlyZWZveCcpID09PSAtMSkge1xuICAgICAgICAgIGF1ZGlvQ29kZWMgPSAnbXA0YS40MC41JztcbiAgICAgICAgfVxuICAgICAgfSAvLyBIRS1BQUMgaXMgYnJva2VuIG9uIEFuZHJvaWQsIGFsd2F5cyBzaWduYWwgYXVkaW8gY29kZWMgYXMgQUFDIGV2ZW4gaWYgdmFyaWFudCBtYW5pZmVzdCBzdGF0ZXMgb3RoZXJ3aXNlXG5cblxuICAgICAgaWYgKHVhLmluZGV4T2YoJ2FuZHJvaWQnKSAhPT0gLTEgJiYgYXVkaW8uY29udGFpbmVyICE9PSAnYXVkaW8vbXBlZycpIHtcbiAgICAgICAgLy8gRXhjbHVkZSBtcGVnIGF1ZGlvXG4gICAgICAgIGF1ZGlvQ29kZWMgPSAnbXA0YS40MC4yJztcbiAgICAgICAgdGhpcy5sb2coXCJBbmRyb2lkOiBmb3JjZSBhdWRpbyBjb2RlYyB0byBcIiArIGF1ZGlvQ29kZWMpO1xuICAgICAgfVxuXG4gICAgICBpZiAoY3VycmVudExldmVsLmF1ZGlvQ29kZWMgJiYgY3VycmVudExldmVsLmF1ZGlvQ29kZWMgIT09IGF1ZGlvQ29kZWMpIHtcbiAgICAgICAgdGhpcy5sb2coXCJTd2FwcGluZyBtYW5pZmVzdCBhdWRpbyBjb2RlYyBcXFwiXCIgKyBjdXJyZW50TGV2ZWwuYXVkaW9Db2RlYyArIFwiXFxcIiBmb3IgXFxcIlwiICsgYXVkaW9Db2RlYyArIFwiXFxcIlwiKTtcbiAgICAgIH1cblxuICAgICAgYXVkaW8ubGV2ZWxDb2RlYyA9IGF1ZGlvQ29kZWM7XG4gICAgICBhdWRpby5pZCA9ICdtYWluJztcbiAgICAgIHRoaXMubG9nKFwiSW5pdCBhdWRpbyBidWZmZXIsIGNvbnRhaW5lcjpcIiArIGF1ZGlvLmNvbnRhaW5lciArIFwiLCBjb2RlY3Nbc2VsZWN0ZWQvbGV2ZWwvcGFyc2VkXT1bXCIgKyAoYXVkaW9Db2RlYyB8fCAnJykgKyBcIi9cIiArIChjdXJyZW50TGV2ZWwuYXVkaW9Db2RlYyB8fCAnJykgKyBcIi9cIiArIGF1ZGlvLmNvZGVjICsgXCJdXCIpO1xuICAgIH1cblxuICAgIGlmICh2aWRlbykge1xuICAgICAgdmlkZW8ubGV2ZWxDb2RlYyA9IGN1cnJlbnRMZXZlbC52aWRlb0NvZGVjO1xuICAgICAgdmlkZW8uaWQgPSAnbWFpbic7XG4gICAgICB0aGlzLmxvZyhcIkluaXQgdmlkZW8gYnVmZmVyLCBjb250YWluZXI6XCIgKyB2aWRlby5jb250YWluZXIgKyBcIiwgY29kZWNzW2xldmVsL3BhcnNlZF09W1wiICsgKGN1cnJlbnRMZXZlbC52aWRlb0NvZGVjIHx8ICcnKSArIFwiL1wiICsgdmlkZW8uY29kZWMgKyBcIl1cIik7XG4gICAgfVxuXG4gICAgaWYgKGF1ZGlvdmlkZW8pIHtcbiAgICAgIHRoaXMubG9nKFwiSW5pdCBhdWRpb3ZpZGVvIGJ1ZmZlciwgY29udGFpbmVyOlwiICsgYXVkaW92aWRlby5jb250YWluZXIgKyBcIiwgY29kZWNzW2xldmVsL3BhcnNlZF09W1wiICsgKGN1cnJlbnRMZXZlbC5hdHRycy5DT0RFQ1MgfHwgJycpICsgXCIvXCIgKyBhdWRpb3ZpZGVvLmNvZGVjICsgXCJdXCIpO1xuICAgIH1cblxuICAgIHRoaXMuaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiRXZlbnRzXCJdLkJVRkZFUl9DT0RFQ1MsIHRyYWNrcyk7IC8vIGxvb3AgdGhyb3VnaCB0cmFja3MgdGhhdCBhcmUgZ29pbmcgdG8gYmUgcHJvdmlkZWQgdG8gYnVmZmVyQ29udHJvbGxlclxuXG4gICAgT2JqZWN0LmtleXModHJhY2tzKS5mb3JFYWNoKGZ1bmN0aW9uICh0cmFja05hbWUpIHtcbiAgICAgIHZhciB0cmFjayA9IHRyYWNrc1t0cmFja05hbWVdO1xuICAgICAgdmFyIGluaXRTZWdtZW50ID0gdHJhY2suaW5pdFNlZ21lbnQ7XG5cbiAgICAgIGlmIChpbml0U2VnbWVudCAhPT0gbnVsbCAmJiBpbml0U2VnbWVudCAhPT0gdm9pZCAwICYmIGluaXRTZWdtZW50LmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgX3RoaXMzLmhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcIkV2ZW50c1wiXS5CVUZGRVJfQVBQRU5ESU5HLCB7XG4gICAgICAgICAgdHlwZTogdHJhY2tOYW1lLFxuICAgICAgICAgIGRhdGE6IGluaXRTZWdtZW50LFxuICAgICAgICAgIGZyYWc6IGZyYWcsXG4gICAgICAgICAgcGFydDogbnVsbCxcbiAgICAgICAgICBjaHVua01ldGE6IGNodW5rTWV0YSxcbiAgICAgICAgICBwYXJlbnQ6IGZyYWcudHlwZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTsgLy8gdHJpZ2dlciBoYW5kbGVyIHJpZ2h0IG5vd1xuXG4gICAgdGhpcy50aWNrKCk7XG4gIH07XG5cbiAgX3Byb3RvLmJhY2t0cmFjayA9IGZ1bmN0aW9uIGJhY2t0cmFjayhmcmFnKSB7XG4gICAgdGhpcy5jb3VsZEJhY2t0cmFjayA9IHRydWU7IC8vIENhdXNlcyBmaW5kRnJhZ21lbnRzIHRvIGJhY2t0cmFjayB0aHJvdWdoIGZyYWdtZW50cyB0byBmaW5kIHRoZSBrZXlmcmFtZVxuXG4gICAgdGhpcy5yZXNldFRyYW5zbXV4ZXIoKTtcbiAgICB0aGlzLmZsdXNoQnVmZmVyR2FwKGZyYWcpO1xuICAgIHZhciBkYXRhID0gdGhpcy5mcmFnbWVudFRyYWNrZXIuYmFja3RyYWNrKGZyYWcpO1xuICAgIHRoaXMuZnJhZ1ByZXZpb3VzID0gbnVsbDtcbiAgICB0aGlzLm5leHRMb2FkUG9zaXRpb24gPSBmcmFnLnN0YXJ0O1xuXG4gICAgaWYgKGRhdGEpIHtcbiAgICAgIHRoaXMucmVzZXRGcmFnbWVudExvYWRpbmcoZnJhZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIENoYW5nZSBzdGF0ZSB0byBCQUNLVFJBQ0tJTkcgc28gdGhhdCBmcmFnbWVudEVudGl0eS5iYWNrdHJhY2sgZGF0YSBjYW4gYmUgYWRkZWQgYWZ0ZXIgX2RvRnJhZ0xvYWRcbiAgICAgIHRoaXMuc3RhdGUgPSBfYmFzZV9zdHJlYW1fY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiU3RhdGVcIl0uQkFDS1RSQUNLSU5HO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uY2hlY2tGcmFnbWVudENoYW5nZWQgPSBmdW5jdGlvbiBjaGVja0ZyYWdtZW50Q2hhbmdlZCgpIHtcbiAgICB2YXIgdmlkZW8gPSB0aGlzLm1lZGlhO1xuICAgIHZhciBmcmFnUGxheWluZ0N1cnJlbnQgPSBudWxsO1xuXG4gICAgaWYgKHZpZGVvICYmIHZpZGVvLnJlYWR5U3RhdGUgPiAxICYmIHZpZGVvLnNlZWtpbmcgPT09IGZhbHNlKSB7XG4gICAgICB2YXIgY3VycmVudFRpbWUgPSB2aWRlby5jdXJyZW50VGltZTtcbiAgICAgIC8qIGlmIHZpZGVvIGVsZW1lbnQgaXMgaW4gc2Vla2VkIHN0YXRlLCBjdXJyZW50VGltZSBjYW4gb25seSBpbmNyZWFzZS5cbiAgICAgICAgKGFzc3VtaW5nIHRoYXQgcGxheWJhY2sgcmF0ZSBpcyBwb3NpdGl2ZSAuLi4pXG4gICAgICAgIEFzIHNvbWV0aW1lcyBjdXJyZW50VGltZSBqdW1wcyBiYWNrIHRvIHplcm8gYWZ0ZXIgYVxuICAgICAgICBtZWRpYSBkZWNvZGUgZXJyb3IsIGNoZWNrIHRoaXMsIHRvIGF2b2lkIHNlZWtpbmcgYmFjayB0b1xuICAgICAgICB3cm9uZyBwb3NpdGlvbiBhZnRlciBhIG1lZGlhIGRlY29kZSBlcnJvclxuICAgICAgKi9cblxuICAgICAgaWYgKF91dGlsc19idWZmZXJfaGVscGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXCJCdWZmZXJIZWxwZXJcIl0uaXNCdWZmZXJlZCh2aWRlbywgY3VycmVudFRpbWUpKSB7XG4gICAgICAgIGZyYWdQbGF5aW5nQ3VycmVudCA9IHRoaXMuZ2V0QXBwZW5kZWRGcmFnKGN1cnJlbnRUaW1lKTtcbiAgICAgIH0gZWxzZSBpZiAoX3V0aWxzX2J1ZmZlcl9oZWxwZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1tcIkJ1ZmZlckhlbHBlclwiXS5pc0J1ZmZlcmVkKHZpZGVvLCBjdXJyZW50VGltZSArIDAuMSkpIHtcbiAgICAgICAgLyogZW5zdXJlIHRoYXQgRlJBR19DSEFOR0VEIGV2ZW50IGlzIHRyaWdnZXJlZCBhdCBzdGFydHVwLFxuICAgICAgICAgIHdoZW4gZmlyc3QgdmlkZW8gZnJhbWUgaXMgZGlzcGxheWVkIGFuZCBwbGF5YmFjayBpcyBwYXVzZWQuXG4gICAgICAgICAgYWRkIGEgdG9sZXJhbmNlIG9mIDEwMG1zLCBpbiBjYXNlIGN1cnJlbnQgcG9zaXRpb24gaXMgbm90IGJ1ZmZlcmVkLFxuICAgICAgICAgIGNoZWNrIGlmIGN1cnJlbnQgcG9zKzEwMG1zIGlzIGJ1ZmZlcmVkIGFuZCB1c2UgdGhhdCBidWZmZXIgcmFuZ2VcbiAgICAgICAgICBmb3IgRlJBR19DSEFOR0VEIGV2ZW50IHJlcG9ydGluZyAqL1xuICAgICAgICBmcmFnUGxheWluZ0N1cnJlbnQgPSB0aGlzLmdldEFwcGVuZGVkRnJhZyhjdXJyZW50VGltZSArIDAuMSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChmcmFnUGxheWluZ0N1cnJlbnQpIHtcbiAgICAgICAgdmFyIGZyYWdQbGF5aW5nID0gdGhpcy5mcmFnUGxheWluZztcbiAgICAgICAgdmFyIGZyYWdDdXJyZW50TGV2ZWwgPSBmcmFnUGxheWluZ0N1cnJlbnQubGV2ZWw7XG5cbiAgICAgICAgaWYgKCFmcmFnUGxheWluZyB8fCBmcmFnUGxheWluZ0N1cnJlbnQuc24gIT09IGZyYWdQbGF5aW5nLnNuIHx8IGZyYWdQbGF5aW5nLmxldmVsICE9PSBmcmFnQ3VycmVudExldmVsIHx8IGZyYWdQbGF5aW5nQ3VycmVudC51cmxJZCAhPT0gZnJhZ1BsYXlpbmcudXJsSWQpIHtcbiAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcIkV2ZW50c1wiXS5GUkFHX0NIQU5HRUQsIHtcbiAgICAgICAgICAgIGZyYWc6IGZyYWdQbGF5aW5nQ3VycmVudFxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKCFmcmFnUGxheWluZyB8fCBmcmFnUGxheWluZy5sZXZlbCAhPT0gZnJhZ0N1cnJlbnRMZXZlbCkge1xuICAgICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJFdmVudHNcIl0uTEVWRUxfU1dJVENIRUQsIHtcbiAgICAgICAgICAgICAgbGV2ZWw6IGZyYWdDdXJyZW50TGV2ZWxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuZnJhZ1BsYXlpbmcgPSBmcmFnUGxheWluZ0N1cnJlbnQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgX2NyZWF0ZUNsYXNzKFN0cmVhbUNvbnRyb2xsZXIsIFt7XG4gICAga2V5OiBcIm5leHRMZXZlbFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdmFyIGZyYWcgPSB0aGlzLm5leHRCdWZmZXJlZEZyYWc7XG5cbiAgICAgIGlmIChmcmFnKSB7XG4gICAgICAgIHJldHVybiBmcmFnLmxldmVsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjdXJyZW50TGV2ZWxcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciBtZWRpYSA9IHRoaXMubWVkaWE7XG5cbiAgICAgIGlmIChtZWRpYSkge1xuICAgICAgICB2YXIgZnJhZ1BsYXlpbmdDdXJyZW50ID0gdGhpcy5nZXRBcHBlbmRlZEZyYWcobWVkaWEuY3VycmVudFRpbWUpO1xuXG4gICAgICAgIGlmIChmcmFnUGxheWluZ0N1cnJlbnQpIHtcbiAgICAgICAgICByZXR1cm4gZnJhZ1BsYXlpbmdDdXJyZW50LmxldmVsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibmV4dEJ1ZmZlcmVkRnJhZ1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdmFyIG1lZGlhID0gdGhpcy5tZWRpYTtcblxuICAgICAgaWYgKG1lZGlhKSB7XG4gICAgICAgIC8vIGZpcnN0IGdldCBlbmQgcmFuZ2Ugb2YgY3VycmVudCBmcmFnbWVudFxuICAgICAgICB2YXIgZnJhZ1BsYXlpbmdDdXJyZW50ID0gdGhpcy5nZXRBcHBlbmRlZEZyYWcobWVkaWEuY3VycmVudFRpbWUpO1xuICAgICAgICByZXR1cm4gdGhpcy5mb2xsb3dpbmdCdWZmZXJlZEZyYWcoZnJhZ1BsYXlpbmdDdXJyZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmb3JjZVN0YXJ0TG9hZFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2ZvcmNlU3RhcnRMb2FkO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBTdHJlYW1Db250cm9sbGVyO1xufShfYmFzZV9zdHJlYW1fY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiZGVmYXVsdFwiXSk7XG5cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9jb250cm9sbGVyL3N1YnRpdGxlLXN0cmVhbS1jb250cm9sbGVyLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvY29udHJvbGxlci9zdWJ0aXRsZS1zdHJlYW0tY29udHJvbGxlci50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IFN1YnRpdGxlU3RyZWFtQ29udHJvbGxlciAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJTdWJ0aXRsZVN0cmVhbUNvbnRyb2xsZXJcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBTdWJ0aXRsZVN0cmVhbUNvbnRyb2xsZXI7IH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2V2ZW50cyAqLyBcIi4vc3JjL2V2ZW50cy50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfYnVmZmVyX2hlbHBlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvYnVmZmVyLWhlbHBlciAqLyBcIi4vc3JjL3V0aWxzL2J1ZmZlci1oZWxwZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2ZyYWdtZW50X2ZpbmRlcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZnJhZ21lbnQtZmluZGVycyAqLyBcIi4vc3JjL2NvbnRyb2xsZXIvZnJhZ21lbnQtZmluZGVycy50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfZGlzY29udGludWl0aWVzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9kaXNjb250aW51aXRpZXMgKi8gXCIuL3NyYy91dGlscy9kaXNjb250aW51aXRpZXMudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2xldmVsX2hlbHBlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9sZXZlbC1oZWxwZXIgKi8gXCIuL3NyYy9jb250cm9sbGVyL2xldmVsLWhlbHBlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZnJhZ21lbnRfdHJhY2tlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9mcmFnbWVudC10cmFja2VyICovIFwiLi9zcmMvY29udHJvbGxlci9mcmFnbWVudC10cmFja2VyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9iYXNlX3N0cmVhbV9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2Jhc2Utc3RyZWFtLWNvbnRyb2xsZXIgKi8gXCIuL3NyYy9jb250cm9sbGVyL2Jhc2Utc3RyZWFtLWNvbnRyb2xsZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3R5cGVzX2xvYWRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdHlwZXMvbG9hZGVyICovIFwiLi9zcmMvdHlwZXMvbG9hZGVyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF90eXBlc19sZXZlbF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdHlwZXMvbGV2ZWwgKi8gXCIuL3NyYy90eXBlcy9sZXZlbC50c1wiKTtcbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7IHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzOyBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cblxuXG5cblxuXG5cblxuXG5cbnZhciBUSUNLX0lOVEVSVkFMID0gNTAwOyAvLyBob3cgb2Z0ZW4gdG8gdGljayBpbiBtc1xuXG52YXIgU3VidGl0bGVTdHJlYW1Db250cm9sbGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQmFzZVN0cmVhbUNvbnRyb2xsZXIpIHtcbiAgX2luaGVyaXRzTG9vc2UoU3VidGl0bGVTdHJlYW1Db250cm9sbGVyLCBfQmFzZVN0cmVhbUNvbnRyb2xsZXIpO1xuXG4gIGZ1bmN0aW9uIFN1YnRpdGxlU3RyZWFtQ29udHJvbGxlcihobHMsIGZyYWdtZW50VHJhY2tlcikge1xuICAgIHZhciBfdGhpcztcblxuICAgIF90aGlzID0gX0Jhc2VTdHJlYW1Db250cm9sbGVyLmNhbGwodGhpcywgaGxzLCBmcmFnbWVudFRyYWNrZXIsICdbc3VidGl0bGUtc3RyZWFtLWNvbnRyb2xsZXJdJykgfHwgdGhpcztcbiAgICBfdGhpcy5sZXZlbHMgPSBbXTtcbiAgICBfdGhpcy5jdXJyZW50VHJhY2tJZCA9IC0xO1xuICAgIF90aGlzLnRyYWNrc0J1ZmZlcmVkID0gW107XG4gICAgX3RoaXMubWFpbkRldGFpbHMgPSBudWxsO1xuXG4gICAgX3RoaXMuX3JlZ2lzdGVyTGlzdGVuZXJzKCk7XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gU3VidGl0bGVTdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZTtcblxuICBfcHJvdG8ub25IYW5kbGVyRGVzdHJveWluZyA9IGZ1bmN0aW9uIG9uSGFuZGxlckRlc3Ryb3lpbmcoKSB7XG4gICAgdGhpcy5fdW5yZWdpc3Rlckxpc3RlbmVycygpO1xuXG4gICAgdGhpcy5tYWluRGV0YWlscyA9IG51bGw7XG4gIH07XG5cbiAgX3Byb3RvLl9yZWdpc3Rlckxpc3RlbmVycyA9IGZ1bmN0aW9uIF9yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICB2YXIgaGxzID0gdGhpcy5obHM7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIkV2ZW50c1wiXS5NRURJQV9BVFRBQ0hFRCwgdGhpcy5vbk1lZGlhQXR0YWNoZWQsIHRoaXMpO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJFdmVudHNcIl0uTUVESUFfREVUQUNISU5HLCB0aGlzLm9uTWVkaWFEZXRhY2hpbmcsIHRoaXMpO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJFdmVudHNcIl0uTUFOSUZFU1RfTE9BRElORywgdGhpcy5vbk1hbmlmZXN0TG9hZGluZywgdGhpcyk7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIkV2ZW50c1wiXS5MRVZFTF9MT0FERUQsIHRoaXMub25MZXZlbExvYWRlZCwgdGhpcyk7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIkV2ZW50c1wiXS5FUlJPUiwgdGhpcy5vbkVycm9yLCB0aGlzKTtcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiRXZlbnRzXCJdLlNVQlRJVExFX1RSQUNLU19VUERBVEVELCB0aGlzLm9uU3VidGl0bGVUcmFja3NVcGRhdGVkLCB0aGlzKTtcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiRXZlbnRzXCJdLlNVQlRJVExFX1RSQUNLX1NXSVRDSCwgdGhpcy5vblN1YnRpdGxlVHJhY2tTd2l0Y2gsIHRoaXMpO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJFdmVudHNcIl0uU1VCVElUTEVfVFJBQ0tfTE9BREVELCB0aGlzLm9uU3VidGl0bGVUcmFja0xvYWRlZCwgdGhpcyk7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIkV2ZW50c1wiXS5TVUJUSVRMRV9GUkFHX1BST0NFU1NFRCwgdGhpcy5vblN1YnRpdGxlRnJhZ1Byb2Nlc3NlZCwgdGhpcyk7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIkV2ZW50c1wiXS5CVUZGRVJfRkxVU0hJTkcsIHRoaXMub25CdWZmZXJGbHVzaGluZywgdGhpcyk7XG4gIH07XG5cbiAgX3Byb3RvLl91bnJlZ2lzdGVyTGlzdGVuZXJzID0gZnVuY3Rpb24gX3VucmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgdmFyIGhscyA9IHRoaXMuaGxzO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiRXZlbnRzXCJdLk1FRElBX0FUVEFDSEVELCB0aGlzLm9uTWVkaWFBdHRhY2hlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJFdmVudHNcIl0uTUVESUFfREVUQUNISU5HLCB0aGlzLm9uTWVkaWFEZXRhY2hpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiRXZlbnRzXCJdLk1BTklGRVNUX0xPQURJTkcsIHRoaXMub25NYW5pZmVzdExvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiRXZlbnRzXCJdLkxFVkVMX0xPQURFRCwgdGhpcy5vbkxldmVsTG9hZGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIkV2ZW50c1wiXS5FUlJPUiwgdGhpcy5vbkVycm9yLCB0aGlzKTtcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIkV2ZW50c1wiXS5TVUJUSVRMRV9UUkFDS1NfVVBEQVRFRCwgdGhpcy5vblN1YnRpdGxlVHJhY2tzVXBkYXRlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJFdmVudHNcIl0uU1VCVElUTEVfVFJBQ0tfU1dJVENILCB0aGlzLm9uU3VidGl0bGVUcmFja1N3aXRjaCwgdGhpcyk7XG4gICAgaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJFdmVudHNcIl0uU1VCVElUTEVfVFJBQ0tfTE9BREVELCB0aGlzLm9uU3VidGl0bGVUcmFja0xvYWRlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJFdmVudHNcIl0uU1VCVElUTEVfRlJBR19QUk9DRVNTRUQsIHRoaXMub25TdWJ0aXRsZUZyYWdQcm9jZXNzZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiRXZlbnRzXCJdLkJVRkZFUl9GTFVTSElORywgdGhpcy5vbkJ1ZmZlckZsdXNoaW5nLCB0aGlzKTtcbiAgfTtcblxuICBfcHJvdG8uc3RhcnRMb2FkID0gZnVuY3Rpb24gc3RhcnRMb2FkKCkge1xuICAgIHRoaXMuc3RvcExvYWQoKTtcbiAgICB0aGlzLnN0YXRlID0gX2Jhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcIlN0YXRlXCJdLklETEU7XG4gICAgdGhpcy5zZXRJbnRlcnZhbChUSUNLX0lOVEVSVkFMKTtcbiAgICB0aGlzLnRpY2soKTtcbiAgfTtcblxuICBfcHJvdG8ub25NYW5pZmVzdExvYWRpbmcgPSBmdW5jdGlvbiBvbk1hbmlmZXN0TG9hZGluZygpIHtcbiAgICB0aGlzLm1haW5EZXRhaWxzID0gbnVsbDtcbiAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5yZW1vdmVBbGxGcmFnbWVudHMoKTtcbiAgfTtcblxuICBfcHJvdG8ub25MZXZlbExvYWRlZCA9IGZ1bmN0aW9uIG9uTGV2ZWxMb2FkZWQoZXZlbnQsIGRhdGEpIHtcbiAgICB0aGlzLm1haW5EZXRhaWxzID0gZGF0YS5kZXRhaWxzO1xuICB9O1xuXG4gIF9wcm90by5vblN1YnRpdGxlRnJhZ1Byb2Nlc3NlZCA9IGZ1bmN0aW9uIG9uU3VidGl0bGVGcmFnUHJvY2Vzc2VkKGV2ZW50LCBkYXRhKSB7XG4gICAgdmFyIGZyYWcgPSBkYXRhLmZyYWcsXG4gICAgICAgIHN1Y2Nlc3MgPSBkYXRhLnN1Y2Nlc3M7XG4gICAgdGhpcy5mcmFnUHJldmlvdXMgPSBmcmFnO1xuICAgIHRoaXMuc3RhdGUgPSBfYmFzZV9zdHJlYW1fY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fW1wiU3RhdGVcIl0uSURMRTtcblxuICAgIGlmICghc3VjY2Vzcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBidWZmZXJlZCA9IHRoaXMudHJhY2tzQnVmZmVyZWRbdGhpcy5jdXJyZW50VHJhY2tJZF07XG5cbiAgICBpZiAoIWJ1ZmZlcmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBDcmVhdGUvdXBkYXRlIGEgYnVmZmVyZWQgYXJyYXkgbWF0Y2hpbmcgdGhlIGludGVyZmFjZSB1c2VkIGJ5IEJ1ZmZlckhlbHBlci5idWZmZXJlZEluZm9cbiAgICAvLyBzbyB3ZSBjYW4gcmUtdXNlIHRoZSBsb2dpYyB1c2VkIHRvIGRldGVjdCBob3cgbXVjaCBoYXMgYmVlbiBidWZmZXJlZFxuXG5cbiAgICB2YXIgdGltZVJhbmdlO1xuICAgIHZhciBmcmFnU3RhcnQgPSBmcmFnLnN0YXJ0O1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBidWZmZXJlZC5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGZyYWdTdGFydCA+PSBidWZmZXJlZFtpXS5zdGFydCAmJiBmcmFnU3RhcnQgPD0gYnVmZmVyZWRbaV0uZW5kKSB7XG4gICAgICAgIHRpbWVSYW5nZSA9IGJ1ZmZlcmVkW2ldO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZnJhZ0VuZCA9IGZyYWcuc3RhcnQgKyBmcmFnLmR1cmF0aW9uO1xuXG4gICAgaWYgKHRpbWVSYW5nZSkge1xuICAgICAgdGltZVJhbmdlLmVuZCA9IGZyYWdFbmQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRpbWVSYW5nZSA9IHtcbiAgICAgICAgc3RhcnQ6IGZyYWdTdGFydCxcbiAgICAgICAgZW5kOiBmcmFnRW5kXG4gICAgICB9O1xuICAgICAgYnVmZmVyZWQucHVzaCh0aW1lUmFuZ2UpO1xuICAgIH1cblxuICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyLmZyYWdCdWZmZXJlZChmcmFnKTtcbiAgfTtcblxuICBfcHJvdG8ub25CdWZmZXJGbHVzaGluZyA9IGZ1bmN0aW9uIG9uQnVmZmVyRmx1c2hpbmcoZXZlbnQsIGRhdGEpIHtcbiAgICB2YXIgc3RhcnRPZmZzZXQgPSBkYXRhLnN0YXJ0T2Zmc2V0LFxuICAgICAgICBlbmRPZmZzZXQgPSBkYXRhLmVuZE9mZnNldDtcblxuICAgIGlmIChzdGFydE9mZnNldCA9PT0gMCAmJiBlbmRPZmZzZXQgIT09IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSkge1xuICAgICAgdmFyIGN1cnJlbnRUcmFja0lkID0gdGhpcy5jdXJyZW50VHJhY2tJZCxcbiAgICAgICAgICBsZXZlbHMgPSB0aGlzLmxldmVscztcblxuICAgICAgaWYgKCFsZXZlbHMubGVuZ3RoIHx8ICFsZXZlbHNbY3VycmVudFRyYWNrSWRdIHx8ICFsZXZlbHNbY3VycmVudFRyYWNrSWRdLmRldGFpbHMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgdHJhY2tEZXRhaWxzID0gbGV2ZWxzW2N1cnJlbnRUcmFja0lkXS5kZXRhaWxzO1xuICAgICAgdmFyIHRhcmdldER1cmF0aW9uID0gdHJhY2tEZXRhaWxzLnRhcmdldGR1cmF0aW9uO1xuICAgICAgdmFyIGVuZE9mZnNldFN1YnRpdGxlcyA9IGVuZE9mZnNldCAtIHRhcmdldER1cmF0aW9uO1xuXG4gICAgICBpZiAoZW5kT2Zmc2V0U3VidGl0bGVzIDw9IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBkYXRhLmVuZE9mZnNldFN1YnRpdGxlcyA9IE1hdGgubWF4KDAsIGVuZE9mZnNldFN1YnRpdGxlcyk7XG4gICAgICB0aGlzLnRyYWNrc0J1ZmZlcmVkLmZvckVhY2goZnVuY3Rpb24gKGJ1ZmZlcmVkKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnVmZmVyZWQubGVuZ3RoOykge1xuICAgICAgICAgIGlmIChidWZmZXJlZFtpXS5lbmQgPD0gZW5kT2Zmc2V0U3VidGl0bGVzKSB7XG4gICAgICAgICAgICBidWZmZXJlZC5zaGlmdCgpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfSBlbHNlIGlmIChidWZmZXJlZFtpXS5zdGFydCA8IGVuZE9mZnNldFN1YnRpdGxlcykge1xuICAgICAgICAgICAgYnVmZmVyZWRbaV0uc3RhcnQgPSBlbmRPZmZzZXRTdWJ0aXRsZXM7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5yZW1vdmVGcmFnbWVudHNJblJhbmdlKHN0YXJ0T2Zmc2V0LCBlbmRPZmZzZXRTdWJ0aXRsZXMsIF90eXBlc19sb2FkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1tcIlBsYXlsaXN0TGV2ZWxUeXBlXCJdLlNVQlRJVExFKTtcbiAgICB9XG4gIH0gLy8gSWYgc29tZXRoaW5nIGdvZXMgd3JvbmcsIHByb2NlZWQgdG8gbmV4dCBmcmFnLCBpZiB3ZSB3ZXJlIHByb2Nlc3Npbmcgb25lLlxuICA7XG5cbiAgX3Byb3RvLm9uRXJyb3IgPSBmdW5jdGlvbiBvbkVycm9yKGV2ZW50LCBkYXRhKSB7XG4gICAgdmFyIF90aGlzJGZyYWdDdXJyZW50O1xuXG4gICAgdmFyIGZyYWcgPSBkYXRhLmZyYWc7IC8vIGRvbid0IGhhbmRsZSBlcnJvciBub3QgcmVsYXRlZCB0byBzdWJ0aXRsZSBmcmFnbWVudFxuXG4gICAgaWYgKCFmcmFnIHx8IGZyYWcudHlwZSAhPT0gX3R5cGVzX2xvYWRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fW1wiUGxheWxpc3RMZXZlbFR5cGVcIl0uU1VCVElUTEUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoKF90aGlzJGZyYWdDdXJyZW50ID0gdGhpcy5mcmFnQ3VycmVudCkgIT09IG51bGwgJiYgX3RoaXMkZnJhZ0N1cnJlbnQgIT09IHZvaWQgMCAmJiBfdGhpcyRmcmFnQ3VycmVudC5sb2FkZXIpIHtcbiAgICAgIHRoaXMuZnJhZ0N1cnJlbnQubG9hZGVyLmFib3J0KCk7XG4gICAgfVxuXG4gICAgdGhpcy5zdGF0ZSA9IF9iYXNlX3N0cmVhbV9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXCJTdGF0ZVwiXS5JRExFO1xuICB9IC8vIEdvdCBhbGwgbmV3IHN1YnRpdGxlIGxldmVscy5cbiAgO1xuXG4gIF9wcm90by5vblN1YnRpdGxlVHJhY2tzVXBkYXRlZCA9IGZ1bmN0aW9uIG9uU3VidGl0bGVUcmFja3NVcGRhdGVkKGV2ZW50LCBfcmVmKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICB2YXIgc3VidGl0bGVUcmFja3MgPSBfcmVmLnN1YnRpdGxlVHJhY2tzO1xuICAgIHRoaXMudHJhY2tzQnVmZmVyZWQgPSBbXTtcbiAgICB0aGlzLmxldmVscyA9IHN1YnRpdGxlVHJhY2tzLm1hcChmdW5jdGlvbiAobWVkaWFQbGF5bGlzdCkge1xuICAgICAgcmV0dXJuIG5ldyBfdHlwZXNfbGV2ZWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzhfX1tcIkxldmVsXCJdKG1lZGlhUGxheWxpc3QpO1xuICAgIH0pO1xuICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyLnJlbW92ZUFsbEZyYWdtZW50cygpO1xuICAgIHRoaXMuZnJhZ1ByZXZpb3VzID0gbnVsbDtcbiAgICB0aGlzLmxldmVscy5mb3JFYWNoKGZ1bmN0aW9uIChsZXZlbCkge1xuICAgICAgX3RoaXMyLnRyYWNrc0J1ZmZlcmVkW2xldmVsLmlkXSA9IFtdO1xuICAgIH0pO1xuICAgIHRoaXMubWVkaWFCdWZmZXIgPSBudWxsO1xuICB9O1xuXG4gIF9wcm90by5vblN1YnRpdGxlVHJhY2tTd2l0Y2ggPSBmdW5jdGlvbiBvblN1YnRpdGxlVHJhY2tTd2l0Y2goZXZlbnQsIGRhdGEpIHtcbiAgICB0aGlzLmN1cnJlbnRUcmFja0lkID0gZGF0YS5pZDtcblxuICAgIGlmICghdGhpcy5sZXZlbHMubGVuZ3RoIHx8IHRoaXMuY3VycmVudFRyYWNrSWQgPT09IC0xKSB7XG4gICAgICB0aGlzLmNsZWFySW50ZXJ2YWwoKTtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIENoZWNrIGlmIHRyYWNrIGhhcyB0aGUgbmVjZXNzYXJ5IGRldGFpbHMgdG8gbG9hZCBmcmFnbWVudHNcblxuXG4gICAgdmFyIGN1cnJlbnRUcmFjayA9IHRoaXMubGV2ZWxzW3RoaXMuY3VycmVudFRyYWNrSWRdO1xuXG4gICAgaWYgKGN1cnJlbnRUcmFjayAhPT0gbnVsbCAmJiBjdXJyZW50VHJhY2sgIT09IHZvaWQgMCAmJiBjdXJyZW50VHJhY2suZGV0YWlscykge1xuICAgICAgdGhpcy5tZWRpYUJ1ZmZlciA9IHRoaXMubWVkaWFCdWZmZXJUaW1lUmFuZ2VzO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm1lZGlhQnVmZmVyID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoY3VycmVudFRyYWNrKSB7XG4gICAgICB0aGlzLnNldEludGVydmFsKFRJQ0tfSU5URVJWQUwpO1xuICAgIH1cbiAgfSAvLyBHb3QgYSBuZXcgc2V0IG9mIHN1YnRpdGxlIGZyYWdtZW50cy5cbiAgO1xuXG4gIF9wcm90by5vblN1YnRpdGxlVHJhY2tMb2FkZWQgPSBmdW5jdGlvbiBvblN1YnRpdGxlVHJhY2tMb2FkZWQoZXZlbnQsIGRhdGEpIHtcbiAgICB2YXIgX3RyYWNrJGRldGFpbHM7XG5cbiAgICB2YXIgbmV3RGV0YWlscyA9IGRhdGEuZGV0YWlscyxcbiAgICAgICAgdHJhY2tJZCA9IGRhdGEuaWQ7XG4gICAgdmFyIGN1cnJlbnRUcmFja0lkID0gdGhpcy5jdXJyZW50VHJhY2tJZCxcbiAgICAgICAgbGV2ZWxzID0gdGhpcy5sZXZlbHM7XG5cbiAgICBpZiAoIWxldmVscy5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgdHJhY2sgPSBsZXZlbHNbY3VycmVudFRyYWNrSWRdO1xuXG4gICAgaWYgKHRyYWNrSWQgPj0gbGV2ZWxzLmxlbmd0aCB8fCB0cmFja0lkICE9PSBjdXJyZW50VHJhY2tJZCB8fCAhdHJhY2spIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLm1lZGlhQnVmZmVyID0gdGhpcy5tZWRpYUJ1ZmZlclRpbWVSYW5nZXM7XG5cbiAgICBpZiAobmV3RGV0YWlscy5saXZlIHx8IChfdHJhY2skZGV0YWlscyA9IHRyYWNrLmRldGFpbHMpICE9PSBudWxsICYmIF90cmFjayRkZXRhaWxzICE9PSB2b2lkIDAgJiYgX3RyYWNrJGRldGFpbHMubGl2ZSkge1xuICAgICAgdmFyIG1haW5EZXRhaWxzID0gdGhpcy5tYWluRGV0YWlscztcblxuICAgICAgaWYgKG5ld0RldGFpbHMuZGVsdGFVcGRhdGVGYWlsZWQgfHwgIW1haW5EZXRhaWxzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIG1haW5TbGlkaW5nU3RhcnRGcmFnbWVudCA9IG1haW5EZXRhaWxzLmZyYWdtZW50c1swXTtcblxuICAgICAgaWYgKCF0cmFjay5kZXRhaWxzKSB7XG4gICAgICAgIGlmIChuZXdEZXRhaWxzLmhhc1Byb2dyYW1EYXRlVGltZSAmJiBtYWluRGV0YWlscy5oYXNQcm9ncmFtRGF0ZVRpbWUpIHtcbiAgICAgICAgICBPYmplY3QoX3V0aWxzX2Rpc2NvbnRpbnVpdGllc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiYWxpZ25NZWRpYVBsYXlsaXN0QnlQRFRcIl0pKG5ld0RldGFpbHMsIG1haW5EZXRhaWxzKTtcbiAgICAgICAgfSBlbHNlIGlmIChtYWluU2xpZGluZ1N0YXJ0RnJhZ21lbnQpIHtcbiAgICAgICAgICAvLyBsaW5lIHVwIGxpdmUgcGxheWxpc3Qgd2l0aCBtYWluIHNvIHRoYXQgZnJhZ21lbnRzIGluIHJhbmdlIGFyZSBsb2FkZWRcbiAgICAgICAgICBPYmplY3QoX2xldmVsX2hlbHBlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fW1wiYWRkU2xpZGluZ1wiXSkobmV3RGV0YWlscywgbWFpblNsaWRpbmdTdGFydEZyYWdtZW50LnN0YXJ0KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHNsaWRpbmcgPSB0aGlzLmFsaWduUGxheWxpc3RzKG5ld0RldGFpbHMsIHRyYWNrLmRldGFpbHMpO1xuXG4gICAgICAgIGlmIChzbGlkaW5nID09PSAwICYmIG1haW5TbGlkaW5nU3RhcnRGcmFnbWVudCkge1xuICAgICAgICAgIC8vIHJlYWxpZ24gd2l0aCBtYWluIHdoZW4gdGhlcmUgaXMgbm8gb3ZlcmxhcCB3aXRoIGxhc3QgcmVmcmVzaFxuICAgICAgICAgIE9iamVjdChfbGV2ZWxfaGVscGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXCJhZGRTbGlkaW5nXCJdKShuZXdEZXRhaWxzLCBtYWluU2xpZGluZ1N0YXJ0RnJhZ21lbnQuc3RhcnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdHJhY2suZGV0YWlscyA9IG5ld0RldGFpbHM7XG4gICAgdGhpcy5sZXZlbExhc3RMb2FkZWQgPSB0cmFja0lkOyAvLyB0cmlnZ2VyIGhhbmRsZXIgcmlnaHQgbm93XG5cbiAgICB0aGlzLnRpY2soKTsgLy8gSWYgcGxheWxpc3QgaXMgbWlzYWxpZ25lZCBiZWNhdXNlIG9mIGJhZCBQRFQgb3IgZHJpZnQsIGRlbGV0ZSBkZXRhaWxzIHRvIHJlc3luYyB3aXRoIG1haW4gb24gcmVsb2FkXG5cbiAgICBpZiAobmV3RGV0YWlscy5saXZlICYmICF0aGlzLmZyYWdDdXJyZW50ICYmIHRoaXMubWVkaWEgJiYgdGhpcy5zdGF0ZSA9PT0gX2Jhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcIlN0YXRlXCJdLklETEUpIHtcbiAgICAgIHZhciBmb3VuZEZyYWcgPSBPYmplY3QoX2ZyYWdtZW50X2ZpbmRlcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImZpbmRGcmFnbWVudEJ5UFRTXCJdKShudWxsLCBuZXdEZXRhaWxzLmZyYWdtZW50cywgdGhpcy5tZWRpYS5jdXJyZW50VGltZSwgMCk7XG5cbiAgICAgIGlmICghZm91bmRGcmFnKSB7XG4gICAgICAgIHRoaXMud2FybignU3VidGl0bGUgcGxheWxpc3Qgbm90IGFsaWduZWQgd2l0aCBwbGF5YmFjaycpO1xuICAgICAgICB0cmFjay5kZXRhaWxzID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uX2hhbmRsZUZyYWdtZW50TG9hZENvbXBsZXRlID0gZnVuY3Rpb24gX2hhbmRsZUZyYWdtZW50TG9hZENvbXBsZXRlKGZyYWdMb2FkZWREYXRhKSB7XG4gICAgdmFyIGZyYWcgPSBmcmFnTG9hZGVkRGF0YS5mcmFnLFxuICAgICAgICBwYXlsb2FkID0gZnJhZ0xvYWRlZERhdGEucGF5bG9hZDtcbiAgICB2YXIgZGVjcnlwdERhdGEgPSBmcmFnLmRlY3J5cHRkYXRhO1xuICAgIHZhciBobHMgPSB0aGlzLmhscztcblxuICAgIGlmICh0aGlzLmZyYWdDb250ZXh0Q2hhbmdlZChmcmFnKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gY2hlY2sgdG8gc2VlIGlmIHRoZSBwYXlsb2FkIG5lZWRzIHRvIGJlIGRlY3J5cHRlZFxuXG5cbiAgICBpZiAocGF5bG9hZCAmJiBwYXlsb2FkLmJ5dGVMZW5ndGggPiAwICYmIGRlY3J5cHREYXRhICYmIGRlY3J5cHREYXRhLmtleSAmJiBkZWNyeXB0RGF0YS5pdiAmJiBkZWNyeXB0RGF0YS5tZXRob2QgPT09ICdBRVMtMTI4Jykge1xuICAgICAgdmFyIHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpOyAvLyBkZWNyeXB0IHRoZSBzdWJ0aXRsZXNcblxuICAgICAgdGhpcy5kZWNyeXB0ZXIud2ViQ3J5cHRvRGVjcnlwdChuZXcgVWludDhBcnJheShwYXlsb2FkKSwgZGVjcnlwdERhdGEua2V5LmJ1ZmZlciwgZGVjcnlwdERhdGEuaXYuYnVmZmVyKS50aGVuKGZ1bmN0aW9uIChkZWNyeXB0ZWREYXRhKSB7XG4gICAgICAgIHZhciBlbmRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIGhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIkV2ZW50c1wiXS5GUkFHX0RFQ1JZUFRFRCwge1xuICAgICAgICAgIGZyYWc6IGZyYWcsXG4gICAgICAgICAgcGF5bG9hZDogZGVjcnlwdGVkRGF0YSxcbiAgICAgICAgICBzdGF0czoge1xuICAgICAgICAgICAgdHN0YXJ0OiBzdGFydFRpbWUsXG4gICAgICAgICAgICB0ZGVjcnlwdDogZW5kVGltZVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmRvVGljayA9IGZ1bmN0aW9uIGRvVGljaygpIHtcbiAgICBpZiAoIXRoaXMubWVkaWEpIHtcbiAgICAgIHRoaXMuc3RhdGUgPSBfYmFzZV9zdHJlYW1fY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fW1wiU3RhdGVcIl0uSURMRTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gX2Jhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcIlN0YXRlXCJdLklETEUpIHtcbiAgICAgIHZhciBfZm91bmRGcmFnO1xuXG4gICAgICB2YXIgY3VycmVudFRyYWNrSWQgPSB0aGlzLmN1cnJlbnRUcmFja0lkLFxuICAgICAgICAgIGxldmVscyA9IHRoaXMubGV2ZWxzO1xuXG4gICAgICBpZiAoIWxldmVscy5sZW5ndGggfHwgIWxldmVsc1tjdXJyZW50VHJhY2tJZF0gfHwgIWxldmVsc1tjdXJyZW50VHJhY2tJZF0uZGV0YWlscykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIEV4cGFuZCByYW5nZSBvZiBzdWJzIGxvYWRlZCBieSBvbmUgdGFyZ2V0LWR1cmF0aW9uIGluIGVpdGhlciBkaXJlY3Rpb24gdG8gbWFrZSB1cCBmb3IgbWlzYWxpZ25lZCBwbGF5bGlzdHNcblxuXG4gICAgICB2YXIgdHJhY2tEZXRhaWxzID0gbGV2ZWxzW2N1cnJlbnRUcmFja0lkXS5kZXRhaWxzO1xuICAgICAgdmFyIHRhcmdldER1cmF0aW9uID0gdHJhY2tEZXRhaWxzLnRhcmdldGR1cmF0aW9uO1xuICAgICAgdmFyIGNvbmZpZyA9IHRoaXMuY29uZmlnLFxuICAgICAgICAgIG1lZGlhID0gdGhpcy5tZWRpYTtcbiAgICAgIHZhciBidWZmZXJlZEluZm8gPSBfdXRpbHNfYnVmZmVyX2hlbHBlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiQnVmZmVySGVscGVyXCJdLmJ1ZmZlcmVkSW5mbyh0aGlzLm1lZGlhQnVmZmVyVGltZVJhbmdlcywgbWVkaWEuY3VycmVudFRpbWUgLSB0YXJnZXREdXJhdGlvbiwgY29uZmlnLm1heEJ1ZmZlckhvbGUpO1xuICAgICAgdmFyIHRhcmdldEJ1ZmZlclRpbWUgPSBidWZmZXJlZEluZm8uZW5kLFxuICAgICAgICAgIGJ1ZmZlckxlbiA9IGJ1ZmZlcmVkSW5mby5sZW47XG4gICAgICB2YXIgbWF4QnVmTGVuID0gdGhpcy5nZXRNYXhCdWZmZXJMZW5ndGgoKSArIHRhcmdldER1cmF0aW9uO1xuXG4gICAgICBpZiAoYnVmZmVyTGVuID4gbWF4QnVmTGVuKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc29sZS5hc3NlcnQodHJhY2tEZXRhaWxzLCAnU3VidGl0bGUgdHJhY2sgZGV0YWlscyBhcmUgZGVmaW5lZCBvbiBpZGxlIHN1YnRpdGxlIHN0cmVhbSBjb250cm9sbGVyIHRpY2snKTtcbiAgICAgIHZhciBmcmFnbWVudHMgPSB0cmFja0RldGFpbHMuZnJhZ21lbnRzO1xuICAgICAgdmFyIGZyYWdMZW4gPSBmcmFnbWVudHMubGVuZ3RoO1xuICAgICAgdmFyIGVuZCA9IHRyYWNrRGV0YWlscy5lZGdlO1xuICAgICAgdmFyIGZvdW5kRnJhZztcbiAgICAgIHZhciBmcmFnUHJldmlvdXMgPSB0aGlzLmZyYWdQcmV2aW91cztcblxuICAgICAgaWYgKHRhcmdldEJ1ZmZlclRpbWUgPCBlbmQpIHtcbiAgICAgICAgdmFyIG1heEZyYWdMb29rVXBUb2xlcmFuY2UgPSBjb25maWcubWF4RnJhZ0xvb2tVcFRvbGVyYW5jZTtcbiAgICAgICAgZm91bmRGcmFnID0gT2JqZWN0KF9mcmFnbWVudF9maW5kZXJzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJmaW5kRnJhZ21lbnRCeVBUU1wiXSkoZnJhZ1ByZXZpb3VzLCBmcmFnbWVudHMsIHRhcmdldEJ1ZmZlclRpbWUsIG1heEZyYWdMb29rVXBUb2xlcmFuY2UpO1xuXG4gICAgICAgIGlmICghZm91bmRGcmFnICYmIGZyYWdQcmV2aW91cyAmJiBmcmFnUHJldmlvdXMuc3RhcnQgPCBmcmFnbWVudHNbMF0uc3RhcnQpIHtcbiAgICAgICAgICBmb3VuZEZyYWcgPSBmcmFnbWVudHNbMF07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvdW5kRnJhZyA9IGZyYWdtZW50c1tmcmFnTGVuIC0gMV07XG4gICAgICB9XG5cbiAgICAgIGlmICgoX2ZvdW5kRnJhZyA9IGZvdW5kRnJhZykgIT09IG51bGwgJiYgX2ZvdW5kRnJhZyAhPT0gdm9pZCAwICYmIF9mb3VuZEZyYWcuZW5jcnlwdGVkKSB7XG4gICAgICAgIHRoaXMubG9hZEtleShmb3VuZEZyYWcsIHRyYWNrRGV0YWlscyk7XG4gICAgICB9IGVsc2UgaWYgKGZvdW5kRnJhZyAmJiB0aGlzLmZyYWdtZW50VHJhY2tlci5nZXRTdGF0ZShmb3VuZEZyYWcpID09PSBfZnJhZ21lbnRfdHJhY2tlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1wiRnJhZ21lbnRTdGF0ZVwiXS5OT1RfTE9BREVEKSB7XG4gICAgICAgIC8vIG9ubHkgbG9hZCBpZiBmcmFnbWVudCBpcyBub3QgbG9hZGVkXG4gICAgICAgIHRoaXMubG9hZEZyYWdtZW50KGZvdW5kRnJhZywgdHJhY2tEZXRhaWxzLCB0YXJnZXRCdWZmZXJUaW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmxvYWRGcmFnbWVudCA9IGZ1bmN0aW9uIGxvYWRGcmFnbWVudChmcmFnLCBsZXZlbERldGFpbHMsIHRhcmdldEJ1ZmZlclRpbWUpIHtcbiAgICB0aGlzLmZyYWdDdXJyZW50ID0gZnJhZztcblxuICAgIF9CYXNlU3RyZWFtQ29udHJvbGxlci5wcm90b3R5cGUubG9hZEZyYWdtZW50LmNhbGwodGhpcywgZnJhZywgbGV2ZWxEZXRhaWxzLCB0YXJnZXRCdWZmZXJUaW1lKTtcbiAgfTtcblxuICBfY3JlYXRlQ2xhc3MoU3VidGl0bGVTdHJlYW1Db250cm9sbGVyLCBbe1xuICAgIGtleTogXCJtZWRpYUJ1ZmZlclRpbWVSYW5nZXNcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnRyYWNrc0J1ZmZlcmVkW3RoaXMuY3VycmVudFRyYWNrSWRdIHx8IFtdO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBTdWJ0aXRsZVN0cmVhbUNvbnRyb2xsZXI7XG59KF9iYXNlX3N0cmVhbV9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXCJkZWZhdWx0XCJdKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY29udHJvbGxlci9zdWJ0aXRsZS10cmFjay1jb250cm9sbGVyLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9jb250cm9sbGVyL3N1YnRpdGxlLXRyYWNrLWNvbnRyb2xsZXIudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZXZlbnRzICovIFwiLi9zcmMvZXZlbnRzLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc190ZXh0dHJhY2tfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL3RleHR0cmFjay11dGlscyAqLyBcIi4vc3JjL3V0aWxzL3RleHR0cmFjay11dGlscy50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfYmFzZV9wbGF5bGlzdF9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2Jhc2UtcGxheWxpc3QtY29udHJvbGxlciAqLyBcIi4vc3JjL2NvbnRyb2xsZXIvYmFzZS1wbGF5bGlzdC1jb250cm9sbGVyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF90eXBlc19sb2FkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3R5cGVzL2xvYWRlciAqLyBcIi4vc3JjL3R5cGVzL2xvYWRlci50c1wiKTtcbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7IHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzOyBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cblxuXG5cblxuXG52YXIgU3VidGl0bGVUcmFja0NvbnRyb2xsZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9CYXNlUGxheWxpc3RDb250cm9sbCkge1xuICBfaW5oZXJpdHNMb29zZShTdWJ0aXRsZVRyYWNrQ29udHJvbGxlciwgX0Jhc2VQbGF5bGlzdENvbnRyb2xsKTtcblxuICAvLyBFbmFibGUvZGlzYWJsZSBzdWJ0aXRsZSBkaXNwbGF5IHJlbmRlcmluZ1xuICBmdW5jdGlvbiBTdWJ0aXRsZVRyYWNrQ29udHJvbGxlcihobHMpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfdGhpcyA9IF9CYXNlUGxheWxpc3RDb250cm9sbC5jYWxsKHRoaXMsIGhscywgJ1tzdWJ0aXRsZS10cmFjay1jb250cm9sbGVyXScpIHx8IHRoaXM7XG4gICAgX3RoaXMubWVkaWEgPSBudWxsO1xuICAgIF90aGlzLnRyYWNrcyA9IFtdO1xuICAgIF90aGlzLmdyb3VwSWQgPSBudWxsO1xuICAgIF90aGlzLnRyYWNrc0luR3JvdXAgPSBbXTtcbiAgICBfdGhpcy50cmFja0lkID0gLTE7XG4gICAgX3RoaXMuc2VsZWN0RGVmYXVsdFRyYWNrID0gdHJ1ZTtcbiAgICBfdGhpcy5xdWV1ZWREZWZhdWx0VHJhY2sgPSAtMTtcblxuICAgIF90aGlzLnRyYWNrQ2hhbmdlTGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX3RoaXMub25UZXh0VHJhY2tzQ2hhbmdlZCgpO1xuICAgIH07XG5cbiAgICBfdGhpcy5hc3luY1BvbGxUcmFja0NoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfdGhpcy5wb2xsVHJhY2tDaGFuZ2UoMCk7XG4gICAgfTtcblxuICAgIF90aGlzLnVzZVRleHRUcmFja1BvbGxpbmcgPSBmYWxzZTtcbiAgICBfdGhpcy5zdWJ0aXRsZVBvbGxpbmdJbnRlcnZhbCA9IC0xO1xuICAgIF90aGlzLnN1YnRpdGxlRGlzcGxheSA9IHRydWU7XG5cbiAgICBfdGhpcy5yZWdpc3Rlckxpc3RlbmVycygpO1xuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFN1YnRpdGxlVHJhY2tDb250cm9sbGVyLnByb3RvdHlwZTtcblxuICBfcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgdGhpcy51bnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gICAgdGhpcy50cmFja3MubGVuZ3RoID0gMDtcbiAgICB0aGlzLnRyYWNrc0luR3JvdXAubGVuZ3RoID0gMDtcbiAgICB0aGlzLnRyYWNrQ2hhbmdlTGlzdGVuZXIgPSB0aGlzLmFzeW5jUG9sbFRyYWNrQ2hhbmdlID0gbnVsbDtcblxuICAgIF9CYXNlUGxheWxpc3RDb250cm9sbC5wcm90b3R5cGUuZGVzdHJveS5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIF9wcm90by5yZWdpc3Rlckxpc3RlbmVycyA9IGZ1bmN0aW9uIHJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIHZhciBobHMgPSB0aGlzLmhscztcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiRXZlbnRzXCJdLk1FRElBX0FUVEFDSEVELCB0aGlzLm9uTWVkaWFBdHRhY2hlZCwgdGhpcyk7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIkV2ZW50c1wiXS5NRURJQV9ERVRBQ0hJTkcsIHRoaXMub25NZWRpYURldGFjaGluZywgdGhpcyk7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIkV2ZW50c1wiXS5NQU5JRkVTVF9MT0FESU5HLCB0aGlzLm9uTWFuaWZlc3RMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiRXZlbnRzXCJdLk1BTklGRVNUX1BBUlNFRCwgdGhpcy5vbk1hbmlmZXN0UGFyc2VkLCB0aGlzKTtcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiRXZlbnRzXCJdLkxFVkVMX0xPQURJTkcsIHRoaXMub25MZXZlbExvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJFdmVudHNcIl0uTEVWRUxfU1dJVENISU5HLCB0aGlzLm9uTGV2ZWxTd2l0Y2hpbmcsIHRoaXMpO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJFdmVudHNcIl0uU1VCVElUTEVfVFJBQ0tfTE9BREVELCB0aGlzLm9uU3VidGl0bGVUcmFja0xvYWRlZCwgdGhpcyk7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIkV2ZW50c1wiXS5FUlJPUiwgdGhpcy5vbkVycm9yLCB0aGlzKTtcbiAgfTtcblxuICBfcHJvdG8udW5yZWdpc3Rlckxpc3RlbmVycyA9IGZ1bmN0aW9uIHVucmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgdmFyIGhscyA9IHRoaXMuaGxzO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiRXZlbnRzXCJdLk1FRElBX0FUVEFDSEVELCB0aGlzLm9uTWVkaWFBdHRhY2hlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJFdmVudHNcIl0uTUVESUFfREVUQUNISU5HLCB0aGlzLm9uTWVkaWFEZXRhY2hpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiRXZlbnRzXCJdLk1BTklGRVNUX0xPQURJTkcsIHRoaXMub25NYW5pZmVzdExvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiRXZlbnRzXCJdLk1BTklGRVNUX1BBUlNFRCwgdGhpcy5vbk1hbmlmZXN0UGFyc2VkLCB0aGlzKTtcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIkV2ZW50c1wiXS5MRVZFTF9MT0FESU5HLCB0aGlzLm9uTGV2ZWxMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIkV2ZW50c1wiXS5MRVZFTF9TV0lUQ0hJTkcsIHRoaXMub25MZXZlbFN3aXRjaGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJFdmVudHNcIl0uU1VCVElUTEVfVFJBQ0tfTE9BREVELCB0aGlzLm9uU3VidGl0bGVUcmFja0xvYWRlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJFdmVudHNcIl0uRVJST1IsIHRoaXMub25FcnJvciwgdGhpcyk7XG4gIH0gLy8gTGlzdGVuIGZvciBzdWJ0aXRsZSB0cmFjayBjaGFuZ2UsIHRoZW4gZXh0cmFjdCB0aGUgY3VycmVudCB0cmFjayBJRC5cbiAgO1xuXG4gIF9wcm90by5vbk1lZGlhQXR0YWNoZWQgPSBmdW5jdGlvbiBvbk1lZGlhQXR0YWNoZWQoZXZlbnQsIGRhdGEpIHtcbiAgICB0aGlzLm1lZGlhID0gZGF0YS5tZWRpYTtcblxuICAgIGlmICghdGhpcy5tZWRpYSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnF1ZXVlZERlZmF1bHRUcmFjayA+IC0xKSB7XG4gICAgICB0aGlzLnN1YnRpdGxlVHJhY2sgPSB0aGlzLnF1ZXVlZERlZmF1bHRUcmFjaztcbiAgICAgIHRoaXMucXVldWVkRGVmYXVsdFRyYWNrID0gLTE7XG4gICAgfVxuXG4gICAgdGhpcy51c2VUZXh0VHJhY2tQb2xsaW5nID0gISh0aGlzLm1lZGlhLnRleHRUcmFja3MgJiYgJ29uY2hhbmdlJyBpbiB0aGlzLm1lZGlhLnRleHRUcmFja3MpO1xuXG4gICAgaWYgKHRoaXMudXNlVGV4dFRyYWNrUG9sbGluZykge1xuICAgICAgdGhpcy5wb2xsVHJhY2tDaGFuZ2UoNTAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5tZWRpYS50ZXh0VHJhY2tzLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHRoaXMuYXN5bmNQb2xsVHJhY2tDaGFuZ2UpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8ucG9sbFRyYWNrQ2hhbmdlID0gZnVuY3Rpb24gcG9sbFRyYWNrQ2hhbmdlKHRpbWVvdXQpIHtcbiAgICBzZWxmLmNsZWFySW50ZXJ2YWwodGhpcy5zdWJ0aXRsZVBvbGxpbmdJbnRlcnZhbCk7XG4gICAgdGhpcy5zdWJ0aXRsZVBvbGxpbmdJbnRlcnZhbCA9IHNlbGYuc2V0SW50ZXJ2YWwodGhpcy50cmFja0NoYW5nZUxpc3RlbmVyLCB0aW1lb3V0KTtcbiAgfTtcblxuICBfcHJvdG8ub25NZWRpYURldGFjaGluZyA9IGZ1bmN0aW9uIG9uTWVkaWFEZXRhY2hpbmcoKSB7XG4gICAgaWYgKCF0aGlzLm1lZGlhKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc2VsZi5jbGVhckludGVydmFsKHRoaXMuc3VidGl0bGVQb2xsaW5nSW50ZXJ2YWwpO1xuXG4gICAgaWYgKCF0aGlzLnVzZVRleHRUcmFja1BvbGxpbmcpIHtcbiAgICAgIHRoaXMubWVkaWEudGV4dFRyYWNrcy5yZW1vdmVFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB0aGlzLmFzeW5jUG9sbFRyYWNrQ2hhbmdlKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy50cmFja0lkID4gLTEpIHtcbiAgICAgIHRoaXMucXVldWVkRGVmYXVsdFRyYWNrID0gdGhpcy50cmFja0lkO1xuICAgIH1cblxuICAgIHZhciB0ZXh0VHJhY2tzID0gZmlsdGVyU3VidGl0bGVUcmFja3ModGhpcy5tZWRpYS50ZXh0VHJhY2tzKTsgLy8gQ2xlYXIgbG9hZGVkIGN1ZXMgb24gbWVkaWEgZGV0YWNobWVudCBmcm9tIHRyYWNrc1xuXG4gICAgdGV4dFRyYWNrcy5mb3JFYWNoKGZ1bmN0aW9uICh0cmFjaykge1xuICAgICAgT2JqZWN0KF91dGlsc190ZXh0dHJhY2tfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImNsZWFyQ3VycmVudEN1ZXNcIl0pKHRyYWNrKTtcbiAgICB9KTsgLy8gRGlzYWJsZSBhbGwgc3VidGl0bGUgdHJhY2tzIGJlZm9yZSBkZXRhY2htZW50IHNvIHdoZW4gcmVhdHRhY2hlZCBvbmx5IHRyYWNrcyBpbiB0aGF0IGNvbnRlbnQgYXJlIGVuYWJsZWQuXG5cbiAgICB0aGlzLnN1YnRpdGxlVHJhY2sgPSAtMTtcbiAgICB0aGlzLm1lZGlhID0gbnVsbDtcbiAgfTtcblxuICBfcHJvdG8ub25NYW5pZmVzdExvYWRpbmcgPSBmdW5jdGlvbiBvbk1hbmlmZXN0TG9hZGluZygpIHtcbiAgICB0aGlzLnRyYWNrcyA9IFtdO1xuICAgIHRoaXMuZ3JvdXBJZCA9IG51bGw7XG4gICAgdGhpcy50cmFja3NJbkdyb3VwID0gW107XG4gICAgdGhpcy50cmFja0lkID0gLTE7XG4gICAgdGhpcy5zZWxlY3REZWZhdWx0VHJhY2sgPSB0cnVlO1xuICB9IC8vIEZpcmVkIHdoZW5ldmVyIGEgbmV3IG1hbmlmZXN0IGlzIGxvYWRlZC5cbiAgO1xuXG4gIF9wcm90by5vbk1hbmlmZXN0UGFyc2VkID0gZnVuY3Rpb24gb25NYW5pZmVzdFBhcnNlZChldmVudCwgZGF0YSkge1xuICAgIHRoaXMudHJhY2tzID0gZGF0YS5zdWJ0aXRsZVRyYWNrcztcbiAgfTtcblxuICBfcHJvdG8ub25TdWJ0aXRsZVRyYWNrTG9hZGVkID0gZnVuY3Rpb24gb25TdWJ0aXRsZVRyYWNrTG9hZGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgdmFyIGlkID0gZGF0YS5pZCxcbiAgICAgICAgZGV0YWlscyA9IGRhdGEuZGV0YWlscztcbiAgICB2YXIgdHJhY2tJZCA9IHRoaXMudHJhY2tJZDtcbiAgICB2YXIgY3VycmVudFRyYWNrID0gdGhpcy50cmFja3NJbkdyb3VwW3RyYWNrSWRdO1xuXG4gICAgaWYgKCFjdXJyZW50VHJhY2spIHtcbiAgICAgIHRoaXMud2FybihcIkludmFsaWQgc3VidGl0bGUgdHJhY2sgaWQgXCIgKyBpZCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGN1ckRldGFpbHMgPSBjdXJyZW50VHJhY2suZGV0YWlscztcbiAgICBjdXJyZW50VHJhY2suZGV0YWlscyA9IGRhdGEuZGV0YWlscztcbiAgICB0aGlzLmxvZyhcInN1YnRpdGxlIHRyYWNrIFwiICsgaWQgKyBcIiBsb2FkZWQgW1wiICsgZGV0YWlscy5zdGFydFNOICsgXCItXCIgKyBkZXRhaWxzLmVuZFNOICsgXCJdXCIpO1xuXG4gICAgaWYgKGlkID09PSB0aGlzLnRyYWNrSWQpIHtcbiAgICAgIHRoaXMucmV0cnlDb3VudCA9IDA7XG4gICAgICB0aGlzLnBsYXlsaXN0TG9hZGVkKGlkLCBkYXRhLCBjdXJEZXRhaWxzKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLm9uTGV2ZWxMb2FkaW5nID0gZnVuY3Rpb24gb25MZXZlbExvYWRpbmcoZXZlbnQsIGRhdGEpIHtcbiAgICB0aGlzLnN3aXRjaExldmVsKGRhdGEubGV2ZWwpO1xuICB9O1xuXG4gIF9wcm90by5vbkxldmVsU3dpdGNoaW5nID0gZnVuY3Rpb24gb25MZXZlbFN3aXRjaGluZyhldmVudCwgZGF0YSkge1xuICAgIHRoaXMuc3dpdGNoTGV2ZWwoZGF0YS5sZXZlbCk7XG4gIH07XG5cbiAgX3Byb3RvLnN3aXRjaExldmVsID0gZnVuY3Rpb24gc3dpdGNoTGV2ZWwobGV2ZWxJbmRleCkge1xuICAgIHZhciBsZXZlbEluZm8gPSB0aGlzLmhscy5sZXZlbHNbbGV2ZWxJbmRleF07XG5cbiAgICBpZiAoIShsZXZlbEluZm8gIT09IG51bGwgJiYgbGV2ZWxJbmZvICE9PSB2b2lkIDAgJiYgbGV2ZWxJbmZvLnRleHRHcm91cElkcykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgdGV4dEdyb3VwSWQgPSBsZXZlbEluZm8udGV4dEdyb3VwSWRzW2xldmVsSW5mby51cmxJZF07XG5cbiAgICBpZiAodGhpcy5ncm91cElkICE9PSB0ZXh0R3JvdXBJZCkge1xuICAgICAgdmFyIGxhc3RUcmFjayA9IHRoaXMudHJhY2tzSW5Hcm91cCA/IHRoaXMudHJhY2tzSW5Hcm91cFt0aGlzLnRyYWNrSWRdIDogdW5kZWZpbmVkO1xuICAgICAgdmFyIHN1YnRpdGxlVHJhY2tzID0gdGhpcy50cmFja3MuZmlsdGVyKGZ1bmN0aW9uICh0cmFjaykge1xuICAgICAgICByZXR1cm4gIXRleHRHcm91cElkIHx8IHRyYWNrLmdyb3VwSWQgPT09IHRleHRHcm91cElkO1xuICAgICAgfSk7XG4gICAgICB0aGlzLnRyYWNrc0luR3JvdXAgPSBzdWJ0aXRsZVRyYWNrcztcbiAgICAgIHZhciBpbml0aWFsVHJhY2tJZCA9IHRoaXMuZmluZFRyYWNrSWQobGFzdFRyYWNrID09PSBudWxsIHx8IGxhc3RUcmFjayA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGFzdFRyYWNrLm5hbWUpIHx8IHRoaXMuZmluZFRyYWNrSWQoKTtcbiAgICAgIHRoaXMuZ3JvdXBJZCA9IHRleHRHcm91cElkO1xuICAgICAgdmFyIHN1YnRpdGxlVHJhY2tzVXBkYXRlZCA9IHtcbiAgICAgICAgc3VidGl0bGVUcmFja3M6IHN1YnRpdGxlVHJhY2tzXG4gICAgICB9O1xuICAgICAgdGhpcy5sb2coXCJVcGRhdGluZyBzdWJ0aXRsZSB0cmFja3MsIFwiICsgc3VidGl0bGVUcmFja3MubGVuZ3RoICsgXCIgdHJhY2socykgZm91bmQgaW4gXFxcIlwiICsgdGV4dEdyb3VwSWQgKyBcIlxcXCIgZ3JvdXAtaWRcIik7XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIkV2ZW50c1wiXS5TVUJUSVRMRV9UUkFDS1NfVVBEQVRFRCwgc3VidGl0bGVUcmFja3NVcGRhdGVkKTtcblxuICAgICAgaWYgKGluaXRpYWxUcmFja0lkICE9PSAtMSkge1xuICAgICAgICB0aGlzLnNldFN1YnRpdGxlVHJhY2soaW5pdGlhbFRyYWNrSWQsIGxhc3RUcmFjayk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5maW5kVHJhY2tJZCA9IGZ1bmN0aW9uIGZpbmRUcmFja0lkKG5hbWUpIHtcbiAgICB2YXIgdGV4dFRyYWNrcyA9IHRoaXMudHJhY2tzSW5Hcm91cDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGV4dFRyYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHRyYWNrID0gdGV4dFRyYWNrc1tpXTtcblxuICAgICAgaWYgKCF0aGlzLnNlbGVjdERlZmF1bHRUcmFjayB8fCB0cmFjay5kZWZhdWx0KSB7XG4gICAgICAgIGlmICghbmFtZSB8fCBuYW1lID09PSB0cmFjay5uYW1lKSB7XG4gICAgICAgICAgcmV0dXJuIHRyYWNrLmlkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIC0xO1xuICB9O1xuXG4gIF9wcm90by5vbkVycm9yID0gZnVuY3Rpb24gb25FcnJvcihldmVudCwgZGF0YSkge1xuICAgIF9CYXNlUGxheWxpc3RDb250cm9sbC5wcm90b3R5cGUub25FcnJvci5jYWxsKHRoaXMsIGV2ZW50LCBkYXRhKTtcblxuICAgIGlmIChkYXRhLmZhdGFsIHx8ICFkYXRhLmNvbnRleHQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZGF0YS5jb250ZXh0LnR5cGUgPT09IF90eXBlc19sb2FkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcIlBsYXlsaXN0Q29udGV4dFR5cGVcIl0uU1VCVElUTEVfVFJBQ0sgJiYgZGF0YS5jb250ZXh0LmlkID09PSB0aGlzLnRyYWNrSWQgJiYgZGF0YS5jb250ZXh0Lmdyb3VwSWQgPT09IHRoaXMuZ3JvdXBJZCkge1xuICAgICAgdGhpcy5yZXRyeUxvYWRpbmdPckZhaWwoZGF0YSk7XG4gICAgfVxuICB9XG4gIC8qKiBnZXQgYWx0ZXJuYXRlIHN1YnRpdGxlIHRyYWNrcyBsaXN0IGZyb20gcGxheWxpc3QgKiovXG4gIDtcblxuICBfcHJvdG8ubG9hZFBsYXlsaXN0ID0gZnVuY3Rpb24gbG9hZFBsYXlsaXN0KGhsc1VybFBhcmFtZXRlcnMpIHtcbiAgICB2YXIgY3VycmVudFRyYWNrID0gdGhpcy50cmFja3NJbkdyb3VwW3RoaXMudHJhY2tJZF07XG5cbiAgICBpZiAodGhpcy5zaG91bGRMb2FkVHJhY2soY3VycmVudFRyYWNrKSkge1xuICAgICAgdmFyIGlkID0gY3VycmVudFRyYWNrLmlkO1xuICAgICAgdmFyIGdyb3VwSWQgPSBjdXJyZW50VHJhY2suZ3JvdXBJZDtcbiAgICAgIHZhciB1cmwgPSBjdXJyZW50VHJhY2sudXJsO1xuXG4gICAgICBpZiAoaGxzVXJsUGFyYW1ldGVycykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHVybCA9IGhsc1VybFBhcmFtZXRlcnMuYWRkRGlyZWN0aXZlcyh1cmwpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIHRoaXMud2FybihcIkNvdWxkIG5vdCBjb25zdHJ1Y3QgbmV3IFVSTCB3aXRoIEhMUyBEZWxpdmVyeSBEaXJlY3RpdmVzOiBcIiArIGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLmxvZyhcIkxvYWRpbmcgc3VidGl0bGUgcGxheWxpc3QgZm9yIGlkIFwiICsgaWQpO1xuICAgICAgdGhpcy5obHMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJFdmVudHNcIl0uU1VCVElUTEVfVFJBQ0tfTE9BRElORywge1xuICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgaWQ6IGlkLFxuICAgICAgICBncm91cElkOiBncm91cElkLFxuICAgICAgICBkZWxpdmVyeURpcmVjdGl2ZXM6IGhsc1VybFBhcmFtZXRlcnMgfHwgbnVsbFxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBEaXNhYmxlcyB0aGUgb2xkIHN1YnRpdGxlVHJhY2sgYW5kIHNldHMgY3VycmVudCBtb2RlIG9uIHRoZSBuZXh0IHN1YnRpdGxlVHJhY2suXG4gICAqIFRoaXMgb3BlcmF0ZXMgb24gdGhlIERPTSB0ZXh0VHJhY2tzLlxuICAgKiBBIHZhbHVlIG9mIC0xIHdpbGwgZGlzYWJsZSBhbGwgc3VidGl0bGUgdHJhY2tzLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by50b2dnbGVUcmFja01vZGVzID0gZnVuY3Rpb24gdG9nZ2xlVHJhY2tNb2RlcyhuZXdJZCkge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgdmFyIG1lZGlhID0gdGhpcy5tZWRpYSxcbiAgICAgICAgc3VidGl0bGVEaXNwbGF5ID0gdGhpcy5zdWJ0aXRsZURpc3BsYXksXG4gICAgICAgIHRyYWNrSWQgPSB0aGlzLnRyYWNrSWQ7XG5cbiAgICBpZiAoIW1lZGlhKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHRleHRUcmFja3MgPSBmaWx0ZXJTdWJ0aXRsZVRyYWNrcyhtZWRpYS50ZXh0VHJhY2tzKTtcbiAgICB2YXIgZ3JvdXBUcmFja3MgPSB0ZXh0VHJhY2tzLmZpbHRlcihmdW5jdGlvbiAodHJhY2spIHtcbiAgICAgIHJldHVybiB0cmFjay5ncm91cElkID09PSBfdGhpczIuZ3JvdXBJZDtcbiAgICB9KTtcblxuICAgIGlmIChuZXdJZCA9PT0gLTEpIHtcbiAgICAgIFtdLnNsaWNlLmNhbGwodGV4dFRyYWNrcykuZm9yRWFjaChmdW5jdGlvbiAodHJhY2spIHtcbiAgICAgICAgdHJhY2subW9kZSA9ICdkaXNhYmxlZCc7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG9sZFRyYWNrID0gZ3JvdXBUcmFja3NbdHJhY2tJZF07XG5cbiAgICAgIGlmIChvbGRUcmFjaykge1xuICAgICAgICBvbGRUcmFjay5tb2RlID0gJ2Rpc2FibGVkJztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbmV4dFRyYWNrID0gZ3JvdXBUcmFja3NbbmV3SWRdO1xuXG4gICAgaWYgKG5leHRUcmFjaykge1xuICAgICAgbmV4dFRyYWNrLm1vZGUgPSBzdWJ0aXRsZURpc3BsYXkgPyAnc2hvd2luZycgOiAnaGlkZGVuJztcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIGlzIHJlc3BvbnNpYmxlIGZvciB2YWxpZGF0aW5nIHRoZSBzdWJ0aXRsZSBpbmRleCBhbmQgcGVyaW9kaWNhbGx5IHJlbG9hZGluZyBpZiBsaXZlLlxuICAgKiBEaXNwYXRjaGVzIHRoZSBTVUJUSVRMRV9UUkFDS19TV0lUQ0ggZXZlbnQsIHdoaWNoIGluc3RydWN0cyB0aGUgc3VidGl0bGUtc3RyZWFtLWNvbnRyb2xsZXIgdG8gbG9hZCB0aGUgc2VsZWN0ZWQgdHJhY2suXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnNldFN1YnRpdGxlVHJhY2sgPSBmdW5jdGlvbiBzZXRTdWJ0aXRsZVRyYWNrKG5ld0lkLCBsYXN0VHJhY2spIHtcbiAgICB2YXIgX3RyYWNrcyRuZXdJZDtcblxuICAgIHZhciB0cmFja3MgPSB0aGlzLnRyYWNrc0luR3JvdXA7IC8vIHNldHRpbmcgdGhpcy5zdWJ0aXRsZVRyYWNrIHdpbGwgdHJpZ2dlciBpbnRlcm5hbCBsb2dpY1xuICAgIC8vIGlmIG1lZGlhIGhhcyBub3QgYmVlbiBhdHRhY2hlZCB5ZXQsIGl0IHdpbGwgZmFpbFxuICAgIC8vIHdlIGtlZXAgYSByZWZlcmVuY2UgdG8gdGhlIGRlZmF1bHQgdHJhY2sgaWRcbiAgICAvLyBhbmQgd2UnbGwgc2V0IHN1YnRpdGxlVHJhY2sgd2hlbiBvbk1lZGlhQXR0YWNoZWQgaXMgdHJpZ2dlcmVkXG5cbiAgICBpZiAoIXRoaXMubWVkaWEpIHtcbiAgICAgIHRoaXMucXVldWVkRGVmYXVsdFRyYWNrID0gbmV3SWQ7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMudHJhY2tJZCAhPT0gbmV3SWQpIHtcbiAgICAgIHRoaXMudG9nZ2xlVHJhY2tNb2RlcyhuZXdJZCk7XG4gICAgfSAvLyBleGl0IGlmIHRyYWNrIGlkIGFzIGFscmVhZHkgc2V0IG9yIGludmFsaWRcblxuXG4gICAgaWYgKHRoaXMudHJhY2tJZCA9PT0gbmV3SWQgJiYgKG5ld0lkID09PSAtMSB8fCAoX3RyYWNrcyRuZXdJZCA9IHRyYWNrc1tuZXdJZF0pICE9PSBudWxsICYmIF90cmFja3MkbmV3SWQgIT09IHZvaWQgMCAmJiBfdHJhY2tzJG5ld0lkLmRldGFpbHMpIHx8IG5ld0lkIDwgLTEgfHwgbmV3SWQgPj0gdHJhY2tzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gc3RvcHBpbmcgbGl2ZSByZWxvYWRpbmcgdGltZXIgaWYgYW55XG5cblxuICAgIHRoaXMuY2xlYXJUaW1lcigpO1xuICAgIHZhciB0cmFjayA9IHRyYWNrc1tuZXdJZF07XG4gICAgdGhpcy5sb2coXCJTd2l0Y2hpbmcgdG8gc3VidGl0bGUgdHJhY2sgXCIgKyBuZXdJZCk7XG4gICAgdGhpcy50cmFja0lkID0gbmV3SWQ7XG5cbiAgICBpZiAodHJhY2spIHtcbiAgICAgIHZhciBpZCA9IHRyYWNrLmlkLFxuICAgICAgICAgIF90cmFjayRncm91cElkID0gdHJhY2suZ3JvdXBJZCxcbiAgICAgICAgICBncm91cElkID0gX3RyYWNrJGdyb3VwSWQgPT09IHZvaWQgMCA/ICcnIDogX3RyYWNrJGdyb3VwSWQsXG4gICAgICAgICAgbmFtZSA9IHRyYWNrLm5hbWUsXG4gICAgICAgICAgdHlwZSA9IHRyYWNrLnR5cGUsXG4gICAgICAgICAgdXJsID0gdHJhY2sudXJsO1xuICAgICAgdGhpcy5obHMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJFdmVudHNcIl0uU1VCVElUTEVfVFJBQ0tfU1dJVENILCB7XG4gICAgICAgIGlkOiBpZCxcbiAgICAgICAgZ3JvdXBJZDogZ3JvdXBJZCxcbiAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgdXJsOiB1cmxcbiAgICAgIH0pO1xuICAgICAgdmFyIGhsc1VybFBhcmFtZXRlcnMgPSB0aGlzLnN3aXRjaFBhcmFtcyh0cmFjay51cmwsIGxhc3RUcmFjayA9PT0gbnVsbCB8fCBsYXN0VHJhY2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxhc3RUcmFjay5kZXRhaWxzKTtcbiAgICAgIHRoaXMubG9hZFBsYXlsaXN0KGhsc1VybFBhcmFtZXRlcnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBzd2l0Y2ggdG8gLTFcbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiRXZlbnRzXCJdLlNVQlRJVExFX1RSQUNLX1NXSVRDSCwge1xuICAgICAgICBpZDogbmV3SWRcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8ub25UZXh0VHJhY2tzQ2hhbmdlZCA9IGZ1bmN0aW9uIG9uVGV4dFRyYWNrc0NoYW5nZWQoKSB7XG4gICAgaWYgKCF0aGlzLnVzZVRleHRUcmFja1BvbGxpbmcpIHtcbiAgICAgIHNlbGYuY2xlYXJJbnRlcnZhbCh0aGlzLnN1YnRpdGxlUG9sbGluZ0ludGVydmFsKTtcbiAgICB9IC8vIE1lZGlhIGlzIHVuZGVmaW5lZCB3aGVuIHN3aXRjaGluZyBzdHJlYW1zIHZpYSBsb2FkU291cmNlKClcblxuXG4gICAgaWYgKCF0aGlzLm1lZGlhIHx8ICF0aGlzLmhscy5jb25maWcucmVuZGVyVGV4dFRyYWNrc05hdGl2ZWx5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHRyYWNrSWQgPSAtMTtcbiAgICB2YXIgdHJhY2tzID0gZmlsdGVyU3VidGl0bGVUcmFja3ModGhpcy5tZWRpYS50ZXh0VHJhY2tzKTtcblxuICAgIGZvciAodmFyIGlkID0gMDsgaWQgPCB0cmFja3MubGVuZ3RoOyBpZCsrKSB7XG4gICAgICBpZiAodHJhY2tzW2lkXS5tb2RlID09PSAnaGlkZGVuJykge1xuICAgICAgICAvLyBEbyBub3QgYnJlYWsgaW4gY2FzZSB0aGVyZSBpcyBhIGZvbGxvd2luZyB0cmFjayB3aXRoIHNob3dpbmcuXG4gICAgICAgIHRyYWNrSWQgPSBpZDtcbiAgICAgIH0gZWxzZSBpZiAodHJhY2tzW2lkXS5tb2RlID09PSAnc2hvd2luZycpIHtcbiAgICAgICAgdHJhY2tJZCA9IGlkO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IC8vIFNldHRpbmcgY3VycmVudCBzdWJ0aXRsZVRyYWNrIHdpbGwgaW52b2tlIGNvZGUuXG5cblxuICAgIGlmICh0aGlzLnN1YnRpdGxlVHJhY2sgIT09IHRyYWNrSWQpIHtcbiAgICAgIHRoaXMuc3VidGl0bGVUcmFjayA9IHRyYWNrSWQ7XG4gICAgfVxuICB9O1xuXG4gIF9jcmVhdGVDbGFzcyhTdWJ0aXRsZVRyYWNrQ29udHJvbGxlciwgW3tcbiAgICBrZXk6IFwic3VidGl0bGVUcmFja3NcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnRyYWNrc0luR3JvdXA7XG4gICAgfVxuICAgIC8qKiBnZXQvc2V0IGluZGV4IG9mIHRoZSBzZWxlY3RlZCBzdWJ0aXRsZSB0cmFjayAoYmFzZWQgb24gaW5kZXggaW4gc3VidGl0bGUgdHJhY2sgbGlzdHMpICoqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic3VidGl0bGVUcmFja1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMudHJhY2tJZDtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KG5ld0lkKSB7XG4gICAgICB0aGlzLnNlbGVjdERlZmF1bHRUcmFjayA9IGZhbHNlO1xuICAgICAgdmFyIGxhc3RUcmFjayA9IHRoaXMudHJhY2tzSW5Hcm91cCA/IHRoaXMudHJhY2tzSW5Hcm91cFt0aGlzLnRyYWNrSWRdIDogdW5kZWZpbmVkO1xuICAgICAgdGhpcy5zZXRTdWJ0aXRsZVRyYWNrKG5ld0lkLCBsYXN0VHJhY2spO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBTdWJ0aXRsZVRyYWNrQ29udHJvbGxlcjtcbn0oX2Jhc2VfcGxheWxpc3RfY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiZGVmYXVsdFwiXSk7XG5cbmZ1bmN0aW9uIGZpbHRlclN1YnRpdGxlVHJhY2tzKHRleHRUcmFja0xpc3QpIHtcbiAgdmFyIHRyYWNrcyA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGV4dFRyYWNrTGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciB0cmFjayA9IHRleHRUcmFja0xpc3RbaV07IC8vIEVkZ2UgYWRkcyBhIHRyYWNrIHdpdGhvdXQgYSBsYWJlbDsgd2UgZG9uJ3Qgd2FudCB0byB1c2UgaXRcblxuICAgIGlmICh0cmFjay5raW5kID09PSAnc3VidGl0bGVzJyAmJiB0cmFjay5sYWJlbCkge1xuICAgICAgdHJhY2tzLnB1c2godGV4dFRyYWNrTGlzdFtpXSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRyYWNrcztcbn1cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChTdWJ0aXRsZVRyYWNrQ29udHJvbGxlcik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NvbnRyb2xsZXIvdGltZWxpbmUtY29udHJvbGxlci50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvY29udHJvbGxlci90aW1lbGluZS1jb250cm9sbGVyLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBUaW1lbGluZUNvbnRyb2xsZXIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiVGltZWxpbmVDb250cm9sbGVyXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gVGltZWxpbmVDb250cm9sbGVyOyB9KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfaG9tZV9ydW5uZXJfd29ya19obHNfanNfaGxzX2pzX3NyY19wb2x5ZmlsbHNfbnVtYmVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3NyYy9wb2x5ZmlsbHMvbnVtYmVyICovIFwiLi9zcmMvcG9seWZpbGxzL251bWJlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9ldmVudHMgKi8gXCIuL3NyYy9ldmVudHMudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2NlYV82MDhfcGFyc2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9jZWEtNjA4LXBhcnNlciAqLyBcIi4vc3JjL3V0aWxzL2NlYS02MDgtcGFyc2VyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19vdXRwdXRfZmlsdGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9vdXRwdXQtZmlsdGVyICovIFwiLi9zcmMvdXRpbHMvb3V0cHV0LWZpbHRlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfd2VidnR0X3BhcnNlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvd2VidnR0LXBhcnNlciAqLyBcIi4vc3JjL3V0aWxzL3dlYnZ0dC1wYXJzZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX3RleHR0cmFja191dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvdGV4dHRyYWNrLXV0aWxzICovIFwiLi9zcmMvdXRpbHMvdGV4dHRyYWNrLXV0aWxzLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19pbXNjMV90dG1sX3BhcnNlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvaW1zYzEtdHRtbC1wYXJzZXIgKi8gXCIuL3NyYy91dGlscy9pbXNjMS10dG1sLXBhcnNlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdHlwZXNfbG9hZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi90eXBlcy9sb2FkZXIgKi8gXCIuL3NyYy90eXBlcy9sb2FkZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvbG9nZ2VyICovIFwiLi9zcmMvdXRpbHMvbG9nZ2VyLnRzXCIpO1xuXG5cblxuXG5cblxuXG5cblxuXG52YXIgVGltZWxpbmVDb250cm9sbGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gVGltZWxpbmVDb250cm9sbGVyKGhscykge1xuICAgIHRoaXMuaGxzID0gdm9pZCAwO1xuICAgIHRoaXMubWVkaWEgPSBudWxsO1xuICAgIHRoaXMuY29uZmlnID0gdm9pZCAwO1xuICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XG4gICAgdGhpcy5DdWVzID0gdm9pZCAwO1xuICAgIHRoaXMudGV4dFRyYWNrcyA9IFtdO1xuICAgIHRoaXMudHJhY2tzID0gW107XG4gICAgdGhpcy5pbml0UFRTID0gW107XG4gICAgdGhpcy50aW1lc2NhbGUgPSBbXTtcbiAgICB0aGlzLnVucGFyc2VkVnR0RnJhZ3MgPSBbXTtcbiAgICB0aGlzLmNhcHRpb25zVHJhY2tzID0ge307XG4gICAgdGhpcy5ub25OYXRpdmVDYXB0aW9uc1RyYWNrcyA9IHt9O1xuICAgIHRoaXMuY2VhNjA4UGFyc2VyMSA9IHZvaWQgMDtcbiAgICB0aGlzLmNlYTYwOFBhcnNlcjIgPSB2b2lkIDA7XG4gICAgdGhpcy5sYXN0U24gPSAtMTtcbiAgICB0aGlzLmxhc3RQYXJ0SW5kZXggPSAtMTtcbiAgICB0aGlzLnByZXZDQyA9IC0xO1xuICAgIHRoaXMudnR0Q0NzID0gbmV3VlRUQ0NzKCk7XG4gICAgdGhpcy5jYXB0aW9uc1Byb3BlcnRpZXMgPSB2b2lkIDA7XG4gICAgdGhpcy5obHMgPSBobHM7XG4gICAgdGhpcy5jb25maWcgPSBobHMuY29uZmlnO1xuICAgIHRoaXMuQ3VlcyA9IGhscy5jb25maWcuY3VlSGFuZGxlcjtcbiAgICB0aGlzLmNhcHRpb25zUHJvcGVydGllcyA9IHtcbiAgICAgIHRleHRUcmFjazE6IHtcbiAgICAgICAgbGFiZWw6IHRoaXMuY29uZmlnLmNhcHRpb25zVGV4dFRyYWNrMUxhYmVsLFxuICAgICAgICBsYW5ndWFnZUNvZGU6IHRoaXMuY29uZmlnLmNhcHRpb25zVGV4dFRyYWNrMUxhbmd1YWdlQ29kZVxuICAgICAgfSxcbiAgICAgIHRleHRUcmFjazI6IHtcbiAgICAgICAgbGFiZWw6IHRoaXMuY29uZmlnLmNhcHRpb25zVGV4dFRyYWNrMkxhYmVsLFxuICAgICAgICBsYW5ndWFnZUNvZGU6IHRoaXMuY29uZmlnLmNhcHRpb25zVGV4dFRyYWNrMkxhbmd1YWdlQ29kZVxuICAgICAgfSxcbiAgICAgIHRleHRUcmFjazM6IHtcbiAgICAgICAgbGFiZWw6IHRoaXMuY29uZmlnLmNhcHRpb25zVGV4dFRyYWNrM0xhYmVsLFxuICAgICAgICBsYW5ndWFnZUNvZGU6IHRoaXMuY29uZmlnLmNhcHRpb25zVGV4dFRyYWNrM0xhbmd1YWdlQ29kZVxuICAgICAgfSxcbiAgICAgIHRleHRUcmFjazQ6IHtcbiAgICAgICAgbGFiZWw6IHRoaXMuY29uZmlnLmNhcHRpb25zVGV4dFRyYWNrNExhYmVsLFxuICAgICAgICBsYW5ndWFnZUNvZGU6IHRoaXMuY29uZmlnLmNhcHRpb25zVGV4dFRyYWNrNExhbmd1YWdlQ29kZVxuICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAodGhpcy5jb25maWcuZW5hYmxlQ0VBNzA4Q2FwdGlvbnMpIHtcbiAgICAgIHZhciBjaGFubmVsMSA9IG5ldyBfdXRpbHNfb3V0cHV0X2ZpbHRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiZGVmYXVsdFwiXSh0aGlzLCAndGV4dFRyYWNrMScpO1xuICAgICAgdmFyIGNoYW5uZWwyID0gbmV3IF91dGlsc19vdXRwdXRfZmlsdGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJkZWZhdWx0XCJdKHRoaXMsICd0ZXh0VHJhY2syJyk7XG4gICAgICB2YXIgY2hhbm5lbDMgPSBuZXcgX3V0aWxzX291dHB1dF9maWx0ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcImRlZmF1bHRcIl0odGhpcywgJ3RleHRUcmFjazMnKTtcbiAgICAgIHZhciBjaGFubmVsNCA9IG5ldyBfdXRpbHNfb3V0cHV0X2ZpbHRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiZGVmYXVsdFwiXSh0aGlzLCAndGV4dFRyYWNrNCcpO1xuICAgICAgdGhpcy5jZWE2MDhQYXJzZXIxID0gbmV3IF91dGlsc19jZWFfNjA4X3BhcnNlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiZGVmYXVsdFwiXSgxLCBjaGFubmVsMSwgY2hhbm5lbDIpO1xuICAgICAgdGhpcy5jZWE2MDhQYXJzZXIyID0gbmV3IF91dGlsc19jZWFfNjA4X3BhcnNlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiZGVmYXVsdFwiXSgzLCBjaGFubmVsMywgY2hhbm5lbDQpO1xuICAgIH1cblxuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFdmVudHNcIl0uTUVESUFfQVRUQUNISU5HLCB0aGlzLm9uTWVkaWFBdHRhY2hpbmcsIHRoaXMpO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFdmVudHNcIl0uTUVESUFfREVUQUNISU5HLCB0aGlzLm9uTWVkaWFEZXRhY2hpbmcsIHRoaXMpO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFdmVudHNcIl0uTUFOSUZFU1RfTE9BRElORywgdGhpcy5vbk1hbmlmZXN0TG9hZGluZywgdGhpcyk7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkV2ZW50c1wiXS5NQU5JRkVTVF9MT0FERUQsIHRoaXMub25NYW5pZmVzdExvYWRlZCwgdGhpcyk7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkV2ZW50c1wiXS5TVUJUSVRMRV9UUkFDS1NfVVBEQVRFRCwgdGhpcy5vblN1YnRpdGxlVHJhY2tzVXBkYXRlZCwgdGhpcyk7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkV2ZW50c1wiXS5GUkFHX0xPQURJTkcsIHRoaXMub25GcmFnTG9hZGluZywgdGhpcyk7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkV2ZW50c1wiXS5GUkFHX0xPQURFRCwgdGhpcy5vbkZyYWdMb2FkZWQsIHRoaXMpO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFdmVudHNcIl0uRlJBR19QQVJTSU5HX1VTRVJEQVRBLCB0aGlzLm9uRnJhZ1BhcnNpbmdVc2VyZGF0YSwgdGhpcyk7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkV2ZW50c1wiXS5GUkFHX0RFQ1JZUFRFRCwgdGhpcy5vbkZyYWdEZWNyeXB0ZWQsIHRoaXMpO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFdmVudHNcIl0uSU5JVF9QVFNfRk9VTkQsIHRoaXMub25Jbml0UHRzRm91bmQsIHRoaXMpO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFdmVudHNcIl0uU1VCVElUTEVfVFJBQ0tTX0NMRUFSRUQsIHRoaXMub25TdWJ0aXRsZVRyYWNrc0NsZWFyZWQsIHRoaXMpO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFdmVudHNcIl0uQlVGRkVSX0ZMVVNISU5HLCB0aGlzLm9uQnVmZmVyRmx1c2hpbmcsIHRoaXMpO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFRpbWVsaW5lQ29udHJvbGxlci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgIHZhciBobHMgPSB0aGlzLmhscztcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkV2ZW50c1wiXS5NRURJQV9BVFRBQ0hJTkcsIHRoaXMub25NZWRpYUF0dGFjaGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFdmVudHNcIl0uTUVESUFfREVUQUNISU5HLCB0aGlzLm9uTWVkaWFEZXRhY2hpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXZlbnRzXCJdLk1BTklGRVNUX0xPQURJTkcsIHRoaXMub25NYW5pZmVzdExvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXZlbnRzXCJdLk1BTklGRVNUX0xPQURFRCwgdGhpcy5vbk1hbmlmZXN0TG9hZGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkV2ZW50c1wiXS5TVUJUSVRMRV9UUkFDS1NfVVBEQVRFRCwgdGhpcy5vblN1YnRpdGxlVHJhY2tzVXBkYXRlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFdmVudHNcIl0uRlJBR19MT0FESU5HLCB0aGlzLm9uRnJhZ0xvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXZlbnRzXCJdLkZSQUdfTE9BREVELCB0aGlzLm9uRnJhZ0xvYWRlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFdmVudHNcIl0uRlJBR19QQVJTSU5HX1VTRVJEQVRBLCB0aGlzLm9uRnJhZ1BhcnNpbmdVc2VyZGF0YSwgdGhpcyk7XG4gICAgaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFdmVudHNcIl0uRlJBR19ERUNSWVBURUQsIHRoaXMub25GcmFnRGVjcnlwdGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkV2ZW50c1wiXS5JTklUX1BUU19GT1VORCwgdGhpcy5vbkluaXRQdHNGb3VuZCwgdGhpcyk7XG4gICAgaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFdmVudHNcIl0uU1VCVElUTEVfVFJBQ0tTX0NMRUFSRUQsIHRoaXMub25TdWJ0aXRsZVRyYWNrc0NsZWFyZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXZlbnRzXCJdLkJVRkZFUl9GTFVTSElORywgdGhpcy5vbkJ1ZmZlckZsdXNoaW5nLCB0aGlzKTsgLy8gQHRzLWlnbm9yZVxuXG4gICAgdGhpcy5obHMgPSB0aGlzLmNvbmZpZyA9IHRoaXMuY2VhNjA4UGFyc2VyMSA9IHRoaXMuY2VhNjA4UGFyc2VyMiA9IG51bGw7XG4gIH07XG5cbiAgX3Byb3RvLmFkZEN1ZXMgPSBmdW5jdGlvbiBhZGRDdWVzKHRyYWNrTmFtZSwgc3RhcnRUaW1lLCBlbmRUaW1lLCBzY3JlZW4sIGN1ZVJhbmdlcykge1xuICAgIC8vIHNraXAgY3VlcyB3aGljaCBvdmVybGFwIG1vcmUgdGhhbiA1MCUgd2l0aCBwcmV2aW91c2x5IHBhcnNlZCB0aW1lIHJhbmdlc1xuICAgIHZhciBtZXJnZWQgPSBmYWxzZTtcblxuICAgIGZvciAodmFyIGkgPSBjdWVSYW5nZXMubGVuZ3RoOyBpLS07KSB7XG4gICAgICB2YXIgY3VlUmFuZ2UgPSBjdWVSYW5nZXNbaV07XG4gICAgICB2YXIgb3ZlcmxhcCA9IGludGVyc2VjdGlvbihjdWVSYW5nZVswXSwgY3VlUmFuZ2VbMV0sIHN0YXJ0VGltZSwgZW5kVGltZSk7XG5cbiAgICAgIGlmIChvdmVybGFwID49IDApIHtcbiAgICAgICAgY3VlUmFuZ2VbMF0gPSBNYXRoLm1pbihjdWVSYW5nZVswXSwgc3RhcnRUaW1lKTtcbiAgICAgICAgY3VlUmFuZ2VbMV0gPSBNYXRoLm1heChjdWVSYW5nZVsxXSwgZW5kVGltZSk7XG4gICAgICAgIG1lcmdlZCA9IHRydWU7XG5cbiAgICAgICAgaWYgKG92ZXJsYXAgLyAoZW5kVGltZSAtIHN0YXJ0VGltZSkgPiAwLjUpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIW1lcmdlZCkge1xuICAgICAgY3VlUmFuZ2VzLnB1c2goW3N0YXJ0VGltZSwgZW5kVGltZV0pO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmNvbmZpZy5yZW5kZXJUZXh0VHJhY2tzTmF0aXZlbHkpIHtcbiAgICAgIHZhciB0cmFjayA9IHRoaXMuY2FwdGlvbnNUcmFja3NbdHJhY2tOYW1lXTtcbiAgICAgIHRoaXMuQ3Vlcy5uZXdDdWUodHJhY2ssIHN0YXJ0VGltZSwgZW5kVGltZSwgc2NyZWVuKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGN1ZXMgPSB0aGlzLkN1ZXMubmV3Q3VlKG51bGwsIHN0YXJ0VGltZSwgZW5kVGltZSwgc2NyZWVuKTtcbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXZlbnRzXCJdLkNVRVNfUEFSU0VELCB7XG4gICAgICAgIHR5cGU6ICdjYXB0aW9ucycsXG4gICAgICAgIGN1ZXM6IGN1ZXMsXG4gICAgICAgIHRyYWNrOiB0cmFja05hbWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfSAvLyBUcmlnZ2VyZWQgd2hlbiBhbiBpbml0aWFsIFBUUyBpcyBmb3VuZDsgdXNlZCBmb3Igc3luY2hyb25pc2F0aW9uIG9mIFdlYlZUVC5cbiAgO1xuXG4gIF9wcm90by5vbkluaXRQdHNGb3VuZCA9IGZ1bmN0aW9uIG9uSW5pdFB0c0ZvdW5kKGV2ZW50LCBfcmVmKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHZhciBmcmFnID0gX3JlZi5mcmFnLFxuICAgICAgICBpZCA9IF9yZWYuaWQsXG4gICAgICAgIGluaXRQVFMgPSBfcmVmLmluaXRQVFMsXG4gICAgICAgIHRpbWVzY2FsZSA9IF9yZWYudGltZXNjYWxlO1xuICAgIHZhciB1bnBhcnNlZFZ0dEZyYWdzID0gdGhpcy51bnBhcnNlZFZ0dEZyYWdzO1xuXG4gICAgaWYgKGlkID09PSAnbWFpbicpIHtcbiAgICAgIHRoaXMuaW5pdFBUU1tmcmFnLmNjXSA9IGluaXRQVFM7XG4gICAgICB0aGlzLnRpbWVzY2FsZVtmcmFnLmNjXSA9IHRpbWVzY2FsZTtcbiAgICB9IC8vIER1ZSB0byBhc3luY2hyb25vdXMgcHJvY2Vzc2luZywgaW5pdGlhbCBQVFMgbWF5IGFycml2ZSBsYXRlciB0aGFuIHRoZSBmaXJzdCBWVFQgZnJhZ21lbnRzIGFyZSBsb2FkZWQuXG4gICAgLy8gUGFyc2UgYW55IHVucGFyc2VkIGZyYWdtZW50cyB1cG9uIHJlY2VpdmluZyB0aGUgaW5pdGlhbCBQVFMuXG5cblxuICAgIGlmICh1bnBhcnNlZFZ0dEZyYWdzLmxlbmd0aCkge1xuICAgICAgdGhpcy51bnBhcnNlZFZ0dEZyYWdzID0gW107XG4gICAgICB1bnBhcnNlZFZ0dEZyYWdzLmZvckVhY2goZnVuY3Rpb24gKGZyYWcpIHtcbiAgICAgICAgX3RoaXMub25GcmFnTG9hZGVkKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkV2ZW50c1wiXS5GUkFHX0xPQURFRCwgZnJhZyk7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmdldEV4aXN0aW5nVHJhY2sgPSBmdW5jdGlvbiBnZXRFeGlzdGluZ1RyYWNrKHRyYWNrTmFtZSkge1xuICAgIHZhciBtZWRpYSA9IHRoaXMubWVkaWE7XG5cbiAgICBpZiAobWVkaWEpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVkaWEudGV4dFRyYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgdGV4dFRyYWNrID0gbWVkaWEudGV4dFRyYWNrc1tpXTtcblxuICAgICAgICBpZiAodGV4dFRyYWNrW3RyYWNrTmFtZV0pIHtcbiAgICAgICAgICByZXR1cm4gdGV4dFRyYWNrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgX3Byb3RvLmNyZWF0ZUNhcHRpb25zVHJhY2sgPSBmdW5jdGlvbiBjcmVhdGVDYXB0aW9uc1RyYWNrKHRyYWNrTmFtZSkge1xuICAgIGlmICh0aGlzLmNvbmZpZy5yZW5kZXJUZXh0VHJhY2tzTmF0aXZlbHkpIHtcbiAgICAgIHRoaXMuY3JlYXRlTmF0aXZlVHJhY2sodHJhY2tOYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jcmVhdGVOb25OYXRpdmVUcmFjayh0cmFja05hbWUpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uY3JlYXRlTmF0aXZlVHJhY2sgPSBmdW5jdGlvbiBjcmVhdGVOYXRpdmVUcmFjayh0cmFja05hbWUpIHtcbiAgICBpZiAodGhpcy5jYXB0aW9uc1RyYWNrc1t0cmFja05hbWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGNhcHRpb25zUHJvcGVydGllcyA9IHRoaXMuY2FwdGlvbnNQcm9wZXJ0aWVzLFxuICAgICAgICBjYXB0aW9uc1RyYWNrcyA9IHRoaXMuY2FwdGlvbnNUcmFja3MsXG4gICAgICAgIG1lZGlhID0gdGhpcy5tZWRpYTtcbiAgICB2YXIgX2NhcHRpb25zUHJvcGVydGllcyR0ID0gY2FwdGlvbnNQcm9wZXJ0aWVzW3RyYWNrTmFtZV0sXG4gICAgICAgIGxhYmVsID0gX2NhcHRpb25zUHJvcGVydGllcyR0LmxhYmVsLFxuICAgICAgICBsYW5ndWFnZUNvZGUgPSBfY2FwdGlvbnNQcm9wZXJ0aWVzJHQubGFuZ3VhZ2VDb2RlOyAvLyBFbmFibGUgcmV1c2Ugb2YgZXhpc3RpbmcgdGV4dCB0cmFjay5cblxuICAgIHZhciBleGlzdGluZ1RyYWNrID0gdGhpcy5nZXRFeGlzdGluZ1RyYWNrKHRyYWNrTmFtZSk7XG5cbiAgICBpZiAoIWV4aXN0aW5nVHJhY2spIHtcbiAgICAgIHZhciB0ZXh0VHJhY2sgPSB0aGlzLmNyZWF0ZVRleHRUcmFjaygnY2FwdGlvbnMnLCBsYWJlbCwgbGFuZ3VhZ2VDb2RlKTtcblxuICAgICAgaWYgKHRleHRUcmFjaykge1xuICAgICAgICAvLyBTZXQgYSBzcGVjaWFsIHByb3BlcnR5IG9uIHRoZSB0cmFjayBzbyB3ZSBrbm93IGl0J3MgbWFuYWdlZCBieSBIbHMuanNcbiAgICAgICAgdGV4dFRyYWNrW3RyYWNrTmFtZV0gPSB0cnVlO1xuICAgICAgICBjYXB0aW9uc1RyYWNrc1t0cmFja05hbWVdID0gdGV4dFRyYWNrO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjYXB0aW9uc1RyYWNrc1t0cmFja05hbWVdID0gZXhpc3RpbmdUcmFjaztcbiAgICAgIE9iamVjdChfdXRpbHNfdGV4dHRyYWNrX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXCJjbGVhckN1cnJlbnRDdWVzXCJdKShjYXB0aW9uc1RyYWNrc1t0cmFja05hbWVdKTtcbiAgICAgIE9iamVjdChfdXRpbHNfdGV4dHRyYWNrX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXCJzZW5kQWRkVHJhY2tFdmVudFwiXSkoY2FwdGlvbnNUcmFja3NbdHJhY2tOYW1lXSwgbWVkaWEpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uY3JlYXRlTm9uTmF0aXZlVHJhY2sgPSBmdW5jdGlvbiBjcmVhdGVOb25OYXRpdmVUcmFjayh0cmFja05hbWUpIHtcbiAgICBpZiAodGhpcy5ub25OYXRpdmVDYXB0aW9uc1RyYWNrc1t0cmFja05hbWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBDcmVhdGUgYSBsaXN0IG9mIGEgc2luZ2xlIHRyYWNrIGZvciB0aGUgcHJvdmlkZXIgdG8gY29uc3VtZVxuXG5cbiAgICB2YXIgdHJhY2tQcm9wZXJ0aWVzID0gdGhpcy5jYXB0aW9uc1Byb3BlcnRpZXNbdHJhY2tOYW1lXTtcblxuICAgIGlmICghdHJhY2tQcm9wZXJ0aWVzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGxhYmVsID0gdHJhY2tQcm9wZXJ0aWVzLmxhYmVsO1xuICAgIHZhciB0cmFjayA9IHtcbiAgICAgIF9pZDogdHJhY2tOYW1lLFxuICAgICAgbGFiZWw6IGxhYmVsLFxuICAgICAga2luZDogJ2NhcHRpb25zJyxcbiAgICAgIGRlZmF1bHQ6IHRyYWNrUHJvcGVydGllcy5tZWRpYSA/ICEhdHJhY2tQcm9wZXJ0aWVzLm1lZGlhLmRlZmF1bHQgOiBmYWxzZSxcbiAgICAgIGNsb3NlZENhcHRpb25zOiB0cmFja1Byb3BlcnRpZXMubWVkaWFcbiAgICB9O1xuICAgIHRoaXMubm9uTmF0aXZlQ2FwdGlvbnNUcmFja3NbdHJhY2tOYW1lXSA9IHRyYWNrO1xuICAgIHRoaXMuaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXZlbnRzXCJdLk5PTl9OQVRJVkVfVEVYVF9UUkFDS1NfRk9VTkQsIHtcbiAgICAgIHRyYWNrczogW3RyYWNrXVxuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90by5jcmVhdGVUZXh0VHJhY2sgPSBmdW5jdGlvbiBjcmVhdGVUZXh0VHJhY2soa2luZCwgbGFiZWwsIGxhbmcpIHtcbiAgICB2YXIgbWVkaWEgPSB0aGlzLm1lZGlhO1xuXG4gICAgaWYgKCFtZWRpYSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJldHVybiBtZWRpYS5hZGRUZXh0VHJhY2soa2luZCwgbGFiZWwsIGxhbmcpO1xuICB9O1xuXG4gIF9wcm90by5vbk1lZGlhQXR0YWNoaW5nID0gZnVuY3Rpb24gb25NZWRpYUF0dGFjaGluZyhldmVudCwgZGF0YSkge1xuICAgIHRoaXMubWVkaWEgPSBkYXRhLm1lZGlhO1xuXG4gICAgdGhpcy5fY2xlYW5UcmFja3MoKTtcbiAgfTtcblxuICBfcHJvdG8ub25NZWRpYURldGFjaGluZyA9IGZ1bmN0aW9uIG9uTWVkaWFEZXRhY2hpbmcoKSB7XG4gICAgdmFyIGNhcHRpb25zVHJhY2tzID0gdGhpcy5jYXB0aW9uc1RyYWNrcztcbiAgICBPYmplY3Qua2V5cyhjYXB0aW9uc1RyYWNrcykuZm9yRWFjaChmdW5jdGlvbiAodHJhY2tOYW1lKSB7XG4gICAgICBPYmplY3QoX3V0aWxzX3RleHR0cmFja191dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1wiY2xlYXJDdXJyZW50Q3Vlc1wiXSkoY2FwdGlvbnNUcmFja3NbdHJhY2tOYW1lXSk7XG4gICAgICBkZWxldGUgY2FwdGlvbnNUcmFja3NbdHJhY2tOYW1lXTtcbiAgICB9KTtcbiAgICB0aGlzLm5vbk5hdGl2ZUNhcHRpb25zVHJhY2tzID0ge307XG4gIH07XG5cbiAgX3Byb3RvLm9uTWFuaWZlc3RMb2FkaW5nID0gZnVuY3Rpb24gb25NYW5pZmVzdExvYWRpbmcoKSB7XG4gICAgdGhpcy5sYXN0U24gPSAtMTsgLy8gRGV0ZWN0IGRpc2NvbnRpbnVpdHkgaW4gZnJhZ21lbnQgcGFyc2luZ1xuXG4gICAgdGhpcy5sYXN0UGFydEluZGV4ID0gLTE7XG4gICAgdGhpcy5wcmV2Q0MgPSAtMTtcbiAgICB0aGlzLnZ0dENDcyA9IG5ld1ZUVENDcygpOyAvLyBEZXRlY3QgZGlzY29udGludWl0eSBpbiBzdWJ0aXRsZSBtYW5pZmVzdHNcblxuICAgIHRoaXMuX2NsZWFuVHJhY2tzKCk7XG5cbiAgICB0aGlzLnRyYWNrcyA9IFtdO1xuICAgIHRoaXMuY2FwdGlvbnNUcmFja3MgPSB7fTtcbiAgICB0aGlzLm5vbk5hdGl2ZUNhcHRpb25zVHJhY2tzID0ge307XG4gICAgdGhpcy50ZXh0VHJhY2tzID0gW107XG4gICAgdGhpcy51bnBhcnNlZFZ0dEZyYWdzID0gdGhpcy51bnBhcnNlZFZ0dEZyYWdzIHx8IFtdO1xuICAgIHRoaXMuaW5pdFBUUyA9IFtdO1xuICAgIHRoaXMudGltZXNjYWxlID0gW107XG5cbiAgICBpZiAodGhpcy5jZWE2MDhQYXJzZXIxICYmIHRoaXMuY2VhNjA4UGFyc2VyMikge1xuICAgICAgdGhpcy5jZWE2MDhQYXJzZXIxLnJlc2V0KCk7XG4gICAgICB0aGlzLmNlYTYwOFBhcnNlcjIucmVzZXQoKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLl9jbGVhblRyYWNrcyA9IGZ1bmN0aW9uIF9jbGVhblRyYWNrcygpIHtcbiAgICAvLyBjbGVhciBvdXRkYXRlZCBzdWJ0aXRsZXNcbiAgICB2YXIgbWVkaWEgPSB0aGlzLm1lZGlhO1xuXG4gICAgaWYgKCFtZWRpYSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB0ZXh0VHJhY2tzID0gbWVkaWEudGV4dFRyYWNrcztcblxuICAgIGlmICh0ZXh0VHJhY2tzKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRleHRUcmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgT2JqZWN0KF91dGlsc190ZXh0dHJhY2tfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcImNsZWFyQ3VycmVudEN1ZXNcIl0pKHRleHRUcmFja3NbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBfcHJvdG8ub25TdWJ0aXRsZVRyYWNrc1VwZGF0ZWQgPSBmdW5jdGlvbiBvblN1YnRpdGxlVHJhY2tzVXBkYXRlZChldmVudCwgZGF0YSkge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgdGhpcy50ZXh0VHJhY2tzID0gW107XG4gICAgdmFyIHRyYWNrcyA9IGRhdGEuc3VidGl0bGVUcmFja3MgfHwgW107XG4gICAgdmFyIGhhc0lNU0MxID0gdHJhY2tzLnNvbWUoZnVuY3Rpb24gKHRyYWNrKSB7XG4gICAgICByZXR1cm4gdHJhY2sudGV4dENvZGVjID09PSBfdXRpbHNfaW1zYzFfdHRtbF9wYXJzZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcIklNU0MxX0NPREVDXCJdO1xuICAgIH0pO1xuXG4gICAgaWYgKHRoaXMuY29uZmlnLmVuYWJsZVdlYlZUVCB8fCBoYXNJTVNDMSAmJiB0aGlzLmNvbmZpZy5lbmFibGVJTVNDMSkge1xuICAgICAgdmFyIHNhbWVUcmFja3MgPSB0aGlzLnRyYWNrcyAmJiB0cmFja3MgJiYgdGhpcy50cmFja3MubGVuZ3RoID09PSB0cmFja3MubGVuZ3RoO1xuICAgICAgdGhpcy50cmFja3MgPSB0cmFja3MgfHwgW107XG5cbiAgICAgIGlmICh0aGlzLmNvbmZpZy5yZW5kZXJUZXh0VHJhY2tzTmF0aXZlbHkpIHtcbiAgICAgICAgdmFyIGluVXNlVHJhY2tzID0gdGhpcy5tZWRpYSA/IHRoaXMubWVkaWEudGV4dFRyYWNrcyA6IFtdO1xuICAgICAgICB0aGlzLnRyYWNrcy5mb3JFYWNoKGZ1bmN0aW9uICh0cmFjaywgaW5kZXgpIHtcbiAgICAgICAgICB2YXIgdGV4dFRyYWNrO1xuXG4gICAgICAgICAgaWYgKGluZGV4IDwgaW5Vc2VUcmFja3MubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgaW5Vc2VUcmFjayA9IG51bGw7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5Vc2VUcmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgaWYgKGNhblJldXNlVnR0VGV4dFRyYWNrKGluVXNlVHJhY2tzW2ldLCB0cmFjaykpIHtcbiAgICAgICAgICAgICAgICBpblVzZVRyYWNrID0gaW5Vc2VUcmFja3NbaV07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gLy8gUmV1c2UgdHJhY2tzIHdpdGggdGhlIHNhbWUgbGFiZWwsIGJ1dCBkbyBub3QgcmV1c2UgNjA4LzcwOCB0cmFja3NcblxuXG4gICAgICAgICAgICBpZiAoaW5Vc2VUcmFjaykge1xuICAgICAgICAgICAgICB0ZXh0VHJhY2sgPSBpblVzZVRyYWNrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0ZXh0VHJhY2spIHtcbiAgICAgICAgICAgIE9iamVjdChfdXRpbHNfdGV4dHRyYWNrX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXCJjbGVhckN1cnJlbnRDdWVzXCJdKSh0ZXh0VHJhY2spO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0ZXh0VHJhY2sgPSBfdGhpczIuY3JlYXRlVGV4dFRyYWNrKCdzdWJ0aXRsZXMnLCB0cmFjay5uYW1lLCB0cmFjay5sYW5nKTtcblxuICAgICAgICAgICAgaWYgKHRleHRUcmFjaykge1xuICAgICAgICAgICAgICB0ZXh0VHJhY2subW9kZSA9ICdkaXNhYmxlZCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHRleHRUcmFjaykge1xuICAgICAgICAgICAgdGV4dFRyYWNrLmdyb3VwSWQgPSB0cmFjay5ncm91cElkO1xuXG4gICAgICAgICAgICBfdGhpczIudGV4dFRyYWNrcy5wdXNoKHRleHRUcmFjayk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoIXNhbWVUcmFja3MgJiYgdGhpcy50cmFja3MgJiYgdGhpcy50cmFja3MubGVuZ3RoKSB7XG4gICAgICAgIC8vIENyZWF0ZSBhIGxpc3Qgb2YgdHJhY2tzIGZvciB0aGUgcHJvdmlkZXIgdG8gY29uc3VtZVxuICAgICAgICB2YXIgdHJhY2tzTGlzdCA9IHRoaXMudHJhY2tzLm1hcChmdW5jdGlvbiAodHJhY2spIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGFiZWw6IHRyYWNrLm5hbWUsXG4gICAgICAgICAgICBraW5kOiB0cmFjay50eXBlLnRvTG93ZXJDYXNlKCksXG4gICAgICAgICAgICBkZWZhdWx0OiB0cmFjay5kZWZhdWx0LFxuICAgICAgICAgICAgc3VidGl0bGVUcmFjazogdHJhY2tcbiAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFdmVudHNcIl0uTk9OX05BVElWRV9URVhUX1RSQUNLU19GT1VORCwge1xuICAgICAgICAgIHRyYWNrczogdHJhY2tzTGlzdFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLm9uTWFuaWZlc3RMb2FkZWQgPSBmdW5jdGlvbiBvbk1hbmlmZXN0TG9hZGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICBpZiAodGhpcy5jb25maWcuZW5hYmxlQ0VBNzA4Q2FwdGlvbnMgJiYgZGF0YS5jYXB0aW9ucykge1xuICAgICAgZGF0YS5jYXB0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChjYXB0aW9uc1RyYWNrKSB7XG4gICAgICAgIHZhciBpbnN0cmVhbUlkTWF0Y2ggPSAvKD86Q0N8U0VSVklDRSkoWzEtNF0pLy5leGVjKGNhcHRpb25zVHJhY2suaW5zdHJlYW1JZCk7XG5cbiAgICAgICAgaWYgKCFpbnN0cmVhbUlkTWF0Y2gpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdHJhY2tOYW1lID0gXCJ0ZXh0VHJhY2tcIiArIGluc3RyZWFtSWRNYXRjaFsxXTtcbiAgICAgICAgdmFyIHRyYWNrUHJvcGVydGllcyA9IF90aGlzMy5jYXB0aW9uc1Byb3BlcnRpZXNbdHJhY2tOYW1lXTtcblxuICAgICAgICBpZiAoIXRyYWNrUHJvcGVydGllcykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRyYWNrUHJvcGVydGllcy5sYWJlbCA9IGNhcHRpb25zVHJhY2submFtZTtcblxuICAgICAgICBpZiAoY2FwdGlvbnNUcmFjay5sYW5nKSB7XG4gICAgICAgICAgLy8gb3B0aW9uYWwgYXR0cmlidXRlXG4gICAgICAgICAgdHJhY2tQcm9wZXJ0aWVzLmxhbmd1YWdlQ29kZSA9IGNhcHRpb25zVHJhY2subGFuZztcbiAgICAgICAgfVxuXG4gICAgICAgIHRyYWNrUHJvcGVydGllcy5tZWRpYSA9IGNhcHRpb25zVHJhY2s7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLm9uRnJhZ0xvYWRpbmcgPSBmdW5jdGlvbiBvbkZyYWdMb2FkaW5nKGV2ZW50LCBkYXRhKSB7XG4gICAgdmFyIGNlYTYwOFBhcnNlcjEgPSB0aGlzLmNlYTYwOFBhcnNlcjEsXG4gICAgICAgIGNlYTYwOFBhcnNlcjIgPSB0aGlzLmNlYTYwOFBhcnNlcjIsXG4gICAgICAgIGxhc3RTbiA9IHRoaXMubGFzdFNuLFxuICAgICAgICBsYXN0UGFydEluZGV4ID0gdGhpcy5sYXN0UGFydEluZGV4O1xuXG4gICAgaWYgKCF0aGlzLmVuYWJsZWQgfHwgIShjZWE2MDhQYXJzZXIxICYmIGNlYTYwOFBhcnNlcjIpKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBpZiB0aGlzIGZyYWcgaXNuJ3QgY29udGlndW91cywgY2xlYXIgdGhlIHBhcnNlciBzbyBjdWVzIHdpdGggYmFkIHN0YXJ0L2VuZCB0aW1lcyBhcmVuJ3QgYWRkZWQgdG8gdGhlIHRleHRUcmFja1xuXG5cbiAgICBpZiAoZGF0YS5mcmFnLnR5cGUgPT09IF90eXBlc19sb2FkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1tcIlBsYXlsaXN0TGV2ZWxUeXBlXCJdLk1BSU4pIHtcbiAgICAgIHZhciBfZGF0YSRwYXJ0JGluZGV4LCBfZGF0YSRwYXJ0O1xuXG4gICAgICB2YXIgc24gPSBkYXRhLmZyYWcuc247XG4gICAgICB2YXIgcGFydEluZGV4ID0gKF9kYXRhJHBhcnQkaW5kZXggPSBkYXRhID09PSBudWxsIHx8IGRhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfZGF0YSRwYXJ0ID0gZGF0YS5wYXJ0KSA9PT0gbnVsbCB8fCBfZGF0YSRwYXJ0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZGF0YSRwYXJ0LmluZGV4KSAhPSBudWxsID8gX2RhdGEkcGFydCRpbmRleCA6IC0xO1xuXG4gICAgICBpZiAoIShzbiA9PT0gbGFzdFNuICsgMSB8fCBzbiA9PT0gbGFzdFNuICYmIHBhcnRJbmRleCA9PT0gbGFzdFBhcnRJbmRleCArIDEpKSB7XG4gICAgICAgIGNlYTYwOFBhcnNlcjEucmVzZXQoKTtcbiAgICAgICAgY2VhNjA4UGFyc2VyMi5yZXNldCgpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmxhc3RTbiA9IHNuO1xuICAgICAgdGhpcy5sYXN0UGFydEluZGV4ID0gcGFydEluZGV4O1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8ub25GcmFnTG9hZGVkID0gZnVuY3Rpb24gb25GcmFnTG9hZGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgdmFyIGZyYWcgPSBkYXRhLmZyYWcsXG4gICAgICAgIHBheWxvYWQgPSBkYXRhLnBheWxvYWQ7XG4gICAgdmFyIGluaXRQVFMgPSB0aGlzLmluaXRQVFMsXG4gICAgICAgIHVucGFyc2VkVnR0RnJhZ3MgPSB0aGlzLnVucGFyc2VkVnR0RnJhZ3M7XG5cbiAgICBpZiAoZnJhZy50eXBlID09PSBfdHlwZXNfbG9hZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bXCJQbGF5bGlzdExldmVsVHlwZVwiXS5TVUJUSVRMRSkge1xuICAgICAgLy8gSWYgZnJhZ21lbnQgaXMgc3VidGl0bGUgdHlwZSwgcGFyc2UgYXMgV2ViVlRULlxuICAgICAgaWYgKHBheWxvYWQuYnl0ZUxlbmd0aCkge1xuICAgICAgICAvLyBXZSBuZWVkIGFuIGluaXRpYWwgc3luY2hyb25pc2F0aW9uIFBUUy4gU3RvcmUgZnJhZ21lbnRzIGFzIGxvbmcgYXMgbm9uZSBoYXMgYXJyaXZlZC5cbiAgICAgICAgaWYgKCFPYmplY3QoX2hvbWVfcnVubmVyX3dvcmtfaGxzX2pzX2hsc19qc19zcmNfcG9seWZpbGxzX251bWJlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiaXNGaW5pdGVOdW1iZXJcIl0pKGluaXRQVFNbZnJhZy5jY10pKSB7XG4gICAgICAgICAgdW5wYXJzZWRWdHRGcmFncy5wdXNoKGRhdGEpO1xuXG4gICAgICAgICAgaWYgKGluaXRQVFMubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBmaW5pc2ggdW5zdWNjZXNzZnVsbHksIG90aGVyd2lzZSB0aGUgc3VidGl0bGUtc3RyZWFtLWNvbnRyb2xsZXIgY291bGQgYmUgYmxvY2tlZCBmcm9tIGxvYWRpbmcgbmV3IGZyYWdzLlxuICAgICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFdmVudHNcIl0uU1VCVElUTEVfRlJBR19QUk9DRVNTRUQsIHtcbiAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICAgIGZyYWc6IGZyYWcsXG4gICAgICAgICAgICAgIGVycm9yOiBuZXcgRXJyb3IoJ01pc3NpbmcgaW5pdGlhbCBzdWJ0aXRsZSBQVFMnKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRlY3J5cHREYXRhID0gZnJhZy5kZWNyeXB0ZGF0YTsgLy8gZnJhZ21lbnQgYWZ0ZXIgZGVjcnlwdGlvbiBoYXMgYSBzdGF0cyBvYmplY3RcblxuICAgICAgICB2YXIgZGVjcnlwdGVkID0gKCdzdGF0cycgaW4gZGF0YSk7IC8vIElmIHRoZSBzdWJ0aXRsZXMgYXJlIG5vdCBlbmNyeXB0ZWQsIHBhcnNlIFZUVHMgbm93LiBPdGhlcndpc2UsIHdlIG5lZWQgdG8gd2FpdC5cblxuICAgICAgICBpZiAoZGVjcnlwdERhdGEgPT0gbnVsbCB8fCBkZWNyeXB0RGF0YS5rZXkgPT0gbnVsbCB8fCBkZWNyeXB0RGF0YS5tZXRob2QgIT09ICdBRVMtMTI4JyB8fCBkZWNyeXB0ZWQpIHtcbiAgICAgICAgICB2YXIgdHJhY2tQbGF5bGlzdE1lZGlhID0gdGhpcy50cmFja3NbZnJhZy5sZXZlbF07XG4gICAgICAgICAgdmFyIHZ0dENDcyA9IHRoaXMudnR0Q0NzO1xuXG4gICAgICAgICAgaWYgKCF2dHRDQ3NbZnJhZy5jY10pIHtcbiAgICAgICAgICAgIHZ0dENDc1tmcmFnLmNjXSA9IHtcbiAgICAgICAgICAgICAgc3RhcnQ6IGZyYWcuc3RhcnQsXG4gICAgICAgICAgICAgIHByZXZDQzogdGhpcy5wcmV2Q0MsXG4gICAgICAgICAgICAgIG5ldzogdHJ1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMucHJldkNDID0gZnJhZy5jYztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodHJhY2tQbGF5bGlzdE1lZGlhICYmIHRyYWNrUGxheWxpc3RNZWRpYS50ZXh0Q29kZWMgPT09IF91dGlsc19pbXNjMV90dG1sX3BhcnNlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fW1wiSU1TQzFfQ09ERUNcIl0pIHtcbiAgICAgICAgICAgIHRoaXMuX3BhcnNlSU1TQzEoZnJhZywgcGF5bG9hZCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3BhcnNlVlRUcyhmcmFnLCBwYXlsb2FkLCB2dHRDQ3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSW4gY2FzZSB0aGVyZSBpcyBubyBwYXlsb2FkLCBmaW5pc2ggdW5zdWNjZXNzZnVsbHkuXG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXZlbnRzXCJdLlNVQlRJVExFX0ZSQUdfUFJPQ0VTU0VELCB7XG4gICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgZnJhZzogZnJhZyxcbiAgICAgICAgICBlcnJvcjogbmV3IEVycm9yKCdFbXB0eSBzdWJ0aXRsZSBwYXlsb2FkJylcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5fcGFyc2VJTVNDMSA9IGZ1bmN0aW9uIF9wYXJzZUlNU0MxKGZyYWcsIHBheWxvYWQpIHtcbiAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgIHZhciBobHMgPSB0aGlzLmhscztcbiAgICBPYmplY3QoX3V0aWxzX2ltc2MxX3R0bWxfcGFyc2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXCJwYXJzZUlNU0MxXCJdKShwYXlsb2FkLCB0aGlzLmluaXRQVFNbZnJhZy5jY10sIHRoaXMudGltZXNjYWxlW2ZyYWcuY2NdLCBmdW5jdGlvbiAoY3Vlcykge1xuICAgICAgX3RoaXM0Ll9hcHBlbmRDdWVzKGN1ZXMsIGZyYWcubGV2ZWwpO1xuXG4gICAgICBobHMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFdmVudHNcIl0uU1VCVElUTEVfRlJBR19QUk9DRVNTRUQsIHtcbiAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgZnJhZzogZnJhZ1xuICAgICAgfSk7XG4gICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV84X19bXCJsb2dnZXJcIl0ubG9nKFwiRmFpbGVkIHRvIHBhcnNlIElNU0MxOiBcIiArIGVycm9yKTtcbiAgICAgIGhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkV2ZW50c1wiXS5TVUJUSVRMRV9GUkFHX1BST0NFU1NFRCwge1xuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgZnJhZzogZnJhZyxcbiAgICAgICAgZXJyb3I6IGVycm9yXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG8uX3BhcnNlVlRUcyA9IGZ1bmN0aW9uIF9wYXJzZVZUVHMoZnJhZywgcGF5bG9hZCwgdnR0Q0NzKSB7XG4gICAgdmFyIF90aGlzNSA9IHRoaXM7XG5cbiAgICB2YXIgaGxzID0gdGhpcy5obHM7IC8vIFBhcnNlIHRoZSBXZWJWVFQgZmlsZSBjb250ZW50cy5cblxuICAgIE9iamVjdChfdXRpbHNfd2VidnR0X3BhcnNlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fW1wicGFyc2VXZWJWVFRcIl0pKHBheWxvYWQsIHRoaXMuaW5pdFBUU1tmcmFnLmNjXSwgdGhpcy50aW1lc2NhbGVbZnJhZy5jY10sIHZ0dENDcywgZnJhZy5jYywgZnJhZy5zdGFydCwgZnVuY3Rpb24gKGN1ZXMpIHtcbiAgICAgIF90aGlzNS5fYXBwZW5kQ3VlcyhjdWVzLCBmcmFnLmxldmVsKTtcblxuICAgICAgaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXZlbnRzXCJdLlNVQlRJVExFX0ZSQUdfUFJPQ0VTU0VELCB7XG4gICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgIGZyYWc6IGZyYWdcbiAgICAgIH0pO1xuICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgX3RoaXM1Ll9mYWxsYmFja1RvSU1TQzEoZnJhZywgcGF5bG9hZCk7IC8vIFNvbWV0aGluZyB3ZW50IHdyb25nIHdoaWxlIHBhcnNpbmcuIFRyaWdnZXIgZXZlbnQgd2l0aCBzdWNjZXNzIGZhbHNlLlxuXG5cbiAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzhfX1tcImxvZ2dlclwiXS5sb2coXCJGYWlsZWQgdG8gcGFyc2UgVlRUIGN1ZTogXCIgKyBlcnJvcik7XG4gICAgICBobHMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFdmVudHNcIl0uU1VCVElUTEVfRlJBR19QUk9DRVNTRUQsIHtcbiAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgIGZyYWc6IGZyYWcsXG4gICAgICAgIGVycm9yOiBlcnJvclxuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLl9mYWxsYmFja1RvSU1TQzEgPSBmdW5jdGlvbiBfZmFsbGJhY2tUb0lNU0MxKGZyYWcsIHBheWxvYWQpIHtcbiAgICB2YXIgX3RoaXM2ID0gdGhpcztcblxuICAgIC8vIElmIHRleHRDb2RlYyBpcyB1bmtub3duLCB0cnkgcGFyc2luZyBhcyBJTVNDMS4gU2V0IHRleHRDb2RlYyBiYXNlZCBvbiB0aGUgcmVzdWx0XG4gICAgdmFyIHRyYWNrUGxheWxpc3RNZWRpYSA9IHRoaXMudHJhY2tzW2ZyYWcubGV2ZWxdO1xuXG4gICAgaWYgKCF0cmFja1BsYXlsaXN0TWVkaWEudGV4dENvZGVjKSB7XG4gICAgICBPYmplY3QoX3V0aWxzX2ltc2MxX3R0bWxfcGFyc2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXCJwYXJzZUlNU0MxXCJdKShwYXlsb2FkLCB0aGlzLmluaXRQVFNbZnJhZy5jY10sIHRoaXMudGltZXNjYWxlW2ZyYWcuY2NdLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRyYWNrUGxheWxpc3RNZWRpYS50ZXh0Q29kZWMgPSBfdXRpbHNfaW1zYzFfdHRtbF9wYXJzZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcIklNU0MxX0NPREVDXCJdO1xuXG4gICAgICAgIF90aGlzNi5fcGFyc2VJTVNDMShmcmFnLCBwYXlsb2FkKTtcbiAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdHJhY2tQbGF5bGlzdE1lZGlhLnRleHRDb2RlYyA9ICd3dnR0JztcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uX2FwcGVuZEN1ZXMgPSBmdW5jdGlvbiBfYXBwZW5kQ3VlcyhjdWVzLCBmcmFnTGV2ZWwpIHtcbiAgICB2YXIgaGxzID0gdGhpcy5obHM7XG5cbiAgICBpZiAodGhpcy5jb25maWcucmVuZGVyVGV4dFRyYWNrc05hdGl2ZWx5KSB7XG4gICAgICB2YXIgdGV4dFRyYWNrID0gdGhpcy50ZXh0VHJhY2tzW2ZyYWdMZXZlbF07IC8vIFdlYlZUVFBhcnNlci5wYXJzZSBpcyBhbiBhc3luYyBtZXRob2QgYW5kIGlmIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgdGV4dCB0cmFjayBtb2RlIGlzIHNldCB0byBcImRpc2FibGVkXCJcbiAgICAgIC8vIGJlZm9yZSBwYXJzaW5nIGlzIGRvbmUgdGhlbiBkb24ndCB0cnkgdG8gYWNjZXNzIGN1cnJlbnRUcmFjay5jdWVzLmdldEN1ZUJ5SWQgYXMgY3VlcyB3aWxsIGJlIG51bGxcbiAgICAgIC8vIGFuZCB0cnlpbmcgdG8gYWNjZXNzIGdldEN1ZUJ5SWQgbWV0aG9kIG9mIGN1ZXMgd2lsbCB0aHJvdyBhbiBleGNlcHRpb25cbiAgICAgIC8vIEJlY2F1c2Ugd2UgY2hlY2sgaWYgdGhlIG1vZGUgaXMgZGlzYWJsZWQsIHdlIGNhbiBmb3JjZSBjaGVjayBgY3Vlc2AgYmVsb3cuIFRoZXkgY2FuJ3QgYmUgbnVsbC5cblxuICAgICAgaWYgKHRleHRUcmFjay5tb2RlID09PSAnZGlzYWJsZWQnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY3Vlcy5mb3JFYWNoKGZ1bmN0aW9uIChjdWUpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdChfdXRpbHNfdGV4dHRyYWNrX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXCJhZGRDdWVUb1RyYWNrXCJdKSh0ZXh0VHJhY2ssIGN1ZSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGN1cnJlbnRUcmFjayA9IHRoaXMudHJhY2tzW2ZyYWdMZXZlbF07XG4gICAgICB2YXIgdHJhY2sgPSBjdXJyZW50VHJhY2suZGVmYXVsdCA/ICdkZWZhdWx0JyA6ICdzdWJ0aXRsZXMnICsgZnJhZ0xldmVsO1xuICAgICAgaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXZlbnRzXCJdLkNVRVNfUEFSU0VELCB7XG4gICAgICAgIHR5cGU6ICdzdWJ0aXRsZXMnLFxuICAgICAgICBjdWVzOiBjdWVzLFxuICAgICAgICB0cmFjazogdHJhY2tcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8ub25GcmFnRGVjcnlwdGVkID0gZnVuY3Rpb24gb25GcmFnRGVjcnlwdGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgdmFyIGZyYWcgPSBkYXRhLmZyYWc7XG5cbiAgICBpZiAoZnJhZy50eXBlID09PSBfdHlwZXNfbG9hZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bXCJQbGF5bGlzdExldmVsVHlwZVwiXS5TVUJUSVRMRSkge1xuICAgICAgaWYgKCFPYmplY3QoX2hvbWVfcnVubmVyX3dvcmtfaGxzX2pzX2hsc19qc19zcmNfcG9seWZpbGxzX251bWJlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiaXNGaW5pdGVOdW1iZXJcIl0pKHRoaXMuaW5pdFBUU1tmcmFnLmNjXSkpIHtcbiAgICAgICAgdGhpcy51bnBhcnNlZFZ0dEZyYWdzLnB1c2goZGF0YSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5vbkZyYWdMb2FkZWQoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXZlbnRzXCJdLkZSQUdfTE9BREVELCBkYXRhKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLm9uU3VidGl0bGVUcmFja3NDbGVhcmVkID0gZnVuY3Rpb24gb25TdWJ0aXRsZVRyYWNrc0NsZWFyZWQoKSB7XG4gICAgdGhpcy50cmFja3MgPSBbXTtcbiAgICB0aGlzLmNhcHRpb25zVHJhY2tzID0ge307XG4gIH07XG5cbiAgX3Byb3RvLm9uRnJhZ1BhcnNpbmdVc2VyZGF0YSA9IGZ1bmN0aW9uIG9uRnJhZ1BhcnNpbmdVc2VyZGF0YShldmVudCwgZGF0YSkge1xuICAgIHZhciBjZWE2MDhQYXJzZXIxID0gdGhpcy5jZWE2MDhQYXJzZXIxLFxuICAgICAgICBjZWE2MDhQYXJzZXIyID0gdGhpcy5jZWE2MDhQYXJzZXIyO1xuXG4gICAgaWYgKCF0aGlzLmVuYWJsZWQgfHwgIShjZWE2MDhQYXJzZXIxICYmIGNlYTYwOFBhcnNlcjIpKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBJZiB0aGUgZXZlbnQgY29udGFpbnMgY2FwdGlvbnMgKGZvdW5kIGluIHRoZSBieXRlcyBwcm9wZXJ0eSksIHB1c2ggYWxsIGJ5dGVzIGludG8gdGhlIHBhcnNlciBpbW1lZGlhdGVseVxuICAgIC8vIEl0IHdpbGwgY3JlYXRlIHRoZSBwcm9wZXIgdGltZXN0YW1wcyBiYXNlZCBvbiB0aGUgUFRTIHZhbHVlXG5cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5zYW1wbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2NCeXRlcyA9IGRhdGEuc2FtcGxlc1tpXS5ieXRlcztcblxuICAgICAgaWYgKGNjQnl0ZXMpIHtcbiAgICAgICAgdmFyIGNjZGF0YXMgPSB0aGlzLmV4dHJhY3RDZWE2MDhEYXRhKGNjQnl0ZXMpO1xuICAgICAgICBjZWE2MDhQYXJzZXIxLmFkZERhdGEoZGF0YS5zYW1wbGVzW2ldLnB0cywgY2NkYXRhc1swXSk7XG4gICAgICAgIGNlYTYwOFBhcnNlcjIuYWRkRGF0YShkYXRhLnNhbXBsZXNbaV0ucHRzLCBjY2RhdGFzWzFdKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLm9uQnVmZmVyRmx1c2hpbmcgPSBmdW5jdGlvbiBvbkJ1ZmZlckZsdXNoaW5nKGV2ZW50LCBfcmVmMikge1xuICAgIHZhciBzdGFydE9mZnNldCA9IF9yZWYyLnN0YXJ0T2Zmc2V0LFxuICAgICAgICBlbmRPZmZzZXQgPSBfcmVmMi5lbmRPZmZzZXQsXG4gICAgICAgIGVuZE9mZnNldFN1YnRpdGxlcyA9IF9yZWYyLmVuZE9mZnNldFN1YnRpdGxlcyxcbiAgICAgICAgdHlwZSA9IF9yZWYyLnR5cGU7XG4gICAgdmFyIG1lZGlhID0gdGhpcy5tZWRpYTtcblxuICAgIGlmICghbWVkaWEgfHwgbWVkaWEuY3VycmVudFRpbWUgPCBlbmRPZmZzZXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIENsZWFyIDYwOCBjYXB0aW9uIGN1ZXMgZnJvbSB0aGUgY2FwdGlvbnMgVGV4dFRyYWNrcyB3aGVuIHRoZSB2aWRlbyBiYWNrIGJ1ZmZlciBpcyBmbHVzaGVkXG4gICAgLy8gRm9yd2FyZCBjdWVzIGFyZSBuZXZlciByZW1vdmVkIGJlY2F1c2Ugd2UgY2FuIGxvb3NlIHN0cmVhbWVkIDYwOCBjb250ZW50IGZyb20gcmVjZW50IGZyYWdtZW50c1xuXG5cbiAgICBpZiAoIXR5cGUgfHwgdHlwZSA9PT0gJ3ZpZGVvJykge1xuICAgICAgdmFyIGNhcHRpb25zVHJhY2tzID0gdGhpcy5jYXB0aW9uc1RyYWNrcztcbiAgICAgIE9iamVjdC5rZXlzKGNhcHRpb25zVHJhY2tzKS5mb3JFYWNoKGZ1bmN0aW9uICh0cmFja05hbWUpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdChfdXRpbHNfdGV4dHRyYWNrX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXCJyZW1vdmVDdWVzSW5SYW5nZVwiXSkoY2FwdGlvbnNUcmFja3NbdHJhY2tOYW1lXSwgc3RhcnRPZmZzZXQsIGVuZE9mZnNldCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5jb25maWcucmVuZGVyVGV4dFRyYWNrc05hdGl2ZWx5KSB7XG4gICAgICAvLyBDbGVhciBWVFQvSU1TQzEgc3VidGl0bGUgY3VlcyBmcm9tIHRoZSBzdWJ0aXRsZSBUZXh0VHJhY2tzIHdoZW4gdGhlIGJhY2sgYnVmZmVyIGlzIGZsdXNoZWRcbiAgICAgIGlmIChzdGFydE9mZnNldCA9PT0gMCAmJiBlbmRPZmZzZXRTdWJ0aXRsZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgdGV4dFRyYWNrcyA9IHRoaXMudGV4dFRyYWNrcztcbiAgICAgICAgT2JqZWN0LmtleXModGV4dFRyYWNrcykuZm9yRWFjaChmdW5jdGlvbiAodHJhY2tOYW1lKSB7XG4gICAgICAgICAgcmV0dXJuIE9iamVjdChfdXRpbHNfdGV4dHRyYWNrX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXCJyZW1vdmVDdWVzSW5SYW5nZVwiXSkodGV4dFRyYWNrc1t0cmFja05hbWVdLCBzdGFydE9mZnNldCwgZW5kT2Zmc2V0U3VidGl0bGVzKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5leHRyYWN0Q2VhNjA4RGF0YSA9IGZ1bmN0aW9uIGV4dHJhY3RDZWE2MDhEYXRhKGJ5dGVBcnJheSkge1xuICAgIHZhciBjb3VudCA9IGJ5dGVBcnJheVswXSAmIDMxO1xuICAgIHZhciBwb3NpdGlvbiA9IDI7XG4gICAgdmFyIGFjdHVhbENDQnl0ZXMgPSBbW10sIFtdXTtcblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgY291bnQ7IGorKykge1xuICAgICAgdmFyIHRtcEJ5dGUgPSBieXRlQXJyYXlbcG9zaXRpb24rK107XG4gICAgICB2YXIgY2NieXRlMSA9IDB4N2YgJiBieXRlQXJyYXlbcG9zaXRpb24rK107XG4gICAgICB2YXIgY2NieXRlMiA9IDB4N2YgJiBieXRlQXJyYXlbcG9zaXRpb24rK107XG4gICAgICB2YXIgY2NWYWxpZCA9ICg0ICYgdG1wQnl0ZSkgIT09IDA7XG4gICAgICB2YXIgY2NUeXBlID0gMyAmIHRtcEJ5dGU7XG5cbiAgICAgIGlmIChjY2J5dGUxID09PSAwICYmIGNjYnl0ZTIgPT09IDApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChjY1ZhbGlkKSB7XG4gICAgICAgIGlmIChjY1R5cGUgPT09IDAgfHwgY2NUeXBlID09PSAxKSB7XG4gICAgICAgICAgYWN0dWFsQ0NCeXRlc1tjY1R5cGVdLnB1c2goY2NieXRlMSk7XG4gICAgICAgICAgYWN0dWFsQ0NCeXRlc1tjY1R5cGVdLnB1c2goY2NieXRlMik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYWN0dWFsQ0NCeXRlcztcbiAgfTtcblxuICByZXR1cm4gVGltZWxpbmVDb250cm9sbGVyO1xufSgpO1xuXG5mdW5jdGlvbiBjYW5SZXVzZVZ0dFRleHRUcmFjayhpblVzZVRyYWNrLCBtYW5pZmVzdFRyYWNrKSB7XG4gIHJldHVybiBpblVzZVRyYWNrICYmIGluVXNlVHJhY2subGFiZWwgPT09IG1hbmlmZXN0VHJhY2submFtZSAmJiAhKGluVXNlVHJhY2sudGV4dFRyYWNrMSB8fCBpblVzZVRyYWNrLnRleHRUcmFjazIpO1xufVxuXG5mdW5jdGlvbiBpbnRlcnNlY3Rpb24oeDEsIHgyLCB5MSwgeTIpIHtcbiAgcmV0dXJuIE1hdGgubWluKHgyLCB5MikgLSBNYXRoLm1heCh4MSwgeTEpO1xufVxuXG5mdW5jdGlvbiBuZXdWVFRDQ3MoKSB7XG4gIHJldHVybiB7XG4gICAgY2NPZmZzZXQ6IDAsXG4gICAgcHJlc2VudGF0aW9uT2Zmc2V0OiAwLFxuICAgIDA6IHtcbiAgICAgIHN0YXJ0OiAwLFxuICAgICAgcHJldkNDOiAtMSxcbiAgICAgIG5ldzogZmFsc2VcbiAgICB9XG4gIH07XG59XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NyeXB0L2Flcy1jcnlwdG8udHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9jcnlwdC9hZXMtY3J5cHRvLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJkZWZhdWx0XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gQUVTQ3J5cHRvOyB9KTtcbnZhciBBRVNDcnlwdG8gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBBRVNDcnlwdG8oc3VidGxlLCBpdikge1xuICAgIHRoaXMuc3VidGxlID0gdm9pZCAwO1xuICAgIHRoaXMuYWVzSVYgPSB2b2lkIDA7XG4gICAgdGhpcy5zdWJ0bGUgPSBzdWJ0bGU7XG4gICAgdGhpcy5hZXNJViA9IGl2O1xuICB9XG5cbiAgdmFyIF9wcm90byA9IEFFU0NyeXB0by5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmRlY3J5cHQgPSBmdW5jdGlvbiBkZWNyeXB0KGRhdGEsIGtleSkge1xuICAgIHJldHVybiB0aGlzLnN1YnRsZS5kZWNyeXB0KHtcbiAgICAgIG5hbWU6ICdBRVMtQ0JDJyxcbiAgICAgIGl2OiB0aGlzLmFlc0lWXG4gICAgfSwga2V5LCBkYXRhKTtcbiAgfTtcblxuICByZXR1cm4gQUVTQ3J5cHRvO1xufSgpO1xuXG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY3J5cHQvYWVzLWRlY3J5cHRvci50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NyeXB0L2Flcy1kZWNyeXB0b3IudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiByZW1vdmVQYWRkaW5nLCBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcInJlbW92ZVBhZGRpbmdcIiwgZnVuY3Rpb24oKSB7IHJldHVybiByZW1vdmVQYWRkaW5nOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJkZWZhdWx0XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gQUVTRGVjcnlwdG9yOyB9KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfdHlwZWRfYXJyYXlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL3R5cGVkLWFycmF5ICovIFwiLi9zcmMvdXRpbHMvdHlwZWQtYXJyYXkudHNcIik7XG4gLy8gUEtDUzdcblxuZnVuY3Rpb24gcmVtb3ZlUGFkZGluZyhhcnJheSkge1xuICB2YXIgb3V0cHV0Qnl0ZXMgPSBhcnJheS5ieXRlTGVuZ3RoO1xuICB2YXIgcGFkZGluZ0J5dGVzID0gb3V0cHV0Qnl0ZXMgJiYgbmV3IERhdGFWaWV3KGFycmF5LmJ1ZmZlcikuZ2V0VWludDgob3V0cHV0Qnl0ZXMgLSAxKTtcblxuICBpZiAocGFkZGluZ0J5dGVzKSB7XG4gICAgcmV0dXJuIE9iamVjdChfdXRpbHNfdHlwZWRfYXJyYXlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcInNsaWNlVWludDhcIl0pKGFycmF5LCAwLCBvdXRwdXRCeXRlcyAtIHBhZGRpbmdCeXRlcyk7XG4gIH1cblxuICByZXR1cm4gYXJyYXk7XG59XG5cbnZhciBBRVNEZWNyeXB0b3IgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBBRVNEZWNyeXB0b3IoKSB7XG4gICAgdGhpcy5yY29uID0gWzB4MCwgMHgxLCAweDIsIDB4NCwgMHg4LCAweDEwLCAweDIwLCAweDQwLCAweDgwLCAweDFiLCAweDM2XTtcbiAgICB0aGlzLnN1Yk1peCA9IFtuZXcgVWludDMyQXJyYXkoMjU2KSwgbmV3IFVpbnQzMkFycmF5KDI1NiksIG5ldyBVaW50MzJBcnJheSgyNTYpLCBuZXcgVWludDMyQXJyYXkoMjU2KV07XG4gICAgdGhpcy5pbnZTdWJNaXggPSBbbmV3IFVpbnQzMkFycmF5KDI1NiksIG5ldyBVaW50MzJBcnJheSgyNTYpLCBuZXcgVWludDMyQXJyYXkoMjU2KSwgbmV3IFVpbnQzMkFycmF5KDI1NildO1xuICAgIHRoaXMuc0JveCA9IG5ldyBVaW50MzJBcnJheSgyNTYpO1xuICAgIHRoaXMuaW52U0JveCA9IG5ldyBVaW50MzJBcnJheSgyNTYpO1xuICAgIHRoaXMua2V5ID0gbmV3IFVpbnQzMkFycmF5KDApO1xuICAgIHRoaXMua3NSb3dzID0gMDtcbiAgICB0aGlzLmtleVNpemUgPSAwO1xuICAgIHRoaXMua2V5U2NoZWR1bGUgPSB2b2lkIDA7XG4gICAgdGhpcy5pbnZLZXlTY2hlZHVsZSA9IHZvaWQgMDtcbiAgICB0aGlzLmluaXRUYWJsZSgpO1xuICB9IC8vIFVzaW5nIHZpZXcuZ2V0VWludDMyKCkgYWxzbyBzd2FwcyB0aGUgYnl0ZSBvcmRlci5cblxuXG4gIHZhciBfcHJvdG8gPSBBRVNEZWNyeXB0b3IucHJvdG90eXBlO1xuXG4gIF9wcm90by51aW50OEFycmF5VG9VaW50MzJBcnJheV8gPSBmdW5jdGlvbiB1aW50OEFycmF5VG9VaW50MzJBcnJheV8oYXJyYXlCdWZmZXIpIHtcbiAgICB2YXIgdmlldyA9IG5ldyBEYXRhVmlldyhhcnJheUJ1ZmZlcik7XG4gICAgdmFyIG5ld0FycmF5ID0gbmV3IFVpbnQzMkFycmF5KDQpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICAgIG5ld0FycmF5W2ldID0gdmlldy5nZXRVaW50MzIoaSAqIDQpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXdBcnJheTtcbiAgfTtcblxuICBfcHJvdG8uaW5pdFRhYmxlID0gZnVuY3Rpb24gaW5pdFRhYmxlKCkge1xuICAgIHZhciBzQm94ID0gdGhpcy5zQm94O1xuICAgIHZhciBpbnZTQm94ID0gdGhpcy5pbnZTQm94O1xuICAgIHZhciBzdWJNaXggPSB0aGlzLnN1Yk1peDtcbiAgICB2YXIgc3ViTWl4MCA9IHN1Yk1peFswXTtcbiAgICB2YXIgc3ViTWl4MSA9IHN1Yk1peFsxXTtcbiAgICB2YXIgc3ViTWl4MiA9IHN1Yk1peFsyXTtcbiAgICB2YXIgc3ViTWl4MyA9IHN1Yk1peFszXTtcbiAgICB2YXIgaW52U3ViTWl4ID0gdGhpcy5pbnZTdWJNaXg7XG4gICAgdmFyIGludlN1Yk1peDAgPSBpbnZTdWJNaXhbMF07XG4gICAgdmFyIGludlN1Yk1peDEgPSBpbnZTdWJNaXhbMV07XG4gICAgdmFyIGludlN1Yk1peDIgPSBpbnZTdWJNaXhbMl07XG4gICAgdmFyIGludlN1Yk1peDMgPSBpbnZTdWJNaXhbM107XG4gICAgdmFyIGQgPSBuZXcgVWludDMyQXJyYXkoMjU2KTtcbiAgICB2YXIgeCA9IDA7XG4gICAgdmFyIHhpID0gMDtcbiAgICB2YXIgaSA9IDA7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcbiAgICAgIGlmIChpIDwgMTI4KSB7XG4gICAgICAgIGRbaV0gPSBpIDw8IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkW2ldID0gaSA8PCAxIF4gMHgxMWI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG4gICAgICB2YXIgc3ggPSB4aSBeIHhpIDw8IDEgXiB4aSA8PCAyIF4geGkgPDwgMyBeIHhpIDw8IDQ7XG4gICAgICBzeCA9IHN4ID4+PiA4IF4gc3ggJiAweGZmIF4gMHg2MztcbiAgICAgIHNCb3hbeF0gPSBzeDtcbiAgICAgIGludlNCb3hbc3hdID0geDsgLy8gQ29tcHV0ZSBtdWx0aXBsaWNhdGlvblxuXG4gICAgICB2YXIgeDIgPSBkW3hdO1xuICAgICAgdmFyIHg0ID0gZFt4Ml07XG4gICAgICB2YXIgeDggPSBkW3g0XTsgLy8gQ29tcHV0ZSBzdWIvaW52U3ViIGJ5dGVzLCBtaXggY29sdW1ucyB0YWJsZXNcblxuICAgICAgdmFyIHQgPSBkW3N4XSAqIDB4MTAxIF4gc3ggKiAweDEwMTAxMDA7XG4gICAgICBzdWJNaXgwW3hdID0gdCA8PCAyNCB8IHQgPj4+IDg7XG4gICAgICBzdWJNaXgxW3hdID0gdCA8PCAxNiB8IHQgPj4+IDE2O1xuICAgICAgc3ViTWl4Mlt4XSA9IHQgPDwgOCB8IHQgPj4+IDI0O1xuICAgICAgc3ViTWl4M1t4XSA9IHQ7IC8vIENvbXB1dGUgaW52IHN1YiBieXRlcywgaW52IG1peCBjb2x1bW5zIHRhYmxlc1xuXG4gICAgICB0ID0geDggKiAweDEwMTAxMDEgXiB4NCAqIDB4MTAwMDEgXiB4MiAqIDB4MTAxIF4geCAqIDB4MTAxMDEwMDtcbiAgICAgIGludlN1Yk1peDBbc3hdID0gdCA8PCAyNCB8IHQgPj4+IDg7XG4gICAgICBpbnZTdWJNaXgxW3N4XSA9IHQgPDwgMTYgfCB0ID4+PiAxNjtcbiAgICAgIGludlN1Yk1peDJbc3hdID0gdCA8PCA4IHwgdCA+Pj4gMjQ7XG4gICAgICBpbnZTdWJNaXgzW3N4XSA9IHQ7IC8vIENvbXB1dGUgbmV4dCBjb3VudGVyXG5cbiAgICAgIGlmICgheCkge1xuICAgICAgICB4ID0geGkgPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeCA9IHgyIF4gZFtkW2RbeDggXiB4Ml1dXTtcbiAgICAgICAgeGkgXj0gZFtkW3hpXV07XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5leHBhbmRLZXkgPSBmdW5jdGlvbiBleHBhbmRLZXkoa2V5QnVmZmVyKSB7XG4gICAgLy8gY29udmVydCBrZXlCdWZmZXIgdG8gVWludDMyQXJyYXlcbiAgICB2YXIga2V5ID0gdGhpcy51aW50OEFycmF5VG9VaW50MzJBcnJheV8oa2V5QnVmZmVyKTtcbiAgICB2YXIgc2FtZUtleSA9IHRydWU7XG4gICAgdmFyIG9mZnNldCA9IDA7XG5cbiAgICB3aGlsZSAob2Zmc2V0IDwga2V5Lmxlbmd0aCAmJiBzYW1lS2V5KSB7XG4gICAgICBzYW1lS2V5ID0ga2V5W29mZnNldF0gPT09IHRoaXMua2V5W29mZnNldF07XG4gICAgICBvZmZzZXQrKztcbiAgICB9XG5cbiAgICBpZiAoc2FtZUtleSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMua2V5ID0ga2V5O1xuICAgIHZhciBrZXlTaXplID0gdGhpcy5rZXlTaXplID0ga2V5Lmxlbmd0aDtcblxuICAgIGlmIChrZXlTaXplICE9PSA0ICYmIGtleVNpemUgIT09IDYgJiYga2V5U2l6ZSAhPT0gOCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFlcyBrZXkgc2l6ZT0nICsga2V5U2l6ZSk7XG4gICAgfVxuXG4gICAgdmFyIGtzUm93cyA9IHRoaXMua3NSb3dzID0gKGtleVNpemUgKyA2ICsgMSkgKiA0O1xuICAgIHZhciBrc1JvdztcbiAgICB2YXIgaW52S3NSb3c7XG4gICAgdmFyIGtleVNjaGVkdWxlID0gdGhpcy5rZXlTY2hlZHVsZSA9IG5ldyBVaW50MzJBcnJheShrc1Jvd3MpO1xuICAgIHZhciBpbnZLZXlTY2hlZHVsZSA9IHRoaXMuaW52S2V5U2NoZWR1bGUgPSBuZXcgVWludDMyQXJyYXkoa3NSb3dzKTtcbiAgICB2YXIgc2JveCA9IHRoaXMuc0JveDtcbiAgICB2YXIgcmNvbiA9IHRoaXMucmNvbjtcbiAgICB2YXIgaW52U3ViTWl4ID0gdGhpcy5pbnZTdWJNaXg7XG4gICAgdmFyIGludlN1Yk1peDAgPSBpbnZTdWJNaXhbMF07XG4gICAgdmFyIGludlN1Yk1peDEgPSBpbnZTdWJNaXhbMV07XG4gICAgdmFyIGludlN1Yk1peDIgPSBpbnZTdWJNaXhbMl07XG4gICAgdmFyIGludlN1Yk1peDMgPSBpbnZTdWJNaXhbM107XG4gICAgdmFyIHByZXY7XG4gICAgdmFyIHQ7XG5cbiAgICBmb3IgKGtzUm93ID0gMDsga3NSb3cgPCBrc1Jvd3M7IGtzUm93KyspIHtcbiAgICAgIGlmIChrc1JvdyA8IGtleVNpemUpIHtcbiAgICAgICAgcHJldiA9IGtleVNjaGVkdWxlW2tzUm93XSA9IGtleVtrc1Jvd107XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB0ID0gcHJldjtcblxuICAgICAgaWYgKGtzUm93ICUga2V5U2l6ZSA9PT0gMCkge1xuICAgICAgICAvLyBSb3Qgd29yZFxuICAgICAgICB0ID0gdCA8PCA4IHwgdCA+Pj4gMjQ7IC8vIFN1YiB3b3JkXG5cbiAgICAgICAgdCA9IHNib3hbdCA+Pj4gMjRdIDw8IDI0IHwgc2JveFt0ID4+PiAxNiAmIDB4ZmZdIDw8IDE2IHwgc2JveFt0ID4+PiA4ICYgMHhmZl0gPDwgOCB8IHNib3hbdCAmIDB4ZmZdOyAvLyBNaXggUmNvblxuXG4gICAgICAgIHQgXj0gcmNvbltrc1JvdyAvIGtleVNpemUgfCAwXSA8PCAyNDtcbiAgICAgIH0gZWxzZSBpZiAoa2V5U2l6ZSA+IDYgJiYga3NSb3cgJSBrZXlTaXplID09PSA0KSB7XG4gICAgICAgIC8vIFN1YiB3b3JkXG4gICAgICAgIHQgPSBzYm94W3QgPj4+IDI0XSA8PCAyNCB8IHNib3hbdCA+Pj4gMTYgJiAweGZmXSA8PCAxNiB8IHNib3hbdCA+Pj4gOCAmIDB4ZmZdIDw8IDggfCBzYm94W3QgJiAweGZmXTtcbiAgICAgIH1cblxuICAgICAga2V5U2NoZWR1bGVba3NSb3ddID0gcHJldiA9IChrZXlTY2hlZHVsZVtrc1JvdyAtIGtleVNpemVdIF4gdCkgPj4+IDA7XG4gICAgfVxuXG4gICAgZm9yIChpbnZLc1JvdyA9IDA7IGludktzUm93IDwga3NSb3dzOyBpbnZLc1JvdysrKSB7XG4gICAgICBrc1JvdyA9IGtzUm93cyAtIGludktzUm93O1xuXG4gICAgICBpZiAoaW52S3NSb3cgJiAzKSB7XG4gICAgICAgIHQgPSBrZXlTY2hlZHVsZVtrc1Jvd107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0ID0ga2V5U2NoZWR1bGVba3NSb3cgLSA0XTtcbiAgICAgIH1cblxuICAgICAgaWYgKGludktzUm93IDwgNCB8fCBrc1JvdyA8PSA0KSB7XG4gICAgICAgIGludktleVNjaGVkdWxlW2ludktzUm93XSA9IHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnZLZXlTY2hlZHVsZVtpbnZLc1Jvd10gPSBpbnZTdWJNaXgwW3Nib3hbdCA+Pj4gMjRdXSBeIGludlN1Yk1peDFbc2JveFt0ID4+PiAxNiAmIDB4ZmZdXSBeIGludlN1Yk1peDJbc2JveFt0ID4+PiA4ICYgMHhmZl1dIF4gaW52U3ViTWl4M1tzYm94W3QgJiAweGZmXV07XG4gICAgICB9XG5cbiAgICAgIGludktleVNjaGVkdWxlW2ludktzUm93XSA9IGludktleVNjaGVkdWxlW2ludktzUm93XSA+Pj4gMDtcbiAgICB9XG4gIH0gLy8gQWRkaW5nIHRoaXMgYXMgYSBtZXRob2QgZ3JlYXRseSBpbXByb3ZlcyBwZXJmb3JtYW5jZS5cbiAgO1xuXG4gIF9wcm90by5uZXR3b3JrVG9Ib3N0T3JkZXJTd2FwID0gZnVuY3Rpb24gbmV0d29ya1RvSG9zdE9yZGVyU3dhcCh3b3JkKSB7XG4gICAgcmV0dXJuIHdvcmQgPDwgMjQgfCAod29yZCAmIDB4ZmYwMCkgPDwgOCB8ICh3b3JkICYgMHhmZjAwMDApID4+IDggfCB3b3JkID4+PiAyNDtcbiAgfTtcblxuICBfcHJvdG8uZGVjcnlwdCA9IGZ1bmN0aW9uIGRlY3J5cHQoaW5wdXRBcnJheUJ1ZmZlciwgb2Zmc2V0LCBhZXNJVikge1xuICAgIHZhciBuUm91bmRzID0gdGhpcy5rZXlTaXplICsgNjtcbiAgICB2YXIgaW52S2V5U2NoZWR1bGUgPSB0aGlzLmludktleVNjaGVkdWxlO1xuICAgIHZhciBpbnZTQk9YID0gdGhpcy5pbnZTQm94O1xuICAgIHZhciBpbnZTdWJNaXggPSB0aGlzLmludlN1Yk1peDtcbiAgICB2YXIgaW52U3ViTWl4MCA9IGludlN1Yk1peFswXTtcbiAgICB2YXIgaW52U3ViTWl4MSA9IGludlN1Yk1peFsxXTtcbiAgICB2YXIgaW52U3ViTWl4MiA9IGludlN1Yk1peFsyXTtcbiAgICB2YXIgaW52U3ViTWl4MyA9IGludlN1Yk1peFszXTtcbiAgICB2YXIgaW5pdFZlY3RvciA9IHRoaXMudWludDhBcnJheVRvVWludDMyQXJyYXlfKGFlc0lWKTtcbiAgICB2YXIgaW5pdFZlY3RvcjAgPSBpbml0VmVjdG9yWzBdO1xuICAgIHZhciBpbml0VmVjdG9yMSA9IGluaXRWZWN0b3JbMV07XG4gICAgdmFyIGluaXRWZWN0b3IyID0gaW5pdFZlY3RvclsyXTtcbiAgICB2YXIgaW5pdFZlY3RvcjMgPSBpbml0VmVjdG9yWzNdO1xuICAgIHZhciBpbnB1dEludDMyID0gbmV3IEludDMyQXJyYXkoaW5wdXRBcnJheUJ1ZmZlcik7XG4gICAgdmFyIG91dHB1dEludDMyID0gbmV3IEludDMyQXJyYXkoaW5wdXRJbnQzMi5sZW5ndGgpO1xuICAgIHZhciB0MCwgdDEsIHQyLCB0MztcbiAgICB2YXIgczAsIHMxLCBzMiwgczM7XG4gICAgdmFyIGlucHV0V29yZHMwLCBpbnB1dFdvcmRzMSwgaW5wdXRXb3JkczIsIGlucHV0V29yZHMzO1xuICAgIHZhciBrc1JvdywgaTtcbiAgICB2YXIgc3dhcFdvcmQgPSB0aGlzLm5ldHdvcmtUb0hvc3RPcmRlclN3YXA7XG5cbiAgICB3aGlsZSAob2Zmc2V0IDwgaW5wdXRJbnQzMi5sZW5ndGgpIHtcbiAgICAgIGlucHV0V29yZHMwID0gc3dhcFdvcmQoaW5wdXRJbnQzMltvZmZzZXRdKTtcbiAgICAgIGlucHV0V29yZHMxID0gc3dhcFdvcmQoaW5wdXRJbnQzMltvZmZzZXQgKyAxXSk7XG4gICAgICBpbnB1dFdvcmRzMiA9IHN3YXBXb3JkKGlucHV0SW50MzJbb2Zmc2V0ICsgMl0pO1xuICAgICAgaW5wdXRXb3JkczMgPSBzd2FwV29yZChpbnB1dEludDMyW29mZnNldCArIDNdKTtcbiAgICAgIHMwID0gaW5wdXRXb3JkczAgXiBpbnZLZXlTY2hlZHVsZVswXTtcbiAgICAgIHMxID0gaW5wdXRXb3JkczMgXiBpbnZLZXlTY2hlZHVsZVsxXTtcbiAgICAgIHMyID0gaW5wdXRXb3JkczIgXiBpbnZLZXlTY2hlZHVsZVsyXTtcbiAgICAgIHMzID0gaW5wdXRXb3JkczEgXiBpbnZLZXlTY2hlZHVsZVszXTtcbiAgICAgIGtzUm93ID0gNDsgLy8gSXRlcmF0ZSB0aHJvdWdoIHRoZSByb3VuZHMgb2YgZGVjcnlwdGlvblxuXG4gICAgICBmb3IgKGkgPSAxOyBpIDwgblJvdW5kczsgaSsrKSB7XG4gICAgICAgIHQwID0gaW52U3ViTWl4MFtzMCA+Pj4gMjRdIF4gaW52U3ViTWl4MVtzMSA+PiAxNiAmIDB4ZmZdIF4gaW52U3ViTWl4MltzMiA+PiA4ICYgMHhmZl0gXiBpbnZTdWJNaXgzW3MzICYgMHhmZl0gXiBpbnZLZXlTY2hlZHVsZVtrc1Jvd107XG4gICAgICAgIHQxID0gaW52U3ViTWl4MFtzMSA+Pj4gMjRdIF4gaW52U3ViTWl4MVtzMiA+PiAxNiAmIDB4ZmZdIF4gaW52U3ViTWl4MltzMyA+PiA4ICYgMHhmZl0gXiBpbnZTdWJNaXgzW3MwICYgMHhmZl0gXiBpbnZLZXlTY2hlZHVsZVtrc1JvdyArIDFdO1xuICAgICAgICB0MiA9IGludlN1Yk1peDBbczIgPj4+IDI0XSBeIGludlN1Yk1peDFbczMgPj4gMTYgJiAweGZmXSBeIGludlN1Yk1peDJbczAgPj4gOCAmIDB4ZmZdIF4gaW52U3ViTWl4M1tzMSAmIDB4ZmZdIF4gaW52S2V5U2NoZWR1bGVba3NSb3cgKyAyXTtcbiAgICAgICAgdDMgPSBpbnZTdWJNaXgwW3MzID4+PiAyNF0gXiBpbnZTdWJNaXgxW3MwID4+IDE2ICYgMHhmZl0gXiBpbnZTdWJNaXgyW3MxID4+IDggJiAweGZmXSBeIGludlN1Yk1peDNbczIgJiAweGZmXSBeIGludktleVNjaGVkdWxlW2tzUm93ICsgM107IC8vIFVwZGF0ZSBzdGF0ZVxuXG4gICAgICAgIHMwID0gdDA7XG4gICAgICAgIHMxID0gdDE7XG4gICAgICAgIHMyID0gdDI7XG4gICAgICAgIHMzID0gdDM7XG4gICAgICAgIGtzUm93ID0ga3NSb3cgKyA0O1xuICAgICAgfSAvLyBTaGlmdCByb3dzLCBzdWIgYnl0ZXMsIGFkZCByb3VuZCBrZXlcblxuXG4gICAgICB0MCA9IGludlNCT1hbczAgPj4+IDI0XSA8PCAyNCBeIGludlNCT1hbczEgPj4gMTYgJiAweGZmXSA8PCAxNiBeIGludlNCT1hbczIgPj4gOCAmIDB4ZmZdIDw8IDggXiBpbnZTQk9YW3MzICYgMHhmZl0gXiBpbnZLZXlTY2hlZHVsZVtrc1Jvd107XG4gICAgICB0MSA9IGludlNCT1hbczEgPj4+IDI0XSA8PCAyNCBeIGludlNCT1hbczIgPj4gMTYgJiAweGZmXSA8PCAxNiBeIGludlNCT1hbczMgPj4gOCAmIDB4ZmZdIDw8IDggXiBpbnZTQk9YW3MwICYgMHhmZl0gXiBpbnZLZXlTY2hlZHVsZVtrc1JvdyArIDFdO1xuICAgICAgdDIgPSBpbnZTQk9YW3MyID4+PiAyNF0gPDwgMjQgXiBpbnZTQk9YW3MzID4+IDE2ICYgMHhmZl0gPDwgMTYgXiBpbnZTQk9YW3MwID4+IDggJiAweGZmXSA8PCA4IF4gaW52U0JPWFtzMSAmIDB4ZmZdIF4gaW52S2V5U2NoZWR1bGVba3NSb3cgKyAyXTtcbiAgICAgIHQzID0gaW52U0JPWFtzMyA+Pj4gMjRdIDw8IDI0IF4gaW52U0JPWFtzMCA+PiAxNiAmIDB4ZmZdIDw8IDE2IF4gaW52U0JPWFtzMSA+PiA4ICYgMHhmZl0gPDwgOCBeIGludlNCT1hbczIgJiAweGZmXSBeIGludktleVNjaGVkdWxlW2tzUm93ICsgM107IC8vIFdyaXRlXG5cbiAgICAgIG91dHB1dEludDMyW29mZnNldF0gPSBzd2FwV29yZCh0MCBeIGluaXRWZWN0b3IwKTtcbiAgICAgIG91dHB1dEludDMyW29mZnNldCArIDFdID0gc3dhcFdvcmQodDMgXiBpbml0VmVjdG9yMSk7XG4gICAgICBvdXRwdXRJbnQzMltvZmZzZXQgKyAyXSA9IHN3YXBXb3JkKHQyIF4gaW5pdFZlY3RvcjIpO1xuICAgICAgb3V0cHV0SW50MzJbb2Zmc2V0ICsgM10gPSBzd2FwV29yZCh0MSBeIGluaXRWZWN0b3IzKTsgLy8gcmVzZXQgaW5pdFZlY3RvciB0byBsYXN0IDQgdW5zaWduZWQgaW50XG5cbiAgICAgIGluaXRWZWN0b3IwID0gaW5wdXRXb3JkczA7XG4gICAgICBpbml0VmVjdG9yMSA9IGlucHV0V29yZHMxO1xuICAgICAgaW5pdFZlY3RvcjIgPSBpbnB1dFdvcmRzMjtcbiAgICAgIGluaXRWZWN0b3IzID0gaW5wdXRXb3JkczM7XG4gICAgICBvZmZzZXQgPSBvZmZzZXQgKyA0O1xuICAgIH1cblxuICAgIHJldHVybiBvdXRwdXRJbnQzMi5idWZmZXI7XG4gIH07XG5cbiAgcmV0dXJuIEFFU0RlY3J5cHRvcjtcbn0oKTtcblxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NyeXB0L2RlY3J5cHRlci50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvY3J5cHQvZGVjcnlwdGVyLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImRlZmF1bHRcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBEZWNyeXB0ZXI7IH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9hZXNfY3J5cHRvX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2Flcy1jcnlwdG8gKi8gXCIuL3NyYy9jcnlwdC9hZXMtY3J5cHRvLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9mYXN0X2Flc19rZXlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZmFzdC1hZXMta2V5ICovIFwiLi9zcmMvY3J5cHQvZmFzdC1hZXMta2V5LnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9hZXNfZGVjcnlwdG9yX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2Flcy1kZWNyeXB0b3IgKi8gXCIuL3NyYy9jcnlwdC9hZXMtZGVjcnlwdG9yLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL2xvZ2dlciAqLyBcIi4vc3JjL3V0aWxzL2xvZ2dlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfbXA0X3Rvb2xzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9tcDQtdG9vbHMgKi8gXCIuL3NyYy91dGlscy9tcDQtdG9vbHMudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX3R5cGVkX2FycmF5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy90eXBlZC1hcnJheSAqLyBcIi4vc3JjL3V0aWxzL3R5cGVkLWFycmF5LnRzXCIpO1xuXG5cblxuXG5cblxudmFyIENIVU5LX1NJWkUgPSAxNjsgLy8gMTYgYnl0ZXMsIDEyOCBiaXRzXG5cbnZhciBEZWNyeXB0ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBEZWNyeXB0ZXIob2JzZXJ2ZXIsIGNvbmZpZywgX3RlbXApIHtcbiAgICB2YXIgX3JlZiA9IF90ZW1wID09PSB2b2lkIDAgPyB7fSA6IF90ZW1wLFxuICAgICAgICBfcmVmJHJlbW92ZVBLQ1M3UGFkZGkgPSBfcmVmLnJlbW92ZVBLQ1M3UGFkZGluZyxcbiAgICAgICAgcmVtb3ZlUEtDUzdQYWRkaW5nID0gX3JlZiRyZW1vdmVQS0NTN1BhZGRpID09PSB2b2lkIDAgPyB0cnVlIDogX3JlZiRyZW1vdmVQS0NTN1BhZGRpO1xuXG4gICAgdGhpcy5sb2dFbmFibGVkID0gdHJ1ZTtcbiAgICB0aGlzLm9ic2VydmVyID0gdm9pZCAwO1xuICAgIHRoaXMuY29uZmlnID0gdm9pZCAwO1xuICAgIHRoaXMucmVtb3ZlUEtDUzdQYWRkaW5nID0gdm9pZCAwO1xuICAgIHRoaXMuc3VidGxlID0gbnVsbDtcbiAgICB0aGlzLnNvZnR3YXJlRGVjcnlwdGVyID0gbnVsbDtcbiAgICB0aGlzLmtleSA9IG51bGw7XG4gICAgdGhpcy5mYXN0QWVzS2V5ID0gbnVsbDtcbiAgICB0aGlzLnJlbWFpbmRlckRhdGEgPSBudWxsO1xuICAgIHRoaXMuY3VycmVudElWID0gbnVsbDtcbiAgICB0aGlzLmN1cnJlbnRSZXN1bHQgPSBudWxsO1xuICAgIHRoaXMub2JzZXJ2ZXIgPSBvYnNlcnZlcjtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICB0aGlzLnJlbW92ZVBLQ1M3UGFkZGluZyA9IHJlbW92ZVBLQ1M3UGFkZGluZzsgLy8gYnVpbHQgaW4gZGVjcnlwdG9yIGV4cGVjdHMgUEtDUzcgcGFkZGluZ1xuXG4gICAgaWYgKHJlbW92ZVBLQ1M3UGFkZGluZykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIGJyb3dzZXJDcnlwdG8gPSBzZWxmLmNyeXB0bztcblxuICAgICAgICBpZiAoYnJvd3NlckNyeXB0bykge1xuICAgICAgICAgIHRoaXMuc3VidGxlID0gYnJvd3NlckNyeXB0by5zdWJ0bGUgfHwgYnJvd3NlckNyeXB0by53ZWJraXRTdWJ0bGU7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLyogbm8tb3AgKi9cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5zdWJ0bGUgPT09IG51bGwpIHtcbiAgICAgIHRoaXMuY29uZmlnLmVuYWJsZVNvZnR3YXJlQUVTID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICB2YXIgX3Byb3RvID0gRGVjcnlwdGVyLnByb3RvdHlwZTtcblxuICBfcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHRoaXMub2JzZXJ2ZXIgPSBudWxsO1xuICB9O1xuXG4gIF9wcm90by5pc1N5bmMgPSBmdW5jdGlvbiBpc1N5bmMoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29uZmlnLmVuYWJsZVNvZnR3YXJlQUVTO1xuICB9O1xuXG4gIF9wcm90by5mbHVzaCA9IGZ1bmN0aW9uIGZsdXNoKCkge1xuICAgIHZhciBjdXJyZW50UmVzdWx0ID0gdGhpcy5jdXJyZW50UmVzdWx0O1xuXG4gICAgaWYgKCFjdXJyZW50UmVzdWx0KSB7XG4gICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGRhdGEgPSBuZXcgVWludDhBcnJheShjdXJyZW50UmVzdWx0KTtcbiAgICB0aGlzLnJlc2V0KCk7XG5cbiAgICBpZiAodGhpcy5yZW1vdmVQS0NTN1BhZGRpbmcpIHtcbiAgICAgIHJldHVybiBPYmplY3QoX2Flc19kZWNyeXB0b3JfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcInJlbW92ZVBhZGRpbmdcIl0pKGRhdGEpO1xuICAgIH1cblxuICAgIHJldHVybiBkYXRhO1xuICB9O1xuXG4gIF9wcm90by5yZXNldCA9IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgIHRoaXMuY3VycmVudFJlc3VsdCA9IG51bGw7XG4gICAgdGhpcy5jdXJyZW50SVYgPSBudWxsO1xuICAgIHRoaXMucmVtYWluZGVyRGF0YSA9IG51bGw7XG5cbiAgICBpZiAodGhpcy5zb2Z0d2FyZURlY3J5cHRlcikge1xuICAgICAgdGhpcy5zb2Z0d2FyZURlY3J5cHRlciA9IG51bGw7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5kZWNyeXB0ID0gZnVuY3Rpb24gZGVjcnlwdChkYXRhLCBrZXksIGl2LCBjYWxsYmFjaykge1xuICAgIGlmICh0aGlzLmNvbmZpZy5lbmFibGVTb2Z0d2FyZUFFUykge1xuICAgICAgdGhpcy5zb2Z0d2FyZURlY3J5cHQobmV3IFVpbnQ4QXJyYXkoZGF0YSksIGtleSwgaXYpO1xuICAgICAgdmFyIGRlY3J5cHRSZXN1bHQgPSB0aGlzLmZsdXNoKCk7XG5cbiAgICAgIGlmIChkZWNyeXB0UmVzdWx0KSB7XG4gICAgICAgIGNhbGxiYWNrKGRlY3J5cHRSZXN1bHQuYnVmZmVyKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy53ZWJDcnlwdG9EZWNyeXB0KG5ldyBVaW50OEFycmF5KGRhdGEpLCBrZXksIGl2KS50aGVuKGNhbGxiYWNrKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLnNvZnR3YXJlRGVjcnlwdCA9IGZ1bmN0aW9uIHNvZnR3YXJlRGVjcnlwdChkYXRhLCBrZXksIGl2KSB7XG4gICAgdmFyIGN1cnJlbnRJViA9IHRoaXMuY3VycmVudElWLFxuICAgICAgICBjdXJyZW50UmVzdWx0ID0gdGhpcy5jdXJyZW50UmVzdWx0LFxuICAgICAgICByZW1haW5kZXJEYXRhID0gdGhpcy5yZW1haW5kZXJEYXRhO1xuICAgIHRoaXMubG9nT25jZSgnSlMgQUVTIGRlY3J5cHQnKTsgLy8gVGhlIG91dHB1dCBpcyBzdGFnZ2VyZWQgZHVyaW5nIHByb2dyZXNzaXZlIHBhcnNpbmcgLSB0aGUgY3VycmVudCByZXN1bHQgaXMgY2FjaGVkLCBhbmQgZW1pdHRlZCBvbiB0aGUgbmV4dCBjYWxsXG4gICAgLy8gVGhpcyBpcyBkb25lIGluIG9yZGVyIHRvIHN0cmlwIFBLQ1M3IHBhZGRpbmcsIHdoaWNoIGlzIGZvdW5kIGF0IHRoZSBlbmQgb2YgZWFjaCBzZWdtZW50LiBXZSBvbmx5IGtub3cgd2UndmUgcmVhY2hlZFxuICAgIC8vIHRoZSBlbmQgb24gZmx1c2goKSwgYnV0IGJ5IHRoYXQgdGltZSB3ZSBoYXZlIGFscmVhZHkgcmVjZWl2ZWQgYWxsIGJ5dGVzIGZvciB0aGUgc2VnbWVudC5cbiAgICAvLyBQcm9ncmVzc2l2ZSBkZWNyeXB0aW9uIGRvZXMgbm90IHdvcmsgd2l0aCBXZWJDcnlwdG9cblxuICAgIGlmIChyZW1haW5kZXJEYXRhKSB7XG4gICAgICBkYXRhID0gT2JqZWN0KF91dGlsc19tcDRfdG9vbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1tcImFwcGVuZFVpbnQ4QXJyYXlcIl0pKHJlbWFpbmRlckRhdGEsIGRhdGEpO1xuICAgICAgdGhpcy5yZW1haW5kZXJEYXRhID0gbnVsbDtcbiAgICB9IC8vIEJ5dGUgbGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNiAoQUVTLTEyOCA9IDEyOCBiaXQgYmxvY2tzID0gMTYgYnl0ZXMpXG5cblxuICAgIHZhciBjdXJyZW50Q2h1bmsgPSB0aGlzLmdldFZhbGlkQ2h1bmsoZGF0YSk7XG5cbiAgICBpZiAoIWN1cnJlbnRDaHVuay5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmIChjdXJyZW50SVYpIHtcbiAgICAgIGl2ID0gY3VycmVudElWO1xuICAgIH1cblxuICAgIHZhciBzb2Z0d2FyZURlY3J5cHRlciA9IHRoaXMuc29mdHdhcmVEZWNyeXB0ZXI7XG5cbiAgICBpZiAoIXNvZnR3YXJlRGVjcnlwdGVyKSB7XG4gICAgICBzb2Z0d2FyZURlY3J5cHRlciA9IHRoaXMuc29mdHdhcmVEZWNyeXB0ZXIgPSBuZXcgX2Flc19kZWNyeXB0b3JfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImRlZmF1bHRcIl0oKTtcbiAgICB9XG5cbiAgICBzb2Z0d2FyZURlY3J5cHRlci5leHBhbmRLZXkoa2V5KTtcbiAgICB2YXIgcmVzdWx0ID0gY3VycmVudFJlc3VsdDtcbiAgICB0aGlzLmN1cnJlbnRSZXN1bHQgPSBzb2Z0d2FyZURlY3J5cHRlci5kZWNyeXB0KGN1cnJlbnRDaHVuay5idWZmZXIsIDAsIGl2KTtcbiAgICB0aGlzLmN1cnJlbnRJViA9IE9iamVjdChfdXRpbHNfdHlwZWRfYXJyYXlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcInNsaWNlVWludDhcIl0pKGN1cnJlbnRDaHVuaywgLTE2KS5idWZmZXI7XG5cbiAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICBfcHJvdG8ud2ViQ3J5cHRvRGVjcnlwdCA9IGZ1bmN0aW9uIHdlYkNyeXB0b0RlY3J5cHQoZGF0YSwga2V5LCBpdikge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgc3VidGxlID0gdGhpcy5zdWJ0bGU7XG5cbiAgICBpZiAodGhpcy5rZXkgIT09IGtleSB8fCAhdGhpcy5mYXN0QWVzS2V5KSB7XG4gICAgICB0aGlzLmtleSA9IGtleTtcbiAgICAgIHRoaXMuZmFzdEFlc0tleSA9IG5ldyBfZmFzdF9hZXNfa2V5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJkZWZhdWx0XCJdKHN1YnRsZSwga2V5KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5mYXN0QWVzS2V5LmV4cGFuZEtleSgpLnRoZW4oZnVuY3Rpb24gKGFlc0tleSkge1xuICAgICAgLy8gZGVjcnlwdCB1c2luZyB3ZWIgY3J5cHRvXG4gICAgICBpZiAoIXN1YnRsZSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCd3ZWIgY3J5cHRvIG5vdCBpbml0aWFsaXplZCcpKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGNyeXB0byA9IG5ldyBfYWVzX2NyeXB0b19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiZGVmYXVsdFwiXShzdWJ0bGUsIGl2KTtcbiAgICAgIHJldHVybiBjcnlwdG8uZGVjcnlwdChkYXRhLmJ1ZmZlciwgYWVzS2V5KTtcbiAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICByZXR1cm4gX3RoaXMub25XZWJDcnlwdG9FcnJvcihlcnIsIGRhdGEsIGtleSwgaXYpO1xuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90by5vbldlYkNyeXB0b0Vycm9yID0gZnVuY3Rpb24gb25XZWJDcnlwdG9FcnJvcihlcnIsIGRhdGEsIGtleSwgaXYpIHtcbiAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJsb2dnZXJcIl0ud2FybignW2RlY3J5cHRlci50c106IFdlYkNyeXB0byBFcnJvciwgZGlzYWJsZSBXZWJDcnlwdG8gQVBJOicsIGVycik7XG4gICAgdGhpcy5jb25maWcuZW5hYmxlU29mdHdhcmVBRVMgPSB0cnVlO1xuICAgIHRoaXMubG9nRW5hYmxlZCA9IHRydWU7XG4gICAgcmV0dXJuIHRoaXMuc29mdHdhcmVEZWNyeXB0KGRhdGEsIGtleSwgaXYpO1xuICB9O1xuXG4gIF9wcm90by5nZXRWYWxpZENodW5rID0gZnVuY3Rpb24gZ2V0VmFsaWRDaHVuayhkYXRhKSB7XG4gICAgdmFyIGN1cnJlbnRDaHVuayA9IGRhdGE7XG4gICAgdmFyIHNwbGl0UG9pbnQgPSBkYXRhLmxlbmd0aCAtIGRhdGEubGVuZ3RoICUgQ0hVTktfU0laRTtcblxuICAgIGlmIChzcGxpdFBvaW50ICE9PSBkYXRhLmxlbmd0aCkge1xuICAgICAgY3VycmVudENodW5rID0gT2JqZWN0KF91dGlsc190eXBlZF9hcnJheV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1wic2xpY2VVaW50OFwiXSkoZGF0YSwgMCwgc3BsaXRQb2ludCk7XG4gICAgICB0aGlzLnJlbWFpbmRlckRhdGEgPSBPYmplY3QoX3V0aWxzX3R5cGVkX2FycmF5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXCJzbGljZVVpbnQ4XCJdKShkYXRhLCBzcGxpdFBvaW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4gY3VycmVudENodW5rO1xuICB9O1xuXG4gIF9wcm90by5sb2dPbmNlID0gZnVuY3Rpb24gbG9nT25jZShtc2cpIHtcbiAgICBpZiAoIXRoaXMubG9nRW5hYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcImxvZ2dlclwiXS5sb2coXCJbZGVjcnlwdGVyLnRzXTogXCIgKyBtc2cpO1xuICAgIHRoaXMubG9nRW5hYmxlZCA9IGZhbHNlO1xuICB9O1xuXG4gIHJldHVybiBEZWNyeXB0ZXI7XG59KCk7XG5cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9jcnlwdC9mYXN0LWFlcy1rZXkudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NyeXB0L2Zhc3QtYWVzLWtleS50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJkZWZhdWx0XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gRmFzdEFFU0tleTsgfSk7XG52YXIgRmFzdEFFU0tleSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEZhc3RBRVNLZXkoc3VidGxlLCBrZXkpIHtcbiAgICB0aGlzLnN1YnRsZSA9IHZvaWQgMDtcbiAgICB0aGlzLmtleSA9IHZvaWQgMDtcbiAgICB0aGlzLnN1YnRsZSA9IHN1YnRsZTtcbiAgICB0aGlzLmtleSA9IGtleTtcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBGYXN0QUVTS2V5LnByb3RvdHlwZTtcblxuICBfcHJvdG8uZXhwYW5kS2V5ID0gZnVuY3Rpb24gZXhwYW5kS2V5KCkge1xuICAgIHJldHVybiB0aGlzLnN1YnRsZS5pbXBvcnRLZXkoJ3JhdycsIHRoaXMua2V5LCB7XG4gICAgICBuYW1lOiAnQUVTLUNCQydcbiAgICB9LCBmYWxzZSwgWydlbmNyeXB0JywgJ2RlY3J5cHQnXSk7XG4gIH07XG5cbiAgcmV0dXJuIEZhc3RBRVNLZXk7XG59KCk7XG5cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9kZW11eC9hYWNkZW11eGVyLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvZGVtdXgvYWFjZGVtdXhlci50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2Jhc2VfYXVkaW9fZGVtdXhlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9iYXNlLWF1ZGlvLWRlbXV4ZXIgKi8gXCIuL3NyYy9kZW11eC9iYXNlLWF1ZGlvLWRlbXV4ZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2FkdHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vYWR0cyAqLyBcIi4vc3JjL2RlbXV4L2FkdHMudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvbG9nZ2VyICovIFwiLi9zcmMvdXRpbHMvbG9nZ2VyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9kZW11eF9pZDNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2RlbXV4L2lkMyAqLyBcIi4vc3JjL2RlbXV4L2lkMy50c1wiKTtcbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpOyBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzczsgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG4vKipcbiAqIEFBQyBkZW11eGVyXG4gKi9cblxuXG5cblxuXG52YXIgQUFDRGVtdXhlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0Jhc2VBdWRpb0RlbXV4ZXIpIHtcbiAgX2luaGVyaXRzTG9vc2UoQUFDRGVtdXhlciwgX0Jhc2VBdWRpb0RlbXV4ZXIpO1xuXG4gIGZ1bmN0aW9uIEFBQ0RlbXV4ZXIob2JzZXJ2ZXIsIGNvbmZpZykge1xuICAgIHZhciBfdGhpcztcblxuICAgIF90aGlzID0gX0Jhc2VBdWRpb0RlbXV4ZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgIF90aGlzLm9ic2VydmVyID0gdm9pZCAwO1xuICAgIF90aGlzLmNvbmZpZyA9IHZvaWQgMDtcbiAgICBfdGhpcy5vYnNlcnZlciA9IG9ic2VydmVyO1xuICAgIF90aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gQUFDRGVtdXhlci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLnJlc2V0SW5pdFNlZ21lbnQgPSBmdW5jdGlvbiByZXNldEluaXRTZWdtZW50KGF1ZGlvQ29kZWMsIHZpZGVvQ29kZWMsIGR1cmF0aW9uKSB7XG4gICAgX0Jhc2VBdWRpb0RlbXV4ZXIucHJvdG90eXBlLnJlc2V0SW5pdFNlZ21lbnQuY2FsbCh0aGlzLCBhdWRpb0NvZGVjLCB2aWRlb0NvZGVjLCBkdXJhdGlvbik7XG5cbiAgICB0aGlzLl9hdWRpb1RyYWNrID0ge1xuICAgICAgY29udGFpbmVyOiAnYXVkaW8vYWR0cycsXG4gICAgICB0eXBlOiAnYXVkaW8nLFxuICAgICAgaWQ6IDIsXG4gICAgICBwaWQ6IC0xLFxuICAgICAgc2VxdWVuY2VOdW1iZXI6IDAsXG4gICAgICBpc0FBQzogdHJ1ZSxcbiAgICAgIHNhbXBsZXM6IFtdLFxuICAgICAgbWFuaWZlc3RDb2RlYzogYXVkaW9Db2RlYyxcbiAgICAgIGR1cmF0aW9uOiBkdXJhdGlvbixcbiAgICAgIGlucHV0VGltZVNjYWxlOiA5MDAwMCxcbiAgICAgIGRyb3BwZWQ6IDBcbiAgICB9O1xuICB9IC8vIFNvdXJjZSBmb3IgcHJvYmUgaW5mbyAtIGh0dHBzOi8vd2lraS5tdWx0aW1lZGlhLmN4L2luZGV4LnBocD90aXRsZT1BRFRTXG4gIDtcblxuICBBQUNEZW11eGVyLnByb2JlID0gZnVuY3Rpb24gcHJvYmUoZGF0YSkge1xuICAgIGlmICghZGF0YSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gLy8gQ2hlY2sgZm9yIHRoZSBBRFRTIHN5bmMgd29yZFxuICAgIC8vIExvb2sgZm9yIEFEVFMgaGVhZGVyIHwgMTExMSAxMTExIHwgMTExMSBYMDBYIHwgd2hlcmUgWCBjYW4gYmUgZWl0aGVyIDAgb3IgMVxuICAgIC8vIExheWVyIGJpdHMgKHBvc2l0aW9uIDE0IGFuZCAxNSkgaW4gaGVhZGVyIHNob3VsZCBiZSBhbHdheXMgMCBmb3IgQURUU1xuICAgIC8vIE1vcmUgaW5mbyBodHRwczovL3dpa2kubXVsdGltZWRpYS5jeC9pbmRleC5waHA/dGl0bGU9QURUU1xuXG5cbiAgICB2YXIgaWQzRGF0YSA9IF9kZW11eF9pZDNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcImdldElEM0RhdGFcIl0oZGF0YSwgMCkgfHwgW107XG4gICAgdmFyIG9mZnNldCA9IGlkM0RhdGEubGVuZ3RoO1xuXG4gICAgZm9yICh2YXIgbGVuZ3RoID0gZGF0YS5sZW5ndGg7IG9mZnNldCA8IGxlbmd0aDsgb2Zmc2V0KyspIHtcbiAgICAgIGlmIChfYWR0c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wicHJvYmVcIl0oZGF0YSwgb2Zmc2V0KSkge1xuICAgICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJsb2dnZXJcIl0ubG9nKCdBRFRTIHN5bmMgd29yZCBmb3VuZCAhJyk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICBfcHJvdG8uY2FuUGFyc2UgPSBmdW5jdGlvbiBjYW5QYXJzZShkYXRhLCBvZmZzZXQpIHtcbiAgICByZXR1cm4gX2FkdHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImNhblBhcnNlXCJdKGRhdGEsIG9mZnNldCk7XG4gIH07XG5cbiAgX3Byb3RvLmFwcGVuZEZyYW1lID0gZnVuY3Rpb24gYXBwZW5kRnJhbWUodHJhY2ssIGRhdGEsIG9mZnNldCkge1xuICAgIF9hZHRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJpbml0VHJhY2tDb25maWdcIl0odHJhY2ssIHRoaXMub2JzZXJ2ZXIsIGRhdGEsIG9mZnNldCwgdHJhY2subWFuaWZlc3RDb2RlYyk7XG4gICAgdmFyIGZyYW1lID0gX2FkdHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImFwcGVuZEZyYW1lXCJdKHRyYWNrLCBkYXRhLCBvZmZzZXQsIHRoaXMuaW5pdFBUUywgdGhpcy5mcmFtZUluZGV4KTtcblxuICAgIGlmIChmcmFtZSAmJiBmcmFtZS5taXNzaW5nID09PSAwKSB7XG4gICAgICByZXR1cm4gZnJhbWU7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBBQUNEZW11eGVyO1xufShfYmFzZV9hdWRpb19kZW11eGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJkZWZhdWx0XCJdKTtcblxuQUFDRGVtdXhlci5taW5Qcm9iZUJ5dGVMZW5ndGggPSA5O1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChBQUNEZW11eGVyKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvZGVtdXgvYWR0cy50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2RlbXV4L2FkdHMudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBnZXRBdWRpb0NvbmZpZywgaXNIZWFkZXJQYXR0ZXJuLCBnZXRIZWFkZXJMZW5ndGgsIGdldEZ1bGxGcmFtZUxlbmd0aCwgY2FuR2V0RnJhbWVMZW5ndGgsIGlzSGVhZGVyLCBjYW5QYXJzZSwgcHJvYmUsIGluaXRUcmFja0NvbmZpZywgZ2V0RnJhbWVEdXJhdGlvbiwgcGFyc2VGcmFtZUhlYWRlciwgYXBwZW5kRnJhbWUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZ2V0QXVkaW9Db25maWdcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBnZXRBdWRpb0NvbmZpZzsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiaXNIZWFkZXJQYXR0ZXJuXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gaXNIZWFkZXJQYXR0ZXJuOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJnZXRIZWFkZXJMZW5ndGhcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBnZXRIZWFkZXJMZW5ndGg7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImdldEZ1bGxGcmFtZUxlbmd0aFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGdldEZ1bGxGcmFtZUxlbmd0aDsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiY2FuR2V0RnJhbWVMZW5ndGhcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBjYW5HZXRGcmFtZUxlbmd0aDsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiaXNIZWFkZXJcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBpc0hlYWRlcjsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiY2FuUGFyc2VcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBjYW5QYXJzZTsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwicHJvYmVcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBwcm9iZTsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiaW5pdFRyYWNrQ29uZmlnXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gaW5pdFRyYWNrQ29uZmlnOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJnZXRGcmFtZUR1cmF0aW9uXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZ2V0RnJhbWVEdXJhdGlvbjsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwicGFyc2VGcmFtZUhlYWRlclwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHBhcnNlRnJhbWVIZWFkZXI7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImFwcGVuZEZyYW1lXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gYXBwZW5kRnJhbWU7IH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL2xvZ2dlciAqLyBcIi4vc3JjL3V0aWxzL2xvZ2dlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9lcnJvcnMgKi8gXCIuL3NyYy9lcnJvcnMudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZXZlbnRzICovIFwiLi9zcmMvZXZlbnRzLnRzXCIpO1xuLyoqXG4gKiBBRFRTIHBhcnNlciBoZWxwZXJcbiAqIEBsaW5rIGh0dHBzOi8vd2lraS5tdWx0aW1lZGlhLmN4L2luZGV4LnBocD90aXRsZT1BRFRTXG4gKi9cblxuXG5cbmZ1bmN0aW9uIGdldEF1ZGlvQ29uZmlnKG9ic2VydmVyLCBkYXRhLCBvZmZzZXQsIGF1ZGlvQ29kZWMpIHtcbiAgdmFyIGFkdHNPYmplY3RUeXBlO1xuICB2YXIgYWR0c0V4dGVuc2lvblNhbXBsaW5nSW5kZXg7XG4gIHZhciBhZHRzQ2hhbmVsQ29uZmlnO1xuICB2YXIgY29uZmlnO1xuICB2YXIgdXNlckFnZW50ID0gbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpO1xuICB2YXIgbWFuaWZlc3RDb2RlYyA9IGF1ZGlvQ29kZWM7XG4gIHZhciBhZHRzU2FtcGxlaW5nUmF0ZXMgPSBbOTYwMDAsIDg4MjAwLCA2NDAwMCwgNDgwMDAsIDQ0MTAwLCAzMjAwMCwgMjQwMDAsIDIyMDUwLCAxNjAwMCwgMTIwMDAsIDExMDI1LCA4MDAwLCA3MzUwXTsgLy8gYnl0ZSAyXG5cbiAgYWR0c09iamVjdFR5cGUgPSAoKGRhdGFbb2Zmc2V0ICsgMl0gJiAweGMwKSA+Pj4gNikgKyAxO1xuICB2YXIgYWR0c1NhbXBsaW5nSW5kZXggPSAoZGF0YVtvZmZzZXQgKyAyXSAmIDB4M2MpID4+PiAyO1xuXG4gIGlmIChhZHRzU2FtcGxpbmdJbmRleCA+IGFkdHNTYW1wbGVpbmdSYXRlcy5sZW5ndGggLSAxKSB7XG4gICAgb2JzZXJ2ZXIudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJFdmVudHNcIl0uRVJST1IsIHtcbiAgICAgIHR5cGU6IF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkVycm9yVHlwZXNcIl0uTUVESUFfRVJST1IsXG4gICAgICBkZXRhaWxzOiBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFcnJvckRldGFpbHNcIl0uRlJBR19QQVJTSU5HX0VSUk9SLFxuICAgICAgZmF0YWw6IHRydWUsXG4gICAgICByZWFzb246IFwiaW52YWxpZCBBRFRTIHNhbXBsaW5nIGluZGV4OlwiICsgYWR0c1NhbXBsaW5nSW5kZXhcbiAgICB9KTtcbiAgICByZXR1cm47XG4gIH1cblxuICBhZHRzQ2hhbmVsQ29uZmlnID0gKGRhdGFbb2Zmc2V0ICsgMl0gJiAweDAxKSA8PCAyOyAvLyBieXRlIDNcblxuICBhZHRzQ2hhbmVsQ29uZmlnIHw9IChkYXRhW29mZnNldCArIDNdICYgMHhjMCkgPj4+IDY7XG4gIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImxvZ2dlclwiXS5sb2coXCJtYW5pZmVzdCBjb2RlYzpcIiArIGF1ZGlvQ29kZWMgKyBcIiwgQURUUyB0eXBlOlwiICsgYWR0c09iamVjdFR5cGUgKyBcIiwgc2FtcGxpbmdJbmRleDpcIiArIGFkdHNTYW1wbGluZ0luZGV4KTsgLy8gZmlyZWZveDogZnJlcSBsZXNzIHRoYW4gMjRrSHogPSBBQUMgU0JSIChIRS1BQUMpXG5cbiAgaWYgKC9maXJlZm94L2kudGVzdCh1c2VyQWdlbnQpKSB7XG4gICAgaWYgKGFkdHNTYW1wbGluZ0luZGV4ID49IDYpIHtcbiAgICAgIGFkdHNPYmplY3RUeXBlID0gNTtcbiAgICAgIGNvbmZpZyA9IG5ldyBBcnJheSg0KTsgLy8gSEUtQUFDIHVzZXMgU0JSIChTcGVjdHJhbCBCYW5kIFJlcGxpY2F0aW9uKSAsIGhpZ2ggZnJlcXVlbmNpZXMgYXJlIGNvbnN0cnVjdGVkIGZyb20gbG93IGZyZXF1ZW5jaWVzXG4gICAgICAvLyB0aGVyZSBpcyBhIGZhY3RvciAyIGJldHdlZW4gZnJhbWUgc2FtcGxlIHJhdGUgYW5kIG91dHB1dCBzYW1wbGUgcmF0ZVxuICAgICAgLy8gbXVsdGlwbHkgZnJlcXVlbmN5IGJ5IDIgKHNlZSB0YWJsZSBiZWxvdywgZXF1aXZhbGVudCB0byBzdWJzdHJhY3QgMylcblxuICAgICAgYWR0c0V4dGVuc2lvblNhbXBsaW5nSW5kZXggPSBhZHRzU2FtcGxpbmdJbmRleCAtIDM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFkdHNPYmplY3RUeXBlID0gMjtcbiAgICAgIGNvbmZpZyA9IG5ldyBBcnJheSgyKTtcbiAgICAgIGFkdHNFeHRlbnNpb25TYW1wbGluZ0luZGV4ID0gYWR0c1NhbXBsaW5nSW5kZXg7XG4gICAgfSAvLyBBbmRyb2lkIDogYWx3YXlzIHVzZSBBQUNcblxuICB9IGVsc2UgaWYgKHVzZXJBZ2VudC5pbmRleE9mKCdhbmRyb2lkJykgIT09IC0xKSB7XG4gICAgYWR0c09iamVjdFR5cGUgPSAyO1xuICAgIGNvbmZpZyA9IG5ldyBBcnJheSgyKTtcbiAgICBhZHRzRXh0ZW5zaW9uU2FtcGxpbmdJbmRleCA9IGFkdHNTYW1wbGluZ0luZGV4O1xuICB9IGVsc2Uge1xuICAgIC8qICBmb3Igb3RoZXIgYnJvd3NlcnMgKENocm9tZS9WaXZhbGRpL09wZXJhIC4uLilcbiAgICAgICAgYWx3YXlzIGZvcmNlIGF1ZGlvIHR5cGUgdG8gYmUgSEUtQUFDIFNCUiwgYXMgc29tZSBicm93c2VycyBkbyBub3Qgc3VwcG9ydCBhdWRpbyBjb2RlYyBzd2l0Y2ggcHJvcGVybHkgKGxpa2UgQ2hyb21lIC4uLilcbiAgICAqL1xuICAgIGFkdHNPYmplY3RUeXBlID0gNTtcbiAgICBjb25maWcgPSBuZXcgQXJyYXkoNCk7IC8vIGlmIChtYW5pZmVzdCBjb2RlYyBpcyBIRS1BQUMgb3IgSEUtQUFDdjIpIE9SIChtYW5pZmVzdCBjb2RlYyBub3Qgc3BlY2lmaWVkIEFORCBmcmVxdWVuY3kgbGVzcyB0aGFuIDI0a0h6KVxuXG4gICAgaWYgKGF1ZGlvQ29kZWMgJiYgKGF1ZGlvQ29kZWMuaW5kZXhPZignbXA0YS40MC4yOScpICE9PSAtMSB8fCBhdWRpb0NvZGVjLmluZGV4T2YoJ21wNGEuNDAuNScpICE9PSAtMSkgfHwgIWF1ZGlvQ29kZWMgJiYgYWR0c1NhbXBsaW5nSW5kZXggPj0gNikge1xuICAgICAgLy8gSEUtQUFDIHVzZXMgU0JSIChTcGVjdHJhbCBCYW5kIFJlcGxpY2F0aW9uKSAsIGhpZ2ggZnJlcXVlbmNpZXMgYXJlIGNvbnN0cnVjdGVkIGZyb20gbG93IGZyZXF1ZW5jaWVzXG4gICAgICAvLyB0aGVyZSBpcyBhIGZhY3RvciAyIGJldHdlZW4gZnJhbWUgc2FtcGxlIHJhdGUgYW5kIG91dHB1dCBzYW1wbGUgcmF0ZVxuICAgICAgLy8gbXVsdGlwbHkgZnJlcXVlbmN5IGJ5IDIgKHNlZSB0YWJsZSBiZWxvdywgZXF1aXZhbGVudCB0byBzdWJzdHJhY3QgMylcbiAgICAgIGFkdHNFeHRlbnNpb25TYW1wbGluZ0luZGV4ID0gYWR0c1NhbXBsaW5nSW5kZXggLSAzO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBpZiAobWFuaWZlc3QgY29kZWMgaXMgQUFDKSBBTkQgKGZyZXF1ZW5jeSBsZXNzIHRoYW4gMjRrSHogQU5EIG5iIGNoYW5uZWwgaXMgMSkgT1IgKG1hbmlmZXN0IGNvZGVjIG5vdCBzcGVjaWZpZWQgYW5kIG1vbm8gYXVkaW8pXG4gICAgICAvLyBDaHJvbWUgZmFpbHMgdG8gcGxheSBiYWNrIHdpdGggbG93IGZyZXF1ZW5jeSBBQUMgTEMgbW9ubyB3aGVuIGluaXRpYWxpemVkIHdpdGggSEUtQUFDLiAgVGhpcyBpcyBub3QgYSBwcm9ibGVtIHdpdGggc3RlcmVvLlxuICAgICAgaWYgKGF1ZGlvQ29kZWMgJiYgYXVkaW9Db2RlYy5pbmRleE9mKCdtcDRhLjQwLjInKSAhPT0gLTEgJiYgKGFkdHNTYW1wbGluZ0luZGV4ID49IDYgJiYgYWR0c0NoYW5lbENvbmZpZyA9PT0gMSB8fCAvdml2YWxkaS9pLnRlc3QodXNlckFnZW50KSkgfHwgIWF1ZGlvQ29kZWMgJiYgYWR0c0NoYW5lbENvbmZpZyA9PT0gMSkge1xuICAgICAgICBhZHRzT2JqZWN0VHlwZSA9IDI7XG4gICAgICAgIGNvbmZpZyA9IG5ldyBBcnJheSgyKTtcbiAgICAgIH1cblxuICAgICAgYWR0c0V4dGVuc2lvblNhbXBsaW5nSW5kZXggPSBhZHRzU2FtcGxpbmdJbmRleDtcbiAgICB9XG4gIH1cbiAgLyogcmVmZXIgdG8gaHR0cDovL3dpa2kubXVsdGltZWRpYS5jeC9pbmRleC5waHA/dGl0bGU9TVBFRy00X0F1ZGlvI0F1ZGlvX1NwZWNpZmljX0NvbmZpZ1xuICAgICAgSVNPIDE0NDk2LTMgKEFBQykucGRmIC0gVGFibGUgMS4xMyDigJQgU3ludGF4IG9mIEF1ZGlvU3BlY2lmaWNDb25maWcoKVxuICAgIEF1ZGlvIFByb2ZpbGUgLyBBdWRpbyBPYmplY3QgVHlwZVxuICAgIDA6IE51bGxcbiAgICAxOiBBQUMgTWFpblxuICAgIDI6IEFBQyBMQyAoTG93IENvbXBsZXhpdHkpXG4gICAgMzogQUFDIFNTUiAoU2NhbGFibGUgU2FtcGxlIFJhdGUpXG4gICAgNDogQUFDIExUUCAoTG9uZyBUZXJtIFByZWRpY3Rpb24pXG4gICAgNTogU0JSIChTcGVjdHJhbCBCYW5kIFJlcGxpY2F0aW9uKVxuICAgIDY6IEFBQyBTY2FsYWJsZVxuICAgc2FtcGxpbmcgZnJlcVxuICAgIDA6IDk2MDAwIEh6XG4gICAgMTogODgyMDAgSHpcbiAgICAyOiA2NDAwMCBIelxuICAgIDM6IDQ4MDAwIEh6XG4gICAgNDogNDQxMDAgSHpcbiAgICA1OiAzMjAwMCBIelxuICAgIDY6IDI0MDAwIEh6XG4gICAgNzogMjIwNTAgSHpcbiAgICA4OiAxNjAwMCBIelxuICAgIDk6IDEyMDAwIEh6XG4gICAgMTA6IDExMDI1IEh6XG4gICAgMTE6IDgwMDAgSHpcbiAgICAxMjogNzM1MCBIelxuICAgIDEzOiBSZXNlcnZlZFxuICAgIDE0OiBSZXNlcnZlZFxuICAgIDE1OiBmcmVxdWVuY3kgaXMgd3JpdHRlbiBleHBsaWN0bHlcbiAgICBDaGFubmVsIENvbmZpZ3VyYXRpb25zXG4gICAgVGhlc2UgYXJlIHRoZSBjaGFubmVsIGNvbmZpZ3VyYXRpb25zOlxuICAgIDA6IERlZmluZWQgaW4gQU9UIFNwZWNpZmMgQ29uZmlnXG4gICAgMTogMSBjaGFubmVsOiBmcm9udC1jZW50ZXJcbiAgICAyOiAyIGNoYW5uZWxzOiBmcm9udC1sZWZ0LCBmcm9udC1yaWdodFxuICAqL1xuICAvLyBhdWRpb09iamVjdFR5cGUgPSBwcm9maWxlID0+IHByb2ZpbGUsIHRoZSBNUEVHLTQgQXVkaW8gT2JqZWN0IFR5cGUgbWludXMgMVxuXG5cbiAgY29uZmlnWzBdID0gYWR0c09iamVjdFR5cGUgPDwgMzsgLy8gc2FtcGxpbmdGcmVxdWVuY3lJbmRleFxuXG4gIGNvbmZpZ1swXSB8PSAoYWR0c1NhbXBsaW5nSW5kZXggJiAweDBlKSA+PiAxO1xuICBjb25maWdbMV0gfD0gKGFkdHNTYW1wbGluZ0luZGV4ICYgMHgwMSkgPDwgNzsgLy8gY2hhbm5lbENvbmZpZ3VyYXRpb25cblxuICBjb25maWdbMV0gfD0gYWR0c0NoYW5lbENvbmZpZyA8PCAzO1xuXG4gIGlmIChhZHRzT2JqZWN0VHlwZSA9PT0gNSkge1xuICAgIC8vIGFkdHNFeHRlbnNpb25TYW1wbGVpbmdJbmRleFxuICAgIGNvbmZpZ1sxXSB8PSAoYWR0c0V4dGVuc2lvblNhbXBsaW5nSW5kZXggJiAweDBlKSA+PiAxO1xuICAgIGNvbmZpZ1syXSA9IChhZHRzRXh0ZW5zaW9uU2FtcGxpbmdJbmRleCAmIDB4MDEpIDw8IDc7IC8vIGFkdHNPYmplY3RUeXBlIChmb3JjZSB0byAyLCBjaHJvbWUgaXMgY2hlY2tpbmcgdGhhdCBvYmplY3QgdHlwZSBpcyBsZXNzIHRoYW4gNSA/Pz9cbiAgICAvLyAgICBodHRwczovL2Nocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjLmdpdC8rL21hc3Rlci9tZWRpYS9mb3JtYXRzL21wNC9hYWMuY2NcblxuICAgIGNvbmZpZ1syXSB8PSAyIDw8IDI7XG4gICAgY29uZmlnWzNdID0gMDtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgY29uZmlnOiBjb25maWcsXG4gICAgc2FtcGxlcmF0ZTogYWR0c1NhbXBsZWluZ1JhdGVzW2FkdHNTYW1wbGluZ0luZGV4XSxcbiAgICBjaGFubmVsQ291bnQ6IGFkdHNDaGFuZWxDb25maWcsXG4gICAgY29kZWM6ICdtcDRhLjQwLicgKyBhZHRzT2JqZWN0VHlwZSxcbiAgICBtYW5pZmVzdENvZGVjOiBtYW5pZmVzdENvZGVjXG4gIH07XG59XG5mdW5jdGlvbiBpc0hlYWRlclBhdHRlcm4oZGF0YSwgb2Zmc2V0KSB7XG4gIHJldHVybiBkYXRhW29mZnNldF0gPT09IDB4ZmYgJiYgKGRhdGFbb2Zmc2V0ICsgMV0gJiAweGY2KSA9PT0gMHhmMDtcbn1cbmZ1bmN0aW9uIGdldEhlYWRlckxlbmd0aChkYXRhLCBvZmZzZXQpIHtcbiAgcmV0dXJuIGRhdGFbb2Zmc2V0ICsgMV0gJiAweDAxID8gNyA6IDk7XG59XG5mdW5jdGlvbiBnZXRGdWxsRnJhbWVMZW5ndGgoZGF0YSwgb2Zmc2V0KSB7XG4gIHJldHVybiAoZGF0YVtvZmZzZXQgKyAzXSAmIDB4MDMpIDw8IDExIHwgZGF0YVtvZmZzZXQgKyA0XSA8PCAzIHwgKGRhdGFbb2Zmc2V0ICsgNV0gJiAweGUwKSA+Pj4gNTtcbn1cbmZ1bmN0aW9uIGNhbkdldEZyYW1lTGVuZ3RoKGRhdGEsIG9mZnNldCkge1xuICByZXR1cm4gb2Zmc2V0ICsgNSA8IGRhdGEubGVuZ3RoO1xufVxuZnVuY3Rpb24gaXNIZWFkZXIoZGF0YSwgb2Zmc2V0KSB7XG4gIC8vIExvb2sgZm9yIEFEVFMgaGVhZGVyIHwgMTExMSAxMTExIHwgMTExMSBYMDBYIHwgd2hlcmUgWCBjYW4gYmUgZWl0aGVyIDAgb3IgMVxuICAvLyBMYXllciBiaXRzIChwb3NpdGlvbiAxNCBhbmQgMTUpIGluIGhlYWRlciBzaG91bGQgYmUgYWx3YXlzIDAgZm9yIEFEVFNcbiAgLy8gTW9yZSBpbmZvIGh0dHBzOi8vd2lraS5tdWx0aW1lZGlhLmN4L2luZGV4LnBocD90aXRsZT1BRFRTXG4gIHJldHVybiBvZmZzZXQgKyAxIDwgZGF0YS5sZW5ndGggJiYgaXNIZWFkZXJQYXR0ZXJuKGRhdGEsIG9mZnNldCk7XG59XG5mdW5jdGlvbiBjYW5QYXJzZShkYXRhLCBvZmZzZXQpIHtcbiAgcmV0dXJuIGNhbkdldEZyYW1lTGVuZ3RoKGRhdGEsIG9mZnNldCkgJiYgaXNIZWFkZXJQYXR0ZXJuKGRhdGEsIG9mZnNldCkgJiYgZ2V0RnVsbEZyYW1lTGVuZ3RoKGRhdGEsIG9mZnNldCkgPD0gZGF0YS5sZW5ndGggLSBvZmZzZXQ7XG59XG5mdW5jdGlvbiBwcm9iZShkYXRhLCBvZmZzZXQpIHtcbiAgLy8gc2FtZSBhcyBpc0hlYWRlciBidXQgd2UgYWxzbyBjaGVjayB0aGF0IEFEVFMgZnJhbWUgZm9sbG93cyBsYXN0IEFEVFMgZnJhbWVcbiAgLy8gb3IgZW5kIG9mIGRhdGEgaXMgcmVhY2hlZFxuICBpZiAoaXNIZWFkZXIoZGF0YSwgb2Zmc2V0KSkge1xuICAgIC8vIEFEVFMgaGVhZGVyIExlbmd0aFxuICAgIHZhciBoZWFkZXJMZW5ndGggPSBnZXRIZWFkZXJMZW5ndGgoZGF0YSwgb2Zmc2V0KTtcblxuICAgIGlmIChvZmZzZXQgKyBoZWFkZXJMZW5ndGggPj0gZGF0YS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IC8vIEFEVFMgZnJhbWUgTGVuZ3RoXG5cblxuICAgIHZhciBmcmFtZUxlbmd0aCA9IGdldEZ1bGxGcmFtZUxlbmd0aChkYXRhLCBvZmZzZXQpO1xuXG4gICAgaWYgKGZyYW1lTGVuZ3RoIDw9IGhlYWRlckxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBuZXdPZmZzZXQgPSBvZmZzZXQgKyBmcmFtZUxlbmd0aDtcbiAgICByZXR1cm4gbmV3T2Zmc2V0ID09PSBkYXRhLmxlbmd0aCB8fCBpc0hlYWRlcihkYXRhLCBuZXdPZmZzZXQpO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaW5pdFRyYWNrQ29uZmlnKHRyYWNrLCBvYnNlcnZlciwgZGF0YSwgb2Zmc2V0LCBhdWRpb0NvZGVjKSB7XG4gIGlmICghdHJhY2suc2FtcGxlcmF0ZSkge1xuICAgIHZhciBjb25maWcgPSBnZXRBdWRpb0NvbmZpZyhvYnNlcnZlciwgZGF0YSwgb2Zmc2V0LCBhdWRpb0NvZGVjKTtcblxuICAgIGlmICghY29uZmlnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdHJhY2suY29uZmlnID0gY29uZmlnLmNvbmZpZztcbiAgICB0cmFjay5zYW1wbGVyYXRlID0gY29uZmlnLnNhbXBsZXJhdGU7XG4gICAgdHJhY2suY2hhbm5lbENvdW50ID0gY29uZmlnLmNoYW5uZWxDb3VudDtcbiAgICB0cmFjay5jb2RlYyA9IGNvbmZpZy5jb2RlYztcbiAgICB0cmFjay5tYW5pZmVzdENvZGVjID0gY29uZmlnLm1hbmlmZXN0Q29kZWM7XG4gICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wibG9nZ2VyXCJdLmxvZyhcInBhcnNlZCBjb2RlYzpcIiArIHRyYWNrLmNvZGVjICsgXCIsIHJhdGU6XCIgKyBjb25maWcuc2FtcGxlcmF0ZSArIFwiLCBjaGFubmVsczpcIiArIGNvbmZpZy5jaGFubmVsQ291bnQpO1xuICB9XG59XG5mdW5jdGlvbiBnZXRGcmFtZUR1cmF0aW9uKHNhbXBsZXJhdGUpIHtcbiAgcmV0dXJuIDEwMjQgKiA5MDAwMCAvIHNhbXBsZXJhdGU7XG59XG5mdW5jdGlvbiBwYXJzZUZyYW1lSGVhZGVyKGRhdGEsIG9mZnNldCwgcHRzLCBmcmFtZUluZGV4LCBmcmFtZUR1cmF0aW9uKSB7XG4gIC8vIFRoZSBwcm90ZWN0aW9uIHNraXAgYml0IHRlbGxzIHVzIGlmIHdlIGhhdmUgMiBieXRlcyBvZiBDUkMgZGF0YSBhdCB0aGUgZW5kIG9mIHRoZSBBRFRTIGhlYWRlclxuICB2YXIgaGVhZGVyTGVuZ3RoID0gZ2V0SGVhZGVyTGVuZ3RoKGRhdGEsIG9mZnNldCk7IC8vIHJldHJpZXZlIGZyYW1lIHNpemVcblxuICB2YXIgZnJhbWVMZW5ndGggPSBnZXRGdWxsRnJhbWVMZW5ndGgoZGF0YSwgb2Zmc2V0KTtcbiAgZnJhbWVMZW5ndGggLT0gaGVhZGVyTGVuZ3RoO1xuXG4gIGlmIChmcmFtZUxlbmd0aCA+IDApIHtcbiAgICB2YXIgc3RhbXAgPSBwdHMgKyBmcmFtZUluZGV4ICogZnJhbWVEdXJhdGlvbjsgLy8gbG9nZ2VyLmxvZyhgQUFDIGZyYW1lLCBvZmZzZXQvbGVuZ3RoL3RvdGFsL3B0czoke29mZnNldCtoZWFkZXJMZW5ndGh9LyR7ZnJhbWVMZW5ndGh9LyR7ZGF0YS5ieXRlTGVuZ3RofS8keyhzdGFtcC85MCkudG9GaXhlZCgwKX1gKTtcblxuICAgIHJldHVybiB7XG4gICAgICBoZWFkZXJMZW5ndGg6IGhlYWRlckxlbmd0aCxcbiAgICAgIGZyYW1lTGVuZ3RoOiBmcmFtZUxlbmd0aCxcbiAgICAgIHN0YW1wOiBzdGFtcFxuICAgIH07XG4gIH1cbn1cbmZ1bmN0aW9uIGFwcGVuZEZyYW1lKHRyYWNrLCBkYXRhLCBvZmZzZXQsIHB0cywgZnJhbWVJbmRleCkge1xuICB2YXIgZnJhbWVEdXJhdGlvbiA9IGdldEZyYW1lRHVyYXRpb24odHJhY2suc2FtcGxlcmF0ZSk7XG4gIHZhciBoZWFkZXIgPSBwYXJzZUZyYW1lSGVhZGVyKGRhdGEsIG9mZnNldCwgcHRzLCBmcmFtZUluZGV4LCBmcmFtZUR1cmF0aW9uKTtcblxuICBpZiAoaGVhZGVyKSB7XG4gICAgdmFyIGZyYW1lTGVuZ3RoID0gaGVhZGVyLmZyYW1lTGVuZ3RoLFxuICAgICAgICBoZWFkZXJMZW5ndGggPSBoZWFkZXIuaGVhZGVyTGVuZ3RoLFxuICAgICAgICBzdGFtcCA9IGhlYWRlci5zdGFtcDtcbiAgICB2YXIgbGVuZ3RoID0gaGVhZGVyTGVuZ3RoICsgZnJhbWVMZW5ndGg7XG4gICAgdmFyIG1pc3NpbmcgPSBNYXRoLm1heCgwLCBvZmZzZXQgKyBsZW5ndGggLSBkYXRhLmxlbmd0aCk7IC8vIGxvZ2dlci5sb2coYEFBQyBmcmFtZSAke2ZyYW1lSW5kZXh9LCBwdHM6JHtzdGFtcH0gbGVuZ3RoQG9mZnNldC90b3RhbDogJHtmcmFtZUxlbmd0aH1AJHtvZmZzZXQraGVhZGVyTGVuZ3RofS8ke2RhdGEuYnl0ZUxlbmd0aH0gbWlzc2luZzogJHttaXNzaW5nfWApO1xuXG4gICAgdmFyIHVuaXQ7XG5cbiAgICBpZiAobWlzc2luZykge1xuICAgICAgdW5pdCA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCAtIGhlYWRlckxlbmd0aCk7XG4gICAgICB1bml0LnNldChkYXRhLnN1YmFycmF5KG9mZnNldCArIGhlYWRlckxlbmd0aCwgZGF0YS5sZW5ndGgpLCAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdW5pdCA9IGRhdGEuc3ViYXJyYXkob2Zmc2V0ICsgaGVhZGVyTGVuZ3RoLCBvZmZzZXQgKyBsZW5ndGgpO1xuICAgIH1cblxuICAgIHZhciBzYW1wbGUgPSB7XG4gICAgICB1bml0OiB1bml0LFxuICAgICAgcHRzOiBzdGFtcFxuICAgIH07XG5cbiAgICBpZiAoIW1pc3NpbmcpIHtcbiAgICAgIHRyYWNrLnNhbXBsZXMucHVzaChzYW1wbGUpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBzYW1wbGU6IHNhbXBsZSxcbiAgICAgIGxlbmd0aDogbGVuZ3RoLFxuICAgICAgbWlzc2luZzogbWlzc2luZ1xuICAgIH07XG4gIH1cbn1cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvZGVtdXgvYmFzZS1hdWRpby1kZW11eGVyLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9kZW11eC9iYXNlLWF1ZGlvLWRlbXV4ZXIudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGluaXRQVFNGbiwgZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJpbml0UFRTRm5cIiwgZnVuY3Rpb24oKSB7IHJldHVybiBpbml0UFRTRm47IH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9ob21lX3J1bm5lcl93b3JrX2hsc19qc19obHNfanNfc3JjX3BvbHlmaWxsc19udW1iZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc3JjL3BvbHlmaWxscy9udW1iZXIgKi8gXCIuL3NyYy9wb2x5ZmlsbHMvbnVtYmVyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9kZW11eF9pZDNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2RlbXV4L2lkMyAqLyBcIi4vc3JjL2RlbXV4L2lkMy50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZHVtbXlfZGVtdXhlZF90cmFja19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9kdW1teS1kZW11eGVkLXRyYWNrICovIFwiLi9zcmMvZGVtdXgvZHVtbXktZGVtdXhlZC10cmFjay50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfbXA0X3Rvb2xzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9tcDQtdG9vbHMgKi8gXCIuL3NyYy91dGlscy9tcDQtdG9vbHMudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX3R5cGVkX2FycmF5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy90eXBlZC1hcnJheSAqLyBcIi4vc3JjL3V0aWxzL3R5cGVkLWFycmF5LnRzXCIpO1xuXG5cblxuXG5cblxudmFyIEJhc2VBdWRpb0RlbXV4ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBCYXNlQXVkaW9EZW11eGVyKCkge1xuICAgIHRoaXMuX2F1ZGlvVHJhY2sgPSB2b2lkIDA7XG4gICAgdGhpcy5faWQzVHJhY2sgPSB2b2lkIDA7XG4gICAgdGhpcy5mcmFtZUluZGV4ID0gMDtcbiAgICB0aGlzLmNhY2hlZERhdGEgPSBudWxsO1xuICAgIHRoaXMuaW5pdFBUUyA9IG51bGw7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gQmFzZUF1ZGlvRGVtdXhlci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLnJlc2V0SW5pdFNlZ21lbnQgPSBmdW5jdGlvbiByZXNldEluaXRTZWdtZW50KGF1ZGlvQ29kZWMsIHZpZGVvQ29kZWMsIGR1cmF0aW9uKSB7XG4gICAgdGhpcy5faWQzVHJhY2sgPSB7XG4gICAgICB0eXBlOiAnaWQzJyxcbiAgICAgIGlkOiAzLFxuICAgICAgcGlkOiAtMSxcbiAgICAgIGlucHV0VGltZVNjYWxlOiA5MDAwMCxcbiAgICAgIHNlcXVlbmNlTnVtYmVyOiAwLFxuICAgICAgc2FtcGxlczogW10sXG4gICAgICBkcm9wcGVkOiAwXG4gICAgfTtcbiAgfTtcblxuICBfcHJvdG8ucmVzZXRUaW1lU3RhbXAgPSBmdW5jdGlvbiByZXNldFRpbWVTdGFtcCgpIHt9O1xuXG4gIF9wcm90by5yZXNldENvbnRpZ3VpdHkgPSBmdW5jdGlvbiByZXNldENvbnRpZ3VpdHkoKSB7fTtcblxuICBfcHJvdG8uY2FuUGFyc2UgPSBmdW5jdGlvbiBjYW5QYXJzZShkYXRhLCBvZmZzZXQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgX3Byb3RvLmFwcGVuZEZyYW1lID0gZnVuY3Rpb24gYXBwZW5kRnJhbWUodHJhY2ssIGRhdGEsIG9mZnNldCkge30gLy8gZmVlZCBpbmNvbWluZyBkYXRhIHRvIHRoZSBmcm9udCBvZiB0aGUgcGFyc2luZyBwaXBlbGluZVxuICA7XG5cbiAgX3Byb3RvLmRlbXV4ID0gZnVuY3Rpb24gZGVtdXgoZGF0YSwgdGltZU9mZnNldCkge1xuICAgIGlmICh0aGlzLmNhY2hlZERhdGEpIHtcbiAgICAgIGRhdGEgPSBPYmplY3QoX3V0aWxzX21wNF90b29sc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiYXBwZW5kVWludDhBcnJheVwiXSkodGhpcy5jYWNoZWREYXRhLCBkYXRhKTtcbiAgICAgIHRoaXMuY2FjaGVkRGF0YSA9IG51bGw7XG4gICAgfVxuXG4gICAgdmFyIGlkM0RhdGEgPSBfZGVtdXhfaWQzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJnZXRJRDNEYXRhXCJdKGRhdGEsIDApO1xuICAgIHZhciBvZmZzZXQgPSBpZDNEYXRhID8gaWQzRGF0YS5sZW5ndGggOiAwO1xuICAgIHZhciBsYXN0RGF0YUluZGV4O1xuICAgIHZhciBwdHM7XG4gICAgdmFyIHRyYWNrID0gdGhpcy5fYXVkaW9UcmFjaztcbiAgICB2YXIgaWQzVHJhY2sgPSB0aGlzLl9pZDNUcmFjaztcbiAgICB2YXIgdGltZXN0YW1wID0gaWQzRGF0YSA/IF9kZW11eF9pZDNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImdldFRpbWVTdGFtcFwiXShpZDNEYXRhKSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgbGVuZ3RoID0gZGF0YS5sZW5ndGg7XG5cbiAgICBpZiAodGhpcy5mcmFtZUluZGV4ID09PSAwIHx8IHRoaXMuaW5pdFBUUyA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5pbml0UFRTID0gaW5pdFBUU0ZuKHRpbWVzdGFtcCwgdGltZU9mZnNldCk7XG4gICAgfSAvLyBtb3JlIGV4cHJlc3NpdmUgdGhhbiBhbHRlcm5hdGl2ZTogaWQzRGF0YT8ubGVuZ3RoXG5cblxuICAgIGlmIChpZDNEYXRhICYmIGlkM0RhdGEubGVuZ3RoID4gMCkge1xuICAgICAgaWQzVHJhY2suc2FtcGxlcy5wdXNoKHtcbiAgICAgICAgcHRzOiB0aGlzLmluaXRQVFMsXG4gICAgICAgIGR0czogdGhpcy5pbml0UFRTLFxuICAgICAgICBkYXRhOiBpZDNEYXRhXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBwdHMgPSB0aGlzLmluaXRQVFM7XG5cbiAgICB3aGlsZSAob2Zmc2V0IDwgbGVuZ3RoKSB7XG4gICAgICBpZiAodGhpcy5jYW5QYXJzZShkYXRhLCBvZmZzZXQpKSB7XG4gICAgICAgIHZhciBmcmFtZSA9IHRoaXMuYXBwZW5kRnJhbWUodHJhY2ssIGRhdGEsIG9mZnNldCk7XG5cbiAgICAgICAgaWYgKGZyYW1lKSB7XG4gICAgICAgICAgdGhpcy5mcmFtZUluZGV4Kys7XG4gICAgICAgICAgcHRzID0gZnJhbWUuc2FtcGxlLnB0cztcbiAgICAgICAgICBvZmZzZXQgKz0gZnJhbWUubGVuZ3RoO1xuICAgICAgICAgIGxhc3REYXRhSW5kZXggPSBvZmZzZXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb2Zmc2V0ID0gbGVuZ3RoO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKF9kZW11eF9pZDNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImNhblBhcnNlXCJdKGRhdGEsIG9mZnNldCkpIHtcbiAgICAgICAgLy8gYWZ0ZXIgYSBJRDMuY2FuUGFyc2UsIGEgY2FsbCB0byBJRDMuZ2V0SUQzRGF0YSAqc2hvdWxkKiBhbHdheXMgcmV0dXJucyBzb21lIGRhdGFcbiAgICAgICAgaWQzRGF0YSA9IF9kZW11eF9pZDNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImdldElEM0RhdGFcIl0oZGF0YSwgb2Zmc2V0KTtcbiAgICAgICAgaWQzVHJhY2suc2FtcGxlcy5wdXNoKHtcbiAgICAgICAgICBwdHM6IHB0cyxcbiAgICAgICAgICBkdHM6IHB0cyxcbiAgICAgICAgICBkYXRhOiBpZDNEYXRhXG4gICAgICAgIH0pO1xuICAgICAgICBvZmZzZXQgKz0gaWQzRGF0YS5sZW5ndGg7XG4gICAgICAgIGxhc3REYXRhSW5kZXggPSBvZmZzZXQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvZmZzZXQrKztcbiAgICAgIH1cblxuICAgICAgaWYgKG9mZnNldCA9PT0gbGVuZ3RoICYmIGxhc3REYXRhSW5kZXggIT09IGxlbmd0aCkge1xuICAgICAgICB2YXIgcGFydGlhbERhdGEgPSBPYmplY3QoX3V0aWxzX3R5cGVkX2FycmF5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXCJzbGljZVVpbnQ4XCJdKShkYXRhLCBsYXN0RGF0YUluZGV4KTtcblxuICAgICAgICBpZiAodGhpcy5jYWNoZWREYXRhKSB7XG4gICAgICAgICAgdGhpcy5jYWNoZWREYXRhID0gT2JqZWN0KF91dGlsc19tcDRfdG9vbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcImFwcGVuZFVpbnQ4QXJyYXlcIl0pKHRoaXMuY2FjaGVkRGF0YSwgcGFydGlhbERhdGEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuY2FjaGVkRGF0YSA9IHBhcnRpYWxEYXRhO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGF1ZGlvVHJhY2s6IHRyYWNrLFxuICAgICAgYXZjVHJhY2s6IE9iamVjdChfZHVtbXlfZGVtdXhlZF90cmFja19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiZHVtbXlUcmFja1wiXSkoKSxcbiAgICAgIGlkM1RyYWNrOiBpZDNUcmFjayxcbiAgICAgIHRleHRUcmFjazogT2JqZWN0KF9kdW1teV9kZW11eGVkX3RyYWNrX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJkdW1teVRyYWNrXCJdKSgpXG4gICAgfTtcbiAgfTtcblxuICBfcHJvdG8uZGVtdXhTYW1wbGVBZXMgPSBmdW5jdGlvbiBkZW11eFNhbXBsZUFlcyhkYXRhLCBrZXlEYXRhLCB0aW1lT2Zmc2V0KSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIltcIiArIHRoaXMgKyBcIl0gVGhpcyBkZW11eGVyIGRvZXMgbm90IHN1cHBvcnQgU2FtcGxlLUFFUyBkZWNyeXB0aW9uXCIpKTtcbiAgfTtcblxuICBfcHJvdG8uZmx1c2ggPSBmdW5jdGlvbiBmbHVzaCh0aW1lT2Zmc2V0KSB7XG4gICAgLy8gUGFyc2UgY2FjaGUgaW4gY2FzZSBvZiByZW1haW5pbmcgZnJhbWVzLlxuICAgIHZhciBjYWNoZWREYXRhID0gdGhpcy5jYWNoZWREYXRhO1xuXG4gICAgaWYgKGNhY2hlZERhdGEpIHtcbiAgICAgIHRoaXMuY2FjaGVkRGF0YSA9IG51bGw7XG4gICAgICB0aGlzLmRlbXV4KGNhY2hlZERhdGEsIDApO1xuICAgIH1cblxuICAgIHRoaXMuZnJhbWVJbmRleCA9IDA7XG4gICAgcmV0dXJuIHtcbiAgICAgIGF1ZGlvVHJhY2s6IHRoaXMuX2F1ZGlvVHJhY2ssXG4gICAgICBhdmNUcmFjazogT2JqZWN0KF9kdW1teV9kZW11eGVkX3RyYWNrX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJkdW1teVRyYWNrXCJdKSgpLFxuICAgICAgaWQzVHJhY2s6IHRoaXMuX2lkM1RyYWNrLFxuICAgICAgdGV4dFRyYWNrOiBPYmplY3QoX2R1bW15X2RlbXV4ZWRfdHJhY2tfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImR1bW15VHJhY2tcIl0pKClcbiAgICB9O1xuICB9O1xuXG4gIF9wcm90by5kZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveSgpIHt9O1xuXG4gIHJldHVybiBCYXNlQXVkaW9EZW11eGVyO1xufSgpO1xuLyoqXG4gKiBJbml0aWFsaXplIFBUU1xuICogPHA+XG4gKiAgICB1c2UgdGltZXN0YW1wIHVubGVzcyBpdCBpcyB1bmRlZmluZWQsIE5hTiBvciBJbmZpbml0eVxuICogPC9wPlxuICovXG5cblxudmFyIGluaXRQVFNGbiA9IGZ1bmN0aW9uIGluaXRQVFNGbih0aW1lc3RhbXAsIHRpbWVPZmZzZXQpIHtcbiAgcmV0dXJuIE9iamVjdChfaG9tZV9ydW5uZXJfd29ya19obHNfanNfaGxzX2pzX3NyY19wb2x5ZmlsbHNfbnVtYmVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJpc0Zpbml0ZU51bWJlclwiXSkodGltZXN0YW1wKSA/IHRpbWVzdGFtcCAqIDkwIDogdGltZU9mZnNldCAqIDkwMDAwO1xufTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoQmFzZUF1ZGlvRGVtdXhlcik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2RlbXV4L2NodW5rLWNhY2hlLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2RlbXV4L2NodW5rLWNhY2hlLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZGVmYXVsdFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIENodW5rQ2FjaGU7IH0pO1xudmFyIENodW5rQ2FjaGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBDaHVua0NhY2hlKCkge1xuICAgIHRoaXMuY2h1bmtzID0gW107XG4gICAgdGhpcy5kYXRhTGVuZ3RoID0gMDtcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBDaHVua0NhY2hlLnByb3RvdHlwZTtcblxuICBfcHJvdG8ucHVzaCA9IGZ1bmN0aW9uIHB1c2goY2h1bmspIHtcbiAgICB0aGlzLmNodW5rcy5wdXNoKGNodW5rKTtcbiAgICB0aGlzLmRhdGFMZW5ndGggKz0gY2h1bmsubGVuZ3RoO1xuICB9O1xuXG4gIF9wcm90by5mbHVzaCA9IGZ1bmN0aW9uIGZsdXNoKCkge1xuICAgIHZhciBjaHVua3MgPSB0aGlzLmNodW5rcyxcbiAgICAgICAgZGF0YUxlbmd0aCA9IHRoaXMuZGF0YUxlbmd0aDtcbiAgICB2YXIgcmVzdWx0O1xuXG4gICAgaWYgKCFjaHVua3MubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoMCk7XG4gICAgfSBlbHNlIGlmIChjaHVua3MubGVuZ3RoID09PSAxKSB7XG4gICAgICByZXN1bHQgPSBjaHVua3NbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IGNvbmNhdFVpbnQ4QXJyYXlzKGNodW5rcywgZGF0YUxlbmd0aCk7XG4gICAgfVxuXG4gICAgdGhpcy5yZXNldCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgX3Byb3RvLnJlc2V0ID0gZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgdGhpcy5jaHVua3MubGVuZ3RoID0gMDtcbiAgICB0aGlzLmRhdGFMZW5ndGggPSAwO1xuICB9O1xuXG4gIHJldHVybiBDaHVua0NhY2hlO1xufSgpO1xuXG5cblxuZnVuY3Rpb24gY29uY2F0VWludDhBcnJheXMoY2h1bmtzLCBkYXRhTGVuZ3RoKSB7XG4gIHZhciByZXN1bHQgPSBuZXcgVWludDhBcnJheShkYXRhTGVuZ3RoKTtcbiAgdmFyIG9mZnNldCA9IDA7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaHVua3MubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY2h1bmsgPSBjaHVua3NbaV07XG4gICAgcmVzdWx0LnNldChjaHVuaywgb2Zmc2V0KTtcbiAgICBvZmZzZXQgKz0gY2h1bmsubGVuZ3RoO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvZGVtdXgvZHVtbXktZGVtdXhlZC10cmFjay50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2RlbXV4L2R1bW15LWRlbXV4ZWQtdHJhY2sudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkdW1teVRyYWNrICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImR1bW15VHJhY2tcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBkdW1teVRyYWNrOyB9KTtcbmZ1bmN0aW9uIGR1bW15VHJhY2soKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJycsXG4gICAgaWQ6IC0xLFxuICAgIHBpZDogLTEsXG4gICAgaW5wdXRUaW1lU2NhbGU6IDkwMDAwLFxuICAgIHNlcXVlbmNlTnVtYmVyOiAtMSxcbiAgICBzYW1wbGVzOiBbXSxcbiAgICBkcm9wcGVkOiAwXG4gIH07XG59XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2RlbXV4L2V4cC1nb2xvbWIudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9kZW11eC9leHAtZ29sb21iLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9sb2dnZXIgKi8gXCIuL3NyYy91dGlscy9sb2dnZXIudHNcIik7XG4vKipcbiAqIFBhcnNlciBmb3IgZXhwb25lbnRpYWwgR29sb21iIGNvZGVzLCBhIHZhcmlhYmxlLWJpdHdpZHRoIG51bWJlciBlbmNvZGluZyBzY2hlbWUgdXNlZCBieSBoMjY0LlxuICovXG5cblxudmFyIEV4cEdvbG9tYiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEV4cEdvbG9tYihkYXRhKSB7XG4gICAgdGhpcy5kYXRhID0gdm9pZCAwO1xuICAgIHRoaXMuYnl0ZXNBdmFpbGFibGUgPSB2b2lkIDA7XG4gICAgdGhpcy53b3JkID0gdm9pZCAwO1xuICAgIHRoaXMuYml0c0F2YWlsYWJsZSA9IHZvaWQgMDtcbiAgICB0aGlzLmRhdGEgPSBkYXRhOyAvLyB0aGUgbnVtYmVyIG9mIGJ5dGVzIGxlZnQgdG8gZXhhbWluZSBpbiB0aGlzLmRhdGFcblxuICAgIHRoaXMuYnl0ZXNBdmFpbGFibGUgPSBkYXRhLmJ5dGVMZW5ndGg7IC8vIHRoZSBjdXJyZW50IHdvcmQgYmVpbmcgZXhhbWluZWRcblxuICAgIHRoaXMud29yZCA9IDA7IC8vIDp1aW50XG4gICAgLy8gdGhlIG51bWJlciBvZiBiaXRzIGxlZnQgdG8gZXhhbWluZSBpbiB0aGUgY3VycmVudCB3b3JkXG5cbiAgICB0aGlzLmJpdHNBdmFpbGFibGUgPSAwOyAvLyA6dWludFxuICB9IC8vICgpOnZvaWRcblxuXG4gIHZhciBfcHJvdG8gPSBFeHBHb2xvbWIucHJvdG90eXBlO1xuXG4gIF9wcm90by5sb2FkV29yZCA9IGZ1bmN0aW9uIGxvYWRXb3JkKCkge1xuICAgIHZhciBkYXRhID0gdGhpcy5kYXRhO1xuICAgIHZhciBieXRlc0F2YWlsYWJsZSA9IHRoaXMuYnl0ZXNBdmFpbGFibGU7XG4gICAgdmFyIHBvc2l0aW9uID0gZGF0YS5ieXRlTGVuZ3RoIC0gYnl0ZXNBdmFpbGFibGU7XG4gICAgdmFyIHdvcmtpbmdCeXRlcyA9IG5ldyBVaW50OEFycmF5KDQpO1xuICAgIHZhciBhdmFpbGFibGVCeXRlcyA9IE1hdGgubWluKDQsIGJ5dGVzQXZhaWxhYmxlKTtcblxuICAgIGlmIChhdmFpbGFibGVCeXRlcyA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdubyBieXRlcyBhdmFpbGFibGUnKTtcbiAgICB9XG5cbiAgICB3b3JraW5nQnl0ZXMuc2V0KGRhdGEuc3ViYXJyYXkocG9zaXRpb24sIHBvc2l0aW9uICsgYXZhaWxhYmxlQnl0ZXMpKTtcbiAgICB0aGlzLndvcmQgPSBuZXcgRGF0YVZpZXcod29ya2luZ0J5dGVzLmJ1ZmZlcikuZ2V0VWludDMyKDApOyAvLyB0cmFjayB0aGUgYW1vdW50IG9mIHRoaXMuZGF0YSB0aGF0IGhhcyBiZWVuIHByb2Nlc3NlZFxuXG4gICAgdGhpcy5iaXRzQXZhaWxhYmxlID0gYXZhaWxhYmxlQnl0ZXMgKiA4O1xuICAgIHRoaXMuYnl0ZXNBdmFpbGFibGUgLT0gYXZhaWxhYmxlQnl0ZXM7XG4gIH0gLy8gKGNvdW50OmludCk6dm9pZFxuICA7XG5cbiAgX3Byb3RvLnNraXBCaXRzID0gZnVuY3Rpb24gc2tpcEJpdHMoY291bnQpIHtcbiAgICB2YXIgc2tpcEJ5dGVzOyAvLyA6aW50XG5cbiAgICBpZiAodGhpcy5iaXRzQXZhaWxhYmxlID4gY291bnQpIHtcbiAgICAgIHRoaXMud29yZCA8PD0gY291bnQ7XG4gICAgICB0aGlzLmJpdHNBdmFpbGFibGUgLT0gY291bnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvdW50IC09IHRoaXMuYml0c0F2YWlsYWJsZTtcbiAgICAgIHNraXBCeXRlcyA9IGNvdW50ID4+IDM7XG4gICAgICBjb3VudCAtPSBza2lwQnl0ZXMgPj4gMztcbiAgICAgIHRoaXMuYnl0ZXNBdmFpbGFibGUgLT0gc2tpcEJ5dGVzO1xuICAgICAgdGhpcy5sb2FkV29yZCgpO1xuICAgICAgdGhpcy53b3JkIDw8PSBjb3VudDtcbiAgICAgIHRoaXMuYml0c0F2YWlsYWJsZSAtPSBjb3VudDtcbiAgICB9XG4gIH0gLy8gKHNpemU6aW50KTp1aW50XG4gIDtcblxuICBfcHJvdG8ucmVhZEJpdHMgPSBmdW5jdGlvbiByZWFkQml0cyhzaXplKSB7XG4gICAgdmFyIGJpdHMgPSBNYXRoLm1pbih0aGlzLmJpdHNBdmFpbGFibGUsIHNpemUpOyAvLyA6dWludFxuXG4gICAgdmFyIHZhbHUgPSB0aGlzLndvcmQgPj4+IDMyIC0gYml0czsgLy8gOnVpbnRcblxuICAgIGlmIChzaXplID4gMzIpIHtcbiAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImxvZ2dlclwiXS5lcnJvcignQ2Fubm90IHJlYWQgbW9yZSB0aGFuIDMyIGJpdHMgYXQgYSB0aW1lJyk7XG4gICAgfVxuXG4gICAgdGhpcy5iaXRzQXZhaWxhYmxlIC09IGJpdHM7XG5cbiAgICBpZiAodGhpcy5iaXRzQXZhaWxhYmxlID4gMCkge1xuICAgICAgdGhpcy53b3JkIDw8PSBiaXRzO1xuICAgIH0gZWxzZSBpZiAodGhpcy5ieXRlc0F2YWlsYWJsZSA+IDApIHtcbiAgICAgIHRoaXMubG9hZFdvcmQoKTtcbiAgICB9XG5cbiAgICBiaXRzID0gc2l6ZSAtIGJpdHM7XG5cbiAgICBpZiAoYml0cyA+IDAgJiYgdGhpcy5iaXRzQXZhaWxhYmxlKSB7XG4gICAgICByZXR1cm4gdmFsdSA8PCBiaXRzIHwgdGhpcy5yZWFkQml0cyhiaXRzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHZhbHU7XG4gICAgfVxuICB9IC8vICgpOnVpbnRcbiAgO1xuXG4gIF9wcm90by5za2lwTFogPSBmdW5jdGlvbiBza2lwTFooKSB7XG4gICAgdmFyIGxlYWRpbmdaZXJvQ291bnQ7IC8vIDp1aW50XG5cbiAgICBmb3IgKGxlYWRpbmdaZXJvQ291bnQgPSAwOyBsZWFkaW5nWmVyb0NvdW50IDwgdGhpcy5iaXRzQXZhaWxhYmxlOyArK2xlYWRpbmdaZXJvQ291bnQpIHtcbiAgICAgIGlmICgodGhpcy53b3JkICYgMHg4MDAwMDAwMCA+Pj4gbGVhZGluZ1plcm9Db3VudCkgIT09IDApIHtcbiAgICAgICAgLy8gdGhlIGZpcnN0IGJpdCBvZiB3b3JraW5nIHdvcmQgaXMgMVxuICAgICAgICB0aGlzLndvcmQgPDw9IGxlYWRpbmdaZXJvQ291bnQ7XG4gICAgICAgIHRoaXMuYml0c0F2YWlsYWJsZSAtPSBsZWFkaW5nWmVyb0NvdW50O1xuICAgICAgICByZXR1cm4gbGVhZGluZ1plcm9Db3VudDtcbiAgICAgIH1cbiAgICB9IC8vIHdlIGV4aGF1c3RlZCB3b3JkIGFuZCBzdGlsbCBoYXZlIG5vdCBmb3VuZCBhIDFcblxuXG4gICAgdGhpcy5sb2FkV29yZCgpO1xuICAgIHJldHVybiBsZWFkaW5nWmVyb0NvdW50ICsgdGhpcy5za2lwTFooKTtcbiAgfSAvLyAoKTp2b2lkXG4gIDtcblxuICBfcHJvdG8uc2tpcFVFRyA9IGZ1bmN0aW9uIHNraXBVRUcoKSB7XG4gICAgdGhpcy5za2lwQml0cygxICsgdGhpcy5za2lwTFooKSk7XG4gIH0gLy8gKCk6dm9pZFxuICA7XG5cbiAgX3Byb3RvLnNraXBFRyA9IGZ1bmN0aW9uIHNraXBFRygpIHtcbiAgICB0aGlzLnNraXBCaXRzKDEgKyB0aGlzLnNraXBMWigpKTtcbiAgfSAvLyAoKTp1aW50XG4gIDtcblxuICBfcHJvdG8ucmVhZFVFRyA9IGZ1bmN0aW9uIHJlYWRVRUcoKSB7XG4gICAgdmFyIGNseiA9IHRoaXMuc2tpcExaKCk7IC8vIDp1aW50XG5cbiAgICByZXR1cm4gdGhpcy5yZWFkQml0cyhjbHogKyAxKSAtIDE7XG4gIH0gLy8gKCk6aW50XG4gIDtcblxuICBfcHJvdG8ucmVhZEVHID0gZnVuY3Rpb24gcmVhZEVHKCkge1xuICAgIHZhciB2YWx1ID0gdGhpcy5yZWFkVUVHKCk7IC8vIDppbnRcblxuICAgIGlmICgweDAxICYgdmFsdSkge1xuICAgICAgLy8gdGhlIG51bWJlciBpcyBvZGQgaWYgdGhlIGxvdyBvcmRlciBiaXQgaXMgc2V0XG4gICAgICByZXR1cm4gMSArIHZhbHUgPj4+IDE7IC8vIGFkZCAxIHRvIG1ha2UgaXQgZXZlbiwgYW5kIGRpdmlkZSBieSAyXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAtMSAqICh2YWx1ID4+PiAxKTsgLy8gZGl2aWRlIGJ5IHR3byB0aGVuIG1ha2UgaXQgbmVnYXRpdmVcbiAgICB9XG4gIH0gLy8gU29tZSBjb252ZW5pZW5jZSBmdW5jdGlvbnNcbiAgLy8gOkJvb2xlYW5cbiAgO1xuXG4gIF9wcm90by5yZWFkQm9vbGVhbiA9IGZ1bmN0aW9uIHJlYWRCb29sZWFuKCkge1xuICAgIHJldHVybiB0aGlzLnJlYWRCaXRzKDEpID09PSAxO1xuICB9IC8vICgpOmludFxuICA7XG5cbiAgX3Byb3RvLnJlYWRVQnl0ZSA9IGZ1bmN0aW9uIHJlYWRVQnl0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5yZWFkQml0cyg4KTtcbiAgfSAvLyAoKTppbnRcbiAgO1xuXG4gIF9wcm90by5yZWFkVVNob3J0ID0gZnVuY3Rpb24gcmVhZFVTaG9ydCgpIHtcbiAgICByZXR1cm4gdGhpcy5yZWFkQml0cygxNik7XG4gIH0gLy8gKCk6aW50XG4gIDtcblxuICBfcHJvdG8ucmVhZFVJbnQgPSBmdW5jdGlvbiByZWFkVUludCgpIHtcbiAgICByZXR1cm4gdGhpcy5yZWFkQml0cygzMik7XG4gIH1cbiAgLyoqXG4gICAqIEFkdmFuY2UgdGhlIEV4cEdvbG9tYiBkZWNvZGVyIHBhc3QgYSBzY2FsaW5nIGxpc3QuIFRoZSBzY2FsaW5nXG4gICAqIGxpc3QgaXMgb3B0aW9uYWxseSB0cmFuc21pdHRlZCBhcyBwYXJ0IG9mIGEgc2VxdWVuY2UgcGFyYW1ldGVyXG4gICAqIHNldCBhbmQgaXMgbm90IHJlbGV2YW50IHRvIHRyYW5zbXV4aW5nLlxuICAgKiBAcGFyYW0gY291bnQgdGhlIG51bWJlciBvZiBlbnRyaWVzIGluIHRoaXMgc2NhbGluZyBsaXN0XG4gICAqIEBzZWUgUmVjb21tZW5kYXRpb24gSVRVLVQgSC4yNjQsIFNlY3Rpb24gNy4zLjIuMS4xLjFcbiAgICovXG4gIDtcblxuICBfcHJvdG8uc2tpcFNjYWxpbmdMaXN0ID0gZnVuY3Rpb24gc2tpcFNjYWxpbmdMaXN0KGNvdW50KSB7XG4gICAgdmFyIGxhc3RTY2FsZSA9IDg7XG4gICAgdmFyIG5leHRTY2FsZSA9IDg7XG4gICAgdmFyIGRlbHRhU2NhbGU7XG5cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNvdW50OyBqKyspIHtcbiAgICAgIGlmIChuZXh0U2NhbGUgIT09IDApIHtcbiAgICAgICAgZGVsdGFTY2FsZSA9IHRoaXMucmVhZEVHKCk7XG4gICAgICAgIG5leHRTY2FsZSA9IChsYXN0U2NhbGUgKyBkZWx0YVNjYWxlICsgMjU2KSAlIDI1NjtcbiAgICAgIH1cblxuICAgICAgbGFzdFNjYWxlID0gbmV4dFNjYWxlID09PSAwID8gbGFzdFNjYWxlIDogbmV4dFNjYWxlO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmVhZCBhIHNlcXVlbmNlIHBhcmFtZXRlciBzZXQgYW5kIHJldHVybiBzb21lIGludGVyZXN0aW5nIHZpZGVvXG4gICAqIHByb3BlcnRpZXMuIEEgc2VxdWVuY2UgcGFyYW1ldGVyIHNldCBpcyB0aGUgSDI2NCBtZXRhZGF0YSB0aGF0XG4gICAqIGRlc2NyaWJlcyB0aGUgcHJvcGVydGllcyBvZiB1cGNvbWluZyB2aWRlbyBmcmFtZXMuXG4gICAqIEBwYXJhbSBkYXRhIHtVaW50OEFycmF5fSB0aGUgYnl0ZXMgb2YgYSBzZXF1ZW5jZSBwYXJhbWV0ZXIgc2V0XG4gICAqIEByZXR1cm4ge29iamVjdH0gYW4gb2JqZWN0IHdpdGggY29uZmlndXJhdGlvbiBwYXJzZWQgZnJvbSB0aGVcbiAgICogc2VxdWVuY2UgcGFyYW1ldGVyIHNldCwgaW5jbHVkaW5nIHRoZSBkaW1lbnNpb25zIG9mIHRoZVxuICAgKiBhc3NvY2lhdGVkIHZpZGVvIGZyYW1lcy5cbiAgICovXG4gIDtcblxuICBfcHJvdG8ucmVhZFNQUyA9IGZ1bmN0aW9uIHJlYWRTUFMoKSB7XG4gICAgdmFyIGZyYW1lQ3JvcExlZnRPZmZzZXQgPSAwO1xuICAgIHZhciBmcmFtZUNyb3BSaWdodE9mZnNldCA9IDA7XG4gICAgdmFyIGZyYW1lQ3JvcFRvcE9mZnNldCA9IDA7XG4gICAgdmFyIGZyYW1lQ3JvcEJvdHRvbU9mZnNldCA9IDA7XG4gICAgdmFyIG51bVJlZkZyYW1lc0luUGljT3JkZXJDbnRDeWNsZTtcbiAgICB2YXIgc2NhbGluZ0xpc3RDb3VudDtcbiAgICB2YXIgaTtcbiAgICB2YXIgcmVhZFVCeXRlID0gdGhpcy5yZWFkVUJ5dGUuYmluZCh0aGlzKTtcbiAgICB2YXIgcmVhZEJpdHMgPSB0aGlzLnJlYWRCaXRzLmJpbmQodGhpcyk7XG4gICAgdmFyIHJlYWRVRUcgPSB0aGlzLnJlYWRVRUcuYmluZCh0aGlzKTtcbiAgICB2YXIgcmVhZEJvb2xlYW4gPSB0aGlzLnJlYWRCb29sZWFuLmJpbmQodGhpcyk7XG4gICAgdmFyIHNraXBCaXRzID0gdGhpcy5za2lwQml0cy5iaW5kKHRoaXMpO1xuICAgIHZhciBza2lwRUcgPSB0aGlzLnNraXBFRy5iaW5kKHRoaXMpO1xuICAgIHZhciBza2lwVUVHID0gdGhpcy5za2lwVUVHLmJpbmQodGhpcyk7XG4gICAgdmFyIHNraXBTY2FsaW5nTGlzdCA9IHRoaXMuc2tpcFNjYWxpbmdMaXN0LmJpbmQodGhpcyk7XG4gICAgcmVhZFVCeXRlKCk7XG4gICAgdmFyIHByb2ZpbGVJZGMgPSByZWFkVUJ5dGUoKTsgLy8gcHJvZmlsZV9pZGNcblxuICAgIHJlYWRCaXRzKDUpOyAvLyBwcm9maWxlQ29tcGF0IGNvbnN0cmFpbnRfc2V0WzAtNF1fZmxhZywgdSg1KVxuXG4gICAgc2tpcEJpdHMoMyk7IC8vIHJlc2VydmVkX3plcm9fM2JpdHMgdSgzKSxcblxuICAgIHJlYWRVQnl0ZSgpOyAvLyBsZXZlbF9pZGMgdSg4KVxuXG4gICAgc2tpcFVFRygpOyAvLyBzZXFfcGFyYW1ldGVyX3NldF9pZFxuICAgIC8vIHNvbWUgcHJvZmlsZXMgaGF2ZSBtb3JlIG9wdGlvbmFsIGRhdGEgd2UgZG9uJ3QgbmVlZFxuXG4gICAgaWYgKHByb2ZpbGVJZGMgPT09IDEwMCB8fCBwcm9maWxlSWRjID09PSAxMTAgfHwgcHJvZmlsZUlkYyA9PT0gMTIyIHx8IHByb2ZpbGVJZGMgPT09IDI0NCB8fCBwcm9maWxlSWRjID09PSA0NCB8fCBwcm9maWxlSWRjID09PSA4MyB8fCBwcm9maWxlSWRjID09PSA4NiB8fCBwcm9maWxlSWRjID09PSAxMTggfHwgcHJvZmlsZUlkYyA9PT0gMTI4KSB7XG4gICAgICB2YXIgY2hyb21hRm9ybWF0SWRjID0gcmVhZFVFRygpO1xuXG4gICAgICBpZiAoY2hyb21hRm9ybWF0SWRjID09PSAzKSB7XG4gICAgICAgIHNraXBCaXRzKDEpO1xuICAgICAgfSAvLyBzZXBhcmF0ZV9jb2xvdXJfcGxhbmVfZmxhZ1xuXG5cbiAgICAgIHNraXBVRUcoKTsgLy8gYml0X2RlcHRoX2x1bWFfbWludXM4XG5cbiAgICAgIHNraXBVRUcoKTsgLy8gYml0X2RlcHRoX2Nocm9tYV9taW51czhcblxuICAgICAgc2tpcEJpdHMoMSk7IC8vIHFwcHJpbWVfeV96ZXJvX3RyYW5zZm9ybV9ieXBhc3NfZmxhZ1xuXG4gICAgICBpZiAocmVhZEJvb2xlYW4oKSkge1xuICAgICAgICAvLyBzZXFfc2NhbGluZ19tYXRyaXhfcHJlc2VudF9mbGFnXG4gICAgICAgIHNjYWxpbmdMaXN0Q291bnQgPSBjaHJvbWFGb3JtYXRJZGMgIT09IDMgPyA4IDogMTI7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHNjYWxpbmdMaXN0Q291bnQ7IGkrKykge1xuICAgICAgICAgIGlmIChyZWFkQm9vbGVhbigpKSB7XG4gICAgICAgICAgICAvLyBzZXFfc2NhbGluZ19saXN0X3ByZXNlbnRfZmxhZ1sgaSBdXG4gICAgICAgICAgICBpZiAoaSA8IDYpIHtcbiAgICAgICAgICAgICAgc2tpcFNjYWxpbmdMaXN0KDE2KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHNraXBTY2FsaW5nTGlzdCg2NCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2tpcFVFRygpOyAvLyBsb2cyX21heF9mcmFtZV9udW1fbWludXM0XG5cbiAgICB2YXIgcGljT3JkZXJDbnRUeXBlID0gcmVhZFVFRygpO1xuXG4gICAgaWYgKHBpY09yZGVyQ250VHlwZSA9PT0gMCkge1xuICAgICAgcmVhZFVFRygpOyAvLyBsb2cyX21heF9waWNfb3JkZXJfY250X2xzYl9taW51czRcbiAgICB9IGVsc2UgaWYgKHBpY09yZGVyQ250VHlwZSA9PT0gMSkge1xuICAgICAgc2tpcEJpdHMoMSk7IC8vIGRlbHRhX3BpY19vcmRlcl9hbHdheXNfemVyb19mbGFnXG5cbiAgICAgIHNraXBFRygpOyAvLyBvZmZzZXRfZm9yX25vbl9yZWZfcGljXG5cbiAgICAgIHNraXBFRygpOyAvLyBvZmZzZXRfZm9yX3RvcF90b19ib3R0b21fZmllbGRcblxuICAgICAgbnVtUmVmRnJhbWVzSW5QaWNPcmRlckNudEN5Y2xlID0gcmVhZFVFRygpO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbnVtUmVmRnJhbWVzSW5QaWNPcmRlckNudEN5Y2xlOyBpKyspIHtcbiAgICAgICAgc2tpcEVHKCk7XG4gICAgICB9IC8vIG9mZnNldF9mb3JfcmVmX2ZyYW1lWyBpIF1cblxuICAgIH1cblxuICAgIHNraXBVRUcoKTsgLy8gbWF4X251bV9yZWZfZnJhbWVzXG5cbiAgICBza2lwQml0cygxKTsgLy8gZ2Fwc19pbl9mcmFtZV9udW1fdmFsdWVfYWxsb3dlZF9mbGFnXG5cbiAgICB2YXIgcGljV2lkdGhJbk1ic01pbnVzMSA9IHJlYWRVRUcoKTtcbiAgICB2YXIgcGljSGVpZ2h0SW5NYXBVbml0c01pbnVzMSA9IHJlYWRVRUcoKTtcbiAgICB2YXIgZnJhbWVNYnNPbmx5RmxhZyA9IHJlYWRCaXRzKDEpO1xuXG4gICAgaWYgKGZyYW1lTWJzT25seUZsYWcgPT09IDApIHtcbiAgICAgIHNraXBCaXRzKDEpO1xuICAgIH0gLy8gbWJfYWRhcHRpdmVfZnJhbWVfZmllbGRfZmxhZ1xuXG5cbiAgICBza2lwQml0cygxKTsgLy8gZGlyZWN0Xzh4OF9pbmZlcmVuY2VfZmxhZ1xuXG4gICAgaWYgKHJlYWRCb29sZWFuKCkpIHtcbiAgICAgIC8vIGZyYW1lX2Nyb3BwaW5nX2ZsYWdcbiAgICAgIGZyYW1lQ3JvcExlZnRPZmZzZXQgPSByZWFkVUVHKCk7XG4gICAgICBmcmFtZUNyb3BSaWdodE9mZnNldCA9IHJlYWRVRUcoKTtcbiAgICAgIGZyYW1lQ3JvcFRvcE9mZnNldCA9IHJlYWRVRUcoKTtcbiAgICAgIGZyYW1lQ3JvcEJvdHRvbU9mZnNldCA9IHJlYWRVRUcoKTtcbiAgICB9XG5cbiAgICB2YXIgcGl4ZWxSYXRpbyA9IFsxLCAxXTtcblxuICAgIGlmIChyZWFkQm9vbGVhbigpKSB7XG4gICAgICAvLyB2dWlfcGFyYW1ldGVyc19wcmVzZW50X2ZsYWdcbiAgICAgIGlmIChyZWFkQm9vbGVhbigpKSB7XG4gICAgICAgIC8vIGFzcGVjdF9yYXRpb19pbmZvX3ByZXNlbnRfZmxhZ1xuICAgICAgICB2YXIgYXNwZWN0UmF0aW9JZGMgPSByZWFkVUJ5dGUoKTtcblxuICAgICAgICBzd2l0Y2ggKGFzcGVjdFJhdGlvSWRjKSB7XG4gICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgcGl4ZWxSYXRpbyA9IFsxLCAxXTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgcGl4ZWxSYXRpbyA9IFsxMiwgMTFdO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBwaXhlbFJhdGlvID0gWzEwLCAxMV07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIHBpeGVsUmF0aW8gPSBbMTYsIDExXTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgcGl4ZWxSYXRpbyA9IFs0MCwgMzNdO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICBwaXhlbFJhdGlvID0gWzI0LCAxMV07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgIHBpeGVsUmF0aW8gPSBbMjAsIDExXTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgcGl4ZWxSYXRpbyA9IFszMiwgMTFdO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICBwaXhlbFJhdGlvID0gWzgwLCAzM107XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICBwaXhlbFJhdGlvID0gWzE4LCAxMV07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICBwaXhlbFJhdGlvID0gWzE1LCAxMV07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICBwaXhlbFJhdGlvID0gWzY0LCAzM107XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICBwaXhlbFJhdGlvID0gWzE2MCwgOTldO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgICAgcGl4ZWxSYXRpbyA9IFs0LCAzXTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICAgIHBpeGVsUmF0aW8gPSBbMywgMl07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgICBwaXhlbFJhdGlvID0gWzIsIDFdO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDI1NTpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgcGl4ZWxSYXRpbyA9IFtyZWFkVUJ5dGUoKSA8PCA4IHwgcmVhZFVCeXRlKCksIHJlYWRVQnl0ZSgpIDw8IDggfCByZWFkVUJ5dGUoKV07XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHdpZHRoOiBNYXRoLmNlaWwoKHBpY1dpZHRoSW5NYnNNaW51czEgKyAxKSAqIDE2IC0gZnJhbWVDcm9wTGVmdE9mZnNldCAqIDIgLSBmcmFtZUNyb3BSaWdodE9mZnNldCAqIDIpLFxuICAgICAgaGVpZ2h0OiAoMiAtIGZyYW1lTWJzT25seUZsYWcpICogKHBpY0hlaWdodEluTWFwVW5pdHNNaW51czEgKyAxKSAqIDE2IC0gKGZyYW1lTWJzT25seUZsYWcgPyAyIDogNCkgKiAoZnJhbWVDcm9wVG9wT2Zmc2V0ICsgZnJhbWVDcm9wQm90dG9tT2Zmc2V0KSxcbiAgICAgIHBpeGVsUmF0aW86IHBpeGVsUmF0aW9cbiAgICB9O1xuICB9O1xuXG4gIF9wcm90by5yZWFkU2xpY2VUeXBlID0gZnVuY3Rpb24gcmVhZFNsaWNlVHlwZSgpIHtcbiAgICAvLyBza2lwIE5BTHUgdHlwZVxuICAgIHRoaXMucmVhZFVCeXRlKCk7IC8vIGRpc2NhcmQgZmlyc3RfbWJfaW5fc2xpY2VcblxuICAgIHRoaXMucmVhZFVFRygpOyAvLyByZXR1cm4gc2xpY2VfdHlwZVxuXG4gICAgcmV0dXJuIHRoaXMucmVhZFVFRygpO1xuICB9O1xuXG4gIHJldHVybiBFeHBHb2xvbWI7XG59KCk7XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoRXhwR29sb21iKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvZGVtdXgvaWQzLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9kZW11eC9pZDMudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGlzSGVhZGVyLCBpc0Zvb3RlciwgZ2V0SUQzRGF0YSwgY2FuUGFyc2UsIGdldFRpbWVTdGFtcCwgaXNUaW1lU3RhbXBGcmFtZSwgZ2V0SUQzRnJhbWVzLCBkZWNvZGVGcmFtZSwgdXRmOEFycmF5VG9TdHIsIHRlc3RhYmxlcyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJpc0hlYWRlclwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGlzSGVhZGVyOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJpc0Zvb3RlclwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGlzRm9vdGVyOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJnZXRJRDNEYXRhXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZ2V0SUQzRGF0YTsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiY2FuUGFyc2VcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBjYW5QYXJzZTsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZ2V0VGltZVN0YW1wXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZ2V0VGltZVN0YW1wOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJpc1RpbWVTdGFtcEZyYW1lXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gaXNUaW1lU3RhbXBGcmFtZTsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZ2V0SUQzRnJhbWVzXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZ2V0SUQzRnJhbWVzOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJkZWNvZGVGcmFtZVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGRlY29kZUZyYW1lOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJ1dGY4QXJyYXlUb1N0clwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHV0ZjhBcnJheVRvU3RyOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJ0ZXN0YWJsZXNcIiwgZnVuY3Rpb24oKSB7IHJldHVybiB0ZXN0YWJsZXM7IH0pO1xuLy8gYnJlYWtpbmcgdXAgdGhvc2UgdHdvIHR5cGVzIGluIG9yZGVyIHRvIGNsYXJpZnkgd2hhdCBpcyBoYXBwZW5pbmcgaW4gdGhlIGRlY29kaW5nIHBhdGguXG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGFuIElEMyBoZWFkZXIgY2FuIGJlIGZvdW5kIGF0IG9mZnNldCBpbiBkYXRhXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGRhdGEgLSBUaGUgZGF0YSB0byBzZWFyY2ggaW5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgLSBUaGUgb2Zmc2V0IGF0IHdoaWNoIHRvIHN0YXJ0IHNlYXJjaGluZ1xuICogQHJldHVybiB7Ym9vbGVhbn0gLSBUcnVlIGlmIGFuIElEMyBoZWFkZXIgaXMgZm91bmRcbiAqL1xudmFyIGlzSGVhZGVyID0gZnVuY3Rpb24gaXNIZWFkZXIoZGF0YSwgb2Zmc2V0KSB7XG4gIC8qXG4gICAqIGh0dHA6Ly9pZDMub3JnL2lkM3YyLjMuMFxuICAgKiBbMF0gICAgID0gJ0knXG4gICAqIFsxXSAgICAgPSAnRCdcbiAgICogWzJdICAgICA9ICczJ1xuICAgKiBbMyw0XSAgID0ge1ZlcnNpb259XG4gICAqIFs1XSAgICAgPSB7RmxhZ3N9XG4gICAqIFs2LTldICAgPSB7SUQzIFNpemV9XG4gICAqXG4gICAqIEFuIElEM3YyIHRhZyBjYW4gYmUgZGV0ZWN0ZWQgd2l0aCB0aGUgZm9sbG93aW5nIHBhdHRlcm46XG4gICAqICAkNDkgNDQgMzMgeXkgeXkgeHggenogenogenogenpcbiAgICogV2hlcmUgeXkgaXMgbGVzcyB0aGFuICRGRiwgeHggaXMgdGhlICdmbGFncycgYnl0ZSBhbmQgenogaXMgbGVzcyB0aGFuICQ4MFxuICAgKi9cbiAgaWYgKG9mZnNldCArIDEwIDw9IGRhdGEubGVuZ3RoKSB7XG4gICAgLy8gbG9vayBmb3IgJ0lEMycgaWRlbnRpZmllclxuICAgIGlmIChkYXRhW29mZnNldF0gPT09IDB4NDkgJiYgZGF0YVtvZmZzZXQgKyAxXSA9PT0gMHg0NCAmJiBkYXRhW29mZnNldCArIDJdID09PSAweDMzKSB7XG4gICAgICAvLyBjaGVjayB2ZXJzaW9uIGlzIHdpdGhpbiByYW5nZVxuICAgICAgaWYgKGRhdGFbb2Zmc2V0ICsgM10gPCAweGZmICYmIGRhdGFbb2Zmc2V0ICsgNF0gPCAweGZmKSB7XG4gICAgICAgIC8vIGNoZWNrIHNpemUgaXMgd2l0aGluIHJhbmdlXG4gICAgICAgIGlmIChkYXRhW29mZnNldCArIDZdIDwgMHg4MCAmJiBkYXRhW29mZnNldCArIDddIDwgMHg4MCAmJiBkYXRhW29mZnNldCArIDhdIDwgMHg4MCAmJiBkYXRhW29mZnNldCArIDldIDwgMHg4MCkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufTtcbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGFuIElEMyBmb290ZXIgY2FuIGJlIGZvdW5kIGF0IG9mZnNldCBpbiBkYXRhXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGRhdGEgLSBUaGUgZGF0YSB0byBzZWFyY2ggaW5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgLSBUaGUgb2Zmc2V0IGF0IHdoaWNoIHRvIHN0YXJ0IHNlYXJjaGluZ1xuICogQHJldHVybiB7Ym9vbGVhbn0gLSBUcnVlIGlmIGFuIElEMyBmb290ZXIgaXMgZm91bmRcbiAqL1xuXG52YXIgaXNGb290ZXIgPSBmdW5jdGlvbiBpc0Zvb3RlcihkYXRhLCBvZmZzZXQpIHtcbiAgLypcbiAgICogVGhlIGZvb3RlciBpcyBhIGNvcHkgb2YgdGhlIGhlYWRlciwgYnV0IHdpdGggYSBkaWZmZXJlbnQgaWRlbnRpZmllclxuICAgKi9cbiAgaWYgKG9mZnNldCArIDEwIDw9IGRhdGEubGVuZ3RoKSB7XG4gICAgLy8gbG9vayBmb3IgJzNESScgaWRlbnRpZmllclxuICAgIGlmIChkYXRhW29mZnNldF0gPT09IDB4MzMgJiYgZGF0YVtvZmZzZXQgKyAxXSA9PT0gMHg0NCAmJiBkYXRhW29mZnNldCArIDJdID09PSAweDQ5KSB7XG4gICAgICAvLyBjaGVjayB2ZXJzaW9uIGlzIHdpdGhpbiByYW5nZVxuICAgICAgaWYgKGRhdGFbb2Zmc2V0ICsgM10gPCAweGZmICYmIGRhdGFbb2Zmc2V0ICsgNF0gPCAweGZmKSB7XG4gICAgICAgIC8vIGNoZWNrIHNpemUgaXMgd2l0aGluIHJhbmdlXG4gICAgICAgIGlmIChkYXRhW29mZnNldCArIDZdIDwgMHg4MCAmJiBkYXRhW29mZnNldCArIDddIDwgMHg4MCAmJiBkYXRhW29mZnNldCArIDhdIDwgMHg4MCAmJiBkYXRhW29mZnNldCArIDldIDwgMHg4MCkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufTtcbi8qKlxuICogUmV0dXJucyBhbnkgYWRqYWNlbnQgSUQzIHRhZ3MgZm91bmQgaW4gZGF0YSBzdGFydGluZyBhdCBvZmZzZXQsIGFzIG9uZSBibG9jayBvZiBkYXRhXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGRhdGEgLSBUaGUgZGF0YSB0byBzZWFyY2ggaW5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgLSBUaGUgb2Zmc2V0IGF0IHdoaWNoIHRvIHN0YXJ0IHNlYXJjaGluZ1xuICogQHJldHVybiB7VWludDhBcnJheSB8IHVuZGVmaW5lZH0gLSBUaGUgYmxvY2sgb2YgZGF0YSBjb250YWluaW5nIGFueSBJRDMgdGFncyBmb3VuZFxuICogb3IgKnVuZGVmaW5lZCogaWYgbm8gaGVhZGVyIGlzIGZvdW5kIGF0IHRoZSBzdGFydGluZyBvZmZzZXRcbiAqL1xuXG52YXIgZ2V0SUQzRGF0YSA9IGZ1bmN0aW9uIGdldElEM0RhdGEoZGF0YSwgb2Zmc2V0KSB7XG4gIHZhciBmcm9udCA9IG9mZnNldDtcbiAgdmFyIGxlbmd0aCA9IDA7XG5cbiAgd2hpbGUgKGlzSGVhZGVyKGRhdGEsIG9mZnNldCkpIHtcbiAgICAvLyBJRDMgaGVhZGVyIGlzIDEwIGJ5dGVzXG4gICAgbGVuZ3RoICs9IDEwO1xuICAgIHZhciBzaXplID0gcmVhZFNpemUoZGF0YSwgb2Zmc2V0ICsgNik7XG4gICAgbGVuZ3RoICs9IHNpemU7XG5cbiAgICBpZiAoaXNGb290ZXIoZGF0YSwgb2Zmc2V0ICsgMTApKSB7XG4gICAgICAvLyBJRDMgZm9vdGVyIGlzIDEwIGJ5dGVzXG4gICAgICBsZW5ndGggKz0gMTA7XG4gICAgfVxuXG4gICAgb2Zmc2V0ICs9IGxlbmd0aDtcbiAgfVxuXG4gIGlmIChsZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIGRhdGEuc3ViYXJyYXkoZnJvbnQsIGZyb250ICsgbGVuZ3RoKTtcbiAgfVxuXG4gIHJldHVybiB1bmRlZmluZWQ7XG59O1xuXG52YXIgcmVhZFNpemUgPSBmdW5jdGlvbiByZWFkU2l6ZShkYXRhLCBvZmZzZXQpIHtcbiAgdmFyIHNpemUgPSAwO1xuICBzaXplID0gKGRhdGFbb2Zmc2V0XSAmIDB4N2YpIDw8IDIxO1xuICBzaXplIHw9IChkYXRhW29mZnNldCArIDFdICYgMHg3ZikgPDwgMTQ7XG4gIHNpemUgfD0gKGRhdGFbb2Zmc2V0ICsgMl0gJiAweDdmKSA8PCA3O1xuICBzaXplIHw9IGRhdGFbb2Zmc2V0ICsgM10gJiAweDdmO1xuICByZXR1cm4gc2l6ZTtcbn07XG5cbnZhciBjYW5QYXJzZSA9IGZ1bmN0aW9uIGNhblBhcnNlKGRhdGEsIG9mZnNldCkge1xuICByZXR1cm4gaXNIZWFkZXIoZGF0YSwgb2Zmc2V0KSAmJiByZWFkU2l6ZShkYXRhLCBvZmZzZXQgKyA2KSArIDEwIDw9IGRhdGEubGVuZ3RoIC0gb2Zmc2V0O1xufTtcbi8qKlxuICogU2VhcmNoZXMgZm9yIHRoZSBFbGVtZW50YXJ5IFN0cmVhbSB0aW1lc3RhbXAgZm91bmQgaW4gdGhlIElEMyBkYXRhIGNodW5rXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGRhdGEgLSBCbG9jayBvZiBkYXRhIGNvbnRhaW5pbmcgb25lIG9yIG1vcmUgSUQzIHRhZ3NcbiAqIEByZXR1cm4ge251bWJlciB8IHVuZGVmaW5lZH0gLSBUaGUgdGltZXN0YW1wXG4gKi9cblxudmFyIGdldFRpbWVTdGFtcCA9IGZ1bmN0aW9uIGdldFRpbWVTdGFtcChkYXRhKSB7XG4gIHZhciBmcmFtZXMgPSBnZXRJRDNGcmFtZXMoZGF0YSk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBmcmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZnJhbWUgPSBmcmFtZXNbaV07XG5cbiAgICBpZiAoaXNUaW1lU3RhbXBGcmFtZShmcmFtZSkpIHtcbiAgICAgIHJldHVybiByZWFkVGltZVN0YW1wKGZyYW1lKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkO1xufTtcbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBJRDMgZnJhbWUgaXMgYW4gRWxlbWVudGFyeSBTdHJlYW0gdGltZXN0YW1wIGZyYW1lXG4gKiBAcGFyYW0ge0lEMyBmcmFtZX0gZnJhbWVcbiAqL1xuXG52YXIgaXNUaW1lU3RhbXBGcmFtZSA9IGZ1bmN0aW9uIGlzVGltZVN0YW1wRnJhbWUoZnJhbWUpIHtcbiAgcmV0dXJuIGZyYW1lICYmIGZyYW1lLmtleSA9PT0gJ1BSSVYnICYmIGZyYW1lLmluZm8gPT09ICdjb20uYXBwbGUuc3RyZWFtaW5nLnRyYW5zcG9ydFN0cmVhbVRpbWVzdGFtcCc7XG59O1xuXG52YXIgZ2V0RnJhbWVEYXRhID0gZnVuY3Rpb24gZ2V0RnJhbWVEYXRhKGRhdGEpIHtcbiAgLypcbiAgRnJhbWUgSUQgICAgICAgJHh4IHh4IHh4IHh4IChmb3VyIGNoYXJhY3RlcnMpXG4gIFNpemUgICAgICAgICAgICR4eCB4eCB4eCB4eFxuICBGbGFncyAgICAgICAgICAkeHggeHhcbiAgKi9cbiAgdmFyIHR5cGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGRhdGFbMF0sIGRhdGFbMV0sIGRhdGFbMl0sIGRhdGFbM10pO1xuICB2YXIgc2l6ZSA9IHJlYWRTaXplKGRhdGEsIDQpOyAvLyBza2lwIGZyYW1lIGlkLCBzaXplLCBhbmQgZmxhZ3NcblxuICB2YXIgb2Zmc2V0ID0gMTA7XG4gIHJldHVybiB7XG4gICAgdHlwZTogdHlwZSxcbiAgICBzaXplOiBzaXplLFxuICAgIGRhdGE6IGRhdGEuc3ViYXJyYXkob2Zmc2V0LCBvZmZzZXQgKyBzaXplKVxuICB9O1xufTtcbi8qKlxuICogUmV0dXJucyBhbiBhcnJheSBvZiBJRDMgZnJhbWVzIGZvdW5kIGluIGFsbCB0aGUgSUQzIHRhZ3MgaW4gdGhlIGlkM0RhdGFcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gaWQzRGF0YSAtIFRoZSBJRDMgZGF0YSBjb250YWluaW5nIG9uZSBvciBtb3JlIElEMyB0YWdzXG4gKiBAcmV0dXJuIHtJRDMuRnJhbWVbXX0gLSBBcnJheSBvZiBJRDMgZnJhbWUgb2JqZWN0c1xuICovXG5cblxudmFyIGdldElEM0ZyYW1lcyA9IGZ1bmN0aW9uIGdldElEM0ZyYW1lcyhpZDNEYXRhKSB7XG4gIHZhciBvZmZzZXQgPSAwO1xuICB2YXIgZnJhbWVzID0gW107XG5cbiAgd2hpbGUgKGlzSGVhZGVyKGlkM0RhdGEsIG9mZnNldCkpIHtcbiAgICB2YXIgc2l6ZSA9IHJlYWRTaXplKGlkM0RhdGEsIG9mZnNldCArIDYpOyAvLyBza2lwIHBhc3QgSUQzIGhlYWRlclxuXG4gICAgb2Zmc2V0ICs9IDEwO1xuICAgIHZhciBlbmQgPSBvZmZzZXQgKyBzaXplOyAvLyBsb29wIHRocm91Z2ggZnJhbWVzIGluIHRoZSBJRDMgdGFnXG5cbiAgICB3aGlsZSAob2Zmc2V0ICsgOCA8IGVuZCkge1xuICAgICAgdmFyIGZyYW1lRGF0YSA9IGdldEZyYW1lRGF0YShpZDNEYXRhLnN1YmFycmF5KG9mZnNldCkpO1xuICAgICAgdmFyIGZyYW1lID0gZGVjb2RlRnJhbWUoZnJhbWVEYXRhKTtcblxuICAgICAgaWYgKGZyYW1lKSB7XG4gICAgICAgIGZyYW1lcy5wdXNoKGZyYW1lKTtcbiAgICAgIH0gLy8gc2tpcCBmcmFtZSBoZWFkZXIgYW5kIGZyYW1lIGRhdGFcblxuXG4gICAgICBvZmZzZXQgKz0gZnJhbWVEYXRhLnNpemUgKyAxMDtcbiAgICB9XG5cbiAgICBpZiAoaXNGb290ZXIoaWQzRGF0YSwgb2Zmc2V0KSkge1xuICAgICAgb2Zmc2V0ICs9IDEwO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmcmFtZXM7XG59O1xudmFyIGRlY29kZUZyYW1lID0gZnVuY3Rpb24gZGVjb2RlRnJhbWUoZnJhbWUpIHtcbiAgaWYgKGZyYW1lLnR5cGUgPT09ICdQUklWJykge1xuICAgIHJldHVybiBkZWNvZGVQcml2RnJhbWUoZnJhbWUpO1xuICB9IGVsc2UgaWYgKGZyYW1lLnR5cGVbMF0gPT09ICdXJykge1xuICAgIHJldHVybiBkZWNvZGVVUkxGcmFtZShmcmFtZSk7XG4gIH1cblxuICByZXR1cm4gZGVjb2RlVGV4dEZyYW1lKGZyYW1lKTtcbn07XG5cbnZhciBkZWNvZGVQcml2RnJhbWUgPSBmdW5jdGlvbiBkZWNvZGVQcml2RnJhbWUoZnJhbWUpIHtcbiAgLypcbiAgRm9ybWF0OiA8dGV4dCBzdHJpbmc+XFwwPGJpbmFyeSBkYXRhPlxuICAqL1xuICBpZiAoZnJhbWUuc2l6ZSA8IDIpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgdmFyIG93bmVyID0gdXRmOEFycmF5VG9TdHIoZnJhbWUuZGF0YSwgdHJ1ZSk7XG4gIHZhciBwcml2YXRlRGF0YSA9IG5ldyBVaW50OEFycmF5KGZyYW1lLmRhdGEuc3ViYXJyYXkob3duZXIubGVuZ3RoICsgMSkpO1xuICByZXR1cm4ge1xuICAgIGtleTogZnJhbWUudHlwZSxcbiAgICBpbmZvOiBvd25lcixcbiAgICBkYXRhOiBwcml2YXRlRGF0YS5idWZmZXJcbiAgfTtcbn07XG5cbnZhciBkZWNvZGVUZXh0RnJhbWUgPSBmdW5jdGlvbiBkZWNvZGVUZXh0RnJhbWUoZnJhbWUpIHtcbiAgaWYgKGZyYW1lLnNpemUgPCAyKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlmIChmcmFtZS50eXBlID09PSAnVFhYWCcpIHtcbiAgICAvKlxuICAgIEZvcm1hdDpcbiAgICBbMF0gICA9IHtUZXh0IEVuY29kaW5nfVxuICAgIFsxLT9dID0ge0Rlc2NyaXB0aW9ufVxcMHtWYWx1ZX1cbiAgICAqL1xuICAgIHZhciBpbmRleCA9IDE7XG4gICAgdmFyIGRlc2NyaXB0aW9uID0gdXRmOEFycmF5VG9TdHIoZnJhbWUuZGF0YS5zdWJhcnJheShpbmRleCksIHRydWUpO1xuICAgIGluZGV4ICs9IGRlc2NyaXB0aW9uLmxlbmd0aCArIDE7XG4gICAgdmFyIHZhbHVlID0gdXRmOEFycmF5VG9TdHIoZnJhbWUuZGF0YS5zdWJhcnJheShpbmRleCkpO1xuICAgIHJldHVybiB7XG4gICAgICBrZXk6IGZyYW1lLnR5cGUsXG4gICAgICBpbmZvOiBkZXNjcmlwdGlvbixcbiAgICAgIGRhdGE6IHZhbHVlXG4gICAgfTtcbiAgfVxuICAvKlxuICBGb3JtYXQ6XG4gIFswXSAgID0ge1RleHQgRW5jb2Rpbmd9XG4gIFsxLT9dID0ge1ZhbHVlfVxuICAqL1xuXG5cbiAgdmFyIHRleHQgPSB1dGY4QXJyYXlUb1N0cihmcmFtZS5kYXRhLnN1YmFycmF5KDEpKTtcbiAgcmV0dXJuIHtcbiAgICBrZXk6IGZyYW1lLnR5cGUsXG4gICAgZGF0YTogdGV4dFxuICB9O1xufTtcblxudmFyIGRlY29kZVVSTEZyYW1lID0gZnVuY3Rpb24gZGVjb2RlVVJMRnJhbWUoZnJhbWUpIHtcbiAgaWYgKGZyYW1lLnR5cGUgPT09ICdXWFhYJykge1xuICAgIC8qXG4gICAgRm9ybWF0OlxuICAgIFswXSAgID0ge1RleHQgRW5jb2Rpbmd9XG4gICAgWzEtP10gPSB7RGVzY3JpcHRpb259XFwwe1VSTH1cbiAgICAqL1xuICAgIGlmIChmcmFtZS5zaXplIDwgMikge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICB2YXIgaW5kZXggPSAxO1xuICAgIHZhciBkZXNjcmlwdGlvbiA9IHV0ZjhBcnJheVRvU3RyKGZyYW1lLmRhdGEuc3ViYXJyYXkoaW5kZXgpLCB0cnVlKTtcbiAgICBpbmRleCArPSBkZXNjcmlwdGlvbi5sZW5ndGggKyAxO1xuICAgIHZhciB2YWx1ZSA9IHV0ZjhBcnJheVRvU3RyKGZyYW1lLmRhdGEuc3ViYXJyYXkoaW5kZXgpKTtcbiAgICByZXR1cm4ge1xuICAgICAga2V5OiBmcmFtZS50eXBlLFxuICAgICAgaW5mbzogZGVzY3JpcHRpb24sXG4gICAgICBkYXRhOiB2YWx1ZVxuICAgIH07XG4gIH1cbiAgLypcbiAgRm9ybWF0OlxuICBbMC0/XSA9IHtVUkx9XG4gICovXG5cblxuICB2YXIgdXJsID0gdXRmOEFycmF5VG9TdHIoZnJhbWUuZGF0YSk7XG4gIHJldHVybiB7XG4gICAga2V5OiBmcmFtZS50eXBlLFxuICAgIGRhdGE6IHVybFxuICB9O1xufTtcblxudmFyIHJlYWRUaW1lU3RhbXAgPSBmdW5jdGlvbiByZWFkVGltZVN0YW1wKHRpbWVTdGFtcEZyYW1lKSB7XG4gIGlmICh0aW1lU3RhbXBGcmFtZS5kYXRhLmJ5dGVMZW5ndGggPT09IDgpIHtcbiAgICB2YXIgZGF0YSA9IG5ldyBVaW50OEFycmF5KHRpbWVTdGFtcEZyYW1lLmRhdGEpOyAvLyB0aW1lc3RhbXAgaXMgMzMgYml0IGV4cHJlc3NlZCBhcyBhIGJpZy1lbmRpYW4gZWlnaHQtb2N0ZXQgbnVtYmVyLFxuICAgIC8vIHdpdGggdGhlIHVwcGVyIDMxIGJpdHMgc2V0IHRvIHplcm8uXG5cbiAgICB2YXIgcHRzMzNCaXQgPSBkYXRhWzNdICYgMHgxO1xuICAgIHZhciB0aW1lc3RhbXAgPSAoZGF0YVs0XSA8PCAyMykgKyAoZGF0YVs1XSA8PCAxNSkgKyAoZGF0YVs2XSA8PCA3KSArIGRhdGFbN107XG4gICAgdGltZXN0YW1wIC89IDQ1O1xuXG4gICAgaWYgKHB0czMzQml0KSB7XG4gICAgICB0aW1lc3RhbXAgKz0gNDc3MjE4NTguODQ7XG4gICAgfSAvLyAyXjMyIC8gOTBcblxuXG4gICAgcmV0dXJuIE1hdGgucm91bmQodGltZXN0YW1wKTtcbiAgfVxuXG4gIHJldHVybiB1bmRlZmluZWQ7XG59OyAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzg5MzY5ODQvdWludDhhcnJheS10by1zdHJpbmctaW4tamF2YXNjcmlwdC8yMjM3MzE5N1xuLy8gaHR0cDovL3d3dy5vbmljb3MuY29tL3N0YWZmL2l6L2FtdXNlL2phdmFzY3JpcHQvZXhwZXJ0L3V0Zi50eHRcblxuLyogdXRmLmpzIC0gVVRGLTggPD0+IFVURi0xNiBjb252ZXJ0aW9uXG4gKlxuICogQ29weXJpZ2h0IChDKSAxOTk5IE1hc2FuYW8gSXp1bW8gPGl6QG9uaWNvcy5jby5qcD5cbiAqIFZlcnNpb246IDEuMFxuICogTGFzdE1vZGlmaWVkOiBEZWMgMjUgMTk5OVxuICogVGhpcyBsaWJyYXJ5IGlzIGZyZWUuICBZb3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0LlxuICovXG5cblxudmFyIHV0ZjhBcnJheVRvU3RyID0gZnVuY3Rpb24gdXRmOEFycmF5VG9TdHIoYXJyYXksIGV4aXRPbk51bGwpIHtcbiAgaWYgKGV4aXRPbk51bGwgPT09IHZvaWQgMCkge1xuICAgIGV4aXRPbk51bGwgPSBmYWxzZTtcbiAgfVxuXG4gIHZhciBkZWNvZGVyID0gZ2V0VGV4dERlY29kZXIoKTtcblxuICBpZiAoZGVjb2Rlcikge1xuICAgIHZhciBkZWNvZGVkID0gZGVjb2Rlci5kZWNvZGUoYXJyYXkpO1xuXG4gICAgaWYgKGV4aXRPbk51bGwpIHtcbiAgICAgIC8vIGdyYWIgdXAgdG8gdGhlIGZpcnN0IG51bGxcbiAgICAgIHZhciBpZHggPSBkZWNvZGVkLmluZGV4T2YoJ1xcMCcpO1xuICAgICAgcmV0dXJuIGlkeCAhPT0gLTEgPyBkZWNvZGVkLnN1YnN0cmluZygwLCBpZHgpIDogZGVjb2RlZDtcbiAgICB9IC8vIHJlbW92ZSBhbnkgbnVsbCBjaGFyYWN0ZXJzXG5cblxuICAgIHJldHVybiBkZWNvZGVkLnJlcGxhY2UoL1xcMC9nLCAnJyk7XG4gIH1cblxuICB2YXIgbGVuID0gYXJyYXkubGVuZ3RoO1xuICB2YXIgYztcbiAgdmFyIGNoYXIyO1xuICB2YXIgY2hhcjM7XG4gIHZhciBvdXQgPSAnJztcbiAgdmFyIGkgPSAwO1xuXG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgYyA9IGFycmF5W2krK107XG5cbiAgICBpZiAoYyA9PT0gMHgwMCAmJiBleGl0T25OdWxsKSB7XG4gICAgICByZXR1cm4gb3V0O1xuICAgIH0gZWxzZSBpZiAoYyA9PT0gMHgwMCB8fCBjID09PSAweDAzKSB7XG4gICAgICAvLyBJZiB0aGUgY2hhcmFjdGVyIGlzIDMgKEVORF9PRl9URVhUKSBvciAwIChOVUxMKSB0aGVuIHNraXAgaXRcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHN3aXRjaCAoYyA+PiA0KSB7XG4gICAgICBjYXNlIDA6XG4gICAgICBjYXNlIDE6XG4gICAgICBjYXNlIDI6XG4gICAgICBjYXNlIDM6XG4gICAgICBjYXNlIDQ6XG4gICAgICBjYXNlIDU6XG4gICAgICBjYXNlIDY6XG4gICAgICBjYXNlIDc6XG4gICAgICAgIC8vIDB4eHh4eHh4XG4gICAgICAgIG91dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGMpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAxMjpcbiAgICAgIGNhc2UgMTM6XG4gICAgICAgIC8vIDExMHggeHh4eCAgIDEweHggeHh4eFxuICAgICAgICBjaGFyMiA9IGFycmF5W2krK107XG4gICAgICAgIG91dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKChjICYgMHgxZikgPDwgNiB8IGNoYXIyICYgMHgzZik7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDE0OlxuICAgICAgICAvLyAxMTEwIHh4eHggIDEweHggeHh4eCAgMTB4eCB4eHh4XG4gICAgICAgIGNoYXIyID0gYXJyYXlbaSsrXTtcbiAgICAgICAgY2hhcjMgPSBhcnJheVtpKytdO1xuICAgICAgICBvdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoYyAmIDB4MGYpIDw8IDEyIHwgKGNoYXIyICYgMHgzZikgPDwgNiB8IChjaGFyMyAmIDB4M2YpIDw8IDApO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb3V0O1xufTtcbnZhciB0ZXN0YWJsZXMgPSB7XG4gIGRlY29kZVRleHRGcmFtZTogZGVjb2RlVGV4dEZyYW1lXG59O1xudmFyIGRlY29kZXI7XG5cbmZ1bmN0aW9uIGdldFRleHREZWNvZGVyKCkge1xuICBpZiAoIWRlY29kZXIgJiYgdHlwZW9mIHNlbGYuVGV4dERlY29kZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgZGVjb2RlciA9IG5ldyBzZWxmLlRleHREZWNvZGVyKCd1dGYtOCcpO1xuICB9XG5cbiAgcmV0dXJuIGRlY29kZXI7XG59XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2RlbXV4L21wM2RlbXV4ZXIudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9kZW11eC9tcDNkZW11eGVyLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfYmFzZV9hdWRpb19kZW11eGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2Jhc2UtYXVkaW8tZGVtdXhlciAqLyBcIi4vc3JjL2RlbXV4L2Jhc2UtYXVkaW8tZGVtdXhlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZGVtdXhfaWQzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9kZW11eC9pZDMgKi8gXCIuL3NyYy9kZW11eC9pZDMudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvbG9nZ2VyICovIFwiLi9zcmMvdXRpbHMvbG9nZ2VyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9tcGVnYXVkaW9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbXBlZ2F1ZGlvICovIFwiLi9zcmMvZGVtdXgvbXBlZ2F1ZGlvLnRzXCIpO1xuZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7IHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzOyBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbi8qKlxuICogTVAzIGRlbXV4ZXJcbiAqL1xuXG5cblxuXG5cbnZhciBNUDNEZW11eGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQmFzZUF1ZGlvRGVtdXhlcikge1xuICBfaW5oZXJpdHNMb29zZShNUDNEZW11eGVyLCBfQmFzZUF1ZGlvRGVtdXhlcik7XG5cbiAgZnVuY3Rpb24gTVAzRGVtdXhlcigpIHtcbiAgICByZXR1cm4gX0Jhc2VBdWRpb0RlbXV4ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IE1QM0RlbXV4ZXIucHJvdG90eXBlO1xuXG4gIF9wcm90by5yZXNldEluaXRTZWdtZW50ID0gZnVuY3Rpb24gcmVzZXRJbml0U2VnbWVudChhdWRpb0NvZGVjLCB2aWRlb0NvZGVjLCBkdXJhdGlvbikge1xuICAgIF9CYXNlQXVkaW9EZW11eGVyLnByb3RvdHlwZS5yZXNldEluaXRTZWdtZW50LmNhbGwodGhpcywgYXVkaW9Db2RlYywgdmlkZW9Db2RlYywgZHVyYXRpb24pO1xuXG4gICAgdGhpcy5fYXVkaW9UcmFjayA9IHtcbiAgICAgIGNvbnRhaW5lcjogJ2F1ZGlvL21wZWcnLFxuICAgICAgdHlwZTogJ2F1ZGlvJyxcbiAgICAgIGlkOiAyLFxuICAgICAgcGlkOiAtMSxcbiAgICAgIHNlcXVlbmNlTnVtYmVyOiAwLFxuICAgICAgaXNBQUM6IGZhbHNlLFxuICAgICAgc2FtcGxlczogW10sXG4gICAgICBtYW5pZmVzdENvZGVjOiBhdWRpb0NvZGVjLFxuICAgICAgZHVyYXRpb246IGR1cmF0aW9uLFxuICAgICAgaW5wdXRUaW1lU2NhbGU6IDkwMDAwLFxuICAgICAgZHJvcHBlZDogMFxuICAgIH07XG4gIH07XG5cbiAgTVAzRGVtdXhlci5wcm9iZSA9IGZ1bmN0aW9uIHByb2JlKGRhdGEpIHtcbiAgICBpZiAoIWRhdGEpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IC8vIGNoZWNrIGlmIGRhdGEgY29udGFpbnMgSUQzIHRpbWVzdGFtcCBhbmQgTVBFRyBzeW5jIHdvcmRcbiAgICAvLyBMb29rIGZvciBNUEVHIGhlYWRlciB8IDExMTEgMTExMSB8IDExMVggWFlaWCB8IHdoZXJlIFggY2FuIGJlIGVpdGhlciAwIG9yIDEgYW5kIFkgb3IgWiBzaG91bGQgYmUgMVxuICAgIC8vIExheWVyIGJpdHMgKHBvc2l0aW9uIDE0IGFuZCAxNSkgaW4gaGVhZGVyIHNob3VsZCBiZSBhbHdheXMgZGlmZmVyZW50IGZyb20gMCAoTGF5ZXIgSSBvciBMYXllciBJSSBvciBMYXllciBJSUkpXG4gICAgLy8gTW9yZSBpbmZvIGh0dHA6Ly93d3cubXAzLXRlY2gub3JnL3Byb2dyYW1tZXIvZnJhbWVfaGVhZGVyLmh0bWxcblxuXG4gICAgdmFyIGlkM0RhdGEgPSBfZGVtdXhfaWQzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJnZXRJRDNEYXRhXCJdKGRhdGEsIDApIHx8IFtdO1xuICAgIHZhciBvZmZzZXQgPSBpZDNEYXRhLmxlbmd0aDtcblxuICAgIGZvciAodmFyIGxlbmd0aCA9IGRhdGEubGVuZ3RoOyBvZmZzZXQgPCBsZW5ndGg7IG9mZnNldCsrKSB7XG4gICAgICBpZiAoX21wZWdhdWRpb19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wicHJvYmVcIl0oZGF0YSwgb2Zmc2V0KSkge1xuICAgICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJsb2dnZXJcIl0ubG9nKCdNUEVHIEF1ZGlvIHN5bmMgd29yZCBmb3VuZCAhJyk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICBfcHJvdG8uY2FuUGFyc2UgPSBmdW5jdGlvbiBjYW5QYXJzZShkYXRhLCBvZmZzZXQpIHtcbiAgICByZXR1cm4gX21wZWdhdWRpb19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiY2FuUGFyc2VcIl0oZGF0YSwgb2Zmc2V0KTtcbiAgfTtcblxuICBfcHJvdG8uYXBwZW5kRnJhbWUgPSBmdW5jdGlvbiBhcHBlbmRGcmFtZSh0cmFjaywgZGF0YSwgb2Zmc2V0KSB7XG4gICAgaWYgKHRoaXMuaW5pdFBUUyA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJldHVybiBfbXBlZ2F1ZGlvX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJhcHBlbmRGcmFtZVwiXSh0cmFjaywgZGF0YSwgb2Zmc2V0LCB0aGlzLmluaXRQVFMsIHRoaXMuZnJhbWVJbmRleCk7XG4gIH07XG5cbiAgcmV0dXJuIE1QM0RlbXV4ZXI7XG59KF9iYXNlX2F1ZGlvX2RlbXV4ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImRlZmF1bHRcIl0pO1xuXG5NUDNEZW11eGVyLm1pblByb2JlQnl0ZUxlbmd0aCA9IDQ7XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKE1QM0RlbXV4ZXIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9kZW11eC9tcDRkZW11eGVyLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvZGVtdXgvbXA0ZGVtdXhlci50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX21wNF90b29sc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvbXA0LXRvb2xzICovIFwiLi9zcmMvdXRpbHMvbXA0LXRvb2xzLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9kdW1teV9kZW11eGVkX3RyYWNrX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2R1bW15LWRlbXV4ZWQtdHJhY2sgKi8gXCIuL3NyYy9kZW11eC9kdW1teS1kZW11eGVkLXRyYWNrLnRzXCIpO1xuLyoqXG4gKiBNUDQgZGVtdXhlclxuICovXG5cblxuXG52YXIgTVA0RGVtdXhlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIE1QNERlbXV4ZXIob2JzZXJ2ZXIsIGNvbmZpZykge1xuICAgIHRoaXMucmVtYWluZGVyRGF0YSA9IG51bGw7XG4gICAgdGhpcy5jb25maWcgPSB2b2lkIDA7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gTVA0RGVtdXhlci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLnJlc2V0VGltZVN0YW1wID0gZnVuY3Rpb24gcmVzZXRUaW1lU3RhbXAoKSB7fTtcblxuICBfcHJvdG8ucmVzZXRJbml0U2VnbWVudCA9IGZ1bmN0aW9uIHJlc2V0SW5pdFNlZ21lbnQoKSB7fTtcblxuICBfcHJvdG8ucmVzZXRDb250aWd1aXR5ID0gZnVuY3Rpb24gcmVzZXRDb250aWd1aXR5KCkge307XG5cbiAgTVA0RGVtdXhlci5wcm9iZSA9IGZ1bmN0aW9uIHByb2JlKGRhdGEpIHtcbiAgICAvLyBlbnN1cmUgd2UgZmluZCBhIG1vb2YgYm94IGluIHRoZSBmaXJzdCAxNiBrQlxuICAgIHJldHVybiBPYmplY3QoX3V0aWxzX21wNF90b29sc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiZmluZEJveFwiXSkoe1xuICAgICAgZGF0YTogZGF0YSxcbiAgICAgIHN0YXJ0OiAwLFxuICAgICAgZW5kOiBNYXRoLm1pbihkYXRhLmxlbmd0aCwgMTYzODQpXG4gICAgfSwgWydtb29mJ10pLmxlbmd0aCA+IDA7XG4gIH07XG5cbiAgX3Byb3RvLmRlbXV4ID0gZnVuY3Rpb24gZGVtdXgoZGF0YSkge1xuICAgIC8vIExvYWQgYWxsIGRhdGEgaW50byB0aGUgYXZjIHRyYWNrLiBUaGUgQ01BRiByZW11eGVyIHdpbGwgbG9vayBmb3IgdGhlIGRhdGEgaW4gdGhlIHNhbXBsZXMgb2JqZWN0OyB0aGUgcmVzdCBvZiB0aGUgZmllbGRzIGRvIG5vdCBtYXR0ZXJcbiAgICB2YXIgYXZjU2FtcGxlcyA9IGRhdGE7XG4gICAgdmFyIGF2Y1RyYWNrID0gT2JqZWN0KF9kdW1teV9kZW11eGVkX3RyYWNrX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJkdW1teVRyYWNrXCJdKSgpO1xuXG4gICAgaWYgKHRoaXMuY29uZmlnLnByb2dyZXNzaXZlKSB7XG4gICAgICAvLyBTcGxpdCB0aGUgYnl0ZXN0cmVhbSBpbnRvIHR3byByYW5nZXM6IG9uZSBlbmNvbXBhc3NpbmcgYWxsIGRhdGEgdXAgdW50aWwgdGhlIHN0YXJ0IG9mIHRoZSBsYXN0IG1vb2YsIGFuZCBldmVyeXRoaW5nIGVsc2UuXG4gICAgICAvLyBUaGlzIGlzIGRvbmUgdG8gZ3VhcmFudGVlIHRoYXQgd2UncmUgc2VuZGluZyB2YWxpZCBkYXRhIHRvIE1TRSAtIHdoZW4gZGVtdXhpbmcgcHJvZ3Jlc3NpdmVseSwgd2UgaGF2ZSBubyBndWFyYW50ZWVcbiAgICAgIC8vIHRoYXQgdGhlIGZldGNoIGxvYWRlciBnaXZlcyB1cyBmbHVzaCBtb29mK21kYXQgcGFpcnMuIElmIHdlIHB1c2ggamFnZ2VkIGRhdGEgdG8gTVNFLCBpdCB3aWxsIHRocm93IGFuIGV4Y2VwdGlvbi5cbiAgICAgIGlmICh0aGlzLnJlbWFpbmRlckRhdGEpIHtcbiAgICAgICAgYXZjU2FtcGxlcyA9IE9iamVjdChfdXRpbHNfbXA0X3Rvb2xzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJhcHBlbmRVaW50OEFycmF5XCJdKSh0aGlzLnJlbWFpbmRlckRhdGEsIGRhdGEpO1xuICAgICAgfVxuXG4gICAgICB2YXIgc2VnbWVudGVkRGF0YSA9IE9iamVjdChfdXRpbHNfbXA0X3Rvb2xzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJzZWdtZW50VmFsaWRSYW5nZVwiXSkoYXZjU2FtcGxlcyk7XG4gICAgICB0aGlzLnJlbWFpbmRlckRhdGEgPSBzZWdtZW50ZWREYXRhLnJlbWFpbmRlcjtcbiAgICAgIGF2Y1RyYWNrLnNhbXBsZXMgPSBzZWdtZW50ZWREYXRhLnZhbGlkIHx8IG5ldyBVaW50OEFycmF5KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGF2Y1RyYWNrLnNhbXBsZXMgPSBhdmNTYW1wbGVzO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBhdWRpb1RyYWNrOiBPYmplY3QoX2R1bW15X2RlbXV4ZWRfdHJhY2tfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImR1bW15VHJhY2tcIl0pKCksXG4gICAgICBhdmNUcmFjazogYXZjVHJhY2ssXG4gICAgICBpZDNUcmFjazogT2JqZWN0KF9kdW1teV9kZW11eGVkX3RyYWNrX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJkdW1teVRyYWNrXCJdKSgpLFxuICAgICAgdGV4dFRyYWNrOiBPYmplY3QoX2R1bW15X2RlbXV4ZWRfdHJhY2tfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImR1bW15VHJhY2tcIl0pKClcbiAgICB9O1xuICB9O1xuXG4gIF9wcm90by5mbHVzaCA9IGZ1bmN0aW9uIGZsdXNoKCkge1xuICAgIHZhciBhdmNUcmFjayA9IE9iamVjdChfZHVtbXlfZGVtdXhlZF90cmFja19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiZHVtbXlUcmFja1wiXSkoKTtcbiAgICBhdmNUcmFjay5zYW1wbGVzID0gdGhpcy5yZW1haW5kZXJEYXRhIHx8IG5ldyBVaW50OEFycmF5KCk7XG4gICAgdGhpcy5yZW1haW5kZXJEYXRhID0gbnVsbDtcbiAgICByZXR1cm4ge1xuICAgICAgYXVkaW9UcmFjazogT2JqZWN0KF9kdW1teV9kZW11eGVkX3RyYWNrX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJkdW1teVRyYWNrXCJdKSgpLFxuICAgICAgYXZjVHJhY2s6IGF2Y1RyYWNrLFxuICAgICAgaWQzVHJhY2s6IE9iamVjdChfZHVtbXlfZGVtdXhlZF90cmFja19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiZHVtbXlUcmFja1wiXSkoKSxcbiAgICAgIHRleHRUcmFjazogT2JqZWN0KF9kdW1teV9kZW11eGVkX3RyYWNrX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJkdW1teVRyYWNrXCJdKSgpXG4gICAgfTtcbiAgfTtcblxuICBfcHJvdG8uZGVtdXhTYW1wbGVBZXMgPSBmdW5jdGlvbiBkZW11eFNhbXBsZUFlcyhkYXRhLCBrZXlEYXRhLCB0aW1lT2Zmc2V0KSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignVGhlIE1QNCBkZW11eGVyIGRvZXMgbm90IHN1cHBvcnQgU0FNUExFLUFFUyBkZWNyeXB0aW9uJykpO1xuICB9O1xuXG4gIF9wcm90by5kZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveSgpIHt9O1xuXG4gIHJldHVybiBNUDREZW11eGVyO1xufSgpO1xuXG5NUDREZW11eGVyLm1pblByb2JlQnl0ZUxlbmd0aCA9IDEwMjQ7XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKE1QNERlbXV4ZXIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9kZW11eC9tcGVnYXVkaW8udHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2RlbXV4L21wZWdhdWRpby50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogYXBwZW5kRnJhbWUsIHBhcnNlSGVhZGVyLCBpc0hlYWRlclBhdHRlcm4sIGlzSGVhZGVyLCBjYW5QYXJzZSwgcHJvYmUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiYXBwZW5kRnJhbWVcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBhcHBlbmRGcmFtZTsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwicGFyc2VIZWFkZXJcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBwYXJzZUhlYWRlcjsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiaXNIZWFkZXJQYXR0ZXJuXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gaXNIZWFkZXJQYXR0ZXJuOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJpc0hlYWRlclwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGlzSGVhZGVyOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJjYW5QYXJzZVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGNhblBhcnNlOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJwcm9iZVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHByb2JlOyB9KTtcbi8qKlxuICogIE1QRUcgcGFyc2VyIGhlbHBlclxuICovXG52YXIgY2hyb21lVmVyc2lvbiA9IG51bGw7XG52YXIgQml0cmF0ZXNNYXAgPSBbMzIsIDY0LCA5NiwgMTI4LCAxNjAsIDE5MiwgMjI0LCAyNTYsIDI4OCwgMzIwLCAzNTIsIDM4NCwgNDE2LCA0NDgsIDMyLCA0OCwgNTYsIDY0LCA4MCwgOTYsIDExMiwgMTI4LCAxNjAsIDE5MiwgMjI0LCAyNTYsIDMyMCwgMzg0LCAzMiwgNDAsIDQ4LCA1NiwgNjQsIDgwLCA5NiwgMTEyLCAxMjgsIDE2MCwgMTkyLCAyMjQsIDI1NiwgMzIwLCAzMiwgNDgsIDU2LCA2NCwgODAsIDk2LCAxMTIsIDEyOCwgMTQ0LCAxNjAsIDE3NiwgMTkyLCAyMjQsIDI1NiwgOCwgMTYsIDI0LCAzMiwgNDAsIDQ4LCA1NiwgNjQsIDgwLCA5NiwgMTEyLCAxMjgsIDE0NCwgMTYwXTtcbnZhciBTYW1wbGluZ1JhdGVNYXAgPSBbNDQxMDAsIDQ4MDAwLCAzMjAwMCwgMjIwNTAsIDI0MDAwLCAxNjAwMCwgMTEwMjUsIDEyMDAwLCA4MDAwXTtcbnZhciBTYW1wbGVzQ29lZmZpY2llbnRzID0gWy8vIE1QRUcgMi41XG5bMCwgLy8gUmVzZXJ2ZWRcbjcyLCAvLyBMYXllcjNcbjE0NCwgLy8gTGF5ZXIyXG4xMiAvLyBMYXllcjFcbl0sIC8vIFJlc2VydmVkXG5bMCwgLy8gUmVzZXJ2ZWRcbjAsIC8vIExheWVyM1xuMCwgLy8gTGF5ZXIyXG4wIC8vIExheWVyMVxuXSwgLy8gTVBFRyAyXG5bMCwgLy8gUmVzZXJ2ZWRcbjcyLCAvLyBMYXllcjNcbjE0NCwgLy8gTGF5ZXIyXG4xMiAvLyBMYXllcjFcbl0sIC8vIE1QRUcgMVxuWzAsIC8vIFJlc2VydmVkXG4xNDQsIC8vIExheWVyM1xuMTQ0LCAvLyBMYXllcjJcbjEyIC8vIExheWVyMVxuXV07XG52YXIgQnl0ZXNJblNsb3QgPSBbMCwgLy8gUmVzZXJ2ZWRcbjEsIC8vIExheWVyM1xuMSwgLy8gTGF5ZXIyXG40IC8vIExheWVyMVxuXTtcbmZ1bmN0aW9uIGFwcGVuZEZyYW1lKHRyYWNrLCBkYXRhLCBvZmZzZXQsIHB0cywgZnJhbWVJbmRleCkge1xuICAvLyBVc2luZyBodHRwOi8vd3d3LmRhdGF2b3lhZ2UuY29tL21wZ3NjcmlwdC9tcGVnaGRyLmh0bSBhcyBhIHJlZmVyZW5jZVxuICBpZiAob2Zmc2V0ICsgMjQgPiBkYXRhLmxlbmd0aCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBoZWFkZXIgPSBwYXJzZUhlYWRlcihkYXRhLCBvZmZzZXQpO1xuXG4gIGlmIChoZWFkZXIgJiYgb2Zmc2V0ICsgaGVhZGVyLmZyYW1lTGVuZ3RoIDw9IGRhdGEubGVuZ3RoKSB7XG4gICAgdmFyIGZyYW1lRHVyYXRpb24gPSBoZWFkZXIuc2FtcGxlc1BlckZyYW1lICogOTAwMDAgLyBoZWFkZXIuc2FtcGxlUmF0ZTtcbiAgICB2YXIgc3RhbXAgPSBwdHMgKyBmcmFtZUluZGV4ICogZnJhbWVEdXJhdGlvbjtcbiAgICB2YXIgc2FtcGxlID0ge1xuICAgICAgdW5pdDogZGF0YS5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIGhlYWRlci5mcmFtZUxlbmd0aCksXG4gICAgICBwdHM6IHN0YW1wLFxuICAgICAgZHRzOiBzdGFtcFxuICAgIH07XG4gICAgdHJhY2suY29uZmlnID0gW107XG4gICAgdHJhY2suY2hhbm5lbENvdW50ID0gaGVhZGVyLmNoYW5uZWxDb3VudDtcbiAgICB0cmFjay5zYW1wbGVyYXRlID0gaGVhZGVyLnNhbXBsZVJhdGU7XG4gICAgdHJhY2suc2FtcGxlcy5wdXNoKHNhbXBsZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNhbXBsZTogc2FtcGxlLFxuICAgICAgbGVuZ3RoOiBoZWFkZXIuZnJhbWVMZW5ndGgsXG4gICAgICBtaXNzaW5nOiAwXG4gICAgfTtcbiAgfVxufVxuZnVuY3Rpb24gcGFyc2VIZWFkZXIoZGF0YSwgb2Zmc2V0KSB7XG4gIHZhciBtcGVnVmVyc2lvbiA9IGRhdGFbb2Zmc2V0ICsgMV0gPj4gMyAmIDM7XG4gIHZhciBtcGVnTGF5ZXIgPSBkYXRhW29mZnNldCArIDFdID4+IDEgJiAzO1xuICB2YXIgYml0UmF0ZUluZGV4ID0gZGF0YVtvZmZzZXQgKyAyXSA+PiA0ICYgMTU7XG4gIHZhciBzYW1wbGVSYXRlSW5kZXggPSBkYXRhW29mZnNldCArIDJdID4+IDIgJiAzO1xuXG4gIGlmIChtcGVnVmVyc2lvbiAhPT0gMSAmJiBiaXRSYXRlSW5kZXggIT09IDAgJiYgYml0UmF0ZUluZGV4ICE9PSAxNSAmJiBzYW1wbGVSYXRlSW5kZXggIT09IDMpIHtcbiAgICB2YXIgcGFkZGluZ0JpdCA9IGRhdGFbb2Zmc2V0ICsgMl0gPj4gMSAmIDE7XG4gICAgdmFyIGNoYW5uZWxNb2RlID0gZGF0YVtvZmZzZXQgKyAzXSA+PiA2O1xuICAgIHZhciBjb2x1bW5JbkJpdHJhdGVzID0gbXBlZ1ZlcnNpb24gPT09IDMgPyAzIC0gbXBlZ0xheWVyIDogbXBlZ0xheWVyID09PSAzID8gMyA6IDQ7XG4gICAgdmFyIGJpdFJhdGUgPSBCaXRyYXRlc01hcFtjb2x1bW5JbkJpdHJhdGVzICogMTQgKyBiaXRSYXRlSW5kZXggLSAxXSAqIDEwMDA7XG4gICAgdmFyIGNvbHVtbkluU2FtcGxlUmF0ZXMgPSBtcGVnVmVyc2lvbiA9PT0gMyA/IDAgOiBtcGVnVmVyc2lvbiA9PT0gMiA/IDEgOiAyO1xuICAgIHZhciBzYW1wbGVSYXRlID0gU2FtcGxpbmdSYXRlTWFwW2NvbHVtbkluU2FtcGxlUmF0ZXMgKiAzICsgc2FtcGxlUmF0ZUluZGV4XTtcbiAgICB2YXIgY2hhbm5lbENvdW50ID0gY2hhbm5lbE1vZGUgPT09IDMgPyAxIDogMjsgLy8gSWYgYml0cyBvZiBjaGFubmVsIG1vZGUgYXJlIGAxMWAgdGhlbiBpdCBpcyBhIHNpbmdsZSBjaGFubmVsIChNb25vKVxuXG4gICAgdmFyIHNhbXBsZUNvZWZmaWNpZW50ID0gU2FtcGxlc0NvZWZmaWNpZW50c1ttcGVnVmVyc2lvbl1bbXBlZ0xheWVyXTtcbiAgICB2YXIgYnl0ZXNJblNsb3QgPSBCeXRlc0luU2xvdFttcGVnTGF5ZXJdO1xuICAgIHZhciBzYW1wbGVzUGVyRnJhbWUgPSBzYW1wbGVDb2VmZmljaWVudCAqIDggKiBieXRlc0luU2xvdDtcbiAgICB2YXIgZnJhbWVMZW5ndGggPSBNYXRoLmZsb29yKHNhbXBsZUNvZWZmaWNpZW50ICogYml0UmF0ZSAvIHNhbXBsZVJhdGUgKyBwYWRkaW5nQml0KSAqIGJ5dGVzSW5TbG90O1xuXG4gICAgaWYgKGNocm9tZVZlcnNpb24gPT09IG51bGwpIHtcbiAgICAgIHZhciB1c2VyQWdlbnQgPSBuYXZpZ2F0b3IudXNlckFnZW50IHx8ICcnO1xuICAgICAgdmFyIHJlc3VsdCA9IHVzZXJBZ2VudC5tYXRjaCgvQ2hyb21lXFwvKFxcZCspL2kpO1xuICAgICAgY2hyb21lVmVyc2lvbiA9IHJlc3VsdCA/IHBhcnNlSW50KHJlc3VsdFsxXSkgOiAwO1xuICAgIH1cblxuICAgIHZhciBuZWVkQ2hyb21lRml4ID0gISFjaHJvbWVWZXJzaW9uICYmIGNocm9tZVZlcnNpb24gPD0gODc7XG5cbiAgICBpZiAobmVlZENocm9tZUZpeCAmJiBtcGVnTGF5ZXIgPT09IDIgJiYgYml0UmF0ZSA+PSAyMjQwMDAgJiYgY2hhbm5lbE1vZGUgPT09IDApIHtcbiAgICAgIC8vIFdvcmsgYXJvdW5kIGJ1ZyBpbiBDaHJvbWl1bSBieSBzZXR0aW5nIGNoYW5uZWxNb2RlIHRvIGR1YWwtY2hhbm5lbCAoMDEpIGluc3RlYWQgb2Ygc3RlcmVvICgwMClcbiAgICAgIGRhdGFbb2Zmc2V0ICsgM10gPSBkYXRhW29mZnNldCArIDNdIHwgMHg4MDtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgc2FtcGxlUmF0ZTogc2FtcGxlUmF0ZSxcbiAgICAgIGNoYW5uZWxDb3VudDogY2hhbm5lbENvdW50LFxuICAgICAgZnJhbWVMZW5ndGg6IGZyYW1lTGVuZ3RoLFxuICAgICAgc2FtcGxlc1BlckZyYW1lOiBzYW1wbGVzUGVyRnJhbWVcbiAgICB9O1xuICB9XG59XG5mdW5jdGlvbiBpc0hlYWRlclBhdHRlcm4oZGF0YSwgb2Zmc2V0KSB7XG4gIHJldHVybiBkYXRhW29mZnNldF0gPT09IDB4ZmYgJiYgKGRhdGFbb2Zmc2V0ICsgMV0gJiAweGUwKSA9PT0gMHhlMCAmJiAoZGF0YVtvZmZzZXQgKyAxXSAmIDB4MDYpICE9PSAweDAwO1xufVxuZnVuY3Rpb24gaXNIZWFkZXIoZGF0YSwgb2Zmc2V0KSB7XG4gIC8vIExvb2sgZm9yIE1QRUcgaGVhZGVyIHwgMTExMSAxMTExIHwgMTExWCBYWVpYIHwgd2hlcmUgWCBjYW4gYmUgZWl0aGVyIDAgb3IgMSBhbmQgWSBvciBaIHNob3VsZCBiZSAxXG4gIC8vIExheWVyIGJpdHMgKHBvc2l0aW9uIDE0IGFuZCAxNSkgaW4gaGVhZGVyIHNob3VsZCBiZSBhbHdheXMgZGlmZmVyZW50IGZyb20gMCAoTGF5ZXIgSSBvciBMYXllciBJSSBvciBMYXllciBJSUkpXG4gIC8vIE1vcmUgaW5mbyBodHRwOi8vd3d3Lm1wMy10ZWNoLm9yZy9wcm9ncmFtbWVyL2ZyYW1lX2hlYWRlci5odG1sXG4gIHJldHVybiBvZmZzZXQgKyAxIDwgZGF0YS5sZW5ndGggJiYgaXNIZWFkZXJQYXR0ZXJuKGRhdGEsIG9mZnNldCk7XG59XG5mdW5jdGlvbiBjYW5QYXJzZShkYXRhLCBvZmZzZXQpIHtcbiAgdmFyIGhlYWRlclNpemUgPSA0O1xuICByZXR1cm4gaXNIZWFkZXJQYXR0ZXJuKGRhdGEsIG9mZnNldCkgJiYgaGVhZGVyU2l6ZSA8PSBkYXRhLmxlbmd0aCAtIG9mZnNldDtcbn1cbmZ1bmN0aW9uIHByb2JlKGRhdGEsIG9mZnNldCkge1xuICAvLyBzYW1lIGFzIGlzSGVhZGVyIGJ1dCB3ZSBhbHNvIGNoZWNrIHRoYXQgTVBFRyBmcmFtZSBmb2xsb3dzIGxhc3QgTVBFRyBmcmFtZVxuICAvLyBvciBlbmQgb2YgZGF0YSBpcyByZWFjaGVkXG4gIGlmIChvZmZzZXQgKyAxIDwgZGF0YS5sZW5ndGggJiYgaXNIZWFkZXJQYXR0ZXJuKGRhdGEsIG9mZnNldCkpIHtcbiAgICAvLyBNUEVHIGhlYWRlciBMZW5ndGhcbiAgICB2YXIgaGVhZGVyTGVuZ3RoID0gNDsgLy8gTVBFRyBmcmFtZSBMZW5ndGhcblxuICAgIHZhciBoZWFkZXIgPSBwYXJzZUhlYWRlcihkYXRhLCBvZmZzZXQpO1xuICAgIHZhciBmcmFtZUxlbmd0aCA9IGhlYWRlckxlbmd0aDtcblxuICAgIGlmIChoZWFkZXIgIT09IG51bGwgJiYgaGVhZGVyICE9PSB2b2lkIDAgJiYgaGVhZGVyLmZyYW1lTGVuZ3RoKSB7XG4gICAgICBmcmFtZUxlbmd0aCA9IGhlYWRlci5mcmFtZUxlbmd0aDtcbiAgICB9XG5cbiAgICB2YXIgbmV3T2Zmc2V0ID0gb2Zmc2V0ICsgZnJhbWVMZW5ndGg7XG4gICAgcmV0dXJuIG5ld09mZnNldCA9PT0gZGF0YS5sZW5ndGggfHwgaXNIZWFkZXIoZGF0YSwgbmV3T2Zmc2V0KTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvZGVtdXgvc2FtcGxlLWFlcy50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2RlbXV4L3NhbXBsZS1hZXMudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9jcnlwdF9kZWNyeXB0ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2NyeXB0L2RlY3J5cHRlciAqLyBcIi4vc3JjL2NyeXB0L2RlY3J5cHRlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdHNkZW11eGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3RzZGVtdXhlciAqLyBcIi4vc3JjL2RlbXV4L3RzZGVtdXhlci50c1wiKTtcbi8qKlxuICogU0FNUExFLUFFUyBkZWNyeXB0ZXJcbiAqL1xuXG5cblxudmFyIFNhbXBsZUFlc0RlY3J5cHRlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFNhbXBsZUFlc0RlY3J5cHRlcihvYnNlcnZlciwgY29uZmlnLCBrZXlEYXRhKSB7XG4gICAgdGhpcy5rZXlEYXRhID0gdm9pZCAwO1xuICAgIHRoaXMuZGVjcnlwdGVyID0gdm9pZCAwO1xuICAgIHRoaXMua2V5RGF0YSA9IGtleURhdGE7XG4gICAgdGhpcy5kZWNyeXB0ZXIgPSBuZXcgX2NyeXB0X2RlY3J5cHRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiZGVmYXVsdFwiXShvYnNlcnZlciwgY29uZmlnLCB7XG4gICAgICByZW1vdmVQS0NTN1BhZGRpbmc6IGZhbHNlXG4gICAgfSk7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gU2FtcGxlQWVzRGVjcnlwdGVyLnByb3RvdHlwZTtcblxuICBfcHJvdG8uZGVjcnlwdEJ1ZmZlciA9IGZ1bmN0aW9uIGRlY3J5cHRCdWZmZXIoZW5jcnlwdGVkRGF0YSwgY2FsbGJhY2spIHtcbiAgICB0aGlzLmRlY3J5cHRlci5kZWNyeXB0KGVuY3J5cHRlZERhdGEsIHRoaXMua2V5RGF0YS5rZXkuYnVmZmVyLCB0aGlzLmtleURhdGEuaXYuYnVmZmVyLCBjYWxsYmFjayk7XG4gIH0gLy8gQUFDIC0gZW5jcnlwdCBhbGwgZnVsbCAxNiBieXRlcyBibG9ja3Mgc3RhcnRpbmcgZnJvbSBvZmZzZXQgMTZcbiAgO1xuXG4gIF9wcm90by5kZWNyeXB0QWFjU2FtcGxlID0gZnVuY3Rpb24gZGVjcnlwdEFhY1NhbXBsZShzYW1wbGVzLCBzYW1wbGVJbmRleCwgY2FsbGJhY2ssIHN5bmMpIHtcbiAgICB2YXIgY3VyVW5pdCA9IHNhbXBsZXNbc2FtcGxlSW5kZXhdLnVuaXQ7XG4gICAgdmFyIGVuY3J5cHRlZERhdGEgPSBjdXJVbml0LnN1YmFycmF5KDE2LCBjdXJVbml0Lmxlbmd0aCAtIGN1clVuaXQubGVuZ3RoICUgMTYpO1xuICAgIHZhciBlbmNyeXB0ZWRCdWZmZXIgPSBlbmNyeXB0ZWREYXRhLmJ1ZmZlci5zbGljZShlbmNyeXB0ZWREYXRhLmJ5dGVPZmZzZXQsIGVuY3J5cHRlZERhdGEuYnl0ZU9mZnNldCArIGVuY3J5cHRlZERhdGEubGVuZ3RoKTtcbiAgICB2YXIgbG9jYWx0aGlzID0gdGhpcztcbiAgICB0aGlzLmRlY3J5cHRCdWZmZXIoZW5jcnlwdGVkQnVmZmVyLCBmdW5jdGlvbiAoZGVjcnlwdGVkQnVmZmVyKSB7XG4gICAgICB2YXIgZGVjcnlwdGVkRGF0YSA9IG5ldyBVaW50OEFycmF5KGRlY3J5cHRlZEJ1ZmZlcik7XG4gICAgICBjdXJVbml0LnNldChkZWNyeXB0ZWREYXRhLCAxNik7XG5cbiAgICAgIGlmICghc3luYykge1xuICAgICAgICBsb2NhbHRoaXMuZGVjcnlwdEFhY1NhbXBsZXMoc2FtcGxlcywgc2FtcGxlSW5kZXggKyAxLCBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLmRlY3J5cHRBYWNTYW1wbGVzID0gZnVuY3Rpb24gZGVjcnlwdEFhY1NhbXBsZXMoc2FtcGxlcywgc2FtcGxlSW5kZXgsIGNhbGxiYWNrKSB7XG4gICAgZm9yICg7OyBzYW1wbGVJbmRleCsrKSB7XG4gICAgICBpZiAoc2FtcGxlSW5kZXggPj0gc2FtcGxlcy5sZW5ndGgpIHtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2FtcGxlc1tzYW1wbGVJbmRleF0udW5pdC5sZW5ndGggPCAzMikge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHN5bmMgPSB0aGlzLmRlY3J5cHRlci5pc1N5bmMoKTtcbiAgICAgIHRoaXMuZGVjcnlwdEFhY1NhbXBsZShzYW1wbGVzLCBzYW1wbGVJbmRleCwgY2FsbGJhY2ssIHN5bmMpO1xuXG4gICAgICBpZiAoIXN5bmMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgfSAvLyBBVkMgLSBlbmNyeXB0IG9uZSAxNiBieXRlcyBibG9jayBvdXQgb2YgdGVuLCBzdGFydGluZyBmcm9tIG9mZnNldCAzMlxuICA7XG5cbiAgX3Byb3RvLmdldEF2Y0VuY3J5cHRlZERhdGEgPSBmdW5jdGlvbiBnZXRBdmNFbmNyeXB0ZWREYXRhKGRlY29kZWREYXRhKSB7XG4gICAgdmFyIGVuY3J5cHRlZERhdGFMZW4gPSBNYXRoLmZsb29yKChkZWNvZGVkRGF0YS5sZW5ndGggLSA0OCkgLyAxNjApICogMTYgKyAxNjtcbiAgICB2YXIgZW5jcnlwdGVkRGF0YSA9IG5ldyBJbnQ4QXJyYXkoZW5jcnlwdGVkRGF0YUxlbik7XG4gICAgdmFyIG91dHB1dFBvcyA9IDA7XG5cbiAgICBmb3IgKHZhciBpbnB1dFBvcyA9IDMyOyBpbnB1dFBvcyA8IGRlY29kZWREYXRhLmxlbmd0aCAtIDE2OyBpbnB1dFBvcyArPSAxNjAsIG91dHB1dFBvcyArPSAxNikge1xuICAgICAgZW5jcnlwdGVkRGF0YS5zZXQoZGVjb2RlZERhdGEuc3ViYXJyYXkoaW5wdXRQb3MsIGlucHV0UG9zICsgMTYpLCBvdXRwdXRQb3MpO1xuICAgIH1cblxuICAgIHJldHVybiBlbmNyeXB0ZWREYXRhO1xuICB9O1xuXG4gIF9wcm90by5nZXRBdmNEZWNyeXB0ZWRVbml0ID0gZnVuY3Rpb24gZ2V0QXZjRGVjcnlwdGVkVW5pdChkZWNvZGVkRGF0YSwgZGVjcnlwdGVkRGF0YSkge1xuICAgIHZhciB1aW50OERlY3J5cHRlZERhdGEgPSBuZXcgVWludDhBcnJheShkZWNyeXB0ZWREYXRhKTtcbiAgICB2YXIgaW5wdXRQb3MgPSAwO1xuXG4gICAgZm9yICh2YXIgb3V0cHV0UG9zID0gMzI7IG91dHB1dFBvcyA8IGRlY29kZWREYXRhLmxlbmd0aCAtIDE2OyBvdXRwdXRQb3MgKz0gMTYwLCBpbnB1dFBvcyArPSAxNikge1xuICAgICAgZGVjb2RlZERhdGEuc2V0KHVpbnQ4RGVjcnlwdGVkRGF0YS5zdWJhcnJheShpbnB1dFBvcywgaW5wdXRQb3MgKyAxNiksIG91dHB1dFBvcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlY29kZWREYXRhO1xuICB9O1xuXG4gIF9wcm90by5kZWNyeXB0QXZjU2FtcGxlID0gZnVuY3Rpb24gZGVjcnlwdEF2Y1NhbXBsZShzYW1wbGVzLCBzYW1wbGVJbmRleCwgdW5pdEluZGV4LCBjYWxsYmFjaywgY3VyVW5pdCwgc3luYykge1xuICAgIHZhciBkZWNvZGVkRGF0YSA9IE9iamVjdChfdHNkZW11eGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJkaXNjYXJkRVBCXCJdKShjdXJVbml0LmRhdGEpO1xuICAgIHZhciBlbmNyeXB0ZWREYXRhID0gdGhpcy5nZXRBdmNFbmNyeXB0ZWREYXRhKGRlY29kZWREYXRhKTtcbiAgICB2YXIgbG9jYWx0aGlzID0gdGhpcztcbiAgICB0aGlzLmRlY3J5cHRCdWZmZXIoZW5jcnlwdGVkRGF0YS5idWZmZXIsIGZ1bmN0aW9uIChkZWNyeXB0ZWRCdWZmZXIpIHtcbiAgICAgIGN1clVuaXQuZGF0YSA9IGxvY2FsdGhpcy5nZXRBdmNEZWNyeXB0ZWRVbml0KGRlY29kZWREYXRhLCBkZWNyeXB0ZWRCdWZmZXIpO1xuXG4gICAgICBpZiAoIXN5bmMpIHtcbiAgICAgICAgbG9jYWx0aGlzLmRlY3J5cHRBdmNTYW1wbGVzKHNhbXBsZXMsIHNhbXBsZUluZGV4LCB1bml0SW5kZXggKyAxLCBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLmRlY3J5cHRBdmNTYW1wbGVzID0gZnVuY3Rpb24gZGVjcnlwdEF2Y1NhbXBsZXMoc2FtcGxlcywgc2FtcGxlSW5kZXgsIHVuaXRJbmRleCwgY2FsbGJhY2spIHtcbiAgICBpZiAoc2FtcGxlcyBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGRlY3J5cHQgc2FtcGxlcyBvZiB0eXBlIFVpbnQ4QXJyYXknKTtcbiAgICB9XG5cbiAgICBmb3IgKDs7IHNhbXBsZUluZGV4KyssIHVuaXRJbmRleCA9IDApIHtcbiAgICAgIGlmIChzYW1wbGVJbmRleCA+PSBzYW1wbGVzLmxlbmd0aCkge1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBjdXJVbml0cyA9IHNhbXBsZXNbc2FtcGxlSW5kZXhdLnVuaXRzO1xuXG4gICAgICBmb3IgKDs7IHVuaXRJbmRleCsrKSB7XG4gICAgICAgIGlmICh1bml0SW5kZXggPj0gY3VyVW5pdHMubGVuZ3RoKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY3VyVW5pdCA9IGN1clVuaXRzW3VuaXRJbmRleF07XG5cbiAgICAgICAgaWYgKGN1clVuaXQuZGF0YS5sZW5ndGggPD0gNDggfHwgY3VyVW5pdC50eXBlICE9PSAxICYmIGN1clVuaXQudHlwZSAhPT0gNSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHN5bmMgPSB0aGlzLmRlY3J5cHRlci5pc1N5bmMoKTtcbiAgICAgICAgdGhpcy5kZWNyeXB0QXZjU2FtcGxlKHNhbXBsZXMsIHNhbXBsZUluZGV4LCB1bml0SW5kZXgsIGNhbGxiYWNrLCBjdXJVbml0LCBzeW5jKTtcblxuICAgICAgICBpZiAoIXN5bmMpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIFNhbXBsZUFlc0RlY3J5cHRlcjtcbn0oKTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChTYW1wbGVBZXNEZWNyeXB0ZXIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9kZW11eC90cmFuc211eGVyLWludGVyZmFjZS50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9kZW11eC90cmFuc211eGVyLWludGVyZmFjZS50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImRlZmF1bHRcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBUcmFuc211eGVySW50ZXJmYWNlOyB9KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciB3ZWJ3b3JraWZ5X3dlYnBhY2tfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIHdlYndvcmtpZnktd2VicGFjayAqLyBcIi4vbm9kZV9tb2R1bGVzL3dlYndvcmtpZnktd2VicGFjay9pbmRleC5qc1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciB3ZWJ3b3JraWZ5X3dlYnBhY2tfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubih3ZWJ3b3JraWZ5X3dlYnBhY2tfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZXZlbnRzICovIFwiLi9zcmMvZXZlbnRzLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9kZW11eF90cmFuc211eGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9kZW11eC90cmFuc211eGVyICovIFwiLi9zcmMvZGVtdXgvdHJhbnNtdXhlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9sb2dnZXIgKi8gXCIuL3NyYy91dGlscy9sb2dnZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZXJyb3JzICovIFwiLi9zcmMvZXJyb3JzLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19tZWRpYXNvdXJjZV9oZWxwZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL21lZGlhc291cmNlLWhlbHBlciAqLyBcIi4vc3JjL3V0aWxzL21lZGlhc291cmNlLWhlbHBlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBldmVudGVtaXR0ZXIzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBldmVudGVtaXR0ZXIzICovIFwiLi9ub2RlX21vZHVsZXMvZXZlbnRlbWl0dGVyMy9pbmRleC5qc1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBldmVudGVtaXR0ZXIzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oZXZlbnRlbWl0dGVyM19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fKTtcblxuXG5cblxuXG5cblxudmFyIE1lZGlhU291cmNlID0gT2JqZWN0KF91dGlsc19tZWRpYXNvdXJjZV9oZWxwZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcImdldE1lZGlhU291cmNlXCJdKSgpIHx8IHtcbiAgaXNUeXBlU3VwcG9ydGVkOiBmdW5jdGlvbiBpc1R5cGVTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG52YXIgVHJhbnNtdXhlckludGVyZmFjZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFRyYW5zbXV4ZXJJbnRlcmZhY2UoaGxzLCBpZCwgb25UcmFuc211eENvbXBsZXRlLCBvbkZsdXNoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHRoaXMuaGxzID0gdm9pZCAwO1xuICAgIHRoaXMuaWQgPSB2b2lkIDA7XG4gICAgdGhpcy5vYnNlcnZlciA9IHZvaWQgMDtcbiAgICB0aGlzLmZyYWcgPSBudWxsO1xuICAgIHRoaXMucGFydCA9IG51bGw7XG4gICAgdGhpcy53b3JrZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5vbndtc2cgPSB2b2lkIDA7XG4gICAgdGhpcy50cmFuc211eGVyID0gbnVsbDtcbiAgICB0aGlzLm9uVHJhbnNtdXhDb21wbGV0ZSA9IHZvaWQgMDtcbiAgICB0aGlzLm9uRmx1c2ggPSB2b2lkIDA7XG4gICAgdGhpcy5obHMgPSBobHM7XG4gICAgdGhpcy5pZCA9IGlkO1xuICAgIHRoaXMub25UcmFuc211eENvbXBsZXRlID0gb25UcmFuc211eENvbXBsZXRlO1xuICAgIHRoaXMub25GbHVzaCA9IG9uRmx1c2g7XG4gICAgdmFyIGNvbmZpZyA9IGhscy5jb25maWc7XG5cbiAgICB2YXIgZm9yd2FyZE1lc3NhZ2UgPSBmdW5jdGlvbiBmb3J3YXJkTWVzc2FnZShldiwgZGF0YSkge1xuICAgICAgZGF0YSA9IGRhdGEgfHwge307XG4gICAgICBkYXRhLmZyYWcgPSBfdGhpcy5mcmFnO1xuICAgICAgZGF0YS5pZCA9IF90aGlzLmlkO1xuICAgICAgaGxzLnRyaWdnZXIoZXYsIGRhdGEpO1xuICAgIH07IC8vIGZvcndhcmQgZXZlbnRzIHRvIG1haW4gdGhyZWFkXG5cblxuICAgIHRoaXMub2JzZXJ2ZXIgPSBuZXcgZXZlbnRlbWl0dGVyM19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fW1wiRXZlbnRFbWl0dGVyXCJdKCk7XG4gICAgdGhpcy5vYnNlcnZlci5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFdmVudHNcIl0uRlJBR19ERUNSWVBURUQsIGZvcndhcmRNZXNzYWdlKTtcbiAgICB0aGlzLm9ic2VydmVyLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkV2ZW50c1wiXS5FUlJPUiwgZm9yd2FyZE1lc3NhZ2UpO1xuICAgIHZhciB0eXBlU3VwcG9ydGVkID0ge1xuICAgICAgbXA0OiBNZWRpYVNvdXJjZS5pc1R5cGVTdXBwb3J0ZWQoJ3ZpZGVvL21wNCcpLFxuICAgICAgbXBlZzogTWVkaWFTb3VyY2UuaXNUeXBlU3VwcG9ydGVkKCdhdWRpby9tcGVnJyksXG4gICAgICBtcDM6IE1lZGlhU291cmNlLmlzVHlwZVN1cHBvcnRlZCgnYXVkaW8vbXA0OyBjb2RlY3M9XCJtcDNcIicpXG4gICAgfTsgLy8gbmF2aWdhdG9yLnZlbmRvciBpcyBub3QgYWx3YXlzIGF2YWlsYWJsZSBpbiBXZWIgV29ya2VyXG4gICAgLy8gcmVmZXIgdG8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dvcmtlckdsb2JhbFNjb3BlL25hdmlnYXRvclxuXG4gICAgdmFyIHZlbmRvciA9IG5hdmlnYXRvci52ZW5kb3I7XG5cbiAgICBpZiAoY29uZmlnLmVuYWJsZVdvcmtlciAmJiB0eXBlb2YgV29ya2VyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wibG9nZ2VyXCJdLmxvZygnZGVtdXhpbmcgaW4gd2Vid29ya2VyJyk7XG4gICAgICB2YXIgd29ya2VyO1xuXG4gICAgICB0cnkge1xuICAgICAgICB3b3JrZXIgPSB0aGlzLndvcmtlciA9IHdlYndvcmtpZnlfd2VicGFja19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fKC8qcmVxdWlyZS5yZXNvbHZlKi8oLyohIC4uL2RlbXV4L3RyYW5zbXV4ZXItd29ya2VyLnRzICovIFwiLi9zcmMvZGVtdXgvdHJhbnNtdXhlci13b3JrZXIudHNcIikpO1xuICAgICAgICB0aGlzLm9ud21zZyA9IHRoaXMub25Xb3JrZXJNZXNzYWdlLmJpbmQodGhpcyk7XG4gICAgICAgIHdvcmtlci5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgdGhpcy5vbndtc2cpO1xuXG4gICAgICAgIHdvcmtlci5vbmVycm9yID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXZlbnRzXCJdLkVSUk9SLCB7XG4gICAgICAgICAgICB0eXBlOiBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXCJFcnJvclR5cGVzXCJdLk9USEVSX0VSUk9SLFxuICAgICAgICAgICAgZGV0YWlsczogX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fW1wiRXJyb3JEZXRhaWxzXCJdLklOVEVSTkFMX0VYQ0VQVElPTixcbiAgICAgICAgICAgIGZhdGFsOiB0cnVlLFxuICAgICAgICAgICAgZXZlbnQ6ICdkZW11eGVyV29ya2VyJyxcbiAgICAgICAgICAgIGVycm9yOiBuZXcgRXJyb3IoZXZlbnQubWVzc2FnZSArIFwiICAoXCIgKyBldmVudC5maWxlbmFtZSArIFwiOlwiICsgZXZlbnQubGluZW5vICsgXCIpXCIpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgd29ya2VyLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICBjbWQ6ICdpbml0JyxcbiAgICAgICAgICB0eXBlU3VwcG9ydGVkOiB0eXBlU3VwcG9ydGVkLFxuICAgICAgICAgIHZlbmRvcjogdmVuZG9yLFxuICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICBjb25maWc6IEpTT04uc3RyaW5naWZ5KGNvbmZpZylcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wibG9nZ2VyXCJdLndhcm4oJ0Vycm9yIGluIHdvcmtlcjonLCBlcnIpO1xuICAgICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJsb2dnZXJcIl0uZXJyb3IoJ0Vycm9yIHdoaWxlIGluaXRpYWxpemluZyBEZW11eGVyV29ya2VyLCBmYWxsYmFjayB0byBpbmxpbmUnKTtcblxuICAgICAgICBpZiAod29ya2VyKSB7XG4gICAgICAgICAgLy8gcmV2b2tlIHRoZSBPYmplY3QgVVJMIHRoYXQgd2FzIHVzZWQgdG8gY3JlYXRlIHRyYW5zbXV4ZXIgd29ya2VyLCBzbyBhcyBub3QgdG8gbGVhayBpdFxuICAgICAgICAgIHNlbGYuVVJMLnJldm9rZU9iamVjdFVSTCh3b3JrZXIub2JqZWN0VVJMKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudHJhbnNtdXhlciA9IG5ldyBfZGVtdXhfdHJhbnNtdXhlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiZGVmYXVsdFwiXSh0aGlzLm9ic2VydmVyLCB0eXBlU3VwcG9ydGVkLCBjb25maWcsIHZlbmRvciwgaWQpO1xuICAgICAgICB0aGlzLndvcmtlciA9IG51bGw7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudHJhbnNtdXhlciA9IG5ldyBfZGVtdXhfdHJhbnNtdXhlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiZGVmYXVsdFwiXSh0aGlzLm9ic2VydmVyLCB0eXBlU3VwcG9ydGVkLCBjb25maWcsIHZlbmRvciwgaWQpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBUcmFuc211eGVySW50ZXJmYWNlLnByb3RvdHlwZTtcblxuICBfcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgdmFyIHcgPSB0aGlzLndvcmtlcjtcblxuICAgIGlmICh3KSB7XG4gICAgICB3LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCB0aGlzLm9ud21zZyk7XG4gICAgICB3LnRlcm1pbmF0ZSgpO1xuICAgICAgdGhpcy53b3JrZXIgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgdHJhbnNtdXhlciA9IHRoaXMudHJhbnNtdXhlcjtcblxuICAgICAgaWYgKHRyYW5zbXV4ZXIpIHtcbiAgICAgICAgdHJhbnNtdXhlci5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMudHJhbnNtdXhlciA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIG9ic2VydmVyID0gdGhpcy5vYnNlcnZlcjtcblxuICAgIGlmIChvYnNlcnZlcikge1xuICAgICAgb2JzZXJ2ZXIucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgfSAvLyBAdHMtaWdub3JlXG5cblxuICAgIHRoaXMub2JzZXJ2ZXIgPSBudWxsO1xuICB9O1xuXG4gIF9wcm90by5wdXNoID0gZnVuY3Rpb24gcHVzaChkYXRhLCBpbml0U2VnbWVudERhdGEsIGF1ZGlvQ29kZWMsIHZpZGVvQ29kZWMsIGZyYWcsIHBhcnQsIGR1cmF0aW9uLCBhY2N1cmF0ZVRpbWVPZmZzZXQsIGNodW5rTWV0YSwgZGVmYXVsdEluaXRQVFMpIHtcbiAgICB2YXIgX2ZyYWckaW5pdFNlZ21lbnQsXG4gICAgICAgIF9sYXN0RnJhZyRpbml0U2VnbWVudCxcbiAgICAgICAgX3RoaXMyID0gdGhpcztcblxuICAgIGNodW5rTWV0YS50cmFuc211eGluZy5zdGFydCA9IHNlbGYucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgdmFyIHRyYW5zbXV4ZXIgPSB0aGlzLnRyYW5zbXV4ZXIsXG4gICAgICAgIHdvcmtlciA9IHRoaXMud29ya2VyO1xuICAgIHZhciB0aW1lT2Zmc2V0ID0gcGFydCA/IHBhcnQuc3RhcnQgOiBmcmFnLnN0YXJ0O1xuICAgIHZhciBkZWNyeXB0ZGF0YSA9IGZyYWcuZGVjcnlwdGRhdGE7XG4gICAgdmFyIGxhc3RGcmFnID0gdGhpcy5mcmFnO1xuICAgIHZhciBkaXNjb250aW51aXR5ID0gIShsYXN0RnJhZyAmJiBmcmFnLmNjID09PSBsYXN0RnJhZy5jYyk7XG4gICAgdmFyIHRyYWNrU3dpdGNoID0gIShsYXN0RnJhZyAmJiBjaHVua01ldGEubGV2ZWwgPT09IGxhc3RGcmFnLmxldmVsKTtcbiAgICB2YXIgc25EaWZmID0gbGFzdEZyYWcgPyBjaHVua01ldGEuc24gLSBsYXN0RnJhZy5zbiA6IC0xO1xuICAgIHZhciBwYXJ0RGlmZiA9IHRoaXMucGFydCA/IGNodW5rTWV0YS5wYXJ0IC0gdGhpcy5wYXJ0LmluZGV4IDogMTtcbiAgICB2YXIgY29udGlndW91cyA9ICF0cmFja1N3aXRjaCAmJiAoc25EaWZmID09PSAxIHx8IHNuRGlmZiA9PT0gMCAmJiBwYXJ0RGlmZiA9PT0gMSk7XG4gICAgdmFyIG5vdyA9IHNlbGYucGVyZm9ybWFuY2Uubm93KCk7XG5cbiAgICBpZiAodHJhY2tTd2l0Y2ggfHwgc25EaWZmIHx8IGZyYWcuc3RhdHMucGFyc2luZy5zdGFydCA9PT0gMCkge1xuICAgICAgZnJhZy5zdGF0cy5wYXJzaW5nLnN0YXJ0ID0gbm93O1xuICAgIH1cblxuICAgIGlmIChwYXJ0ICYmIChwYXJ0RGlmZiB8fCAhY29udGlndW91cykpIHtcbiAgICAgIHBhcnQuc3RhdHMucGFyc2luZy5zdGFydCA9IG5vdztcbiAgICB9XG5cbiAgICB2YXIgaW5pdFNlZ21lbnRDaGFuZ2UgPSAhKGxhc3RGcmFnICYmICgoX2ZyYWckaW5pdFNlZ21lbnQgPSBmcmFnLmluaXRTZWdtZW50KSA9PT0gbnVsbCB8fCBfZnJhZyRpbml0U2VnbWVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2ZyYWckaW5pdFNlZ21lbnQudXJsKSA9PT0gKChfbGFzdEZyYWckaW5pdFNlZ21lbnQgPSBsYXN0RnJhZy5pbml0U2VnbWVudCkgPT09IG51bGwgfHwgX2xhc3RGcmFnJGluaXRTZWdtZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfbGFzdEZyYWckaW5pdFNlZ21lbnQudXJsKSk7XG4gICAgdmFyIHN0YXRlID0gbmV3IF9kZW11eF90cmFuc211eGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJUcmFuc211eFN0YXRlXCJdKGRpc2NvbnRpbnVpdHksIGNvbnRpZ3VvdXMsIGFjY3VyYXRlVGltZU9mZnNldCwgdHJhY2tTd2l0Y2gsIHRpbWVPZmZzZXQsIGluaXRTZWdtZW50Q2hhbmdlKTtcblxuICAgIGlmICghY29udGlndW91cyB8fCBkaXNjb250aW51aXR5IHx8IGluaXRTZWdtZW50Q2hhbmdlKSB7XG4gICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJsb2dnZXJcIl0ubG9nKFwiW3RyYW5zbXV4ZXItaW50ZXJmYWNlLCBcIiArIGZyYWcudHlwZSArIFwiXTogU3RhcnRpbmcgbmV3IHRyYW5zbXV4IHNlc3Npb24gZm9yIHNuOiBcIiArIGNodW5rTWV0YS5zbiArIFwiIHA6IFwiICsgY2h1bmtNZXRhLnBhcnQgKyBcIiBsZXZlbDogXCIgKyBjaHVua01ldGEubGV2ZWwgKyBcIiBpZDogXCIgKyBjaHVua01ldGEuaWQgKyBcIlxcbiAgICAgICAgZGlzY29udGludWl0eTogXCIgKyBkaXNjb250aW51aXR5ICsgXCJcXG4gICAgICAgIHRyYWNrU3dpdGNoOiBcIiArIHRyYWNrU3dpdGNoICsgXCJcXG4gICAgICAgIGNvbnRpZ3VvdXM6IFwiICsgY29udGlndW91cyArIFwiXFxuICAgICAgICBhY2N1cmF0ZVRpbWVPZmZzZXQ6IFwiICsgYWNjdXJhdGVUaW1lT2Zmc2V0ICsgXCJcXG4gICAgICAgIHRpbWVPZmZzZXQ6IFwiICsgdGltZU9mZnNldCArIFwiXFxuICAgICAgICBpbml0U2VnbWVudENoYW5nZTogXCIgKyBpbml0U2VnbWVudENoYW5nZSk7XG4gICAgICB2YXIgY29uZmlnID0gbmV3IF9kZW11eF90cmFuc211eGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJUcmFuc211eENvbmZpZ1wiXShhdWRpb0NvZGVjLCB2aWRlb0NvZGVjLCBpbml0U2VnbWVudERhdGEsIGR1cmF0aW9uLCBkZWZhdWx0SW5pdFBUUyk7XG4gICAgICB0aGlzLmNvbmZpZ3VyZVRyYW5zbXV4ZXIoY29uZmlnKTtcbiAgICB9XG5cbiAgICB0aGlzLmZyYWcgPSBmcmFnO1xuICAgIHRoaXMucGFydCA9IHBhcnQ7IC8vIEZyYWdzIHdpdGggc24gb2YgJ2luaXRTZWdtZW50JyBhcmUgbm90IHRyYW5zbXV4ZWRcblxuICAgIGlmICh3b3JrZXIpIHtcbiAgICAgIC8vIHBvc3QgZnJhZ21lbnQgcGF5bG9hZCBhcyB0cmFuc2ZlcmFibGUgb2JqZWN0cyBmb3IgQXJyYXlCdWZmZXIgKG5vIGNvcHkpXG4gICAgICB3b3JrZXIucG9zdE1lc3NhZ2Uoe1xuICAgICAgICBjbWQ6ICdkZW11eCcsXG4gICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgIGRlY3J5cHRkYXRhOiBkZWNyeXB0ZGF0YSxcbiAgICAgICAgY2h1bmtNZXRhOiBjaHVua01ldGEsXG4gICAgICAgIHN0YXRlOiBzdGF0ZVxuICAgICAgfSwgZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyID8gW2RhdGFdIDogW10pO1xuICAgIH0gZWxzZSBpZiAodHJhbnNtdXhlcikge1xuICAgICAgdmFyIF90cmFuc211eFJlc3VsdCA9IHRyYW5zbXV4ZXIucHVzaChkYXRhLCBkZWNyeXB0ZGF0YSwgY2h1bmtNZXRhLCBzdGF0ZSk7XG5cbiAgICAgIGlmIChPYmplY3QoX2RlbXV4X3RyYW5zbXV4ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImlzUHJvbWlzZVwiXSkoX3RyYW5zbXV4UmVzdWx0KSkge1xuICAgICAgICBfdHJhbnNtdXhSZXN1bHQudGhlbihmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgIF90aGlzMi5oYW5kbGVUcmFuc211eENvbXBsZXRlKGRhdGEpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaGFuZGxlVHJhbnNtdXhDb21wbGV0ZShfdHJhbnNtdXhSZXN1bHQpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uZmx1c2ggPSBmdW5jdGlvbiBmbHVzaChjaHVua01ldGEpIHtcbiAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgIGNodW5rTWV0YS50cmFuc211eGluZy5zdGFydCA9IHNlbGYucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgdmFyIHRyYW5zbXV4ZXIgPSB0aGlzLnRyYW5zbXV4ZXIsXG4gICAgICAgIHdvcmtlciA9IHRoaXMud29ya2VyO1xuXG4gICAgaWYgKHdvcmtlcikge1xuICAgICAgd29ya2VyLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgY21kOiAnZmx1c2gnLFxuICAgICAgICBjaHVua01ldGE6IGNodW5rTWV0YVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICh0cmFuc211eGVyKSB7XG4gICAgICB2YXIgX3RyYW5zbXV4UmVzdWx0MiA9IHRyYW5zbXV4ZXIuZmx1c2goY2h1bmtNZXRhKTtcblxuICAgICAgaWYgKE9iamVjdChfZGVtdXhfdHJhbnNtdXhlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiaXNQcm9taXNlXCJdKShfdHJhbnNtdXhSZXN1bHQyKSkge1xuICAgICAgICBfdHJhbnNtdXhSZXN1bHQyLnRoZW4oZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICBfdGhpczMuaGFuZGxlRmx1c2hSZXN1bHQoZGF0YSwgY2h1bmtNZXRhKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmhhbmRsZUZsdXNoUmVzdWx0KF90cmFuc211eFJlc3VsdDIsIGNodW5rTWV0YSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5oYW5kbGVGbHVzaFJlc3VsdCA9IGZ1bmN0aW9uIGhhbmRsZUZsdXNoUmVzdWx0KHJlc3VsdHMsIGNodW5rTWV0YSkge1xuICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgcmVzdWx0cy5mb3JFYWNoKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgIF90aGlzNC5oYW5kbGVUcmFuc211eENvbXBsZXRlKHJlc3VsdCk7XG4gICAgfSk7XG4gICAgdGhpcy5vbkZsdXNoKGNodW5rTWV0YSk7XG4gIH07XG5cbiAgX3Byb3RvLm9uV29ya2VyTWVzc2FnZSA9IGZ1bmN0aW9uIG9uV29ya2VyTWVzc2FnZShldikge1xuICAgIHZhciBkYXRhID0gZXYuZGF0YTtcbiAgICB2YXIgaGxzID0gdGhpcy5obHM7XG5cbiAgICBzd2l0Y2ggKGRhdGEuZXZlbnQpIHtcbiAgICAgIGNhc2UgJ2luaXQnOlxuICAgICAgICB7XG4gICAgICAgICAgLy8gcmV2b2tlIHRoZSBPYmplY3QgVVJMIHRoYXQgd2FzIHVzZWQgdG8gY3JlYXRlIHRyYW5zbXV4ZXIgd29ya2VyLCBzbyBhcyBub3QgdG8gbGVhayBpdFxuICAgICAgICAgIHNlbGYuVVJMLnJldm9rZU9iamVjdFVSTCh0aGlzLndvcmtlci5vYmplY3RVUkwpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ3RyYW5zbXV4Q29tcGxldGUnOlxuICAgICAgICB7XG4gICAgICAgICAgdGhpcy5oYW5kbGVUcmFuc211eENvbXBsZXRlKGRhdGEuZGF0YSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAnZmx1c2gnOlxuICAgICAgICB7XG4gICAgICAgICAgdGhpcy5vbkZsdXNoKGRhdGEuZGF0YSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB7XG4gICAgICAgICAgZGF0YS5kYXRhID0gZGF0YS5kYXRhIHx8IHt9O1xuICAgICAgICAgIGRhdGEuZGF0YS5mcmFnID0gdGhpcy5mcmFnO1xuICAgICAgICAgIGRhdGEuZGF0YS5pZCA9IHRoaXMuaWQ7XG4gICAgICAgICAgaGxzLnRyaWdnZXIoZGF0YS5ldmVudCwgZGF0YS5kYXRhKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uY29uZmlndXJlVHJhbnNtdXhlciA9IGZ1bmN0aW9uIGNvbmZpZ3VyZVRyYW5zbXV4ZXIoY29uZmlnKSB7XG4gICAgdmFyIHdvcmtlciA9IHRoaXMud29ya2VyLFxuICAgICAgICB0cmFuc211eGVyID0gdGhpcy50cmFuc211eGVyO1xuXG4gICAgaWYgKHdvcmtlcikge1xuICAgICAgd29ya2VyLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgY21kOiAnY29uZmlndXJlJyxcbiAgICAgICAgY29uZmlnOiBjb25maWdcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAodHJhbnNtdXhlcikge1xuICAgICAgdHJhbnNtdXhlci5jb25maWd1cmUoY29uZmlnKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmhhbmRsZVRyYW5zbXV4Q29tcGxldGUgPSBmdW5jdGlvbiBoYW5kbGVUcmFuc211eENvbXBsZXRlKHJlc3VsdCkge1xuICAgIHJlc3VsdC5jaHVua01ldGEudHJhbnNtdXhpbmcuZW5kID0gc2VsZi5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICB0aGlzLm9uVHJhbnNtdXhDb21wbGV0ZShyZXN1bHQpO1xuICB9O1xuXG4gIHJldHVybiBUcmFuc211eGVySW50ZXJmYWNlO1xufSgpO1xuXG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvZGVtdXgvdHJhbnNtdXhlci13b3JrZXIudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvZGVtdXgvdHJhbnNtdXhlci13b3JrZXIudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJkZWZhdWx0XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gVHJhbnNtdXhlcldvcmtlcjsgfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2RlbXV4X3RyYW5zbXV4ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2RlbXV4L3RyYW5zbXV4ZXIgKi8gXCIuL3NyYy9kZW11eC90cmFuc211eGVyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2V2ZW50cyAqLyBcIi4vc3JjL2V2ZW50cy50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9sb2dnZXIgKi8gXCIuL3NyYy91dGlscy9sb2dnZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgZXZlbnRlbWl0dGVyM19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgZXZlbnRlbWl0dGVyMyAqLyBcIi4vbm9kZV9tb2R1bGVzL2V2ZW50ZW1pdHRlcjMvaW5kZXguanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgZXZlbnRlbWl0dGVyM19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGV2ZW50ZW1pdHRlcjNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyk7XG5cblxuXG5cbmZ1bmN0aW9uIFRyYW5zbXV4ZXJXb3JrZXIoc2VsZikge1xuICB2YXIgb2JzZXJ2ZXIgPSBuZXcgZXZlbnRlbWl0dGVyM19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiRXZlbnRFbWl0dGVyXCJdKCk7XG5cbiAgdmFyIGZvcndhcmRNZXNzYWdlID0gZnVuY3Rpb24gZm9yd2FyZE1lc3NhZ2UoZXYsIGRhdGEpIHtcbiAgICBzZWxmLnBvc3RNZXNzYWdlKHtcbiAgICAgIGV2ZW50OiBldixcbiAgICAgIGRhdGE6IGRhdGFcbiAgICB9KTtcbiAgfTsgLy8gZm9yd2FyZCBldmVudHMgdG8gbWFpbiB0aHJlYWRcblxuXG4gIG9ic2VydmVyLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkV2ZW50c1wiXS5GUkFHX0RFQ1JZUFRFRCwgZm9yd2FyZE1lc3NhZ2UpO1xuICBvYnNlcnZlci5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFdmVudHNcIl0uRVJST1IsIGZvcndhcmRNZXNzYWdlKTtcbiAgc2VsZi5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgZnVuY3Rpb24gKGV2KSB7XG4gICAgdmFyIGRhdGEgPSBldi5kYXRhO1xuXG4gICAgc3dpdGNoIChkYXRhLmNtZCkge1xuICAgICAgY2FzZSAnaW5pdCc6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgY29uZmlnID0gSlNPTi5wYXJzZShkYXRhLmNvbmZpZyk7XG4gICAgICAgICAgc2VsZi50cmFuc211eGVyID0gbmV3IF9kZW11eF90cmFuc211eGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJkZWZhdWx0XCJdKG9ic2VydmVyLCBkYXRhLnR5cGVTdXBwb3J0ZWQsIGNvbmZpZywgZGF0YS52ZW5kb3IsIGRhdGEuaWQpO1xuICAgICAgICAgIE9iamVjdChfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJlbmFibGVMb2dzXCJdKShjb25maWcuZGVidWcpO1xuICAgICAgICAgIGZvcndhcmRNZXNzYWdlKCdpbml0JywgbnVsbCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAnY29uZmlndXJlJzpcbiAgICAgICAge1xuICAgICAgICAgIHNlbGYudHJhbnNtdXhlci5jb25maWd1cmUoZGF0YS5jb25maWcpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ2RlbXV4JzpcbiAgICAgICAge1xuICAgICAgICAgIHZhciB0cmFuc211eFJlc3VsdCA9IHNlbGYudHJhbnNtdXhlci5wdXNoKGRhdGEuZGF0YSwgZGF0YS5kZWNyeXB0ZGF0YSwgZGF0YS5jaHVua01ldGEsIGRhdGEuc3RhdGUpO1xuXG4gICAgICAgICAgaWYgKE9iamVjdChfZGVtdXhfdHJhbnNtdXhlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiaXNQcm9taXNlXCJdKSh0cmFuc211eFJlc3VsdCkpIHtcbiAgICAgICAgICAgIHRyYW5zbXV4UmVzdWx0LnRoZW4oZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgICAgZW1pdFRyYW5zbXV4Q29tcGxldGUoc2VsZiwgZGF0YSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZW1pdFRyYW5zbXV4Q29tcGxldGUoc2VsZiwgdHJhbnNtdXhSZXN1bHQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ2ZsdXNoJzpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBpZCA9IGRhdGEuY2h1bmtNZXRhO1xuXG4gICAgICAgICAgdmFyIF90cmFuc211eFJlc3VsdCA9IHNlbGYudHJhbnNtdXhlci5mbHVzaChpZCk7XG5cbiAgICAgICAgICBpZiAoT2JqZWN0KF9kZW11eF90cmFuc211eGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJpc1Byb21pc2VcIl0pKF90cmFuc211eFJlc3VsdCkpIHtcbiAgICAgICAgICAgIF90cmFuc211eFJlc3VsdC50aGVuKGZ1bmN0aW9uIChyZXN1bHRzKSB7XG4gICAgICAgICAgICAgIGhhbmRsZUZsdXNoUmVzdWx0KHNlbGYsIHJlc3VsdHMsIGlkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBoYW5kbGVGbHVzaFJlc3VsdChzZWxmLCBfdHJhbnNtdXhSZXN1bHQsIGlkKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBicmVhaztcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBlbWl0VHJhbnNtdXhDb21wbGV0ZShzZWxmLCB0cmFuc211eFJlc3VsdCkge1xuICBpZiAoaXNFbXB0eVJlc3VsdCh0cmFuc211eFJlc3VsdC5yZW11eFJlc3VsdCkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgdHJhbnNmZXJhYmxlID0gW107XG4gIHZhciBfdHJhbnNtdXhSZXN1bHQkcmVtdXggPSB0cmFuc211eFJlc3VsdC5yZW11eFJlc3VsdCxcbiAgICAgIGF1ZGlvID0gX3RyYW5zbXV4UmVzdWx0JHJlbXV4LmF1ZGlvLFxuICAgICAgdmlkZW8gPSBfdHJhbnNtdXhSZXN1bHQkcmVtdXgudmlkZW87XG5cbiAgaWYgKGF1ZGlvKSB7XG4gICAgYWRkVG9UcmFuc2ZlcmFibGUodHJhbnNmZXJhYmxlLCBhdWRpbyk7XG4gIH1cblxuICBpZiAodmlkZW8pIHtcbiAgICBhZGRUb1RyYW5zZmVyYWJsZSh0cmFuc2ZlcmFibGUsIHZpZGVvKTtcbiAgfVxuXG4gIHNlbGYucG9zdE1lc3NhZ2Uoe1xuICAgIGV2ZW50OiAndHJhbnNtdXhDb21wbGV0ZScsXG4gICAgZGF0YTogdHJhbnNtdXhSZXN1bHRcbiAgfSwgdHJhbnNmZXJhYmxlKTtcbn0gLy8gQ29udmVydHMgZGF0YSB0byBhIHRyYW5zZmVyYWJsZSBvYmplY3QgaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vd2ViL3VwZGF0ZXMvMjAxMS8xMi9UcmFuc2ZlcmFibGUtT2JqZWN0cy1MaWdodG5pbmctRmFzdClcbi8vIGluIG9yZGVyIHRvIG1pbmltaXplIG1lc3NhZ2UgcGFzc2luZyBvdmVyaGVhZFxuXG5cbmZ1bmN0aW9uIGFkZFRvVHJhbnNmZXJhYmxlKHRyYW5zZmVyYWJsZSwgdHJhY2spIHtcbiAgaWYgKHRyYWNrLmRhdGExKSB7XG4gICAgdHJhbnNmZXJhYmxlLnB1c2godHJhY2suZGF0YTEuYnVmZmVyKTtcbiAgfVxuXG4gIGlmICh0cmFjay5kYXRhMikge1xuICAgIHRyYW5zZmVyYWJsZS5wdXNoKHRyYWNrLmRhdGEyLmJ1ZmZlcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFuZGxlRmx1c2hSZXN1bHQoc2VsZiwgcmVzdWx0cywgY2h1bmtNZXRhKSB7XG4gIHJlc3VsdHMuZm9yRWFjaChmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgZW1pdFRyYW5zbXV4Q29tcGxldGUoc2VsZiwgcmVzdWx0KTtcbiAgfSk7XG4gIHNlbGYucG9zdE1lc3NhZ2Uoe1xuICAgIGV2ZW50OiAnZmx1c2gnLFxuICAgIGRhdGE6IGNodW5rTWV0YVxuICB9KTtcbn1cblxuZnVuY3Rpb24gaXNFbXB0eVJlc3VsdChyZW11eFJlc3VsdCkge1xuICByZXR1cm4gIXJlbXV4UmVzdWx0LmF1ZGlvICYmICFyZW11eFJlc3VsdC52aWRlbyAmJiAhcmVtdXhSZXN1bHQudGV4dCAmJiAhcmVtdXhSZXN1bHQuaWQzICYmICFyZW11eFJlc3VsdC5pbml0U2VnbWVudDtcbn1cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvZGVtdXgvdHJhbnNtdXhlci50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2RlbXV4L3RyYW5zbXV4ZXIudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0LCBpc1Byb21pc2UsIFRyYW5zbXV4Q29uZmlnLCBUcmFuc211eFN0YXRlICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImRlZmF1bHRcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBUcmFuc211eGVyOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJpc1Byb21pc2VcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBpc1Byb21pc2U7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlRyYW5zbXV4Q29uZmlnXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gVHJhbnNtdXhDb25maWc7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlRyYW5zbXV4U3RhdGVcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBUcmFuc211eFN0YXRlOyB9KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9ldmVudHMgKi8gXCIuL3NyYy9ldmVudHMudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZXJyb3JzICovIFwiLi9zcmMvZXJyb3JzLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9jcnlwdF9kZWNyeXB0ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2NyeXB0L2RlY3J5cHRlciAqLyBcIi4vc3JjL2NyeXB0L2RlY3J5cHRlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZGVtdXhfYWFjZGVtdXhlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZGVtdXgvYWFjZGVtdXhlciAqLyBcIi4vc3JjL2RlbXV4L2FhY2RlbXV4ZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2RlbXV4X21wNGRlbXV4ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2RlbXV4L21wNGRlbXV4ZXIgKi8gXCIuL3NyYy9kZW11eC9tcDRkZW11eGVyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9kZW11eF90c2RlbXV4ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2RlbXV4L3RzZGVtdXhlciAqLyBcIi4vc3JjL2RlbXV4L3RzZGVtdXhlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZGVtdXhfbXAzZGVtdXhlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZGVtdXgvbXAzZGVtdXhlciAqLyBcIi4vc3JjL2RlbXV4L21wM2RlbXV4ZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3JlbXV4X21wNF9yZW11eGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9yZW11eC9tcDQtcmVtdXhlciAqLyBcIi4vc3JjL3JlbXV4L21wNC1yZW11eGVyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9yZW11eF9wYXNzdGhyb3VnaF9yZW11eGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV84X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9yZW11eC9wYXNzdGhyb3VnaC1yZW11eGVyICovIFwiLi9zcmMvcmVtdXgvcGFzc3Rocm91Z2gtcmVtdXhlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfY2h1bmtfY2FjaGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzlfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vY2h1bmstY2FjaGUgKi8gXCIuL3NyYy9kZW11eC9jaHVuay1jYWNoZS50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfbXA0X3Rvb2xzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvbXA0LXRvb2xzICovIFwiLi9zcmMvdXRpbHMvbXA0LXRvb2xzLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzExX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9sb2dnZXIgKi8gXCIuL3NyYy91dGlscy9sb2dnZXIudHNcIik7XG5cblxuXG5cblxuXG5cblxuXG5cblxuXG52YXIgbm93OyAvLyBwZXJmb3JtYW5jZS5ub3coKSBub3QgYXZhaWxhYmxlIG9uIFdlYldvcmtlciwgYXQgbGVhc3Qgb24gU2FmYXJpIERlc2t0b3BcblxudHJ5IHtcbiAgbm93ID0gc2VsZi5wZXJmb3JtYW5jZS5ub3cuYmluZChzZWxmLnBlcmZvcm1hbmNlKTtcbn0gY2F0Y2ggKGVycikge1xuICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMV9fW1wibG9nZ2VyXCJdLmRlYnVnKCdVbmFibGUgdG8gdXNlIFBlcmZvcm1hbmNlIEFQSSBvbiB0aGlzIGVudmlyb25tZW50Jyk7XG4gIG5vdyA9IHNlbGYuRGF0ZS5ub3c7XG59XG5cbnZhciBtdXhDb25maWcgPSBbe1xuICBkZW11eDogX2RlbXV4X3RzZGVtdXhlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1wiZGVmYXVsdFwiXSxcbiAgcmVtdXg6IF9yZW11eF9tcDRfcmVtdXhlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fW1wiZGVmYXVsdFwiXVxufSwge1xuICBkZW11eDogX2RlbXV4X21wNGRlbXV4ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1tcImRlZmF1bHRcIl0sXG4gIHJlbXV4OiBfcmVtdXhfcGFzc3Rocm91Z2hfcmVtdXhlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOF9fW1wiZGVmYXVsdFwiXVxufSwge1xuICBkZW11eDogX2RlbXV4X2FhY2RlbXV4ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcImRlZmF1bHRcIl0sXG4gIHJlbXV4OiBfcmVtdXhfbXA0X3JlbXV4ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1tcImRlZmF1bHRcIl1cbn0sIHtcbiAgZGVtdXg6IF9kZW11eF9tcDNkZW11eGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXCJkZWZhdWx0XCJdLFxuICByZW11eDogX3JlbXV4X21wNF9yZW11eGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bXCJkZWZhdWx0XCJdXG59XTtcbnZhciBtaW5Qcm9iZUJ5dGVMZW5ndGggPSAxMDI0O1xubXV4Q29uZmlnLmZvckVhY2goZnVuY3Rpb24gKF9yZWYpIHtcbiAgdmFyIGRlbXV4ID0gX3JlZi5kZW11eDtcbiAgbWluUHJvYmVCeXRlTGVuZ3RoID0gTWF0aC5tYXgobWluUHJvYmVCeXRlTGVuZ3RoLCBkZW11eC5taW5Qcm9iZUJ5dGVMZW5ndGgpO1xufSk7XG5cbnZhciBUcmFuc211eGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gVHJhbnNtdXhlcihvYnNlcnZlciwgdHlwZVN1cHBvcnRlZCwgY29uZmlnLCB2ZW5kb3IsIGlkKSB7XG4gICAgdGhpcy5vYnNlcnZlciA9IHZvaWQgMDtcbiAgICB0aGlzLnR5cGVTdXBwb3J0ZWQgPSB2b2lkIDA7XG4gICAgdGhpcy5jb25maWcgPSB2b2lkIDA7XG4gICAgdGhpcy52ZW5kb3IgPSB2b2lkIDA7XG4gICAgdGhpcy5pZCA9IHZvaWQgMDtcbiAgICB0aGlzLmRlbXV4ZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5yZW11eGVyID0gdm9pZCAwO1xuICAgIHRoaXMuZGVjcnlwdGVyID0gdm9pZCAwO1xuICAgIHRoaXMucHJvYmUgPSB2b2lkIDA7XG4gICAgdGhpcy5kZWNyeXB0aW9uUHJvbWlzZSA9IG51bGw7XG4gICAgdGhpcy50cmFuc211eENvbmZpZyA9IHZvaWQgMDtcbiAgICB0aGlzLmN1cnJlbnRUcmFuc211eFN0YXRlID0gdm9pZCAwO1xuICAgIHRoaXMuY2FjaGUgPSBuZXcgX2NodW5rX2NhY2hlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV85X19bXCJkZWZhdWx0XCJdKCk7XG4gICAgdGhpcy5vYnNlcnZlciA9IG9ic2VydmVyO1xuICAgIHRoaXMudHlwZVN1cHBvcnRlZCA9IHR5cGVTdXBwb3J0ZWQ7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgdGhpcy52ZW5kb3IgPSB2ZW5kb3I7XG4gICAgdGhpcy5pZCA9IGlkO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFRyYW5zbXV4ZXIucHJvdG90eXBlO1xuXG4gIF9wcm90by5jb25maWd1cmUgPSBmdW5jdGlvbiBjb25maWd1cmUodHJhbnNtdXhDb25maWcpIHtcbiAgICB0aGlzLnRyYW5zbXV4Q29uZmlnID0gdHJhbnNtdXhDb25maWc7XG5cbiAgICBpZiAodGhpcy5kZWNyeXB0ZXIpIHtcbiAgICAgIHRoaXMuZGVjcnlwdGVyLnJlc2V0KCk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5wdXNoID0gZnVuY3Rpb24gcHVzaChkYXRhLCBkZWNyeXB0ZGF0YSwgY2h1bmtNZXRhLCBzdGF0ZSkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgc3RhdHMgPSBjaHVua01ldGEudHJhbnNtdXhpbmc7XG4gICAgc3RhdHMuZXhlY3V0ZVN0YXJ0ID0gbm93KCk7XG4gICAgdmFyIHVpbnREYXRhID0gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7XG4gICAgdmFyIGNhY2hlID0gdGhpcy5jYWNoZSxcbiAgICAgICAgY29uZmlnID0gdGhpcy5jb25maWcsXG4gICAgICAgIGN1cnJlbnRUcmFuc211eFN0YXRlID0gdGhpcy5jdXJyZW50VHJhbnNtdXhTdGF0ZSxcbiAgICAgICAgdHJhbnNtdXhDb25maWcgPSB0aGlzLnRyYW5zbXV4Q29uZmlnO1xuXG4gICAgaWYgKHN0YXRlKSB7XG4gICAgICB0aGlzLmN1cnJlbnRUcmFuc211eFN0YXRlID0gc3RhdGU7XG4gICAgfVxuXG4gICAgdmFyIGtleURhdGEgPSBnZXRFbmNyeXB0aW9uVHlwZSh1aW50RGF0YSwgZGVjcnlwdGRhdGEpO1xuXG4gICAgaWYgKGtleURhdGEgJiYga2V5RGF0YS5tZXRob2QgPT09ICdBRVMtMTI4Jykge1xuICAgICAgdmFyIGRlY3J5cHRlciA9IHRoaXMuZ2V0RGVjcnlwdGVyKCk7IC8vIFNvZnR3YXJlIGRlY3J5cHRpb24gaXMgc3luY2hyb25vdXM7IHdlYkNyeXB0byBpcyBub3RcblxuICAgICAgaWYgKGNvbmZpZy5lbmFibGVTb2Z0d2FyZUFFUykge1xuICAgICAgICAvLyBTb2Z0d2FyZSBkZWNyeXB0aW9uIGlzIHByb2dyZXNzaXZlLiBQcm9ncmVzc2l2ZSBkZWNyeXB0aW9uIG1heSBub3QgcmV0dXJuIGEgcmVzdWx0IG9uIGVhY2ggY2FsbC4gQW55IGNhY2hlZFxuICAgICAgICAvLyBkYXRhIGlzIGhhbmRsZWQgaW4gdGhlIGZsdXNoKCkgY2FsbFxuICAgICAgICB2YXIgZGVjcnlwdGVkRGF0YSA9IGRlY3J5cHRlci5zb2Z0d2FyZURlY3J5cHQodWludERhdGEsIGtleURhdGEua2V5LmJ1ZmZlciwga2V5RGF0YS5pdi5idWZmZXIpO1xuXG4gICAgICAgIGlmICghZGVjcnlwdGVkRGF0YSkge1xuICAgICAgICAgIHN0YXRzLmV4ZWN1dGVFbmQgPSBub3coKTtcbiAgICAgICAgICByZXR1cm4gZW1wdHlSZXN1bHQoY2h1bmtNZXRhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHVpbnREYXRhID0gbmV3IFVpbnQ4QXJyYXkoZGVjcnlwdGVkRGF0YSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmRlY3J5cHRpb25Qcm9taXNlID0gZGVjcnlwdGVyLndlYkNyeXB0b0RlY3J5cHQodWludERhdGEsIGtleURhdGEua2V5LmJ1ZmZlciwga2V5RGF0YS5pdi5idWZmZXIpLnRoZW4oZnVuY3Rpb24gKGRlY3J5cHRlZERhdGEpIHtcbiAgICAgICAgICAvLyBDYWxsaW5nIHB1c2ggaGVyZSBpcyBpbXBvcnRhbnQ7IGlmIGZsdXNoKCkgaXMgY2FsbGVkIHdoaWxlIHRoaXMgaXMgc3RpbGwgcmVzb2x2aW5nLCB0aGlzIGVuc3VyZXMgdGhhdFxuICAgICAgICAgIC8vIHRoZSBkZWNyeXB0ZWQgZGF0YSBoYXMgYmVlbiB0cmFuc211eGVkXG4gICAgICAgICAgdmFyIHJlc3VsdCA9IF90aGlzLnB1c2goZGVjcnlwdGVkRGF0YSwgbnVsbCwgY2h1bmtNZXRhKTtcblxuICAgICAgICAgIF90aGlzLmRlY3J5cHRpb25Qcm9taXNlID0gbnVsbDtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVjcnlwdGlvblByb21pc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIF9yZWYyID0gc3RhdGUgfHwgY3VycmVudFRyYW5zbXV4U3RhdGUsXG4gICAgICAgIGNvbnRpZ3VvdXMgPSBfcmVmMi5jb250aWd1b3VzLFxuICAgICAgICBkaXNjb250aW51aXR5ID0gX3JlZjIuZGlzY29udGludWl0eSxcbiAgICAgICAgdHJhY2tTd2l0Y2ggPSBfcmVmMi50cmFja1N3aXRjaCxcbiAgICAgICAgYWNjdXJhdGVUaW1lT2Zmc2V0ID0gX3JlZjIuYWNjdXJhdGVUaW1lT2Zmc2V0LFxuICAgICAgICB0aW1lT2Zmc2V0ID0gX3JlZjIudGltZU9mZnNldCxcbiAgICAgICAgaW5pdFNlZ21lbnRDaGFuZ2UgPSBfcmVmMi5pbml0U2VnbWVudENoYW5nZTtcblxuICAgIHZhciBhdWRpb0NvZGVjID0gdHJhbnNtdXhDb25maWcuYXVkaW9Db2RlYyxcbiAgICAgICAgdmlkZW9Db2RlYyA9IHRyYW5zbXV4Q29uZmlnLnZpZGVvQ29kZWMsXG4gICAgICAgIGRlZmF1bHRJbml0UHRzID0gdHJhbnNtdXhDb25maWcuZGVmYXVsdEluaXRQdHMsXG4gICAgICAgIGR1cmF0aW9uID0gdHJhbnNtdXhDb25maWcuZHVyYXRpb24sXG4gICAgICAgIGluaXRTZWdtZW50RGF0YSA9IHRyYW5zbXV4Q29uZmlnLmluaXRTZWdtZW50RGF0YTsgLy8gUmVzZXQgbXV4ZXJzIGJlZm9yZSBwcm9iaW5nIHRvIGVuc3VyZSB0aGF0IHRoZWlyIHN0YXRlIGlzIGNsZWFuLCBldmVuIGlmIGZsdXNoaW5nIG9jY3VycyBiZWZvcmUgYSBzdWNjZXNzZnVsIHByb2JlXG5cbiAgICBpZiAoZGlzY29udGludWl0eSB8fCB0cmFja1N3aXRjaCB8fCBpbml0U2VnbWVudENoYW5nZSkge1xuICAgICAgdGhpcy5yZXNldEluaXRTZWdtZW50KGluaXRTZWdtZW50RGF0YSwgYXVkaW9Db2RlYywgdmlkZW9Db2RlYywgZHVyYXRpb24pO1xuICAgIH1cblxuICAgIGlmIChkaXNjb250aW51aXR5IHx8IGluaXRTZWdtZW50Q2hhbmdlKSB7XG4gICAgICB0aGlzLnJlc2V0SW5pdGlhbFRpbWVzdGFtcChkZWZhdWx0SW5pdFB0cyk7XG4gICAgfVxuXG4gICAgaWYgKCFjb250aWd1b3VzKSB7XG4gICAgICB0aGlzLnJlc2V0Q29udGlndWl0eSgpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLm5lZWRzUHJvYmluZyh1aW50RGF0YSwgZGlzY29udGludWl0eSwgdHJhY2tTd2l0Y2gpKSB7XG4gICAgICBpZiAoY2FjaGUuZGF0YUxlbmd0aCkge1xuICAgICAgICB2YXIgY2FjaGVkRGF0YSA9IGNhY2hlLmZsdXNoKCk7XG4gICAgICAgIHVpbnREYXRhID0gT2JqZWN0KF91dGlsc19tcDRfdG9vbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEwX19bXCJhcHBlbmRVaW50OEFycmF5XCJdKShjYWNoZWREYXRhLCB1aW50RGF0YSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY29uZmlndXJlVHJhbnNtdXhlcih1aW50RGF0YSwgdHJhbnNtdXhDb25maWcpO1xuICAgIH1cblxuICAgIHZhciByZXN1bHQgPSB0aGlzLnRyYW5zbXV4KHVpbnREYXRhLCBrZXlEYXRhLCB0aW1lT2Zmc2V0LCBhY2N1cmF0ZVRpbWVPZmZzZXQsIGNodW5rTWV0YSk7XG4gICAgdmFyIGN1cnJlbnRTdGF0ZSA9IHRoaXMuY3VycmVudFRyYW5zbXV4U3RhdGU7XG4gICAgY3VycmVudFN0YXRlLmNvbnRpZ3VvdXMgPSB0cnVlO1xuICAgIGN1cnJlbnRTdGF0ZS5kaXNjb250aW51aXR5ID0gZmFsc2U7XG4gICAgY3VycmVudFN0YXRlLnRyYWNrU3dpdGNoID0gZmFsc2U7XG4gICAgc3RhdHMuZXhlY3V0ZUVuZCA9IG5vdygpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0gLy8gRHVlIHRvIGRhdGEgY2FjaGluZywgZmx1c2ggY2FsbHMgY2FuIHByb2R1Y2UgbW9yZSB0aGFuIG9uZSBUcmFuc211eGVyUmVzdWx0IChoZW5jZSB0aGUgQXJyYXkgdHlwZSlcbiAgO1xuXG4gIF9wcm90by5mbHVzaCA9IGZ1bmN0aW9uIGZsdXNoKGNodW5rTWV0YSkge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgdmFyIHN0YXRzID0gY2h1bmtNZXRhLnRyYW5zbXV4aW5nO1xuICAgIHN0YXRzLmV4ZWN1dGVTdGFydCA9IG5vdygpO1xuICAgIHZhciBkZWNyeXB0ZXIgPSB0aGlzLmRlY3J5cHRlcixcbiAgICAgICAgY2FjaGUgPSB0aGlzLmNhY2hlLFxuICAgICAgICBjdXJyZW50VHJhbnNtdXhTdGF0ZSA9IHRoaXMuY3VycmVudFRyYW5zbXV4U3RhdGUsXG4gICAgICAgIGRlY3J5cHRpb25Qcm9taXNlID0gdGhpcy5kZWNyeXB0aW9uUHJvbWlzZTtcblxuICAgIGlmIChkZWNyeXB0aW9uUHJvbWlzZSkge1xuICAgICAgLy8gVXBvbiByZXNvbHV0aW9uLCB0aGUgZGVjcnlwdGlvbiBwcm9taXNlIGNhbGxzIHB1c2goKSBhbmQgcmV0dXJucyBpdHMgVHJhbnNtdXhlclJlc3VsdCB1cCB0aGUgc3RhY2suIFRoZXJlZm9yZVxuICAgICAgLy8gb25seSBmbHVzaGluZyBpcyByZXF1aXJlZCBmb3IgYXN5bmMgZGVjcnlwdGlvblxuICAgICAgcmV0dXJuIGRlY3J5cHRpb25Qcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3RoaXMyLmZsdXNoKGNodW5rTWV0YSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB2YXIgdHJhbnNtdXhSZXN1bHRzID0gW107XG4gICAgdmFyIHRpbWVPZmZzZXQgPSBjdXJyZW50VHJhbnNtdXhTdGF0ZS50aW1lT2Zmc2V0O1xuXG4gICAgaWYgKGRlY3J5cHRlcikge1xuICAgICAgLy8gVGhlIGRlY3J5cHRlciBtYXkgaGF2ZSBkYXRhIGNhY2hlZCwgd2hpY2ggbmVlZHMgdG8gYmUgZGVtdXhlZC4gSW4gdGhpcyBjYXNlIHdlJ2xsIGhhdmUgdHdvIFRyYW5zbXV4UmVzdWx0c1xuICAgICAgLy8gVGhpcyBoYXBwZW5zIGluIHRoZSBjYXNlIHRoYXQgd2UgcmVjZWl2ZSBvbmx5IDEgcHVzaCBjYWxsIGZvciBhIHNlZ21lbnQgKGVpdGhlciBmb3Igbm9uLXByb2dyZXNzaXZlIGRvd25sb2FkcyxcbiAgICAgIC8vIG9yIGZvciBwcm9ncmVzc2l2ZSBkb3dubG9hZHMgd2l0aCBzbWFsbCBzZWdtZW50cylcbiAgICAgIHZhciBkZWNyeXB0ZWREYXRhID0gZGVjcnlwdGVyLmZsdXNoKCk7XG5cbiAgICAgIGlmIChkZWNyeXB0ZWREYXRhKSB7XG4gICAgICAgIC8vIFB1c2ggYWx3YXlzIHJldHVybnMgYSBUcmFuc211eGVyUmVzdWx0IGlmIGRlY3J5cHRkYXRhIGlzIG51bGxcbiAgICAgICAgdHJhbnNtdXhSZXN1bHRzLnB1c2godGhpcy5wdXNoKGRlY3J5cHRlZERhdGEsIG51bGwsIGNodW5rTWV0YSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBieXRlc1NlZW4gPSBjYWNoZS5kYXRhTGVuZ3RoO1xuICAgIGNhY2hlLnJlc2V0KCk7XG4gICAgdmFyIGRlbXV4ZXIgPSB0aGlzLmRlbXV4ZXIsXG4gICAgICAgIHJlbXV4ZXIgPSB0aGlzLnJlbXV4ZXI7XG5cbiAgICBpZiAoIWRlbXV4ZXIgfHwgIXJlbXV4ZXIpIHtcbiAgICAgIC8vIElmIHByb2JpbmcgZmFpbGVkLCBhbmQgZWFjaCBkZW11eGVyIHNhdyBlbm91Z2ggYnl0ZXMgdG8gYmUgYWJsZSB0byBwcm9iZSwgdGhlbiBIbHMuanMgaGFzIGJlZW4gZ2l2ZW4gY29udGVudCBpdHMgbm90IGFibGUgdG8gaGFuZGxlXG4gICAgICBpZiAoYnl0ZXNTZWVuID49IG1pblByb2JlQnl0ZUxlbmd0aCkge1xuICAgICAgICB0aGlzLm9ic2VydmVyLmVtaXQoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiRXZlbnRzXCJdLkVSUk9SLCBfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJFdmVudHNcIl0uRVJST1IsIHtcbiAgICAgICAgICB0eXBlOiBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFcnJvclR5cGVzXCJdLk1FRElBX0VSUk9SLFxuICAgICAgICAgIGRldGFpbHM6IF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkVycm9yRGV0YWlsc1wiXS5GUkFHX1BBUlNJTkdfRVJST1IsXG4gICAgICAgICAgZmF0YWw6IHRydWUsXG4gICAgICAgICAgcmVhc29uOiAnbm8gZGVtdXggbWF0Y2hpbmcgd2l0aCBjb250ZW50IGZvdW5kJ1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgc3RhdHMuZXhlY3V0ZUVuZCA9IG5vdygpO1xuICAgICAgcmV0dXJuIFtlbXB0eVJlc3VsdChjaHVua01ldGEpXTtcbiAgICB9XG5cbiAgICB2YXIgZGVtdXhSZXN1bHRPclByb21pc2UgPSBkZW11eGVyLmZsdXNoKHRpbWVPZmZzZXQpO1xuXG4gICAgaWYgKGlzUHJvbWlzZShkZW11eFJlc3VsdE9yUHJvbWlzZSkpIHtcbiAgICAgIC8vIERlY3J5cHQgZmluYWwgU0FNUExFLUFFUyBzYW1wbGVzXG4gICAgICByZXR1cm4gZGVtdXhSZXN1bHRPclByb21pc2UudGhlbihmdW5jdGlvbiAoZGVtdXhSZXN1bHQpIHtcbiAgICAgICAgX3RoaXMyLmZsdXNoUmVtdXgodHJhbnNtdXhSZXN1bHRzLCBkZW11eFJlc3VsdCwgY2h1bmtNZXRhKTtcblxuICAgICAgICByZXR1cm4gdHJhbnNtdXhSZXN1bHRzO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy5mbHVzaFJlbXV4KHRyYW5zbXV4UmVzdWx0cywgZGVtdXhSZXN1bHRPclByb21pc2UsIGNodW5rTWV0YSk7XG4gICAgcmV0dXJuIHRyYW5zbXV4UmVzdWx0cztcbiAgfTtcblxuICBfcHJvdG8uZmx1c2hSZW11eCA9IGZ1bmN0aW9uIGZsdXNoUmVtdXgodHJhbnNtdXhSZXN1bHRzLCBkZW11eFJlc3VsdCwgY2h1bmtNZXRhKSB7XG4gICAgdmFyIGF1ZGlvVHJhY2sgPSBkZW11eFJlc3VsdC5hdWRpb1RyYWNrLFxuICAgICAgICBhdmNUcmFjayA9IGRlbXV4UmVzdWx0LmF2Y1RyYWNrLFxuICAgICAgICBpZDNUcmFjayA9IGRlbXV4UmVzdWx0LmlkM1RyYWNrLFxuICAgICAgICB0ZXh0VHJhY2sgPSBkZW11eFJlc3VsdC50ZXh0VHJhY2s7XG4gICAgdmFyIF90aGlzJGN1cnJlbnRUcmFuc211eCA9IHRoaXMuY3VycmVudFRyYW5zbXV4U3RhdGUsXG4gICAgICAgIGFjY3VyYXRlVGltZU9mZnNldCA9IF90aGlzJGN1cnJlbnRUcmFuc211eC5hY2N1cmF0ZVRpbWVPZmZzZXQsXG4gICAgICAgIHRpbWVPZmZzZXQgPSBfdGhpcyRjdXJyZW50VHJhbnNtdXgudGltZU9mZnNldDtcbiAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMV9fW1wibG9nZ2VyXCJdLmxvZyhcIlt0cmFuc211eGVyLnRzXTogRmx1c2hlZCBmcmFnbWVudCBcIiArIGNodW5rTWV0YS5zbiArIChjaHVua01ldGEucGFydCA+IC0xID8gJyBwOiAnICsgY2h1bmtNZXRhLnBhcnQgOiAnJykgKyBcIiBvZiBsZXZlbCBcIiArIGNodW5rTWV0YS5sZXZlbCk7XG4gICAgdmFyIHJlbXV4UmVzdWx0ID0gdGhpcy5yZW11eGVyLnJlbXV4KGF1ZGlvVHJhY2ssIGF2Y1RyYWNrLCBpZDNUcmFjaywgdGV4dFRyYWNrLCB0aW1lT2Zmc2V0LCBhY2N1cmF0ZVRpbWVPZmZzZXQsIHRydWUsIHRoaXMuaWQpO1xuICAgIHRyYW5zbXV4UmVzdWx0cy5wdXNoKHtcbiAgICAgIHJlbXV4UmVzdWx0OiByZW11eFJlc3VsdCxcbiAgICAgIGNodW5rTWV0YTogY2h1bmtNZXRhXG4gICAgfSk7XG4gICAgY2h1bmtNZXRhLnRyYW5zbXV4aW5nLmV4ZWN1dGVFbmQgPSBub3coKTtcbiAgfTtcblxuICBfcHJvdG8ucmVzZXRJbml0aWFsVGltZXN0YW1wID0gZnVuY3Rpb24gcmVzZXRJbml0aWFsVGltZXN0YW1wKGRlZmF1bHRJbml0UHRzKSB7XG4gICAgdmFyIGRlbXV4ZXIgPSB0aGlzLmRlbXV4ZXIsXG4gICAgICAgIHJlbXV4ZXIgPSB0aGlzLnJlbXV4ZXI7XG5cbiAgICBpZiAoIWRlbXV4ZXIgfHwgIXJlbXV4ZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBkZW11eGVyLnJlc2V0VGltZVN0YW1wKGRlZmF1bHRJbml0UHRzKTtcbiAgICByZW11eGVyLnJlc2V0VGltZVN0YW1wKGRlZmF1bHRJbml0UHRzKTtcbiAgfTtcblxuICBfcHJvdG8ucmVzZXRDb250aWd1aXR5ID0gZnVuY3Rpb24gcmVzZXRDb250aWd1aXR5KCkge1xuICAgIHZhciBkZW11eGVyID0gdGhpcy5kZW11eGVyLFxuICAgICAgICByZW11eGVyID0gdGhpcy5yZW11eGVyO1xuXG4gICAgaWYgKCFkZW11eGVyIHx8ICFyZW11eGVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZGVtdXhlci5yZXNldENvbnRpZ3VpdHkoKTtcbiAgICByZW11eGVyLnJlc2V0TmV4dFRpbWVzdGFtcCgpO1xuICB9O1xuXG4gIF9wcm90by5yZXNldEluaXRTZWdtZW50ID0gZnVuY3Rpb24gcmVzZXRJbml0U2VnbWVudChpbml0U2VnbWVudERhdGEsIGF1ZGlvQ29kZWMsIHZpZGVvQ29kZWMsIGR1cmF0aW9uKSB7XG4gICAgdmFyIGRlbXV4ZXIgPSB0aGlzLmRlbXV4ZXIsXG4gICAgICAgIHJlbXV4ZXIgPSB0aGlzLnJlbXV4ZXI7XG5cbiAgICBpZiAoIWRlbXV4ZXIgfHwgIXJlbXV4ZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBkZW11eGVyLnJlc2V0SW5pdFNlZ21lbnQoYXVkaW9Db2RlYywgdmlkZW9Db2RlYywgZHVyYXRpb24pO1xuICAgIHJlbXV4ZXIucmVzZXRJbml0U2VnbWVudChpbml0U2VnbWVudERhdGEsIGF1ZGlvQ29kZWMsIHZpZGVvQ29kZWMpO1xuICB9O1xuXG4gIF9wcm90by5kZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICBpZiAodGhpcy5kZW11eGVyKSB7XG4gICAgICB0aGlzLmRlbXV4ZXIuZGVzdHJveSgpO1xuICAgICAgdGhpcy5kZW11eGVyID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnJlbXV4ZXIpIHtcbiAgICAgIHRoaXMucmVtdXhlci5kZXN0cm95KCk7XG4gICAgICB0aGlzLnJlbXV4ZXIgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by50cmFuc211eCA9IGZ1bmN0aW9uIHRyYW5zbXV4KGRhdGEsIGtleURhdGEsIHRpbWVPZmZzZXQsIGFjY3VyYXRlVGltZU9mZnNldCwgY2h1bmtNZXRhKSB7XG4gICAgdmFyIHJlc3VsdDtcblxuICAgIGlmIChrZXlEYXRhICYmIGtleURhdGEubWV0aG9kID09PSAnU0FNUExFLUFFUycpIHtcbiAgICAgIHJlc3VsdCA9IHRoaXMudHJhbnNtdXhTYW1wbGVBZXMoZGF0YSwga2V5RGF0YSwgdGltZU9mZnNldCwgYWNjdXJhdGVUaW1lT2Zmc2V0LCBjaHVua01ldGEpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgPSB0aGlzLnRyYW5zbXV4VW5lbmNyeXB0ZWQoZGF0YSwgdGltZU9mZnNldCwgYWNjdXJhdGVUaW1lT2Zmc2V0LCBjaHVua01ldGEpO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgX3Byb3RvLnRyYW5zbXV4VW5lbmNyeXB0ZWQgPSBmdW5jdGlvbiB0cmFuc211eFVuZW5jcnlwdGVkKGRhdGEsIHRpbWVPZmZzZXQsIGFjY3VyYXRlVGltZU9mZnNldCwgY2h1bmtNZXRhKSB7XG4gICAgdmFyIF9kZW11eCA9IHRoaXMuZGVtdXhlci5kZW11eChkYXRhLCB0aW1lT2Zmc2V0LCBmYWxzZSwgIXRoaXMuY29uZmlnLnByb2dyZXNzaXZlKSxcbiAgICAgICAgYXVkaW9UcmFjayA9IF9kZW11eC5hdWRpb1RyYWNrLFxuICAgICAgICBhdmNUcmFjayA9IF9kZW11eC5hdmNUcmFjayxcbiAgICAgICAgaWQzVHJhY2sgPSBfZGVtdXguaWQzVHJhY2ssXG4gICAgICAgIHRleHRUcmFjayA9IF9kZW11eC50ZXh0VHJhY2s7XG5cbiAgICB2YXIgcmVtdXhSZXN1bHQgPSB0aGlzLnJlbXV4ZXIucmVtdXgoYXVkaW9UcmFjaywgYXZjVHJhY2ssIGlkM1RyYWNrLCB0ZXh0VHJhY2ssIHRpbWVPZmZzZXQsIGFjY3VyYXRlVGltZU9mZnNldCwgZmFsc2UsIHRoaXMuaWQpO1xuICAgIHJldHVybiB7XG4gICAgICByZW11eFJlc3VsdDogcmVtdXhSZXN1bHQsXG4gICAgICBjaHVua01ldGE6IGNodW5rTWV0YVxuICAgIH07XG4gIH07XG5cbiAgX3Byb3RvLnRyYW5zbXV4U2FtcGxlQWVzID0gZnVuY3Rpb24gdHJhbnNtdXhTYW1wbGVBZXMoZGF0YSwgZGVjcnlwdERhdGEsIHRpbWVPZmZzZXQsIGFjY3VyYXRlVGltZU9mZnNldCwgY2h1bmtNZXRhKSB7XG4gICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICByZXR1cm4gdGhpcy5kZW11eGVyLmRlbXV4U2FtcGxlQWVzKGRhdGEsIGRlY3J5cHREYXRhLCB0aW1lT2Zmc2V0KS50aGVuKGZ1bmN0aW9uIChkZW11eFJlc3VsdCkge1xuICAgICAgdmFyIHJlbXV4UmVzdWx0ID0gX3RoaXMzLnJlbXV4ZXIucmVtdXgoZGVtdXhSZXN1bHQuYXVkaW9UcmFjaywgZGVtdXhSZXN1bHQuYXZjVHJhY2ssIGRlbXV4UmVzdWx0LmlkM1RyYWNrLCBkZW11eFJlc3VsdC50ZXh0VHJhY2ssIHRpbWVPZmZzZXQsIGFjY3VyYXRlVGltZU9mZnNldCwgZmFsc2UsIF90aGlzMy5pZCk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlbXV4UmVzdWx0OiByZW11eFJlc3VsdCxcbiAgICAgICAgY2h1bmtNZXRhOiBjaHVua01ldGFcbiAgICAgIH07XG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLmNvbmZpZ3VyZVRyYW5zbXV4ZXIgPSBmdW5jdGlvbiBjb25maWd1cmVUcmFuc211eGVyKGRhdGEsIHRyYW5zbXV4Q29uZmlnKSB7XG4gICAgdmFyIGNvbmZpZyA9IHRoaXMuY29uZmlnLFxuICAgICAgICBvYnNlcnZlciA9IHRoaXMub2JzZXJ2ZXIsXG4gICAgICAgIHR5cGVTdXBwb3J0ZWQgPSB0aGlzLnR5cGVTdXBwb3J0ZWQsXG4gICAgICAgIHZlbmRvciA9IHRoaXMudmVuZG9yO1xuICAgIHZhciBhdWRpb0NvZGVjID0gdHJhbnNtdXhDb25maWcuYXVkaW9Db2RlYyxcbiAgICAgICAgZGVmYXVsdEluaXRQdHMgPSB0cmFuc211eENvbmZpZy5kZWZhdWx0SW5pdFB0cyxcbiAgICAgICAgZHVyYXRpb24gPSB0cmFuc211eENvbmZpZy5kdXJhdGlvbixcbiAgICAgICAgaW5pdFNlZ21lbnREYXRhID0gdHJhbnNtdXhDb25maWcuaW5pdFNlZ21lbnREYXRhLFxuICAgICAgICB2aWRlb0NvZGVjID0gdHJhbnNtdXhDb25maWcudmlkZW9Db2RlYzsgLy8gcHJvYmUgZm9yIGNvbnRlbnQgdHlwZVxuXG4gICAgdmFyIG11eDtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBtdXhDb25maWcubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmIChtdXhDb25maWdbaV0uZGVtdXgucHJvYmUoZGF0YSkpIHtcbiAgICAgICAgbXV4ID0gbXV4Q29uZmlnW2ldO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIW11eCkge1xuICAgICAgLy8gSWYgcHJvYmluZyBwcmV2aW91cyBjb25maWdzIGZhaWwsIHVzZSBtcDQgcGFzc3Rocm91Z2hcbiAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzExX19bXCJsb2dnZXJcIl0ud2FybignRmFpbGVkIHRvIGZpbmQgZGVtdXhlciBieSBwcm9iaW5nIGZyYWcsIHRyZWF0aW5nIGFzIG1wNCBwYXNzdGhyb3VnaCcpO1xuICAgICAgbXV4ID0ge1xuICAgICAgICBkZW11eDogX2RlbXV4X21wNGRlbXV4ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1tcImRlZmF1bHRcIl0sXG4gICAgICAgIHJlbXV4OiBfcmVtdXhfcGFzc3Rocm91Z2hfcmVtdXhlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOF9fW1wiZGVmYXVsdFwiXVxuICAgICAgfTtcbiAgICB9IC8vIHNvIGxldCdzIGNoZWNrIHRoYXQgY3VycmVudCByZW11eGVyIGFuZCBkZW11eGVyIGFyZSBzdGlsbCB2YWxpZFxuXG5cbiAgICB2YXIgZGVtdXhlciA9IHRoaXMuZGVtdXhlcjtcbiAgICB2YXIgcmVtdXhlciA9IHRoaXMucmVtdXhlcjtcbiAgICB2YXIgUmVtdXhlciA9IG11eC5yZW11eDtcbiAgICB2YXIgRGVtdXhlciA9IG11eC5kZW11eDtcblxuICAgIGlmICghcmVtdXhlciB8fCAhKHJlbXV4ZXIgaW5zdGFuY2VvZiBSZW11eGVyKSkge1xuICAgICAgdGhpcy5yZW11eGVyID0gbmV3IFJlbXV4ZXIob2JzZXJ2ZXIsIGNvbmZpZywgdHlwZVN1cHBvcnRlZCwgdmVuZG9yKTtcbiAgICB9XG5cbiAgICBpZiAoIWRlbXV4ZXIgfHwgIShkZW11eGVyIGluc3RhbmNlb2YgRGVtdXhlcikpIHtcbiAgICAgIHRoaXMuZGVtdXhlciA9IG5ldyBEZW11eGVyKG9ic2VydmVyLCBjb25maWcsIHR5cGVTdXBwb3J0ZWQpO1xuICAgICAgdGhpcy5wcm9iZSA9IERlbXV4ZXIucHJvYmU7XG4gICAgfSAvLyBFbnN1cmUgdGhhdCBtdXhlcnMgYXJlIGFsd2F5cyBpbml0aWFsaXplZCB3aXRoIGFuIGluaXRTZWdtZW50XG5cblxuICAgIHRoaXMucmVzZXRJbml0U2VnbWVudChpbml0U2VnbWVudERhdGEsIGF1ZGlvQ29kZWMsIHZpZGVvQ29kZWMsIGR1cmF0aW9uKTtcbiAgICB0aGlzLnJlc2V0SW5pdGlhbFRpbWVzdGFtcChkZWZhdWx0SW5pdFB0cyk7XG4gIH07XG5cbiAgX3Byb3RvLm5lZWRzUHJvYmluZyA9IGZ1bmN0aW9uIG5lZWRzUHJvYmluZyhkYXRhLCBkaXNjb250aW51aXR5LCB0cmFja1N3aXRjaCkge1xuICAgIC8vIGluIGNhc2Ugb2YgY29udGludWl0eSBjaGFuZ2UsIG9yIHRyYWNrIHN3aXRjaFxuICAgIC8vIHdlIG1pZ2h0IHN3aXRjaCBmcm9tIGNvbnRlbnQgdHlwZSAoQUFDIGNvbnRhaW5lciB0byBUUyBjb250YWluZXIsIG9yIFRTIHRvIGZtcDQgZm9yIGV4YW1wbGUpXG4gICAgcmV0dXJuICF0aGlzLmRlbXV4ZXIgfHwgIXRoaXMucmVtdXhlciB8fCBkaXNjb250aW51aXR5IHx8IHRyYWNrU3dpdGNoO1xuICB9O1xuXG4gIF9wcm90by5nZXREZWNyeXB0ZXIgPSBmdW5jdGlvbiBnZXREZWNyeXB0ZXIoKSB7XG4gICAgdmFyIGRlY3J5cHRlciA9IHRoaXMuZGVjcnlwdGVyO1xuXG4gICAgaWYgKCFkZWNyeXB0ZXIpIHtcbiAgICAgIGRlY3J5cHRlciA9IHRoaXMuZGVjcnlwdGVyID0gbmV3IF9jcnlwdF9kZWNyeXB0ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImRlZmF1bHRcIl0odGhpcy5vYnNlcnZlciwgdGhpcy5jb25maWcpO1xuICAgIH1cblxuICAgIHJldHVybiBkZWNyeXB0ZXI7XG4gIH07XG5cbiAgcmV0dXJuIFRyYW5zbXV4ZXI7XG59KCk7XG5cblxuXG5mdW5jdGlvbiBnZXRFbmNyeXB0aW9uVHlwZShkYXRhLCBkZWNyeXB0RGF0YSkge1xuICB2YXIgZW5jcnlwdGlvblR5cGUgPSBudWxsO1xuXG4gIGlmIChkYXRhLmJ5dGVMZW5ndGggPiAwICYmIGRlY3J5cHREYXRhICE9IG51bGwgJiYgZGVjcnlwdERhdGEua2V5ICE9IG51bGwgJiYgZGVjcnlwdERhdGEuaXYgIT09IG51bGwgJiYgZGVjcnlwdERhdGEubWV0aG9kICE9IG51bGwpIHtcbiAgICBlbmNyeXB0aW9uVHlwZSA9IGRlY3J5cHREYXRhO1xuICB9XG5cbiAgcmV0dXJuIGVuY3J5cHRpb25UeXBlO1xufVxuXG52YXIgZW1wdHlSZXN1bHQgPSBmdW5jdGlvbiBlbXB0eVJlc3VsdChjaHVua01ldGEpIHtcbiAgcmV0dXJuIHtcbiAgICByZW11eFJlc3VsdDoge30sXG4gICAgY2h1bmtNZXRhOiBjaHVua01ldGFcbiAgfTtcbn07XG5cbmZ1bmN0aW9uIGlzUHJvbWlzZShwKSB7XG4gIHJldHVybiAndGhlbicgaW4gcCAmJiBwLnRoZW4gaW5zdGFuY2VvZiBGdW5jdGlvbjtcbn1cbnZhciBUcmFuc211eENvbmZpZyA9IGZ1bmN0aW9uIFRyYW5zbXV4Q29uZmlnKGF1ZGlvQ29kZWMsIHZpZGVvQ29kZWMsIGluaXRTZWdtZW50RGF0YSwgZHVyYXRpb24sIGRlZmF1bHRJbml0UHRzKSB7XG4gIHRoaXMuYXVkaW9Db2RlYyA9IHZvaWQgMDtcbiAgdGhpcy52aWRlb0NvZGVjID0gdm9pZCAwO1xuICB0aGlzLmluaXRTZWdtZW50RGF0YSA9IHZvaWQgMDtcbiAgdGhpcy5kdXJhdGlvbiA9IHZvaWQgMDtcbiAgdGhpcy5kZWZhdWx0SW5pdFB0cyA9IHZvaWQgMDtcbiAgdGhpcy5hdWRpb0NvZGVjID0gYXVkaW9Db2RlYztcbiAgdGhpcy52aWRlb0NvZGVjID0gdmlkZW9Db2RlYztcbiAgdGhpcy5pbml0U2VnbWVudERhdGEgPSBpbml0U2VnbWVudERhdGE7XG4gIHRoaXMuZHVyYXRpb24gPSBkdXJhdGlvbjtcbiAgdGhpcy5kZWZhdWx0SW5pdFB0cyA9IGRlZmF1bHRJbml0UHRzO1xufTtcbnZhciBUcmFuc211eFN0YXRlID0gZnVuY3Rpb24gVHJhbnNtdXhTdGF0ZShkaXNjb250aW51aXR5LCBjb250aWd1b3VzLCBhY2N1cmF0ZVRpbWVPZmZzZXQsIHRyYWNrU3dpdGNoLCB0aW1lT2Zmc2V0LCBpbml0U2VnbWVudENoYW5nZSkge1xuICB0aGlzLmRpc2NvbnRpbnVpdHkgPSB2b2lkIDA7XG4gIHRoaXMuY29udGlndW91cyA9IHZvaWQgMDtcbiAgdGhpcy5hY2N1cmF0ZVRpbWVPZmZzZXQgPSB2b2lkIDA7XG4gIHRoaXMudHJhY2tTd2l0Y2ggPSB2b2lkIDA7XG4gIHRoaXMudGltZU9mZnNldCA9IHZvaWQgMDtcbiAgdGhpcy5pbml0U2VnbWVudENoYW5nZSA9IHZvaWQgMDtcbiAgdGhpcy5kaXNjb250aW51aXR5ID0gZGlzY29udGludWl0eTtcbiAgdGhpcy5jb250aWd1b3VzID0gY29udGlndW91cztcbiAgdGhpcy5hY2N1cmF0ZVRpbWVPZmZzZXQgPSBhY2N1cmF0ZVRpbWVPZmZzZXQ7XG4gIHRoaXMudHJhY2tTd2l0Y2ggPSB0cmFja1N3aXRjaDtcbiAgdGhpcy50aW1lT2Zmc2V0ID0gdGltZU9mZnNldDtcbiAgdGhpcy5pbml0U2VnbWVudENoYW5nZSA9IGluaXRTZWdtZW50Q2hhbmdlO1xufTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvZGVtdXgvdHNkZW11eGVyLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9kZW11eC90c2RlbXV4ZXIudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRpc2NhcmRFUEIsIGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZGlzY2FyZEVQQlwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGRpc2NhcmRFUEI7IH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9hZHRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2FkdHMgKi8gXCIuL3NyYy9kZW11eC9hZHRzLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9tcGVnYXVkaW9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbXBlZ2F1ZGlvICovIFwiLi9zcmMvZGVtdXgvbXBlZ2F1ZGlvLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9leHBfZ29sb21iX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2V4cC1nb2xvbWIgKi8gXCIuL3NyYy9kZW11eC9leHAtZ29sb21iLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9pZDNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaWQzICovIFwiLi9zcmMvZGVtdXgvaWQzLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9zYW1wbGVfYWVzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3NhbXBsZS1hZXMgKi8gXCIuL3NyYy9kZW11eC9zYW1wbGUtYWVzLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2V2ZW50cyAqLyBcIi4vc3JjL2V2ZW50cy50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfbXA0X3Rvb2xzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9tcDQtdG9vbHMgKi8gXCIuL3NyYy91dGlscy9tcDQtdG9vbHMudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvbG9nZ2VyICovIFwiLi9zcmMvdXRpbHMvbG9nZ2VyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzhfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2Vycm9ycyAqLyBcIi4vc3JjL2Vycm9ycy50c1wiKTtcbi8qKlxuICogaGlnaGx5IG9wdGltaXplZCBUUyBkZW11eGVyOlxuICogcGFyc2UgUEFULCBQTVRcbiAqIGV4dHJhY3QgUEVTIHBhY2tldCBmcm9tIGF1ZGlvIGFuZCB2aWRlbyBQSURzXG4gKiBleHRyYWN0IEFWQy9IMjY0IE5BTCB1bml0cyBhbmQgQUFDL0FEVFMgc2FtcGxlcyBmcm9tIFBFUyBwYWNrZXRcbiAqIHRyaWdnZXIgdGhlIHJlbXV4ZXIgdXBvbiBwYXJzaW5nIGNvbXBsZXRpb25cbiAqIGl0IGFsc28gdHJpZXMgdG8gd29ya2Fyb3VuZCBhcyBiZXN0IGFzIGl0IGNhbiBhdWRpbyBjb2RlYyBzd2l0Y2ggKEhFLUFBQyB0byBBQUMgYW5kIHZpY2UgdmVyc2EpLCB3aXRob3V0IGhhdmluZyB0byByZXN0YXJ0IHRoZSBNZWRpYVNvdXJjZS5cbiAqIGl0IGFsc28gY29udHJvbHMgdGhlIHJlbXV4aW5nIHByb2Nlc3MgOlxuICogdXBvbiBkaXNjb250aW51aXR5IG9yIGxldmVsIHN3aXRjaCBkZXRlY3Rpb24sIGl0IHdpbGwgYWxzbyBub3RpZmllcyB0aGUgcmVtdXhlciBzbyB0aGF0IGl0IGNhbiByZXNldCBpdHMgc3RhdGUuXG4gKi9cblxuXG5cblxuXG5cblxuXG5cbi8vIFdlIGFyZSB1c2luZyBmaXhlZCB0cmFjayBJRHMgZm9yIGRyaXZpbmcgdGhlIE1QNCByZW11eGVyXG4vLyBpbnN0ZWFkIG9mIGZvbGxvd2luZyB0aGUgVFMgUElEcy5cbi8vIFRoZXJlIGlzIG5vIHJlYXNvbiBub3QgdG8gZG8gdGhpcyBhbmQgc29tZSBicm93c2Vycy9Tb3VyY2VCdWZmZXItZGVtdXhlcnNcbi8vIG1heSBub3QgbGlrZSBpZiB0aGVyZSBhcmUgVHJhY2tJRCBcInN3aXRjaGVzXCJcbi8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdmlkZW8tZGV2L2hscy5qcy9pc3N1ZXMvMTMzMVxuLy8gSGVyZSB3ZSBhcmUgbWFwcGluZyBvdXIgaW50ZXJuYWwgdHJhY2sgdHlwZXMgdG8gY29uc3RhbnQgTVA0IHRyYWNrIElEc1xuLy8gV2l0aCBNU0UgY3VycmVudGx5IG9uZSBjYW4gb25seSBoYXZlIG9uZSB0cmFjayBvZiBlYWNoLCBhbmQgd2UgYXJlIG11eGluZ1xuLy8gd2hhdGV2ZXIgdmlkZW8vYXVkaW8gcmVuZGl0aW9uIGluIHRoZW0uXG52YXIgUmVtdXhlclRyYWNrSWRDb25maWcgPSB7XG4gIHZpZGVvOiAxLFxuICBhdWRpbzogMixcbiAgaWQzOiAzLFxuICB0ZXh0OiA0XG59O1xuXG52YXIgVFNEZW11eGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gVFNEZW11eGVyKG9ic2VydmVyLCBjb25maWcsIHR5cGVTdXBwb3J0ZWQpIHtcbiAgICB0aGlzLm9ic2VydmVyID0gdm9pZCAwO1xuICAgIHRoaXMuY29uZmlnID0gdm9pZCAwO1xuICAgIHRoaXMudHlwZVN1cHBvcnRlZCA9IHZvaWQgMDtcbiAgICB0aGlzLnNhbXBsZUFlcyA9IG51bGw7XG4gICAgdGhpcy5wbXRQYXJzZWQgPSBmYWxzZTtcbiAgICB0aGlzLmF1ZGlvQ29kZWMgPSB2b2lkIDA7XG4gICAgdGhpcy52aWRlb0NvZGVjID0gdm9pZCAwO1xuICAgIHRoaXMuX2R1cmF0aW9uID0gMDtcbiAgICB0aGlzLmFhY0xhc3RQVFMgPSBudWxsO1xuICAgIHRoaXMuX2luaXRQVFMgPSBudWxsO1xuICAgIHRoaXMuX2luaXREVFMgPSBudWxsO1xuICAgIHRoaXMuX3BtdElkID0gLTE7XG4gICAgdGhpcy5fYXZjVHJhY2sgPSB2b2lkIDA7XG4gICAgdGhpcy5fYXVkaW9UcmFjayA9IHZvaWQgMDtcbiAgICB0aGlzLl9pZDNUcmFjayA9IHZvaWQgMDtcbiAgICB0aGlzLl90eHRUcmFjayA9IHZvaWQgMDtcbiAgICB0aGlzLmFhY092ZXJGbG93ID0gbnVsbDtcbiAgICB0aGlzLmF2Y1NhbXBsZSA9IG51bGw7XG4gICAgdGhpcy5yZW1haW5kZXJEYXRhID0gbnVsbDtcbiAgICB0aGlzLm9ic2VydmVyID0gb2JzZXJ2ZXI7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgdGhpcy50eXBlU3VwcG9ydGVkID0gdHlwZVN1cHBvcnRlZDtcbiAgfVxuXG4gIFRTRGVtdXhlci5wcm9iZSA9IGZ1bmN0aW9uIHByb2JlKGRhdGEpIHtcbiAgICB2YXIgc3luY09mZnNldCA9IFRTRGVtdXhlci5zeW5jT2Zmc2V0KGRhdGEpO1xuXG4gICAgaWYgKHN5bmNPZmZzZXQgPCAwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChzeW5jT2Zmc2V0KSB7XG4gICAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1tcImxvZ2dlclwiXS53YXJuKFwiTVBFRzItVFMgZGV0ZWN0ZWQgYnV0IGZpcnN0IHN5bmMgd29yZCBmb3VuZCBAIG9mZnNldCBcIiArIHN5bmNPZmZzZXQgKyBcIiwganVuayBhaGVhZCA/XCIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH07XG5cbiAgVFNEZW11eGVyLnN5bmNPZmZzZXQgPSBmdW5jdGlvbiBzeW5jT2Zmc2V0KGRhdGEpIHtcbiAgICAvLyBzY2FuIDEwMDAgZmlyc3QgYnl0ZXNcbiAgICB2YXIgc2NhbndpbmRvdyA9IE1hdGgubWluKDEwMDAsIGRhdGEubGVuZ3RoIC0gMyAqIDE4OCk7XG4gICAgdmFyIGkgPSAwO1xuXG4gICAgd2hpbGUgKGkgPCBzY2Fud2luZG93KSB7XG4gICAgICAvLyBhIFRTIGZyYWdtZW50IHNob3VsZCBjb250YWluIGF0IGxlYXN0IDMgVFMgcGFja2V0cywgYSBQQVQsIGEgUE1ULCBhbmQgb25lIFBJRCwgZWFjaCBzdGFydGluZyB3aXRoIDB4NDdcbiAgICAgIGlmIChkYXRhW2ldID09PSAweDQ3ICYmIGRhdGFbaSArIDE4OF0gPT09IDB4NDcgJiYgZGF0YVtpICsgMiAqIDE4OF0gPT09IDB4NDcpIHtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpKys7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIC0xO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgdHJhY2sgbW9kZWwgaW50ZXJuYWwgdG8gZGVtdXhlciB1c2VkIHRvIGRyaXZlIHJlbXV4aW5nIGlucHV0XG4gICAqXG4gICAqIEBwYXJhbSB0eXBlICdhdWRpbycgfCAndmlkZW8nIHwgJ2lkMycgfCAndGV4dCdcbiAgICogQHBhcmFtIGR1cmF0aW9uXG4gICAqIEByZXR1cm4gVFNEZW11eGVyJ3MgaW50ZXJuYWwgdHJhY2sgbW9kZWxcbiAgICovXG4gIDtcblxuICBUU0RlbXV4ZXIuY3JlYXRlVHJhY2sgPSBmdW5jdGlvbiBjcmVhdGVUcmFjayh0eXBlLCBkdXJhdGlvbikge1xuICAgIHJldHVybiB7XG4gICAgICBjb250YWluZXI6IHR5cGUgPT09ICd2aWRlbycgfHwgdHlwZSA9PT0gJ2F1ZGlvJyA/ICd2aWRlby9tcDJ0JyA6IHVuZGVmaW5lZCxcbiAgICAgIHR5cGU6IHR5cGUsXG4gICAgICBpZDogUmVtdXhlclRyYWNrSWRDb25maWdbdHlwZV0sXG4gICAgICBwaWQ6IC0xLFxuICAgICAgaW5wdXRUaW1lU2NhbGU6IDkwMDAwLFxuICAgICAgc2VxdWVuY2VOdW1iZXI6IDAsXG4gICAgICBzYW1wbGVzOiBbXSxcbiAgICAgIGRyb3BwZWQ6IDAsXG4gICAgICBkdXJhdGlvbjogdHlwZSA9PT0gJ2F1ZGlvJyA/IGR1cmF0aW9uIDogdW5kZWZpbmVkXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgYSBuZXcgaW5pdCBzZWdtZW50IG9uIHRoZSBkZW11eGVyL3JlbXV4ZXIgaW50ZXJmYWNlLiBOZWVkZWQgZm9yIGRpc2NvbnRpbnVpdGllcy90cmFjay1zd2l0Y2hlcyAob3IgYXQgc3RyZWFtIHN0YXJ0KVxuICAgKiBSZXNldHMgYWxsIGludGVybmFsIHRyYWNrIGluc3RhbmNlcyBvZiB0aGUgZGVtdXhlci5cbiAgICovXG4gIDtcblxuICB2YXIgX3Byb3RvID0gVFNEZW11eGVyLnByb3RvdHlwZTtcblxuICBfcHJvdG8ucmVzZXRJbml0U2VnbWVudCA9IGZ1bmN0aW9uIHJlc2V0SW5pdFNlZ21lbnQoYXVkaW9Db2RlYywgdmlkZW9Db2RlYywgZHVyYXRpb24pIHtcbiAgICB0aGlzLnBtdFBhcnNlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3BtdElkID0gLTE7XG4gICAgdGhpcy5fYXZjVHJhY2sgPSBUU0RlbXV4ZXIuY3JlYXRlVHJhY2soJ3ZpZGVvJywgZHVyYXRpb24pO1xuICAgIHRoaXMuX2F1ZGlvVHJhY2sgPSBUU0RlbXV4ZXIuY3JlYXRlVHJhY2soJ2F1ZGlvJywgZHVyYXRpb24pO1xuICAgIHRoaXMuX2lkM1RyYWNrID0gVFNEZW11eGVyLmNyZWF0ZVRyYWNrKCdpZDMnLCBkdXJhdGlvbik7XG4gICAgdGhpcy5fdHh0VHJhY2sgPSBUU0RlbXV4ZXIuY3JlYXRlVHJhY2soJ3RleHQnLCBkdXJhdGlvbik7XG4gICAgdGhpcy5fYXVkaW9UcmFjay5pc0FBQyA9IHRydWU7IC8vIGZsdXNoIGFueSBwYXJ0aWFsIGNvbnRlbnRcblxuICAgIHRoaXMuYWFjT3ZlckZsb3cgPSBudWxsO1xuICAgIHRoaXMuYWFjTGFzdFBUUyA9IG51bGw7XG4gICAgdGhpcy5hdmNTYW1wbGUgPSBudWxsO1xuICAgIHRoaXMuYXVkaW9Db2RlYyA9IGF1ZGlvQ29kZWM7XG4gICAgdGhpcy52aWRlb0NvZGVjID0gdmlkZW9Db2RlYztcbiAgICB0aGlzLl9kdXJhdGlvbiA9IGR1cmF0aW9uO1xuICB9O1xuXG4gIF9wcm90by5yZXNldFRpbWVTdGFtcCA9IGZ1bmN0aW9uIHJlc2V0VGltZVN0YW1wKCkge307XG5cbiAgX3Byb3RvLnJlc2V0Q29udGlndWl0eSA9IGZ1bmN0aW9uIHJlc2V0Q29udGlndWl0eSgpIHtcbiAgICB2YXIgX2F1ZGlvVHJhY2sgPSB0aGlzLl9hdWRpb1RyYWNrLFxuICAgICAgICBfYXZjVHJhY2sgPSB0aGlzLl9hdmNUcmFjayxcbiAgICAgICAgX2lkM1RyYWNrID0gdGhpcy5faWQzVHJhY2s7XG5cbiAgICBpZiAoX2F1ZGlvVHJhY2spIHtcbiAgICAgIF9hdWRpb1RyYWNrLnBlc0RhdGEgPSBudWxsO1xuICAgIH1cblxuICAgIGlmIChfYXZjVHJhY2spIHtcbiAgICAgIF9hdmNUcmFjay5wZXNEYXRhID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoX2lkM1RyYWNrKSB7XG4gICAgICBfaWQzVHJhY2sucGVzRGF0YSA9IG51bGw7XG4gICAgfVxuXG4gICAgdGhpcy5hYWNPdmVyRmxvdyA9IG51bGw7XG4gICAgdGhpcy5hYWNMYXN0UFRTID0gbnVsbDtcbiAgfTtcblxuICBfcHJvdG8uZGVtdXggPSBmdW5jdGlvbiBkZW11eChkYXRhLCB0aW1lT2Zmc2V0LCBpc1NhbXBsZUFlcywgZmx1c2gpIHtcbiAgICBpZiAoaXNTYW1wbGVBZXMgPT09IHZvaWQgMCkge1xuICAgICAgaXNTYW1wbGVBZXMgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoZmx1c2ggPT09IHZvaWQgMCkge1xuICAgICAgZmx1c2ggPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoIWlzU2FtcGxlQWVzKSB7XG4gICAgICB0aGlzLnNhbXBsZUFlcyA9IG51bGw7XG4gICAgfVxuXG4gICAgdmFyIHBlcztcbiAgICB2YXIgYXZjVHJhY2sgPSB0aGlzLl9hdmNUcmFjaztcbiAgICB2YXIgYXVkaW9UcmFjayA9IHRoaXMuX2F1ZGlvVHJhY2s7XG4gICAgdmFyIGlkM1RyYWNrID0gdGhpcy5faWQzVHJhY2s7XG4gICAgdmFyIGF2Y0lkID0gYXZjVHJhY2sucGlkO1xuICAgIHZhciBhdmNEYXRhID0gYXZjVHJhY2sucGVzRGF0YTtcbiAgICB2YXIgYXVkaW9JZCA9IGF1ZGlvVHJhY2sucGlkO1xuICAgIHZhciBpZDNJZCA9IGlkM1RyYWNrLnBpZDtcbiAgICB2YXIgYXVkaW9EYXRhID0gYXVkaW9UcmFjay5wZXNEYXRhO1xuICAgIHZhciBpZDNEYXRhID0gaWQzVHJhY2sucGVzRGF0YTtcbiAgICB2YXIgdW5rbm93blBJRHMgPSBmYWxzZTtcbiAgICB2YXIgcG10UGFyc2VkID0gdGhpcy5wbXRQYXJzZWQ7XG4gICAgdmFyIHBtdElkID0gdGhpcy5fcG10SWQ7XG4gICAgdmFyIGxlbiA9IGRhdGEubGVuZ3RoO1xuXG4gICAgaWYgKHRoaXMucmVtYWluZGVyRGF0YSkge1xuICAgICAgZGF0YSA9IE9iamVjdChfdXRpbHNfbXA0X3Rvb2xzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXCJhcHBlbmRVaW50OEFycmF5XCJdKSh0aGlzLnJlbWFpbmRlckRhdGEsIGRhdGEpO1xuICAgICAgbGVuID0gZGF0YS5sZW5ndGg7XG4gICAgICB0aGlzLnJlbWFpbmRlckRhdGEgPSBudWxsO1xuICAgIH1cblxuICAgIGlmIChsZW4gPCAxODggJiYgIWZsdXNoKSB7XG4gICAgICB0aGlzLnJlbWFpbmRlckRhdGEgPSBkYXRhO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYXVkaW9UcmFjazogYXVkaW9UcmFjayxcbiAgICAgICAgYXZjVHJhY2s6IGF2Y1RyYWNrLFxuICAgICAgICBpZDNUcmFjazogaWQzVHJhY2ssXG4gICAgICAgIHRleHRUcmFjazogdGhpcy5fdHh0VHJhY2tcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIHN5bmNPZmZzZXQgPSBNYXRoLm1heCgwLCBUU0RlbXV4ZXIuc3luY09mZnNldChkYXRhKSk7XG4gICAgbGVuIC09IChsZW4gKyBzeW5jT2Zmc2V0KSAlIDE4ODtcblxuICAgIGlmIChsZW4gPCBkYXRhLmJ5dGVMZW5ndGggJiYgIWZsdXNoKSB7XG4gICAgICB0aGlzLnJlbWFpbmRlckRhdGEgPSBuZXcgVWludDhBcnJheShkYXRhLmJ1ZmZlciwgbGVuLCBkYXRhLmJ1ZmZlci5ieXRlTGVuZ3RoIC0gbGVuKTtcbiAgICB9IC8vIGxvb3AgdGhyb3VnaCBUUyBwYWNrZXRzXG5cblxuICAgIHZhciB0c1BhY2tldEVycm9ycyA9IDA7XG5cbiAgICBmb3IgKHZhciBzdGFydCA9IHN5bmNPZmZzZXQ7IHN0YXJ0IDwgbGVuOyBzdGFydCArPSAxODgpIHtcbiAgICAgIGlmIChkYXRhW3N0YXJ0XSA9PT0gMHg0Nykge1xuICAgICAgICB2YXIgc3R0ID0gISEoZGF0YVtzdGFydCArIDFdICYgMHg0MCk7IC8vIHBpZCBpcyBhIDEzLWJpdCBmaWVsZCBzdGFydGluZyBhdCB0aGUgbGFzdCBiaXQgb2YgVFNbMV1cblxuICAgICAgICB2YXIgcGlkID0gKChkYXRhW3N0YXJ0ICsgMV0gJiAweDFmKSA8PCA4KSArIGRhdGFbc3RhcnQgKyAyXTtcbiAgICAgICAgdmFyIGF0ZiA9IChkYXRhW3N0YXJ0ICsgM10gJiAweDMwKSA+PiA0OyAvLyBpZiBhbiBhZGFwdGlvbiBmaWVsZCBpcyBwcmVzZW50LCBpdHMgbGVuZ3RoIGlzIHNwZWNpZmllZCBieSB0aGUgZmlmdGggYnl0ZSBvZiB0aGUgVFMgcGFja2V0IGhlYWRlci5cblxuICAgICAgICB2YXIgb2Zmc2V0ID0gdm9pZCAwO1xuXG4gICAgICAgIGlmIChhdGYgPiAxKSB7XG4gICAgICAgICAgb2Zmc2V0ID0gc3RhcnQgKyA1ICsgZGF0YVtzdGFydCArIDRdOyAvLyBjb250aW51ZSBpZiB0aGVyZSBpcyBvbmx5IGFkYXB0YXRpb24gZmllbGRcblxuICAgICAgICAgIGlmIChvZmZzZXQgPT09IHN0YXJ0ICsgMTg4KSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb2Zmc2V0ID0gc3RhcnQgKyA0O1xuICAgICAgICB9XG5cbiAgICAgICAgc3dpdGNoIChwaWQpIHtcbiAgICAgICAgICBjYXNlIGF2Y0lkOlxuICAgICAgICAgICAgaWYgKHN0dCkge1xuICAgICAgICAgICAgICBpZiAoYXZjRGF0YSAmJiAocGVzID0gcGFyc2VQRVMoYXZjRGF0YSkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJzZUFWQ1BFUyhwZXMsIGZhbHNlKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGF2Y0RhdGEgPSB7XG4gICAgICAgICAgICAgICAgZGF0YTogW10sXG4gICAgICAgICAgICAgICAgc2l6ZTogMFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYXZjRGF0YSkge1xuICAgICAgICAgICAgICBhdmNEYXRhLmRhdGEucHVzaChkYXRhLnN1YmFycmF5KG9mZnNldCwgc3RhcnQgKyAxODgpKTtcbiAgICAgICAgICAgICAgYXZjRGF0YS5zaXplICs9IHN0YXJ0ICsgMTg4IC0gb2Zmc2V0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgYXVkaW9JZDpcbiAgICAgICAgICAgIGlmIChzdHQpIHtcbiAgICAgICAgICAgICAgaWYgKGF1ZGlvRGF0YSAmJiAocGVzID0gcGFyc2VQRVMoYXVkaW9EYXRhKSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoYXVkaW9UcmFjay5pc0FBQykge1xuICAgICAgICAgICAgICAgICAgdGhpcy5wYXJzZUFBQ1BFUyhwZXMpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLnBhcnNlTVBFR1BFUyhwZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGF1ZGlvRGF0YSA9IHtcbiAgICAgICAgICAgICAgICBkYXRhOiBbXSxcbiAgICAgICAgICAgICAgICBzaXplOiAwXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChhdWRpb0RhdGEpIHtcbiAgICAgICAgICAgICAgYXVkaW9EYXRhLmRhdGEucHVzaChkYXRhLnN1YmFycmF5KG9mZnNldCwgc3RhcnQgKyAxODgpKTtcbiAgICAgICAgICAgICAgYXVkaW9EYXRhLnNpemUgKz0gc3RhcnQgKyAxODggLSBvZmZzZXQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBpZDNJZDpcbiAgICAgICAgICAgIGlmIChzdHQpIHtcbiAgICAgICAgICAgICAgaWYgKGlkM0RhdGEgJiYgKHBlcyA9IHBhcnNlUEVTKGlkM0RhdGEpKSkge1xuICAgICAgICAgICAgICAgIHRoaXMucGFyc2VJRDNQRVMocGVzKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlkM0RhdGEgPSB7XG4gICAgICAgICAgICAgICAgZGF0YTogW10sXG4gICAgICAgICAgICAgICAgc2l6ZTogMFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaWQzRGF0YSkge1xuICAgICAgICAgICAgICBpZDNEYXRhLmRhdGEucHVzaChkYXRhLnN1YmFycmF5KG9mZnNldCwgc3RhcnQgKyAxODgpKTtcbiAgICAgICAgICAgICAgaWQzRGF0YS5zaXplICs9IHN0YXJ0ICsgMTg4IC0gb2Zmc2V0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGlmIChzdHQpIHtcbiAgICAgICAgICAgICAgb2Zmc2V0ICs9IGRhdGFbb2Zmc2V0XSArIDE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHBtdElkID0gdGhpcy5fcG10SWQgPSBwYXJzZVBBVChkYXRhLCBvZmZzZXQpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIHBtdElkOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBpZiAoc3R0KSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IGRhdGFbb2Zmc2V0XSArIDE7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB2YXIgcGFyc2VkUElEcyA9IHBhcnNlUE1UKGRhdGEsIG9mZnNldCwgdGhpcy50eXBlU3VwcG9ydGVkLm1wZWcgPT09IHRydWUgfHwgdGhpcy50eXBlU3VwcG9ydGVkLm1wMyA9PT0gdHJ1ZSwgaXNTYW1wbGVBZXMpOyAvLyBvbmx5IHVwZGF0ZSB0cmFjayBpZCBpZiB0cmFjayBQSUQgZm91bmQgd2hpbGUgcGFyc2luZyBQTVRcbiAgICAgICAgICAgICAgLy8gdGhpcyBpcyB0byBhdm9pZCByZXNldHRpbmcgdGhlIFBJRCB0byAtMSBpbiBjYXNlXG4gICAgICAgICAgICAgIC8vIHRyYWNrIFBJRCB0cmFuc2llbnRseSBkaXNhcHBlYXJzIGZyb20gdGhlIHN0cmVhbVxuICAgICAgICAgICAgICAvLyB0aGlzIGNvdWxkIGhhcHBlbiBpbiBjYXNlIG9mIHRyYW5zaWVudCBtaXNzaW5nIGF1ZGlvIHNhbXBsZXMgZm9yIGV4YW1wbGVcbiAgICAgICAgICAgICAgLy8gTk9URSB0aGlzIGlzIG9ubHkgdGhlIFBJRCBvZiB0aGUgdHJhY2sgYXMgZm91bmQgaW4gVFMsXG4gICAgICAgICAgICAgIC8vIGJ1dCB3ZSBhcmUgbm90IHVzaW5nIHRoaXMgZm9yIE1QNCB0cmFjayBJRHMuXG5cbiAgICAgICAgICAgICAgYXZjSWQgPSBwYXJzZWRQSURzLmF2YztcblxuICAgICAgICAgICAgICBpZiAoYXZjSWQgPiAwKSB7XG4gICAgICAgICAgICAgICAgYXZjVHJhY2sucGlkID0gYXZjSWQ7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBhdWRpb0lkID0gcGFyc2VkUElEcy5hdWRpbztcblxuICAgICAgICAgICAgICBpZiAoYXVkaW9JZCA+IDApIHtcbiAgICAgICAgICAgICAgICBhdWRpb1RyYWNrLnBpZCA9IGF1ZGlvSWQ7XG4gICAgICAgICAgICAgICAgYXVkaW9UcmFjay5pc0FBQyA9IHBhcnNlZFBJRHMuaXNBQUM7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZDNJZCA9IHBhcnNlZFBJRHMuaWQzO1xuXG4gICAgICAgICAgICAgIGlmIChpZDNJZCA+IDApIHtcbiAgICAgICAgICAgICAgICBpZDNUcmFjay5waWQgPSBpZDNJZDtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmICh1bmtub3duUElEcyAmJiAhcG10UGFyc2VkKSB7XG4gICAgICAgICAgICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fW1wibG9nZ2VyXCJdLmxvZygncmVwYXJzZSBmcm9tIGJlZ2lubmluZycpO1xuICAgICAgICAgICAgICAgIHVua25vd25QSURzID0gZmFsc2U7IC8vIHdlIHNldCBpdCB0byAtMTg4LCB0aGUgKz0gMTg4IGluIHRoZSBmb3IgbG9vcCB3aWxsIHJlc2V0IHN0YXJ0IHRvIDBcblxuICAgICAgICAgICAgICAgIHN0YXJ0ID0gc3luY09mZnNldCAtIDE4ODtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHBtdFBhcnNlZCA9IHRoaXMucG10UGFyc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlIDE3OlxuICAgICAgICAgIGNhc2UgMHgxZmZmOlxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdW5rbm93blBJRHMgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRzUGFja2V0RXJyb3JzKys7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRzUGFja2V0RXJyb3JzID4gMCkge1xuICAgICAgdGhpcy5vYnNlcnZlci5lbWl0KF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcIkV2ZW50c1wiXS5FUlJPUiwgX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1wiRXZlbnRzXCJdLkVSUk9SLCB7XG4gICAgICAgIHR5cGU6IF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzhfX1tcIkVycm9yVHlwZXNcIl0uTUVESUFfRVJST1IsXG4gICAgICAgIGRldGFpbHM6IF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzhfX1tcIkVycm9yRGV0YWlsc1wiXS5GUkFHX1BBUlNJTkdfRVJST1IsXG4gICAgICAgIGZhdGFsOiBmYWxzZSxcbiAgICAgICAgcmVhc29uOiBcIkZvdW5kIFwiICsgdHNQYWNrZXRFcnJvcnMgKyBcIiBUUyBwYWNrZXQvcyB0aGF0IGRvIG5vdCBzdGFydCB3aXRoIDB4NDdcIlxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgYXZjVHJhY2sucGVzRGF0YSA9IGF2Y0RhdGE7XG4gICAgYXVkaW9UcmFjay5wZXNEYXRhID0gYXVkaW9EYXRhO1xuICAgIGlkM1RyYWNrLnBlc0RhdGEgPSBpZDNEYXRhO1xuICAgIHZhciBkZW11eFJlc3VsdCA9IHtcbiAgICAgIGF1ZGlvVHJhY2s6IGF1ZGlvVHJhY2ssXG4gICAgICBhdmNUcmFjazogYXZjVHJhY2ssXG4gICAgICBpZDNUcmFjazogaWQzVHJhY2ssXG4gICAgICB0ZXh0VHJhY2s6IHRoaXMuX3R4dFRyYWNrXG4gICAgfTtcblxuICAgIGlmIChmbHVzaCkge1xuICAgICAgdGhpcy5leHRyYWN0UmVtYWluaW5nU2FtcGxlcyhkZW11eFJlc3VsdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlbXV4UmVzdWx0O1xuICB9O1xuXG4gIF9wcm90by5mbHVzaCA9IGZ1bmN0aW9uIGZsdXNoKCkge1xuICAgIHZhciByZW1haW5kZXJEYXRhID0gdGhpcy5yZW1haW5kZXJEYXRhO1xuICAgIHRoaXMucmVtYWluZGVyRGF0YSA9IG51bGw7XG4gICAgdmFyIHJlc3VsdDtcblxuICAgIGlmIChyZW1haW5kZXJEYXRhKSB7XG4gICAgICByZXN1bHQgPSB0aGlzLmRlbXV4KHJlbWFpbmRlckRhdGEsIC0xLCBmYWxzZSwgdHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgYXVkaW9UcmFjazogdGhpcy5fYXVkaW9UcmFjayxcbiAgICAgICAgYXZjVHJhY2s6IHRoaXMuX2F2Y1RyYWNrLFxuICAgICAgICB0ZXh0VHJhY2s6IHRoaXMuX3R4dFRyYWNrLFxuICAgICAgICBpZDNUcmFjazogdGhpcy5faWQzVHJhY2tcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdGhpcy5leHRyYWN0UmVtYWluaW5nU2FtcGxlcyhyZXN1bHQpO1xuXG4gICAgaWYgKHRoaXMuc2FtcGxlQWVzKSB7XG4gICAgICByZXR1cm4gdGhpcy5kZWNyeXB0KHJlc3VsdCwgdGhpcy5zYW1wbGVBZXMpO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgX3Byb3RvLmV4dHJhY3RSZW1haW5pbmdTYW1wbGVzID0gZnVuY3Rpb24gZXh0cmFjdFJlbWFpbmluZ1NhbXBsZXMoZGVtdXhSZXN1bHQpIHtcbiAgICB2YXIgYXVkaW9UcmFjayA9IGRlbXV4UmVzdWx0LmF1ZGlvVHJhY2ssXG4gICAgICAgIGF2Y1RyYWNrID0gZGVtdXhSZXN1bHQuYXZjVHJhY2ssXG4gICAgICAgIGlkM1RyYWNrID0gZGVtdXhSZXN1bHQuaWQzVHJhY2s7XG4gICAgdmFyIGF2Y0RhdGEgPSBhdmNUcmFjay5wZXNEYXRhO1xuICAgIHZhciBhdWRpb0RhdGEgPSBhdWRpb1RyYWNrLnBlc0RhdGE7XG4gICAgdmFyIGlkM0RhdGEgPSBpZDNUcmFjay5wZXNEYXRhOyAvLyB0cnkgdG8gcGFyc2UgbGFzdCBQRVMgcGFja2V0c1xuXG4gICAgdmFyIHBlcztcblxuICAgIGlmIChhdmNEYXRhICYmIChwZXMgPSBwYXJzZVBFUyhhdmNEYXRhKSkpIHtcbiAgICAgIHRoaXMucGFyc2VBVkNQRVMocGVzLCB0cnVlKTtcbiAgICAgIGF2Y1RyYWNrLnBlc0RhdGEgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBlaXRoZXIgYXZjRGF0YSBudWxsIG9yIFBFUyB0cnVuY2F0ZWQsIGtlZXAgaXQgZm9yIG5leHQgZnJhZyBwYXJzaW5nXG4gICAgICBhdmNUcmFjay5wZXNEYXRhID0gYXZjRGF0YTtcbiAgICB9XG5cbiAgICBpZiAoYXVkaW9EYXRhICYmIChwZXMgPSBwYXJzZVBFUyhhdWRpb0RhdGEpKSkge1xuICAgICAgaWYgKGF1ZGlvVHJhY2suaXNBQUMpIHtcbiAgICAgICAgdGhpcy5wYXJzZUFBQ1BFUyhwZXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wYXJzZU1QRUdQRVMocGVzKTtcbiAgICAgIH1cblxuICAgICAgYXVkaW9UcmFjay5wZXNEYXRhID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGF1ZGlvRGF0YSAhPT0gbnVsbCAmJiBhdWRpb0RhdGEgIT09IHZvaWQgMCAmJiBhdWRpb0RhdGEuc2l6ZSkge1xuICAgICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bXCJsb2dnZXJcIl0ubG9nKCdsYXN0IEFBQyBQRVMgcGFja2V0IHRydW5jYXRlZCxtaWdodCBvdmVybGFwIGJldHdlZW4gZnJhZ21lbnRzJyk7XG4gICAgICB9IC8vIGVpdGhlciBhdWRpb0RhdGEgbnVsbCBvciBQRVMgdHJ1bmNhdGVkLCBrZWVwIGl0IGZvciBuZXh0IGZyYWcgcGFyc2luZ1xuXG5cbiAgICAgIGF1ZGlvVHJhY2sucGVzRGF0YSA9IGF1ZGlvRGF0YTtcbiAgICB9XG5cbiAgICBpZiAoaWQzRGF0YSAmJiAocGVzID0gcGFyc2VQRVMoaWQzRGF0YSkpKSB7XG4gICAgICB0aGlzLnBhcnNlSUQzUEVTKHBlcyk7XG4gICAgICBpZDNUcmFjay5wZXNEYXRhID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZWl0aGVyIGlkM0RhdGEgbnVsbCBvciBQRVMgdHJ1bmNhdGVkLCBrZWVwIGl0IGZvciBuZXh0IGZyYWcgcGFyc2luZ1xuICAgICAgaWQzVHJhY2sucGVzRGF0YSA9IGlkM0RhdGE7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5kZW11eFNhbXBsZUFlcyA9IGZ1bmN0aW9uIGRlbXV4U2FtcGxlQWVzKGRhdGEsIGtleURhdGEsIHRpbWVPZmZzZXQpIHtcbiAgICB2YXIgZGVtdXhSZXN1bHQgPSB0aGlzLmRlbXV4KGRhdGEsIHRpbWVPZmZzZXQsIHRydWUsICF0aGlzLmNvbmZpZy5wcm9ncmVzc2l2ZSk7XG4gICAgdmFyIHNhbXBsZUFlcyA9IHRoaXMuc2FtcGxlQWVzID0gbmV3IF9zYW1wbGVfYWVzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXCJkZWZhdWx0XCJdKHRoaXMub2JzZXJ2ZXIsIHRoaXMuY29uZmlnLCBrZXlEYXRhKTtcbiAgICByZXR1cm4gdGhpcy5kZWNyeXB0KGRlbXV4UmVzdWx0LCBzYW1wbGVBZXMpO1xuICB9O1xuXG4gIF9wcm90by5kZWNyeXB0ID0gZnVuY3Rpb24gZGVjcnlwdChkZW11eFJlc3VsdCwgc2FtcGxlQWVzKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICB2YXIgYXVkaW9UcmFjayA9IGRlbXV4UmVzdWx0LmF1ZGlvVHJhY2ssXG4gICAgICAgICAgYXZjVHJhY2sgPSBkZW11eFJlc3VsdC5hdmNUcmFjaztcblxuICAgICAgaWYgKGF1ZGlvVHJhY2suc2FtcGxlcyAmJiBhdWRpb1RyYWNrLmlzQUFDKSB7XG4gICAgICAgIHNhbXBsZUFlcy5kZWNyeXB0QWFjU2FtcGxlcyhhdWRpb1RyYWNrLnNhbXBsZXMsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoYXZjVHJhY2suc2FtcGxlcykge1xuICAgICAgICAgICAgc2FtcGxlQWVzLmRlY3J5cHRBdmNTYW1wbGVzKGF2Y1RyYWNrLnNhbXBsZXMsIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmVzb2x2ZShkZW11eFJlc3VsdCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzb2x2ZShkZW11eFJlc3VsdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoYXZjVHJhY2suc2FtcGxlcykge1xuICAgICAgICBzYW1wbGVBZXMuZGVjcnlwdEF2Y1NhbXBsZXMoYXZjVHJhY2suc2FtcGxlcywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJlc29sdmUoZGVtdXhSZXN1bHQpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5faW5pdFBUUyA9IHRoaXMuX2luaXREVFMgPSBudWxsO1xuICAgIHRoaXMuX2R1cmF0aW9uID0gMDtcbiAgfTtcblxuICBfcHJvdG8ucGFyc2VBVkNQRVMgPSBmdW5jdGlvbiBwYXJzZUFWQ1BFUyhwZXMsIGxhc3QpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIHRyYWNrID0gdGhpcy5fYXZjVHJhY2s7XG4gICAgdmFyIHVuaXRzID0gdGhpcy5wYXJzZUFWQ05BTHUocGVzLmRhdGEpO1xuICAgIHZhciBkZWJ1ZyA9IGZhbHNlO1xuICAgIHZhciBhdmNTYW1wbGUgPSB0aGlzLmF2Y1NhbXBsZTtcbiAgICB2YXIgcHVzaDtcbiAgICB2YXIgc3BzZm91bmQgPSBmYWxzZTsgLy8gZnJlZSBwZXMuZGF0YSB0byBzYXZlIHVwIHNvbWUgbWVtb3J5XG5cbiAgICBwZXMuZGF0YSA9IG51bGw7IC8vIGlmIG5ldyBOQUwgdW5pdHMgZm91bmQgYW5kIGxhc3Qgc2FtcGxlIHN0aWxsIHRoZXJlLCBsZXQncyBwdXNoIC4uLlxuICAgIC8vIHRoaXMgaGVscHMgcGFyc2luZyBzdHJlYW1zIHdpdGggbWlzc2luZyBBVUQgKG9ubHkgZG8gdGhpcyBpZiBBVUQgbmV2ZXIgZm91bmQpXG5cbiAgICBpZiAoYXZjU2FtcGxlICYmIHVuaXRzLmxlbmd0aCAmJiAhdHJhY2suYXVkRm91bmQpIHtcbiAgICAgIHB1c2hBY2Nlc3NVbml0KGF2Y1NhbXBsZSwgdHJhY2spO1xuICAgICAgYXZjU2FtcGxlID0gdGhpcy5hdmNTYW1wbGUgPSBjcmVhdGVBVkNTYW1wbGUoZmFsc2UsIHBlcy5wdHMsIHBlcy5kdHMsICcnKTtcbiAgICB9XG5cbiAgICB1bml0cy5mb3JFYWNoKGZ1bmN0aW9uICh1bml0KSB7XG4gICAgICBzd2l0Y2ggKHVuaXQudHlwZSkge1xuICAgICAgICAvLyBORFJcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHB1c2ggPSB0cnVlO1xuXG4gICAgICAgICAgICBpZiAoIWF2Y1NhbXBsZSkge1xuICAgICAgICAgICAgICBhdmNTYW1wbGUgPSBfdGhpcy5hdmNTYW1wbGUgPSBjcmVhdGVBVkNTYW1wbGUodHJ1ZSwgcGVzLnB0cywgcGVzLmR0cywgJycpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZGVidWcpIHtcbiAgICAgICAgICAgICAgYXZjU2FtcGxlLmRlYnVnICs9ICdORFIgJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYXZjU2FtcGxlLmZyYW1lID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBkYXRhID0gdW5pdC5kYXRhOyAvLyBvbmx5IGNoZWNrIHNsaWNlIHR5cGUgdG8gZGV0ZWN0IEtGIGluIGNhc2UgU1BTIGZvdW5kIGluIHNhbWUgcGFja2V0IChhbnkga2V5ZnJhbWUgaXMgcHJlY2VkZWQgYnkgU1BTIC4uLilcblxuICAgICAgICAgICAgaWYgKHNwc2ZvdW5kICYmIGRhdGEubGVuZ3RoID4gNCkge1xuICAgICAgICAgICAgICAvLyByZXRyaWV2ZSBzbGljZSB0eXBlIGJ5IHBhcnNpbmcgYmVnaW5uaW5nIG9mIE5BTCB1bml0IChmb2xsb3cgSDI2NCBzcGVjLCBzbGljZV9oZWFkZXIgZGVmaW5pdGlvbikgdG8gZGV0ZWN0IGtleWZyYW1lIGVtYmVkZGVkIGluIE5EUlxuICAgICAgICAgICAgICB2YXIgc2xpY2VUeXBlID0gbmV3IF9leHBfZ29sb21iX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJkZWZhdWx0XCJdKGRhdGEpLnJlYWRTbGljZVR5cGUoKTsgLy8gMiA6IEkgc2xpY2UsIDQgOiBTSSBzbGljZSwgNyA6IEkgc2xpY2UsIDk6IFNJIHNsaWNlXG4gICAgICAgICAgICAgIC8vIFNJIHNsaWNlIDogQSBzbGljZSB0aGF0IGlzIGNvZGVkIHVzaW5nIGludHJhIHByZWRpY3Rpb24gb25seSBhbmQgdXNpbmcgcXVhbnRpc2F0aW9uIG9mIHRoZSBwcmVkaWN0aW9uIHNhbXBsZXMuXG4gICAgICAgICAgICAgIC8vIEFuIFNJIHNsaWNlIGNhbiBiZSBjb2RlZCBzdWNoIHRoYXQgaXRzIGRlY29kZWQgc2FtcGxlcyBjYW4gYmUgY29uc3RydWN0ZWQgaWRlbnRpY2FsbHkgdG8gYW4gU1Agc2xpY2UuXG4gICAgICAgICAgICAgIC8vIEkgc2xpY2U6IEEgc2xpY2UgdGhhdCBpcyBub3QgYW4gU0kgc2xpY2UgdGhhdCBpcyBkZWNvZGVkIHVzaW5nIGludHJhIHByZWRpY3Rpb24gb25seS5cbiAgICAgICAgICAgICAgLy8gaWYgKHNsaWNlVHlwZSA9PT0gMiB8fCBzbGljZVR5cGUgPT09IDcpIHtcblxuICAgICAgICAgICAgICBpZiAoc2xpY2VUeXBlID09PSAyIHx8IHNsaWNlVHlwZSA9PT0gNCB8fCBzbGljZVR5cGUgPT09IDcgfHwgc2xpY2VUeXBlID09PSA5KSB7XG4gICAgICAgICAgICAgICAgYXZjU2FtcGxlLmtleSA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7IC8vIElEUlxuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgcHVzaCA9IHRydWU7IC8vIGhhbmRsZSBQRVMgbm90IHN0YXJ0aW5nIHdpdGggQVVEXG5cbiAgICAgICAgICBpZiAoIWF2Y1NhbXBsZSkge1xuICAgICAgICAgICAgYXZjU2FtcGxlID0gX3RoaXMuYXZjU2FtcGxlID0gY3JlYXRlQVZDU2FtcGxlKHRydWUsIHBlcy5wdHMsIHBlcy5kdHMsICcnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZGVidWcpIHtcbiAgICAgICAgICAgIGF2Y1NhbXBsZS5kZWJ1ZyArPSAnSURSICc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYXZjU2FtcGxlLmtleSA9IHRydWU7XG4gICAgICAgICAgYXZjU2FtcGxlLmZyYW1lID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gU0VJXG5cbiAgICAgICAgY2FzZSA2OlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHB1c2ggPSB0cnVlO1xuXG4gICAgICAgICAgICBpZiAoZGVidWcgJiYgYXZjU2FtcGxlKSB7XG4gICAgICAgICAgICAgIGF2Y1NhbXBsZS5kZWJ1ZyArPSAnU0VJICc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBleHBHb2xvbWJEZWNvZGVyID0gbmV3IF9leHBfZ29sb21iX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJkZWZhdWx0XCJdKGRpc2NhcmRFUEIodW5pdC5kYXRhKSk7IC8vIHNraXAgZnJhbWVUeXBlXG5cbiAgICAgICAgICAgIGV4cEdvbG9tYkRlY29kZXIucmVhZFVCeXRlKCk7XG4gICAgICAgICAgICB2YXIgcGF5bG9hZFR5cGUgPSAwO1xuICAgICAgICAgICAgdmFyIHBheWxvYWRTaXplID0gMDtcbiAgICAgICAgICAgIHZhciBlbmRPZkNhcHRpb25zID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgYiA9IDA7XG5cbiAgICAgICAgICAgIHdoaWxlICghZW5kT2ZDYXB0aW9ucyAmJiBleHBHb2xvbWJEZWNvZGVyLmJ5dGVzQXZhaWxhYmxlID4gMSkge1xuICAgICAgICAgICAgICBwYXlsb2FkVHlwZSA9IDA7XG5cbiAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIGIgPSBleHBHb2xvbWJEZWNvZGVyLnJlYWRVQnl0ZSgpO1xuICAgICAgICAgICAgICAgIHBheWxvYWRUeXBlICs9IGI7XG4gICAgICAgICAgICAgIH0gd2hpbGUgKGIgPT09IDB4ZmYpOyAvLyBQYXJzZSBwYXlsb2FkIHNpemUuXG5cblxuICAgICAgICAgICAgICBwYXlsb2FkU2l6ZSA9IDA7XG5cbiAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIGIgPSBleHBHb2xvbWJEZWNvZGVyLnJlYWRVQnl0ZSgpO1xuICAgICAgICAgICAgICAgIHBheWxvYWRTaXplICs9IGI7XG4gICAgICAgICAgICAgIH0gd2hpbGUgKGIgPT09IDB4ZmYpOyAvLyBUT0RPOiB0aGVyZSBjYW4gYmUgbW9yZSB0aGFuIG9uZSBwYXlsb2FkIGluIGFuIFNFSSBwYWNrZXQuLi5cbiAgICAgICAgICAgICAgLy8gVE9ETzogbmVlZCB0byByZWFkIHR5cGUgYW5kIHNpemUgaW4gYSB3aGlsZSBsb29wIHRvIGdldCB0aGVtIGFsbFxuXG5cbiAgICAgICAgICAgICAgaWYgKHBheWxvYWRUeXBlID09PSA0ICYmIGV4cEdvbG9tYkRlY29kZXIuYnl0ZXNBdmFpbGFibGUgIT09IDApIHtcbiAgICAgICAgICAgICAgICBlbmRPZkNhcHRpb25zID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB2YXIgY291bnRyeUNvZGUgPSBleHBHb2xvbWJEZWNvZGVyLnJlYWRVQnl0ZSgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNvdW50cnlDb2RlID09PSAxODEpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBwcm92aWRlckNvZGUgPSBleHBHb2xvbWJEZWNvZGVyLnJlYWRVU2hvcnQoKTtcblxuICAgICAgICAgICAgICAgICAgaWYgKHByb3ZpZGVyQ29kZSA9PT0gNDkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHVzZXJTdHJ1Y3R1cmUgPSBleHBHb2xvbWJEZWNvZGVyLnJlYWRVSW50KCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHVzZXJTdHJ1Y3R1cmUgPT09IDB4NDc0MTM5MzQpIHtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgdXNlckRhdGFUeXBlID0gZXhwR29sb21iRGVjb2Rlci5yZWFkVUJ5dGUoKTsgLy8gUmF3IENFQS02MDggYnl0ZXMgd3JhcHBlZCBpbiBDRUEtNzA4IHBhY2tldFxuXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHVzZXJEYXRhVHlwZSA9PT0gMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZpcnN0Qnl0ZSA9IGV4cEdvbG9tYkRlY29kZXIucmVhZFVCeXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2Vjb25kQnl0ZSA9IGV4cEdvbG9tYkRlY29kZXIucmVhZFVCeXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdG90YWxDQ3MgPSAzMSAmIGZpcnN0Qnl0ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBieXRlQXJyYXkgPSBbZmlyc3RCeXRlLCBzZWNvbmRCeXRlXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b3RhbENDczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDMgYnl0ZXMgcGVyIENDXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGJ5dGVBcnJheS5wdXNoKGV4cEdvbG9tYkRlY29kZXIucmVhZFVCeXRlKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBieXRlQXJyYXkucHVzaChleHBHb2xvbWJEZWNvZGVyLnJlYWRVQnl0ZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYnl0ZUFycmF5LnB1c2goZXhwR29sb21iRGVjb2Rlci5yZWFkVUJ5dGUoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGluc2VydFNhbXBsZUluT3JkZXIoX3RoaXMuX3R4dFRyYWNrLnNhbXBsZXMsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogMyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcHRzOiBwZXMucHRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBieXRlczogYnl0ZUFycmF5XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAocGF5bG9hZFR5cGUgPT09IDUgJiYgZXhwR29sb21iRGVjb2Rlci5ieXRlc0F2YWlsYWJsZSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIGVuZE9mQ2FwdGlvbnMgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgaWYgKHBheWxvYWRTaXplID4gMTYpIHtcbiAgICAgICAgICAgICAgICAgIHZhciB1dWlkU3RyQXJyYXkgPSBbXTtcblxuICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IDE2OyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHV1aWRTdHJBcnJheS5wdXNoKGV4cEdvbG9tYkRlY29kZXIucmVhZFVCeXRlKCkudG9TdHJpbmcoMTYpKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoX2kgPT09IDMgfHwgX2kgPT09IDUgfHwgX2kgPT09IDcgfHwgX2kgPT09IDkpIHtcbiAgICAgICAgICAgICAgICAgICAgICB1dWlkU3RyQXJyYXkucHVzaCgnLScpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIHZhciBsZW5ndGggPSBwYXlsb2FkU2l6ZSAtIDE2O1xuICAgICAgICAgICAgICAgICAgdmFyIHVzZXJEYXRhUGF5bG9hZEJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtcblxuICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgbGVuZ3RoOyBfaTIrKykge1xuICAgICAgICAgICAgICAgICAgICB1c2VyRGF0YVBheWxvYWRCeXRlc1tfaTJdID0gZXhwR29sb21iRGVjb2Rlci5yZWFkVUJ5dGUoKTtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgaW5zZXJ0U2FtcGxlSW5PcmRlcihfdGhpcy5fdHh0VHJhY2suc2FtcGxlcywge1xuICAgICAgICAgICAgICAgICAgICBwdHM6IHBlcy5wdHMsXG4gICAgICAgICAgICAgICAgICAgIHBheWxvYWRUeXBlOiBwYXlsb2FkVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgdXVpZDogdXVpZFN0ckFycmF5LmpvaW4oJycpLFxuICAgICAgICAgICAgICAgICAgICB1c2VyRGF0YTogT2JqZWN0KF9pZDNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcInV0ZjhBcnJheVRvU3RyXCJdKSh1c2VyRGF0YVBheWxvYWRCeXRlcyksXG4gICAgICAgICAgICAgICAgICAgIHVzZXJEYXRhQnl0ZXM6IHVzZXJEYXRhUGF5bG9hZEJ5dGVzXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAocGF5bG9hZFNpemUgPCBleHBHb2xvbWJEZWNvZGVyLmJ5dGVzQXZhaWxhYmxlKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2kzID0gMDsgX2kzIDwgcGF5bG9hZFNpemU7IF9pMysrKSB7XG4gICAgICAgICAgICAgICAgICBleHBHb2xvbWJEZWNvZGVyLnJlYWRVQnl0ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhazsgLy8gU1BTXG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgNzpcbiAgICAgICAgICBwdXNoID0gdHJ1ZTtcbiAgICAgICAgICBzcHNmb3VuZCA9IHRydWU7XG5cbiAgICAgICAgICBpZiAoZGVidWcgJiYgYXZjU2FtcGxlKSB7XG4gICAgICAgICAgICBhdmNTYW1wbGUuZGVidWcgKz0gJ1NQUyAnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghdHJhY2suc3BzKSB7XG4gICAgICAgICAgICB2YXIgX2V4cEdvbG9tYkRlY29kZXIgPSBuZXcgX2V4cF9nb2xvbWJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImRlZmF1bHRcIl0odW5pdC5kYXRhKTtcblxuICAgICAgICAgICAgdmFyIGNvbmZpZyA9IF9leHBHb2xvbWJEZWNvZGVyLnJlYWRTUFMoKTtcblxuICAgICAgICAgICAgdHJhY2sud2lkdGggPSBjb25maWcud2lkdGg7XG4gICAgICAgICAgICB0cmFjay5oZWlnaHQgPSBjb25maWcuaGVpZ2h0O1xuICAgICAgICAgICAgdHJhY2sucGl4ZWxSYXRpbyA9IGNvbmZpZy5waXhlbFJhdGlvOyAvLyBUT0RPOiBgdHJhY2suc3BzYCBpcyBkZWZpbmVkIGFzIGEgYG51bWJlcltdYCwgYnV0IHdlJ3JlIHNldHRpbmcgaXQgdG8gYSBgVWludDhBcnJheVtdYC5cblxuICAgICAgICAgICAgdHJhY2suc3BzID0gW3VuaXQuZGF0YV07XG4gICAgICAgICAgICB0cmFjay5kdXJhdGlvbiA9IF90aGlzLl9kdXJhdGlvbjtcbiAgICAgICAgICAgIHZhciBjb2RlY2FycmF5ID0gdW5pdC5kYXRhLnN1YmFycmF5KDEsIDQpO1xuICAgICAgICAgICAgdmFyIGNvZGVjc3RyaW5nID0gJ2F2YzEuJztcblxuICAgICAgICAgICAgZm9yICh2YXIgX2k0ID0gMDsgX2k0IDwgMzsgX2k0KyspIHtcbiAgICAgICAgICAgICAgdmFyIGggPSBjb2RlY2FycmF5W19pNF0udG9TdHJpbmcoMTYpO1xuXG4gICAgICAgICAgICAgIGlmIChoLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgICAgICBoID0gJzAnICsgaDtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGNvZGVjc3RyaW5nICs9IGg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRyYWNrLmNvZGVjID0gY29kZWNzdHJpbmc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIFBQU1xuXG4gICAgICAgIGNhc2UgODpcbiAgICAgICAgICBwdXNoID0gdHJ1ZTtcblxuICAgICAgICAgIGlmIChkZWJ1ZyAmJiBhdmNTYW1wbGUpIHtcbiAgICAgICAgICAgIGF2Y1NhbXBsZS5kZWJ1ZyArPSAnUFBTICc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCF0cmFjay5wcHMpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IGB0cmFjay5wc3NgIGlzIGRlZmluZWQgYXMgYSBgbnVtYmVyW11gLCBidXQgd2UncmUgc2V0dGluZyBpdCB0byBhIGBVaW50OEFycmF5W11gLlxuICAgICAgICAgICAgdHJhY2sucHBzID0gW3VuaXQuZGF0YV07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIEFVRFxuXG4gICAgICAgIGNhc2UgOTpcbiAgICAgICAgICBwdXNoID0gZmFsc2U7XG4gICAgICAgICAgdHJhY2suYXVkRm91bmQgPSB0cnVlO1xuXG4gICAgICAgICAgaWYgKGF2Y1NhbXBsZSkge1xuICAgICAgICAgICAgcHVzaEFjY2Vzc1VuaXQoYXZjU2FtcGxlLCB0cmFjayk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYXZjU2FtcGxlID0gX3RoaXMuYXZjU2FtcGxlID0gY3JlYXRlQVZDU2FtcGxlKGZhbHNlLCBwZXMucHRzLCBwZXMuZHRzLCBkZWJ1ZyA/ICdBVUQgJyA6ICcnKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gRmlsbGVyIERhdGFcblxuICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgIHB1c2ggPSBmYWxzZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHB1c2ggPSBmYWxzZTtcblxuICAgICAgICAgIGlmIChhdmNTYW1wbGUpIHtcbiAgICAgICAgICAgIGF2Y1NhbXBsZS5kZWJ1ZyArPSAndW5rbm93biBOQUwgJyArIHVuaXQudHlwZSArICcgJztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgaWYgKGF2Y1NhbXBsZSAmJiBwdXNoKSB7XG4gICAgICAgIHZhciBfdW5pdHMgPSBhdmNTYW1wbGUudW5pdHM7XG5cbiAgICAgICAgX3VuaXRzLnB1c2godW5pdCk7XG4gICAgICB9XG4gICAgfSk7IC8vIGlmIGxhc3QgUEVTIHBhY2tldCwgcHVzaCBzYW1wbGVzXG5cbiAgICBpZiAobGFzdCAmJiBhdmNTYW1wbGUpIHtcbiAgICAgIHB1c2hBY2Nlc3NVbml0KGF2Y1NhbXBsZSwgdHJhY2spO1xuICAgICAgdGhpcy5hdmNTYW1wbGUgPSBudWxsO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uZ2V0TGFzdE5hbFVuaXQgPSBmdW5jdGlvbiBnZXRMYXN0TmFsVW5pdCgpIHtcbiAgICB2YXIgX2F2Y1NhbXBsZTtcblxuICAgIHZhciBhdmNTYW1wbGUgPSB0aGlzLmF2Y1NhbXBsZTtcbiAgICB2YXIgbGFzdFVuaXQ7IC8vIHRyeSB0byBmYWxsYmFjayB0byBwcmV2aW91cyBzYW1wbGUgaWYgY3VycmVudCBvbmUgaXMgZW1wdHlcblxuICAgIGlmICghYXZjU2FtcGxlIHx8IGF2Y1NhbXBsZS51bml0cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHZhciBzYW1wbGVzID0gdGhpcy5fYXZjVHJhY2suc2FtcGxlcztcbiAgICAgIGF2Y1NhbXBsZSA9IHNhbXBsZXNbc2FtcGxlcy5sZW5ndGggLSAxXTtcbiAgICB9XG5cbiAgICBpZiAoKF9hdmNTYW1wbGUgPSBhdmNTYW1wbGUpICE9PSBudWxsICYmIF9hdmNTYW1wbGUgIT09IHZvaWQgMCAmJiBfYXZjU2FtcGxlLnVuaXRzKSB7XG4gICAgICB2YXIgdW5pdHMgPSBhdmNTYW1wbGUudW5pdHM7XG4gICAgICBsYXN0VW5pdCA9IHVuaXRzW3VuaXRzLmxlbmd0aCAtIDFdO1xuICAgIH1cblxuICAgIHJldHVybiBsYXN0VW5pdDtcbiAgfTtcblxuICBfcHJvdG8ucGFyc2VBVkNOQUx1ID0gZnVuY3Rpb24gcGFyc2VBVkNOQUx1KGFycmF5KSB7XG4gICAgdmFyIGxlbiA9IGFycmF5LmJ5dGVMZW5ndGg7XG4gICAgdmFyIHRyYWNrID0gdGhpcy5fYXZjVHJhY2s7XG4gICAgdmFyIHN0YXRlID0gdHJhY2submFsdVN0YXRlIHx8IDA7XG4gICAgdmFyIGxhc3RTdGF0ZSA9IHN0YXRlO1xuICAgIHZhciB1bml0cyA9IFtdO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgdmFsdWU7XG4gICAgdmFyIG92ZXJmbG93O1xuICAgIHZhciB1bml0VHlwZTtcbiAgICB2YXIgbGFzdFVuaXRTdGFydCA9IC0xO1xuICAgIHZhciBsYXN0VW5pdFR5cGUgPSAwOyAvLyBsb2dnZXIubG9nKCdQRVM6JyArIEhleC5oZXhEdW1wKGFycmF5KSk7XG5cbiAgICBpZiAoc3RhdGUgPT09IC0xKSB7XG4gICAgICAvLyBzcGVjaWFsIHVzZSBjYXNlIHdoZXJlIHdlIGZvdW5kIDMgb3IgNC1ieXRlIHN0YXJ0IGNvZGVzIGV4YWN0bHkgYXQgdGhlIGVuZCBvZiBwcmV2aW91cyBQRVMgcGFja2V0XG4gICAgICBsYXN0VW5pdFN0YXJ0ID0gMDsgLy8gTkFMdSB0eXBlIGlzIHZhbHVlIHJlYWQgZnJvbSBvZmZzZXQgMFxuXG4gICAgICBsYXN0VW5pdFR5cGUgPSBhcnJheVswXSAmIDB4MWY7XG4gICAgICBzdGF0ZSA9IDA7XG4gICAgICBpID0gMTtcbiAgICB9XG5cbiAgICB3aGlsZSAoaSA8IGxlbikge1xuICAgICAgdmFsdWUgPSBhcnJheVtpKytdOyAvLyBvcHRpbWl6YXRpb24uIHN0YXRlIDAgYW5kIDEgYXJlIHRoZSBwcmVkb21pbmFudCBjYXNlLiBsZXQncyBoYW5kbGUgdGhlbSBvdXRzaWRlIG9mIHRoZSBzd2l0Y2gvY2FzZVxuXG4gICAgICBpZiAoIXN0YXRlKSB7XG4gICAgICAgIHN0YXRlID0gdmFsdWUgPyAwIDogMTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGF0ZSA9PT0gMSkge1xuICAgICAgICBzdGF0ZSA9IHZhbHVlID8gMCA6IDI7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSAvLyBoZXJlIHdlIGhhdmUgc3RhdGUgZWl0aGVyIGVxdWFsIHRvIDIgb3IgM1xuXG5cbiAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgc3RhdGUgPSAzO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gMSkge1xuICAgICAgICBpZiAobGFzdFVuaXRTdGFydCA+PSAwKSB7XG4gICAgICAgICAgdmFyIHVuaXQgPSB7XG4gICAgICAgICAgICBkYXRhOiBhcnJheS5zdWJhcnJheShsYXN0VW5pdFN0YXJ0LCBpIC0gc3RhdGUgLSAxKSxcbiAgICAgICAgICAgIHR5cGU6IGxhc3RVbml0VHlwZVxuICAgICAgICAgIH07IC8vIGxvZ2dlci5sb2coJ3B1c2hpbmcgTkFMVSwgdHlwZS9zaXplOicgKyB1bml0LnR5cGUgKyAnLycgKyB1bml0LmRhdGEuYnl0ZUxlbmd0aCk7XG5cbiAgICAgICAgICB1bml0cy5wdXNoKHVuaXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGxhc3RVbml0U3RhcnQgaXMgdW5kZWZpbmVkID0+IHRoaXMgaXMgdGhlIGZpcnN0IHN0YXJ0IGNvZGUgZm91bmQgaW4gdGhpcyBQRVMgcGFja2V0XG4gICAgICAgICAgLy8gZmlyc3QgY2hlY2sgaWYgc3RhcnQgY29kZSBkZWxpbWl0ZXIgaXMgb3ZlcmxhcHBpbmcgYmV0d2VlbiAyIFBFUyBwYWNrZXRzLFxuICAgICAgICAgIC8vIGllIGl0IHN0YXJ0ZWQgaW4gbGFzdCBwYWNrZXQgKGxhc3RTdGF0ZSBub3QgemVybylcbiAgICAgICAgICAvLyBhbmQgZW5kZWQgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGlzIFBFUyBwYWNrZXQgKGkgPD0gNCAtIGxhc3RTdGF0ZSlcbiAgICAgICAgICB2YXIgbGFzdFVuaXQgPSB0aGlzLmdldExhc3ROYWxVbml0KCk7XG5cbiAgICAgICAgICBpZiAobGFzdFVuaXQpIHtcbiAgICAgICAgICAgIGlmIChsYXN0U3RhdGUgJiYgaSA8PSA0IC0gbGFzdFN0YXRlKSB7XG4gICAgICAgICAgICAgIC8vIHN0YXJ0IGRlbGltaXRlciBvdmVybGFwcGluZyBiZXR3ZWVuIFBFUyBwYWNrZXRzXG4gICAgICAgICAgICAgIC8vIHN0cmlwIHN0YXJ0IGRlbGltaXRlciBieXRlcyBmcm9tIHRoZSBlbmQgb2YgbGFzdCBOQUwgdW5pdFxuICAgICAgICAgICAgICAvLyBjaGVjayBpZiBsYXN0VW5pdCBoYWQgYSBzdGF0ZSBkaWZmZXJlbnQgZnJvbSB6ZXJvXG4gICAgICAgICAgICAgIGlmIChsYXN0VW5pdC5zdGF0ZSkge1xuICAgICAgICAgICAgICAgIC8vIHN0cmlwIGxhc3QgYnl0ZXNcbiAgICAgICAgICAgICAgICBsYXN0VW5pdC5kYXRhID0gbGFzdFVuaXQuZGF0YS5zdWJhcnJheSgwLCBsYXN0VW5pdC5kYXRhLmJ5dGVMZW5ndGggLSBsYXN0U3RhdGUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IC8vIElmIE5BTCB1bml0cyBhcmUgbm90IHN0YXJ0aW5nIHJpZ2h0IGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIFBFUyBwYWNrZXQsIHB1c2ggcHJlY2VkaW5nIGRhdGEgaW50byBwcmV2aW91cyBOQUwgdW5pdC5cblxuXG4gICAgICAgICAgICBvdmVyZmxvdyA9IGkgLSBzdGF0ZSAtIDE7XG5cbiAgICAgICAgICAgIGlmIChvdmVyZmxvdyA+IDApIHtcbiAgICAgICAgICAgICAgLy8gbG9nZ2VyLmxvZygnZmlyc3QgTkFMVSBmb3VuZCB3aXRoIG92ZXJmbG93OicgKyBvdmVyZmxvdyk7XG4gICAgICAgICAgICAgIHZhciB0bXAgPSBuZXcgVWludDhBcnJheShsYXN0VW5pdC5kYXRhLmJ5dGVMZW5ndGggKyBvdmVyZmxvdyk7XG4gICAgICAgICAgICAgIHRtcC5zZXQobGFzdFVuaXQuZGF0YSwgMCk7XG4gICAgICAgICAgICAgIHRtcC5zZXQoYXJyYXkuc3ViYXJyYXkoMCwgb3ZlcmZsb3cpLCBsYXN0VW5pdC5kYXRhLmJ5dGVMZW5ndGgpO1xuICAgICAgICAgICAgICBsYXN0VW5pdC5kYXRhID0gdG1wO1xuICAgICAgICAgICAgICBsYXN0VW5pdC5zdGF0ZSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIGNoZWNrIGlmIHdlIGNhbiByZWFkIHVuaXQgdHlwZVxuXG5cbiAgICAgICAgaWYgKGkgPCBsZW4pIHtcbiAgICAgICAgICB1bml0VHlwZSA9IGFycmF5W2ldICYgMHgxZjsgLy8gbG9nZ2VyLmxvZygnZmluZCBOQUxVIEAgb2Zmc2V0OicgKyBpICsgJyx0eXBlOicgKyB1bml0VHlwZSk7XG5cbiAgICAgICAgICBsYXN0VW5pdFN0YXJ0ID0gaTtcbiAgICAgICAgICBsYXN0VW5pdFR5cGUgPSB1bml0VHlwZTtcbiAgICAgICAgICBzdGF0ZSA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gbm90IGVub3VnaCBieXRlIHRvIHJlYWQgdW5pdCB0eXBlLiBsZXQncyByZWFkIGl0IG9uIG5leHQgUEVTIHBhcnNpbmdcbiAgICAgICAgICBzdGF0ZSA9IC0xO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZSA9IDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGxhc3RVbml0U3RhcnQgPj0gMCAmJiBzdGF0ZSA+PSAwKSB7XG4gICAgICB2YXIgX3VuaXQgPSB7XG4gICAgICAgIGRhdGE6IGFycmF5LnN1YmFycmF5KGxhc3RVbml0U3RhcnQsIGxlbiksXG4gICAgICAgIHR5cGU6IGxhc3RVbml0VHlwZSxcbiAgICAgICAgc3RhdGU6IHN0YXRlXG4gICAgICB9O1xuICAgICAgdW5pdHMucHVzaChfdW5pdCk7IC8vIGxvZ2dlci5sb2coJ3B1c2hpbmcgTkFMVSwgdHlwZS9zaXplL3N0YXRlOicgKyB1bml0LnR5cGUgKyAnLycgKyB1bml0LmRhdGEuYnl0ZUxlbmd0aCArICcvJyArIHN0YXRlKTtcbiAgICB9IC8vIG5vIE5BTHUgZm91bmRcblxuXG4gICAgaWYgKHVuaXRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgLy8gYXBwZW5kIHBlcy5kYXRhIHRvIHByZXZpb3VzIE5BTCB1bml0XG4gICAgICB2YXIgX2xhc3RVbml0ID0gdGhpcy5nZXRMYXN0TmFsVW5pdCgpO1xuXG4gICAgICBpZiAoX2xhc3RVbml0KSB7XG4gICAgICAgIHZhciBfdG1wID0gbmV3IFVpbnQ4QXJyYXkoX2xhc3RVbml0LmRhdGEuYnl0ZUxlbmd0aCArIGFycmF5LmJ5dGVMZW5ndGgpO1xuXG4gICAgICAgIF90bXAuc2V0KF9sYXN0VW5pdC5kYXRhLCAwKTtcblxuICAgICAgICBfdG1wLnNldChhcnJheSwgX2xhc3RVbml0LmRhdGEuYnl0ZUxlbmd0aCk7XG5cbiAgICAgICAgX2xhc3RVbml0LmRhdGEgPSBfdG1wO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRyYWNrLm5hbHVTdGF0ZSA9IHN0YXRlO1xuICAgIHJldHVybiB1bml0cztcbiAgfTtcblxuICBfcHJvdG8ucGFyc2VBQUNQRVMgPSBmdW5jdGlvbiBwYXJzZUFBQ1BFUyhwZXMpIHtcbiAgICB2YXIgc3RhcnRPZmZzZXQgPSAwO1xuICAgIHZhciB0cmFjayA9IHRoaXMuX2F1ZGlvVHJhY2s7XG4gICAgdmFyIGFhY092ZXJGbG93ID0gdGhpcy5hYWNPdmVyRmxvdztcbiAgICB2YXIgZGF0YSA9IHBlcy5kYXRhO1xuXG4gICAgaWYgKGFhY092ZXJGbG93KSB7XG4gICAgICB0aGlzLmFhY092ZXJGbG93ID0gbnVsbDtcbiAgICAgIHZhciBzYW1wbGVMZW5ndGggPSBhYWNPdmVyRmxvdy5zYW1wbGUudW5pdC5ieXRlTGVuZ3RoO1xuICAgICAgdmFyIGZyYW1lTWlzc2luZ0J5dGVzID0gTWF0aC5taW4oYWFjT3ZlckZsb3cubWlzc2luZywgc2FtcGxlTGVuZ3RoKTtcbiAgICAgIHZhciBmcmFtZU92ZXJmbG93Qnl0ZXMgPSBzYW1wbGVMZW5ndGggLSBmcmFtZU1pc3NpbmdCeXRlcztcbiAgICAgIGFhY092ZXJGbG93LnNhbXBsZS51bml0LnNldChkYXRhLnN1YmFycmF5KDAsIGZyYW1lTWlzc2luZ0J5dGVzKSwgZnJhbWVPdmVyZmxvd0J5dGVzKTtcbiAgICAgIHRyYWNrLnNhbXBsZXMucHVzaChhYWNPdmVyRmxvdy5zYW1wbGUpOyAvLyBsb2dnZXIubG9nKGBBQUM6IGFwcGVuZCBvdmVyZmxvd2luZyAke2ZyYW1lT3ZlcmZsb3dCeXRlc30gYnl0ZXMgdG8gYmVnaW5uaW5nIG9mIG5ldyBQRVNgKTtcblxuICAgICAgc3RhcnRPZmZzZXQgPSBhYWNPdmVyRmxvdy5taXNzaW5nO1xuICAgIH0gLy8gbG9vayBmb3IgQURUUyBoZWFkZXIgKDB4RkZGeClcblxuXG4gICAgdmFyIG9mZnNldDtcbiAgICB2YXIgbGVuO1xuXG4gICAgZm9yIChvZmZzZXQgPSBzdGFydE9mZnNldCwgbGVuID0gZGF0YS5sZW5ndGg7IG9mZnNldCA8IGxlbiAtIDE7IG9mZnNldCsrKSB7XG4gICAgICBpZiAoX2FkdHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImlzSGVhZGVyXCJdKGRhdGEsIG9mZnNldCkpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSAvLyBpZiBBRFRTIGhlYWRlciBkb2VzIG5vdCBzdGFydCBzdHJhaWdodCBmcm9tIHRoZSBiZWdpbm5pbmcgb2YgdGhlIFBFUyBwYXlsb2FkLCByYWlzZSBhbiBlcnJvclxuXG5cbiAgICBpZiAob2Zmc2V0ICE9PSBzdGFydE9mZnNldCkge1xuICAgICAgdmFyIHJlYXNvbjtcbiAgICAgIHZhciBmYXRhbDtcblxuICAgICAgaWYgKG9mZnNldCA8IGxlbiAtIDEpIHtcbiAgICAgICAgcmVhc29uID0gXCJBQUMgUEVTIGRpZCBub3Qgc3RhcnQgd2l0aCBBRFRTIGhlYWRlcixvZmZzZXQ6XCIgKyBvZmZzZXQ7XG4gICAgICAgIGZhdGFsID0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZWFzb24gPSAnbm8gQURUUyBoZWFkZXIgZm91bmQgaW4gQUFDIFBFUyc7XG4gICAgICAgIGZhdGFsID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fW1wibG9nZ2VyXCJdLndhcm4oXCJwYXJzaW5nIGVycm9yOlwiICsgcmVhc29uKTtcbiAgICAgIHRoaXMub2JzZXJ2ZXIuZW1pdChfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXCJFdmVudHNcIl0uRVJST1IsIF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcIkV2ZW50c1wiXS5FUlJPUiwge1xuICAgICAgICB0eXBlOiBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV84X19bXCJFcnJvclR5cGVzXCJdLk1FRElBX0VSUk9SLFxuICAgICAgICBkZXRhaWxzOiBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV84X19bXCJFcnJvckRldGFpbHNcIl0uRlJBR19QQVJTSU5HX0VSUk9SLFxuICAgICAgICBmYXRhbDogZmF0YWwsXG4gICAgICAgIHJlYXNvbjogcmVhc29uXG4gICAgICB9KTtcblxuICAgICAgaWYgKGZhdGFsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBfYWR0c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiaW5pdFRyYWNrQ29uZmlnXCJdKHRyYWNrLCB0aGlzLm9ic2VydmVyLCBkYXRhLCBvZmZzZXQsIHRoaXMuYXVkaW9Db2RlYyk7XG4gICAgdmFyIHB0cztcblxuICAgIGlmIChwZXMucHRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHB0cyA9IHBlcy5wdHM7XG4gICAgfSBlbHNlIGlmIChhYWNPdmVyRmxvdykge1xuICAgICAgLy8gaWYgbGFzdCBBQUMgZnJhbWUgaXMgb3ZlcmZsb3dpbmcsIHdlIHNob3VsZCBlbnN1cmUgdGltZXN0YW1wcyBhcmUgY29udGlndW91czpcbiAgICAgIC8vIGZpcnN0IHNhbXBsZSBQVFMgc2hvdWxkIGJlIGVxdWFsIHRvIGxhc3Qgc2FtcGxlIFBUUyArIGZyYW1lRHVyYXRpb25cbiAgICAgIHZhciBmcmFtZUR1cmF0aW9uID0gX2FkdHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImdldEZyYW1lRHVyYXRpb25cIl0odHJhY2suc2FtcGxlcmF0ZSk7XG4gICAgICBwdHMgPSBhYWNPdmVyRmxvdy5zYW1wbGUucHRzICsgZnJhbWVEdXJhdGlvbjtcbiAgICB9IGVsc2Uge1xuICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fW1wibG9nZ2VyXCJdLndhcm4oJ1t0c2RlbXV4ZXJdOiBBQUMgUEVTIHVua25vd24gUFRTJyk7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBzY2FuIGZvciBhYWMgc2FtcGxlc1xuXG5cbiAgICB2YXIgZnJhbWVJbmRleCA9IDA7XG5cbiAgICB3aGlsZSAob2Zmc2V0IDwgbGVuKSB7XG4gICAgICBpZiAoX2FkdHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImlzSGVhZGVyXCJdKGRhdGEsIG9mZnNldCkpIHtcbiAgICAgICAgaWYgKG9mZnNldCArIDUgPCBsZW4pIHtcbiAgICAgICAgICB2YXIgZnJhbWUgPSBfYWR0c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiYXBwZW5kRnJhbWVcIl0odHJhY2ssIGRhdGEsIG9mZnNldCwgcHRzLCBmcmFtZUluZGV4KTtcblxuICAgICAgICAgIGlmIChmcmFtZSkge1xuICAgICAgICAgICAgaWYgKGZyYW1lLm1pc3NpbmcpIHtcbiAgICAgICAgICAgICAgdGhpcy5hYWNPdmVyRmxvdyA9IGZyYW1lO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgb2Zmc2V0ICs9IGZyYW1lLmxlbmd0aDtcbiAgICAgICAgICAgICAgZnJhbWVJbmRleCsrO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gV2UgYXJlIGF0IGFuIEFEVFMgaGVhZGVyLCBidXQgZG8gbm90IGhhdmUgZW5vdWdoIGRhdGEgZm9yIGEgZnJhbWVcbiAgICAgICAgLy8gUmVtYWluaW5nIGRhdGEgd2lsbCBiZSBhZGRlZCB0byBhYWNPdmVyRmxvd1xuXG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBub3RoaW5nIGZvdW5kLCBrZWVwIGxvb2tpbmdcbiAgICAgICAgb2Zmc2V0Kys7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5wYXJzZU1QRUdQRVMgPSBmdW5jdGlvbiBwYXJzZU1QRUdQRVMocGVzKSB7XG4gICAgdmFyIGRhdGEgPSBwZXMuZGF0YTtcbiAgICB2YXIgbGVuZ3RoID0gZGF0YS5sZW5ndGg7XG4gICAgdmFyIGZyYW1lSW5kZXggPSAwO1xuICAgIHZhciBvZmZzZXQgPSAwO1xuICAgIHZhciBwdHMgPSBwZXMucHRzO1xuXG4gICAgaWYgKHB0cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bXCJsb2dnZXJcIl0ud2FybignW3RzZGVtdXhlcl06IE1QRUcgUEVTIHVua25vd24gUFRTJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2hpbGUgKG9mZnNldCA8IGxlbmd0aCkge1xuICAgICAgaWYgKF9tcGVnYXVkaW9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImlzSGVhZGVyXCJdKGRhdGEsIG9mZnNldCkpIHtcbiAgICAgICAgdmFyIGZyYW1lID0gX21wZWdhdWRpb19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiYXBwZW5kRnJhbWVcIl0odGhpcy5fYXVkaW9UcmFjaywgZGF0YSwgb2Zmc2V0LCBwdHMsIGZyYW1lSW5kZXgpO1xuXG4gICAgICAgIGlmIChmcmFtZSkge1xuICAgICAgICAgIG9mZnNldCArPSBmcmFtZS5sZW5ndGg7XG4gICAgICAgICAgZnJhbWVJbmRleCsrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGxvZ2dlci5sb2coJ1VuYWJsZSB0byBwYXJzZSBNcGVnIGF1ZGlvIGZyYW1lJyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG5vdGhpbmcgZm91bmQsIGtlZXAgbG9va2luZ1xuICAgICAgICBvZmZzZXQrKztcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLnBhcnNlSUQzUEVTID0gZnVuY3Rpb24gcGFyc2VJRDNQRVMocGVzKSB7XG4gICAgaWYgKHBlcy5wdHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fW1wibG9nZ2VyXCJdLndhcm4oJ1t0c2RlbXV4ZXJdOiBJRDMgUEVTIHVua25vd24gUFRTJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5faWQzVHJhY2suc2FtcGxlcy5wdXNoKHBlcyk7XG4gIH07XG5cbiAgcmV0dXJuIFRTRGVtdXhlcjtcbn0oKTtcblxuVFNEZW11eGVyLm1pblByb2JlQnl0ZUxlbmd0aCA9IDE4ODtcblxuZnVuY3Rpb24gY3JlYXRlQVZDU2FtcGxlKGtleSwgcHRzLCBkdHMsIGRlYnVnKSB7XG4gIHJldHVybiB7XG4gICAga2V5OiBrZXksXG4gICAgZnJhbWU6IGZhbHNlLFxuICAgIHB0czogcHRzLFxuICAgIGR0czogZHRzLFxuICAgIHVuaXRzOiBbXSxcbiAgICBkZWJ1ZzogZGVidWcsXG4gICAgbGVuZ3RoOiAwXG4gIH07XG59XG5cbmZ1bmN0aW9uIHBhcnNlUEFUKGRhdGEsIG9mZnNldCkge1xuICAvLyBza2lwIHRoZSBQU0kgaGVhZGVyIGFuZCBwYXJzZSB0aGUgZmlyc3QgUE1UIGVudHJ5XG4gIHJldHVybiAoZGF0YVtvZmZzZXQgKyAxMF0gJiAweDFmKSA8PCA4IHwgZGF0YVtvZmZzZXQgKyAxMV07IC8vIGxvZ2dlci5sb2coJ1BNVCBQSUQ6JyAgKyB0aGlzLl9wbXRJZCk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlUE1UKGRhdGEsIG9mZnNldCwgbXBlZ1N1cHBvcnRlZCwgaXNTYW1wbGVBZXMpIHtcbiAgdmFyIHJlc3VsdCA9IHtcbiAgICBhdWRpbzogLTEsXG4gICAgYXZjOiAtMSxcbiAgICBpZDM6IC0xLFxuICAgIGlzQUFDOiB0cnVlXG4gIH07XG4gIHZhciBzZWN0aW9uTGVuZ3RoID0gKGRhdGFbb2Zmc2V0ICsgMV0gJiAweDBmKSA8PCA4IHwgZGF0YVtvZmZzZXQgKyAyXTtcbiAgdmFyIHRhYmxlRW5kID0gb2Zmc2V0ICsgMyArIHNlY3Rpb25MZW5ndGggLSA0OyAvLyB0byBkZXRlcm1pbmUgd2hlcmUgdGhlIHRhYmxlIGlzLCB3ZSBoYXZlIHRvIGZpZ3VyZSBvdXQgaG93XG4gIC8vIGxvbmcgdGhlIHByb2dyYW0gaW5mbyBkZXNjcmlwdG9ycyBhcmVcblxuICB2YXIgcHJvZ3JhbUluZm9MZW5ndGggPSAoZGF0YVtvZmZzZXQgKyAxMF0gJiAweDBmKSA8PCA4IHwgZGF0YVtvZmZzZXQgKyAxMV07IC8vIGFkdmFuY2UgdGhlIG9mZnNldCB0byB0aGUgZmlyc3QgZW50cnkgaW4gdGhlIG1hcHBpbmcgdGFibGVcblxuICBvZmZzZXQgKz0gMTIgKyBwcm9ncmFtSW5mb0xlbmd0aDtcblxuICB3aGlsZSAob2Zmc2V0IDwgdGFibGVFbmQpIHtcbiAgICB2YXIgcGlkID0gKGRhdGFbb2Zmc2V0ICsgMV0gJiAweDFmKSA8PCA4IHwgZGF0YVtvZmZzZXQgKyAyXTtcblxuICAgIHN3aXRjaCAoZGF0YVtvZmZzZXRdKSB7XG4gICAgICBjYXNlIDB4Y2Y6XG4gICAgICAgIC8vIFNBTVBMRS1BRVMgQUFDXG4gICAgICAgIGlmICghaXNTYW1wbGVBZXMpIHtcbiAgICAgICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bXCJsb2dnZXJcIl0ubG9nKCdBRFRTIEFBQyB3aXRoIEFFUy0xMjgtQ0JDIGZyYW1lIGVuY3J5cHRpb24gZm91bmQgaW4gdW5lbmNyeXB0ZWQgc3RyZWFtJyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuXG4gICAgICBjYXNlIDB4MGY6XG4gICAgICAgIC8vIElTTy9JRUMgMTM4MTgtNyBBRFRTIEFBQyAoTVBFRy0yIGxvd2VyIGJpdC1yYXRlIGF1ZGlvKVxuICAgICAgICAvLyBsb2dnZXIubG9nKCdBQUMgUElEOicgICsgcGlkKTtcbiAgICAgICAgaWYgKHJlc3VsdC5hdWRpbyA9PT0gLTEpIHtcbiAgICAgICAgICByZXN1bHQuYXVkaW8gPSBwaWQ7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIC8vIFBhY2tldGl6ZWQgbWV0YWRhdGEgKElEMylcblxuICAgICAgY2FzZSAweDE1OlxuICAgICAgICAvLyBsb2dnZXIubG9nKCdJRDMgUElEOicgICsgcGlkKTtcbiAgICAgICAgaWYgKHJlc3VsdC5pZDMgPT09IC0xKSB7XG4gICAgICAgICAgcmVzdWx0LmlkMyA9IHBpZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDB4ZGI6XG4gICAgICAgIC8vIFNBTVBMRS1BRVMgQVZDXG4gICAgICAgIGlmICghaXNTYW1wbGVBZXMpIHtcbiAgICAgICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bXCJsb2dnZXJcIl0ubG9nKCdILjI2NCB3aXRoIEFFUy0xMjgtQ0JDIHNsaWNlIGVuY3J5cHRpb24gZm91bmQgaW4gdW5lbmNyeXB0ZWQgc3RyZWFtJyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuXG4gICAgICBjYXNlIDB4MWI6XG4gICAgICAgIC8vIElUVS1UIFJlYy4gSC4yNjQgYW5kIElTTy9JRUMgMTQ0OTYtMTAgKGxvd2VyIGJpdC1yYXRlIHZpZGVvKVxuICAgICAgICAvLyBsb2dnZXIubG9nKCdBVkMgUElEOicgICsgcGlkKTtcbiAgICAgICAgaWYgKHJlc3VsdC5hdmMgPT09IC0xKSB7XG4gICAgICAgICAgcmVzdWx0LmF2YyA9IHBpZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgLy8gSVNPL0lFQyAxMTE3Mi0zIChNUEVHLTEgYXVkaW8pXG4gICAgICAvLyBvciBJU08vSUVDIDEzODE4LTMgKE1QRUctMiBoYWx2ZWQgc2FtcGxlIHJhdGUgYXVkaW8pXG5cbiAgICAgIGNhc2UgMHgwMzpcbiAgICAgIGNhc2UgMHgwNDpcbiAgICAgICAgLy8gbG9nZ2VyLmxvZygnTVBFRyBQSUQ6JyAgKyBwaWQpO1xuICAgICAgICBpZiAoIW1wZWdTdXBwb3J0ZWQpIHtcbiAgICAgICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bXCJsb2dnZXJcIl0ubG9nKCdNUEVHIGF1ZGlvIGZvdW5kLCBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3NlcicpO1xuICAgICAgICB9IGVsc2UgaWYgKHJlc3VsdC5hdWRpbyA9PT0gLTEpIHtcbiAgICAgICAgICByZXN1bHQuYXVkaW8gPSBwaWQ7XG4gICAgICAgICAgcmVzdWx0LmlzQUFDID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAweDI0OlxuICAgICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bXCJsb2dnZXJcIl0ud2FybignVW5zdXBwb3J0ZWQgSEVWQyBzdHJlYW0gdHlwZSBmb3VuZCcpO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgLy8gbG9nZ2VyLmxvZygndW5rbm93biBzdHJlYW0gdHlwZTonICsgZGF0YVtvZmZzZXRdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfSAvLyBtb3ZlIHRvIHRoZSBuZXh0IHRhYmxlIGVudHJ5XG4gICAgLy8gc2tpcCBwYXN0IHRoZSBlbGVtZW50YXJ5IHN0cmVhbSBkZXNjcmlwdG9ycywgaWYgcHJlc2VudFxuXG5cbiAgICBvZmZzZXQgKz0gKChkYXRhW29mZnNldCArIDNdICYgMHgwZikgPDwgOCB8IGRhdGFbb2Zmc2V0ICsgNF0pICsgNTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIHBhcnNlUEVTKHN0cmVhbSkge1xuICB2YXIgaSA9IDA7XG4gIHZhciBmcmFnO1xuICB2YXIgcGVzTGVuO1xuICB2YXIgcGVzSGRyTGVuO1xuICB2YXIgcGVzUHRzO1xuICB2YXIgcGVzRHRzO1xuICB2YXIgZGF0YSA9IHN0cmVhbS5kYXRhOyAvLyBzYWZldHkgY2hlY2tcblxuICBpZiAoIXN0cmVhbSB8fCBzdHJlYW0uc2l6ZSA9PT0gMCkge1xuICAgIHJldHVybiBudWxsO1xuICB9IC8vIHdlIG1pZ2h0IG5lZWQgdXAgdG8gMTkgYnl0ZXMgdG8gcmVhZCBQRVMgaGVhZGVyXG4gIC8vIGlmIGZpcnN0IGNodW5rIG9mIGRhdGEgaXMgbGVzcyB0aGFuIDE5IGJ5dGVzLCBsZXQncyBtZXJnZSBpdCB3aXRoIGZvbGxvd2luZyBvbmVzIHVudGlsIHdlIGdldCAxOSBieXRlc1xuICAvLyB1c3VhbGx5IG9ubHkgb25lIG1lcmdlIGlzIG5lZWRlZCAoYW5kIHRoaXMgaXMgcmFyZSAuLi4pXG5cblxuICB3aGlsZSAoZGF0YVswXS5sZW5ndGggPCAxOSAmJiBkYXRhLmxlbmd0aCA+IDEpIHtcbiAgICB2YXIgbmV3RGF0YSA9IG5ldyBVaW50OEFycmF5KGRhdGFbMF0ubGVuZ3RoICsgZGF0YVsxXS5sZW5ndGgpO1xuICAgIG5ld0RhdGEuc2V0KGRhdGFbMF0pO1xuICAgIG5ld0RhdGEuc2V0KGRhdGFbMV0sIGRhdGFbMF0ubGVuZ3RoKTtcbiAgICBkYXRhWzBdID0gbmV3RGF0YTtcbiAgICBkYXRhLnNwbGljZSgxLCAxKTtcbiAgfSAvLyByZXRyaWV2ZSBQVFMvRFRTIGZyb20gZmlyc3QgZnJhZ21lbnRcblxuXG4gIGZyYWcgPSBkYXRhWzBdO1xuICB2YXIgcGVzUHJlZml4ID0gKGZyYWdbMF0gPDwgMTYpICsgKGZyYWdbMV0gPDwgOCkgKyBmcmFnWzJdO1xuXG4gIGlmIChwZXNQcmVmaXggPT09IDEpIHtcbiAgICBwZXNMZW4gPSAoZnJhZ1s0XSA8PCA4KSArIGZyYWdbNV07IC8vIGlmIFBFUyBwYXJzZWQgbGVuZ3RoIGlzIG5vdCB6ZXJvIGFuZCBncmVhdGVyIHRoYW4gdG90YWwgcmVjZWl2ZWQgbGVuZ3RoLCBzdG9wIHBhcnNpbmcuIFBFUyBtaWdodCBiZSB0cnVuY2F0ZWRcbiAgICAvLyBtaW51cyA2IDogUEVTIGhlYWRlciBzaXplXG5cbiAgICBpZiAocGVzTGVuICYmIHBlc0xlbiA+IHN0cmVhbS5zaXplIC0gNikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIHBlc0ZsYWdzID0gZnJhZ1s3XTtcblxuICAgIGlmIChwZXNGbGFncyAmIDB4YzApIHtcbiAgICAgIC8qIFBFUyBoZWFkZXIgZGVzY3JpYmVkIGhlcmUgOiBodHRwOi8vZHZkLnNvdXJjZWZvcmdlLm5ldC9kdmRpbmZvL3Blcy1oZHIuaHRtbFxuICAgICAgICAgIGFzIFBUUyAvIERUUyBpcyAzMyBiaXQgd2UgY2Fubm90IHVzZSBiaXR3aXNlIG9wZXJhdG9yIGluIEpTLFxuICAgICAgICAgIGFzIEJpdHdpc2Ugb3BlcmF0b3JzIHRyZWF0IHRoZWlyIG9wZXJhbmRzIGFzIGEgc2VxdWVuY2Ugb2YgMzIgYml0cyAqL1xuICAgICAgcGVzUHRzID0gKGZyYWdbOV0gJiAweDBlKSAqIDUzNjg3MDkxMiArIC8vIDEgPDwgMjlcbiAgICAgIChmcmFnWzEwXSAmIDB4ZmYpICogNDE5NDMwNCArIC8vIDEgPDwgMjJcbiAgICAgIChmcmFnWzExXSAmIDB4ZmUpICogMTYzODQgKyAvLyAxIDw8IDE0XG4gICAgICAoZnJhZ1sxMl0gJiAweGZmKSAqIDEyOCArIC8vIDEgPDwgN1xuICAgICAgKGZyYWdbMTNdICYgMHhmZSkgLyAyO1xuXG4gICAgICBpZiAocGVzRmxhZ3MgJiAweDQwKSB7XG4gICAgICAgIHBlc0R0cyA9IChmcmFnWzE0XSAmIDB4MGUpICogNTM2ODcwOTEyICsgLy8gMSA8PCAyOVxuICAgICAgICAoZnJhZ1sxNV0gJiAweGZmKSAqIDQxOTQzMDQgKyAvLyAxIDw8IDIyXG4gICAgICAgIChmcmFnWzE2XSAmIDB4ZmUpICogMTYzODQgKyAvLyAxIDw8IDE0XG4gICAgICAgIChmcmFnWzE3XSAmIDB4ZmYpICogMTI4ICsgLy8gMSA8PCA3XG4gICAgICAgIChmcmFnWzE4XSAmIDB4ZmUpIC8gMjtcblxuICAgICAgICBpZiAocGVzUHRzIC0gcGVzRHRzID4gNjAgKiA5MDAwMCkge1xuICAgICAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1tcImxvZ2dlclwiXS53YXJuKE1hdGgucm91bmQoKHBlc1B0cyAtIHBlc0R0cykgLyA5MDAwMCkgKyBcInMgZGVsdGEgYmV0d2VlbiBQVFMgYW5kIERUUywgYWxpZ24gdGhlbVwiKTtcbiAgICAgICAgICBwZXNQdHMgPSBwZXNEdHM7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBlc0R0cyA9IHBlc1B0cztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBwZXNIZHJMZW4gPSBmcmFnWzhdOyAvLyA5IGJ5dGVzIDogNiBieXRlcyBmb3IgUEVTIGhlYWRlciArIDMgYnl0ZXMgZm9yIFBFUyBleHRlbnNpb25cblxuICAgIHZhciBwYXlsb2FkU3RhcnRPZmZzZXQgPSBwZXNIZHJMZW4gKyA5O1xuXG4gICAgaWYgKHN0cmVhbS5zaXplIDw9IHBheWxvYWRTdGFydE9mZnNldCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgc3RyZWFtLnNpemUgLT0gcGF5bG9hZFN0YXJ0T2Zmc2V0OyAvLyByZWFzc2VtYmxlIFBFUyBwYWNrZXRcblxuICAgIHZhciBwZXNEYXRhID0gbmV3IFVpbnQ4QXJyYXkoc3RyZWFtLnNpemUpO1xuXG4gICAgZm9yICh2YXIgaiA9IDAsIGRhdGFMZW4gPSBkYXRhLmxlbmd0aDsgaiA8IGRhdGFMZW47IGorKykge1xuICAgICAgZnJhZyA9IGRhdGFbal07XG4gICAgICB2YXIgbGVuID0gZnJhZy5ieXRlTGVuZ3RoO1xuXG4gICAgICBpZiAocGF5bG9hZFN0YXJ0T2Zmc2V0KSB7XG4gICAgICAgIGlmIChwYXlsb2FkU3RhcnRPZmZzZXQgPiBsZW4pIHtcbiAgICAgICAgICAvLyB0cmltIGZ1bGwgZnJhZyBpZiBQRVMgaGVhZGVyIGJpZ2dlciB0aGFuIGZyYWdcbiAgICAgICAgICBwYXlsb2FkU3RhcnRPZmZzZXQgLT0gbGVuO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHRyaW0gcGFydGlhbCBmcmFnIGlmIFBFUyBoZWFkZXIgc21hbGxlciB0aGFuIGZyYWdcbiAgICAgICAgICBmcmFnID0gZnJhZy5zdWJhcnJheShwYXlsb2FkU3RhcnRPZmZzZXQpO1xuICAgICAgICAgIGxlbiAtPSBwYXlsb2FkU3RhcnRPZmZzZXQ7XG4gICAgICAgICAgcGF5bG9hZFN0YXJ0T2Zmc2V0ID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBwZXNEYXRhLnNldChmcmFnLCBpKTtcbiAgICAgIGkgKz0gbGVuO1xuICAgIH1cblxuICAgIGlmIChwZXNMZW4pIHtcbiAgICAgIC8vIHBheWxvYWQgc2l6ZSA6IHJlbW92ZSBQRVMgaGVhZGVyICsgUEVTIGV4dGVuc2lvblxuICAgICAgcGVzTGVuIC09IHBlc0hkckxlbiArIDM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGRhdGE6IHBlc0RhdGEsXG4gICAgICBwdHM6IHBlc1B0cyxcbiAgICAgIGR0czogcGVzRHRzLFxuICAgICAgbGVuOiBwZXNMZW5cbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIHB1c2hBY2Nlc3NVbml0KGF2Y1NhbXBsZSwgYXZjVHJhY2spIHtcbiAgaWYgKGF2Y1NhbXBsZS51bml0cy5sZW5ndGggJiYgYXZjU2FtcGxlLmZyYW1lKSB7XG4gICAgLy8gaWYgc2FtcGxlIGRvZXMgbm90IGhhdmUgUFRTL0RUUywgcGF0Y2ggd2l0aCBsYXN0IHNhbXBsZSBQVFMvRFRTXG4gICAgaWYgKGF2Y1NhbXBsZS5wdHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIHNhbXBsZXMgPSBhdmNUcmFjay5zYW1wbGVzO1xuICAgICAgdmFyIG5iU2FtcGxlcyA9IHNhbXBsZXMubGVuZ3RoO1xuXG4gICAgICBpZiAobmJTYW1wbGVzKSB7XG4gICAgICAgIHZhciBsYXN0U2FtcGxlID0gc2FtcGxlc1tuYlNhbXBsZXMgLSAxXTtcbiAgICAgICAgYXZjU2FtcGxlLnB0cyA9IGxhc3RTYW1wbGUucHRzO1xuICAgICAgICBhdmNTYW1wbGUuZHRzID0gbGFzdFNhbXBsZS5kdHM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBkcm9wcGluZyBzYW1wbGVzLCBubyB0aW1lc3RhbXAgZm91bmRcbiAgICAgICAgYXZjVHJhY2suZHJvcHBlZCsrO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgYXZjVHJhY2suc2FtcGxlcy5wdXNoKGF2Y1NhbXBsZSk7XG4gIH1cblxuICBpZiAoYXZjU2FtcGxlLmRlYnVnLmxlbmd0aCkge1xuICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1tcImxvZ2dlclwiXS5sb2coYXZjU2FtcGxlLnB0cyArICcvJyArIGF2Y1NhbXBsZS5kdHMgKyAnOicgKyBhdmNTYW1wbGUuZGVidWcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluc2VydFNhbXBsZUluT3JkZXIoYXJyLCBkYXRhKSB7XG4gIHZhciBsZW4gPSBhcnIubGVuZ3RoO1xuXG4gIGlmIChsZW4gPiAwKSB7XG4gICAgaWYgKGRhdGEucHRzID49IGFycltsZW4gLSAxXS5wdHMpIHtcbiAgICAgIGFyci5wdXNoKGRhdGEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKHZhciBwb3MgPSBsZW4gLSAxOyBwb3MgPj0gMDsgcG9zLS0pIHtcbiAgICAgICAgaWYgKGRhdGEucHRzIDwgYXJyW3Bvc10ucHRzKSB7XG4gICAgICAgICAgYXJyLnNwbGljZShwb3MsIDAsIGRhdGEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGFyci5wdXNoKGRhdGEpO1xuICB9XG59XG4vKipcbiAqIHJlbW92ZSBFbXVsYXRpb24gUHJldmVudGlvbiBieXRlcyBmcm9tIGEgUkJTUFxuICovXG5cblxuZnVuY3Rpb24gZGlzY2FyZEVQQihkYXRhKSB7XG4gIHZhciBsZW5ndGggPSBkYXRhLmJ5dGVMZW5ndGg7XG4gIHZhciBFUEJQb3NpdGlvbnMgPSBbXTtcbiAgdmFyIGkgPSAxOyAvLyBGaW5kIGFsbCBgRW11bGF0aW9uIFByZXZlbnRpb24gQnl0ZXNgXG5cbiAgd2hpbGUgKGkgPCBsZW5ndGggLSAyKSB7XG4gICAgaWYgKGRhdGFbaV0gPT09IDAgJiYgZGF0YVtpICsgMV0gPT09IDAgJiYgZGF0YVtpICsgMl0gPT09IDB4MDMpIHtcbiAgICAgIEVQQlBvc2l0aW9ucy5wdXNoKGkgKyAyKTtcbiAgICAgIGkgKz0gMjtcbiAgICB9IGVsc2Uge1xuICAgICAgaSsrO1xuICAgIH1cbiAgfSAvLyBJZiBubyBFbXVsYXRpb24gUHJldmVudGlvbiBCeXRlcyB3ZXJlIGZvdW5kIGp1c3QgcmV0dXJuIHRoZSBvcmlnaW5hbFxuICAvLyBhcnJheVxuXG5cbiAgaWYgKEVQQlBvc2l0aW9ucy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gZGF0YTtcbiAgfSAvLyBDcmVhdGUgYSBuZXcgYXJyYXkgdG8gaG9sZCB0aGUgTkFMIHVuaXQgZGF0YVxuXG5cbiAgdmFyIG5ld0xlbmd0aCA9IGxlbmd0aCAtIEVQQlBvc2l0aW9ucy5sZW5ndGg7XG4gIHZhciBuZXdEYXRhID0gbmV3IFVpbnQ4QXJyYXkobmV3TGVuZ3RoKTtcbiAgdmFyIHNvdXJjZUluZGV4ID0gMDtcblxuICBmb3IgKGkgPSAwOyBpIDwgbmV3TGVuZ3RoOyBzb3VyY2VJbmRleCsrLCBpKyspIHtcbiAgICBpZiAoc291cmNlSW5kZXggPT09IEVQQlBvc2l0aW9uc1swXSkge1xuICAgICAgLy8gU2tpcCB0aGlzIGJ5dGVcbiAgICAgIHNvdXJjZUluZGV4Kys7IC8vIFJlbW92ZSB0aGlzIHBvc2l0aW9uIGluZGV4XG5cbiAgICAgIEVQQlBvc2l0aW9ucy5zaGlmdCgpO1xuICAgIH1cblxuICAgIG5ld0RhdGFbaV0gPSBkYXRhW3NvdXJjZUluZGV4XTtcbiAgfVxuXG4gIHJldHVybiBuZXdEYXRhO1xufVxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChUU0RlbXV4ZXIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9lcnJvcnMudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2Vycm9ycy50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogRXJyb3JUeXBlcywgRXJyb3JEZXRhaWxzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIkVycm9yVHlwZXNcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBFcnJvclR5cGVzOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJFcnJvckRldGFpbHNcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBFcnJvckRldGFpbHM7IH0pO1xudmFyIEVycm9yVHlwZXM7XG4vKipcbiAqIEBlbnVtIHtFcnJvckRldGFpbHN9XG4gKiBAdHlwZWRlZiB7c3RyaW5nfSBFcnJvckRldGFpbFxuICovXG5cbihmdW5jdGlvbiAoRXJyb3JUeXBlcykge1xuICBFcnJvclR5cGVzW1wiTkVUV09SS19FUlJPUlwiXSA9IFwibmV0d29ya0Vycm9yXCI7XG4gIEVycm9yVHlwZXNbXCJNRURJQV9FUlJPUlwiXSA9IFwibWVkaWFFcnJvclwiO1xuICBFcnJvclR5cGVzW1wiS0VZX1NZU1RFTV9FUlJPUlwiXSA9IFwia2V5U3lzdGVtRXJyb3JcIjtcbiAgRXJyb3JUeXBlc1tcIk1VWF9FUlJPUlwiXSA9IFwibXV4RXJyb3JcIjtcbiAgRXJyb3JUeXBlc1tcIk9USEVSX0VSUk9SXCJdID0gXCJvdGhlckVycm9yXCI7XG59KShFcnJvclR5cGVzIHx8IChFcnJvclR5cGVzID0ge30pKTtcblxudmFyIEVycm9yRGV0YWlscztcblxuKGZ1bmN0aW9uIChFcnJvckRldGFpbHMpIHtcbiAgRXJyb3JEZXRhaWxzW1wiS0VZX1NZU1RFTV9OT19LRVlTXCJdID0gXCJrZXlTeXN0ZW1Ob0tleXNcIjtcbiAgRXJyb3JEZXRhaWxzW1wiS0VZX1NZU1RFTV9OT19BQ0NFU1NcIl0gPSBcImtleVN5c3RlbU5vQWNjZXNzXCI7XG4gIEVycm9yRGV0YWlsc1tcIktFWV9TWVNURU1fTk9fU0VTU0lPTlwiXSA9IFwia2V5U3lzdGVtTm9TZXNzaW9uXCI7XG4gIEVycm9yRGV0YWlsc1tcIktFWV9TWVNURU1fTElDRU5TRV9SRVFVRVNUX0ZBSUxFRFwiXSA9IFwia2V5U3lzdGVtTGljZW5zZVJlcXVlc3RGYWlsZWRcIjtcbiAgRXJyb3JEZXRhaWxzW1wiS0VZX1NZU1RFTV9OT19JTklUX0RBVEFcIl0gPSBcImtleVN5c3RlbU5vSW5pdERhdGFcIjtcbiAgRXJyb3JEZXRhaWxzW1wiTUFOSUZFU1RfTE9BRF9FUlJPUlwiXSA9IFwibWFuaWZlc3RMb2FkRXJyb3JcIjtcbiAgRXJyb3JEZXRhaWxzW1wiTUFOSUZFU1RfTE9BRF9USU1FT1VUXCJdID0gXCJtYW5pZmVzdExvYWRUaW1lT3V0XCI7XG4gIEVycm9yRGV0YWlsc1tcIk1BTklGRVNUX1BBUlNJTkdfRVJST1JcIl0gPSBcIm1hbmlmZXN0UGFyc2luZ0Vycm9yXCI7XG4gIEVycm9yRGV0YWlsc1tcIk1BTklGRVNUX0lOQ09NUEFUSUJMRV9DT0RFQ1NfRVJST1JcIl0gPSBcIm1hbmlmZXN0SW5jb21wYXRpYmxlQ29kZWNzRXJyb3JcIjtcbiAgRXJyb3JEZXRhaWxzW1wiTEVWRUxfRU1QVFlfRVJST1JcIl0gPSBcImxldmVsRW1wdHlFcnJvclwiO1xuICBFcnJvckRldGFpbHNbXCJMRVZFTF9MT0FEX0VSUk9SXCJdID0gXCJsZXZlbExvYWRFcnJvclwiO1xuICBFcnJvckRldGFpbHNbXCJMRVZFTF9MT0FEX1RJTUVPVVRcIl0gPSBcImxldmVsTG9hZFRpbWVPdXRcIjtcbiAgRXJyb3JEZXRhaWxzW1wiTEVWRUxfU1dJVENIX0VSUk9SXCJdID0gXCJsZXZlbFN3aXRjaEVycm9yXCI7XG4gIEVycm9yRGV0YWlsc1tcIkFVRElPX1RSQUNLX0xPQURfRVJST1JcIl0gPSBcImF1ZGlvVHJhY2tMb2FkRXJyb3JcIjtcbiAgRXJyb3JEZXRhaWxzW1wiQVVESU9fVFJBQ0tfTE9BRF9USU1FT1VUXCJdID0gXCJhdWRpb1RyYWNrTG9hZFRpbWVPdXRcIjtcbiAgRXJyb3JEZXRhaWxzW1wiU1VCVElUTEVfTE9BRF9FUlJPUlwiXSA9IFwic3VidGl0bGVUcmFja0xvYWRFcnJvclwiO1xuICBFcnJvckRldGFpbHNbXCJTVUJUSVRMRV9UUkFDS19MT0FEX1RJTUVPVVRcIl0gPSBcInN1YnRpdGxlVHJhY2tMb2FkVGltZU91dFwiO1xuICBFcnJvckRldGFpbHNbXCJGUkFHX0xPQURfRVJST1JcIl0gPSBcImZyYWdMb2FkRXJyb3JcIjtcbiAgRXJyb3JEZXRhaWxzW1wiRlJBR19MT0FEX1RJTUVPVVRcIl0gPSBcImZyYWdMb2FkVGltZU91dFwiO1xuICBFcnJvckRldGFpbHNbXCJGUkFHX0RFQ1JZUFRfRVJST1JcIl0gPSBcImZyYWdEZWNyeXB0RXJyb3JcIjtcbiAgRXJyb3JEZXRhaWxzW1wiRlJBR19QQVJTSU5HX0VSUk9SXCJdID0gXCJmcmFnUGFyc2luZ0Vycm9yXCI7XG4gIEVycm9yRGV0YWlsc1tcIlJFTVVYX0FMTE9DX0VSUk9SXCJdID0gXCJyZW11eEFsbG9jRXJyb3JcIjtcbiAgRXJyb3JEZXRhaWxzW1wiS0VZX0xPQURfRVJST1JcIl0gPSBcImtleUxvYWRFcnJvclwiO1xuICBFcnJvckRldGFpbHNbXCJLRVlfTE9BRF9USU1FT1VUXCJdID0gXCJrZXlMb2FkVGltZU91dFwiO1xuICBFcnJvckRldGFpbHNbXCJCVUZGRVJfQUREX0NPREVDX0VSUk9SXCJdID0gXCJidWZmZXJBZGRDb2RlY0Vycm9yXCI7XG4gIEVycm9yRGV0YWlsc1tcIkJVRkZFUl9JTkNPTVBBVElCTEVfQ09ERUNTX0VSUk9SXCJdID0gXCJidWZmZXJJbmNvbXBhdGlibGVDb2RlY3NFcnJvclwiO1xuICBFcnJvckRldGFpbHNbXCJCVUZGRVJfQVBQRU5EX0VSUk9SXCJdID0gXCJidWZmZXJBcHBlbmRFcnJvclwiO1xuICBFcnJvckRldGFpbHNbXCJCVUZGRVJfQVBQRU5ESU5HX0VSUk9SXCJdID0gXCJidWZmZXJBcHBlbmRpbmdFcnJvclwiO1xuICBFcnJvckRldGFpbHNbXCJCVUZGRVJfU1RBTExFRF9FUlJPUlwiXSA9IFwiYnVmZmVyU3RhbGxlZEVycm9yXCI7XG4gIEVycm9yRGV0YWlsc1tcIkJVRkZFUl9GVUxMX0VSUk9SXCJdID0gXCJidWZmZXJGdWxsRXJyb3JcIjtcbiAgRXJyb3JEZXRhaWxzW1wiQlVGRkVSX1NFRUtfT1ZFUl9IT0xFXCJdID0gXCJidWZmZXJTZWVrT3ZlckhvbGVcIjtcbiAgRXJyb3JEZXRhaWxzW1wiQlVGRkVSX05VREdFX09OX1NUQUxMXCJdID0gXCJidWZmZXJOdWRnZU9uU3RhbGxcIjtcbiAgRXJyb3JEZXRhaWxzW1wiSU5URVJOQUxfRVhDRVBUSU9OXCJdID0gXCJpbnRlcm5hbEV4Y2VwdGlvblwiO1xuICBFcnJvckRldGFpbHNbXCJJTlRFUk5BTF9BQk9SVEVEXCJdID0gXCJhYm9ydGVkXCI7XG4gIEVycm9yRGV0YWlsc1tcIlVOS05PV05cIl0gPSBcInVua25vd25cIjtcbn0pKEVycm9yRGV0YWlscyB8fCAoRXJyb3JEZXRhaWxzID0ge30pKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvZXZlbnRzLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9ldmVudHMudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IEV2ZW50cyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJFdmVudHNcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBFdmVudHM7IH0pO1xuLyoqXG4gKiBAcmVhZG9ubHlcbiAqIEBlbnVtIHtzdHJpbmd9XG4gKi9cbnZhciBFdmVudHM7XG5cbihmdW5jdGlvbiAoRXZlbnRzKSB7XG4gIEV2ZW50c1tcIk1FRElBX0FUVEFDSElOR1wiXSA9IFwiaGxzTWVkaWFBdHRhY2hpbmdcIjtcbiAgRXZlbnRzW1wiTUVESUFfQVRUQUNIRURcIl0gPSBcImhsc01lZGlhQXR0YWNoZWRcIjtcbiAgRXZlbnRzW1wiTUVESUFfREVUQUNISU5HXCJdID0gXCJobHNNZWRpYURldGFjaGluZ1wiO1xuICBFdmVudHNbXCJNRURJQV9ERVRBQ0hFRFwiXSA9IFwiaGxzTWVkaWFEZXRhY2hlZFwiO1xuICBFdmVudHNbXCJCVUZGRVJfUkVTRVRcIl0gPSBcImhsc0J1ZmZlclJlc2V0XCI7XG4gIEV2ZW50c1tcIkJVRkZFUl9DT0RFQ1NcIl0gPSBcImhsc0J1ZmZlckNvZGVjc1wiO1xuICBFdmVudHNbXCJCVUZGRVJfQ1JFQVRFRFwiXSA9IFwiaGxzQnVmZmVyQ3JlYXRlZFwiO1xuICBFdmVudHNbXCJCVUZGRVJfQVBQRU5ESU5HXCJdID0gXCJobHNCdWZmZXJBcHBlbmRpbmdcIjtcbiAgRXZlbnRzW1wiQlVGRkVSX0FQUEVOREVEXCJdID0gXCJobHNCdWZmZXJBcHBlbmRlZFwiO1xuICBFdmVudHNbXCJCVUZGRVJfRU9TXCJdID0gXCJobHNCdWZmZXJFb3NcIjtcbiAgRXZlbnRzW1wiQlVGRkVSX0ZMVVNISU5HXCJdID0gXCJobHNCdWZmZXJGbHVzaGluZ1wiO1xuICBFdmVudHNbXCJCVUZGRVJfRkxVU0hFRFwiXSA9IFwiaGxzQnVmZmVyRmx1c2hlZFwiO1xuICBFdmVudHNbXCJNQU5JRkVTVF9MT0FESU5HXCJdID0gXCJobHNNYW5pZmVzdExvYWRpbmdcIjtcbiAgRXZlbnRzW1wiTUFOSUZFU1RfTE9BREVEXCJdID0gXCJobHNNYW5pZmVzdExvYWRlZFwiO1xuICBFdmVudHNbXCJNQU5JRkVTVF9QQVJTRURcIl0gPSBcImhsc01hbmlmZXN0UGFyc2VkXCI7XG4gIEV2ZW50c1tcIkxFVkVMX1NXSVRDSElOR1wiXSA9IFwiaGxzTGV2ZWxTd2l0Y2hpbmdcIjtcbiAgRXZlbnRzW1wiTEVWRUxfU1dJVENIRURcIl0gPSBcImhsc0xldmVsU3dpdGNoZWRcIjtcbiAgRXZlbnRzW1wiTEVWRUxfTE9BRElOR1wiXSA9IFwiaGxzTGV2ZWxMb2FkaW5nXCI7XG4gIEV2ZW50c1tcIkxFVkVMX0xPQURFRFwiXSA9IFwiaGxzTGV2ZWxMb2FkZWRcIjtcbiAgRXZlbnRzW1wiTEVWRUxfVVBEQVRFRFwiXSA9IFwiaGxzTGV2ZWxVcGRhdGVkXCI7XG4gIEV2ZW50c1tcIkxFVkVMX1BUU19VUERBVEVEXCJdID0gXCJobHNMZXZlbFB0c1VwZGF0ZWRcIjtcbiAgRXZlbnRzW1wiTEVWRUxTX1VQREFURURcIl0gPSBcImhsc0xldmVsc1VwZGF0ZWRcIjtcbiAgRXZlbnRzW1wiQVVESU9fVFJBQ0tTX1VQREFURURcIl0gPSBcImhsc0F1ZGlvVHJhY2tzVXBkYXRlZFwiO1xuICBFdmVudHNbXCJBVURJT19UUkFDS19TV0lUQ0hJTkdcIl0gPSBcImhsc0F1ZGlvVHJhY2tTd2l0Y2hpbmdcIjtcbiAgRXZlbnRzW1wiQVVESU9fVFJBQ0tfU1dJVENIRURcIl0gPSBcImhsc0F1ZGlvVHJhY2tTd2l0Y2hlZFwiO1xuICBFdmVudHNbXCJBVURJT19UUkFDS19MT0FESU5HXCJdID0gXCJobHNBdWRpb1RyYWNrTG9hZGluZ1wiO1xuICBFdmVudHNbXCJBVURJT19UUkFDS19MT0FERURcIl0gPSBcImhsc0F1ZGlvVHJhY2tMb2FkZWRcIjtcbiAgRXZlbnRzW1wiU1VCVElUTEVfVFJBQ0tTX1VQREFURURcIl0gPSBcImhsc1N1YnRpdGxlVHJhY2tzVXBkYXRlZFwiO1xuICBFdmVudHNbXCJTVUJUSVRMRV9UUkFDS1NfQ0xFQVJFRFwiXSA9IFwiaGxzU3VidGl0bGVUcmFja3NDbGVhcmVkXCI7XG4gIEV2ZW50c1tcIlNVQlRJVExFX1RSQUNLX1NXSVRDSFwiXSA9IFwiaGxzU3VidGl0bGVUcmFja1N3aXRjaFwiO1xuICBFdmVudHNbXCJTVUJUSVRMRV9UUkFDS19MT0FESU5HXCJdID0gXCJobHNTdWJ0aXRsZVRyYWNrTG9hZGluZ1wiO1xuICBFdmVudHNbXCJTVUJUSVRMRV9UUkFDS19MT0FERURcIl0gPSBcImhsc1N1YnRpdGxlVHJhY2tMb2FkZWRcIjtcbiAgRXZlbnRzW1wiU1VCVElUTEVfRlJBR19QUk9DRVNTRURcIl0gPSBcImhsc1N1YnRpdGxlRnJhZ1Byb2Nlc3NlZFwiO1xuICBFdmVudHNbXCJDVUVTX1BBUlNFRFwiXSA9IFwiaGxzQ3Vlc1BhcnNlZFwiO1xuICBFdmVudHNbXCJOT05fTkFUSVZFX1RFWFRfVFJBQ0tTX0ZPVU5EXCJdID0gXCJobHNOb25OYXRpdmVUZXh0VHJhY2tzRm91bmRcIjtcbiAgRXZlbnRzW1wiSU5JVF9QVFNfRk9VTkRcIl0gPSBcImhsc0luaXRQdHNGb3VuZFwiO1xuICBFdmVudHNbXCJGUkFHX0xPQURJTkdcIl0gPSBcImhsc0ZyYWdMb2FkaW5nXCI7XG4gIEV2ZW50c1tcIkZSQUdfTE9BRF9FTUVSR0VOQ1lfQUJPUlRFRFwiXSA9IFwiaGxzRnJhZ0xvYWRFbWVyZ2VuY3lBYm9ydGVkXCI7XG4gIEV2ZW50c1tcIkZSQUdfTE9BREVEXCJdID0gXCJobHNGcmFnTG9hZGVkXCI7XG4gIEV2ZW50c1tcIkZSQUdfREVDUllQVEVEXCJdID0gXCJobHNGcmFnRGVjcnlwdGVkXCI7XG4gIEV2ZW50c1tcIkZSQUdfUEFSU0lOR19JTklUX1NFR01FTlRcIl0gPSBcImhsc0ZyYWdQYXJzaW5nSW5pdFNlZ21lbnRcIjtcbiAgRXZlbnRzW1wiRlJBR19QQVJTSU5HX1VTRVJEQVRBXCJdID0gXCJobHNGcmFnUGFyc2luZ1VzZXJkYXRhXCI7XG4gIEV2ZW50c1tcIkZSQUdfUEFSU0lOR19NRVRBREFUQVwiXSA9IFwiaGxzRnJhZ1BhcnNpbmdNZXRhZGF0YVwiO1xuICBFdmVudHNbXCJGUkFHX1BBUlNFRFwiXSA9IFwiaGxzRnJhZ1BhcnNlZFwiO1xuICBFdmVudHNbXCJGUkFHX0JVRkZFUkVEXCJdID0gXCJobHNGcmFnQnVmZmVyZWRcIjtcbiAgRXZlbnRzW1wiRlJBR19DSEFOR0VEXCJdID0gXCJobHNGcmFnQ2hhbmdlZFwiO1xuICBFdmVudHNbXCJGUFNfRFJPUFwiXSA9IFwiaGxzRnBzRHJvcFwiO1xuICBFdmVudHNbXCJGUFNfRFJPUF9MRVZFTF9DQVBQSU5HXCJdID0gXCJobHNGcHNEcm9wTGV2ZWxDYXBwaW5nXCI7XG4gIEV2ZW50c1tcIkVSUk9SXCJdID0gXCJobHNFcnJvclwiO1xuICBFdmVudHNbXCJERVNUUk9ZSU5HXCJdID0gXCJobHNEZXN0cm95aW5nXCI7XG4gIEV2ZW50c1tcIktFWV9MT0FESU5HXCJdID0gXCJobHNLZXlMb2FkaW5nXCI7XG4gIEV2ZW50c1tcIktFWV9MT0FERURcIl0gPSBcImhsc0tleUxvYWRlZFwiO1xuICBFdmVudHNbXCJMSVZFX0JBQ0tfQlVGRkVSX1JFQUNIRURcIl0gPSBcImhsc0xpdmVCYWNrQnVmZmVyUmVhY2hlZFwiO1xuICBFdmVudHNbXCJCQUNLX0JVRkZFUl9SRUFDSEVEXCJdID0gXCJobHNCYWNrQnVmZmVyUmVhY2hlZFwiO1xufSkoRXZlbnRzIHx8IChFdmVudHMgPSB7fSkpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9obHMudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2hscy50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJkZWZhdWx0XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gSGxzOyB9KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciB1cmxfdG9vbGtpdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgdXJsLXRvb2xraXQgKi8gXCIuL25vZGVfbW9kdWxlcy91cmwtdG9vbGtpdC9zcmMvdXJsLXRvb2xraXQuanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgdXJsX3Rvb2xraXRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubih1cmxfdG9vbGtpdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbG9hZGVyX3BsYXlsaXN0X2xvYWRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9sb2FkZXIvcGxheWxpc3QtbG9hZGVyICovIFwiLi9zcmMvbG9hZGVyL3BsYXlsaXN0LWxvYWRlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbG9hZGVyX2tleV9sb2FkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbG9hZGVyL2tleS1sb2FkZXIgKi8gXCIuL3NyYy9sb2FkZXIva2V5LWxvYWRlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfY29udHJvbGxlcl9pZDNfdHJhY2tfY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9jb250cm9sbGVyL2lkMy10cmFjay1jb250cm9sbGVyICovIFwiLi9zcmMvY29udHJvbGxlci9pZDMtdHJhY2stY29udHJvbGxlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfY29udHJvbGxlcl9sYXRlbmN5X2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vY29udHJvbGxlci9sYXRlbmN5LWNvbnRyb2xsZXIgKi8gXCIuL3NyYy9jb250cm9sbGVyL2xhdGVuY3ktY29udHJvbGxlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfY29udHJvbGxlcl9sZXZlbF9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2NvbnRyb2xsZXIvbGV2ZWwtY29udHJvbGxlciAqLyBcIi4vc3JjL2NvbnRyb2xsZXIvbGV2ZWwtY29udHJvbGxlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfY29udHJvbGxlcl9mcmFnbWVudF90cmFja2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2NvbnRyb2xsZXIvZnJhZ21lbnQtdHJhY2tlciAqLyBcIi4vc3JjL2NvbnRyb2xsZXIvZnJhZ21lbnQtdHJhY2tlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfY29udHJvbGxlcl9zdHJlYW1fY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9jb250cm9sbGVyL3N0cmVhbS1jb250cm9sbGVyICovIFwiLi9zcmMvY29udHJvbGxlci9zdHJlYW0tY29udHJvbGxlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfaXNfc3VwcG9ydGVkX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV84X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzLXN1cHBvcnRlZCAqLyBcIi4vc3JjL2lzLXN1cHBvcnRlZC50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV85X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3V0aWxzL2xvZ2dlciAqLyBcIi4vc3JjL3V0aWxzL2xvZ2dlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfY29uZmlnX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9jb25maWcgKi8gXCIuL3NyYy9jb25maWcudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgZXZlbnRlbWl0dGVyM19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGV2ZW50ZW1pdHRlcjMgKi8gXCIuL25vZGVfbW9kdWxlcy9ldmVudGVtaXR0ZXIzL2luZGV4LmpzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGV2ZW50ZW1pdHRlcjNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzExX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oZXZlbnRlbWl0dGVyM19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTFfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZXZlbnRzICovIFwiLi9zcmMvZXZlbnRzLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEzX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2Vycm9ycyAqLyBcIi4vc3JjL2Vycm9ycy50c1wiKTtcbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuLyoqXG4gKiBAbW9kdWxlIEhsc1xuICogQGNsYXNzXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIEhscyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIEhscy5pc1N1cHBvcnRlZCA9IGZ1bmN0aW9uIGlzU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiBPYmplY3QoX2lzX3N1cHBvcnRlZF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOF9fW1wiaXNTdXBwb3J0ZWRcIl0pKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgYW4gSExTIGNsaWVudCB0aGF0IGNhbiBhdHRhY2ggdG8gZXhhY3RseSBvbmUgYEhUTUxNZWRpYUVsZW1lbnRgLlxuICAgKlxuICAgKiBAY29uc3RydWN0cyBIbHNcbiAgICogQHBhcmFtIHtIbHNDb25maWd9IGNvbmZpZ1xuICAgKi9cbiAgZnVuY3Rpb24gSGxzKHVzZXJDb25maWcpIHtcbiAgICBpZiAodXNlckNvbmZpZyA9PT0gdm9pZCAwKSB7XG4gICAgICB1c2VyQ29uZmlnID0ge307XG4gICAgfVxuXG4gICAgdGhpcy5jb25maWcgPSB2b2lkIDA7XG4gICAgdGhpcy51c2VyQ29uZmlnID0gdm9pZCAwO1xuICAgIHRoaXMuY29yZUNvbXBvbmVudHMgPSB2b2lkIDA7XG4gICAgdGhpcy5uZXR3b3JrQ29udHJvbGxlcnMgPSB2b2lkIDA7XG4gICAgdGhpcy5fZW1pdHRlciA9IG5ldyBldmVudGVtaXR0ZXIzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMV9fW1wiRXZlbnRFbWl0dGVyXCJdKCk7XG4gICAgdGhpcy5fYXV0b0xldmVsQ2FwcGluZyA9IHZvaWQgMDtcbiAgICB0aGlzLmFickNvbnRyb2xsZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5idWZmZXJDb250cm9sbGVyID0gdm9pZCAwO1xuICAgIHRoaXMuY2FwTGV2ZWxDb250cm9sbGVyID0gdm9pZCAwO1xuICAgIHRoaXMubGF0ZW5jeUNvbnRyb2xsZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5sZXZlbENvbnRyb2xsZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5zdHJlYW1Db250cm9sbGVyID0gdm9pZCAwO1xuICAgIHRoaXMuYXVkaW9UcmFja0NvbnRyb2xsZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5zdWJ0aXRsZVRyYWNrQ29udHJvbGxlciA9IHZvaWQgMDtcbiAgICB0aGlzLmVtZUNvbnRyb2xsZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5jbWNkQ29udHJvbGxlciA9IHZvaWQgMDtcbiAgICB0aGlzLl9tZWRpYSA9IG51bGw7XG4gICAgdGhpcy51cmwgPSBudWxsO1xuICAgIHZhciBjb25maWcgPSB0aGlzLmNvbmZpZyA9IE9iamVjdChfY29uZmlnX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMF9fW1wibWVyZ2VDb25maWdcIl0pKEhscy5EZWZhdWx0Q29uZmlnLCB1c2VyQ29uZmlnKTtcbiAgICB0aGlzLnVzZXJDb25maWcgPSB1c2VyQ29uZmlnO1xuICAgIE9iamVjdChfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV85X19bXCJlbmFibGVMb2dzXCJdKShjb25maWcuZGVidWcpO1xuICAgIHRoaXMuX2F1dG9MZXZlbENhcHBpbmcgPSAtMTtcblxuICAgIGlmIChjb25maWcucHJvZ3Jlc3NpdmUpIHtcbiAgICAgIE9iamVjdChfY29uZmlnX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMF9fW1wiZW5hYmxlU3RyZWFtaW5nTW9kZVwiXSkoY29uZmlnKTtcbiAgICB9IC8vIGNvcmUgY29udHJvbGxlcnMgYW5kIG5ldHdvcmsgbG9hZGVyc1xuXG5cbiAgICB2YXIgQ29uZmlnQWJyQ29udHJvbGxlciA9IGNvbmZpZy5hYnJDb250cm9sbGVyLFxuICAgICAgICBDb25maWdCdWZmZXJDb250cm9sbGVyID0gY29uZmlnLmJ1ZmZlckNvbnRyb2xsZXIsXG4gICAgICAgIENvbmZpZ0NhcExldmVsQ29udHJvbGxlciA9IGNvbmZpZy5jYXBMZXZlbENvbnRyb2xsZXIsXG4gICAgICAgIENvbmZpZ0Zwc0NvbnRyb2xsZXIgPSBjb25maWcuZnBzQ29udHJvbGxlcjtcbiAgICB2YXIgYWJyQ29udHJvbGxlciA9IHRoaXMuYWJyQ29udHJvbGxlciA9IG5ldyBDb25maWdBYnJDb250cm9sbGVyKHRoaXMpO1xuICAgIHZhciBidWZmZXJDb250cm9sbGVyID0gdGhpcy5idWZmZXJDb250cm9sbGVyID0gbmV3IENvbmZpZ0J1ZmZlckNvbnRyb2xsZXIodGhpcyk7XG4gICAgdmFyIGNhcExldmVsQ29udHJvbGxlciA9IHRoaXMuY2FwTGV2ZWxDb250cm9sbGVyID0gbmV3IENvbmZpZ0NhcExldmVsQ29udHJvbGxlcih0aGlzKTtcbiAgICB2YXIgZnBzQ29udHJvbGxlciA9IG5ldyBDb25maWdGcHNDb250cm9sbGVyKHRoaXMpO1xuICAgIHZhciBwbGF5TGlzdExvYWRlciA9IG5ldyBfbG9hZGVyX3BsYXlsaXN0X2xvYWRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiZGVmYXVsdFwiXSh0aGlzKTtcbiAgICB2YXIga2V5TG9hZGVyID0gbmV3IF9sb2FkZXJfa2V5X2xvYWRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiZGVmYXVsdFwiXSh0aGlzKTtcbiAgICB2YXIgaWQzVHJhY2tDb250cm9sbGVyID0gbmV3IF9jb250cm9sbGVyX2lkM190cmFja19jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJkZWZhdWx0XCJdKHRoaXMpOyAvLyBuZXR3b3JrIGNvbnRyb2xsZXJzXG5cbiAgICB2YXIgbGV2ZWxDb250cm9sbGVyID0gdGhpcy5sZXZlbENvbnRyb2xsZXIgPSBuZXcgX2NvbnRyb2xsZXJfbGV2ZWxfY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1wiZGVmYXVsdFwiXSh0aGlzKTsgLy8gRnJhZ21lbnRUcmFja2VyIG11c3QgYmUgZGVmaW5lZCBiZWZvcmUgU3RyZWFtQ29udHJvbGxlciBiZWNhdXNlIHRoZSBvcmRlciBvZiBldmVudCBoYW5kbGluZyBpcyBpbXBvcnRhbnRcblxuICAgIHZhciBmcmFnbWVudFRyYWNrZXIgPSBuZXcgX2NvbnRyb2xsZXJfZnJhZ21lbnRfdHJhY2tlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fW1wiRnJhZ21lbnRUcmFja2VyXCJdKHRoaXMpO1xuICAgIHZhciBzdHJlYW1Db250cm9sbGVyID0gdGhpcy5zdHJlYW1Db250cm9sbGVyID0gbmV3IF9jb250cm9sbGVyX3N0cmVhbV9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bXCJkZWZhdWx0XCJdKHRoaXMsIGZyYWdtZW50VHJhY2tlcik7IC8vIENhcCBsZXZlbCBjb250cm9sbGVyIHVzZXMgc3RyZWFtQ29udHJvbGxlciB0byBmbHVzaCB0aGUgYnVmZmVyXG5cbiAgICBjYXBMZXZlbENvbnRyb2xsZXIuc2V0U3RyZWFtQ29udHJvbGxlcihzdHJlYW1Db250cm9sbGVyKTsgLy8gZnBzQ29udHJvbGxlciB1c2VzIHN0cmVhbUNvbnRyb2xsZXIgdG8gc3dpdGNoIHdoZW4gZnJhbWVzIGFyZSBiZWluZyBkcm9wcGVkXG5cbiAgICBmcHNDb250cm9sbGVyLnNldFN0cmVhbUNvbnRyb2xsZXIoc3RyZWFtQ29udHJvbGxlcik7XG4gICAgdmFyIG5ldHdvcmtDb250cm9sbGVycyA9IFtsZXZlbENvbnRyb2xsZXIsIHN0cmVhbUNvbnRyb2xsZXJdO1xuICAgIHRoaXMubmV0d29ya0NvbnRyb2xsZXJzID0gbmV0d29ya0NvbnRyb2xsZXJzO1xuICAgIHZhciBjb3JlQ29tcG9uZW50cyA9IFtwbGF5TGlzdExvYWRlciwga2V5TG9hZGVyLCBhYnJDb250cm9sbGVyLCBidWZmZXJDb250cm9sbGVyLCBjYXBMZXZlbENvbnRyb2xsZXIsIGZwc0NvbnRyb2xsZXIsIGlkM1RyYWNrQ29udHJvbGxlciwgZnJhZ21lbnRUcmFja2VyXTtcbiAgICB0aGlzLmF1ZGlvVHJhY2tDb250cm9sbGVyID0gdGhpcy5jcmVhdGVDb250cm9sbGVyKGNvbmZpZy5hdWRpb1RyYWNrQ29udHJvbGxlciwgbnVsbCwgbmV0d29ya0NvbnRyb2xsZXJzKTtcbiAgICB0aGlzLmNyZWF0ZUNvbnRyb2xsZXIoY29uZmlnLmF1ZGlvU3RyZWFtQ29udHJvbGxlciwgZnJhZ21lbnRUcmFja2VyLCBuZXR3b3JrQ29udHJvbGxlcnMpOyAvLyBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlciBtdXN0IGJlIGRlZmluZWQgYmVmb3JlICBiZWNhdXNlIHRoZSBvcmRlciBvZiBldmVudCBoYW5kbGluZyBpcyBpbXBvcnRhbnRcblxuICAgIHRoaXMuc3VidGl0bGVUcmFja0NvbnRyb2xsZXIgPSB0aGlzLmNyZWF0ZUNvbnRyb2xsZXIoY29uZmlnLnN1YnRpdGxlVHJhY2tDb250cm9sbGVyLCBudWxsLCBuZXR3b3JrQ29udHJvbGxlcnMpO1xuICAgIHRoaXMuY3JlYXRlQ29udHJvbGxlcihjb25maWcuc3VidGl0bGVTdHJlYW1Db250cm9sbGVyLCBmcmFnbWVudFRyYWNrZXIsIG5ldHdvcmtDb250cm9sbGVycyk7XG4gICAgdGhpcy5jcmVhdGVDb250cm9sbGVyKGNvbmZpZy50aW1lbGluZUNvbnRyb2xsZXIsIG51bGwsIGNvcmVDb21wb25lbnRzKTtcbiAgICB0aGlzLmVtZUNvbnRyb2xsZXIgPSB0aGlzLmNyZWF0ZUNvbnRyb2xsZXIoY29uZmlnLmVtZUNvbnRyb2xsZXIsIG51bGwsIGNvcmVDb21wb25lbnRzKTtcbiAgICB0aGlzLmNtY2RDb250cm9sbGVyID0gdGhpcy5jcmVhdGVDb250cm9sbGVyKGNvbmZpZy5jbWNkQ29udHJvbGxlciwgbnVsbCwgY29yZUNvbXBvbmVudHMpO1xuICAgIHRoaXMubGF0ZW5jeUNvbnRyb2xsZXIgPSB0aGlzLmNyZWF0ZUNvbnRyb2xsZXIoX2NvbnRyb2xsZXJfbGF0ZW5jeV9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXCJkZWZhdWx0XCJdLCBudWxsLCBjb3JlQ29tcG9uZW50cyk7XG4gICAgdGhpcy5jb3JlQ29tcG9uZW50cyA9IGNvcmVDb21wb25lbnRzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IEhscy5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmNyZWF0ZUNvbnRyb2xsZXIgPSBmdW5jdGlvbiBjcmVhdGVDb250cm9sbGVyKENvbnRyb2xsZXJDbGFzcywgZnJhZ21lbnRUcmFja2VyLCBjb21wb25lbnRzKSB7XG4gICAgaWYgKENvbnRyb2xsZXJDbGFzcykge1xuICAgICAgdmFyIGNvbnRyb2xsZXJJbnN0YW5jZSA9IGZyYWdtZW50VHJhY2tlciA/IG5ldyBDb250cm9sbGVyQ2xhc3ModGhpcywgZnJhZ21lbnRUcmFja2VyKSA6IG5ldyBDb250cm9sbGVyQ2xhc3ModGhpcyk7XG5cbiAgICAgIGlmIChjb21wb25lbnRzKSB7XG4gICAgICAgIGNvbXBvbmVudHMucHVzaChjb250cm9sbGVySW5zdGFuY2UpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29udHJvbGxlckluc3RhbmNlO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9IC8vIERlbGVnYXRlIHRoZSBFdmVudEVtaXR0ZXIgdGhyb3VnaCB0aGUgcHVibGljIEFQSSBvZiBIbHMuanNcbiAgO1xuXG4gIF9wcm90by5vbiA9IGZ1bmN0aW9uIG9uKGV2ZW50LCBsaXN0ZW5lciwgY29udGV4dCkge1xuICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHtcbiAgICAgIGNvbnRleHQgPSB0aGlzO1xuICAgIH1cblxuICAgIHRoaXMuX2VtaXR0ZXIub24oZXZlbnQsIGxpc3RlbmVyLCBjb250ZXh0KTtcbiAgfTtcblxuICBfcHJvdG8ub25jZSA9IGZ1bmN0aW9uIG9uY2UoZXZlbnQsIGxpc3RlbmVyLCBjb250ZXh0KSB7XG4gICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkge1xuICAgICAgY29udGV4dCA9IHRoaXM7XG4gICAgfVxuXG4gICAgdGhpcy5fZW1pdHRlci5vbmNlKGV2ZW50LCBsaXN0ZW5lciwgY29udGV4dCk7XG4gIH07XG5cbiAgX3Byb3RvLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uIHJlbW92ZUFsbExpc3RlbmVycyhldmVudCkge1xuICAgIHRoaXMuX2VtaXR0ZXIucmVtb3ZlQWxsTGlzdGVuZXJzKGV2ZW50KTtcbiAgfTtcblxuICBfcHJvdG8ub2ZmID0gZnVuY3Rpb24gb2ZmKGV2ZW50LCBsaXN0ZW5lciwgY29udGV4dCwgb25jZSkge1xuICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHtcbiAgICAgIGNvbnRleHQgPSB0aGlzO1xuICAgIH1cblxuICAgIHRoaXMuX2VtaXR0ZXIub2ZmKGV2ZW50LCBsaXN0ZW5lciwgY29udGV4dCwgb25jZSk7XG4gIH07XG5cbiAgX3Byb3RvLmxpc3RlbmVycyA9IGZ1bmN0aW9uIGxpc3RlbmVycyhldmVudCkge1xuICAgIHJldHVybiB0aGlzLl9lbWl0dGVyLmxpc3RlbmVycyhldmVudCk7XG4gIH07XG5cbiAgX3Byb3RvLmVtaXQgPSBmdW5jdGlvbiBlbWl0KGV2ZW50LCBuYW1lLCBldmVudE9iamVjdCkge1xuICAgIHJldHVybiB0aGlzLl9lbWl0dGVyLmVtaXQoZXZlbnQsIG5hbWUsIGV2ZW50T2JqZWN0KTtcbiAgfTtcblxuICBfcHJvdG8udHJpZ2dlciA9IGZ1bmN0aW9uIHRyaWdnZXIoZXZlbnQsIGV2ZW50T2JqZWN0KSB7XG4gICAgaWYgKHRoaXMuY29uZmlnLmRlYnVnKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbWl0KGV2ZW50LCBldmVudCwgZXZlbnRPYmplY3QpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbWl0KGV2ZW50LCBldmVudCwgZXZlbnRPYmplY3QpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV85X19bXCJsb2dnZXJcIl0uZXJyb3IoJ0FuIGludGVybmFsIGVycm9yIGhhcHBlbmVkIHdoaWxlIGhhbmRsaW5nIGV2ZW50ICcgKyBldmVudCArICcuIEVycm9yIG1lc3NhZ2U6IFwiJyArIGUubWVzc2FnZSArICdcIi4gSGVyZSBpcyBhIHN0YWNrdHJhY2U6JywgZSk7XG4gICAgICAgIHRoaXMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMl9fW1wiRXZlbnRzXCJdLkVSUk9SLCB7XG4gICAgICAgICAgdHlwZTogX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTNfX1tcIkVycm9yVHlwZXNcIl0uT1RIRVJfRVJST1IsXG4gICAgICAgICAgZGV0YWlsczogX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTNfX1tcIkVycm9yRGV0YWlsc1wiXS5JTlRFUk5BTF9FWENFUFRJT04sXG4gICAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICAgIGV2ZW50OiBldmVudCxcbiAgICAgICAgICBlcnJvcjogZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgX3Byb3RvLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbiBsaXN0ZW5lckNvdW50KGV2ZW50KSB7XG4gICAgcmV0dXJuIHRoaXMuX2VtaXR0ZXIubGlzdGVuZXJDb3VudChldmVudCk7XG4gIH1cbiAgLyoqXG4gICAqIERpc3Bvc2Ugb2YgdGhlIGluc3RhbmNlXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzlfX1tcImxvZ2dlclwiXS5sb2coJ2Rlc3Ryb3knKTtcbiAgICB0aGlzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTJfX1tcIkV2ZW50c1wiXS5ERVNUUk9ZSU5HLCB1bmRlZmluZWQpO1xuICAgIHRoaXMuZGV0YWNoTWVkaWEoKTtcbiAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgIHRoaXMuX2F1dG9MZXZlbENhcHBpbmcgPSAtMTtcbiAgICB0aGlzLnVybCA9IG51bGw7XG4gICAgdGhpcy5uZXR3b3JrQ29udHJvbGxlcnMuZm9yRWFjaChmdW5jdGlvbiAoY29tcG9uZW50KSB7XG4gICAgICByZXR1cm4gY29tcG9uZW50LmRlc3Ryb3koKTtcbiAgICB9KTtcbiAgICB0aGlzLm5ldHdvcmtDb250cm9sbGVycy5sZW5ndGggPSAwO1xuICAgIHRoaXMuY29yZUNvbXBvbmVudHMuZm9yRWFjaChmdW5jdGlvbiAoY29tcG9uZW50KSB7XG4gICAgICByZXR1cm4gY29tcG9uZW50LmRlc3Ryb3koKTtcbiAgICB9KTtcbiAgICB0aGlzLmNvcmVDb21wb25lbnRzLmxlbmd0aCA9IDA7XG4gIH1cbiAgLyoqXG4gICAqIEF0dGFjaGVzIEhscy5qcyB0byBhIG1lZGlhIGVsZW1lbnRcbiAgICogQHBhcmFtIHtIVE1MTWVkaWFFbGVtZW50fSBtZWRpYVxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5hdHRhY2hNZWRpYSA9IGZ1bmN0aW9uIGF0dGFjaE1lZGlhKG1lZGlhKSB7XG4gICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOV9fW1wibG9nZ2VyXCJdLmxvZygnYXR0YWNoTWVkaWEnKTtcbiAgICB0aGlzLl9tZWRpYSA9IG1lZGlhO1xuICAgIHRoaXMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMl9fW1wiRXZlbnRzXCJdLk1FRElBX0FUVEFDSElORywge1xuICAgICAgbWVkaWE6IG1lZGlhXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIERldGFjaCBIbHMuanMgZnJvbSB0aGUgbWVkaWFcbiAgICovXG4gIDtcblxuICBfcHJvdG8uZGV0YWNoTWVkaWEgPSBmdW5jdGlvbiBkZXRhY2hNZWRpYSgpIHtcbiAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV85X19bXCJsb2dnZXJcIl0ubG9nKCdkZXRhY2hNZWRpYScpO1xuICAgIHRoaXMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMl9fW1wiRXZlbnRzXCJdLk1FRElBX0RFVEFDSElORywgdW5kZWZpbmVkKTtcbiAgICB0aGlzLl9tZWRpYSA9IG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIFNldCB0aGUgc291cmNlIFVSTC4gQ2FuIGJlIHJlbGF0aXZlIG9yIGFic29sdXRlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmxvYWRTb3VyY2UgPSBmdW5jdGlvbiBsb2FkU291cmNlKHVybCkge1xuICAgIHRoaXMuc3RvcExvYWQoKTtcbiAgICB2YXIgbWVkaWEgPSB0aGlzLm1lZGlhO1xuICAgIHZhciBsb2FkZWRTb3VyY2UgPSB0aGlzLnVybDtcbiAgICB2YXIgbG9hZGluZ1NvdXJjZSA9IHRoaXMudXJsID0gdXJsX3Rvb2xraXRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImJ1aWxkQWJzb2x1dGVVUkxcIl0oc2VsZi5sb2NhdGlvbi5ocmVmLCB1cmwsIHtcbiAgICAgIGFsd2F5c05vcm1hbGl6ZTogdHJ1ZVxuICAgIH0pO1xuICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzlfX1tcImxvZ2dlclwiXS5sb2coXCJsb2FkU291cmNlOlwiICsgbG9hZGluZ1NvdXJjZSk7XG5cbiAgICBpZiAobWVkaWEgJiYgbG9hZGVkU291cmNlICYmIGxvYWRlZFNvdXJjZSAhPT0gbG9hZGluZ1NvdXJjZSAmJiB0aGlzLmJ1ZmZlckNvbnRyb2xsZXIuaGFzU291cmNlVHlwZXMoKSkge1xuICAgICAgdGhpcy5kZXRhY2hNZWRpYSgpO1xuICAgICAgdGhpcy5hdHRhY2hNZWRpYShtZWRpYSk7XG4gICAgfSAvLyB3aGVuIGF0dGFjaGluZyB0byBhIHNvdXJjZSBVUkwsIHRyaWdnZXIgYSBwbGF5bGlzdCBsb2FkXG5cblxuICAgIHRoaXMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMl9fW1wiRXZlbnRzXCJdLk1BTklGRVNUX0xPQURJTkcsIHtcbiAgICAgIHVybDogdXJsXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFN0YXJ0IGxvYWRpbmcgZGF0YSBmcm9tIHRoZSBzdHJlYW0gc291cmNlLlxuICAgKiBEZXBlbmRpbmcgb24gZGVmYXVsdCBjb25maWcsIGNsaWVudCBzdGFydHMgbG9hZGluZyBhdXRvbWF0aWNhbGx5IHdoZW4gYSBzb3VyY2UgaXMgc2V0LlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnRQb3NpdGlvbiBTZXQgdGhlIHN0YXJ0IHBvc2l0aW9uIHRvIHN0cmVhbSBmcm9tXG4gICAqIEBkZWZhdWx0IC0xIE5vbmUgKGZyb20gZWFybGllc3QgcG9pbnQpXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnN0YXJ0TG9hZCA9IGZ1bmN0aW9uIHN0YXJ0TG9hZChzdGFydFBvc2l0aW9uKSB7XG4gICAgaWYgKHN0YXJ0UG9zaXRpb24gPT09IHZvaWQgMCkge1xuICAgICAgc3RhcnRQb3NpdGlvbiA9IC0xO1xuICAgIH1cblxuICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzlfX1tcImxvZ2dlclwiXS5sb2coXCJzdGFydExvYWQoXCIgKyBzdGFydFBvc2l0aW9uICsgXCIpXCIpO1xuICAgIHRoaXMubmV0d29ya0NvbnRyb2xsZXJzLmZvckVhY2goZnVuY3Rpb24gKGNvbnRyb2xsZXIpIHtcbiAgICAgIGNvbnRyb2xsZXIuc3RhcnRMb2FkKHN0YXJ0UG9zaXRpb24pO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBTdG9wIGxvYWRpbmcgb2YgYW55IHN0cmVhbSBkYXRhLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5zdG9wTG9hZCA9IGZ1bmN0aW9uIHN0b3BMb2FkKCkge1xuICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzlfX1tcImxvZ2dlclwiXS5sb2coJ3N0b3BMb2FkJyk7XG4gICAgdGhpcy5uZXR3b3JrQ29udHJvbGxlcnMuZm9yRWFjaChmdW5jdGlvbiAoY29udHJvbGxlcikge1xuICAgICAgY29udHJvbGxlci5zdG9wTG9hZCgpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBTd2FwIHRocm91Z2ggcG9zc2libGUgYXVkaW8gY29kZWNzIGluIHRoZSBzdHJlYW0gKGZvciBleGFtcGxlIHRvIHN3aXRjaCBmcm9tIHN0ZXJlbyB0byA1LjEpXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnN3YXBBdWRpb0NvZGVjID0gZnVuY3Rpb24gc3dhcEF1ZGlvQ29kZWMoKSB7XG4gICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOV9fW1wibG9nZ2VyXCJdLmxvZygnc3dhcEF1ZGlvQ29kZWMnKTtcbiAgICB0aGlzLnN0cmVhbUNvbnRyb2xsZXIuc3dhcEF1ZGlvQ29kZWMoKTtcbiAgfVxuICAvKipcbiAgICogV2hlbiB0aGUgbWVkaWEtZWxlbWVudCBmYWlscywgdGhpcyBhbGxvd3MgdG8gZGV0YWNoIGFuZCB0aGVuIHJlLWF0dGFjaCBpdFxuICAgKiBhcyBvbmUgY2FsbCAoY29udmVuaWVuY2UgbWV0aG9kKS5cbiAgICpcbiAgICogQXV0b21hdGljIHJlY292ZXJ5IG9mIG1lZGlhLWVycm9ycyBieSB0aGlzIHByb2Nlc3MgaXMgY29uZmlndXJhYmxlLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5yZWNvdmVyTWVkaWFFcnJvciA9IGZ1bmN0aW9uIHJlY292ZXJNZWRpYUVycm9yKCkge1xuICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzlfX1tcImxvZ2dlclwiXS5sb2coJ3JlY292ZXJNZWRpYUVycm9yJyk7XG4gICAgdmFyIG1lZGlhID0gdGhpcy5fbWVkaWE7XG4gICAgdGhpcy5kZXRhY2hNZWRpYSgpO1xuXG4gICAgaWYgKG1lZGlhKSB7XG4gICAgICB0aGlzLmF0dGFjaE1lZGlhKG1lZGlhKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLnJlbW92ZUxldmVsID0gZnVuY3Rpb24gcmVtb3ZlTGV2ZWwobGV2ZWxJbmRleCwgdXJsSWQpIHtcbiAgICBpZiAodXJsSWQgPT09IHZvaWQgMCkge1xuICAgICAgdXJsSWQgPSAwO1xuICAgIH1cblxuICAgIHRoaXMubGV2ZWxDb250cm9sbGVyLnJlbW92ZUxldmVsKGxldmVsSW5kZXgsIHVybElkKTtcbiAgfVxuICAvKipcbiAgICogQHR5cGUge0xldmVsW119XG4gICAqL1xuICA7XG5cbiAgX2NyZWF0ZUNsYXNzKEhscywgW3tcbiAgICBrZXk6IFwibGV2ZWxzXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgbGV2ZWxzID0gdGhpcy5sZXZlbENvbnRyb2xsZXIubGV2ZWxzO1xuICAgICAgcmV0dXJuIGxldmVscyA/IGxldmVscyA6IFtdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbmRleCBvZiBxdWFsaXR5IGxldmVsIGN1cnJlbnRseSBwbGF5ZWRcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiY3VycmVudExldmVsXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zdHJlYW1Db250cm9sbGVyLmN1cnJlbnRMZXZlbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHF1YWxpdHkgbGV2ZWwgaW5kZXggaW1tZWRpYXRlbHkgLlxuICAgICAqIFRoaXMgd2lsbCBmbHVzaCB0aGUgY3VycmVudCBidWZmZXIgdG8gcmVwbGFjZSB0aGUgcXVhbGl0eSBhc2FwLlxuICAgICAqIFRoYXQgbWVhbnMgcGxheWJhY2sgd2lsbCBpbnRlcnJ1cHQgYXQgbGVhc3Qgc2hvcnRseSB0byByZS1idWZmZXIgYW5kIHJlLXN5bmMgZXZlbnR1YWxseS5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfSAtMSBmb3IgYXV0b21hdGljIGxldmVsIHNlbGVjdGlvblxuICAgICAqL1xuICAgICxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldChuZXdMZXZlbCkge1xuICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOV9fW1wibG9nZ2VyXCJdLmxvZyhcInNldCBjdXJyZW50TGV2ZWw6XCIgKyBuZXdMZXZlbCk7XG4gICAgICB0aGlzLmxvYWRMZXZlbCA9IG5ld0xldmVsO1xuICAgICAgdGhpcy5hYnJDb250cm9sbGVyLmNsZWFyVGltZXIoKTtcbiAgICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlci5pbW1lZGlhdGVMZXZlbFN3aXRjaCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbmRleCBvZiBuZXh0IHF1YWxpdHkgbGV2ZWwgbG9hZGVkIGFzIHNjaGVkdWxlZCBieSBzdHJlYW0gY29udHJvbGxlci5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwibmV4dExldmVsXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zdHJlYW1Db250cm9sbGVyLm5leHRMZXZlbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHF1YWxpdHkgbGV2ZWwgaW5kZXggZm9yIG5leHQgbG9hZGVkIGRhdGEuXG4gICAgICogVGhpcyB3aWxsIHN3aXRjaCB0aGUgdmlkZW8gcXVhbGl0eSBhc2FwLCB3aXRob3V0IGludGVycnVwdGluZyBwbGF5YmFjay5cbiAgICAgKiBNYXkgYWJvcnQgY3VycmVudCBsb2FkaW5nIG9mIGRhdGEsIGFuZCBmbHVzaCBwYXJ0cyBvZiBidWZmZXIgKG91dHNpZGUgY3VycmVudGx5IHBsYXllZCBmcmFnbWVudCByZWdpb24pLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9IC0xIGZvciBhdXRvbWF0aWMgbGV2ZWwgc2VsZWN0aW9uXG4gICAgICovXG4gICAgLFxuICAgIHNldDogZnVuY3Rpb24gc2V0KG5ld0xldmVsKSB7XG4gICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV85X19bXCJsb2dnZXJcIl0ubG9nKFwic2V0IG5leHRMZXZlbDpcIiArIG5ld0xldmVsKTtcbiAgICAgIHRoaXMubGV2ZWxDb250cm9sbGVyLm1hbnVhbExldmVsID0gbmV3TGV2ZWw7XG4gICAgICB0aGlzLnN0cmVhbUNvbnRyb2xsZXIubmV4dExldmVsU3dpdGNoKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgcXVhbGl0eSBsZXZlbCBvZiB0aGUgY3VycmVudGx5IG9yIGxhc3QgKG9mIG5vbmUgaXMgbG9hZGVkIGN1cnJlbnRseSkgc2VnbWVudFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJsb2FkTGV2ZWxcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmxldmVsQ29udHJvbGxlci5sZXZlbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHF1YWxpdHkgbGV2ZWwgaW5kZXggZm9yIG5leHQgbG9hZGVkIGRhdGEgaW4gYSBjb25zZXJ2YXRpdmUgd2F5LlxuICAgICAqIFRoaXMgd2lsbCBzd2l0Y2ggdGhlIHF1YWxpdHkgd2l0aG91dCBmbHVzaGluZywgYnV0IGludGVycnVwdCBjdXJyZW50IGxvYWRpbmcuXG4gICAgICogVGh1cyB0aGUgbW9tZW50IHdoZW4gdGhlIHF1YWxpdHkgc3dpdGNoIHdpbGwgYXBwZWFyIGluIGVmZmVjdCB3aWxsIG9ubHkgYmUgYWZ0ZXIgdGhlIGFscmVhZHkgZXhpc3RpbmcgYnVmZmVyLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9IG5ld0xldmVsIC0xIGZvciBhdXRvbWF0aWMgbGV2ZWwgc2VsZWN0aW9uXG4gICAgICovXG4gICAgLFxuICAgIHNldDogZnVuY3Rpb24gc2V0KG5ld0xldmVsKSB7XG4gICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV85X19bXCJsb2dnZXJcIl0ubG9nKFwic2V0IGxvYWRMZXZlbDpcIiArIG5ld0xldmVsKTtcbiAgICAgIHRoaXMubGV2ZWxDb250cm9sbGVyLm1hbnVhbExldmVsID0gbmV3TGV2ZWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGdldCBuZXh0IHF1YWxpdHkgbGV2ZWwgbG9hZGVkXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm5leHRMb2FkTGV2ZWxcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmxldmVsQ29udHJvbGxlci5uZXh0TG9hZExldmVsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgcXVhbGl0eSBsZXZlbCBvZiBuZXh0IGxvYWRlZCBzZWdtZW50IGluIGEgZnVsbHkgXCJub24tZGVzdHJ1Y3RpdmVcIiB3YXkuXG4gICAgICogU2FtZSBhcyBgbG9hZExldmVsYCBidXQgd2lsbCB3YWl0IGZvciBuZXh0IHN3aXRjaCAodW50aWwgY3VycmVudCBsb2FkaW5nIGlzIGRvbmUpLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9IGxldmVsXG4gICAgICovXG4gICAgLFxuICAgIHNldDogZnVuY3Rpb24gc2V0KGxldmVsKSB7XG4gICAgICB0aGlzLmxldmVsQ29udHJvbGxlci5uZXh0TG9hZExldmVsID0gbGV2ZWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiBcImZpcnN0IGxldmVsXCI6IGxpa2UgYSBkZWZhdWx0IGxldmVsLCBpZiBub3Qgc2V0LFxuICAgICAqIGZhbGxzIGJhY2sgdG8gaW5kZXggb2YgZmlyc3QgbGV2ZWwgcmVmZXJlbmNlZCBpbiBtYW5pZmVzdFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJmaXJzdExldmVsXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gTWF0aC5tYXgodGhpcy5sZXZlbENvbnRyb2xsZXIuZmlyc3RMZXZlbCwgdGhpcy5taW5BdXRvTGV2ZWwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIFwiZmlyc3QtbGV2ZWxcIiwgc2VlIGdldHRlci5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgICxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldChuZXdMZXZlbCkge1xuICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOV9fW1wibG9nZ2VyXCJdLmxvZyhcInNldCBmaXJzdExldmVsOlwiICsgbmV3TGV2ZWwpO1xuICAgICAgdGhpcy5sZXZlbENvbnRyb2xsZXIuZmlyc3RMZXZlbCA9IG5ld0xldmVsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gc3RhcnQgbGV2ZWwgKGxldmVsIG9mIGZpcnN0IGZyYWdtZW50IHRoYXQgd2lsbCBiZSBwbGF5ZWQgYmFjaylcbiAgICAgKiBpZiBub3Qgb3ZlcnJpZGVkIGJ5IHVzZXIsIGZpcnN0IGxldmVsIGFwcGVhcmluZyBpbiBtYW5pZmVzdCB3aWxsIGJlIHVzZWQgYXMgc3RhcnQgbGV2ZWxcbiAgICAgKiBpZiAtMSA6IGF1dG9tYXRpYyBzdGFydCBsZXZlbCBzZWxlY3Rpb24sIHBsYXliYWNrIHdpbGwgc3RhcnQgZnJvbSBsZXZlbCBtYXRjaGluZyBkb3dubG9hZCBiYW5kd2lkdGhcbiAgICAgKiAoZGV0ZXJtaW5lZCBmcm9tIGRvd25sb2FkIG9mIGZpcnN0IHNlZ21lbnQpXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInN0YXJ0TGV2ZWxcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmxldmVsQ29udHJvbGxlci5zdGFydExldmVsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBzZXQgIHN0YXJ0IGxldmVsIChsZXZlbCBvZiBmaXJzdCBmcmFnbWVudCB0aGF0IHdpbGwgYmUgcGxheWVkIGJhY2spXG4gICAgICogaWYgbm90IG92ZXJyaWRlZCBieSB1c2VyLCBmaXJzdCBsZXZlbCBhcHBlYXJpbmcgaW4gbWFuaWZlc3Qgd2lsbCBiZSB1c2VkIGFzIHN0YXJ0IGxldmVsXG4gICAgICogaWYgLTEgOiBhdXRvbWF0aWMgc3RhcnQgbGV2ZWwgc2VsZWN0aW9uLCBwbGF5YmFjayB3aWxsIHN0YXJ0IGZyb20gbGV2ZWwgbWF0Y2hpbmcgZG93bmxvYWQgYmFuZHdpZHRoXG4gICAgICogKGRldGVybWluZWQgZnJvbSBkb3dubG9hZCBvZiBmaXJzdCBzZWdtZW50KVxuICAgICAqIEB0eXBlIHtudW1iZXJ9IG5ld0xldmVsXG4gICAgICovXG4gICAgLFxuICAgIHNldDogZnVuY3Rpb24gc2V0KG5ld0xldmVsKSB7XG4gICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV85X19bXCJsb2dnZXJcIl0ubG9nKFwic2V0IHN0YXJ0TGV2ZWw6XCIgKyBuZXdMZXZlbCk7IC8vIGlmIG5vdCBpbiBhdXRvbWF0aWMgc3RhcnQgbGV2ZWwgZGV0ZWN0aW9uLCBlbnN1cmUgc3RhcnRMZXZlbCBpcyBncmVhdGVyIHRoYW4gbWluQXV0b0xldmVsXG5cbiAgICAgIGlmIChuZXdMZXZlbCAhPT0gLTEpIHtcbiAgICAgICAgbmV3TGV2ZWwgPSBNYXRoLm1heChuZXdMZXZlbCwgdGhpcy5taW5BdXRvTGV2ZWwpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmxldmVsQ29udHJvbGxlci5zdGFydExldmVsID0gbmV3TGV2ZWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY3VycmVudCBzZXR0aW5nIGZvciBjYXBMZXZlbFRvUGxheWVyU2l6ZVxuICAgICAqXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJjYXBMZXZlbFRvUGxheWVyU2l6ZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29uZmlnLmNhcExldmVsVG9QbGF5ZXJTaXplO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBzZXQgIGR5bmFtaWNhbGx5IHNldCBjYXBMZXZlbFRvUGxheWVyU2l6ZSBhZ2FpbnN0IChgQ2FwTGV2ZWxDb250cm9sbGVyYClcbiAgICAgKlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgICxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldChzaG91bGRTdGFydENhcHBpbmcpIHtcbiAgICAgIHZhciBuZXdDYXBMZXZlbFRvUGxheWVyU2l6ZSA9ICEhc2hvdWxkU3RhcnRDYXBwaW5nO1xuXG4gICAgICBpZiAobmV3Q2FwTGV2ZWxUb1BsYXllclNpemUgIT09IHRoaXMuY29uZmlnLmNhcExldmVsVG9QbGF5ZXJTaXplKSB7XG4gICAgICAgIGlmIChuZXdDYXBMZXZlbFRvUGxheWVyU2l6ZSkge1xuICAgICAgICAgIHRoaXMuY2FwTGV2ZWxDb250cm9sbGVyLnN0YXJ0Q2FwcGluZygpOyAvLyBJZiBjYXBwaW5nIG9jY3VycywgbmV4dExldmVsU3dpdGNoIHdpbGwgaGFwcGVuIGJhc2VkIG9uIHNpemUuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5jYXBMZXZlbENvbnRyb2xsZXIuc3RvcENhcHBpbmcoKTtcbiAgICAgICAgICB0aGlzLmF1dG9MZXZlbENhcHBpbmcgPSAtMTtcbiAgICAgICAgICB0aGlzLnN0cmVhbUNvbnRyb2xsZXIubmV4dExldmVsU3dpdGNoKCk7IC8vIE5vdyB3ZSdyZSB1bmNhcHBlZCwgZ2V0IHRoZSBuZXh0IGxldmVsIGFzYXAuXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNvbmZpZy5jYXBMZXZlbFRvUGxheWVyU2l6ZSA9IG5ld0NhcExldmVsVG9QbGF5ZXJTaXplO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYXBwaW5nL21heCBsZXZlbCB2YWx1ZSB0aGF0IHNob3VsZCBiZSB1c2VkIGJ5IGF1dG9tYXRpYyBsZXZlbCBzZWxlY3Rpb24gYWxnb3JpdGhtIChgQUJSQ29udHJvbGxlcmApXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImF1dG9MZXZlbENhcHBpbmdcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9hdXRvTGV2ZWxDYXBwaW5nO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBnZXQgYmFuZHdpZHRoIGVzdGltYXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICAsXG4gICAgc2V0OlxuICAgIC8qKlxuICAgICAqIENhcHBpbmcvbWF4IGxldmVsIHZhbHVlIHRoYXQgc2hvdWxkIGJlIHVzZWQgYnkgYXV0b21hdGljIGxldmVsIHNlbGVjdGlvbiBhbGdvcml0aG0gKGBBQlJDb250cm9sbGVyYClcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNldChuZXdMZXZlbCkge1xuICAgICAgaWYgKHRoaXMuX2F1dG9MZXZlbENhcHBpbmcgIT09IG5ld0xldmVsKSB7XG4gICAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzlfX1tcImxvZ2dlclwiXS5sb2coXCJzZXQgYXV0b0xldmVsQ2FwcGluZzpcIiArIG5ld0xldmVsKTtcbiAgICAgICAgdGhpcy5fYXV0b0xldmVsQ2FwcGluZyA9IG5ld0xldmVsO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcnVlIHdoZW4gYXV0b21hdGljIGxldmVsIHNlbGVjdGlvbiBlbmFibGVkXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJiYW5kd2lkdGhFc3RpbWF0ZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdmFyIGJ3RXN0aW1hdG9yID0gdGhpcy5hYnJDb250cm9sbGVyLmJ3RXN0aW1hdG9yO1xuXG4gICAgICBpZiAoIWJ3RXN0aW1hdG9yKSB7XG4gICAgICAgIHJldHVybiBOYU47XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBid0VzdGltYXRvci5nZXRFc3RpbWF0ZSgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhdXRvTGV2ZWxFbmFibGVkXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5sZXZlbENvbnRyb2xsZXIubWFudWFsTGV2ZWwgPT09IC0xO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMZXZlbCBzZXQgbWFudWFsbHkgKGlmIGFueSlcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwibWFudWFsTGV2ZWxcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmxldmVsQ29udHJvbGxlci5tYW51YWxMZXZlbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogbWluIGxldmVsIHNlbGVjdGFibGUgaW4gYXV0byBtb2RlIGFjY29yZGluZyB0byBjb25maWcubWluQXV0b0JpdHJhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwibWluQXV0b0xldmVsXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgbGV2ZWxzID0gdGhpcy5sZXZlbHMsXG4gICAgICAgICAgbWluQXV0b0JpdHJhdGUgPSB0aGlzLmNvbmZpZy5taW5BdXRvQml0cmF0ZTtcbiAgICAgIGlmICghbGV2ZWxzKSByZXR1cm4gMDtcbiAgICAgIHZhciBsZW4gPSBsZXZlbHMubGVuZ3RoO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmIChsZXZlbHNbaV0ubWF4Qml0cmF0ZSA+IG1pbkF1dG9CaXRyYXRlKSB7XG4gICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIG1heCBsZXZlbCBzZWxlY3RhYmxlIGluIGF1dG8gbW9kZSBhY2NvcmRpbmcgdG8gYXV0b0xldmVsQ2FwcGluZ1xuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJtYXhBdXRvTGV2ZWxcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciBsZXZlbHMgPSB0aGlzLmxldmVscyxcbiAgICAgICAgICBhdXRvTGV2ZWxDYXBwaW5nID0gdGhpcy5hdXRvTGV2ZWxDYXBwaW5nO1xuICAgICAgdmFyIG1heEF1dG9MZXZlbDtcblxuICAgICAgaWYgKGF1dG9MZXZlbENhcHBpbmcgPT09IC0xICYmIGxldmVscyAmJiBsZXZlbHMubGVuZ3RoKSB7XG4gICAgICAgIG1heEF1dG9MZXZlbCA9IGxldmVscy5sZW5ndGggLSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWF4QXV0b0xldmVsID0gYXV0b0xldmVsQ2FwcGluZztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1heEF1dG9MZXZlbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogbmV4dCBhdXRvbWF0aWNhbGx5IHNlbGVjdGVkIHF1YWxpdHkgbGV2ZWxcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwibmV4dEF1dG9MZXZlbFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgLy8gZW5zdXJlIG5leHQgYXV0byBsZXZlbCBpcyBiZXR3ZWVuICBtaW4gYW5kIG1heCBhdXRvIGxldmVsXG4gICAgICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgodGhpcy5hYnJDb250cm9sbGVyLm5leHRBdXRvTGV2ZWwsIHRoaXMubWluQXV0b0xldmVsKSwgdGhpcy5tYXhBdXRvTGV2ZWwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiB0aGlzIHNldHRlciBpcyB1c2VkIHRvIGZvcmNlIG5leHQgYXV0byBsZXZlbC5cbiAgICAgKiB0aGlzIGlzIHVzZWZ1bCB0byBmb3JjZSBhIHN3aXRjaCBkb3duIGluIGF1dG8gbW9kZTpcbiAgICAgKiBpbiBjYXNlIG9mIGxvYWQgZXJyb3Igb24gbGV2ZWwgTiwgaGxzLmpzIGNhbiBzZXQgbmV4dEF1dG9MZXZlbCB0byBOLTEgZm9yIGV4YW1wbGUpXG4gICAgICogZm9yY2VkIHZhbHVlIGlzIHZhbGlkIGZvciBvbmUgZnJhZ21lbnQuIHVwb24gc3VjY2Vzc2Z1bCBmcmFnIGxvYWRpbmcgYXQgZm9yY2VkIGxldmVsLFxuICAgICAqIHRoaXMgdmFsdWUgd2lsbCBiZSByZXNldHRlZCB0byAtMSBieSBBQlIgY29udHJvbGxlci5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgICxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldChuZXh0TGV2ZWwpIHtcbiAgICAgIHRoaXMuYWJyQ29udHJvbGxlci5uZXh0QXV0b0xldmVsID0gTWF0aC5tYXgodGhpcy5taW5BdXRvTGV2ZWwsIG5leHRMZXZlbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtBdWRpb1RyYWNrW119XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJhdWRpb1RyYWNrc1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdmFyIGF1ZGlvVHJhY2tDb250cm9sbGVyID0gdGhpcy5hdWRpb1RyYWNrQ29udHJvbGxlcjtcbiAgICAgIHJldHVybiBhdWRpb1RyYWNrQ29udHJvbGxlciA/IGF1ZGlvVHJhY2tDb250cm9sbGVyLmF1ZGlvVHJhY2tzIDogW107XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGluZGV4IG9mIHRoZSBzZWxlY3RlZCBhdWRpbyB0cmFjayAoaW5kZXggaW4gYXVkaW8gdHJhY2sgbGlzdHMpXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImF1ZGlvVHJhY2tcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciBhdWRpb1RyYWNrQ29udHJvbGxlciA9IHRoaXMuYXVkaW9UcmFja0NvbnRyb2xsZXI7XG4gICAgICByZXR1cm4gYXVkaW9UcmFja0NvbnRyb2xsZXIgPyBhdWRpb1RyYWNrQ29udHJvbGxlci5hdWRpb1RyYWNrIDogLTE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHNlbGVjdHMgYW4gYXVkaW8gdHJhY2ssIGJhc2VkIG9uIGl0cyBpbmRleCBpbiBhdWRpbyB0cmFjayBsaXN0c1xuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgLFxuICAgIHNldDogZnVuY3Rpb24gc2V0KGF1ZGlvVHJhY2tJZCkge1xuICAgICAgdmFyIGF1ZGlvVHJhY2tDb250cm9sbGVyID0gdGhpcy5hdWRpb1RyYWNrQ29udHJvbGxlcjtcblxuICAgICAgaWYgKGF1ZGlvVHJhY2tDb250cm9sbGVyKSB7XG4gICAgICAgIGF1ZGlvVHJhY2tDb250cm9sbGVyLmF1ZGlvVHJhY2sgPSBhdWRpb1RyYWNrSWQ7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGdldCBhbHRlcm5hdGUgc3VidGl0bGUgdHJhY2tzIGxpc3QgZnJvbSBwbGF5bGlzdFxuICAgICAqIEB0eXBlIHtNZWRpYVBsYXlsaXN0W119XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzdWJ0aXRsZVRyYWNrc1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdmFyIHN1YnRpdGxlVHJhY2tDb250cm9sbGVyID0gdGhpcy5zdWJ0aXRsZVRyYWNrQ29udHJvbGxlcjtcbiAgICAgIHJldHVybiBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlciA/IHN1YnRpdGxlVHJhY2tDb250cm9sbGVyLnN1YnRpdGxlVHJhY2tzIDogW107XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGluZGV4IG9mIHRoZSBzZWxlY3RlZCBzdWJ0aXRsZSB0cmFjayAoaW5kZXggaW4gc3VidGl0bGUgdHJhY2sgbGlzdHMpXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInN1YnRpdGxlVHJhY2tcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlciA9IHRoaXMuc3VidGl0bGVUcmFja0NvbnRyb2xsZXI7XG4gICAgICByZXR1cm4gc3VidGl0bGVUcmFja0NvbnRyb2xsZXIgPyBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlci5zdWJ0aXRsZVRyYWNrIDogLTE7XG4gICAgfSxcbiAgICBzZXQ6XG4gICAgLyoqXG4gICAgICogc2VsZWN0IGFuIHN1YnRpdGxlIHRyYWNrLCBiYXNlZCBvbiBpdHMgaW5kZXggaW4gc3VidGl0bGUgdHJhY2sgbGlzdHNcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNldChzdWJ0aXRsZVRyYWNrSWQpIHtcbiAgICAgIHZhciBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlciA9IHRoaXMuc3VidGl0bGVUcmFja0NvbnRyb2xsZXI7XG5cbiAgICAgIGlmIChzdWJ0aXRsZVRyYWNrQ29udHJvbGxlcikge1xuICAgICAgICBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlci5zdWJ0aXRsZVRyYWNrID0gc3VidGl0bGVUcmFja0lkO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm1lZGlhXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbWVkaWE7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInN1YnRpdGxlRGlzcGxheVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdmFyIHN1YnRpdGxlVHJhY2tDb250cm9sbGVyID0gdGhpcy5zdWJ0aXRsZVRyYWNrQ29udHJvbGxlcjtcbiAgICAgIHJldHVybiBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlciA/IHN1YnRpdGxlVHJhY2tDb250cm9sbGVyLnN1YnRpdGxlRGlzcGxheSA6IGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbmFibGUvZGlzYWJsZSBzdWJ0aXRsZSBkaXNwbGF5IHJlbmRlcmluZ1xuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgICxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgdmFyIHN1YnRpdGxlVHJhY2tDb250cm9sbGVyID0gdGhpcy5zdWJ0aXRsZVRyYWNrQ29udHJvbGxlcjtcblxuICAgICAgaWYgKHN1YnRpdGxlVHJhY2tDb250cm9sbGVyKSB7XG4gICAgICAgIHN1YnRpdGxlVHJhY2tDb250cm9sbGVyLnN1YnRpdGxlRGlzcGxheSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBnZXQgbW9kZSBmb3IgTG93LUxhdGVuY3kgSExTIGxvYWRpbmdcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImxvd0xhdGVuY3lNb2RlXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb25maWcubG93TGF0ZW5jeU1vZGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuYWJsZS9kaXNhYmxlIExvdy1MYXRlbmN5IEhMUyBwYXJ0IHBsYXlsaXN0IGFuZCBzZWdtZW50IGxvYWRpbmcsIGFuZCBzdGFydCBsaXZlIHN0cmVhbXMgYXQgcGxheWxpc3QgUEFSVC1IT0xELUJBQ0sgcmF0aGVyIHRoYW4gSE9MRC1CQUNLLlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgICxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldChtb2RlKSB7XG4gICAgICB0aGlzLmNvbmZpZy5sb3dMYXRlbmN5TW9kZSA9IG1vZGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHBvc2l0aW9uIChpbiBzZWNvbmRzKSBvZiBsaXZlIHN5bmMgcG9pbnQgKGllIGVkZ2Ugb2YgbGl2ZSBwb3NpdGlvbiBtaW51cyBzYWZldHkgZGVsYXkgZGVmaW5lZCBieSBgYGBobHMuY29uZmlnLmxpdmVTeW5jRHVyYXRpb25gYGApXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImxpdmVTeW5jUG9zaXRpb25cIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmxhdGVuY3lDb250cm9sbGVyLmxpdmVTeW5jUG9zaXRpb247XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGVzdGltYXRlZCBwb3NpdGlvbiAoaW4gc2Vjb25kcykgb2YgbGl2ZSBlZGdlIChpZSBlZGdlIG9mIGxpdmUgcGxheWxpc3QgcGx1cyB0aW1lIHN5bmMgcGxheWxpc3QgYWR2YW5jZWQpXG4gICAgICogcmV0dXJucyAwIGJlZm9yZSBmaXJzdCBwbGF5bGlzdCBpcyBsb2FkZWRcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwibGF0ZW5jeVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMubGF0ZW5jeUNvbnRyb2xsZXIubGF0ZW5jeTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogbWF4aW11bSBkaXN0YW5jZSBmcm9tIHRoZSBlZGdlIGJlZm9yZSB0aGUgcGxheWVyIHNlZWtzIGZvcndhcmQgdG8gYGBgaGxzLmxpdmVTeW5jUG9zaXRpb25gYGBcbiAgICAgKiBjb25maWd1cmVkIHVzaW5nIGBgYGxpdmVNYXhMYXRlbmN5RHVyYXRpb25Db3VudGBgYCAobXVsdGlwbGUgb2YgdGFyZ2V0IGR1cmF0aW9uKSBvciBgYGBsaXZlTWF4TGF0ZW5jeUR1cmF0aW9uYGBgXG4gICAgICogcmV0dXJucyAwIGJlZm9yZSBmaXJzdCBwbGF5bGlzdCBpcyBsb2FkZWRcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwibWF4TGF0ZW5jeVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMubGF0ZW5jeUNvbnRyb2xsZXIubWF4TGF0ZW5jeTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogdGFyZ2V0IGRpc3RhbmNlIGZyb20gdGhlIGVkZ2UgYXMgY2FsY3VsYXRlZCBieSB0aGUgbGF0ZW5jeSBjb250cm9sbGVyXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInRhcmdldExhdGVuY3lcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmxhdGVuY3lDb250cm9sbGVyLnRhcmdldExhdGVuY3k7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHRoZSByYXRlIGF0IHdoaWNoIHRoZSBlZGdlIG9mIHRoZSBjdXJyZW50IGxpdmUgcGxheWxpc3QgaXMgYWR2YW5jaW5nIG9yIDEgaWYgdGhlcmUgaXMgbm9uZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkcmlmdFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMubGF0ZW5jeUNvbnRyb2xsZXIuZHJpZnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHNldCB0byB0cnVlIHdoZW4gc3RhcnRMb2FkIGlzIGNhbGxlZCBiZWZvcmUgTUFOSUZFU1RfUEFSU0VEIGV2ZW50XG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJmb3JjZVN0YXJ0TG9hZFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtQ29udHJvbGxlci5mb3JjZVN0YXJ0TG9hZDtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJ2ZXJzaW9uXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gXCIxLjEuNVwiO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJFdmVudHNcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMl9fW1wiRXZlbnRzXCJdO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJFcnJvclR5cGVzXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTNfX1tcIkVycm9yVHlwZXNcIl07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIkVycm9yRGV0YWlsc1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEzX19bXCJFcnJvckRldGFpbHNcIl07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIkRlZmF1bHRDb25maWdcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIGlmICghSGxzLmRlZmF1bHRDb25maWcpIHtcbiAgICAgICAgcmV0dXJuIF9jb25maWdfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEwX19bXCJobHNEZWZhdWx0Q29uZmlnXCJdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gSGxzLmRlZmF1bHRDb25maWc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtIbHNDb25maWd9XG4gICAgICovXG4gICAgLFxuICAgIHNldDogZnVuY3Rpb24gc2V0KGRlZmF1bHRDb25maWcpIHtcbiAgICAgIEhscy5kZWZhdWx0Q29uZmlnID0gZGVmYXVsdENvbmZpZztcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gSGxzO1xufSgpO1xuXG5IbHMuZGVmYXVsdENvbmZpZyA9IHZvaWQgMDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9pcy1zdXBwb3J0ZWQudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2lzLXN1cHBvcnRlZC50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogaXNTdXBwb3J0ZWQsIGNoYW5nZVR5cGVTdXBwb3J0ZWQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiaXNTdXBwb3J0ZWRcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBpc1N1cHBvcnRlZDsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiY2hhbmdlVHlwZVN1cHBvcnRlZFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGNoYW5nZVR5cGVTdXBwb3J0ZWQ7IH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19tZWRpYXNvdXJjZV9oZWxwZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdXRpbHMvbWVkaWFzb3VyY2UtaGVscGVyICovIFwiLi9zcmMvdXRpbHMvbWVkaWFzb3VyY2UtaGVscGVyLnRzXCIpO1xuXG5cbmZ1bmN0aW9uIGdldFNvdXJjZUJ1ZmZlcigpIHtcbiAgcmV0dXJuIHNlbGYuU291cmNlQnVmZmVyIHx8IHNlbGYuV2ViS2l0U291cmNlQnVmZmVyO1xufVxuXG5mdW5jdGlvbiBpc1N1cHBvcnRlZCgpIHtcbiAgdmFyIG1lZGlhU291cmNlID0gT2JqZWN0KF91dGlsc19tZWRpYXNvdXJjZV9oZWxwZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImdldE1lZGlhU291cmNlXCJdKSgpO1xuXG4gIGlmICghbWVkaWFTb3VyY2UpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgc291cmNlQnVmZmVyID0gZ2V0U291cmNlQnVmZmVyKCk7XG4gIHZhciBpc1R5cGVTdXBwb3J0ZWQgPSBtZWRpYVNvdXJjZSAmJiB0eXBlb2YgbWVkaWFTb3VyY2UuaXNUeXBlU3VwcG9ydGVkID09PSAnZnVuY3Rpb24nICYmIG1lZGlhU291cmNlLmlzVHlwZVN1cHBvcnRlZCgndmlkZW8vbXA0OyBjb2RlY3M9XCJhdmMxLjQyRTAxRSxtcDRhLjQwLjJcIicpOyAvLyBpZiBTb3VyY2VCdWZmZXIgaXMgZXhwb3NlZCBlbnN1cmUgaXRzIEFQSSBpcyB2YWxpZFxuICAvLyBzYWZhcmkgYW5kIG9sZCB2ZXJzaW9uIG9mIENocm9tZSBkb2Ugbm90IGV4cG9zZSBTb3VyY2VCdWZmZXIgZ2xvYmFsbHkgc28gY2hlY2tpbmcgU291cmNlQnVmZmVyLnByb3RvdHlwZSBpcyBpbXBvc3NpYmxlXG5cbiAgdmFyIHNvdXJjZUJ1ZmZlclZhbGlkQVBJID0gIXNvdXJjZUJ1ZmZlciB8fCBzb3VyY2VCdWZmZXIucHJvdG90eXBlICYmIHR5cGVvZiBzb3VyY2VCdWZmZXIucHJvdG90eXBlLmFwcGVuZEJ1ZmZlciA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Ygc291cmNlQnVmZmVyLnByb3RvdHlwZS5yZW1vdmUgPT09ICdmdW5jdGlvbic7XG4gIHJldHVybiAhIWlzVHlwZVN1cHBvcnRlZCAmJiAhIXNvdXJjZUJ1ZmZlclZhbGlkQVBJO1xufVxuZnVuY3Rpb24gY2hhbmdlVHlwZVN1cHBvcnRlZCgpIHtcbiAgdmFyIF9zb3VyY2VCdWZmZXIkcHJvdG90eTtcblxuICB2YXIgc291cmNlQnVmZmVyID0gZ2V0U291cmNlQnVmZmVyKCk7XG4gIHJldHVybiB0eXBlb2YgKHNvdXJjZUJ1ZmZlciA9PT0gbnVsbCB8fCBzb3VyY2VCdWZmZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfc291cmNlQnVmZmVyJHByb3RvdHkgPSBzb3VyY2VCdWZmZXIucHJvdG90eXBlKSA9PT0gbnVsbCB8fCBfc291cmNlQnVmZmVyJHByb3RvdHkgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9zb3VyY2VCdWZmZXIkcHJvdG90eS5jaGFuZ2VUeXBlKSA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvbG9hZGVyL2ZyYWdtZW50LWxvYWRlci50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2xvYWRlci9mcmFnbWVudC1sb2FkZXIudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0LCBMb2FkRXJyb3IgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZGVmYXVsdFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIEZyYWdtZW50TG9hZGVyOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJMb2FkRXJyb3JcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBMb2FkRXJyb3I7IH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9ob21lX3J1bm5lcl93b3JrX2hsc19qc19obHNfanNfc3JjX3BvbHlmaWxsc19udW1iZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc3JjL3BvbHlmaWxscy9udW1iZXIgKi8gXCIuL3NyYy9wb2x5ZmlsbHMvbnVtYmVyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2Vycm9ycyAqLyBcIi4vc3JjL2Vycm9ycy50c1wiKTtcblxuXG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpOyBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzczsgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfd3JhcE5hdGl2ZVN1cGVyKENsYXNzKSB7IHZhciBfY2FjaGUgPSB0eXBlb2YgTWFwID09PSBcImZ1bmN0aW9uXCIgPyBuZXcgTWFwKCkgOiB1bmRlZmluZWQ7IF93cmFwTmF0aXZlU3VwZXIgPSBmdW5jdGlvbiBfd3JhcE5hdGl2ZVN1cGVyKENsYXNzKSB7IGlmIChDbGFzcyA9PT0gbnVsbCB8fCAhX2lzTmF0aXZlRnVuY3Rpb24oQ2xhc3MpKSByZXR1cm4gQ2xhc3M7IGlmICh0eXBlb2YgQ2xhc3MgIT09IFwiZnVuY3Rpb25cIikgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gaWYgKHR5cGVvZiBfY2FjaGUgIT09IFwidW5kZWZpbmVkXCIpIHsgaWYgKF9jYWNoZS5oYXMoQ2xhc3MpKSByZXR1cm4gX2NhY2hlLmdldChDbGFzcyk7IF9jYWNoZS5zZXQoQ2xhc3MsIFdyYXBwZXIpOyB9IGZ1bmN0aW9uIFdyYXBwZXIoKSB7IHJldHVybiBfY29uc3RydWN0KENsYXNzLCBhcmd1bWVudHMsIF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3Rvcik7IH0gV3JhcHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKENsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogV3JhcHBlciwgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihXcmFwcGVyLCBDbGFzcyk7IH07IHJldHVybiBfd3JhcE5hdGl2ZVN1cGVyKENsYXNzKTsgfVxuXG5mdW5jdGlvbiBfY29uc3RydWN0KFBhcmVudCwgYXJncywgQ2xhc3MpIHsgaWYgKF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSkgeyBfY29uc3RydWN0ID0gUmVmbGVjdC5jb25zdHJ1Y3Q7IH0gZWxzZSB7IF9jb25zdHJ1Y3QgPSBmdW5jdGlvbiBfY29uc3RydWN0KFBhcmVudCwgYXJncywgQ2xhc3MpIHsgdmFyIGEgPSBbbnVsbF07IGEucHVzaC5hcHBseShhLCBhcmdzKTsgdmFyIENvbnN0cnVjdG9yID0gRnVuY3Rpb24uYmluZC5hcHBseShQYXJlbnQsIGEpOyB2YXIgaW5zdGFuY2UgPSBuZXcgQ29uc3RydWN0b3IoKTsgaWYgKENsYXNzKSBfc2V0UHJvdG90eXBlT2YoaW5zdGFuY2UsIENsYXNzLnByb3RvdHlwZSk7IHJldHVybiBpbnN0YW5jZTsgfTsgfSByZXR1cm4gX2NvbnN0cnVjdC5hcHBseShudWxsLCBhcmd1bWVudHMpOyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVGdW5jdGlvbihmbikgeyByZXR1cm4gRnVuY3Rpb24udG9TdHJpbmcuY2FsbChmbikuaW5kZXhPZihcIltuYXRpdmUgY29kZV1cIikgIT09IC0xOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxuXG52YXIgTUlOX0NIVU5LX1NJWkUgPSBNYXRoLnBvdygyLCAxNyk7IC8vIDEyOGtiXG5cbnZhciBGcmFnbWVudExvYWRlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEZyYWdtZW50TG9hZGVyKGNvbmZpZykge1xuICAgIHRoaXMuY29uZmlnID0gdm9pZCAwO1xuICAgIHRoaXMubG9hZGVyID0gbnVsbDtcbiAgICB0aGlzLnBhcnRMb2FkVGltZW91dCA9IC0xO1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IEZyYWdtZW50TG9hZGVyLnByb3RvdHlwZTtcblxuICBfcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMubG9hZGVyKSB7XG4gICAgICB0aGlzLmxvYWRlci5kZXN0cm95KCk7XG4gICAgICB0aGlzLmxvYWRlciA9IG51bGw7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5hYm9ydCA9IGZ1bmN0aW9uIGFib3J0KCkge1xuICAgIGlmICh0aGlzLmxvYWRlcikge1xuICAgICAgLy8gQWJvcnQgdGhlIGxvYWRlciBmb3IgY3VycmVudCBmcmFnbWVudC4gT25seSBvbmUgbWF5IGxvYWQgYXQgYW55IGdpdmVuIHRpbWVcbiAgICAgIHRoaXMubG9hZGVyLmFib3J0KCk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5sb2FkID0gZnVuY3Rpb24gbG9hZChmcmFnLCBfb25Qcm9ncmVzcykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgdXJsID0gZnJhZy51cmw7XG5cbiAgICBpZiAoIXVybCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBMb2FkRXJyb3Ioe1xuICAgICAgICB0eXBlOiBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFcnJvclR5cGVzXCJdLk5FVFdPUktfRVJST1IsXG4gICAgICAgIGRldGFpbHM6IF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkVycm9yRGV0YWlsc1wiXS5GUkFHX0xPQURfRVJST1IsXG4gICAgICAgIGZhdGFsOiBmYWxzZSxcbiAgICAgICAgZnJhZzogZnJhZyxcbiAgICAgICAgbmV0d29ya0RldGFpbHM6IG51bGxcbiAgICAgIH0sIFwiRnJhZ21lbnQgZG9lcyBub3QgaGF2ZSBhIFwiICsgKHVybCA/ICdwYXJ0IGxpc3QnIDogJ3VybCcpKSk7XG4gICAgfVxuXG4gICAgdGhpcy5hYm9ydCgpO1xuICAgIHZhciBjb25maWcgPSB0aGlzLmNvbmZpZztcbiAgICB2YXIgRnJhZ21lbnRJTG9hZGVyID0gY29uZmlnLmZMb2FkZXI7XG4gICAgdmFyIERlZmF1bHRJTG9hZGVyID0gY29uZmlnLmxvYWRlcjtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgaWYgKF90aGlzLmxvYWRlcikge1xuICAgICAgICBfdGhpcy5sb2FkZXIuZGVzdHJveSgpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbG9hZGVyID0gX3RoaXMubG9hZGVyID0gZnJhZy5sb2FkZXIgPSBGcmFnbWVudElMb2FkZXIgPyBuZXcgRnJhZ21lbnRJTG9hZGVyKGNvbmZpZykgOiBuZXcgRGVmYXVsdElMb2FkZXIoY29uZmlnKTtcbiAgICAgIHZhciBsb2FkZXJDb250ZXh0ID0gY3JlYXRlTG9hZGVyQ29udGV4dChmcmFnKTtcbiAgICAgIHZhciBsb2FkZXJDb25maWcgPSB7XG4gICAgICAgIHRpbWVvdXQ6IGNvbmZpZy5mcmFnTG9hZGluZ1RpbWVPdXQsXG4gICAgICAgIG1heFJldHJ5OiAwLFxuICAgICAgICByZXRyeURlbGF5OiAwLFxuICAgICAgICBtYXhSZXRyeURlbGF5OiBjb25maWcuZnJhZ0xvYWRpbmdNYXhSZXRyeVRpbWVvdXQsXG4gICAgICAgIGhpZ2hXYXRlck1hcms6IE1JTl9DSFVOS19TSVpFXG4gICAgICB9OyAvLyBBc3NpZ24gZnJhZyBzdGF0cyB0byB0aGUgbG9hZGVyJ3Mgc3RhdHMgcmVmZXJlbmNlXG5cbiAgICAgIGZyYWcuc3RhdHMgPSBsb2FkZXIuc3RhdHM7XG4gICAgICBsb2FkZXIubG9hZChsb2FkZXJDb250ZXh0LCBsb2FkZXJDb25maWcsIHtcbiAgICAgICAgb25TdWNjZXNzOiBmdW5jdGlvbiBvblN1Y2Nlc3MocmVzcG9uc2UsIHN0YXRzLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscykge1xuICAgICAgICAgIF90aGlzLnJlc2V0TG9hZGVyKGZyYWcsIGxvYWRlcik7XG5cbiAgICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICAgIGZyYWc6IGZyYWcsXG4gICAgICAgICAgICBwYXJ0OiBudWxsLFxuICAgICAgICAgICAgcGF5bG9hZDogcmVzcG9uc2UuZGF0YSxcbiAgICAgICAgICAgIG5ldHdvcmtEZXRhaWxzOiBuZXR3b3JrRGV0YWlsc1xuICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBvbkVycm9yOiBmdW5jdGlvbiBvbkVycm9yKHJlc3BvbnNlLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscykge1xuICAgICAgICAgIF90aGlzLnJlc2V0TG9hZGVyKGZyYWcsIGxvYWRlcik7XG5cbiAgICAgICAgICByZWplY3QobmV3IExvYWRFcnJvcih7XG4gICAgICAgICAgICB0eXBlOiBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFcnJvclR5cGVzXCJdLk5FVFdPUktfRVJST1IsXG4gICAgICAgICAgICBkZXRhaWxzOiBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFcnJvckRldGFpbHNcIl0uRlJBR19MT0FEX0VSUk9SLFxuICAgICAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICAgICAgZnJhZzogZnJhZyxcbiAgICAgICAgICAgIHJlc3BvbnNlOiByZXNwb25zZSxcbiAgICAgICAgICAgIG5ldHdvcmtEZXRhaWxzOiBuZXR3b3JrRGV0YWlsc1xuICAgICAgICAgIH0pKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25BYm9ydDogZnVuY3Rpb24gb25BYm9ydChzdGF0cywgY29udGV4dCwgbmV0d29ya0RldGFpbHMpIHtcbiAgICAgICAgICBfdGhpcy5yZXNldExvYWRlcihmcmFnLCBsb2FkZXIpO1xuXG4gICAgICAgICAgcmVqZWN0KG5ldyBMb2FkRXJyb3Ioe1xuICAgICAgICAgICAgdHlwZTogX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXJyb3JUeXBlc1wiXS5ORVRXT1JLX0VSUk9SLFxuICAgICAgICAgICAgZGV0YWlsczogX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXJyb3JEZXRhaWxzXCJdLklOVEVSTkFMX0FCT1JURUQsXG4gICAgICAgICAgICBmYXRhbDogZmFsc2UsXG4gICAgICAgICAgICBmcmFnOiBmcmFnLFxuICAgICAgICAgICAgbmV0d29ya0RldGFpbHM6IG5ldHdvcmtEZXRhaWxzXG4gICAgICAgICAgfSkpO1xuICAgICAgICB9LFxuICAgICAgICBvblRpbWVvdXQ6IGZ1bmN0aW9uIG9uVGltZW91dChyZXNwb25zZSwgY29udGV4dCwgbmV0d29ya0RldGFpbHMpIHtcbiAgICAgICAgICBfdGhpcy5yZXNldExvYWRlcihmcmFnLCBsb2FkZXIpO1xuXG4gICAgICAgICAgcmVqZWN0KG5ldyBMb2FkRXJyb3Ioe1xuICAgICAgICAgICAgdHlwZTogX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXJyb3JUeXBlc1wiXS5ORVRXT1JLX0VSUk9SLFxuICAgICAgICAgICAgZGV0YWlsczogX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXJyb3JEZXRhaWxzXCJdLkZSQUdfTE9BRF9USU1FT1VULFxuICAgICAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICAgICAgZnJhZzogZnJhZyxcbiAgICAgICAgICAgIG5ldHdvcmtEZXRhaWxzOiBuZXR3b3JrRGV0YWlsc1xuICAgICAgICAgIH0pKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25Qcm9ncmVzczogZnVuY3Rpb24gb25Qcm9ncmVzcyhzdGF0cywgY29udGV4dCwgZGF0YSwgbmV0d29ya0RldGFpbHMpIHtcbiAgICAgICAgICBpZiAoX29uUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgIF9vblByb2dyZXNzKHtcbiAgICAgICAgICAgICAgZnJhZzogZnJhZyxcbiAgICAgICAgICAgICAgcGFydDogbnVsbCxcbiAgICAgICAgICAgICAgcGF5bG9hZDogZGF0YSxcbiAgICAgICAgICAgICAgbmV0d29ya0RldGFpbHM6IG5ldHdvcmtEZXRhaWxzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90by5sb2FkUGFydCA9IGZ1bmN0aW9uIGxvYWRQYXJ0KGZyYWcsIHBhcnQsIG9uUHJvZ3Jlc3MpIHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgIHRoaXMuYWJvcnQoKTtcbiAgICB2YXIgY29uZmlnID0gdGhpcy5jb25maWc7XG4gICAgdmFyIEZyYWdtZW50SUxvYWRlciA9IGNvbmZpZy5mTG9hZGVyO1xuICAgIHZhciBEZWZhdWx0SUxvYWRlciA9IGNvbmZpZy5sb2FkZXI7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIGlmIChfdGhpczIubG9hZGVyKSB7XG4gICAgICAgIF90aGlzMi5sb2FkZXIuZGVzdHJveSgpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbG9hZGVyID0gX3RoaXMyLmxvYWRlciA9IGZyYWcubG9hZGVyID0gRnJhZ21lbnRJTG9hZGVyID8gbmV3IEZyYWdtZW50SUxvYWRlcihjb25maWcpIDogbmV3IERlZmF1bHRJTG9hZGVyKGNvbmZpZyk7XG4gICAgICB2YXIgbG9hZGVyQ29udGV4dCA9IGNyZWF0ZUxvYWRlckNvbnRleHQoZnJhZywgcGFydCk7XG4gICAgICB2YXIgbG9hZGVyQ29uZmlnID0ge1xuICAgICAgICB0aW1lb3V0OiBjb25maWcuZnJhZ0xvYWRpbmdUaW1lT3V0LFxuICAgICAgICBtYXhSZXRyeTogMCxcbiAgICAgICAgcmV0cnlEZWxheTogMCxcbiAgICAgICAgbWF4UmV0cnlEZWxheTogY29uZmlnLmZyYWdMb2FkaW5nTWF4UmV0cnlUaW1lb3V0LFxuICAgICAgICBoaWdoV2F0ZXJNYXJrOiBNSU5fQ0hVTktfU0laRVxuICAgICAgfTsgLy8gQXNzaWduIHBhcnQgc3RhdHMgdG8gdGhlIGxvYWRlcidzIHN0YXRzIHJlZmVyZW5jZVxuXG4gICAgICBwYXJ0LnN0YXRzID0gbG9hZGVyLnN0YXRzO1xuICAgICAgbG9hZGVyLmxvYWQobG9hZGVyQ29udGV4dCwgbG9hZGVyQ29uZmlnLCB7XG4gICAgICAgIG9uU3VjY2VzczogZnVuY3Rpb24gb25TdWNjZXNzKHJlc3BvbnNlLCBzdGF0cywgY29udGV4dCwgbmV0d29ya0RldGFpbHMpIHtcbiAgICAgICAgICBfdGhpczIucmVzZXRMb2FkZXIoZnJhZywgbG9hZGVyKTtcblxuICAgICAgICAgIF90aGlzMi51cGRhdGVTdGF0c0Zyb21QYXJ0KGZyYWcsIHBhcnQpO1xuXG4gICAgICAgICAgdmFyIHBhcnRMb2FkZWREYXRhID0ge1xuICAgICAgICAgICAgZnJhZzogZnJhZyxcbiAgICAgICAgICAgIHBhcnQ6IHBhcnQsXG4gICAgICAgICAgICBwYXlsb2FkOiByZXNwb25zZS5kYXRhLFxuICAgICAgICAgICAgbmV0d29ya0RldGFpbHM6IG5ldHdvcmtEZXRhaWxzXG4gICAgICAgICAgfTtcbiAgICAgICAgICBvblByb2dyZXNzKHBhcnRMb2FkZWREYXRhKTtcbiAgICAgICAgICByZXNvbHZlKHBhcnRMb2FkZWREYXRhKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25FcnJvcjogZnVuY3Rpb24gb25FcnJvcihyZXNwb25zZSwgY29udGV4dCwgbmV0d29ya0RldGFpbHMpIHtcbiAgICAgICAgICBfdGhpczIucmVzZXRMb2FkZXIoZnJhZywgbG9hZGVyKTtcblxuICAgICAgICAgIHJlamVjdChuZXcgTG9hZEVycm9yKHtcbiAgICAgICAgICAgIHR5cGU6IF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkVycm9yVHlwZXNcIl0uTkVUV09SS19FUlJPUixcbiAgICAgICAgICAgIGRldGFpbHM6IF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkVycm9yRGV0YWlsc1wiXS5GUkFHX0xPQURfRVJST1IsXG4gICAgICAgICAgICBmYXRhbDogZmFsc2UsXG4gICAgICAgICAgICBmcmFnOiBmcmFnLFxuICAgICAgICAgICAgcGFydDogcGFydCxcbiAgICAgICAgICAgIHJlc3BvbnNlOiByZXNwb25zZSxcbiAgICAgICAgICAgIG5ldHdvcmtEZXRhaWxzOiBuZXR3b3JrRGV0YWlsc1xuICAgICAgICAgIH0pKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25BYm9ydDogZnVuY3Rpb24gb25BYm9ydChzdGF0cywgY29udGV4dCwgbmV0d29ya0RldGFpbHMpIHtcbiAgICAgICAgICBmcmFnLnN0YXRzLmFib3J0ZWQgPSBwYXJ0LnN0YXRzLmFib3J0ZWQ7XG5cbiAgICAgICAgICBfdGhpczIucmVzZXRMb2FkZXIoZnJhZywgbG9hZGVyKTtcblxuICAgICAgICAgIHJlamVjdChuZXcgTG9hZEVycm9yKHtcbiAgICAgICAgICAgIHR5cGU6IF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkVycm9yVHlwZXNcIl0uTkVUV09SS19FUlJPUixcbiAgICAgICAgICAgIGRldGFpbHM6IF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkVycm9yRGV0YWlsc1wiXS5JTlRFUk5BTF9BQk9SVEVELFxuICAgICAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICAgICAgZnJhZzogZnJhZyxcbiAgICAgICAgICAgIHBhcnQ6IHBhcnQsXG4gICAgICAgICAgICBuZXR3b3JrRGV0YWlsczogbmV0d29ya0RldGFpbHNcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uVGltZW91dDogZnVuY3Rpb24gb25UaW1lb3V0KHJlc3BvbnNlLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscykge1xuICAgICAgICAgIF90aGlzMi5yZXNldExvYWRlcihmcmFnLCBsb2FkZXIpO1xuXG4gICAgICAgICAgcmVqZWN0KG5ldyBMb2FkRXJyb3Ioe1xuICAgICAgICAgICAgdHlwZTogX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXJyb3JUeXBlc1wiXS5ORVRXT1JLX0VSUk9SLFxuICAgICAgICAgICAgZGV0YWlsczogX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXJyb3JEZXRhaWxzXCJdLkZSQUdfTE9BRF9USU1FT1VULFxuICAgICAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICAgICAgZnJhZzogZnJhZyxcbiAgICAgICAgICAgIHBhcnQ6IHBhcnQsXG4gICAgICAgICAgICBuZXR3b3JrRGV0YWlsczogbmV0d29ya0RldGFpbHNcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90by51cGRhdGVTdGF0c0Zyb21QYXJ0ID0gZnVuY3Rpb24gdXBkYXRlU3RhdHNGcm9tUGFydChmcmFnLCBwYXJ0KSB7XG4gICAgdmFyIGZyYWdTdGF0cyA9IGZyYWcuc3RhdHM7XG4gICAgdmFyIHBhcnRTdGF0cyA9IHBhcnQuc3RhdHM7XG4gICAgdmFyIHBhcnRUb3RhbCA9IHBhcnRTdGF0cy50b3RhbDtcbiAgICBmcmFnU3RhdHMubG9hZGVkICs9IHBhcnRTdGF0cy5sb2FkZWQ7XG5cbiAgICBpZiAocGFydFRvdGFsKSB7XG4gICAgICB2YXIgZXN0VG90YWxQYXJ0cyA9IE1hdGgucm91bmQoZnJhZy5kdXJhdGlvbiAvIHBhcnQuZHVyYXRpb24pO1xuICAgICAgdmFyIGVzdExvYWRlZFBhcnRzID0gTWF0aC5taW4oTWF0aC5yb3VuZChmcmFnU3RhdHMubG9hZGVkIC8gcGFydFRvdGFsKSwgZXN0VG90YWxQYXJ0cyk7XG4gICAgICB2YXIgZXN0UmVtYWluaW5nUGFydHMgPSBlc3RUb3RhbFBhcnRzIC0gZXN0TG9hZGVkUGFydHM7XG4gICAgICB2YXIgZXN0UmVtYWluaW5nQnl0ZXMgPSBlc3RSZW1haW5pbmdQYXJ0cyAqIE1hdGgucm91bmQoZnJhZ1N0YXRzLmxvYWRlZCAvIGVzdExvYWRlZFBhcnRzKTtcbiAgICAgIGZyYWdTdGF0cy50b3RhbCA9IGZyYWdTdGF0cy5sb2FkZWQgKyBlc3RSZW1haW5pbmdCeXRlcztcbiAgICB9IGVsc2Uge1xuICAgICAgZnJhZ1N0YXRzLnRvdGFsID0gTWF0aC5tYXgoZnJhZ1N0YXRzLmxvYWRlZCwgZnJhZ1N0YXRzLnRvdGFsKTtcbiAgICB9XG5cbiAgICB2YXIgZnJhZ0xvYWRpbmcgPSBmcmFnU3RhdHMubG9hZGluZztcbiAgICB2YXIgcGFydExvYWRpbmcgPSBwYXJ0U3RhdHMubG9hZGluZztcblxuICAgIGlmIChmcmFnTG9hZGluZy5zdGFydCkge1xuICAgICAgLy8gYWRkIHRvIGZyYWdtZW50IGxvYWRlciBsYXRlbmN5XG4gICAgICBmcmFnTG9hZGluZy5maXJzdCArPSBwYXJ0TG9hZGluZy5maXJzdCAtIHBhcnRMb2FkaW5nLnN0YXJ0O1xuICAgIH0gZWxzZSB7XG4gICAgICBmcmFnTG9hZGluZy5zdGFydCA9IHBhcnRMb2FkaW5nLnN0YXJ0O1xuICAgICAgZnJhZ0xvYWRpbmcuZmlyc3QgPSBwYXJ0TG9hZGluZy5maXJzdDtcbiAgICB9XG5cbiAgICBmcmFnTG9hZGluZy5lbmQgPSBwYXJ0TG9hZGluZy5lbmQ7XG4gIH07XG5cbiAgX3Byb3RvLnJlc2V0TG9hZGVyID0gZnVuY3Rpb24gcmVzZXRMb2FkZXIoZnJhZywgbG9hZGVyKSB7XG4gICAgZnJhZy5sb2FkZXIgPSBudWxsO1xuXG4gICAgaWYgKHRoaXMubG9hZGVyID09PSBsb2FkZXIpIHtcbiAgICAgIHNlbGYuY2xlYXJUaW1lb3V0KHRoaXMucGFydExvYWRUaW1lb3V0KTtcbiAgICAgIHRoaXMubG9hZGVyID0gbnVsbDtcbiAgICB9XG5cbiAgICBsb2FkZXIuZGVzdHJveSgpO1xuICB9O1xuXG4gIHJldHVybiBGcmFnbWVudExvYWRlcjtcbn0oKTtcblxuXG5cbmZ1bmN0aW9uIGNyZWF0ZUxvYWRlckNvbnRleHQoZnJhZywgcGFydCkge1xuICBpZiAocGFydCA9PT0gdm9pZCAwKSB7XG4gICAgcGFydCA9IG51bGw7XG4gIH1cblxuICB2YXIgc2VnbWVudCA9IHBhcnQgfHwgZnJhZztcbiAgdmFyIGxvYWRlckNvbnRleHQgPSB7XG4gICAgZnJhZzogZnJhZyxcbiAgICBwYXJ0OiBwYXJ0LFxuICAgIHJlc3BvbnNlVHlwZTogJ2FycmF5YnVmZmVyJyxcbiAgICB1cmw6IHNlZ21lbnQudXJsLFxuICAgIGhlYWRlcnM6IHt9LFxuICAgIHJhbmdlU3RhcnQ6IDAsXG4gICAgcmFuZ2VFbmQ6IDBcbiAgfTtcbiAgdmFyIHN0YXJ0ID0gc2VnbWVudC5ieXRlUmFuZ2VTdGFydE9mZnNldDtcbiAgdmFyIGVuZCA9IHNlZ21lbnQuYnl0ZVJhbmdlRW5kT2Zmc2V0O1xuXG4gIGlmIChPYmplY3QoX2hvbWVfcnVubmVyX3dvcmtfaGxzX2pzX2hsc19qc19zcmNfcG9seWZpbGxzX251bWJlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiaXNGaW5pdGVOdW1iZXJcIl0pKHN0YXJ0KSAmJiBPYmplY3QoX2hvbWVfcnVubmVyX3dvcmtfaGxzX2pzX2hsc19qc19zcmNfcG9seWZpbGxzX251bWJlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiaXNGaW5pdGVOdW1iZXJcIl0pKGVuZCkpIHtcbiAgICBsb2FkZXJDb250ZXh0LnJhbmdlU3RhcnQgPSBzdGFydDtcbiAgICBsb2FkZXJDb250ZXh0LnJhbmdlRW5kID0gZW5kO1xuICB9XG5cbiAgcmV0dXJuIGxvYWRlckNvbnRleHQ7XG59XG5cbnZhciBMb2FkRXJyb3IgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9FcnJvcikge1xuICBfaW5oZXJpdHNMb29zZShMb2FkRXJyb3IsIF9FcnJvcik7XG5cbiAgZnVuY3Rpb24gTG9hZEVycm9yKGRhdGEpIHtcbiAgICB2YXIgX3RoaXMzO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHBhcmFtcyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBwYXJhbXNbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIF90aGlzMyA9IF9FcnJvci5jYWxsLmFwcGx5KF9FcnJvciwgW3RoaXNdLmNvbmNhdChwYXJhbXMpKSB8fCB0aGlzO1xuICAgIF90aGlzMy5kYXRhID0gdm9pZCAwO1xuICAgIF90aGlzMy5kYXRhID0gZGF0YTtcbiAgICByZXR1cm4gX3RoaXMzO1xuICB9XG5cbiAgcmV0dXJuIExvYWRFcnJvcjtcbn0oIC8qI19fUFVSRV9fKi9fd3JhcE5hdGl2ZVN1cGVyKEVycm9yKSk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2xvYWRlci9mcmFnbWVudC50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvbG9hZGVyL2ZyYWdtZW50LnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBFbGVtZW50YXJ5U3RyZWFtVHlwZXMsIEJhc2VTZWdtZW50LCBGcmFnbWVudCwgUGFydCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJFbGVtZW50YXJ5U3RyZWFtVHlwZXNcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBFbGVtZW50YXJ5U3RyZWFtVHlwZXM7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIkJhc2VTZWdtZW50XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gQmFzZVNlZ21lbnQ7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIkZyYWdtZW50XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gRnJhZ21lbnQ7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlBhcnRcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBQYXJ0OyB9KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfaG9tZV9ydW5uZXJfd29ya19obHNfanNfaGxzX2pzX3NyY19wb2x5ZmlsbHNfbnVtYmVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3NyYy9wb2x5ZmlsbHMvbnVtYmVyICovIFwiLi9zcmMvcG9seWZpbGxzL251bWJlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciB1cmxfdG9vbGtpdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgdXJsLXRvb2xraXQgKi8gXCIuL25vZGVfbW9kdWxlcy91cmwtdG9vbGtpdC9zcmMvdXJsLXRvb2xraXQuanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgdXJsX3Rvb2xraXRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubih1cmxfdG9vbGtpdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9sb2dnZXIgKi8gXCIuL3NyYy91dGlscy9sb2dnZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2xldmVsX2tleV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9sZXZlbC1rZXkgKi8gXCIuL3NyYy9sb2FkZXIvbGV2ZWwta2V5LnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9sb2FkX3N0YXRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2xvYWQtc3RhdHMgKi8gXCIuL3NyYy9sb2FkZXIvbG9hZC1zdGF0cy50c1wiKTtcblxuXG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpOyBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzczsgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cblxuXG5cblxudmFyIEVsZW1lbnRhcnlTdHJlYW1UeXBlcztcblxuKGZ1bmN0aW9uIChFbGVtZW50YXJ5U3RyZWFtVHlwZXMpIHtcbiAgRWxlbWVudGFyeVN0cmVhbVR5cGVzW1wiQVVESU9cIl0gPSBcImF1ZGlvXCI7XG4gIEVsZW1lbnRhcnlTdHJlYW1UeXBlc1tcIlZJREVPXCJdID0gXCJ2aWRlb1wiO1xuICBFbGVtZW50YXJ5U3RyZWFtVHlwZXNbXCJBVURJT1ZJREVPXCJdID0gXCJhdWRpb3ZpZGVvXCI7XG59KShFbGVtZW50YXJ5U3RyZWFtVHlwZXMgfHwgKEVsZW1lbnRhcnlTdHJlYW1UeXBlcyA9IHt9KSk7XG5cbnZhciBCYXNlU2VnbWVudCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8vIGJhc2V1cmwgaXMgdGhlIFVSTCB0byB0aGUgcGxheWxpc3RcbiAgLy8gcmVsdXJsIGlzIHRoZSBwb3J0aW9uIG9mIHRoZSBVUkwgdGhhdCBjb21lcyBmcm9tIGluc2lkZSB0aGUgcGxheWxpc3QuXG4gIC8vIEhvbGRzIHRoZSB0eXBlcyBvZiBkYXRhIHRoaXMgZnJhZ21lbnQgc3VwcG9ydHNcbiAgZnVuY3Rpb24gQmFzZVNlZ21lbnQoYmFzZXVybCkge1xuICAgIHZhciBfdGhpcyRlbGVtZW50YXJ5U3RyZWE7XG5cbiAgICB0aGlzLl9ieXRlUmFuZ2UgPSBudWxsO1xuICAgIHRoaXMuX3VybCA9IG51bGw7XG4gICAgdGhpcy5iYXNldXJsID0gdm9pZCAwO1xuICAgIHRoaXMucmVsdXJsID0gdm9pZCAwO1xuICAgIHRoaXMuZWxlbWVudGFyeVN0cmVhbXMgPSAoX3RoaXMkZWxlbWVudGFyeVN0cmVhID0ge30sIF90aGlzJGVsZW1lbnRhcnlTdHJlYVtFbGVtZW50YXJ5U3RyZWFtVHlwZXMuQVVESU9dID0gbnVsbCwgX3RoaXMkZWxlbWVudGFyeVN0cmVhW0VsZW1lbnRhcnlTdHJlYW1UeXBlcy5WSURFT10gPSBudWxsLCBfdGhpcyRlbGVtZW50YXJ5U3RyZWFbRWxlbWVudGFyeVN0cmVhbVR5cGVzLkFVRElPVklERU9dID0gbnVsbCwgX3RoaXMkZWxlbWVudGFyeVN0cmVhKTtcbiAgICB0aGlzLmJhc2V1cmwgPSBiYXNldXJsO1xuICB9IC8vIHNldEJ5dGVSYW5nZSBjb252ZXJ0cyBhIEVYVC1YLUJZVEVSQU5HRSBhdHRyaWJ1dGUgaW50byBhIHR3byBlbGVtZW50IGFycmF5XG5cblxuICB2YXIgX3Byb3RvID0gQmFzZVNlZ21lbnQucHJvdG90eXBlO1xuXG4gIF9wcm90by5zZXRCeXRlUmFuZ2UgPSBmdW5jdGlvbiBzZXRCeXRlUmFuZ2UodmFsdWUsIHByZXZpb3VzKSB7XG4gICAgdmFyIHBhcmFtcyA9IHZhbHVlLnNwbGl0KCdAJywgMik7XG4gICAgdmFyIGJ5dGVSYW5nZSA9IFtdO1xuXG4gICAgaWYgKHBhcmFtcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIGJ5dGVSYW5nZVswXSA9IHByZXZpb3VzID8gcHJldmlvdXMuYnl0ZVJhbmdlRW5kT2Zmc2V0IDogMDtcbiAgICB9IGVsc2Uge1xuICAgICAgYnl0ZVJhbmdlWzBdID0gcGFyc2VJbnQocGFyYW1zWzFdKTtcbiAgICB9XG5cbiAgICBieXRlUmFuZ2VbMV0gPSBwYXJzZUludChwYXJhbXNbMF0pICsgYnl0ZVJhbmdlWzBdO1xuICAgIHRoaXMuX2J5dGVSYW5nZSA9IGJ5dGVSYW5nZTtcbiAgfTtcblxuICBfY3JlYXRlQ2xhc3MoQmFzZVNlZ21lbnQsIFt7XG4gICAga2V5OiBcImJ5dGVSYW5nZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgaWYgKCF0aGlzLl9ieXRlUmFuZ2UpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5fYnl0ZVJhbmdlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJieXRlUmFuZ2VTdGFydE9mZnNldFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuYnl0ZVJhbmdlWzBdO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJieXRlUmFuZ2VFbmRPZmZzZXRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmJ5dGVSYW5nZVsxXTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidXJsXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICBpZiAoIXRoaXMuX3VybCAmJiB0aGlzLmJhc2V1cmwgJiYgdGhpcy5yZWx1cmwpIHtcbiAgICAgICAgdGhpcy5fdXJsID0gT2JqZWN0KHVybF90b29sa2l0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJidWlsZEFic29sdXRlVVJMXCJdKSh0aGlzLmJhc2V1cmwsIHRoaXMucmVsdXJsLCB7XG4gICAgICAgICAgYWx3YXlzTm9ybWFsaXplOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5fdXJsIHx8ICcnO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgIHRoaXMuX3VybCA9IHZhbHVlO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBCYXNlU2VnbWVudDtcbn0oKTtcbnZhciBGcmFnbWVudCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0Jhc2VTZWdtZW50KSB7XG4gIF9pbmhlcml0c0xvb3NlKEZyYWdtZW50LCBfQmFzZVNlZ21lbnQpO1xuXG4gIC8vIEVYVElORiBoYXMgdG8gYmUgcHJlc2VudCBmb3IgYSBtMzggdG8gYmUgY29uc2lkZXJlZCB2YWxpZFxuICAvLyBzbiBub3RhdGVzIHRoZSBzZXF1ZW5jZSBudW1iZXIgZm9yIGEgc2VnbWVudCwgYW5kIGlmIHNldCB0byBhIHN0cmluZyBjYW4gYmUgJ2luaXRTZWdtZW50J1xuICAvLyBsZXZlbGtleSBpcyB0aGUgRVhULVgtS0VZIHRoYXQgYXBwbGllcyB0byB0aGlzIHNlZ21lbnQgZm9yIGRlY3J5cHRpb25cbiAgLy8gY29yZSBkaWZmZXJlbmNlIGZyb20gdGhlIHByaXZhdGUgZmllbGQgX2RlY3J5cHRkYXRhIGlzIHRoZSBsYWNrIG9mIHRoZSBpbml0aWFsaXplZCBJVlxuICAvLyBfZGVjcnlwdGRhdGEgd2lsbCBzZXQgdGhlIElWIGZvciB0aGlzIHNlZ21lbnQgYmFzZWQgb24gdGhlIHNlZ21lbnQgbnVtYmVyIGluIHRoZSBmcmFnbWVudFxuICAvLyBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGZyYWdtZW50IHR5cGVcbiAgLy8gQSByZWZlcmVuY2UgdG8gdGhlIGxvYWRlci4gU2V0IHdoaWxlIHRoZSBmcmFnbWVudCBpcyBsb2FkaW5nLCBhbmQgcmVtb3ZlZCBhZnRlcndhcmRzLiBVc2VkIHRvIGFib3J0IGZyYWdtZW50IGxvYWRpbmdcbiAgLy8gVGhlIGxldmVsL3RyYWNrIGluZGV4IHRvIHdoaWNoIHRoZSBmcmFnbWVudCBiZWxvbmdzXG4gIC8vIFRoZSBjb250aW51aXR5IGNvdW50ZXIgb2YgdGhlIGZyYWdtZW50XG4gIC8vIFRoZSBzdGFydGluZyBQcmVzZW50YXRpb24gVGltZSBTdGFtcCAoUFRTKSBvZiB0aGUgZnJhZ21lbnQuIFNldCBhZnRlciB0cmFuc211eCBjb21wbGV0ZS5cbiAgLy8gVGhlIGVuZGluZyBQcmVzZW50YXRpb24gVGltZSBTdGFtcCAoUFRTKSBvZiB0aGUgZnJhZ21lbnQuIFNldCBhZnRlciB0cmFuc211eCBjb21wbGV0ZS5cbiAgLy8gVGhlIGxhdGVzdCBQcmVzZW50YXRpb24gVGltZSBTdGFtcCAoUFRTKSBhcHBlbmRlZCB0byB0aGUgYnVmZmVyLlxuICAvLyBUaGUgc3RhcnRpbmcgRGVjb2RlIFRpbWUgU3RhbXAgKERUUykgb2YgdGhlIGZyYWdtZW50LiBTZXQgYWZ0ZXIgdHJhbnNtdXggY29tcGxldGUuXG4gIC8vIFRoZSBlbmRpbmcgRGVjb2RlIFRpbWUgU3RhbXAgKERUUykgb2YgdGhlIGZyYWdtZW50LiBTZXQgYWZ0ZXIgdHJhbnNtdXggY29tcGxldGUuXG4gIC8vIFRoZSBzdGFydCB0aW1lIG9mIHRoZSBmcmFnbWVudCwgYXMgbGlzdGVkIGluIHRoZSBtYW5pZmVzdC4gVXBkYXRlZCBhZnRlciB0cmFuc211eCBjb21wbGV0ZS5cbiAgLy8gU2V0IGJ5IGB1cGRhdGVGcmFnUFRTRFRTYCBpbiBsZXZlbC1oZWxwZXJcbiAgLy8gVGhlIG1heGltdW0gc3RhcnRpbmcgUHJlc2VudGF0aW9uIFRpbWUgU3RhbXAgKGF1ZGlvL3ZpZGVvIFBUUykgb2YgdGhlIGZyYWdtZW50LiBTZXQgYWZ0ZXIgdHJhbnNtdXggY29tcGxldGUuXG4gIC8vIFRoZSBtaW5pbXVtIGVuZGluZyBQcmVzZW50YXRpb24gVGltZSBTdGFtcCAoYXVkaW8vdmlkZW8gUFRTKSBvZiB0aGUgZnJhZ21lbnQuIFNldCBhZnRlciB0cmFuc211eCBjb21wbGV0ZS5cbiAgLy8gTG9hZC9wYXJzZSB0aW1pbmcgaW5mb3JtYXRpb25cbiAgLy8gQSBmbGFnIGluZGljYXRpbmcgd2hldGhlciB0aGUgc2VnbWVudCB3YXMgZG93bmxvYWRlZCBpbiBvcmRlciB0byB0ZXN0IGJpdHJhdGUsIGFuZCB3YXMgbm90IGJ1ZmZlcmVkXG4gIC8vICNFWFRJTkYgIHNlZ21lbnQgdGl0bGVcbiAgLy8gVGhlIE1lZGlhIEluaXRpYWxpemF0aW9uIFNlY3Rpb24gZm9yIHRoaXMgc2VnbWVudFxuICBmdW5jdGlvbiBGcmFnbWVudCh0eXBlLCBiYXNldXJsKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX3RoaXMgPSBfQmFzZVNlZ21lbnQuY2FsbCh0aGlzLCBiYXNldXJsKSB8fCB0aGlzO1xuICAgIF90aGlzLl9kZWNyeXB0ZGF0YSA9IG51bGw7XG4gICAgX3RoaXMucmF3UHJvZ3JhbURhdGVUaW1lID0gbnVsbDtcbiAgICBfdGhpcy5wcm9ncmFtRGF0ZVRpbWUgPSBudWxsO1xuICAgIF90aGlzLnRhZ0xpc3QgPSBbXTtcbiAgICBfdGhpcy5kdXJhdGlvbiA9IDA7XG4gICAgX3RoaXMuc24gPSAwO1xuICAgIF90aGlzLmxldmVsa2V5ID0gdm9pZCAwO1xuICAgIF90aGlzLnR5cGUgPSB2b2lkIDA7XG4gICAgX3RoaXMubG9hZGVyID0gbnVsbDtcbiAgICBfdGhpcy5sZXZlbCA9IC0xO1xuICAgIF90aGlzLmNjID0gMDtcbiAgICBfdGhpcy5zdGFydFBUUyA9IHZvaWQgMDtcbiAgICBfdGhpcy5lbmRQVFMgPSB2b2lkIDA7XG4gICAgX3RoaXMuYXBwZW5kZWRQVFMgPSB2b2lkIDA7XG4gICAgX3RoaXMuc3RhcnREVFMgPSB2b2lkIDA7XG4gICAgX3RoaXMuZW5kRFRTID0gdm9pZCAwO1xuICAgIF90aGlzLnN0YXJ0ID0gMDtcbiAgICBfdGhpcy5kZWx0YVBUUyA9IHZvaWQgMDtcbiAgICBfdGhpcy5tYXhTdGFydFBUUyA9IHZvaWQgMDtcbiAgICBfdGhpcy5taW5FbmRQVFMgPSB2b2lkIDA7XG4gICAgX3RoaXMuc3RhdHMgPSBuZXcgX2xvYWRfc3RhdHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1tcIkxvYWRTdGF0c1wiXSgpO1xuICAgIF90aGlzLnVybElkID0gMDtcbiAgICBfdGhpcy5kYXRhID0gdm9pZCAwO1xuICAgIF90aGlzLmJpdHJhdGVUZXN0ID0gZmFsc2U7XG4gICAgX3RoaXMudGl0bGUgPSBudWxsO1xuICAgIF90aGlzLmluaXRTZWdtZW50ID0gbnVsbDtcbiAgICBfdGhpcy50eXBlID0gdHlwZTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvMiA9IEZyYWdtZW50LnByb3RvdHlwZTtcblxuICAvKipcbiAgICogVXRpbGl0eSBtZXRob2QgZm9yIHBhcnNlTGV2ZWxQbGF5bGlzdCB0byBjcmVhdGUgYW4gaW5pdGlhbGl6YXRpb24gdmVjdG9yIGZvciBhIGdpdmVuIHNlZ21lbnRcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNlZ21lbnROdW1iZXIgLSBzZWdtZW50IG51bWJlciB0byBnZW5lcmF0ZSBJViB3aXRoXG4gICAqIEByZXR1cm5zIHtVaW50OEFycmF5fVxuICAgKi9cbiAgX3Byb3RvMi5jcmVhdGVJbml0aWFsaXphdGlvblZlY3RvciA9IGZ1bmN0aW9uIGNyZWF0ZUluaXRpYWxpemF0aW9uVmVjdG9yKHNlZ21lbnROdW1iZXIpIHtcbiAgICB2YXIgdWludDhWaWV3ID0gbmV3IFVpbnQ4QXJyYXkoMTYpO1xuXG4gICAgZm9yICh2YXIgaSA9IDEyOyBpIDwgMTY7IGkrKykge1xuICAgICAgdWludDhWaWV3W2ldID0gc2VnbWVudE51bWJlciA+PiA4ICogKDE1IC0gaSkgJiAweGZmO1xuICAgIH1cblxuICAgIHJldHVybiB1aW50OFZpZXc7XG4gIH1cbiAgLyoqXG4gICAqIFV0aWxpdHkgbWV0aG9kIGZvciBwYXJzZUxldmVsUGxheWxpc3QgdG8gZ2V0IGEgZnJhZ21lbnQncyBkZWNyeXB0aW9uIGRhdGEgZnJvbSB0aGUgY3VycmVudGx5IHBhcnNlZCBlbmNyeXB0aW9uIGtleSBkYXRhXG4gICAqIEBwYXJhbSBsZXZlbGtleSAtIGEgcGxheWxpc3QncyBlbmNyeXB0aW9uIGluZm9cbiAgICogQHBhcmFtIHNlZ21lbnROdW1iZXIgLSB0aGUgZnJhZ21lbnQncyBzZWdtZW50IG51bWJlclxuICAgKiBAcmV0dXJucyB7TGV2ZWxLZXl9IC0gYW4gb2JqZWN0IHRvIGJlIGFwcGxpZWQgYXMgYSBmcmFnbWVudCdzIGRlY3J5cHRkYXRhXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvMi5zZXREZWNyeXB0RGF0YUZyb21MZXZlbEtleSA9IGZ1bmN0aW9uIHNldERlY3J5cHREYXRhRnJvbUxldmVsS2V5KGxldmVsa2V5LCBzZWdtZW50TnVtYmVyKSB7XG4gICAgdmFyIGRlY3J5cHRkYXRhID0gbGV2ZWxrZXk7XG5cbiAgICBpZiAoKGxldmVsa2V5ID09PSBudWxsIHx8IGxldmVsa2V5ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsZXZlbGtleS5tZXRob2QpID09PSAnQUVTLTEyOCcgJiYgbGV2ZWxrZXkudXJpICYmICFsZXZlbGtleS5pdikge1xuICAgICAgZGVjcnlwdGRhdGEgPSBfbGV2ZWxfa2V5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJMZXZlbEtleVwiXS5mcm9tVVJJKGxldmVsa2V5LnVyaSk7XG4gICAgICBkZWNyeXB0ZGF0YS5tZXRob2QgPSBsZXZlbGtleS5tZXRob2Q7XG4gICAgICBkZWNyeXB0ZGF0YS5pdiA9IHRoaXMuY3JlYXRlSW5pdGlhbGl6YXRpb25WZWN0b3Ioc2VnbWVudE51bWJlcik7XG4gICAgICBkZWNyeXB0ZGF0YS5rZXlGb3JtYXQgPSAnaWRlbnRpdHknO1xuICAgIH1cblxuICAgIHJldHVybiBkZWNyeXB0ZGF0YTtcbiAgfTtcblxuICBfcHJvdG8yLnNldEVsZW1lbnRhcnlTdHJlYW1JbmZvID0gZnVuY3Rpb24gc2V0RWxlbWVudGFyeVN0cmVhbUluZm8odHlwZSwgc3RhcnRQVFMsIGVuZFBUUywgc3RhcnREVFMsIGVuZERUUywgcGFydGlhbCkge1xuICAgIGlmIChwYXJ0aWFsID09PSB2b2lkIDApIHtcbiAgICAgIHBhcnRpYWwgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgZWxlbWVudGFyeVN0cmVhbXMgPSB0aGlzLmVsZW1lbnRhcnlTdHJlYW1zO1xuICAgIHZhciBpbmZvID0gZWxlbWVudGFyeVN0cmVhbXNbdHlwZV07XG5cbiAgICBpZiAoIWluZm8pIHtcbiAgICAgIGVsZW1lbnRhcnlTdHJlYW1zW3R5cGVdID0ge1xuICAgICAgICBzdGFydFBUUzogc3RhcnRQVFMsXG4gICAgICAgIGVuZFBUUzogZW5kUFRTLFxuICAgICAgICBzdGFydERUUzogc3RhcnREVFMsXG4gICAgICAgIGVuZERUUzogZW5kRFRTLFxuICAgICAgICBwYXJ0aWFsOiBwYXJ0aWFsXG4gICAgICB9O1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGluZm8uc3RhcnRQVFMgPSBNYXRoLm1pbihpbmZvLnN0YXJ0UFRTLCBzdGFydFBUUyk7XG4gICAgaW5mby5lbmRQVFMgPSBNYXRoLm1heChpbmZvLmVuZFBUUywgZW5kUFRTKTtcbiAgICBpbmZvLnN0YXJ0RFRTID0gTWF0aC5taW4oaW5mby5zdGFydERUUywgc3RhcnREVFMpO1xuICAgIGluZm8uZW5kRFRTID0gTWF0aC5tYXgoaW5mby5lbmREVFMsIGVuZERUUyk7XG4gIH07XG5cbiAgX3Byb3RvMi5jbGVhckVsZW1lbnRhcnlTdHJlYW1JbmZvID0gZnVuY3Rpb24gY2xlYXJFbGVtZW50YXJ5U3RyZWFtSW5mbygpIHtcbiAgICB2YXIgZWxlbWVudGFyeVN0cmVhbXMgPSB0aGlzLmVsZW1lbnRhcnlTdHJlYW1zO1xuICAgIGVsZW1lbnRhcnlTdHJlYW1zW0VsZW1lbnRhcnlTdHJlYW1UeXBlcy5BVURJT10gPSBudWxsO1xuICAgIGVsZW1lbnRhcnlTdHJlYW1zW0VsZW1lbnRhcnlTdHJlYW1UeXBlcy5WSURFT10gPSBudWxsO1xuICAgIGVsZW1lbnRhcnlTdHJlYW1zW0VsZW1lbnRhcnlTdHJlYW1UeXBlcy5BVURJT1ZJREVPXSA9IG51bGw7XG4gIH07XG5cbiAgX2NyZWF0ZUNsYXNzKEZyYWdtZW50LCBbe1xuICAgIGtleTogXCJkZWNyeXB0ZGF0YVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgaWYgKCF0aGlzLmxldmVsa2V5ICYmICF0aGlzLl9kZWNyeXB0ZGF0YSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLl9kZWNyeXB0ZGF0YSAmJiB0aGlzLmxldmVsa2V5KSB7XG4gICAgICAgIHZhciBzbiA9IHRoaXMuc247XG5cbiAgICAgICAgaWYgKHR5cGVvZiBzbiAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAvLyBXZSBhcmUgZmV0Y2hpbmcgZGVjcnlwdGlvbiBkYXRhIGZvciBhIGluaXRpYWxpemF0aW9uIHNlZ21lbnRcbiAgICAgICAgICAvLyBJZiB0aGUgc2VnbWVudCB3YXMgZW5jcnlwdGVkIHdpdGggQUVTLTEyOFxuICAgICAgICAgIC8vIEl0IG11c3QgaGF2ZSBhbiBJViBkZWZpbmVkLiBXZSBjYW5ub3Qgc3Vic3RpdHV0ZSB0aGUgU2VnbWVudCBOdW1iZXIgaW4uXG4gICAgICAgICAgaWYgKHRoaXMubGV2ZWxrZXkgJiYgdGhpcy5sZXZlbGtleS5tZXRob2QgPT09ICdBRVMtMTI4JyAmJiAhdGhpcy5sZXZlbGtleS5pdikge1xuICAgICAgICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wibG9nZ2VyXCJdLndhcm4oXCJtaXNzaW5nIElWIGZvciBpbml0aWFsaXphdGlvbiBzZWdtZW50IHdpdGggbWV0aG9kPVxcXCJcIiArIHRoaXMubGV2ZWxrZXkubWV0aG9kICsgXCJcXFwiIC0gY29tcGxpYW5jZSBpc3N1ZVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLypcbiAgICAgICAgICBCZSBjb252ZXJ0ZWQgdG8gYSBOdW1iZXIuXG4gICAgICAgICAgJ2luaXRTZWdtZW50JyB3aWxsIGJlY29tZSBOYU4uXG4gICAgICAgICAgTmFOLCB3aGljaCB3aGVuIGNvbnZlcnRlZCB0aHJvdWdoIFRvSW50MzIoKSAtPiArMC5cbiAgICAgICAgICAtLS1cbiAgICAgICAgICBFeHBsaWNpdGx5IHNldCBzbiB0byByZXN1bHRpbmcgdmFsdWUgZnJvbSBpbXBsaWNpdCBjb252ZXJzaW9ucyAnaW5pdFNlZ21lbnQnIHZhbHVlcyBmb3IgSVYgZ2VuZXJhdGlvbi5cbiAgICAgICAgICAqL1xuXG5cbiAgICAgICAgICBzbiA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9kZWNyeXB0ZGF0YSA9IHRoaXMuc2V0RGVjcnlwdERhdGFGcm9tTGV2ZWxLZXkodGhpcy5sZXZlbGtleSwgc24pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5fZGVjcnlwdGRhdGE7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVuZFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuc3RhcnQgKyB0aGlzLmR1cmF0aW9uO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlbmRQcm9ncmFtRGF0ZVRpbWVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIGlmICh0aGlzLnByb2dyYW1EYXRlVGltZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaWYgKCFPYmplY3QoX2hvbWVfcnVubmVyX3dvcmtfaGxzX2pzX2hsc19qc19zcmNfcG9seWZpbGxzX251bWJlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiaXNGaW5pdGVOdW1iZXJcIl0pKHRoaXMucHJvZ3JhbURhdGVUaW1lKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIGR1cmF0aW9uID0gIU9iamVjdChfaG9tZV9ydW5uZXJfd29ya19obHNfanNfaGxzX2pzX3NyY19wb2x5ZmlsbHNfbnVtYmVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJpc0Zpbml0ZU51bWJlclwiXSkodGhpcy5kdXJhdGlvbikgPyAwIDogdGhpcy5kdXJhdGlvbjtcbiAgICAgIHJldHVybiB0aGlzLnByb2dyYW1EYXRlVGltZSArIGR1cmF0aW9uICogMTAwMDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZW5jcnlwdGVkXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgX3RoaXMkZGVjcnlwdGRhdGE7XG5cbiAgICAgIC8vIEF0IHRoZSBtM3U4LXBhcnNlciBsZXZlbCB3ZSBuZWVkIHRvIGFkZCBzdXBwb3J0IGZvciBtYW5pZmVzdCBzaWduYWxsZWQga2V5Zm9ybWF0c1xuICAgICAgLy8gd2hlbiB3ZSB3YW50IHRoZSBmcmFnbWVudCB0byBzdGFydCByZXBvcnRpbmcgdGhhdCBpdCBpcyBlbmNyeXB0ZWQuXG4gICAgICAvLyBDdXJyZW50bHksIGtleUZvcm1hdCB3aWxsIG9ubHkgYmUgc2V0IGZvciBpZGVudGl0eSBrZXlzXG4gICAgICBpZiAoKF90aGlzJGRlY3J5cHRkYXRhID0gdGhpcy5kZWNyeXB0ZGF0YSkgIT09IG51bGwgJiYgX3RoaXMkZGVjcnlwdGRhdGEgIT09IHZvaWQgMCAmJiBfdGhpcyRkZWNyeXB0ZGF0YS5rZXlGb3JtYXQgJiYgdGhpcy5kZWNyeXB0ZGF0YS51cmkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRnJhZ21lbnQ7XG59KEJhc2VTZWdtZW50KTtcbnZhciBQYXJ0ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQmFzZVNlZ21lbnQyKSB7XG4gIF9pbmhlcml0c0xvb3NlKFBhcnQsIF9CYXNlU2VnbWVudDIpO1xuXG4gIGZ1bmN0aW9uIFBhcnQocGFydEF0dHJzLCBmcmFnLCBiYXNldXJsLCBpbmRleCwgcHJldmlvdXMpIHtcbiAgICB2YXIgX3RoaXMyO1xuXG4gICAgX3RoaXMyID0gX0Jhc2VTZWdtZW50Mi5jYWxsKHRoaXMsIGJhc2V1cmwpIHx8IHRoaXM7XG4gICAgX3RoaXMyLmZyYWdPZmZzZXQgPSAwO1xuICAgIF90aGlzMi5kdXJhdGlvbiA9IDA7XG4gICAgX3RoaXMyLmdhcCA9IGZhbHNlO1xuICAgIF90aGlzMi5pbmRlcGVuZGVudCA9IGZhbHNlO1xuICAgIF90aGlzMi5yZWx1cmwgPSB2b2lkIDA7XG4gICAgX3RoaXMyLmZyYWdtZW50ID0gdm9pZCAwO1xuICAgIF90aGlzMi5pbmRleCA9IHZvaWQgMDtcbiAgICBfdGhpczIuc3RhdHMgPSBuZXcgX2xvYWRfc3RhdHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1tcIkxvYWRTdGF0c1wiXSgpO1xuICAgIF90aGlzMi5kdXJhdGlvbiA9IHBhcnRBdHRycy5kZWNpbWFsRmxvYXRpbmdQb2ludCgnRFVSQVRJT04nKTtcbiAgICBfdGhpczIuZ2FwID0gcGFydEF0dHJzLmJvb2woJ0dBUCcpO1xuICAgIF90aGlzMi5pbmRlcGVuZGVudCA9IHBhcnRBdHRycy5ib29sKCdJTkRFUEVOREVOVCcpO1xuICAgIF90aGlzMi5yZWx1cmwgPSBwYXJ0QXR0cnMuZW51bWVyYXRlZFN0cmluZygnVVJJJyk7XG4gICAgX3RoaXMyLmZyYWdtZW50ID0gZnJhZztcbiAgICBfdGhpczIuaW5kZXggPSBpbmRleDtcbiAgICB2YXIgYnl0ZVJhbmdlID0gcGFydEF0dHJzLmVudW1lcmF0ZWRTdHJpbmcoJ0JZVEVSQU5HRScpO1xuXG4gICAgaWYgKGJ5dGVSYW5nZSkge1xuICAgICAgX3RoaXMyLnNldEJ5dGVSYW5nZShieXRlUmFuZ2UsIHByZXZpb3VzKTtcbiAgICB9XG5cbiAgICBpZiAocHJldmlvdXMpIHtcbiAgICAgIF90aGlzMi5mcmFnT2Zmc2V0ID0gcHJldmlvdXMuZnJhZ09mZnNldCArIHByZXZpb3VzLmR1cmF0aW9uO1xuICAgIH1cblxuICAgIHJldHVybiBfdGhpczI7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoUGFydCwgW3tcbiAgICBrZXk6IFwic3RhcnRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmZyYWdtZW50LnN0YXJ0ICsgdGhpcy5mcmFnT2Zmc2V0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlbmRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnN0YXJ0ICsgdGhpcy5kdXJhdGlvbjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibG9hZGVkXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgZWxlbWVudGFyeVN0cmVhbXMgPSB0aGlzLmVsZW1lbnRhcnlTdHJlYW1zO1xuICAgICAgcmV0dXJuICEhKGVsZW1lbnRhcnlTdHJlYW1zLmF1ZGlvIHx8IGVsZW1lbnRhcnlTdHJlYW1zLnZpZGVvIHx8IGVsZW1lbnRhcnlTdHJlYW1zLmF1ZGlvdmlkZW8pO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBQYXJ0O1xufShCYXNlU2VnbWVudCk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2xvYWRlci9rZXktbG9hZGVyLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2xvYWRlci9rZXktbG9hZGVyLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZGVmYXVsdFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIEtleUxvYWRlcjsgfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZXZlbnRzICovIFwiLi9zcmMvZXZlbnRzLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2Vycm9ycyAqLyBcIi4vc3JjL2Vycm9ycy50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9sb2dnZXIgKi8gXCIuL3NyYy91dGlscy9sb2dnZXIudHNcIik7XG4vKlxuICogRGVjcnlwdCBrZXkgTG9hZGVyXG4gKi9cblxuXG5cblxudmFyIEtleUxvYWRlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEtleUxvYWRlcihobHMpIHtcbiAgICB0aGlzLmhscyA9IHZvaWQgMDtcbiAgICB0aGlzLmxvYWRlcnMgPSB7fTtcbiAgICB0aGlzLmRlY3J5cHRrZXkgPSBudWxsO1xuICAgIHRoaXMuZGVjcnlwdHVybCA9IG51bGw7XG4gICAgdGhpcy5obHMgPSBobHM7XG5cbiAgICB0aGlzLl9yZWdpc3Rlckxpc3RlbmVycygpO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IEtleUxvYWRlci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLl9yZWdpc3Rlckxpc3RlbmVycyA9IGZ1bmN0aW9uIF9yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICB0aGlzLmhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJFdmVudHNcIl0uS0VZX0xPQURJTkcsIHRoaXMub25LZXlMb2FkaW5nLCB0aGlzKTtcbiAgfTtcblxuICBfcHJvdG8uX3VucmVnaXN0ZXJMaXN0ZW5lcnMgPSBmdW5jdGlvbiBfdW5yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICB0aGlzLmhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiRXZlbnRzXCJdLktFWV9MT0FESU5HLCB0aGlzLm9uS2V5TG9hZGluZyk7XG4gIH07XG5cbiAgX3Byb3RvLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgIHRoaXMuX3VucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcblxuICAgIGZvciAodmFyIGxvYWRlck5hbWUgaW4gdGhpcy5sb2FkZXJzKSB7XG4gICAgICB2YXIgbG9hZGVyID0gdGhpcy5sb2FkZXJzW2xvYWRlck5hbWVdO1xuXG4gICAgICBpZiAobG9hZGVyKSB7XG4gICAgICAgIGxvYWRlci5kZXN0cm95KCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5sb2FkZXJzID0ge307XG4gIH07XG5cbiAgX3Byb3RvLm9uS2V5TG9hZGluZyA9IGZ1bmN0aW9uIG9uS2V5TG9hZGluZyhldmVudCwgZGF0YSkge1xuICAgIHZhciBmcmFnID0gZGF0YS5mcmFnO1xuICAgIHZhciB0eXBlID0gZnJhZy50eXBlO1xuICAgIHZhciBsb2FkZXIgPSB0aGlzLmxvYWRlcnNbdHlwZV07XG5cbiAgICBpZiAoIWZyYWcuZGVjcnlwdGRhdGEpIHtcbiAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImxvZ2dlclwiXS53YXJuKCdNaXNzaW5nIGRlY3J5cHRpb24gZGF0YSBvbiBmcmFnbWVudCBpbiBvbktleUxvYWRpbmcnKTtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIExvYWQgdGhlIGtleSBpZiB0aGUgdXJpIGlzIGRpZmZlcmVudCBmcm9tIHByZXZpb3VzIG9uZSwgb3IgaWYgdGhlIGRlY3J5cHQga2V5IGhhcyBub3QgeWV0IGJlZW4gcmV0cmlldmVkXG5cblxuICAgIHZhciB1cmkgPSBmcmFnLmRlY3J5cHRkYXRhLnVyaTtcblxuICAgIGlmICh1cmkgIT09IHRoaXMuZGVjcnlwdHVybCB8fCB0aGlzLmRlY3J5cHRrZXkgPT09IG51bGwpIHtcbiAgICAgIHZhciBjb25maWcgPSB0aGlzLmhscy5jb25maWc7XG5cbiAgICAgIGlmIChsb2FkZXIpIHtcbiAgICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wibG9nZ2VyXCJdLndhcm4oXCJhYm9ydCBwcmV2aW91cyBrZXkgbG9hZGVyIGZvciB0eXBlOlwiICsgdHlwZSk7XG4gICAgICAgIGxvYWRlci5hYm9ydCgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXVyaSkge1xuICAgICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJsb2dnZXJcIl0ud2Fybigna2V5IHVyaSBpcyBmYWxzeScpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBMb2FkZXIgPSBjb25maWcubG9hZGVyO1xuICAgICAgdmFyIGZyYWdMb2FkZXIgPSBmcmFnLmxvYWRlciA9IHRoaXMubG9hZGVyc1t0eXBlXSA9IG5ldyBMb2FkZXIoY29uZmlnKTtcbiAgICAgIHRoaXMuZGVjcnlwdHVybCA9IHVyaTtcbiAgICAgIHRoaXMuZGVjcnlwdGtleSA9IG51bGw7XG4gICAgICB2YXIgbG9hZGVyQ29udGV4dCA9IHtcbiAgICAgICAgdXJsOiB1cmksXG4gICAgICAgIGZyYWc6IGZyYWcsXG4gICAgICAgIHJlc3BvbnNlVHlwZTogJ2FycmF5YnVmZmVyJ1xuICAgICAgfTsgLy8gbWF4UmV0cnkgaXMgMCBzbyB0aGF0IGluc3RlYWQgb2YgcmV0cnlpbmcgdGhlIHNhbWUga2V5IG9uIHRoZSBzYW1lIHZhcmlhbnQgbXVsdGlwbGUgdGltZXMsXG4gICAgICAvLyBrZXktbG9hZGVyIHdpbGwgdHJpZ2dlciBhbiBlcnJvciBhbmQgcmVseSBvbiBzdHJlYW0tY29udHJvbGxlciB0byBoYW5kbGUgcmV0cnkgbG9naWMuXG4gICAgICAvLyB0aGlzIHdpbGwgYWxzbyBhbGlnbiByZXRyeSBsb2dpYyB3aXRoIGZyYWdtZW50LWxvYWRlclxuXG4gICAgICB2YXIgbG9hZGVyQ29uZmlnID0ge1xuICAgICAgICB0aW1lb3V0OiBjb25maWcuZnJhZ0xvYWRpbmdUaW1lT3V0LFxuICAgICAgICBtYXhSZXRyeTogMCxcbiAgICAgICAgcmV0cnlEZWxheTogY29uZmlnLmZyYWdMb2FkaW5nUmV0cnlEZWxheSxcbiAgICAgICAgbWF4UmV0cnlEZWxheTogY29uZmlnLmZyYWdMb2FkaW5nTWF4UmV0cnlUaW1lb3V0LFxuICAgICAgICBoaWdoV2F0ZXJNYXJrOiAwXG4gICAgICB9O1xuICAgICAgdmFyIGxvYWRlckNhbGxiYWNrcyA9IHtcbiAgICAgICAgb25TdWNjZXNzOiB0aGlzLmxvYWRzdWNjZXNzLmJpbmQodGhpcyksXG4gICAgICAgIG9uRXJyb3I6IHRoaXMubG9hZGVycm9yLmJpbmQodGhpcyksXG4gICAgICAgIG9uVGltZW91dDogdGhpcy5sb2FkdGltZW91dC5iaW5kKHRoaXMpXG4gICAgICB9O1xuICAgICAgZnJhZ0xvYWRlci5sb2FkKGxvYWRlckNvbnRleHQsIGxvYWRlckNvbmZpZywgbG9hZGVyQ2FsbGJhY2tzKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuZGVjcnlwdGtleSkge1xuICAgICAgLy8gUmV0dXJuIHRoZSBrZXkgaWYgaXQncyBhbHJlYWR5IGJlZW4gbG9hZGVkXG4gICAgICBmcmFnLmRlY3J5cHRkYXRhLmtleSA9IHRoaXMuZGVjcnlwdGtleTtcbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiRXZlbnRzXCJdLktFWV9MT0FERUQsIHtcbiAgICAgICAgZnJhZzogZnJhZ1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5sb2Fkc3VjY2VzcyA9IGZ1bmN0aW9uIGxvYWRzdWNjZXNzKHJlc3BvbnNlLCBzdGF0cywgY29udGV4dCkge1xuICAgIHZhciBmcmFnID0gY29udGV4dC5mcmFnO1xuXG4gICAgaWYgKCFmcmFnLmRlY3J5cHRkYXRhKSB7XG4gICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJsb2dnZXJcIl0uZXJyb3IoJ2FmdGVyIGtleSBsb2FkLCBkZWNyeXB0ZGF0YSB1bnNldCcpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuZGVjcnlwdGtleSA9IGZyYWcuZGVjcnlwdGRhdGEua2V5ID0gbmV3IFVpbnQ4QXJyYXkocmVzcG9uc2UuZGF0YSk7IC8vIGRldGFjaCBmcmFnbWVudCBsb2FkZXIgb24gbG9hZCBzdWNjZXNzXG5cbiAgICBmcmFnLmxvYWRlciA9IG51bGw7XG4gICAgZGVsZXRlIHRoaXMubG9hZGVyc1tmcmFnLnR5cGVdO1xuICAgIHRoaXMuaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiRXZlbnRzXCJdLktFWV9MT0FERUQsIHtcbiAgICAgIGZyYWc6IGZyYWdcbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG8ubG9hZGVycm9yID0gZnVuY3Rpb24gbG9hZGVycm9yKHJlc3BvbnNlLCBjb250ZXh0KSB7XG4gICAgdmFyIGZyYWcgPSBjb250ZXh0LmZyYWc7XG4gICAgdmFyIGxvYWRlciA9IGZyYWcubG9hZGVyO1xuXG4gICAgaWYgKGxvYWRlcikge1xuICAgICAgbG9hZGVyLmFib3J0KCk7XG4gICAgfVxuXG4gICAgZGVsZXRlIHRoaXMubG9hZGVyc1tmcmFnLnR5cGVdO1xuICAgIHRoaXMuaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiRXZlbnRzXCJdLkVSUk9SLCB7XG4gICAgICB0eXBlOiBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFcnJvclR5cGVzXCJdLk5FVFdPUktfRVJST1IsXG4gICAgICBkZXRhaWxzOiBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFcnJvckRldGFpbHNcIl0uS0VZX0xPQURfRVJST1IsXG4gICAgICBmYXRhbDogZmFsc2UsXG4gICAgICBmcmFnOiBmcmFnLFxuICAgICAgcmVzcG9uc2U6IHJlc3BvbnNlXG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLmxvYWR0aW1lb3V0ID0gZnVuY3Rpb24gbG9hZHRpbWVvdXQoc3RhdHMsIGNvbnRleHQpIHtcbiAgICB2YXIgZnJhZyA9IGNvbnRleHQuZnJhZztcbiAgICB2YXIgbG9hZGVyID0gZnJhZy5sb2FkZXI7XG5cbiAgICBpZiAobG9hZGVyKSB7XG4gICAgICBsb2FkZXIuYWJvcnQoKTtcbiAgICB9XG5cbiAgICBkZWxldGUgdGhpcy5sb2FkZXJzW2ZyYWcudHlwZV07XG4gICAgdGhpcy5obHMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJFdmVudHNcIl0uRVJST1IsIHtcbiAgICAgIHR5cGU6IF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkVycm9yVHlwZXNcIl0uTkVUV09SS19FUlJPUixcbiAgICAgIGRldGFpbHM6IF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkVycm9yRGV0YWlsc1wiXS5LRVlfTE9BRF9USU1FT1VULFxuICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgZnJhZzogZnJhZ1xuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiBLZXlMb2FkZXI7XG59KCk7XG5cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9sb2FkZXIvbGV2ZWwtZGV0YWlscy50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9sb2FkZXIvbGV2ZWwtZGV0YWlscy50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBMZXZlbERldGFpbHMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiTGV2ZWxEZXRhaWxzXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gTGV2ZWxEZXRhaWxzOyB9KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfaG9tZV9ydW5uZXJfd29ya19obHNfanNfaGxzX2pzX3NyY19wb2x5ZmlsbHNfbnVtYmVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3NyYy9wb2x5ZmlsbHMvbnVtYmVyICovIFwiLi9zcmMvcG9seWZpbGxzL251bWJlci50c1wiKTtcblxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbnZhciBERUZBVUxUX1RBUkdFVF9EVVJBVElPTiA9IDEwO1xudmFyIExldmVsRGV0YWlscyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8vIE1hbmlmZXN0IHJlbG9hZCBzeW5jaHJvbml6YXRpb25cbiAgZnVuY3Rpb24gTGV2ZWxEZXRhaWxzKGJhc2VVcmwpIHtcbiAgICB0aGlzLlBUU0tub3duID0gZmFsc2U7XG4gICAgdGhpcy5hbGlnbmVkU2xpZGluZyA9IGZhbHNlO1xuICAgIHRoaXMuYXZlcmFnZXRhcmdldGR1cmF0aW9uID0gdm9pZCAwO1xuICAgIHRoaXMuZW5kQ0MgPSAwO1xuICAgIHRoaXMuZW5kU04gPSAwO1xuICAgIHRoaXMuZnJhZ21lbnRzID0gdm9pZCAwO1xuICAgIHRoaXMuZnJhZ21lbnRIaW50ID0gdm9pZCAwO1xuICAgIHRoaXMucGFydExpc3QgPSBudWxsO1xuICAgIHRoaXMubGl2ZSA9IHRydWU7XG4gICAgdGhpcy5hZ2VIZWFkZXIgPSAwO1xuICAgIHRoaXMuYWR2YW5jZWREYXRlVGltZSA9IHZvaWQgMDtcbiAgICB0aGlzLnVwZGF0ZWQgPSB0cnVlO1xuICAgIHRoaXMuYWR2YW5jZWQgPSB0cnVlO1xuICAgIHRoaXMuYXZhaWxhYmlsaXR5RGVsYXkgPSB2b2lkIDA7XG4gICAgdGhpcy5taXNzZXMgPSAwO1xuICAgIHRoaXMubmVlZFNpZHhSYW5nZXMgPSBmYWxzZTtcbiAgICB0aGlzLnN0YXJ0Q0MgPSAwO1xuICAgIHRoaXMuc3RhcnRTTiA9IDA7XG4gICAgdGhpcy5zdGFydFRpbWVPZmZzZXQgPSBudWxsO1xuICAgIHRoaXMudGFyZ2V0ZHVyYXRpb24gPSAwO1xuICAgIHRoaXMudG90YWxkdXJhdGlvbiA9IDA7XG4gICAgdGhpcy50eXBlID0gbnVsbDtcbiAgICB0aGlzLnVybCA9IHZvaWQgMDtcbiAgICB0aGlzLm0zdTggPSAnJztcbiAgICB0aGlzLnZlcnNpb24gPSBudWxsO1xuICAgIHRoaXMuY2FuQmxvY2tSZWxvYWQgPSBmYWxzZTtcbiAgICB0aGlzLmNhblNraXBVbnRpbCA9IDA7XG4gICAgdGhpcy5jYW5Ta2lwRGF0ZVJhbmdlcyA9IGZhbHNlO1xuICAgIHRoaXMuc2tpcHBlZFNlZ21lbnRzID0gMDtcbiAgICB0aGlzLnJlY2VudGx5UmVtb3ZlZERhdGVyYW5nZXMgPSB2b2lkIDA7XG4gICAgdGhpcy5wYXJ0SG9sZEJhY2sgPSAwO1xuICAgIHRoaXMuaG9sZEJhY2sgPSAwO1xuICAgIHRoaXMucGFydFRhcmdldCA9IDA7XG4gICAgdGhpcy5wcmVsb2FkSGludCA9IHZvaWQgMDtcbiAgICB0aGlzLnJlbmRpdGlvblJlcG9ydHMgPSB2b2lkIDA7XG4gICAgdGhpcy50dW5lSW5Hb2FsID0gMDtcbiAgICB0aGlzLmRlbHRhVXBkYXRlRmFpbGVkID0gdm9pZCAwO1xuICAgIHRoaXMuZHJpZnRTdGFydFRpbWUgPSAwO1xuICAgIHRoaXMuZHJpZnRFbmRUaW1lID0gMDtcbiAgICB0aGlzLmRyaWZ0U3RhcnQgPSAwO1xuICAgIHRoaXMuZHJpZnRFbmQgPSAwO1xuICAgIHRoaXMuZnJhZ21lbnRzID0gW107XG4gICAgdGhpcy51cmwgPSBiYXNlVXJsO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IExldmVsRGV0YWlscy5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLnJlbG9hZGVkID0gZnVuY3Rpb24gcmVsb2FkZWQocHJldmlvdXMpIHtcbiAgICBpZiAoIXByZXZpb3VzKSB7XG4gICAgICB0aGlzLmFkdmFuY2VkID0gdHJ1ZTtcbiAgICAgIHRoaXMudXBkYXRlZCA9IHRydWU7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHBhcnRTbkRpZmYgPSB0aGlzLmxhc3RQYXJ0U24gLSBwcmV2aW91cy5sYXN0UGFydFNuO1xuICAgIHZhciBwYXJ0SW5kZXhEaWZmID0gdGhpcy5sYXN0UGFydEluZGV4IC0gcHJldmlvdXMubGFzdFBhcnRJbmRleDtcbiAgICB0aGlzLnVwZGF0ZWQgPSB0aGlzLmVuZFNOICE9PSBwcmV2aW91cy5lbmRTTiB8fCAhIXBhcnRJbmRleERpZmYgfHwgISFwYXJ0U25EaWZmO1xuICAgIHRoaXMuYWR2YW5jZWQgPSB0aGlzLmVuZFNOID4gcHJldmlvdXMuZW5kU04gfHwgcGFydFNuRGlmZiA+IDAgfHwgcGFydFNuRGlmZiA9PT0gMCAmJiBwYXJ0SW5kZXhEaWZmID4gMDtcblxuICAgIGlmICh0aGlzLnVwZGF0ZWQgfHwgdGhpcy5hZHZhbmNlZCkge1xuICAgICAgdGhpcy5taXNzZXMgPSBNYXRoLmZsb29yKHByZXZpb3VzLm1pc3NlcyAqIDAuNik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubWlzc2VzID0gcHJldmlvdXMubWlzc2VzICsgMTtcbiAgICB9XG5cbiAgICB0aGlzLmF2YWlsYWJpbGl0eURlbGF5ID0gcHJldmlvdXMuYXZhaWxhYmlsaXR5RGVsYXk7XG4gIH07XG5cbiAgX2NyZWF0ZUNsYXNzKExldmVsRGV0YWlscywgW3tcbiAgICBrZXk6IFwiaGFzUHJvZ3JhbURhdGVUaW1lXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICBpZiAodGhpcy5mcmFnbWVudHMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QoX2hvbWVfcnVubmVyX3dvcmtfaGxzX2pzX2hsc19qc19zcmNfcG9seWZpbGxzX251bWJlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiaXNGaW5pdGVOdW1iZXJcIl0pKHRoaXMuZnJhZ21lbnRzW3RoaXMuZnJhZ21lbnRzLmxlbmd0aCAtIDFdLnByb2dyYW1EYXRlVGltZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibGV2ZWxUYXJnZXREdXJhdGlvblwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuYXZlcmFnZXRhcmdldGR1cmF0aW9uIHx8IHRoaXMudGFyZ2V0ZHVyYXRpb24gfHwgREVGQVVMVF9UQVJHRVRfRFVSQVRJT047XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRyaWZ0XCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgcnVuVGltZSA9IHRoaXMuZHJpZnRFbmRUaW1lIC0gdGhpcy5kcmlmdFN0YXJ0VGltZTtcblxuICAgICAgaWYgKHJ1blRpbWUgPiAwKSB7XG4gICAgICAgIHZhciBydW5EdXJhdGlvbiA9IHRoaXMuZHJpZnRFbmQgLSB0aGlzLmRyaWZ0U3RhcnQ7XG4gICAgICAgIHJldHVybiBydW5EdXJhdGlvbiAqIDEwMDAgLyBydW5UaW1lO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZWRnZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMucGFydEVuZCB8fCB0aGlzLmZyYWdtZW50RW5kO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwYXJ0RW5kXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgX3RoaXMkcGFydExpc3Q7XG5cbiAgICAgIGlmICgoX3RoaXMkcGFydExpc3QgPSB0aGlzLnBhcnRMaXN0KSAhPT0gbnVsbCAmJiBfdGhpcyRwYXJ0TGlzdCAhPT0gdm9pZCAwICYmIF90aGlzJHBhcnRMaXN0Lmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJ0TGlzdFt0aGlzLnBhcnRMaXN0Lmxlbmd0aCAtIDFdLmVuZDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuZnJhZ21lbnRFbmQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZyYWdtZW50RW5kXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgX3RoaXMkZnJhZ21lbnRzO1xuXG4gICAgICBpZiAoKF90aGlzJGZyYWdtZW50cyA9IHRoaXMuZnJhZ21lbnRzKSAhPT0gbnVsbCAmJiBfdGhpcyRmcmFnbWVudHMgIT09IHZvaWQgMCAmJiBfdGhpcyRmcmFnbWVudHMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZyYWdtZW50c1t0aGlzLmZyYWdtZW50cy5sZW5ndGggLSAxXS5lbmQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZ2VcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIGlmICh0aGlzLmFkdmFuY2VkRGF0ZVRpbWUpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KERhdGUubm93KCkgLSB0aGlzLmFkdmFuY2VkRGF0ZVRpbWUsIDApIC8gMTAwMDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImxhc3RQYXJ0SW5kZXhcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciBfdGhpcyRwYXJ0TGlzdDI7XG5cbiAgICAgIGlmICgoX3RoaXMkcGFydExpc3QyID0gdGhpcy5wYXJ0TGlzdCkgIT09IG51bGwgJiYgX3RoaXMkcGFydExpc3QyICE9PSB2b2lkIDAgJiYgX3RoaXMkcGFydExpc3QyLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJ0TGlzdFt0aGlzLnBhcnRMaXN0Lmxlbmd0aCAtIDFdLmluZGV4O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImxhc3RQYXJ0U25cIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciBfdGhpcyRwYXJ0TGlzdDM7XG5cbiAgICAgIGlmICgoX3RoaXMkcGFydExpc3QzID0gdGhpcy5wYXJ0TGlzdCkgIT09IG51bGwgJiYgX3RoaXMkcGFydExpc3QzICE9PSB2b2lkIDAgJiYgX3RoaXMkcGFydExpc3QzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJ0TGlzdFt0aGlzLnBhcnRMaXN0Lmxlbmd0aCAtIDFdLmZyYWdtZW50LnNuO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5lbmRTTjtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTGV2ZWxEZXRhaWxzO1xufSgpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9sb2FkZXIvbGV2ZWwta2V5LnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvbG9hZGVyL2xldmVsLWtleS50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IExldmVsS2V5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIkxldmVsS2V5XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gTGV2ZWxLZXk7IH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHVybF90b29sa2l0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISB1cmwtdG9vbGtpdCAqLyBcIi4vbm9kZV9tb2R1bGVzL3VybC10b29sa2l0L3NyYy91cmwtdG9vbGtpdC5qc1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciB1cmxfdG9vbGtpdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKHVybF90b29sa2l0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18pO1xuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5cbnZhciBMZXZlbEtleSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIExldmVsS2V5LmZyb21VUkwgPSBmdW5jdGlvbiBmcm9tVVJMKGJhc2VVcmwsIHJlbGF0aXZlVXJsKSB7XG4gICAgcmV0dXJuIG5ldyBMZXZlbEtleShiYXNlVXJsLCByZWxhdGl2ZVVybCk7XG4gIH07XG5cbiAgTGV2ZWxLZXkuZnJvbVVSSSA9IGZ1bmN0aW9uIGZyb21VUkkodXJpKSB7XG4gICAgcmV0dXJuIG5ldyBMZXZlbEtleSh1cmkpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIExldmVsS2V5KGFic29sdXRlT3JCYXNlVVJJLCByZWxhdGl2ZVVSTCkge1xuICAgIHRoaXMuX3VyaSA9IG51bGw7XG4gICAgdGhpcy5tZXRob2QgPSBudWxsO1xuICAgIHRoaXMua2V5Rm9ybWF0ID0gbnVsbDtcbiAgICB0aGlzLmtleUZvcm1hdFZlcnNpb25zID0gbnVsbDtcbiAgICB0aGlzLmtleUlEID0gbnVsbDtcbiAgICB0aGlzLmtleSA9IG51bGw7XG4gICAgdGhpcy5pdiA9IG51bGw7XG5cbiAgICBpZiAocmVsYXRpdmVVUkwpIHtcbiAgICAgIHRoaXMuX3VyaSA9IE9iamVjdCh1cmxfdG9vbGtpdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiYnVpbGRBYnNvbHV0ZVVSTFwiXSkoYWJzb2x1dGVPckJhc2VVUkksIHJlbGF0aXZlVVJMLCB7XG4gICAgICAgIGFsd2F5c05vcm1hbGl6ZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3VyaSA9IGFic29sdXRlT3JCYXNlVVJJO1xuICAgIH1cbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhMZXZlbEtleSwgW3tcbiAgICBrZXk6IFwidXJpXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdXJpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBMZXZlbEtleTtcbn0oKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvbG9hZGVyL2xvYWQtc3RhdHMudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvbG9hZGVyL2xvYWQtc3RhdHMudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogTG9hZFN0YXRzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIkxvYWRTdGF0c1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIExvYWRTdGF0czsgfSk7XG52YXIgTG9hZFN0YXRzID0gZnVuY3Rpb24gTG9hZFN0YXRzKCkge1xuICB0aGlzLmFib3J0ZWQgPSBmYWxzZTtcbiAgdGhpcy5sb2FkZWQgPSAwO1xuICB0aGlzLnJldHJ5ID0gMDtcbiAgdGhpcy50b3RhbCA9IDA7XG4gIHRoaXMuY2h1bmtDb3VudCA9IDA7XG4gIHRoaXMuYndFc3RpbWF0ZSA9IDA7XG4gIHRoaXMubG9hZGluZyA9IHtcbiAgICBzdGFydDogMCxcbiAgICBmaXJzdDogMCxcbiAgICBlbmQ6IDBcbiAgfTtcbiAgdGhpcy5wYXJzaW5nID0ge1xuICAgIHN0YXJ0OiAwLFxuICAgIGVuZDogMFxuICB9O1xuICB0aGlzLmJ1ZmZlcmluZyA9IHtcbiAgICBzdGFydDogMCxcbiAgICBmaXJzdDogMCxcbiAgICBlbmQ6IDBcbiAgfTtcbn07XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2xvYWRlci9tM3U4LXBhcnNlci50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvbG9hZGVyL20zdTgtcGFyc2VyLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImRlZmF1bHRcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBNM1U4UGFyc2VyOyB9KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfaG9tZV9ydW5uZXJfd29ya19obHNfanNfaGxzX2pzX3NyY19wb2x5ZmlsbHNfbnVtYmVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3NyYy9wb2x5ZmlsbHMvbnVtYmVyICovIFwiLi9zcmMvcG9seWZpbGxzL251bWJlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciB1cmxfdG9vbGtpdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgdXJsLXRvb2xraXQgKi8gXCIuL25vZGVfbW9kdWxlcy91cmwtdG9vbGtpdC9zcmMvdXJsLXRvb2xraXQuanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgdXJsX3Rvb2xraXRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubih1cmxfdG9vbGtpdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZnJhZ21lbnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZnJhZ21lbnQgKi8gXCIuL3NyYy9sb2FkZXIvZnJhZ21lbnQudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2xldmVsX2RldGFpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbGV2ZWwtZGV0YWlscyAqLyBcIi4vc3JjL2xvYWRlci9sZXZlbC1kZXRhaWxzLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9sZXZlbF9rZXlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbGV2ZWwta2V5ICovIFwiLi9zcmMvbG9hZGVyL2xldmVsLWtleS50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfYXR0cl9saXN0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9hdHRyLWxpc3QgKi8gXCIuL3NyYy91dGlscy9hdHRyLWxpc3QudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvbG9nZ2VyICovIFwiLi9zcmMvdXRpbHMvbG9nZ2VyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19jb2RlY3NfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL2NvZGVjcyAqLyBcIi4vc3JjL3V0aWxzL2NvZGVjcy50c1wiKTtcblxuXG5cblxuXG5cblxuXG5cblxuXG4vLyBodHRwczovL3JlZ2V4MTAxLmNvbSBpcyB5b3VyIGZyaWVuZFxudmFyIE1BU1RFUl9QTEFZTElTVF9SRUdFWCA9IC8jRVhULVgtU1RSRUFNLUlORjooW15cXHJcXG5dKikoPzpbXFxyXFxuXSg/OiNbXlxcclxcbl0qKT8pKihbXlxcclxcbl0rKXwjRVhULVgtU0VTU0lPTi1EQVRBOihbXlxcclxcbl0qKVtcXHJcXG5dKy9nO1xudmFyIE1BU1RFUl9QTEFZTElTVF9NRURJQV9SRUdFWCA9IC8jRVhULVgtTUVESUE6KC4qKS9nO1xudmFyIExFVkVMX1BMQVlMSVNUX1JFR0VYX0ZBU1QgPSBuZXcgUmVnRXhwKFsvI0VYVElORjpcXHMqKFxcZCooPzpcXC5cXGQrKT8pKD86LCguKilcXHMrKT8vLnNvdXJjZSwgLy8gZHVyYXRpb24gKCNFWFRJTkY6PGR1cmF0aW9uPiw8dGl0bGU+KSwgZ3JvdXAgMSA9PiBkdXJhdGlvbiwgZ3JvdXAgMiA9PiB0aXRsZVxuLyg/ISMpICooXFxTW1xcUyBdKikvLnNvdXJjZSwgLy8gc2VnbWVudCBVUkksIGdyb3VwIDMgPT4gdGhlIFVSSSAobm90ZSBuZXdsaW5lIGlzIG5vdCBlYXRlbilcbi8jRVhULVgtQllURVJBTkdFOiooLispLy5zb3VyY2UsIC8vIG5leHQgc2VnbWVudCdzIGJ5dGVyYW5nZSwgZ3JvdXAgNCA9PiByYW5nZSBzcGVjICh4QHkpXG4vI0VYVC1YLVBST0dSQU0tREFURS1USU1FOiguKykvLnNvdXJjZSwgLy8gbmV4dCBzZWdtZW50J3MgcHJvZ3JhbSBkYXRlL3RpbWUgZ3JvdXAgNSA9PiB0aGUgZGF0ZXRpbWUgc3BlY1xuLyMuKi8uc291cmNlIC8vIEFsbCBvdGhlciBub24tc2VnbWVudCBvcmllbnRlZCB0YWdzIHdpbGwgbWF0Y2ggd2l0aCBhbGwgZ3JvdXBzIGVtcHR5XG5dLmpvaW4oJ3wnKSwgJ2cnKTtcbnZhciBMRVZFTF9QTEFZTElTVF9SRUdFWF9TTE9XID0gbmV3IFJlZ0V4cChbLyMoRVhUTTNVKS8uc291cmNlLCAvI0VYVC1YLShQTEFZTElTVC1UWVBFKTooLispLy5zb3VyY2UsIC8jRVhULVgtKE1FRElBLVNFUVVFTkNFKTogKihcXGQrKS8uc291cmNlLCAvI0VYVC1YLShTS0lQKTooLispLy5zb3VyY2UsIC8jRVhULVgtKFRBUkdFVERVUkFUSU9OKTogKihcXGQrKS8uc291cmNlLCAvI0VYVC1YLShLRVkpOiguKykvLnNvdXJjZSwgLyNFWFQtWC0oU1RBUlQpOiguKykvLnNvdXJjZSwgLyNFWFQtWC0oRU5ETElTVCkvLnNvdXJjZSwgLyNFWFQtWC0oRElTQ09OVElOVUlUWS1TRVEpVUVOQ0U6ICooXFxkKykvLnNvdXJjZSwgLyNFWFQtWC0oRElTKUNPTlRJTlVJVFkvLnNvdXJjZSwgLyNFWFQtWC0oVkVSU0lPTik6KFxcZCspLy5zb3VyY2UsIC8jRVhULVgtKE1BUCk6KC4rKS8uc291cmNlLCAvI0VYVC1YLShTRVJWRVItQ09OVFJPTCk6KC4rKS8uc291cmNlLCAvI0VYVC1YLShQQVJULUlORik6KC4rKS8uc291cmNlLCAvI0VYVC1YLShHQVApLy5zb3VyY2UsIC8jRVhULVgtKEJJVFJBVEUpOlxccyooXFxkKykvLnNvdXJjZSwgLyNFWFQtWC0oUEFSVCk6KC4rKS8uc291cmNlLCAvI0VYVC1YLShQUkVMT0FELUhJTlQpOiguKykvLnNvdXJjZSwgLyNFWFQtWC0oUkVORElUSU9OLVJFUE9SVCk6KC4rKS8uc291cmNlLCAvKCMpKFteOl0qKTooLiopLy5zb3VyY2UsIC8oIykoLiopKD86LiopXFxyP1xcbj8vLnNvdXJjZV0uam9pbignfCcpKTtcbnZhciBNUDRfUkVHRVhfU1VGRklYID0gL1xcLihtcDR8bTRzfG00dnxtNGEpJC9pO1xuXG5mdW5jdGlvbiBpc01QNFVybCh1cmwpIHtcbiAgdmFyIF9VUkxUb29sa2l0JHBhcnNlVVJMJCwgX1VSTFRvb2xraXQkcGFyc2VVUkw7XG5cbiAgcmV0dXJuIE1QNF9SRUdFWF9TVUZGSVgudGVzdCgoX1VSTFRvb2xraXQkcGFyc2VVUkwkID0gKF9VUkxUb29sa2l0JHBhcnNlVVJMID0gdXJsX3Rvb2xraXRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcInBhcnNlVVJMXCJdKHVybCkpID09PSBudWxsIHx8IF9VUkxUb29sa2l0JHBhcnNlVVJMID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfVVJMVG9vbGtpdCRwYXJzZVVSTC5wYXRoKSAhPSBudWxsID8gX1VSTFRvb2xraXQkcGFyc2VVUkwkIDogJycpO1xufVxuXG52YXIgTTNVOFBhcnNlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIE0zVThQYXJzZXIoKSB7fVxuXG4gIE0zVThQYXJzZXIuZmluZEdyb3VwID0gZnVuY3Rpb24gZmluZEdyb3VwKGdyb3VwcywgbWVkaWFHcm91cElkKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBncm91cHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBncm91cCA9IGdyb3Vwc1tpXTtcblxuICAgICAgaWYgKGdyb3VwLmlkID09PSBtZWRpYUdyb3VwSWQpIHtcbiAgICAgICAgcmV0dXJuIGdyb3VwO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBNM1U4UGFyc2VyLmNvbnZlcnRBVkMxVG9BVkNPVEkgPSBmdW5jdGlvbiBjb252ZXJ0QVZDMVRvQVZDT1RJKGNvZGVjKSB7XG4gICAgLy8gQ29udmVydCBhdmMxIGNvZGVjIHN0cmluZyBmcm9tIFJGQy00MjgxIHRvIFJGQy02MzgxIGZvciBNZWRpYVNvdXJjZS5pc1R5cGVTdXBwb3J0ZWRcbiAgICB2YXIgYXZjZGF0YSA9IGNvZGVjLnNwbGl0KCcuJyk7XG5cbiAgICBpZiAoYXZjZGF0YS5sZW5ndGggPiAyKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gYXZjZGF0YS5zaGlmdCgpICsgJy4nO1xuICAgICAgcmVzdWx0ICs9IHBhcnNlSW50KGF2Y2RhdGEuc2hpZnQoKSkudG9TdHJpbmcoMTYpO1xuICAgICAgcmVzdWx0ICs9ICgnMDAwJyArIHBhcnNlSW50KGF2Y2RhdGEuc2hpZnQoKSkudG9TdHJpbmcoMTYpKS5zdWJzdHIoLTQpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICByZXR1cm4gY29kZWM7XG4gIH07XG5cbiAgTTNVOFBhcnNlci5yZXNvbHZlID0gZnVuY3Rpb24gcmVzb2x2ZSh1cmwsIGJhc2VVcmwpIHtcbiAgICByZXR1cm4gdXJsX3Rvb2xraXRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImJ1aWxkQWJzb2x1dGVVUkxcIl0oYmFzZVVybCwgdXJsLCB7XG4gICAgICBhbHdheXNOb3JtYWxpemU6IHRydWVcbiAgICB9KTtcbiAgfTtcblxuICBNM1U4UGFyc2VyLnBhcnNlTWFzdGVyUGxheWxpc3QgPSBmdW5jdGlvbiBwYXJzZU1hc3RlclBsYXlsaXN0KHN0cmluZywgYmFzZXVybCkge1xuICAgIHZhciBsZXZlbHMgPSBbXTtcbiAgICB2YXIgc2Vzc2lvbkRhdGEgPSB7fTtcbiAgICB2YXIgaGFzU2Vzc2lvbkRhdGEgPSBmYWxzZTtcbiAgICBNQVNURVJfUExBWUxJU1RfUkVHRVgubGFzdEluZGV4ID0gMDtcbiAgICB2YXIgcmVzdWx0O1xuXG4gICAgd2hpbGUgKChyZXN1bHQgPSBNQVNURVJfUExBWUxJU1RfUkVHRVguZXhlYyhzdHJpbmcpKSAhPSBudWxsKSB7XG4gICAgICBpZiAocmVzdWx0WzFdKSB7XG4gICAgICAgIC8vICcjRVhULVgtU1RSRUFNLUlORicgaXMgZm91bmQsIHBhcnNlIGxldmVsIHRhZyAgaW4gZ3JvdXAgMVxuICAgICAgICB2YXIgYXR0cnMgPSBuZXcgX3V0aWxzX2F0dHJfbGlzdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1wiQXR0ckxpc3RcIl0ocmVzdWx0WzFdKTtcbiAgICAgICAgdmFyIGxldmVsID0ge1xuICAgICAgICAgIGF0dHJzOiBhdHRycyxcbiAgICAgICAgICBiaXRyYXRlOiBhdHRycy5kZWNpbWFsSW50ZWdlcignQVZFUkFHRS1CQU5EV0lEVEgnKSB8fCBhdHRycy5kZWNpbWFsSW50ZWdlcignQkFORFdJRFRIJyksXG4gICAgICAgICAgbmFtZTogYXR0cnMuTkFNRSxcbiAgICAgICAgICB1cmw6IE0zVThQYXJzZXIucmVzb2x2ZShyZXN1bHRbMl0sIGJhc2V1cmwpXG4gICAgICAgIH07XG4gICAgICAgIHZhciByZXNvbHV0aW9uID0gYXR0cnMuZGVjaW1hbFJlc29sdXRpb24oJ1JFU09MVVRJT04nKTtcblxuICAgICAgICBpZiAocmVzb2x1dGlvbikge1xuICAgICAgICAgIGxldmVsLndpZHRoID0gcmVzb2x1dGlvbi53aWR0aDtcbiAgICAgICAgICBsZXZlbC5oZWlnaHQgPSByZXNvbHV0aW9uLmhlaWdodDtcbiAgICAgICAgfVxuXG4gICAgICAgIHNldENvZGVjcygoYXR0cnMuQ09ERUNTIHx8ICcnKS5zcGxpdCgvWyAsXSsvKS5maWx0ZXIoZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICByZXR1cm4gYztcbiAgICAgICAgfSksIGxldmVsKTtcblxuICAgICAgICBpZiAobGV2ZWwudmlkZW9Db2RlYyAmJiBsZXZlbC52aWRlb0NvZGVjLmluZGV4T2YoJ2F2YzEnKSAhPT0gLTEpIHtcbiAgICAgICAgICBsZXZlbC52aWRlb0NvZGVjID0gTTNVOFBhcnNlci5jb252ZXJ0QVZDMVRvQVZDT1RJKGxldmVsLnZpZGVvQ29kZWMpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV2ZWxzLnB1c2gobGV2ZWwpO1xuICAgICAgfSBlbHNlIGlmIChyZXN1bHRbM10pIHtcbiAgICAgICAgLy8gJyNFWFQtWC1TRVNTSU9OLURBVEEnIGlzIGZvdW5kLCBwYXJzZSBzZXNzaW9uIGRhdGEgaW4gZ3JvdXAgM1xuICAgICAgICB2YXIgc2Vzc2lvbkF0dHJzID0gbmV3IF91dGlsc19hdHRyX2xpc3RfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcIkF0dHJMaXN0XCJdKHJlc3VsdFszXSk7XG5cbiAgICAgICAgaWYgKHNlc3Npb25BdHRyc1snREFUQS1JRCddKSB7XG4gICAgICAgICAgaGFzU2Vzc2lvbkRhdGEgPSB0cnVlO1xuICAgICAgICAgIHNlc3Npb25EYXRhW3Nlc3Npb25BdHRyc1snREFUQS1JRCddXSA9IHNlc3Npb25BdHRycztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBsZXZlbHM6IGxldmVscyxcbiAgICAgIHNlc3Npb25EYXRhOiBoYXNTZXNzaW9uRGF0YSA/IHNlc3Npb25EYXRhIDogbnVsbFxuICAgIH07XG4gIH07XG5cbiAgTTNVOFBhcnNlci5wYXJzZU1hc3RlclBsYXlsaXN0TWVkaWEgPSBmdW5jdGlvbiBwYXJzZU1hc3RlclBsYXlsaXN0TWVkaWEoc3RyaW5nLCBiYXNldXJsLCB0eXBlLCBncm91cHMpIHtcbiAgICBpZiAoZ3JvdXBzID09PSB2b2lkIDApIHtcbiAgICAgIGdyb3VwcyA9IFtdO1xuICAgIH1cblxuICAgIHZhciByZXN1bHQ7XG4gICAgdmFyIG1lZGlhcyA9IFtdO1xuICAgIHZhciBpZCA9IDA7XG4gICAgTUFTVEVSX1BMQVlMSVNUX01FRElBX1JFR0VYLmxhc3RJbmRleCA9IDA7XG5cbiAgICB3aGlsZSAoKHJlc3VsdCA9IE1BU1RFUl9QTEFZTElTVF9NRURJQV9SRUdFWC5leGVjKHN0cmluZykpICE9PSBudWxsKSB7XG4gICAgICB2YXIgYXR0cnMgPSBuZXcgX3V0aWxzX2F0dHJfbGlzdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1wiQXR0ckxpc3RcIl0ocmVzdWx0WzFdKTtcblxuICAgICAgaWYgKGF0dHJzLlRZUEUgPT09IHR5cGUpIHtcbiAgICAgICAgdmFyIG1lZGlhID0ge1xuICAgICAgICAgIGF0dHJzOiBhdHRycyxcbiAgICAgICAgICBiaXRyYXRlOiAwLFxuICAgICAgICAgIGlkOiBpZCsrLFxuICAgICAgICAgIGdyb3VwSWQ6IGF0dHJzWydHUk9VUC1JRCddLFxuICAgICAgICAgIGluc3RyZWFtSWQ6IGF0dHJzWydJTlNUUkVBTS1JRCddLFxuICAgICAgICAgIG5hbWU6IGF0dHJzLk5BTUUgfHwgYXR0cnMuTEFOR1VBR0UgfHwgJycsXG4gICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICBkZWZhdWx0OiBhdHRycy5ib29sKCdERUZBVUxUJyksXG4gICAgICAgICAgYXV0b3NlbGVjdDogYXR0cnMuYm9vbCgnQVVUT1NFTEVDVCcpLFxuICAgICAgICAgIGZvcmNlZDogYXR0cnMuYm9vbCgnRk9SQ0VEJyksXG4gICAgICAgICAgbGFuZzogYXR0cnMuTEFOR1VBR0UsXG4gICAgICAgICAgdXJsOiBhdHRycy5VUkkgPyBNM1U4UGFyc2VyLnJlc29sdmUoYXR0cnMuVVJJLCBiYXNldXJsKSA6ICcnXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGdyb3Vwcy5sZW5ndGgpIHtcbiAgICAgICAgICAvLyBJZiB0aGVyZSBhcmUgYXVkaW8gb3IgdGV4dCBncm91cHMgc2lnbmFsbGVkIGluIHRoZSBtYW5pZmVzdCwgbGV0J3MgbG9vayBmb3IgYSBtYXRjaGluZyBjb2RlYyBzdHJpbmcgZm9yIHRoaXMgdHJhY2tcbiAgICAgICAgICAvLyBJZiB3ZSBkb24ndCBmaW5kIHRoZSB0cmFjayBzaWduYWxsZWQsIGxldHMgdXNlIHRoZSBmaXJzdCBhdWRpbyBncm91cHMgY29kZWMgd2UgaGF2ZVxuICAgICAgICAgIC8vIEFjdGluZyBhcyBhIGJlc3QgZ3Vlc3NcbiAgICAgICAgICB2YXIgZ3JvdXBDb2RlYyA9IE0zVThQYXJzZXIuZmluZEdyb3VwKGdyb3VwcywgbWVkaWEuZ3JvdXBJZCkgfHwgZ3JvdXBzWzBdO1xuICAgICAgICAgIGFzc2lnbkNvZGVjKG1lZGlhLCBncm91cENvZGVjLCAnYXVkaW9Db2RlYycpO1xuICAgICAgICAgIGFzc2lnbkNvZGVjKG1lZGlhLCBncm91cENvZGVjLCAndGV4dENvZGVjJyk7XG4gICAgICAgIH1cblxuICAgICAgICBtZWRpYXMucHVzaChtZWRpYSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG1lZGlhcztcbiAgfTtcblxuICBNM1U4UGFyc2VyLnBhcnNlTGV2ZWxQbGF5bGlzdCA9IGZ1bmN0aW9uIHBhcnNlTGV2ZWxQbGF5bGlzdChzdHJpbmcsIGJhc2V1cmwsIGlkLCB0eXBlLCBsZXZlbFVybElkKSB7XG4gICAgdmFyIGxldmVsID0gbmV3IF9sZXZlbF9kZXRhaWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJMZXZlbERldGFpbHNcIl0oYmFzZXVybCk7XG4gICAgdmFyIGZyYWdtZW50cyA9IGxldmVsLmZyYWdtZW50czsgLy8gVGhlIG1vc3QgcmVjZW50IGluaXQgc2VnbWVudCBzZWVuIChhcHBsaWVzIHRvIGFsbCBzdWJzZXF1ZW50IHNlZ21lbnRzKVxuXG4gICAgdmFyIGN1cnJlbnRJbml0U2VnbWVudCA9IG51bGw7XG4gICAgdmFyIGN1cnJlbnRTTiA9IDA7XG4gICAgdmFyIGN1cnJlbnRQYXJ0ID0gMDtcbiAgICB2YXIgdG90YWxkdXJhdGlvbiA9IDA7XG4gICAgdmFyIGRpc2NvbnRpbnVpdHlDb3VudGVyID0gMDtcbiAgICB2YXIgcHJldkZyYWcgPSBudWxsO1xuICAgIHZhciBmcmFnID0gbmV3IF9mcmFnbWVudF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiRnJhZ21lbnRcIl0odHlwZSwgYmFzZXVybCk7XG4gICAgdmFyIHJlc3VsdDtcbiAgICB2YXIgaTtcbiAgICB2YXIgbGV2ZWxrZXk7XG4gICAgdmFyIGZpcnN0UGR0SW5kZXggPSAtMTtcbiAgICB2YXIgY3JlYXRlTmV4dEZyYWcgPSBmYWxzZTtcbiAgICBMRVZFTF9QTEFZTElTVF9SRUdFWF9GQVNULmxhc3RJbmRleCA9IDA7XG4gICAgbGV2ZWwubTN1OCA9IHN0cmluZztcblxuICAgIHdoaWxlICgocmVzdWx0ID0gTEVWRUxfUExBWUxJU1RfUkVHRVhfRkFTVC5leGVjKHN0cmluZykpICE9PSBudWxsKSB7XG4gICAgICBpZiAoY3JlYXRlTmV4dEZyYWcpIHtcbiAgICAgICAgY3JlYXRlTmV4dEZyYWcgPSBmYWxzZTtcbiAgICAgICAgZnJhZyA9IG5ldyBfZnJhZ21lbnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcIkZyYWdtZW50XCJdKHR5cGUsIGJhc2V1cmwpOyAvLyBzZXR1cCB0aGUgbmV4dCBmcmFnbWVudCBmb3IgcGFydCBsb2FkaW5nXG5cbiAgICAgICAgZnJhZy5zdGFydCA9IHRvdGFsZHVyYXRpb247XG4gICAgICAgIGZyYWcuc24gPSBjdXJyZW50U047XG4gICAgICAgIGZyYWcuY2MgPSBkaXNjb250aW51aXR5Q291bnRlcjtcbiAgICAgICAgZnJhZy5sZXZlbCA9IGlkO1xuXG4gICAgICAgIGlmIChjdXJyZW50SW5pdFNlZ21lbnQpIHtcbiAgICAgICAgICBmcmFnLmluaXRTZWdtZW50ID0gY3VycmVudEluaXRTZWdtZW50O1xuICAgICAgICAgIGZyYWcucmF3UHJvZ3JhbURhdGVUaW1lID0gY3VycmVudEluaXRTZWdtZW50LnJhd1Byb2dyYW1EYXRlVGltZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgZHVyYXRpb24gPSByZXN1bHRbMV07XG5cbiAgICAgIGlmIChkdXJhdGlvbikge1xuICAgICAgICAvLyBJTkZcbiAgICAgICAgZnJhZy5kdXJhdGlvbiA9IHBhcnNlRmxvYXQoZHVyYXRpb24pOyAvLyBhdm9pZCBzbGljZWQgc3RyaW5ncyAgICBodHRwczovL2dpdGh1Yi5jb20vdmlkZW8tZGV2L2hscy5qcy9pc3N1ZXMvOTM5XG5cbiAgICAgICAgdmFyIHRpdGxlID0gKCcgJyArIHJlc3VsdFsyXSkuc2xpY2UoMSk7XG4gICAgICAgIGZyYWcudGl0bGUgPSB0aXRsZSB8fCBudWxsO1xuICAgICAgICBmcmFnLnRhZ0xpc3QucHVzaCh0aXRsZSA/IFsnSU5GJywgZHVyYXRpb24sIHRpdGxlXSA6IFsnSU5GJywgZHVyYXRpb25dKTtcbiAgICAgIH0gZWxzZSBpZiAocmVzdWx0WzNdKSB7XG4gICAgICAgIC8vIHVybFxuICAgICAgICBpZiAoT2JqZWN0KF9ob21lX3J1bm5lcl93b3JrX2hsc19qc19obHNfanNfc3JjX3BvbHlmaWxsc19udW1iZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImlzRmluaXRlTnVtYmVyXCJdKShmcmFnLmR1cmF0aW9uKSkge1xuICAgICAgICAgIGZyYWcuc3RhcnQgPSB0b3RhbGR1cmF0aW9uO1xuXG4gICAgICAgICAgaWYgKGxldmVsa2V5KSB7XG4gICAgICAgICAgICBmcmFnLmxldmVsa2V5ID0gbGV2ZWxrZXk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnJhZy5zbiA9IGN1cnJlbnRTTjtcbiAgICAgICAgICBmcmFnLmxldmVsID0gaWQ7XG4gICAgICAgICAgZnJhZy5jYyA9IGRpc2NvbnRpbnVpdHlDb3VudGVyO1xuICAgICAgICAgIGZyYWcudXJsSWQgPSBsZXZlbFVybElkO1xuICAgICAgICAgIGZyYWdtZW50cy5wdXNoKGZyYWcpOyAvLyBhdm9pZCBzbGljZWQgc3RyaW5ncyAgICBodHRwczovL2dpdGh1Yi5jb20vdmlkZW8tZGV2L2hscy5qcy9pc3N1ZXMvOTM5XG5cbiAgICAgICAgICBmcmFnLnJlbHVybCA9ICgnICcgKyByZXN1bHRbM10pLnNsaWNlKDEpO1xuICAgICAgICAgIGFzc2lnblByb2dyYW1EYXRlVGltZShmcmFnLCBwcmV2RnJhZyk7XG4gICAgICAgICAgcHJldkZyYWcgPSBmcmFnO1xuICAgICAgICAgIHRvdGFsZHVyYXRpb24gKz0gZnJhZy5kdXJhdGlvbjtcbiAgICAgICAgICBjdXJyZW50U04rKztcbiAgICAgICAgICBjdXJyZW50UGFydCA9IDA7XG4gICAgICAgICAgY3JlYXRlTmV4dEZyYWcgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHJlc3VsdFs0XSkge1xuICAgICAgICAvLyBYLUJZVEVSQU5HRVxuICAgICAgICB2YXIgZGF0YSA9ICgnICcgKyByZXN1bHRbNF0pLnNsaWNlKDEpO1xuXG4gICAgICAgIGlmIChwcmV2RnJhZykge1xuICAgICAgICAgIGZyYWcuc2V0Qnl0ZVJhbmdlKGRhdGEsIHByZXZGcmFnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmcmFnLnNldEJ5dGVSYW5nZShkYXRhKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChyZXN1bHRbNV0pIHtcbiAgICAgICAgLy8gUFJPR1JBTS1EQVRFLVRJTUVcbiAgICAgICAgLy8gYXZvaWQgc2xpY2VkIHN0cmluZ3MgICAgaHR0cHM6Ly9naXRodWIuY29tL3ZpZGVvLWRldi9obHMuanMvaXNzdWVzLzkzOVxuICAgICAgICBmcmFnLnJhd1Byb2dyYW1EYXRlVGltZSA9ICgnICcgKyByZXN1bHRbNV0pLnNsaWNlKDEpO1xuICAgICAgICBmcmFnLnRhZ0xpc3QucHVzaChbJ1BST0dSQU0tREFURS1USU1FJywgZnJhZy5yYXdQcm9ncmFtRGF0ZVRpbWVdKTtcblxuICAgICAgICBpZiAoZmlyc3RQZHRJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICBmaXJzdFBkdEluZGV4ID0gZnJhZ21lbnRzLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0WzBdLm1hdGNoKExFVkVMX1BMQVlMSVNUX1JFR0VYX1NMT1cpO1xuXG4gICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fW1wibG9nZ2VyXCJdLndhcm4oJ05vIG1hdGNoZXMgb24gc2xvdyByZWdleCBtYXRjaCBmb3IgbGV2ZWwgcGxheWxpc3QhJyk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgcmVzdWx0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiByZXN1bHRbaV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gYXZvaWQgc2xpY2VkIHN0cmluZ3MgICAgaHR0cHM6Ly9naXRodWIuY29tL3ZpZGVvLWRldi9obHMuanMvaXNzdWVzLzkzOVxuXG5cbiAgICAgICAgdmFyIHRhZyA9ICgnICcgKyByZXN1bHRbaV0pLnNsaWNlKDEpO1xuICAgICAgICB2YXIgdmFsdWUxID0gKCcgJyArIHJlc3VsdFtpICsgMV0pLnNsaWNlKDEpO1xuICAgICAgICB2YXIgdmFsdWUyID0gcmVzdWx0W2kgKyAyXSA/ICgnICcgKyByZXN1bHRbaSArIDJdKS5zbGljZSgxKSA6ICcnO1xuXG4gICAgICAgIHN3aXRjaCAodGFnKSB7XG4gICAgICAgICAgY2FzZSAnUExBWUxJU1QtVFlQRSc6XG4gICAgICAgICAgICBsZXZlbC50eXBlID0gdmFsdWUxLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ01FRElBLVNFUVVFTkNFJzpcbiAgICAgICAgICAgIGN1cnJlbnRTTiA9IGxldmVsLnN0YXJ0U04gPSBwYXJzZUludCh2YWx1ZTEpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdTS0lQJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdmFyIHNraXBBdHRycyA9IG5ldyBfdXRpbHNfYXR0cl9saXN0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXCJBdHRyTGlzdFwiXSh2YWx1ZTEpO1xuICAgICAgICAgICAgICB2YXIgc2tpcHBlZFNlZ21lbnRzID0gc2tpcEF0dHJzLmRlY2ltYWxJbnRlZ2VyKCdTS0lQUEVELVNFR01FTlRTJyk7XG5cbiAgICAgICAgICAgICAgaWYgKE9iamVjdChfaG9tZV9ydW5uZXJfd29ya19obHNfanNfaGxzX2pzX3NyY19wb2x5ZmlsbHNfbnVtYmVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJpc0Zpbml0ZU51bWJlclwiXSkoc2tpcHBlZFNlZ21lbnRzKSkge1xuICAgICAgICAgICAgICAgIGxldmVsLnNraXBwZWRTZWdtZW50cyA9IHNraXBwZWRTZWdtZW50czsgLy8gVGhpcyB3aWxsIHJlc3VsdCBpbiBmcmFnbWVudHNbXSBjb250YWluaW5nIHVuZGVmaW5lZCB2YWx1ZXMsIHdoaWNoIHdlIHdpbGwgZmlsbCBpbiB3aXRoIGBtZXJnZURldGFpbHNgXG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IHNraXBwZWRTZWdtZW50czsgX2ktLTspIHtcbiAgICAgICAgICAgICAgICAgIGZyYWdtZW50cy51bnNoaWZ0KG51bGwpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGN1cnJlbnRTTiArPSBza2lwcGVkU2VnbWVudHM7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB2YXIgcmVjZW50bHlSZW1vdmVkRGF0ZXJhbmdlcyA9IHNraXBBdHRycy5lbnVtZXJhdGVkU3RyaW5nKCdSRUNFTlRMWS1SRU1PVkVELURBVEVSQU5HRVMnKTtcblxuICAgICAgICAgICAgICBpZiAocmVjZW50bHlSZW1vdmVkRGF0ZXJhbmdlcykge1xuICAgICAgICAgICAgICAgIGxldmVsLnJlY2VudGx5UmVtb3ZlZERhdGVyYW5nZXMgPSByZWNlbnRseVJlbW92ZWREYXRlcmFuZ2VzLnNwbGl0KCdcXHQnKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSAnVEFSR0VURFVSQVRJT04nOlxuICAgICAgICAgICAgbGV2ZWwudGFyZ2V0ZHVyYXRpb24gPSBwYXJzZUZsb2F0KHZhbHVlMSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ1ZFUlNJT04nOlxuICAgICAgICAgICAgbGV2ZWwudmVyc2lvbiA9IHBhcnNlSW50KHZhbHVlMSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ0VYVE0zVSc6XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ0VORExJU1QnOlxuICAgICAgICAgICAgbGV2ZWwubGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICcjJzpcbiAgICAgICAgICAgIGlmICh2YWx1ZTEgfHwgdmFsdWUyKSB7XG4gICAgICAgICAgICAgIGZyYWcudGFnTGlzdC5wdXNoKHZhbHVlMiA/IFt2YWx1ZTEsIHZhbHVlMl0gOiBbdmFsdWUxXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnRElTJzpcbiAgICAgICAgICAgIGRpc2NvbnRpbnVpdHlDb3VudGVyKys7XG5cbiAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG5cbiAgICAgICAgICBjYXNlICdHQVAnOlxuICAgICAgICAgICAgZnJhZy50YWdMaXN0LnB1c2goW3RhZ10pO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdCSVRSQVRFJzpcbiAgICAgICAgICAgIGZyYWcudGFnTGlzdC5wdXNoKFt0YWcsIHZhbHVlMV0pO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdESVNDT05USU5VSVRZLVNFUSc6XG4gICAgICAgICAgICBkaXNjb250aW51aXR5Q291bnRlciA9IHBhcnNlSW50KHZhbHVlMSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ0tFWSc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHZhciBfa2V5QXR0cnMkZW51bWVyYXRlZFM7XG5cbiAgICAgICAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzgyMTYjc2VjdGlvbi00LjMuMi40XG4gICAgICAgICAgICAgIHZhciBrZXlBdHRycyA9IG5ldyBfdXRpbHNfYXR0cl9saXN0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXCJBdHRyTGlzdFwiXSh2YWx1ZTEpO1xuICAgICAgICAgICAgICB2YXIgZGVjcnlwdG1ldGhvZCA9IGtleUF0dHJzLmVudW1lcmF0ZWRTdHJpbmcoJ01FVEhPRCcpO1xuICAgICAgICAgICAgICB2YXIgZGVjcnlwdHVyaSA9IGtleUF0dHJzLlVSSTtcbiAgICAgICAgICAgICAgdmFyIGRlY3J5cHRpdiA9IGtleUF0dHJzLmhleGFkZWNpbWFsSW50ZWdlcignSVYnKTtcbiAgICAgICAgICAgICAgdmFyIGRlY3J5cHRrZXlmb3JtYXR2ZXJzaW9ucyA9IGtleUF0dHJzLmVudW1lcmF0ZWRTdHJpbmcoJ0tFWUZPUk1BVFZFUlNJT05TJyk7XG4gICAgICAgICAgICAgIHZhciBkZWNyeXB0a2V5aWQgPSBrZXlBdHRycy5lbnVtZXJhdGVkU3RyaW5nKCdLRVlJRCcpOyAvLyBGcm9tIFJGQzogVGhpcyBhdHRyaWJ1dGUgaXMgT1BUSU9OQUw7IGl0cyBhYnNlbmNlIGluZGljYXRlcyBhbiBpbXBsaWNpdCB2YWx1ZSBvZiBcImlkZW50aXR5XCIuXG5cbiAgICAgICAgICAgICAgdmFyIGRlY3J5cHRrZXlmb3JtYXQgPSAoX2tleUF0dHJzJGVudW1lcmF0ZWRTID0ga2V5QXR0cnMuZW51bWVyYXRlZFN0cmluZygnS0VZRk9STUFUJykpICE9IG51bGwgPyBfa2V5QXR0cnMkZW51bWVyYXRlZFMgOiAnaWRlbnRpdHknO1xuICAgICAgICAgICAgICB2YXIgdW5zdXBwb3J0ZWRLbm93bktleWZvcm1hdHNJbk1hbmlmZXN0ID0gWydjb20uYXBwbGUuc3RyZWFtaW5na2V5ZGVsaXZlcnknLCAnY29tLm1pY3Jvc29mdC5wbGF5cmVhZHknLCAndXJuOnV1aWQ6ZWRlZjhiYTktNzlkNi00YWNlLWEzYzgtMjdkY2Q1MWQyMWVkJywgLy8gd2lkZXZpbmUgKHYyKVxuICAgICAgICAgICAgICAnY29tLndpZGV2aW5lJyAvLyBlYXJsaWVyIHdpZGV2aW5lICh2MSlcbiAgICAgICAgICAgICAgXTtcblxuICAgICAgICAgICAgICBpZiAodW5zdXBwb3J0ZWRLbm93bktleWZvcm1hdHNJbk1hbmlmZXN0LmluZGV4T2YoZGVjcnlwdGtleWZvcm1hdCkgPiAtMSkge1xuICAgICAgICAgICAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcImxvZ2dlclwiXS53YXJuKFwiS2V5Zm9ybWF0IFwiICsgZGVjcnlwdGtleWZvcm1hdCArIFwiIGlzIG5vdCBzdXBwb3J0ZWQgZnJvbSB0aGUgbWFuaWZlc3RcIik7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoZGVjcnlwdGtleWZvcm1hdCAhPT0gJ2lkZW50aXR5Jykge1xuICAgICAgICAgICAgICAgIC8vIFdlIGFyZSBzdXBwb3NlZCB0byBza2lwIGtleXMgd2UgZG9uJ3QgdW5kZXJzdGFuZC5cbiAgICAgICAgICAgICAgICAvLyBBcyB3ZSBjdXJyZW50bHkgb25seSBvZmZpY2lhbGx5IHN1cHBvcnQgaWRlbnRpdHkga2V5c1xuICAgICAgICAgICAgICAgIC8vIGZyb20gdGhlIG1hbmlmZXN0IHdlIHNob3VsZG4ndCBzYXZlIGFueSBvdGhlciBrZXkuXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH0gLy8gVE9ETzogbXVsdGlwbGUga2V5cyBjYW4gYmUgZGVmaW5lZCBvbiBhIGZyYWdtZW50LCBhbmQgd2UgbmVlZCB0byBzdXBwb3J0IHRoaXNcbiAgICAgICAgICAgICAgLy8gZm9yIGNsaWVudHMgdGhhdCBzdXBwb3J0IGJvdGggcGxheXJlYWR5IGFuZCB3aWRldmluZVxuXG5cbiAgICAgICAgICAgICAgaWYgKGRlY3J5cHRtZXRob2QpIHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBuZWVkIHRvIGRldGVybWluZSBpZiB0aGUgbGV2ZWwga2V5IGlzIGFjdHVhbGx5IGEgcmVsYXRpdmUgVVJMXG4gICAgICAgICAgICAgICAgLy8gaWYgaXQgaXNuJ3QsIHRoZW4gd2Ugc2hvdWxkIGluc3RlYWQgY29uc3RydWN0IHRoZSBMZXZlbEtleSB1c2luZyBmcm9tVVJJLlxuICAgICAgICAgICAgICAgIGxldmVsa2V5ID0gX2xldmVsX2tleV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fW1wiTGV2ZWxLZXlcIl0uZnJvbVVSTChiYXNldXJsLCBkZWNyeXB0dXJpKTtcblxuICAgICAgICAgICAgICAgIGlmIChkZWNyeXB0dXJpICYmIFsnQUVTLTEyOCcsICdTQU1QTEUtQUVTJywgJ1NBTVBMRS1BRVMtQ0VOQyddLmluZGV4T2YoZGVjcnlwdG1ldGhvZCkgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgbGV2ZWxrZXkubWV0aG9kID0gZGVjcnlwdG1ldGhvZDtcbiAgICAgICAgICAgICAgICAgIGxldmVsa2V5LmtleUZvcm1hdCA9IGRlY3J5cHRrZXlmb3JtYXQ7XG5cbiAgICAgICAgICAgICAgICAgIGlmIChkZWNyeXB0a2V5aWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV2ZWxrZXkua2V5SUQgPSBkZWNyeXB0a2V5aWQ7XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIGlmIChkZWNyeXB0a2V5Zm9ybWF0dmVyc2lvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV2ZWxrZXkua2V5Rm9ybWF0VmVyc2lvbnMgPSBkZWNyeXB0a2V5Zm9ybWF0dmVyc2lvbnM7XG4gICAgICAgICAgICAgICAgICB9IC8vIEluaXRpYWxpemF0aW9uIFZlY3RvciAoSVYpXG5cblxuICAgICAgICAgICAgICAgICAgbGV2ZWxrZXkuaXYgPSBkZWNyeXB0aXY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlICdTVEFSVCc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHZhciBzdGFydEF0dHJzID0gbmV3IF91dGlsc19hdHRyX2xpc3RfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcIkF0dHJMaXN0XCJdKHZhbHVlMSk7XG4gICAgICAgICAgICAgIHZhciBzdGFydFRpbWVPZmZzZXQgPSBzdGFydEF0dHJzLmRlY2ltYWxGbG9hdGluZ1BvaW50KCdUSU1FLU9GRlNFVCcpOyAvLyBUSU1FLU9GRlNFVCBjYW4gYmUgMFxuXG4gICAgICAgICAgICAgIGlmIChPYmplY3QoX2hvbWVfcnVubmVyX3dvcmtfaGxzX2pzX2hsc19qc19zcmNfcG9seWZpbGxzX251bWJlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiaXNGaW5pdGVOdW1iZXJcIl0pKHN0YXJ0VGltZU9mZnNldCkpIHtcbiAgICAgICAgICAgICAgICBsZXZlbC5zdGFydFRpbWVPZmZzZXQgPSBzdGFydFRpbWVPZmZzZXQ7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgJ01BUCc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHZhciBtYXBBdHRycyA9IG5ldyBfdXRpbHNfYXR0cl9saXN0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXCJBdHRyTGlzdFwiXSh2YWx1ZTEpO1xuICAgICAgICAgICAgICBmcmFnLnJlbHVybCA9IG1hcEF0dHJzLlVSSTtcblxuICAgICAgICAgICAgICBpZiAobWFwQXR0cnMuQllURVJBTkdFKSB7XG4gICAgICAgICAgICAgICAgZnJhZy5zZXRCeXRlUmFuZ2UobWFwQXR0cnMuQllURVJBTkdFKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGZyYWcubGV2ZWwgPSBpZDtcbiAgICAgICAgICAgICAgZnJhZy5zbiA9ICdpbml0U2VnbWVudCc7XG5cbiAgICAgICAgICAgICAgaWYgKGxldmVsa2V5KSB7XG4gICAgICAgICAgICAgICAgZnJhZy5sZXZlbGtleSA9IGxldmVsa2V5O1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgZnJhZy5pbml0U2VnbWVudCA9IG51bGw7XG4gICAgICAgICAgICAgIGN1cnJlbnRJbml0U2VnbWVudCA9IGZyYWc7XG4gICAgICAgICAgICAgIGNyZWF0ZU5leHRGcmFnID0gdHJ1ZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlICdTRVJWRVItQ09OVFJPTCc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHZhciBzZXJ2ZXJDb250cm9sQXR0cnMgPSBuZXcgX3V0aWxzX2F0dHJfbGlzdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1wiQXR0ckxpc3RcIl0odmFsdWUxKTtcbiAgICAgICAgICAgICAgbGV2ZWwuY2FuQmxvY2tSZWxvYWQgPSBzZXJ2ZXJDb250cm9sQXR0cnMuYm9vbCgnQ0FOLUJMT0NLLVJFTE9BRCcpO1xuICAgICAgICAgICAgICBsZXZlbC5jYW5Ta2lwVW50aWwgPSBzZXJ2ZXJDb250cm9sQXR0cnMub3B0aW9uYWxGbG9hdCgnQ0FOLVNLSVAtVU5USUwnLCAwKTtcbiAgICAgICAgICAgICAgbGV2ZWwuY2FuU2tpcERhdGVSYW5nZXMgPSBsZXZlbC5jYW5Ta2lwVW50aWwgPiAwICYmIHNlcnZlckNvbnRyb2xBdHRycy5ib29sKCdDQU4tU0tJUC1EQVRFUkFOR0VTJyk7XG4gICAgICAgICAgICAgIGxldmVsLnBhcnRIb2xkQmFjayA9IHNlcnZlckNvbnRyb2xBdHRycy5vcHRpb25hbEZsb2F0KCdQQVJULUhPTEQtQkFDSycsIDApO1xuICAgICAgICAgICAgICBsZXZlbC5ob2xkQmFjayA9IHNlcnZlckNvbnRyb2xBdHRycy5vcHRpb25hbEZsb2F0KCdIT0xELUJBQ0snLCAwKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlICdQQVJULUlORic6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHZhciBwYXJ0SW5mQXR0cnMgPSBuZXcgX3V0aWxzX2F0dHJfbGlzdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1wiQXR0ckxpc3RcIl0odmFsdWUxKTtcbiAgICAgICAgICAgICAgbGV2ZWwucGFydFRhcmdldCA9IHBhcnRJbmZBdHRycy5kZWNpbWFsRmxvYXRpbmdQb2ludCgnUEFSVC1UQVJHRVQnKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlICdQQVJUJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdmFyIHBhcnRMaXN0ID0gbGV2ZWwucGFydExpc3Q7XG5cbiAgICAgICAgICAgICAgaWYgKCFwYXJ0TGlzdCkge1xuICAgICAgICAgICAgICAgIHBhcnRMaXN0ID0gbGV2ZWwucGFydExpc3QgPSBbXTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHZhciBwcmV2aW91c0ZyYWdtZW50UGFydCA9IGN1cnJlbnRQYXJ0ID4gMCA/IHBhcnRMaXN0W3BhcnRMaXN0Lmxlbmd0aCAtIDFdIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICB2YXIgaW5kZXggPSBjdXJyZW50UGFydCsrO1xuICAgICAgICAgICAgICB2YXIgcGFydCA9IG5ldyBfZnJhZ21lbnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcIlBhcnRcIl0obmV3IF91dGlsc19hdHRyX2xpc3RfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcIkF0dHJMaXN0XCJdKHZhbHVlMSksIGZyYWcsIGJhc2V1cmwsIGluZGV4LCBwcmV2aW91c0ZyYWdtZW50UGFydCk7XG4gICAgICAgICAgICAgIHBhcnRMaXN0LnB1c2gocGFydCk7XG4gICAgICAgICAgICAgIGZyYWcuZHVyYXRpb24gKz0gcGFydC5kdXJhdGlvbjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlICdQUkVMT0FELUhJTlQnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB2YXIgcHJlbG9hZEhpbnRBdHRycyA9IG5ldyBfdXRpbHNfYXR0cl9saXN0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXCJBdHRyTGlzdFwiXSh2YWx1ZTEpO1xuICAgICAgICAgICAgICBsZXZlbC5wcmVsb2FkSGludCA9IHByZWxvYWRIaW50QXR0cnM7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSAnUkVORElUSU9OLVJFUE9SVCc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHZhciByZW5kaXRpb25SZXBvcnRBdHRycyA9IG5ldyBfdXRpbHNfYXR0cl9saXN0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXCJBdHRyTGlzdFwiXSh2YWx1ZTEpO1xuICAgICAgICAgICAgICBsZXZlbC5yZW5kaXRpb25SZXBvcnRzID0gbGV2ZWwucmVuZGl0aW9uUmVwb3J0cyB8fCBbXTtcbiAgICAgICAgICAgICAgbGV2ZWwucmVuZGl0aW9uUmVwb3J0cy5wdXNoKHJlbmRpdGlvblJlcG9ydEF0dHJzKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fW1wibG9nZ2VyXCJdLndhcm4oXCJsaW5lIHBhcnNlZCBidXQgbm90IGhhbmRsZWQ6IFwiICsgcmVzdWx0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHByZXZGcmFnICYmICFwcmV2RnJhZy5yZWx1cmwpIHtcbiAgICAgIGZyYWdtZW50cy5wb3AoKTtcbiAgICAgIHRvdGFsZHVyYXRpb24gLT0gcHJldkZyYWcuZHVyYXRpb247XG5cbiAgICAgIGlmIChsZXZlbC5wYXJ0TGlzdCkge1xuICAgICAgICBsZXZlbC5mcmFnbWVudEhpbnQgPSBwcmV2RnJhZztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGxldmVsLnBhcnRMaXN0KSB7XG4gICAgICBhc3NpZ25Qcm9ncmFtRGF0ZVRpbWUoZnJhZywgcHJldkZyYWcpO1xuICAgICAgZnJhZy5jYyA9IGRpc2NvbnRpbnVpdHlDb3VudGVyO1xuICAgICAgbGV2ZWwuZnJhZ21lbnRIaW50ID0gZnJhZztcbiAgICB9XG5cbiAgICB2YXIgZnJhZ21lbnRMZW5ndGggPSBmcmFnbWVudHMubGVuZ3RoO1xuICAgIHZhciBmaXJzdEZyYWdtZW50ID0gZnJhZ21lbnRzWzBdO1xuICAgIHZhciBsYXN0RnJhZ21lbnQgPSBmcmFnbWVudHNbZnJhZ21lbnRMZW5ndGggLSAxXTtcbiAgICB0b3RhbGR1cmF0aW9uICs9IGxldmVsLnNraXBwZWRTZWdtZW50cyAqIGxldmVsLnRhcmdldGR1cmF0aW9uO1xuXG4gICAgaWYgKHRvdGFsZHVyYXRpb24gPiAwICYmIGZyYWdtZW50TGVuZ3RoICYmIGxhc3RGcmFnbWVudCkge1xuICAgICAgbGV2ZWwuYXZlcmFnZXRhcmdldGR1cmF0aW9uID0gdG90YWxkdXJhdGlvbiAvIGZyYWdtZW50TGVuZ3RoO1xuICAgICAgdmFyIGxhc3RTbiA9IGxhc3RGcmFnbWVudC5zbjtcbiAgICAgIGxldmVsLmVuZFNOID0gbGFzdFNuICE9PSAnaW5pdFNlZ21lbnQnID8gbGFzdFNuIDogMDtcblxuICAgICAgaWYgKGZpcnN0RnJhZ21lbnQpIHtcbiAgICAgICAgbGV2ZWwuc3RhcnRDQyA9IGZpcnN0RnJhZ21lbnQuY2M7XG5cbiAgICAgICAgaWYgKCFmaXJzdEZyYWdtZW50LmluaXRTZWdtZW50KSB7XG4gICAgICAgICAgLy8gdGhpcyBpcyBhIGJpdCBsdXJreSBidXQgSExTIHJlYWxseSBoYXMgbm8gb3RoZXIgd2F5IHRvIHRlbGwgdXNcbiAgICAgICAgICAvLyBpZiB0aGUgZnJhZ21lbnRzIGFyZSBUUyBvciBNUDQsIGV4Y2VwdCBpZiB3ZSBkb3dubG9hZCB0aGVtIDovXG4gICAgICAgICAgLy8gYnV0IHRoaXMgaXMgdG8gYmUgYWJsZSB0byBoYW5kbGUgU0lEWC5cbiAgICAgICAgICBpZiAobGV2ZWwuZnJhZ21lbnRzLmV2ZXJ5KGZ1bmN0aW9uIChmcmFnKSB7XG4gICAgICAgICAgICByZXR1cm4gZnJhZy5yZWx1cmwgJiYgaXNNUDRVcmwoZnJhZy5yZWx1cmwpO1xuICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXCJsb2dnZXJcIl0ud2FybignTVA0IGZyYWdtZW50cyBmb3VuZCBidXQgbm8gaW5pdCBzZWdtZW50IChwcm9iYWJseSBubyBNQVAsIGluY29tcGxldGUgTTNVOCksIHRyeWluZyB0byBmZXRjaCBTSURYJyk7XG4gICAgICAgICAgICBmcmFnID0gbmV3IF9mcmFnbWVudF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiRnJhZ21lbnRcIl0odHlwZSwgYmFzZXVybCk7XG4gICAgICAgICAgICBmcmFnLnJlbHVybCA9IGxhc3RGcmFnbWVudC5yZWx1cmw7XG4gICAgICAgICAgICBmcmFnLmxldmVsID0gaWQ7XG4gICAgICAgICAgICBmcmFnLnNuID0gJ2luaXRTZWdtZW50JztcbiAgICAgICAgICAgIGZpcnN0RnJhZ21lbnQuaW5pdFNlZ21lbnQgPSBmcmFnO1xuICAgICAgICAgICAgbGV2ZWwubmVlZFNpZHhSYW5nZXMgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsZXZlbC5lbmRTTiA9IDA7XG4gICAgICBsZXZlbC5zdGFydENDID0gMDtcbiAgICB9XG5cbiAgICBpZiAobGV2ZWwuZnJhZ21lbnRIaW50KSB7XG4gICAgICB0b3RhbGR1cmF0aW9uICs9IGxldmVsLmZyYWdtZW50SGludC5kdXJhdGlvbjtcbiAgICB9XG5cbiAgICBsZXZlbC50b3RhbGR1cmF0aW9uID0gdG90YWxkdXJhdGlvbjtcbiAgICBsZXZlbC5lbmRDQyA9IGRpc2NvbnRpbnVpdHlDb3VudGVyO1xuICAgIC8qKlxuICAgICAqIEJhY2tmaWxsIGFueSBtaXNzaW5nIFBEVCB2YWx1ZXNcbiAgICAgKiBcIklmIHRoZSBmaXJzdCBFWFQtWC1QUk9HUkFNLURBVEUtVElNRSB0YWcgaW4gYSBQbGF5bGlzdCBhcHBlYXJzIGFmdGVyXG4gICAgICogb25lIG9yIG1vcmUgTWVkaWEgU2VnbWVudCBVUklzLCB0aGUgY2xpZW50IFNIT1VMRCBleHRyYXBvbGF0ZVxuICAgICAqIGJhY2t3YXJkIGZyb20gdGhhdCB0YWcgKHVzaW5nIEVYVElORiBkdXJhdGlvbnMgYW5kL29yIG1lZGlhXG4gICAgICogdGltZXN0YW1wcykgdG8gYXNzb2NpYXRlIGRhdGVzIHdpdGggdGhvc2Ugc2VnbWVudHMuXCJcbiAgICAgKiBXZSBoYXZlIGFscmVhZHkgZXh0cmFwb2xhdGVkIGZvcndhcmQsIGJ1dCBhbGwgZnJhZ21lbnRzIHVwIHRvIHRoZSBmaXJzdCBpbnN0YW5jZSBvZiBQRFQgZG8gbm90IGhhdmUgdGhlaXIgUERUc1xuICAgICAqIGNvbXB1dGVkLlxuICAgICAqL1xuXG4gICAgaWYgKGZpcnN0UGR0SW5kZXggPiAwKSB7XG4gICAgICBiYWNrZmlsbFByb2dyYW1EYXRlVGltZXMoZnJhZ21lbnRzLCBmaXJzdFBkdEluZGV4KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbGV2ZWw7XG4gIH07XG5cbiAgcmV0dXJuIE0zVThQYXJzZXI7XG59KCk7XG5cblxuXG5mdW5jdGlvbiBzZXRDb2RlY3MoY29kZWNzLCBsZXZlbCkge1xuICBbJ3ZpZGVvJywgJ2F1ZGlvJywgJ3RleHQnXS5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgdmFyIGZpbHRlcmVkID0gY29kZWNzLmZpbHRlcihmdW5jdGlvbiAoY29kZWMpIHtcbiAgICAgIHJldHVybiBPYmplY3QoX3V0aWxzX2NvZGVjc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fW1wiaXNDb2RlY1R5cGVcIl0pKGNvZGVjLCB0eXBlKTtcbiAgICB9KTtcblxuICAgIGlmIChmaWx0ZXJlZC5sZW5ndGgpIHtcbiAgICAgIHZhciBwcmVmZXJyZWQgPSBmaWx0ZXJlZC5maWx0ZXIoZnVuY3Rpb24gKGNvZGVjKSB7XG4gICAgICAgIHJldHVybiBjb2RlYy5sYXN0SW5kZXhPZignYXZjMScsIDApID09PSAwIHx8IGNvZGVjLmxhc3RJbmRleE9mKCdtcDRhJywgMCkgPT09IDA7XG4gICAgICB9KTtcbiAgICAgIGxldmVsW3R5cGUgKyBcIkNvZGVjXCJdID0gcHJlZmVycmVkLmxlbmd0aCA+IDAgPyBwcmVmZXJyZWRbMF0gOiBmaWx0ZXJlZFswXTsgLy8gcmVtb3ZlIGZyb20gbGlzdFxuXG4gICAgICBjb2RlY3MgPSBjb2RlY3MuZmlsdGVyKGZ1bmN0aW9uIChjb2RlYykge1xuICAgICAgICByZXR1cm4gZmlsdGVyZWQuaW5kZXhPZihjb2RlYykgPT09IC0xO1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbiAgbGV2ZWwudW5rbm93bkNvZGVjcyA9IGNvZGVjcztcbn1cblxuZnVuY3Rpb24gYXNzaWduQ29kZWMobWVkaWEsIGdyb3VwSXRlbSwgY29kZWNQcm9wZXJ0eSkge1xuICB2YXIgY29kZWNWYWx1ZSA9IGdyb3VwSXRlbVtjb2RlY1Byb3BlcnR5XTtcblxuICBpZiAoY29kZWNWYWx1ZSkge1xuICAgIG1lZGlhW2NvZGVjUHJvcGVydHldID0gY29kZWNWYWx1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBiYWNrZmlsbFByb2dyYW1EYXRlVGltZXMoZnJhZ21lbnRzLCBmaXJzdFBkdEluZGV4KSB7XG4gIHZhciBmcmFnUHJldiA9IGZyYWdtZW50c1tmaXJzdFBkdEluZGV4XTtcblxuICBmb3IgKHZhciBpID0gZmlyc3RQZHRJbmRleDsgaS0tOykge1xuICAgIHZhciBmcmFnID0gZnJhZ21lbnRzW2ldOyAvLyBFeGl0IG9uIGRlbHRhLXBsYXlsaXN0IHNraXBwZWQgc2VnbWVudHNcblxuICAgIGlmICghZnJhZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZyYWcucHJvZ3JhbURhdGVUaW1lID0gZnJhZ1ByZXYucHJvZ3JhbURhdGVUaW1lIC0gZnJhZy5kdXJhdGlvbiAqIDEwMDA7XG4gICAgZnJhZ1ByZXYgPSBmcmFnO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFzc2lnblByb2dyYW1EYXRlVGltZShmcmFnLCBwcmV2RnJhZykge1xuICBpZiAoZnJhZy5yYXdQcm9ncmFtRGF0ZVRpbWUpIHtcbiAgICBmcmFnLnByb2dyYW1EYXRlVGltZSA9IERhdGUucGFyc2UoZnJhZy5yYXdQcm9ncmFtRGF0ZVRpbWUpO1xuICB9IGVsc2UgaWYgKHByZXZGcmFnICE9PSBudWxsICYmIHByZXZGcmFnICE9PSB2b2lkIDAgJiYgcHJldkZyYWcucHJvZ3JhbURhdGVUaW1lKSB7XG4gICAgZnJhZy5wcm9ncmFtRGF0ZVRpbWUgPSBwcmV2RnJhZy5lbmRQcm9ncmFtRGF0ZVRpbWU7XG4gIH1cblxuICBpZiAoIU9iamVjdChfaG9tZV9ydW5uZXJfd29ya19obHNfanNfaGxzX2pzX3NyY19wb2x5ZmlsbHNfbnVtYmVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJpc0Zpbml0ZU51bWJlclwiXSkoZnJhZy5wcm9ncmFtRGF0ZVRpbWUpKSB7XG4gICAgZnJhZy5wcm9ncmFtRGF0ZVRpbWUgPSBudWxsO1xuICAgIGZyYWcucmF3UHJvZ3JhbURhdGVUaW1lID0gbnVsbDtcbiAgfVxufVxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9sb2FkZXIvcGxheWxpc3QtbG9hZGVyLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvbG9hZGVyL3BsYXlsaXN0LWxvYWRlci50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2hvbWVfcnVubmVyX3dvcmtfaGxzX2pzX2hsc19qc19zcmNfcG9seWZpbGxzX251bWJlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zcmMvcG9seWZpbGxzL251bWJlciAqLyBcIi4vc3JjL3BvbHlmaWxscy9udW1iZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZXZlbnRzICovIFwiLi9zcmMvZXZlbnRzLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2Vycm9ycyAqLyBcIi4vc3JjL2Vycm9ycy50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9sb2dnZXIgKi8gXCIuL3NyYy91dGlscy9sb2dnZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX21wNF90b29sc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvbXA0LXRvb2xzICovIFwiLi9zcmMvdXRpbHMvbXA0LXRvb2xzLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9tM3U4X3BhcnNlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9tM3U4LXBhcnNlciAqLyBcIi4vc3JjL2xvYWRlci9tM3U4LXBhcnNlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdHlwZXNfbG9hZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi90eXBlcy9sb2FkZXIgKi8gXCIuL3NyYy90eXBlcy9sb2FkZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2F0dHJfbGlzdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvYXR0ci1saXN0ICovIFwiLi9zcmMvdXRpbHMvYXR0ci1saXN0LnRzXCIpO1xuXG5cblxuLyoqXG4gKiBQbGF5bGlzdExvYWRlciAtIGRlbGVnYXRlIGZvciBtZWRpYSBtYW5pZmVzdC9wbGF5bGlzdCBsb2FkaW5nIHRhc2tzLiBUYWtlcyBjYXJlIG9mIHBhcnNpbmcgbWVkaWEgdG8gaW50ZXJuYWwgZGF0YS1tb2RlbHMuXG4gKlxuICogT25jZSBsb2FkZWQsIGRpc3BhdGNoZXMgZXZlbnRzIHdpdGggcGFyc2VkIGRhdGEtbW9kZWxzIG9mIG1hbmlmZXN0L2xldmVscy9hdWRpby9zdWJ0aXRsZSB0cmFja3MuXG4gKlxuICogVXNlcyBsb2FkZXIocykgc2V0IGluIGNvbmZpZyB0byBkbyBhY3R1YWwgaW50ZXJuYWwgbG9hZGluZyBvZiByZXNvdXJjZSB0YXNrcy5cbiAqXG4gKiBAbW9kdWxlXG4gKlxuICovXG5cblxuXG5cblxuXG5cblxuZnVuY3Rpb24gbWFwQ29udGV4dFRvTGV2ZWxUeXBlKGNvbnRleHQpIHtcbiAgdmFyIHR5cGUgPSBjb250ZXh0LnR5cGU7XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBfdHlwZXNfbG9hZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXCJQbGF5bGlzdENvbnRleHRUeXBlXCJdLkFVRElPX1RSQUNLOlxuICAgICAgcmV0dXJuIF90eXBlc19sb2FkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcIlBsYXlsaXN0TGV2ZWxUeXBlXCJdLkFVRElPO1xuXG4gICAgY2FzZSBfdHlwZXNfbG9hZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXCJQbGF5bGlzdENvbnRleHRUeXBlXCJdLlNVQlRJVExFX1RSQUNLOlxuICAgICAgcmV0dXJuIF90eXBlc19sb2FkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcIlBsYXlsaXN0TGV2ZWxUeXBlXCJdLlNVQlRJVExFO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBfdHlwZXNfbG9hZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXCJQbGF5bGlzdExldmVsVHlwZVwiXS5NQUlOO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFJlc3BvbnNlVXJsKHJlc3BvbnNlLCBjb250ZXh0KSB7XG4gIHZhciB1cmwgPSByZXNwb25zZS51cmw7IC8vIHJlc3BvbnNlVVJMIG5vdCBzdXBwb3J0ZWQgb24gc29tZSBicm93c2VycyAoaXQgaXMgdXNlZCB0byBkZXRlY3QgVVJMIHJlZGlyZWN0aW9uKVxuICAvLyBkYXRhLXVyaSBtb2RlIGFsc28gbm90IHN1cHBvcnRlZCAoYnV0IG5vIG5lZWQgdG8gZGV0ZWN0IHJlZGlyZWN0aW9uKVxuXG4gIGlmICh1cmwgPT09IHVuZGVmaW5lZCB8fCB1cmwuaW5kZXhPZignZGF0YTonKSA9PT0gMCkge1xuICAgIC8vIGZhbGxiYWNrIHRvIGluaXRpYWwgVVJMXG4gICAgdXJsID0gY29udGV4dC51cmw7XG4gIH1cblxuICByZXR1cm4gdXJsO1xufVxuXG52YXIgUGxheWxpc3RMb2FkZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBQbGF5bGlzdExvYWRlcihobHMpIHtcbiAgICB0aGlzLmhscyA9IHZvaWQgMDtcbiAgICB0aGlzLmxvYWRlcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuaGxzID0gaGxzO1xuICAgIHRoaXMucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBQbGF5bGlzdExvYWRlci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLnJlZ2lzdGVyTGlzdGVuZXJzID0gZnVuY3Rpb24gcmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgdmFyIGhscyA9IHRoaXMuaGxzO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFdmVudHNcIl0uTUFOSUZFU1RfTE9BRElORywgdGhpcy5vbk1hbmlmZXN0TG9hZGluZywgdGhpcyk7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkV2ZW50c1wiXS5MRVZFTF9MT0FESU5HLCB0aGlzLm9uTGV2ZWxMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXZlbnRzXCJdLkFVRElPX1RSQUNLX0xPQURJTkcsIHRoaXMub25BdWRpb1RyYWNrTG9hZGluZywgdGhpcyk7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkV2ZW50c1wiXS5TVUJUSVRMRV9UUkFDS19MT0FESU5HLCB0aGlzLm9uU3VidGl0bGVUcmFja0xvYWRpbmcsIHRoaXMpO1xuICB9O1xuXG4gIF9wcm90by51bnJlZ2lzdGVyTGlzdGVuZXJzID0gZnVuY3Rpb24gdW5yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICB2YXIgaGxzID0gdGhpcy5obHM7XG4gICAgaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFdmVudHNcIl0uTUFOSUZFU1RfTE9BRElORywgdGhpcy5vbk1hbmlmZXN0TG9hZGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFdmVudHNcIl0uTEVWRUxfTE9BRElORywgdGhpcy5vbkxldmVsTG9hZGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFdmVudHNcIl0uQVVESU9fVFJBQ0tfTE9BRElORywgdGhpcy5vbkF1ZGlvVHJhY2tMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkV2ZW50c1wiXS5TVUJUSVRMRV9UUkFDS19MT0FESU5HLCB0aGlzLm9uU3VidGl0bGVUcmFja0xvYWRpbmcsIHRoaXMpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGRlZmF1bHRzIG9yIGNvbmZpZ3VyZWQgbG9hZGVyLXR5cGUgb3ZlcmxvYWRzIChwTG9hZGVyIGFuZCBsb2FkZXIgY29uZmlnIHBhcmFtcylcbiAgICovXG4gIDtcblxuICBfcHJvdG8uY3JlYXRlSW50ZXJuYWxMb2FkZXIgPSBmdW5jdGlvbiBjcmVhdGVJbnRlcm5hbExvYWRlcihjb250ZXh0KSB7XG4gICAgdmFyIGNvbmZpZyA9IHRoaXMuaGxzLmNvbmZpZztcbiAgICB2YXIgUExvYWRlciA9IGNvbmZpZy5wTG9hZGVyO1xuICAgIHZhciBMb2FkZXIgPSBjb25maWcubG9hZGVyO1xuICAgIHZhciBJbnRlcm5hbExvYWRlciA9IFBMb2FkZXIgfHwgTG9hZGVyO1xuICAgIHZhciBsb2FkZXIgPSBuZXcgSW50ZXJuYWxMb2FkZXIoY29uZmlnKTtcbiAgICBjb250ZXh0LmxvYWRlciA9IGxvYWRlcjtcbiAgICB0aGlzLmxvYWRlcnNbY29udGV4dC50eXBlXSA9IGxvYWRlcjtcbiAgICByZXR1cm4gbG9hZGVyO1xuICB9O1xuXG4gIF9wcm90by5nZXRJbnRlcm5hbExvYWRlciA9IGZ1bmN0aW9uIGdldEludGVybmFsTG9hZGVyKGNvbnRleHQpIHtcbiAgICByZXR1cm4gdGhpcy5sb2FkZXJzW2NvbnRleHQudHlwZV07XG4gIH07XG5cbiAgX3Byb3RvLnJlc2V0SW50ZXJuYWxMb2FkZXIgPSBmdW5jdGlvbiByZXNldEludGVybmFsTG9hZGVyKGNvbnRleHRUeXBlKSB7XG4gICAgaWYgKHRoaXMubG9hZGVyc1tjb250ZXh0VHlwZV0pIHtcbiAgICAgIGRlbGV0ZSB0aGlzLmxvYWRlcnNbY29udGV4dFR5cGVdO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQ2FsbCBgZGVzdHJveWAgb24gYWxsIGludGVybmFsIGxvYWRlciBpbnN0YW5jZXMgbWFwcGVkIChvbmUgcGVyIGNvbnRleHQgdHlwZSlcbiAgICovXG4gIDtcblxuICBfcHJvdG8uZGVzdHJveUludGVybmFsTG9hZGVycyA9IGZ1bmN0aW9uIGRlc3Ryb3lJbnRlcm5hbExvYWRlcnMoKSB7XG4gICAgZm9yICh2YXIgY29udGV4dFR5cGUgaW4gdGhpcy5sb2FkZXJzKSB7XG4gICAgICB2YXIgbG9hZGVyID0gdGhpcy5sb2FkZXJzW2NvbnRleHRUeXBlXTtcblxuICAgICAgaWYgKGxvYWRlcikge1xuICAgICAgICBsb2FkZXIuZGVzdHJveSgpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnJlc2V0SW50ZXJuYWxMb2FkZXIoY29udGV4dFR5cGUpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgdGhpcy51bnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gICAgdGhpcy5kZXN0cm95SW50ZXJuYWxMb2FkZXJzKCk7XG4gIH07XG5cbiAgX3Byb3RvLm9uTWFuaWZlc3RMb2FkaW5nID0gZnVuY3Rpb24gb25NYW5pZmVzdExvYWRpbmcoZXZlbnQsIGRhdGEpIHtcbiAgICB2YXIgdXJsID0gZGF0YS51cmw7XG4gICAgdGhpcy5sb2FkKHtcbiAgICAgIGlkOiBudWxsLFxuICAgICAgZ3JvdXBJZDogbnVsbCxcbiAgICAgIGxldmVsOiAwLFxuICAgICAgcmVzcG9uc2VUeXBlOiAndGV4dCcsXG4gICAgICB0eXBlOiBfdHlwZXNfbG9hZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXCJQbGF5bGlzdENvbnRleHRUeXBlXCJdLk1BTklGRVNULFxuICAgICAgdXJsOiB1cmwsXG4gICAgICBkZWxpdmVyeURpcmVjdGl2ZXM6IG51bGxcbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG8ub25MZXZlbExvYWRpbmcgPSBmdW5jdGlvbiBvbkxldmVsTG9hZGluZyhldmVudCwgZGF0YSkge1xuICAgIHZhciBpZCA9IGRhdGEuaWQsXG4gICAgICAgIGxldmVsID0gZGF0YS5sZXZlbCxcbiAgICAgICAgdXJsID0gZGF0YS51cmwsXG4gICAgICAgIGRlbGl2ZXJ5RGlyZWN0aXZlcyA9IGRhdGEuZGVsaXZlcnlEaXJlY3RpdmVzO1xuICAgIHRoaXMubG9hZCh7XG4gICAgICBpZDogaWQsXG4gICAgICBncm91cElkOiBudWxsLFxuICAgICAgbGV2ZWw6IGxldmVsLFxuICAgICAgcmVzcG9uc2VUeXBlOiAndGV4dCcsXG4gICAgICB0eXBlOiBfdHlwZXNfbG9hZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXCJQbGF5bGlzdENvbnRleHRUeXBlXCJdLkxFVkVMLFxuICAgICAgdXJsOiB1cmwsXG4gICAgICBkZWxpdmVyeURpcmVjdGl2ZXM6IGRlbGl2ZXJ5RGlyZWN0aXZlc1xuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90by5vbkF1ZGlvVHJhY2tMb2FkaW5nID0gZnVuY3Rpb24gb25BdWRpb1RyYWNrTG9hZGluZyhldmVudCwgZGF0YSkge1xuICAgIHZhciBpZCA9IGRhdGEuaWQsXG4gICAgICAgIGdyb3VwSWQgPSBkYXRhLmdyb3VwSWQsXG4gICAgICAgIHVybCA9IGRhdGEudXJsLFxuICAgICAgICBkZWxpdmVyeURpcmVjdGl2ZXMgPSBkYXRhLmRlbGl2ZXJ5RGlyZWN0aXZlcztcbiAgICB0aGlzLmxvYWQoe1xuICAgICAgaWQ6IGlkLFxuICAgICAgZ3JvdXBJZDogZ3JvdXBJZCxcbiAgICAgIGxldmVsOiBudWxsLFxuICAgICAgcmVzcG9uc2VUeXBlOiAndGV4dCcsXG4gICAgICB0eXBlOiBfdHlwZXNfbG9hZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXCJQbGF5bGlzdENvbnRleHRUeXBlXCJdLkFVRElPX1RSQUNLLFxuICAgICAgdXJsOiB1cmwsXG4gICAgICBkZWxpdmVyeURpcmVjdGl2ZXM6IGRlbGl2ZXJ5RGlyZWN0aXZlc1xuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90by5vblN1YnRpdGxlVHJhY2tMb2FkaW5nID0gZnVuY3Rpb24gb25TdWJ0aXRsZVRyYWNrTG9hZGluZyhldmVudCwgZGF0YSkge1xuICAgIHZhciBpZCA9IGRhdGEuaWQsXG4gICAgICAgIGdyb3VwSWQgPSBkYXRhLmdyb3VwSWQsXG4gICAgICAgIHVybCA9IGRhdGEudXJsLFxuICAgICAgICBkZWxpdmVyeURpcmVjdGl2ZXMgPSBkYXRhLmRlbGl2ZXJ5RGlyZWN0aXZlcztcbiAgICB0aGlzLmxvYWQoe1xuICAgICAgaWQ6IGlkLFxuICAgICAgZ3JvdXBJZDogZ3JvdXBJZCxcbiAgICAgIGxldmVsOiBudWxsLFxuICAgICAgcmVzcG9uc2VUeXBlOiAndGV4dCcsXG4gICAgICB0eXBlOiBfdHlwZXNfbG9hZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXCJQbGF5bGlzdENvbnRleHRUeXBlXCJdLlNVQlRJVExFX1RSQUNLLFxuICAgICAgdXJsOiB1cmwsXG4gICAgICBkZWxpdmVyeURpcmVjdGl2ZXM6IGRlbGl2ZXJ5RGlyZWN0aXZlc1xuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90by5sb2FkID0gZnVuY3Rpb24gbG9hZChjb250ZXh0KSB7XG4gICAgdmFyIF9jb250ZXh0JGRlbGl2ZXJ5RGlyZTtcblxuICAgIHZhciBjb25maWcgPSB0aGlzLmhscy5jb25maWc7IC8vIGxvZ2dlci5kZWJ1ZyhgW3BsYXlsaXN0LWxvYWRlcl06IExvYWRpbmcgcGxheWxpc3Qgb2YgdHlwZSAke2NvbnRleHQudHlwZX0sIGxldmVsOiAke2NvbnRleHQubGV2ZWx9LCBpZDogJHtjb250ZXh0LmlkfWApO1xuICAgIC8vIENoZWNrIGlmIGEgbG9hZGVyIGZvciB0aGlzIGNvbnRleHQgYWxyZWFkeSBleGlzdHNcblxuICAgIHZhciBsb2FkZXIgPSB0aGlzLmdldEludGVybmFsTG9hZGVyKGNvbnRleHQpO1xuXG4gICAgaWYgKGxvYWRlcikge1xuICAgICAgdmFyIGxvYWRlckNvbnRleHQgPSBsb2FkZXIuY29udGV4dDtcblxuICAgICAgaWYgKGxvYWRlckNvbnRleHQgJiYgbG9hZGVyQ29udGV4dC51cmwgPT09IGNvbnRleHQudXJsKSB7XG4gICAgICAgIC8vIHNhbWUgVVJMIGNhbid0IG92ZXJsYXBcbiAgICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wibG9nZ2VyXCJdLnRyYWNlKCdbcGxheWxpc3QtbG9hZGVyXTogcGxheWxpc3QgcmVxdWVzdCBvbmdvaW5nJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wibG9nZ2VyXCJdLmxvZyhcIltwbGF5bGlzdC1sb2FkZXJdOiBhYm9ydGluZyBwcmV2aW91cyBsb2FkZXIgZm9yIHR5cGU6IFwiICsgY29udGV4dC50eXBlKTtcbiAgICAgIGxvYWRlci5hYm9ydCgpO1xuICAgIH1cblxuICAgIHZhciBtYXhSZXRyeTtcbiAgICB2YXIgdGltZW91dDtcbiAgICB2YXIgcmV0cnlEZWxheTtcbiAgICB2YXIgbWF4UmV0cnlEZWxheTsgLy8gYXBwbHkgZGlmZmVyZW50IGNvbmZpZ3MgZm9yIHJldHJpZXMgZGVwZW5kaW5nIG9uXG4gICAgLy8gY29udGV4dCAobWFuaWZlc3QsIGxldmVsLCBhdWRpby9zdWJzIHBsYXlsaXN0KVxuXG4gICAgc3dpdGNoIChjb250ZXh0LnR5cGUpIHtcbiAgICAgIGNhc2UgX3R5cGVzX2xvYWRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fW1wiUGxheWxpc3RDb250ZXh0VHlwZVwiXS5NQU5JRkVTVDpcbiAgICAgICAgbWF4UmV0cnkgPSBjb25maWcubWFuaWZlc3RMb2FkaW5nTWF4UmV0cnk7XG4gICAgICAgIHRpbWVvdXQgPSBjb25maWcubWFuaWZlc3RMb2FkaW5nVGltZU91dDtcbiAgICAgICAgcmV0cnlEZWxheSA9IGNvbmZpZy5tYW5pZmVzdExvYWRpbmdSZXRyeURlbGF5O1xuICAgICAgICBtYXhSZXRyeURlbGF5ID0gY29uZmlnLm1hbmlmZXN0TG9hZGluZ01heFJldHJ5VGltZW91dDtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgX3R5cGVzX2xvYWRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fW1wiUGxheWxpc3RDb250ZXh0VHlwZVwiXS5MRVZFTDpcbiAgICAgIGNhc2UgX3R5cGVzX2xvYWRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fW1wiUGxheWxpc3RDb250ZXh0VHlwZVwiXS5BVURJT19UUkFDSzpcbiAgICAgIGNhc2UgX3R5cGVzX2xvYWRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fW1wiUGxheWxpc3RDb250ZXh0VHlwZVwiXS5TVUJUSVRMRV9UUkFDSzpcbiAgICAgICAgLy8gTWFuYWdlIHJldHJpZXMgaW4gTGV2ZWwvVHJhY2sgQ29udHJvbGxlclxuICAgICAgICBtYXhSZXRyeSA9IDA7XG4gICAgICAgIHRpbWVvdXQgPSBjb25maWcubGV2ZWxMb2FkaW5nVGltZU91dDtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIG1heFJldHJ5ID0gY29uZmlnLmxldmVsTG9hZGluZ01heFJldHJ5O1xuICAgICAgICB0aW1lb3V0ID0gY29uZmlnLmxldmVsTG9hZGluZ1RpbWVPdXQ7XG4gICAgICAgIHJldHJ5RGVsYXkgPSBjb25maWcubGV2ZWxMb2FkaW5nUmV0cnlEZWxheTtcbiAgICAgICAgbWF4UmV0cnlEZWxheSA9IGNvbmZpZy5sZXZlbExvYWRpbmdNYXhSZXRyeVRpbWVvdXQ7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGxvYWRlciA9IHRoaXMuY3JlYXRlSW50ZXJuYWxMb2FkZXIoY29udGV4dCk7IC8vIE92ZXJyaWRlIGxldmVsL3RyYWNrIHRpbWVvdXQgZm9yIExMLUhMUyByZXF1ZXN0c1xuICAgIC8vICh0aGUgZGVmYXVsdCBvZiAxMDAwMG1zIGlzIGNvdW50ZXIgcHJvZHVjdGl2ZSB0byBibG9ja2luZyBwbGF5bGlzdCByZWxvYWQgcmVxdWVzdHMpXG5cbiAgICBpZiAoKF9jb250ZXh0JGRlbGl2ZXJ5RGlyZSA9IGNvbnRleHQuZGVsaXZlcnlEaXJlY3RpdmVzKSAhPT0gbnVsbCAmJiBfY29udGV4dCRkZWxpdmVyeURpcmUgIT09IHZvaWQgMCAmJiBfY29udGV4dCRkZWxpdmVyeURpcmUucGFydCkge1xuICAgICAgdmFyIGxldmVsRGV0YWlscztcblxuICAgICAgaWYgKGNvbnRleHQudHlwZSA9PT0gX3R5cGVzX2xvYWRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fW1wiUGxheWxpc3RDb250ZXh0VHlwZVwiXS5MRVZFTCAmJiBjb250ZXh0LmxldmVsICE9PSBudWxsKSB7XG4gICAgICAgIGxldmVsRGV0YWlscyA9IHRoaXMuaGxzLmxldmVsc1tjb250ZXh0LmxldmVsXS5kZXRhaWxzO1xuICAgICAgfSBlbHNlIGlmIChjb250ZXh0LnR5cGUgPT09IF90eXBlc19sb2FkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcIlBsYXlsaXN0Q29udGV4dFR5cGVcIl0uQVVESU9fVFJBQ0sgJiYgY29udGV4dC5pZCAhPT0gbnVsbCkge1xuICAgICAgICBsZXZlbERldGFpbHMgPSB0aGlzLmhscy5hdWRpb1RyYWNrc1tjb250ZXh0LmlkXS5kZXRhaWxzO1xuICAgICAgfSBlbHNlIGlmIChjb250ZXh0LnR5cGUgPT09IF90eXBlc19sb2FkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcIlBsYXlsaXN0Q29udGV4dFR5cGVcIl0uU1VCVElUTEVfVFJBQ0sgJiYgY29udGV4dC5pZCAhPT0gbnVsbCkge1xuICAgICAgICBsZXZlbERldGFpbHMgPSB0aGlzLmhscy5zdWJ0aXRsZVRyYWNrc1tjb250ZXh0LmlkXS5kZXRhaWxzO1xuICAgICAgfVxuXG4gICAgICBpZiAobGV2ZWxEZXRhaWxzKSB7XG4gICAgICAgIHZhciBwYXJ0VGFyZ2V0ID0gbGV2ZWxEZXRhaWxzLnBhcnRUYXJnZXQ7XG4gICAgICAgIHZhciB0YXJnZXREdXJhdGlvbiA9IGxldmVsRGV0YWlscy50YXJnZXRkdXJhdGlvbjtcblxuICAgICAgICBpZiAocGFydFRhcmdldCAmJiB0YXJnZXREdXJhdGlvbikge1xuICAgICAgICAgIHRpbWVvdXQgPSBNYXRoLm1pbihNYXRoLm1heChwYXJ0VGFyZ2V0ICogMywgdGFyZ2V0RHVyYXRpb24gKiAwLjgpICogMTAwMCwgdGltZW91dCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbG9hZGVyQ29uZmlnID0ge1xuICAgICAgdGltZW91dDogdGltZW91dCxcbiAgICAgIG1heFJldHJ5OiBtYXhSZXRyeSxcbiAgICAgIHJldHJ5RGVsYXk6IHJldHJ5RGVsYXksXG4gICAgICBtYXhSZXRyeURlbGF5OiBtYXhSZXRyeURlbGF5LFxuICAgICAgaGlnaFdhdGVyTWFyazogMFxuICAgIH07XG4gICAgdmFyIGxvYWRlckNhbGxiYWNrcyA9IHtcbiAgICAgIG9uU3VjY2VzczogdGhpcy5sb2Fkc3VjY2Vzcy5iaW5kKHRoaXMpLFxuICAgICAgb25FcnJvcjogdGhpcy5sb2FkZXJyb3IuYmluZCh0aGlzKSxcbiAgICAgIG9uVGltZW91dDogdGhpcy5sb2FkdGltZW91dC5iaW5kKHRoaXMpXG4gICAgfTsgLy8gbG9nZ2VyLmRlYnVnKGBbcGxheWxpc3QtbG9hZGVyXTogQ2FsbGluZyBpbnRlcm5hbCBsb2FkZXIgZGVsZWdhdGUgZm9yIFVSTDogJHtjb250ZXh0LnVybH1gKTtcblxuICAgIGxvYWRlci5sb2FkKGNvbnRleHQsIGxvYWRlckNvbmZpZywgbG9hZGVyQ2FsbGJhY2tzKTtcbiAgfTtcblxuICBfcHJvdG8ubG9hZHN1Y2Nlc3MgPSBmdW5jdGlvbiBsb2Fkc3VjY2VzcyhyZXNwb25zZSwgc3RhdHMsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzKSB7XG4gICAgaWYgKG5ldHdvcmtEZXRhaWxzID09PSB2b2lkIDApIHtcbiAgICAgIG5ldHdvcmtEZXRhaWxzID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoY29udGV4dC5pc1NpZHhSZXF1ZXN0KSB7XG4gICAgICB0aGlzLmhhbmRsZVNpZHhSZXF1ZXN0KHJlc3BvbnNlLCBjb250ZXh0KTtcbiAgICAgIHRoaXMuaGFuZGxlUGxheWxpc3RMb2FkZWQocmVzcG9uc2UsIHN0YXRzLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5yZXNldEludGVybmFsTG9hZGVyKGNvbnRleHQudHlwZSk7XG4gICAgdmFyIHN0cmluZyA9IHJlc3BvbnNlLmRhdGE7IC8vIFZhbGlkYXRlIGlmIGl0IGlzIGFuIE0zVTggYXQgYWxsXG5cbiAgICBpZiAoc3RyaW5nLmluZGV4T2YoJyNFWFRNM1UnKSAhPT0gMCkge1xuICAgICAgdGhpcy5oYW5kbGVNYW5pZmVzdFBhcnNpbmdFcnJvcihyZXNwb25zZSwgY29udGV4dCwgJ25vIEVYVE0zVSBkZWxpbWl0ZXInLCBuZXR3b3JrRGV0YWlscyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc3RhdHMucGFyc2luZy5zdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpOyAvLyBDaGVjayBpZiBjaHVuay1saXN0IG9yIG1hc3Rlci4gaGFuZGxlIGVtcHR5IGNodW5rIGxpc3QgY2FzZSAoZmlyc3QgRVhUSU5GIG5vdCBzaWduYWxlZCwgYnV0IFRBUkdFVERVUkFUSU9OIHByZXNlbnQpXG5cbiAgICBpZiAoc3RyaW5nLmluZGV4T2YoJyNFWFRJTkY6JykgPiAwIHx8IHN0cmluZy5pbmRleE9mKCcjRVhULVgtVEFSR0VURFVSQVRJT046JykgPiAwKSB7XG4gICAgICB0aGlzLmhhbmRsZVRyYWNrT3JMZXZlbFBsYXlsaXN0KHJlc3BvbnNlLCBzdGF0cywgY29udGV4dCwgbmV0d29ya0RldGFpbHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmhhbmRsZU1hc3RlclBsYXlsaXN0KHJlc3BvbnNlLCBzdGF0cywgY29udGV4dCwgbmV0d29ya0RldGFpbHMpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8ubG9hZGVycm9yID0gZnVuY3Rpb24gbG9hZGVycm9yKHJlc3BvbnNlLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscykge1xuICAgIGlmIChuZXR3b3JrRGV0YWlscyA9PT0gdm9pZCAwKSB7XG4gICAgICBuZXR3b3JrRGV0YWlscyA9IG51bGw7XG4gICAgfVxuXG4gICAgdGhpcy5oYW5kbGVOZXR3b3JrRXJyb3IoY29udGV4dCwgbmV0d29ya0RldGFpbHMsIGZhbHNlLCByZXNwb25zZSk7XG4gIH07XG5cbiAgX3Byb3RvLmxvYWR0aW1lb3V0ID0gZnVuY3Rpb24gbG9hZHRpbWVvdXQoc3RhdHMsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzKSB7XG4gICAgaWYgKG5ldHdvcmtEZXRhaWxzID09PSB2b2lkIDApIHtcbiAgICAgIG5ldHdvcmtEZXRhaWxzID0gbnVsbDtcbiAgICB9XG5cbiAgICB0aGlzLmhhbmRsZU5ldHdvcmtFcnJvcihjb250ZXh0LCBuZXR3b3JrRGV0YWlscywgdHJ1ZSk7XG4gIH07XG5cbiAgX3Byb3RvLmhhbmRsZU1hc3RlclBsYXlsaXN0ID0gZnVuY3Rpb24gaGFuZGxlTWFzdGVyUGxheWxpc3QocmVzcG9uc2UsIHN0YXRzLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscykge1xuICAgIHZhciBobHMgPSB0aGlzLmhscztcbiAgICB2YXIgc3RyaW5nID0gcmVzcG9uc2UuZGF0YTtcbiAgICB2YXIgdXJsID0gZ2V0UmVzcG9uc2VVcmwocmVzcG9uc2UsIGNvbnRleHQpO1xuXG4gICAgdmFyIF9NM1U4UGFyc2VyJHBhcnNlTWFzdCA9IF9tM3U4X3BhcnNlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1wiZGVmYXVsdFwiXS5wYXJzZU1hc3RlclBsYXlsaXN0KHN0cmluZywgdXJsKSxcbiAgICAgICAgbGV2ZWxzID0gX00zVThQYXJzZXIkcGFyc2VNYXN0LmxldmVscyxcbiAgICAgICAgc2Vzc2lvbkRhdGEgPSBfTTNVOFBhcnNlciRwYXJzZU1hc3Quc2Vzc2lvbkRhdGE7XG5cbiAgICBpZiAoIWxldmVscy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuaGFuZGxlTWFuaWZlc3RQYXJzaW5nRXJyb3IocmVzcG9uc2UsIGNvbnRleHQsICdubyBsZXZlbCBmb3VuZCBpbiBtYW5pZmVzdCcsIG5ldHdvcmtEZXRhaWxzKTtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIG11bHRpIGxldmVsIHBsYXlsaXN0LCBwYXJzZSBsZXZlbCBpbmZvXG5cblxuICAgIHZhciBhdWRpb0dyb3VwcyA9IGxldmVscy5tYXAoZnVuY3Rpb24gKGxldmVsKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpZDogbGV2ZWwuYXR0cnMuQVVESU8sXG4gICAgICAgIGF1ZGlvQ29kZWM6IGxldmVsLmF1ZGlvQ29kZWNcbiAgICAgIH07XG4gICAgfSk7XG4gICAgdmFyIHN1YnRpdGxlR3JvdXBzID0gbGV2ZWxzLm1hcChmdW5jdGlvbiAobGV2ZWwpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlkOiBsZXZlbC5hdHRycy5TVUJUSVRMRVMsXG4gICAgICAgIHRleHRDb2RlYzogbGV2ZWwudGV4dENvZGVjXG4gICAgICB9O1xuICAgIH0pO1xuICAgIHZhciBhdWRpb1RyYWNrcyA9IF9tM3U4X3BhcnNlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1wiZGVmYXVsdFwiXS5wYXJzZU1hc3RlclBsYXlsaXN0TWVkaWEoc3RyaW5nLCB1cmwsICdBVURJTycsIGF1ZGlvR3JvdXBzKTtcbiAgICB2YXIgc3VidGl0bGVzID0gX20zdThfcGFyc2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXCJkZWZhdWx0XCJdLnBhcnNlTWFzdGVyUGxheWxpc3RNZWRpYShzdHJpbmcsIHVybCwgJ1NVQlRJVExFUycsIHN1YnRpdGxlR3JvdXBzKTtcbiAgICB2YXIgY2FwdGlvbnMgPSBfbTN1OF9wYXJzZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcImRlZmF1bHRcIl0ucGFyc2VNYXN0ZXJQbGF5bGlzdE1lZGlhKHN0cmluZywgdXJsLCAnQ0xPU0VELUNBUFRJT05TJyk7XG5cbiAgICBpZiAoYXVkaW9UcmFja3MubGVuZ3RoKSB7XG4gICAgICAvLyBjaGVjayBpZiB3ZSBoYXZlIGZvdW5kIGFuIGF1ZGlvIHRyYWNrIGVtYmVkZGVkIGluIG1haW4gcGxheWxpc3QgKGF1ZGlvIHRyYWNrIHdpdGhvdXQgVVJJIGF0dHJpYnV0ZSlcbiAgICAgIHZhciBlbWJlZGRlZEF1ZGlvRm91bmQgPSBhdWRpb1RyYWNrcy5zb21lKGZ1bmN0aW9uIChhdWRpb1RyYWNrKSB7XG4gICAgICAgIHJldHVybiAhYXVkaW9UcmFjay51cmw7XG4gICAgICB9KTsgLy8gaWYgbm8gZW1iZWRkZWQgYXVkaW8gdHJhY2sgZGVmaW5lZCwgYnV0IGF1ZGlvIGNvZGVjIHNpZ25hbGVkIGluIHF1YWxpdHkgbGV2ZWwsXG4gICAgICAvLyB3ZSBuZWVkIHRvIHNpZ25hbCB0aGlzIG1haW4gYXVkaW8gdHJhY2sgdGhpcyBjb3VsZCBoYXBwZW4gd2l0aCBwbGF5bGlzdHMgd2l0aFxuICAgICAgLy8gYWx0IGF1ZGlvIHJlbmRpdGlvbiBpbiB3aGljaCBxdWFsaXR5IGxldmVscyAobWFpbilcbiAgICAgIC8vIGNvbnRhaW5zIGJvdGggYXVkaW8rdmlkZW8uIGJ1dCB3aXRoIG1peGVkIGF1ZGlvIHRyYWNrIG5vdCBzaWduYWxlZFxuXG4gICAgICBpZiAoIWVtYmVkZGVkQXVkaW9Gb3VuZCAmJiBsZXZlbHNbMF0uYXVkaW9Db2RlYyAmJiAhbGV2ZWxzWzBdLmF0dHJzLkFVRElPKSB7XG4gICAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcImxvZ2dlclwiXS5sb2coJ1twbGF5bGlzdC1sb2FkZXJdOiBhdWRpbyBjb2RlYyBzaWduYWxlZCBpbiBxdWFsaXR5IGxldmVsLCBidXQgbm8gZW1iZWRkZWQgYXVkaW8gdHJhY2sgc2lnbmFsZWQsIGNyZWF0ZSBvbmUnKTtcbiAgICAgICAgYXVkaW9UcmFja3MudW5zaGlmdCh7XG4gICAgICAgICAgdHlwZTogJ21haW4nLFxuICAgICAgICAgIG5hbWU6ICdtYWluJyxcbiAgICAgICAgICBkZWZhdWx0OiBmYWxzZSxcbiAgICAgICAgICBhdXRvc2VsZWN0OiBmYWxzZSxcbiAgICAgICAgICBmb3JjZWQ6IGZhbHNlLFxuICAgICAgICAgIGlkOiAtMSxcbiAgICAgICAgICBhdHRyczogbmV3IF91dGlsc19hdHRyX2xpc3RfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1tcIkF0dHJMaXN0XCJdKHt9KSxcbiAgICAgICAgICBiaXRyYXRlOiAwLFxuICAgICAgICAgIHVybDogJydcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXZlbnRzXCJdLk1BTklGRVNUX0xPQURFRCwge1xuICAgICAgbGV2ZWxzOiBsZXZlbHMsXG4gICAgICBhdWRpb1RyYWNrczogYXVkaW9UcmFja3MsXG4gICAgICBzdWJ0aXRsZXM6IHN1YnRpdGxlcyxcbiAgICAgIGNhcHRpb25zOiBjYXB0aW9ucyxcbiAgICAgIHVybDogdXJsLFxuICAgICAgc3RhdHM6IHN0YXRzLFxuICAgICAgbmV0d29ya0RldGFpbHM6IG5ldHdvcmtEZXRhaWxzLFxuICAgICAgc2Vzc2lvbkRhdGE6IHNlc3Npb25EYXRhXG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLmhhbmRsZVRyYWNrT3JMZXZlbFBsYXlsaXN0ID0gZnVuY3Rpb24gaGFuZGxlVHJhY2tPckxldmVsUGxheWxpc3QocmVzcG9uc2UsIHN0YXRzLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscykge1xuICAgIHZhciBobHMgPSB0aGlzLmhscztcbiAgICB2YXIgaWQgPSBjb250ZXh0LmlkLFxuICAgICAgICBsZXZlbCA9IGNvbnRleHQubGV2ZWwsXG4gICAgICAgIHR5cGUgPSBjb250ZXh0LnR5cGU7XG4gICAgdmFyIHVybCA9IGdldFJlc3BvbnNlVXJsKHJlc3BvbnNlLCBjb250ZXh0KTtcbiAgICB2YXIgbGV2ZWxVcmxJZCA9IE9iamVjdChfaG9tZV9ydW5uZXJfd29ya19obHNfanNfaGxzX2pzX3NyY19wb2x5ZmlsbHNfbnVtYmVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJpc0Zpbml0ZU51bWJlclwiXSkoaWQpID8gaWQgOiAwO1xuICAgIHZhciBsZXZlbElkID0gT2JqZWN0KF9ob21lX3J1bm5lcl93b3JrX2hsc19qc19obHNfanNfc3JjX3BvbHlmaWxsc19udW1iZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImlzRmluaXRlTnVtYmVyXCJdKShsZXZlbCkgPyBsZXZlbCA6IGxldmVsVXJsSWQ7XG4gICAgdmFyIGxldmVsVHlwZSA9IG1hcENvbnRleHRUb0xldmVsVHlwZShjb250ZXh0KTtcbiAgICB2YXIgbGV2ZWxEZXRhaWxzID0gX20zdThfcGFyc2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXCJkZWZhdWx0XCJdLnBhcnNlTGV2ZWxQbGF5bGlzdChyZXNwb25zZS5kYXRhLCB1cmwsIGxldmVsSWQsIGxldmVsVHlwZSwgbGV2ZWxVcmxJZCk7XG5cbiAgICBpZiAoIWxldmVsRGV0YWlscy5mcmFnbWVudHMubGVuZ3RoKSB7XG4gICAgICBobHMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFdmVudHNcIl0uRVJST1IsIHtcbiAgICAgICAgdHlwZTogX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiRXJyb3JUeXBlc1wiXS5ORVRXT1JLX0VSUk9SLFxuICAgICAgICBkZXRhaWxzOiBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJFcnJvckRldGFpbHNcIl0uTEVWRUxfRU1QVFlfRVJST1IsXG4gICAgICAgIGZhdGFsOiBmYWxzZSxcbiAgICAgICAgdXJsOiB1cmwsXG4gICAgICAgIHJlYXNvbjogJ25vIGZyYWdtZW50cyBmb3VuZCBpbiBsZXZlbCcsXG4gICAgICAgIGxldmVsOiB0eXBlb2YgY29udGV4dC5sZXZlbCA9PT0gJ251bWJlcicgPyBjb250ZXh0LmxldmVsIDogdW5kZWZpbmVkXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIFdlIGhhdmUgZG9uZSBvdXIgZmlyc3QgcmVxdWVzdCAoTWFuaWZlc3QtdHlwZSkgYW5kIHJlY2VpdmVcbiAgICAvLyBub3QgYSBtYXN0ZXIgcGxheWxpc3QgYnV0IGEgY2h1bmstbGlzdCAodHJhY2svbGV2ZWwpXG4gICAgLy8gV2UgZmlyZSB0aGUgbWFuaWZlc3QtbG9hZGVkIGV2ZW50IGFueXdheSB3aXRoIHRoZSBwYXJzZWQgbGV2ZWwtZGV0YWlsc1xuICAgIC8vIGJ5IGNyZWF0aW5nIGEgc2luZ2xlLWxldmVsIHN0cnVjdHVyZSBmb3IgaXQuXG5cblxuICAgIGlmICh0eXBlID09PSBfdHlwZXNfbG9hZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXCJQbGF5bGlzdENvbnRleHRUeXBlXCJdLk1BTklGRVNUKSB7XG4gICAgICB2YXIgc2luZ2xlTGV2ZWwgPSB7XG4gICAgICAgIGF0dHJzOiBuZXcgX3V0aWxzX2F0dHJfbGlzdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fW1wiQXR0ckxpc3RcIl0oe30pLFxuICAgICAgICBiaXRyYXRlOiAwLFxuICAgICAgICBkZXRhaWxzOiBsZXZlbERldGFpbHMsXG4gICAgICAgIG5hbWU6ICcnLFxuICAgICAgICB1cmw6IHVybFxuICAgICAgfTtcbiAgICAgIGhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkV2ZW50c1wiXS5NQU5JRkVTVF9MT0FERUQsIHtcbiAgICAgICAgbGV2ZWxzOiBbc2luZ2xlTGV2ZWxdLFxuICAgICAgICBhdWRpb1RyYWNrczogW10sXG4gICAgICAgIHVybDogdXJsLFxuICAgICAgICBzdGF0czogc3RhdHMsXG4gICAgICAgIG5ldHdvcmtEZXRhaWxzOiBuZXR3b3JrRGV0YWlscyxcbiAgICAgICAgc2Vzc2lvbkRhdGE6IG51bGxcbiAgICAgIH0pO1xuICAgIH0gLy8gc2F2ZSBwYXJzaW5nIHRpbWVcblxuXG4gICAgc3RhdHMucGFyc2luZy5lbmQgPSBwZXJmb3JtYW5jZS5ub3coKTsgLy8gaW4gY2FzZSB3ZSBuZWVkIFNJRFggcmFuZ2VzXG4gICAgLy8gcmV0dXJuIGVhcmx5IGFmdGVyIGNhbGxpbmcgbG9hZCBmb3JcbiAgICAvLyB0aGUgU0lEWCBib3guXG5cbiAgICBpZiAobGV2ZWxEZXRhaWxzLm5lZWRTaWR4UmFuZ2VzKSB7XG4gICAgICB2YXIgX2xldmVsRGV0YWlscyRmcmFnbWVuO1xuXG4gICAgICB2YXIgc2lkeFVybCA9IChfbGV2ZWxEZXRhaWxzJGZyYWdtZW4gPSBsZXZlbERldGFpbHMuZnJhZ21lbnRzWzBdLmluaXRTZWdtZW50KSA9PT0gbnVsbCB8fCBfbGV2ZWxEZXRhaWxzJGZyYWdtZW4gPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9sZXZlbERldGFpbHMkZnJhZ21lbi51cmw7XG4gICAgICB0aGlzLmxvYWQoe1xuICAgICAgICB1cmw6IHNpZHhVcmwsXG4gICAgICAgIGlzU2lkeFJlcXVlc3Q6IHRydWUsXG4gICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgIGxldmVsOiBsZXZlbCxcbiAgICAgICAgbGV2ZWxEZXRhaWxzOiBsZXZlbERldGFpbHMsXG4gICAgICAgIGlkOiBpZCxcbiAgICAgICAgZ3JvdXBJZDogbnVsbCxcbiAgICAgICAgcmFuZ2VTdGFydDogMCxcbiAgICAgICAgcmFuZ2VFbmQ6IDIwNDgsXG4gICAgICAgIHJlc3BvbnNlVHlwZTogJ2FycmF5YnVmZmVyJyxcbiAgICAgICAgZGVsaXZlcnlEaXJlY3RpdmVzOiBudWxsXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIGV4dGVuZCB0aGUgY29udGV4dCB3aXRoIHRoZSBuZXcgbGV2ZWxEZXRhaWxzIHByb3BlcnR5XG5cblxuICAgIGNvbnRleHQubGV2ZWxEZXRhaWxzID0gbGV2ZWxEZXRhaWxzO1xuICAgIHRoaXMuaGFuZGxlUGxheWxpc3RMb2FkZWQocmVzcG9uc2UsIHN0YXRzLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscyk7XG4gIH07XG5cbiAgX3Byb3RvLmhhbmRsZVNpZHhSZXF1ZXN0ID0gZnVuY3Rpb24gaGFuZGxlU2lkeFJlcXVlc3QocmVzcG9uc2UsIGNvbnRleHQpIHtcbiAgICB2YXIgc2lkeEluZm8gPSBPYmplY3QoX3V0aWxzX21wNF90b29sc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fW1wicGFyc2VTZWdtZW50SW5kZXhcIl0pKG5ldyBVaW50OEFycmF5KHJlc3BvbnNlLmRhdGEpKTsgLy8gaWYgcHJvdmlkZWQgZnJhZ21lbnQgZG9lcyBub3QgY29udGFpbiBzaWR4LCBlYXJseSByZXR1cm5cblxuICAgIGlmICghc2lkeEluZm8pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgc2lkeFJlZmVyZW5jZXMgPSBzaWR4SW5mby5yZWZlcmVuY2VzO1xuICAgIHZhciBsZXZlbERldGFpbHMgPSBjb250ZXh0LmxldmVsRGV0YWlscztcbiAgICBzaWR4UmVmZXJlbmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChzZWdtZW50UmVmLCBpbmRleCkge1xuICAgICAgdmFyIHNlZ1JlZkluZm8gPSBzZWdtZW50UmVmLmluZm87XG4gICAgICB2YXIgZnJhZyA9IGxldmVsRGV0YWlscy5mcmFnbWVudHNbaW5kZXhdO1xuXG4gICAgICBpZiAoZnJhZy5ieXRlUmFuZ2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGZyYWcuc2V0Qnl0ZVJhbmdlKFN0cmluZygxICsgc2VnUmVmSW5mby5lbmQgLSBzZWdSZWZJbmZvLnN0YXJ0KSArICdAJyArIFN0cmluZyhzZWdSZWZJbmZvLnN0YXJ0KSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChmcmFnLmluaXRTZWdtZW50KSB7XG4gICAgICAgIGZyYWcuaW5pdFNlZ21lbnQuc2V0Qnl0ZVJhbmdlKFN0cmluZyhzaWR4SW5mby5tb292RW5kT2Zmc2V0KSArICdAMCcpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90by5oYW5kbGVNYW5pZmVzdFBhcnNpbmdFcnJvciA9IGZ1bmN0aW9uIGhhbmRsZU1hbmlmZXN0UGFyc2luZ0Vycm9yKHJlc3BvbnNlLCBjb250ZXh0LCByZWFzb24sIG5ldHdvcmtEZXRhaWxzKSB7XG4gICAgdGhpcy5obHMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFdmVudHNcIl0uRVJST1IsIHtcbiAgICAgIHR5cGU6IF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcIkVycm9yVHlwZXNcIl0uTkVUV09SS19FUlJPUixcbiAgICAgIGRldGFpbHM6IF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcIkVycm9yRGV0YWlsc1wiXS5NQU5JRkVTVF9QQVJTSU5HX0VSUk9SLFxuICAgICAgZmF0YWw6IGNvbnRleHQudHlwZSA9PT0gX3R5cGVzX2xvYWRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fW1wiUGxheWxpc3RDb250ZXh0VHlwZVwiXS5NQU5JRkVTVCxcbiAgICAgIHVybDogcmVzcG9uc2UudXJsLFxuICAgICAgcmVhc29uOiByZWFzb24sXG4gICAgICByZXNwb25zZTogcmVzcG9uc2UsXG4gICAgICBjb250ZXh0OiBjb250ZXh0LFxuICAgICAgbmV0d29ya0RldGFpbHM6IG5ldHdvcmtEZXRhaWxzXG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLmhhbmRsZU5ldHdvcmtFcnJvciA9IGZ1bmN0aW9uIGhhbmRsZU5ldHdvcmtFcnJvcihjb250ZXh0LCBuZXR3b3JrRGV0YWlscywgdGltZW91dCwgcmVzcG9uc2UpIHtcbiAgICBpZiAodGltZW91dCA9PT0gdm9pZCAwKSB7XG4gICAgICB0aW1lb3V0ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wibG9nZ2VyXCJdLndhcm4oXCJbcGxheWxpc3QtbG9hZGVyXTogQSBuZXR3b3JrIFwiICsgKHRpbWVvdXQgPyAndGltZW91dCcgOiAnZXJyb3InKSArIFwiIG9jY3VycmVkIHdoaWxlIGxvYWRpbmcgXCIgKyBjb250ZXh0LnR5cGUgKyBcIiBsZXZlbDogXCIgKyBjb250ZXh0LmxldmVsICsgXCIgaWQ6IFwiICsgY29udGV4dC5pZCArIFwiIGdyb3VwLWlkOiBcXFwiXCIgKyBjb250ZXh0Lmdyb3VwSWQgKyBcIlxcXCJcIik7XG4gICAgdmFyIGRldGFpbHMgPSBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJFcnJvckRldGFpbHNcIl0uVU5LTk9XTjtcbiAgICB2YXIgZmF0YWwgPSBmYWxzZTtcbiAgICB2YXIgbG9hZGVyID0gdGhpcy5nZXRJbnRlcm5hbExvYWRlcihjb250ZXh0KTtcblxuICAgIHN3aXRjaCAoY29udGV4dC50eXBlKSB7XG4gICAgICBjYXNlIF90eXBlc19sb2FkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcIlBsYXlsaXN0Q29udGV4dFR5cGVcIl0uTUFOSUZFU1Q6XG4gICAgICAgIGRldGFpbHMgPSB0aW1lb3V0ID8gX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiRXJyb3JEZXRhaWxzXCJdLk1BTklGRVNUX0xPQURfVElNRU9VVCA6IF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcIkVycm9yRGV0YWlsc1wiXS5NQU5JRkVTVF9MT0FEX0VSUk9SO1xuICAgICAgICBmYXRhbCA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIF90eXBlc19sb2FkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcIlBsYXlsaXN0Q29udGV4dFR5cGVcIl0uTEVWRUw6XG4gICAgICAgIGRldGFpbHMgPSB0aW1lb3V0ID8gX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiRXJyb3JEZXRhaWxzXCJdLkxFVkVMX0xPQURfVElNRU9VVCA6IF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcIkVycm9yRGV0YWlsc1wiXS5MRVZFTF9MT0FEX0VSUk9SO1xuICAgICAgICBmYXRhbCA9IGZhbHNlO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBfdHlwZXNfbG9hZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXCJQbGF5bGlzdENvbnRleHRUeXBlXCJdLkFVRElPX1RSQUNLOlxuICAgICAgICBkZXRhaWxzID0gdGltZW91dCA/IF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcIkVycm9yRGV0YWlsc1wiXS5BVURJT19UUkFDS19MT0FEX1RJTUVPVVQgOiBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJFcnJvckRldGFpbHNcIl0uQVVESU9fVFJBQ0tfTE9BRF9FUlJPUjtcbiAgICAgICAgZmF0YWwgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgX3R5cGVzX2xvYWRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fW1wiUGxheWxpc3RDb250ZXh0VHlwZVwiXS5TVUJUSVRMRV9UUkFDSzpcbiAgICAgICAgZGV0YWlscyA9IHRpbWVvdXQgPyBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJFcnJvckRldGFpbHNcIl0uU1VCVElUTEVfVFJBQ0tfTE9BRF9USU1FT1VUIDogX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiRXJyb3JEZXRhaWxzXCJdLlNVQlRJVExFX0xPQURfRVJST1I7XG4gICAgICAgIGZhdGFsID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChsb2FkZXIpIHtcbiAgICAgIHRoaXMucmVzZXRJbnRlcm5hbExvYWRlcihjb250ZXh0LnR5cGUpO1xuICAgIH1cblxuICAgIHZhciBlcnJvckRhdGEgPSB7XG4gICAgICB0eXBlOiBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJFcnJvclR5cGVzXCJdLk5FVFdPUktfRVJST1IsXG4gICAgICBkZXRhaWxzOiBkZXRhaWxzLFxuICAgICAgZmF0YWw6IGZhdGFsLFxuICAgICAgdXJsOiBjb250ZXh0LnVybCxcbiAgICAgIGxvYWRlcjogbG9hZGVyLFxuICAgICAgY29udGV4dDogY29udGV4dCxcbiAgICAgIG5ldHdvcmtEZXRhaWxzOiBuZXR3b3JrRGV0YWlsc1xuICAgIH07XG5cbiAgICBpZiAocmVzcG9uc2UpIHtcbiAgICAgIGVycm9yRGF0YS5yZXNwb25zZSA9IHJlc3BvbnNlO1xuICAgIH1cblxuICAgIHRoaXMuaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXZlbnRzXCJdLkVSUk9SLCBlcnJvckRhdGEpO1xuICB9O1xuXG4gIF9wcm90by5oYW5kbGVQbGF5bGlzdExvYWRlZCA9IGZ1bmN0aW9uIGhhbmRsZVBsYXlsaXN0TG9hZGVkKHJlc3BvbnNlLCBzdGF0cywgY29udGV4dCwgbmV0d29ya0RldGFpbHMpIHtcbiAgICB2YXIgdHlwZSA9IGNvbnRleHQudHlwZSxcbiAgICAgICAgbGV2ZWwgPSBjb250ZXh0LmxldmVsLFxuICAgICAgICBpZCA9IGNvbnRleHQuaWQsXG4gICAgICAgIGdyb3VwSWQgPSBjb250ZXh0Lmdyb3VwSWQsXG4gICAgICAgIGxvYWRlciA9IGNvbnRleHQubG9hZGVyLFxuICAgICAgICBsZXZlbERldGFpbHMgPSBjb250ZXh0LmxldmVsRGV0YWlscyxcbiAgICAgICAgZGVsaXZlcnlEaXJlY3RpdmVzID0gY29udGV4dC5kZWxpdmVyeURpcmVjdGl2ZXM7XG5cbiAgICBpZiAoIShsZXZlbERldGFpbHMgIT09IG51bGwgJiYgbGV2ZWxEZXRhaWxzICE9PSB2b2lkIDAgJiYgbGV2ZWxEZXRhaWxzLnRhcmdldGR1cmF0aW9uKSkge1xuICAgICAgdGhpcy5oYW5kbGVNYW5pZmVzdFBhcnNpbmdFcnJvcihyZXNwb25zZSwgY29udGV4dCwgJ2ludmFsaWQgdGFyZ2V0IGR1cmF0aW9uJywgbmV0d29ya0RldGFpbHMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghbG9hZGVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGxldmVsRGV0YWlscy5saXZlKSB7XG4gICAgICBpZiAobG9hZGVyLmdldENhY2hlQWdlKSB7XG4gICAgICAgIGxldmVsRGV0YWlscy5hZ2VIZWFkZXIgPSBsb2FkZXIuZ2V0Q2FjaGVBZ2UoKSB8fCAwO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWxvYWRlci5nZXRDYWNoZUFnZSB8fCBpc05hTihsZXZlbERldGFpbHMuYWdlSGVhZGVyKSkge1xuICAgICAgICBsZXZlbERldGFpbHMuYWdlSGVhZGVyID0gMDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgX3R5cGVzX2xvYWRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fW1wiUGxheWxpc3RDb250ZXh0VHlwZVwiXS5NQU5JRkVTVDpcbiAgICAgIGNhc2UgX3R5cGVzX2xvYWRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fW1wiUGxheWxpc3RDb250ZXh0VHlwZVwiXS5MRVZFTDpcbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFdmVudHNcIl0uTEVWRUxfTE9BREVELCB7XG4gICAgICAgICAgZGV0YWlsczogbGV2ZWxEZXRhaWxzLFxuICAgICAgICAgIGxldmVsOiBsZXZlbCB8fCAwLFxuICAgICAgICAgIGlkOiBpZCB8fCAwLFxuICAgICAgICAgIHN0YXRzOiBzdGF0cyxcbiAgICAgICAgICBuZXR3b3JrRGV0YWlsczogbmV0d29ya0RldGFpbHMsXG4gICAgICAgICAgZGVsaXZlcnlEaXJlY3RpdmVzOiBkZWxpdmVyeURpcmVjdGl2ZXNcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIF90eXBlc19sb2FkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcIlBsYXlsaXN0Q29udGV4dFR5cGVcIl0uQVVESU9fVFJBQ0s6XG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXZlbnRzXCJdLkFVRElPX1RSQUNLX0xPQURFRCwge1xuICAgICAgICAgIGRldGFpbHM6IGxldmVsRGV0YWlscyxcbiAgICAgICAgICBpZDogaWQgfHwgMCxcbiAgICAgICAgICBncm91cElkOiBncm91cElkIHx8ICcnLFxuICAgICAgICAgIHN0YXRzOiBzdGF0cyxcbiAgICAgICAgICBuZXR3b3JrRGV0YWlsczogbmV0d29ya0RldGFpbHMsXG4gICAgICAgICAgZGVsaXZlcnlEaXJlY3RpdmVzOiBkZWxpdmVyeURpcmVjdGl2ZXNcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIF90eXBlc19sb2FkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcIlBsYXlsaXN0Q29udGV4dFR5cGVcIl0uU1VCVElUTEVfVFJBQ0s6XG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXZlbnRzXCJdLlNVQlRJVExFX1RSQUNLX0xPQURFRCwge1xuICAgICAgICAgIGRldGFpbHM6IGxldmVsRGV0YWlscyxcbiAgICAgICAgICBpZDogaWQgfHwgMCxcbiAgICAgICAgICBncm91cElkOiBncm91cElkIHx8ICcnLFxuICAgICAgICAgIHN0YXRzOiBzdGF0cyxcbiAgICAgICAgICBuZXR3b3JrRGV0YWlsczogbmV0d29ya0RldGFpbHMsXG4gICAgICAgICAgZGVsaXZlcnlEaXJlY3RpdmVzOiBkZWxpdmVyeURpcmVjdGl2ZXNcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gUGxheWxpc3RMb2FkZXI7XG59KCk7XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoUGxheWxpc3RMb2FkZXIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9wb2x5ZmlsbHMvbnVtYmVyLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvcG9seWZpbGxzL251bWJlci50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGlzRmluaXRlTnVtYmVyLCBNQVhfU0FGRV9JTlRFR0VSICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImlzRmluaXRlTnVtYmVyXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gaXNGaW5pdGVOdW1iZXI7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIk1BWF9TQUZFX0lOVEVHRVJcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBNQVhfU0FGRV9JTlRFR0VSOyB9KTtcbnZhciBpc0Zpbml0ZU51bWJlciA9IE51bWJlci5pc0Zpbml0ZSB8fCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgaXNGaW5pdGUodmFsdWUpO1xufTtcbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgfHwgOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvcmVtdXgvYWFjLWhlbHBlci50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3JlbXV4L2FhYy1oZWxwZXIudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyoqXG4gKiAgQUFDIGhlbHBlclxuICovXG52YXIgQUFDID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQUFDKCkge31cblxuICBBQUMuZ2V0U2lsZW50RnJhbWUgPSBmdW5jdGlvbiBnZXRTaWxlbnRGcmFtZShjb2RlYywgY2hhbm5lbENvdW50KSB7XG4gICAgc3dpdGNoIChjb2RlYykge1xuICAgICAgY2FzZSAnbXA0YS40MC4yJzpcbiAgICAgICAgaWYgKGNoYW5uZWxDb3VudCA9PT0gMSkge1xuICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShbMHgwMCwgMHhjOCwgMHgwMCwgMHg4MCwgMHgyMywgMHg4MF0pO1xuICAgICAgICB9IGVsc2UgaWYgKGNoYW5uZWxDb3VudCA9PT0gMikge1xuICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShbMHgyMSwgMHgwMCwgMHg0OSwgMHg5MCwgMHgwMiwgMHgxOSwgMHgwMCwgMHgyMywgMHg4MF0pO1xuICAgICAgICB9IGVsc2UgaWYgKGNoYW5uZWxDb3VudCA9PT0gMykge1xuICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShbMHgwMCwgMHhjOCwgMHgwMCwgMHg4MCwgMHgyMCwgMHg4NCwgMHgwMSwgMHgyNiwgMHg0MCwgMHgwOCwgMHg2NCwgMHgwMCwgMHg4ZV0pO1xuICAgICAgICB9IGVsc2UgaWYgKGNoYW5uZWxDb3VudCA9PT0gNCkge1xuICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShbMHgwMCwgMHhjOCwgMHgwMCwgMHg4MCwgMHgyMCwgMHg4NCwgMHgwMSwgMHgyNiwgMHg0MCwgMHgwOCwgMHg2NCwgMHgwMCwgMHg4MCwgMHgyYywgMHg4MCwgMHgwOCwgMHgwMiwgMHgzOF0pO1xuICAgICAgICB9IGVsc2UgaWYgKGNoYW5uZWxDb3VudCA9PT0gNSkge1xuICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShbMHgwMCwgMHhjOCwgMHgwMCwgMHg4MCwgMHgyMCwgMHg4NCwgMHgwMSwgMHgyNiwgMHg0MCwgMHgwOCwgMHg2NCwgMHgwMCwgMHg4MiwgMHgzMCwgMHgwNCwgMHg5OSwgMHgwMCwgMHgyMSwgMHg5MCwgMHgwMiwgMHgzOF0pO1xuICAgICAgICB9IGVsc2UgaWYgKGNoYW5uZWxDb3VudCA9PT0gNikge1xuICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShbMHgwMCwgMHhjOCwgMHgwMCwgMHg4MCwgMHgyMCwgMHg4NCwgMHgwMSwgMHgyNiwgMHg0MCwgMHgwOCwgMHg2NCwgMHgwMCwgMHg4MiwgMHgzMCwgMHgwNCwgMHg5OSwgMHgwMCwgMHgyMSwgMHg5MCwgMHgwMiwgMHgwMCwgMHhiMiwgMHgwMCwgMHgyMCwgMHgwOCwgMHhlMF0pO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyBoYW5kbGUgSEUtQUFDIGJlbG93IChtcDRhLjQwLjUgLyBtcDRhLjQwLjI5KVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAoY2hhbm5lbENvdW50ID09PSAxKSB7XG4gICAgICAgICAgLy8gZmZtcGVnIC15IC1mIGxhdmZpIC1pIFwiYWV2YWxzcmM9MDpkPTAuMDVcIiAtYzphIGxpYmZka19hYWMgLXByb2ZpbGU6YSBhYWNfaGUgLWI6YSA0ayBvdXRwdXQuYWFjICYmIGhleGR1bXAgLXYgLWUgJzE2LzEgXCIweCV4LFwiIFwiXFxuXCInIC12IG91dHB1dC5hYWNcbiAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzB4MSwgMHg0MCwgMHgyMiwgMHg4MCwgMHhhMywgMHg0ZSwgMHhlNiwgMHg4MCwgMHhiYSwgMHg4LCAweDAsIDB4MCwgMHgwLCAweDFjLCAweDYsIDB4ZjEsIDB4YzEsIDB4YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1ZV0pO1xuICAgICAgICB9IGVsc2UgaWYgKGNoYW5uZWxDb3VudCA9PT0gMikge1xuICAgICAgICAgIC8vIGZmbXBlZyAteSAtZiBsYXZmaSAtaSBcImFldmFsc3JjPTB8MDpkPTAuMDVcIiAtYzphIGxpYmZka19hYWMgLXByb2ZpbGU6YSBhYWNfaGVfdjIgLWI6YSA0ayBvdXRwdXQuYWFjICYmIGhleGR1bXAgLXYgLWUgJzE2LzEgXCIweCV4LFwiIFwiXFxuXCInIC12IG91dHB1dC5hYWNcbiAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzB4MSwgMHg0MCwgMHgyMiwgMHg4MCwgMHhhMywgMHg1ZSwgMHhlNiwgMHg4MCwgMHhiYSwgMHg4LCAweDAsIDB4MCwgMHgwLCAweDAsIDB4OTUsIDB4MCwgMHg2LCAweGYxLCAweGExLCAweGEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWVdKTtcbiAgICAgICAgfSBlbHNlIGlmIChjaGFubmVsQ291bnQgPT09IDMpIHtcbiAgICAgICAgICAvLyBmZm1wZWcgLXkgLWYgbGF2ZmkgLWkgXCJhZXZhbHNyYz0wfDB8MDpkPTAuMDVcIiAtYzphIGxpYmZka19hYWMgLXByb2ZpbGU6YSBhYWNfaGVfdjIgLWI6YSA0ayBvdXRwdXQuYWFjICYmIGhleGR1bXAgLXYgLWUgJzE2LzEgXCIweCV4LFwiIFwiXFxuXCInIC12IG91dHB1dC5hYWNcbiAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzB4MSwgMHg0MCwgMHgyMiwgMHg4MCwgMHhhMywgMHg1ZSwgMHhlNiwgMHg4MCwgMHhiYSwgMHg4LCAweDAsIDB4MCwgMHgwLCAweDAsIDB4OTUsIDB4MCwgMHg2LCAweGYxLCAweGExLCAweGEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWVdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH07XG5cbiAgcmV0dXJuIEFBQztcbn0oKTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChBQUMpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9yZW11eC9tcDQtZ2VuZXJhdG9yLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvcmVtdXgvbXA0LWdlbmVyYXRvci50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKipcbiAqIEdlbmVyYXRlIE1QNCBCb3hcbiAqL1xudmFyIFVJTlQzMl9NQVggPSBNYXRoLnBvdygyLCAzMikgLSAxO1xuXG52YXIgTVA0ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gTVA0KCkge31cblxuICBNUDQuaW5pdCA9IGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgTVA0LnR5cGVzID0ge1xuICAgICAgYXZjMTogW10sXG4gICAgICAvLyBjb2RpbmduYW1lXG4gICAgICBhdmNDOiBbXSxcbiAgICAgIGJ0cnQ6IFtdLFxuICAgICAgZGluZjogW10sXG4gICAgICBkcmVmOiBbXSxcbiAgICAgIGVzZHM6IFtdLFxuICAgICAgZnR5cDogW10sXG4gICAgICBoZGxyOiBbXSxcbiAgICAgIG1kYXQ6IFtdLFxuICAgICAgbWRoZDogW10sXG4gICAgICBtZGlhOiBbXSxcbiAgICAgIG1maGQ6IFtdLFxuICAgICAgbWluZjogW10sXG4gICAgICBtb29mOiBbXSxcbiAgICAgIG1vb3Y6IFtdLFxuICAgICAgbXA0YTogW10sXG4gICAgICAnLm1wMyc6IFtdLFxuICAgICAgbXZleDogW10sXG4gICAgICBtdmhkOiBbXSxcbiAgICAgIHBhc3A6IFtdLFxuICAgICAgc2R0cDogW10sXG4gICAgICBzdGJsOiBbXSxcbiAgICAgIHN0Y286IFtdLFxuICAgICAgc3RzYzogW10sXG4gICAgICBzdHNkOiBbXSxcbiAgICAgIHN0c3o6IFtdLFxuICAgICAgc3R0czogW10sXG4gICAgICB0ZmR0OiBbXSxcbiAgICAgIHRmaGQ6IFtdLFxuICAgICAgdHJhZjogW10sXG4gICAgICB0cmFrOiBbXSxcbiAgICAgIHRydW46IFtdLFxuICAgICAgdHJleDogW10sXG4gICAgICB0a2hkOiBbXSxcbiAgICAgIHZtaGQ6IFtdLFxuICAgICAgc21oZDogW11cbiAgICB9O1xuICAgIHZhciBpO1xuXG4gICAgZm9yIChpIGluIE1QNC50eXBlcykge1xuICAgICAgaWYgKE1QNC50eXBlcy5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgICBNUDQudHlwZXNbaV0gPSBbaS5jaGFyQ29kZUF0KDApLCBpLmNoYXJDb2RlQXQoMSksIGkuY2hhckNvZGVBdCgyKSwgaS5jaGFyQ29kZUF0KDMpXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgdmlkZW9IZGxyID0gbmV3IFVpbnQ4QXJyYXkoWzB4MDAsIC8vIHZlcnNpb24gMFxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGZsYWdzXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcHJlX2RlZmluZWRcbiAgICAweDc2LCAweDY5LCAweDY0LCAweDY1LCAvLyBoYW5kbGVyX3R5cGU6ICd2aWRlJ1xuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxuICAgIDB4NTYsIDB4NjksIDB4NjQsIDB4NjUsIDB4NmYsIDB4NDgsIDB4NjEsIDB4NmUsIDB4NjQsIDB4NmMsIDB4NjUsIDB4NzIsIDB4MDAgLy8gbmFtZTogJ1ZpZGVvSGFuZGxlcidcbiAgICBdKTtcbiAgICB2YXIgYXVkaW9IZGxyID0gbmV3IFVpbnQ4QXJyYXkoWzB4MDAsIC8vIHZlcnNpb24gMFxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGZsYWdzXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcHJlX2RlZmluZWRcbiAgICAweDczLCAweDZmLCAweDc1LCAweDZlLCAvLyBoYW5kbGVyX3R5cGU6ICdzb3VuJ1xuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxuICAgIDB4NTMsIDB4NmYsIDB4NzUsIDB4NmUsIDB4NjQsIDB4NDgsIDB4NjEsIDB4NmUsIDB4NjQsIDB4NmMsIDB4NjUsIDB4NzIsIDB4MDAgLy8gbmFtZTogJ1NvdW5kSGFuZGxlcidcbiAgICBdKTtcbiAgICBNUDQuSERMUl9UWVBFUyA9IHtcbiAgICAgIHZpZGVvOiB2aWRlb0hkbHIsXG4gICAgICBhdWRpbzogYXVkaW9IZGxyXG4gICAgfTtcbiAgICB2YXIgZHJlZiA9IG5ldyBVaW50OEFycmF5KFsweDAwLCAvLyB2ZXJzaW9uIDBcbiAgICAweDAwLCAweDAwLCAweDAwLCAvLyBmbGFnc1xuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDEsIC8vIGVudHJ5X2NvdW50XG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwYywgLy8gZW50cnlfc2l6ZVxuICAgIDB4NzUsIDB4NzIsIDB4NmMsIDB4MjAsIC8vICd1cmwnIHR5cGVcbiAgICAweDAwLCAvLyB2ZXJzaW9uIDBcbiAgICAweDAwLCAweDAwLCAweDAxIC8vIGVudHJ5X2ZsYWdzXG4gICAgXSk7XG4gICAgdmFyIHN0Y28gPSBuZXcgVWludDhBcnJheShbMHgwMCwgLy8gdmVyc2lvblxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGZsYWdzXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCAvLyBlbnRyeV9jb3VudFxuICAgIF0pO1xuICAgIE1QNC5TVFRTID0gTVA0LlNUU0MgPSBNUDQuU1RDTyA9IHN0Y287XG4gICAgTVA0LlNUU1ogPSBuZXcgVWludDhBcnJheShbMHgwMCwgLy8gdmVyc2lvblxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGZsYWdzXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gc2FtcGxlX3NpemVcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwIC8vIHNhbXBsZV9jb3VudFxuICAgIF0pO1xuICAgIE1QNC5WTUhEID0gbmV3IFVpbnQ4QXJyYXkoWzB4MDAsIC8vIHZlcnNpb25cbiAgICAweDAwLCAweDAwLCAweDAxLCAvLyBmbGFnc1xuICAgIDB4MDAsIDB4MDAsIC8vIGdyYXBoaWNzbW9kZVxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAgLy8gb3Bjb2xvclxuICAgIF0pO1xuICAgIE1QNC5TTUhEID0gbmV3IFVpbnQ4QXJyYXkoWzB4MDAsIC8vIHZlcnNpb25cbiAgICAweDAwLCAweDAwLCAweDAwLCAvLyBmbGFnc1xuICAgIDB4MDAsIDB4MDAsIC8vIGJhbGFuY2VcbiAgICAweDAwLCAweDAwIC8vIHJlc2VydmVkXG4gICAgXSk7XG4gICAgTVA0LlNUU0QgPSBuZXcgVWludDhBcnJheShbMHgwMCwgLy8gdmVyc2lvbiAwXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gZmxhZ3NcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAxXSk7IC8vIGVudHJ5X2NvdW50XG5cbiAgICB2YXIgbWFqb3JCcmFuZCA9IG5ldyBVaW50OEFycmF5KFsxMDUsIDExNSwgMTExLCAxMDldKTsgLy8gaXNvbVxuXG4gICAgdmFyIGF2YzFCcmFuZCA9IG5ldyBVaW50OEFycmF5KFs5NywgMTE4LCA5OSwgNDldKTsgLy8gYXZjMVxuXG4gICAgdmFyIG1pbm9yVmVyc2lvbiA9IG5ldyBVaW50OEFycmF5KFswLCAwLCAwLCAxXSk7XG4gICAgTVA0LkZUWVAgPSBNUDQuYm94KE1QNC50eXBlcy5mdHlwLCBtYWpvckJyYW5kLCBtaW5vclZlcnNpb24sIG1ham9yQnJhbmQsIGF2YzFCcmFuZCk7XG4gICAgTVA0LkRJTkYgPSBNUDQuYm94KE1QNC50eXBlcy5kaW5mLCBNUDQuYm94KE1QNC50eXBlcy5kcmVmLCBkcmVmKSk7XG4gIH07XG5cbiAgTVA0LmJveCA9IGZ1bmN0aW9uIGJveCh0eXBlKSB7XG4gICAgdmFyIHNpemUgPSA4O1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHBheWxvYWQgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgcGF5bG9hZFtfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgdmFyIGkgPSBwYXlsb2FkLmxlbmd0aDtcbiAgICB2YXIgbGVuID0gaTsgLy8gY2FsY3VsYXRlIHRoZSB0b3RhbCBzaXplIHdlIG5lZWQgdG8gYWxsb2NhdGVcblxuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHNpemUgKz0gcGF5bG9hZFtpXS5ieXRlTGVuZ3RoO1xuICAgIH1cblxuICAgIHZhciByZXN1bHQgPSBuZXcgVWludDhBcnJheShzaXplKTtcbiAgICByZXN1bHRbMF0gPSBzaXplID4+IDI0ICYgMHhmZjtcbiAgICByZXN1bHRbMV0gPSBzaXplID4+IDE2ICYgMHhmZjtcbiAgICByZXN1bHRbMl0gPSBzaXplID4+IDggJiAweGZmO1xuICAgIHJlc3VsdFszXSA9IHNpemUgJiAweGZmO1xuICAgIHJlc3VsdC5zZXQodHlwZSwgNCk7IC8vIGNvcHkgdGhlIHBheWxvYWQgaW50byB0aGUgcmVzdWx0XG5cbiAgICBmb3IgKGkgPSAwLCBzaXplID0gODsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAvLyBjb3B5IHBheWxvYWRbaV0gYXJyYXkgQCBvZmZzZXQgc2l6ZVxuICAgICAgcmVzdWx0LnNldChwYXlsb2FkW2ldLCBzaXplKTtcbiAgICAgIHNpemUgKz0gcGF5bG9hZFtpXS5ieXRlTGVuZ3RoO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgTVA0LmhkbHIgPSBmdW5jdGlvbiBoZGxyKHR5cGUpIHtcbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMuaGRsciwgTVA0LkhETFJfVFlQRVNbdHlwZV0pO1xuICB9O1xuXG4gIE1QNC5tZGF0ID0gZnVuY3Rpb24gbWRhdChkYXRhKSB7XG4gICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLm1kYXQsIGRhdGEpO1xuICB9O1xuXG4gIE1QNC5tZGhkID0gZnVuY3Rpb24gbWRoZCh0aW1lc2NhbGUsIGR1cmF0aW9uKSB7XG4gICAgZHVyYXRpb24gKj0gdGltZXNjYWxlO1xuICAgIHZhciB1cHBlcldvcmREdXJhdGlvbiA9IE1hdGguZmxvb3IoZHVyYXRpb24gLyAoVUlOVDMyX01BWCArIDEpKTtcbiAgICB2YXIgbG93ZXJXb3JkRHVyYXRpb24gPSBNYXRoLmZsb29yKGR1cmF0aW9uICUgKFVJTlQzMl9NQVggKyAxKSk7XG4gICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLm1kaGQsIG5ldyBVaW50OEFycmF5KFsweDAxLCAvLyB2ZXJzaW9uIDFcbiAgICAweDAwLCAweDAwLCAweDAwLCAvLyBmbGFnc1xuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDIsIC8vIGNyZWF0aW9uX3RpbWVcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAzLCAvLyBtb2RpZmljYXRpb25fdGltZVxuICAgIHRpbWVzY2FsZSA+PiAyNCAmIDB4ZmYsIHRpbWVzY2FsZSA+PiAxNiAmIDB4ZmYsIHRpbWVzY2FsZSA+PiA4ICYgMHhmZiwgdGltZXNjYWxlICYgMHhmZiwgLy8gdGltZXNjYWxlXG4gICAgdXBwZXJXb3JkRHVyYXRpb24gPj4gMjQsIHVwcGVyV29yZER1cmF0aW9uID4+IDE2ICYgMHhmZiwgdXBwZXJXb3JkRHVyYXRpb24gPj4gOCAmIDB4ZmYsIHVwcGVyV29yZER1cmF0aW9uICYgMHhmZiwgbG93ZXJXb3JkRHVyYXRpb24gPj4gMjQsIGxvd2VyV29yZER1cmF0aW9uID4+IDE2ICYgMHhmZiwgbG93ZXJXb3JkRHVyYXRpb24gPj4gOCAmIDB4ZmYsIGxvd2VyV29yZER1cmF0aW9uICYgMHhmZiwgMHg1NSwgMHhjNCwgLy8gJ3VuZCcgbGFuZ3VhZ2UgKHVuZGV0ZXJtaW5lZClcbiAgICAweDAwLCAweDAwXSkpO1xuICB9O1xuXG4gIE1QNC5tZGlhID0gZnVuY3Rpb24gbWRpYSh0cmFjaykge1xuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5tZGlhLCBNUDQubWRoZCh0cmFjay50aW1lc2NhbGUsIHRyYWNrLmR1cmF0aW9uKSwgTVA0LmhkbHIodHJhY2sudHlwZSksIE1QNC5taW5mKHRyYWNrKSk7XG4gIH07XG5cbiAgTVA0Lm1maGQgPSBmdW5jdGlvbiBtZmhkKHNlcXVlbmNlTnVtYmVyKSB7XG4gICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLm1maGQsIG5ldyBVaW50OEFycmF5KFsweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyBmbGFnc1xuICAgIHNlcXVlbmNlTnVtYmVyID4+IDI0LCBzZXF1ZW5jZU51bWJlciA+PiAxNiAmIDB4ZmYsIHNlcXVlbmNlTnVtYmVyID4+IDggJiAweGZmLCBzZXF1ZW5jZU51bWJlciAmIDB4ZmYgLy8gc2VxdWVuY2VfbnVtYmVyXG4gICAgXSkpO1xuICB9O1xuXG4gIE1QNC5taW5mID0gZnVuY3Rpb24gbWluZih0cmFjaykge1xuICAgIGlmICh0cmFjay50eXBlID09PSAnYXVkaW8nKSB7XG4gICAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMubWluZiwgTVA0LmJveChNUDQudHlwZXMuc21oZCwgTVA0LlNNSEQpLCBNUDQuRElORiwgTVA0LnN0YmwodHJhY2spKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLm1pbmYsIE1QNC5ib3goTVA0LnR5cGVzLnZtaGQsIE1QNC5WTUhEKSwgTVA0LkRJTkYsIE1QNC5zdGJsKHRyYWNrKSk7XG4gICAgfVxuICB9O1xuXG4gIE1QNC5tb29mID0gZnVuY3Rpb24gbW9vZihzbiwgYmFzZU1lZGlhRGVjb2RlVGltZSwgdHJhY2spIHtcbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMubW9vZiwgTVA0Lm1maGQoc24pLCBNUDQudHJhZih0cmFjaywgYmFzZU1lZGlhRGVjb2RlVGltZSkpO1xuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0gdHJhY2tzLi4uIChvcHRpb25hbCkge2FycmF5fSB0aGUgdHJhY2tzIGFzc29jaWF0ZWQgd2l0aCB0aGlzIG1vdmllXG4gICAqL1xuICA7XG5cbiAgTVA0Lm1vb3YgPSBmdW5jdGlvbiBtb292KHRyYWNrcykge1xuICAgIHZhciBpID0gdHJhY2tzLmxlbmd0aDtcbiAgICB2YXIgYm94ZXMgPSBbXTtcblxuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGJveGVzW2ldID0gTVA0LnRyYWsodHJhY2tzW2ldKTtcbiAgICB9XG5cbiAgICByZXR1cm4gTVA0LmJveC5hcHBseShudWxsLCBbTVA0LnR5cGVzLm1vb3YsIE1QNC5tdmhkKHRyYWNrc1swXS50aW1lc2NhbGUsIHRyYWNrc1swXS5kdXJhdGlvbildLmNvbmNhdChib3hlcykuY29uY2F0KE1QNC5tdmV4KHRyYWNrcykpKTtcbiAgfTtcblxuICBNUDQubXZleCA9IGZ1bmN0aW9uIG12ZXgodHJhY2tzKSB7XG4gICAgdmFyIGkgPSB0cmFja3MubGVuZ3RoO1xuICAgIHZhciBib3hlcyA9IFtdO1xuXG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgYm94ZXNbaV0gPSBNUDQudHJleCh0cmFja3NbaV0pO1xuICAgIH1cblxuICAgIHJldHVybiBNUDQuYm94LmFwcGx5KG51bGwsIFtNUDQudHlwZXMubXZleF0uY29uY2F0KGJveGVzKSk7XG4gIH07XG5cbiAgTVA0Lm12aGQgPSBmdW5jdGlvbiBtdmhkKHRpbWVzY2FsZSwgZHVyYXRpb24pIHtcbiAgICBkdXJhdGlvbiAqPSB0aW1lc2NhbGU7XG4gICAgdmFyIHVwcGVyV29yZER1cmF0aW9uID0gTWF0aC5mbG9vcihkdXJhdGlvbiAvIChVSU5UMzJfTUFYICsgMSkpO1xuICAgIHZhciBsb3dlcldvcmREdXJhdGlvbiA9IE1hdGguZmxvb3IoZHVyYXRpb24gJSAoVUlOVDMyX01BWCArIDEpKTtcbiAgICB2YXIgYnl0ZXMgPSBuZXcgVWludDhBcnJheShbMHgwMSwgLy8gdmVyc2lvbiAxXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gZmxhZ3NcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAyLCAvLyBjcmVhdGlvbl90aW1lXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMywgLy8gbW9kaWZpY2F0aW9uX3RpbWVcbiAgICB0aW1lc2NhbGUgPj4gMjQgJiAweGZmLCB0aW1lc2NhbGUgPj4gMTYgJiAweGZmLCB0aW1lc2NhbGUgPj4gOCAmIDB4ZmYsIHRpbWVzY2FsZSAmIDB4ZmYsIC8vIHRpbWVzY2FsZVxuICAgIHVwcGVyV29yZER1cmF0aW9uID4+IDI0LCB1cHBlcldvcmREdXJhdGlvbiA+PiAxNiAmIDB4ZmYsIHVwcGVyV29yZER1cmF0aW9uID4+IDggJiAweGZmLCB1cHBlcldvcmREdXJhdGlvbiAmIDB4ZmYsIGxvd2VyV29yZER1cmF0aW9uID4+IDI0LCBsb3dlcldvcmREdXJhdGlvbiA+PiAxNiAmIDB4ZmYsIGxvd2VyV29yZER1cmF0aW9uID4+IDggJiAweGZmLCBsb3dlcldvcmREdXJhdGlvbiAmIDB4ZmYsIDB4MDAsIDB4MDEsIDB4MDAsIDB4MDAsIC8vIDEuMCByYXRlXG4gICAgMHgwMSwgMHgwMCwgLy8gMS4wIHZvbHVtZVxuICAgIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxuICAgIDB4MDAsIDB4MDEsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDEsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4NDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHRyYW5zZm9ybWF0aW9uOiB1bml0eSBtYXRyaXhcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyBwcmVfZGVmaW5lZFxuICAgIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYgLy8gbmV4dF90cmFja19JRFxuICAgIF0pO1xuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5tdmhkLCBieXRlcyk7XG4gIH07XG5cbiAgTVA0LnNkdHAgPSBmdW5jdGlvbiBzZHRwKHRyYWNrKSB7XG4gICAgdmFyIHNhbXBsZXMgPSB0cmFjay5zYW1wbGVzIHx8IFtdO1xuICAgIHZhciBieXRlcyA9IG5ldyBVaW50OEFycmF5KDQgKyBzYW1wbGVzLmxlbmd0aCk7XG4gICAgdmFyIGk7XG4gICAgdmFyIGZsYWdzOyAvLyBsZWF2ZSB0aGUgZnVsbCBib3ggaGVhZGVyICg0IGJ5dGVzKSBhbGwgemVyb1xuICAgIC8vIHdyaXRlIHRoZSBzYW1wbGUgdGFibGVcblxuICAgIGZvciAoaSA9IDA7IGkgPCBzYW1wbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBmbGFncyA9IHNhbXBsZXNbaV0uZmxhZ3M7XG4gICAgICBieXRlc1tpICsgNF0gPSBmbGFncy5kZXBlbmRzT24gPDwgNCB8IGZsYWdzLmlzRGVwZW5kZWRPbiA8PCAyIHwgZmxhZ3MuaGFzUmVkdW5kYW5jeTtcbiAgICB9XG5cbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMuc2R0cCwgYnl0ZXMpO1xuICB9O1xuXG4gIE1QNC5zdGJsID0gZnVuY3Rpb24gc3RibCh0cmFjaykge1xuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5zdGJsLCBNUDQuc3RzZCh0cmFjayksIE1QNC5ib3goTVA0LnR5cGVzLnN0dHMsIE1QNC5TVFRTKSwgTVA0LmJveChNUDQudHlwZXMuc3RzYywgTVA0LlNUU0MpLCBNUDQuYm94KE1QNC50eXBlcy5zdHN6LCBNUDQuU1RTWiksIE1QNC5ib3goTVA0LnR5cGVzLnN0Y28sIE1QNC5TVENPKSk7XG4gIH07XG5cbiAgTVA0LmF2YzEgPSBmdW5jdGlvbiBhdmMxKHRyYWNrKSB7XG4gICAgdmFyIHNwcyA9IFtdO1xuICAgIHZhciBwcHMgPSBbXTtcbiAgICB2YXIgaTtcbiAgICB2YXIgZGF0YTtcbiAgICB2YXIgbGVuOyAvLyBhc3NlbWJsZSB0aGUgU1BTc1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHRyYWNrLnNwcy5sZW5ndGg7IGkrKykge1xuICAgICAgZGF0YSA9IHRyYWNrLnNwc1tpXTtcbiAgICAgIGxlbiA9IGRhdGEuYnl0ZUxlbmd0aDtcbiAgICAgIHNwcy5wdXNoKGxlbiA+Pj4gOCAmIDB4ZmYpO1xuICAgICAgc3BzLnB1c2gobGVuICYgMHhmZik7IC8vIFNQU1xuXG4gICAgICBzcHMgPSBzcHMuY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGRhdGEpKTtcbiAgICB9IC8vIGFzc2VtYmxlIHRoZSBQUFNzXG5cblxuICAgIGZvciAoaSA9IDA7IGkgPCB0cmFjay5wcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRhdGEgPSB0cmFjay5wcHNbaV07XG4gICAgICBsZW4gPSBkYXRhLmJ5dGVMZW5ndGg7XG4gICAgICBwcHMucHVzaChsZW4gPj4+IDggJiAweGZmKTtcbiAgICAgIHBwcy5wdXNoKGxlbiAmIDB4ZmYpO1xuICAgICAgcHBzID0gcHBzLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChkYXRhKSk7XG4gICAgfVxuXG4gICAgdmFyIGF2Y2MgPSBNUDQuYm94KE1QNC50eXBlcy5hdmNDLCBuZXcgVWludDhBcnJheShbMHgwMSwgLy8gdmVyc2lvblxuICAgIHNwc1szXSwgLy8gcHJvZmlsZVxuICAgIHNwc1s0XSwgLy8gcHJvZmlsZSBjb21wYXRcbiAgICBzcHNbNV0sIC8vIGxldmVsXG4gICAgMHhmYyB8IDMsIC8vIGxlbmd0aFNpemVNaW51c09uZSwgaGFyZC1jb2RlZCB0byA0IGJ5dGVzXG4gICAgMHhlMCB8IHRyYWNrLnNwcy5sZW5ndGggLy8gM2JpdCByZXNlcnZlZCAoMTExKSArIG51bU9mU2VxdWVuY2VQYXJhbWV0ZXJTZXRzXG4gICAgXS5jb25jYXQoc3BzKS5jb25jYXQoW3RyYWNrLnBwcy5sZW5ndGggLy8gbnVtT2ZQaWN0dXJlUGFyYW1ldGVyU2V0c1xuICAgIF0pLmNvbmNhdChwcHMpKSk7IC8vIFwiUFBTXCJcblxuICAgIHZhciB3aWR0aCA9IHRyYWNrLndpZHRoO1xuICAgIHZhciBoZWlnaHQgPSB0cmFjay5oZWlnaHQ7XG4gICAgdmFyIGhTcGFjaW5nID0gdHJhY2sucGl4ZWxSYXRpb1swXTtcbiAgICB2YXIgdlNwYWNpbmcgPSB0cmFjay5waXhlbFJhdGlvWzFdO1xuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5hdmMxLCBuZXcgVWludDhBcnJheShbMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxuICAgIDB4MDAsIDB4MDEsIC8vIGRhdGFfcmVmZXJlbmNlX2luZGV4XG4gICAgMHgwMCwgMHgwMCwgLy8gcHJlX2RlZmluZWRcbiAgICAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHByZV9kZWZpbmVkXG4gICAgd2lkdGggPj4gOCAmIDB4ZmYsIHdpZHRoICYgMHhmZiwgLy8gd2lkdGhcbiAgICBoZWlnaHQgPj4gOCAmIDB4ZmYsIGhlaWdodCAmIDB4ZmYsIC8vIGhlaWdodFxuICAgIDB4MDAsIDB4NDgsIDB4MDAsIDB4MDAsIC8vIGhvcml6cmVzb2x1dGlvblxuICAgIDB4MDAsIDB4NDgsIDB4MDAsIDB4MDAsIC8vIHZlcnRyZXNvbHV0aW9uXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAweDAwLCAweDAxLCAvLyBmcmFtZV9jb3VudFxuICAgIDB4MTIsIDB4NjQsIDB4NjEsIDB4NjksIDB4NmMsIC8vIGRhaWx5bW90aW9uL2hscy5qc1xuICAgIDB4NzksIDB4NmQsIDB4NmYsIDB4NzQsIDB4NjksIDB4NmYsIDB4NmUsIDB4MmYsIDB4NjgsIDB4NmMsIDB4NzMsIDB4MmUsIDB4NmEsIDB4NzMsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGNvbXByZXNzb3JuYW1lXG4gICAgMHgwMCwgMHgxOCwgLy8gZGVwdGggPSAyNFxuICAgIDB4MTEsIDB4MTFdKSwgLy8gcHJlX2RlZmluZWQgPSAtMVxuICAgIGF2Y2MsIE1QNC5ib3goTVA0LnR5cGVzLmJ0cnQsIG5ldyBVaW50OEFycmF5KFsweDAwLCAweDFjLCAweDljLCAweDgwLCAvLyBidWZmZXJTaXplREJcbiAgICAweDAwLCAweDJkLCAweGM2LCAweGMwLCAvLyBtYXhCaXRyYXRlXG4gICAgMHgwMCwgMHgyZCwgMHhjNiwgMHhjMF0pKSwgLy8gYXZnQml0cmF0ZVxuICAgIE1QNC5ib3goTVA0LnR5cGVzLnBhc3AsIG5ldyBVaW50OEFycmF5KFtoU3BhY2luZyA+PiAyNCwgLy8gaFNwYWNpbmdcbiAgICBoU3BhY2luZyA+PiAxNiAmIDB4ZmYsIGhTcGFjaW5nID4+IDggJiAweGZmLCBoU3BhY2luZyAmIDB4ZmYsIHZTcGFjaW5nID4+IDI0LCAvLyB2U3BhY2luZ1xuICAgIHZTcGFjaW5nID4+IDE2ICYgMHhmZiwgdlNwYWNpbmcgPj4gOCAmIDB4ZmYsIHZTcGFjaW5nICYgMHhmZl0pKSk7XG4gIH07XG5cbiAgTVA0LmVzZHMgPSBmdW5jdGlvbiBlc2RzKHRyYWNrKSB7XG4gICAgdmFyIGNvbmZpZ2xlbiA9IHRyYWNrLmNvbmZpZy5sZW5ndGg7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFsweDAwLCAvLyB2ZXJzaW9uIDBcbiAgICAweDAwLCAweDAwLCAweDAwLCAvLyBmbGFnc1xuICAgIDB4MDMsIC8vIGRlc2NyaXB0b3JfdHlwZVxuICAgIDB4MTcgKyBjb25maWdsZW4sIC8vIGxlbmd0aFxuICAgIDB4MDAsIDB4MDEsIC8vIGVzX2lkXG4gICAgMHgwMCwgLy8gc3RyZWFtX3ByaW9yaXR5XG4gICAgMHgwNCwgLy8gZGVzY3JpcHRvcl90eXBlXG4gICAgMHgwZiArIGNvbmZpZ2xlbiwgLy8gbGVuZ3RoXG4gICAgMHg0MCwgLy8gY29kZWMgOiBtcGVnNF9hdWRpb1xuICAgIDB4MTUsIC8vIHN0cmVhbV90eXBlXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gYnVmZmVyX3NpemVcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyBtYXhCaXRyYXRlXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gYXZnQml0cmF0ZVxuICAgIDB4MDUgLy8gZGVzY3JpcHRvcl90eXBlXG4gICAgXS5jb25jYXQoW2NvbmZpZ2xlbl0pLmNvbmNhdCh0cmFjay5jb25maWcpLmNvbmNhdChbMHgwNiwgMHgwMSwgMHgwMl0pKTsgLy8gR0FTcGVjaWZpY0NvbmZpZykpOyAvLyBsZW5ndGggKyBhdWRpbyBjb25maWcgZGVzY3JpcHRvclxuICB9O1xuXG4gIE1QNC5tcDRhID0gZnVuY3Rpb24gbXA0YSh0cmFjaykge1xuICAgIHZhciBzYW1wbGVyYXRlID0gdHJhY2suc2FtcGxlcmF0ZTtcbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMubXA0YSwgbmV3IFVpbnQ4QXJyYXkoWzB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAweDAwLCAweDAxLCAvLyBkYXRhX3JlZmVyZW5jZV9pbmRleFxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgMHgwMCwgdHJhY2suY2hhbm5lbENvdW50LCAvLyBjaGFubmVsY291bnRcbiAgICAweDAwLCAweDEwLCAvLyBzYW1wbGVTaXplOjE2Yml0c1xuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkMlxuICAgIHNhbXBsZXJhdGUgPj4gOCAmIDB4ZmYsIHNhbXBsZXJhdGUgJiAweGZmLCAvL1xuICAgIDB4MDAsIDB4MDBdKSwgTVA0LmJveChNUDQudHlwZXMuZXNkcywgTVA0LmVzZHModHJhY2spKSk7XG4gIH07XG5cbiAgTVA0Lm1wMyA9IGZ1bmN0aW9uIG1wMyh0cmFjaykge1xuICAgIHZhciBzYW1wbGVyYXRlID0gdHJhY2suc2FtcGxlcmF0ZTtcbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXNbJy5tcDMnXSwgbmV3IFVpbnQ4QXJyYXkoWzB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAweDAwLCAweDAxLCAvLyBkYXRhX3JlZmVyZW5jZV9pbmRleFxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgMHgwMCwgdHJhY2suY2hhbm5lbENvdW50LCAvLyBjaGFubmVsY291bnRcbiAgICAweDAwLCAweDEwLCAvLyBzYW1wbGVTaXplOjE2Yml0c1xuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkMlxuICAgIHNhbXBsZXJhdGUgPj4gOCAmIDB4ZmYsIHNhbXBsZXJhdGUgJiAweGZmLCAvL1xuICAgIDB4MDAsIDB4MDBdKSk7XG4gIH07XG5cbiAgTVA0LnN0c2QgPSBmdW5jdGlvbiBzdHNkKHRyYWNrKSB7XG4gICAgaWYgKHRyYWNrLnR5cGUgPT09ICdhdWRpbycpIHtcbiAgICAgIGlmICghdHJhY2suaXNBQUMgJiYgdHJhY2suY29kZWMgPT09ICdtcDMnKSB7XG4gICAgICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5zdHNkLCBNUDQuU1RTRCwgTVA0Lm1wMyh0cmFjaykpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMuc3RzZCwgTVA0LlNUU0QsIE1QNC5tcDRhKHRyYWNrKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5zdHNkLCBNUDQuU1RTRCwgTVA0LmF2YzEodHJhY2spKTtcbiAgICB9XG4gIH07XG5cbiAgTVA0LnRraGQgPSBmdW5jdGlvbiB0a2hkKHRyYWNrKSB7XG4gICAgdmFyIGlkID0gdHJhY2suaWQ7XG4gICAgdmFyIGR1cmF0aW9uID0gdHJhY2suZHVyYXRpb24gKiB0cmFjay50aW1lc2NhbGU7XG4gICAgdmFyIHdpZHRoID0gdHJhY2sud2lkdGg7XG4gICAgdmFyIGhlaWdodCA9IHRyYWNrLmhlaWdodDtcbiAgICB2YXIgdXBwZXJXb3JkRHVyYXRpb24gPSBNYXRoLmZsb29yKGR1cmF0aW9uIC8gKFVJTlQzMl9NQVggKyAxKSk7XG4gICAgdmFyIGxvd2VyV29yZER1cmF0aW9uID0gTWF0aC5mbG9vcihkdXJhdGlvbiAlIChVSU5UMzJfTUFYICsgMSkpO1xuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy50a2hkLCBuZXcgVWludDhBcnJheShbMHgwMSwgLy8gdmVyc2lvbiAxXG4gICAgMHgwMCwgMHgwMCwgMHgwNywgLy8gZmxhZ3NcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAyLCAvLyBjcmVhdGlvbl90aW1lXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMywgLy8gbW9kaWZpY2F0aW9uX3RpbWVcbiAgICBpZCA+PiAyNCAmIDB4ZmYsIGlkID4+IDE2ICYgMHhmZiwgaWQgPj4gOCAmIDB4ZmYsIGlkICYgMHhmZiwgLy8gdHJhY2tfSURcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxuICAgIHVwcGVyV29yZER1cmF0aW9uID4+IDI0LCB1cHBlcldvcmREdXJhdGlvbiA+PiAxNiAmIDB4ZmYsIHVwcGVyV29yZER1cmF0aW9uID4+IDggJiAweGZmLCB1cHBlcldvcmREdXJhdGlvbiAmIDB4ZmYsIGxvd2VyV29yZER1cmF0aW9uID4+IDI0LCBsb3dlcldvcmREdXJhdGlvbiA+PiAxNiAmIDB4ZmYsIGxvd2VyV29yZER1cmF0aW9uID4+IDggJiAweGZmLCBsb3dlcldvcmREdXJhdGlvbiAmIDB4ZmYsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgMHgwMCwgMHgwMCwgLy8gbGF5ZXJcbiAgICAweDAwLCAweDAwLCAvLyBhbHRlcm5hdGVfZ3JvdXBcbiAgICAweDAwLCAweDAwLCAvLyBub24tYXVkaW8gdHJhY2sgdm9sdW1lXG4gICAgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAweDAwLCAweDAxLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAxLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDQwLCAweDAwLCAweDAwLCAweDAwLCAvLyB0cmFuc2Zvcm1hdGlvbjogdW5pdHkgbWF0cml4XG4gICAgd2lkdGggPj4gOCAmIDB4ZmYsIHdpZHRoICYgMHhmZiwgMHgwMCwgMHgwMCwgLy8gd2lkdGhcbiAgICBoZWlnaHQgPj4gOCAmIDB4ZmYsIGhlaWdodCAmIDB4ZmYsIDB4MDAsIDB4MDAgLy8gaGVpZ2h0XG4gICAgXSkpO1xuICB9O1xuXG4gIE1QNC50cmFmID0gZnVuY3Rpb24gdHJhZih0cmFjaywgYmFzZU1lZGlhRGVjb2RlVGltZSkge1xuICAgIHZhciBzYW1wbGVEZXBlbmRlbmN5VGFibGUgPSBNUDQuc2R0cCh0cmFjayk7XG4gICAgdmFyIGlkID0gdHJhY2suaWQ7XG4gICAgdmFyIHVwcGVyV29yZEJhc2VNZWRpYURlY29kZVRpbWUgPSBNYXRoLmZsb29yKGJhc2VNZWRpYURlY29kZVRpbWUgLyAoVUlOVDMyX01BWCArIDEpKTtcbiAgICB2YXIgbG93ZXJXb3JkQmFzZU1lZGlhRGVjb2RlVGltZSA9IE1hdGguZmxvb3IoYmFzZU1lZGlhRGVjb2RlVGltZSAlIChVSU5UMzJfTUFYICsgMSkpO1xuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy50cmFmLCBNUDQuYm94KE1QNC50eXBlcy50ZmhkLCBuZXcgVWludDhBcnJheShbMHgwMCwgLy8gdmVyc2lvbiAwXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gZmxhZ3NcbiAgICBpZCA+PiAyNCwgaWQgPj4gMTYgJiAweGZmLCBpZCA+PiA4ICYgMHhmZiwgaWQgJiAweGZmIC8vIHRyYWNrX0lEXG4gICAgXSkpLCBNUDQuYm94KE1QNC50eXBlcy50ZmR0LCBuZXcgVWludDhBcnJheShbMHgwMSwgLy8gdmVyc2lvbiAxXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gZmxhZ3NcbiAgICB1cHBlcldvcmRCYXNlTWVkaWFEZWNvZGVUaW1lID4+IDI0LCB1cHBlcldvcmRCYXNlTWVkaWFEZWNvZGVUaW1lID4+IDE2ICYgMHhmZiwgdXBwZXJXb3JkQmFzZU1lZGlhRGVjb2RlVGltZSA+PiA4ICYgMHhmZiwgdXBwZXJXb3JkQmFzZU1lZGlhRGVjb2RlVGltZSAmIDB4ZmYsIGxvd2VyV29yZEJhc2VNZWRpYURlY29kZVRpbWUgPj4gMjQsIGxvd2VyV29yZEJhc2VNZWRpYURlY29kZVRpbWUgPj4gMTYgJiAweGZmLCBsb3dlcldvcmRCYXNlTWVkaWFEZWNvZGVUaW1lID4+IDggJiAweGZmLCBsb3dlcldvcmRCYXNlTWVkaWFEZWNvZGVUaW1lICYgMHhmZl0pKSwgTVA0LnRydW4odHJhY2ssIHNhbXBsZURlcGVuZGVuY3lUYWJsZS5sZW5ndGggKyAxNiArIC8vIHRmaGRcbiAgICAyMCArIC8vIHRmZHRcbiAgICA4ICsgLy8gdHJhZiBoZWFkZXJcbiAgICAxNiArIC8vIG1maGRcbiAgICA4ICsgLy8gbW9vZiBoZWFkZXJcbiAgICA4KSwgLy8gbWRhdCBoZWFkZXJcbiAgICBzYW1wbGVEZXBlbmRlbmN5VGFibGUpO1xuICB9XG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIHRyYWNrIGJveC5cbiAgICogQHBhcmFtIHRyYWNrIHtvYmplY3R9IGEgdHJhY2sgZGVmaW5pdGlvblxuICAgKiBAcmV0dXJuIHtVaW50OEFycmF5fSB0aGUgdHJhY2sgYm94XG4gICAqL1xuICA7XG5cbiAgTVA0LnRyYWsgPSBmdW5jdGlvbiB0cmFrKHRyYWNrKSB7XG4gICAgdHJhY2suZHVyYXRpb24gPSB0cmFjay5kdXJhdGlvbiB8fCAweGZmZmZmZmZmO1xuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy50cmFrLCBNUDQudGtoZCh0cmFjayksIE1QNC5tZGlhKHRyYWNrKSk7XG4gIH07XG5cbiAgTVA0LnRyZXggPSBmdW5jdGlvbiB0cmV4KHRyYWNrKSB7XG4gICAgdmFyIGlkID0gdHJhY2suaWQ7XG4gICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLnRyZXgsIG5ldyBVaW50OEFycmF5KFsweDAwLCAvLyB2ZXJzaW9uIDBcbiAgICAweDAwLCAweDAwLCAweDAwLCAvLyBmbGFnc1xuICAgIGlkID4+IDI0LCBpZCA+PiAxNiAmIDB4ZmYsIGlkID4+IDggJiAweGZmLCBpZCAmIDB4ZmYsIC8vIHRyYWNrX0lEXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMSwgLy8gZGVmYXVsdF9zYW1wbGVfZGVzY3JpcHRpb25faW5kZXhcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyBkZWZhdWx0X3NhbXBsZV9kdXJhdGlvblxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGRlZmF1bHRfc2FtcGxlX3NpemVcbiAgICAweDAwLCAweDAxLCAweDAwLCAweDAxIC8vIGRlZmF1bHRfc2FtcGxlX2ZsYWdzXG4gICAgXSkpO1xuICB9O1xuXG4gIE1QNC50cnVuID0gZnVuY3Rpb24gdHJ1bih0cmFjaywgb2Zmc2V0KSB7XG4gICAgdmFyIHNhbXBsZXMgPSB0cmFjay5zYW1wbGVzIHx8IFtdO1xuICAgIHZhciBsZW4gPSBzYW1wbGVzLmxlbmd0aDtcbiAgICB2YXIgYXJyYXlsZW4gPSAxMiArIDE2ICogbGVuO1xuICAgIHZhciBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5bGVuKTtcbiAgICB2YXIgaTtcbiAgICB2YXIgc2FtcGxlO1xuICAgIHZhciBkdXJhdGlvbjtcbiAgICB2YXIgc2l6ZTtcbiAgICB2YXIgZmxhZ3M7XG4gICAgdmFyIGN0cztcbiAgICBvZmZzZXQgKz0gOCArIGFycmF5bGVuO1xuICAgIGFycmF5LnNldChbMHgwMCwgLy8gdmVyc2lvbiAwXG4gICAgMHgwMCwgMHgwZiwgMHgwMSwgLy8gZmxhZ3NcbiAgICBsZW4gPj4+IDI0ICYgMHhmZiwgbGVuID4+PiAxNiAmIDB4ZmYsIGxlbiA+Pj4gOCAmIDB4ZmYsIGxlbiAmIDB4ZmYsIC8vIHNhbXBsZV9jb3VudFxuICAgIG9mZnNldCA+Pj4gMjQgJiAweGZmLCBvZmZzZXQgPj4+IDE2ICYgMHhmZiwgb2Zmc2V0ID4+PiA4ICYgMHhmZiwgb2Zmc2V0ICYgMHhmZiAvLyBkYXRhX29mZnNldFxuICAgIF0sIDApO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBzYW1wbGUgPSBzYW1wbGVzW2ldO1xuICAgICAgZHVyYXRpb24gPSBzYW1wbGUuZHVyYXRpb247XG4gICAgICBzaXplID0gc2FtcGxlLnNpemU7XG4gICAgICBmbGFncyA9IHNhbXBsZS5mbGFncztcbiAgICAgIGN0cyA9IHNhbXBsZS5jdHM7XG4gICAgICBhcnJheS5zZXQoW2R1cmF0aW9uID4+PiAyNCAmIDB4ZmYsIGR1cmF0aW9uID4+PiAxNiAmIDB4ZmYsIGR1cmF0aW9uID4+PiA4ICYgMHhmZiwgZHVyYXRpb24gJiAweGZmLCAvLyBzYW1wbGVfZHVyYXRpb25cbiAgICAgIHNpemUgPj4+IDI0ICYgMHhmZiwgc2l6ZSA+Pj4gMTYgJiAweGZmLCBzaXplID4+PiA4ICYgMHhmZiwgc2l6ZSAmIDB4ZmYsIC8vIHNhbXBsZV9zaXplXG4gICAgICBmbGFncy5pc0xlYWRpbmcgPDwgMiB8IGZsYWdzLmRlcGVuZHNPbiwgZmxhZ3MuaXNEZXBlbmRlZE9uIDw8IDYgfCBmbGFncy5oYXNSZWR1bmRhbmN5IDw8IDQgfCBmbGFncy5wYWRkaW5nVmFsdWUgPDwgMSB8IGZsYWdzLmlzTm9uU3luYywgZmxhZ3MuZGVncmFkUHJpbyAmIDB4ZjAgPDwgOCwgZmxhZ3MuZGVncmFkUHJpbyAmIDB4MGYsIC8vIHNhbXBsZV9mbGFnc1xuICAgICAgY3RzID4+PiAyNCAmIDB4ZmYsIGN0cyA+Pj4gMTYgJiAweGZmLCBjdHMgPj4+IDggJiAweGZmLCBjdHMgJiAweGZmIC8vIHNhbXBsZV9jb21wb3NpdGlvbl90aW1lX29mZnNldFxuICAgICAgXSwgMTIgKyAxNiAqIGkpO1xuICAgIH1cblxuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy50cnVuLCBhcnJheSk7XG4gIH07XG5cbiAgTVA0LmluaXRTZWdtZW50ID0gZnVuY3Rpb24gaW5pdFNlZ21lbnQodHJhY2tzKSB7XG4gICAgaWYgKCFNUDQudHlwZXMpIHtcbiAgICAgIE1QNC5pbml0KCk7XG4gICAgfVxuXG4gICAgdmFyIG1vdmllID0gTVA0Lm1vb3YodHJhY2tzKTtcbiAgICB2YXIgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkoTVA0LkZUWVAuYnl0ZUxlbmd0aCArIG1vdmllLmJ5dGVMZW5ndGgpO1xuICAgIHJlc3VsdC5zZXQoTVA0LkZUWVApO1xuICAgIHJlc3VsdC5zZXQobW92aWUsIE1QNC5GVFlQLmJ5dGVMZW5ndGgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgcmV0dXJuIE1QNDtcbn0oKTtcblxuTVA0LnR5cGVzID0gdm9pZCAwO1xuTVA0LkhETFJfVFlQRVMgPSB2b2lkIDA7XG5NUDQuU1RUUyA9IHZvaWQgMDtcbk1QNC5TVFNDID0gdm9pZCAwO1xuTVA0LlNUQ08gPSB2b2lkIDA7XG5NUDQuU1RTWiA9IHZvaWQgMDtcbk1QNC5WTUhEID0gdm9pZCAwO1xuTVA0LlNNSEQgPSB2b2lkIDA7XG5NUDQuU1RTRCA9IHZvaWQgMDtcbk1QNC5GVFlQID0gdm9pZCAwO1xuTVA0LkRJTkYgPSB2b2lkIDA7XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKE1QNCk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3JlbXV4L21wNC1yZW11eGVyLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3JlbXV4L21wNC1yZW11eGVyLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQsIG5vcm1hbGl6ZVB0cyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJkZWZhdWx0XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gTVA0UmVtdXhlcjsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwibm9ybWFsaXplUHRzXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gbm9ybWFsaXplUHRzOyB9KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfaG9tZV9ydW5uZXJfd29ya19obHNfanNfaGxzX2pzX3NyY19wb2x5ZmlsbHNfbnVtYmVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3NyYy9wb2x5ZmlsbHMvbnVtYmVyICovIFwiLi9zcmMvcG9seWZpbGxzL251bWJlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfYWFjX2hlbHBlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9hYWMtaGVscGVyICovIFwiLi9zcmMvcmVtdXgvYWFjLWhlbHBlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbXA0X2dlbmVyYXRvcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9tcDQtZ2VuZXJhdG9yICovIFwiLi9zcmMvcmVtdXgvbXA0LWdlbmVyYXRvci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9ldmVudHMgKi8gXCIuL3NyYy9ldmVudHMudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZXJyb3JzICovIFwiLi9zcmMvZXJyb3JzLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL2xvZ2dlciAqLyBcIi4vc3JjL3V0aWxzL2xvZ2dlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdHlwZXNfbG9hZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi90eXBlcy9sb2FkZXIgKi8gXCIuL3NyYy90eXBlcy9sb2FkZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX3RpbWVzY2FsZV9jb252ZXJzaW9uX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy90aW1lc2NhbGUtY29udmVyc2lvbiAqLyBcIi4vc3JjL3V0aWxzL3RpbWVzY2FsZS1jb252ZXJzaW9uLnRzXCIpO1xuXG5cbmZ1bmN0aW9uIF9leHRlbmRzKCkgeyBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07IHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9XG5cblxuXG5cblxuXG5cblxudmFyIE1BWF9TSUxFTlRfRlJBTUVfRFVSQVRJT04gPSAxMCAqIDEwMDA7IC8vIDEwIHNlY29uZHNcblxudmFyIEFBQ19TQU1QTEVTX1BFUl9GUkFNRSA9IDEwMjQ7XG52YXIgTVBFR19BVURJT19TQU1QTEVfUEVSX0ZSQU1FID0gMTE1MjtcbnZhciBjaHJvbWVWZXJzaW9uID0gbnVsbDtcbnZhciBzYWZhcmlXZWJraXRWZXJzaW9uID0gbnVsbDtcbnZhciByZXF1aXJlc1Bvc2l0aXZlRHRzID0gZmFsc2U7XG5cbnZhciBNUDRSZW11eGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gTVA0UmVtdXhlcihvYnNlcnZlciwgY29uZmlnLCB0eXBlU3VwcG9ydGVkLCB2ZW5kb3IpIHtcbiAgICBpZiAodmVuZG9yID09PSB2b2lkIDApIHtcbiAgICAgIHZlbmRvciA9ICcnO1xuICAgIH1cblxuICAgIHRoaXMub2JzZXJ2ZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5jb25maWcgPSB2b2lkIDA7XG4gICAgdGhpcy50eXBlU3VwcG9ydGVkID0gdm9pZCAwO1xuICAgIHRoaXMuSVNHZW5lcmF0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9pbml0UFRTID0gdm9pZCAwO1xuICAgIHRoaXMuX2luaXREVFMgPSB2b2lkIDA7XG4gICAgdGhpcy5uZXh0QXZjRHRzID0gbnVsbDtcbiAgICB0aGlzLm5leHRBdWRpb1B0cyA9IG51bGw7XG4gICAgdGhpcy5pc0F1ZGlvQ29udGlndW91cyA9IGZhbHNlO1xuICAgIHRoaXMuaXNWaWRlb0NvbnRpZ3VvdXMgPSBmYWxzZTtcbiAgICB0aGlzLm9ic2VydmVyID0gb2JzZXJ2ZXI7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgdGhpcy50eXBlU3VwcG9ydGVkID0gdHlwZVN1cHBvcnRlZDtcbiAgICB0aGlzLklTR2VuZXJhdGVkID0gZmFsc2U7XG5cbiAgICBpZiAoY2hyb21lVmVyc2lvbiA9PT0gbnVsbCkge1xuICAgICAgdmFyIHVzZXJBZ2VudCA9IG5hdmlnYXRvci51c2VyQWdlbnQgfHwgJyc7XG4gICAgICB2YXIgcmVzdWx0ID0gdXNlckFnZW50Lm1hdGNoKC9DaHJvbWVcXC8oXFxkKykvaSk7XG4gICAgICBjaHJvbWVWZXJzaW9uID0gcmVzdWx0ID8gcGFyc2VJbnQocmVzdWx0WzFdKSA6IDA7XG4gICAgfVxuXG4gICAgaWYgKHNhZmFyaVdlYmtpdFZlcnNpb24gPT09IG51bGwpIHtcbiAgICAgIHZhciBfcmVzdWx0ID0gbmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvU2FmYXJpXFwvKFxcZCspL2kpO1xuXG4gICAgICBzYWZhcmlXZWJraXRWZXJzaW9uID0gX3Jlc3VsdCA/IHBhcnNlSW50KF9yZXN1bHRbMV0pIDogMDtcbiAgICB9XG5cbiAgICByZXF1aXJlc1Bvc2l0aXZlRHRzID0gISFjaHJvbWVWZXJzaW9uICYmIGNocm9tZVZlcnNpb24gPCA3NSB8fCAhIXNhZmFyaVdlYmtpdFZlcnNpb24gJiYgc2FmYXJpV2Via2l0VmVyc2lvbiA8IDYwMDtcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBNUDRSZW11eGVyLnByb3RvdHlwZTtcblxuICBfcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7fTtcblxuICBfcHJvdG8ucmVzZXRUaW1lU3RhbXAgPSBmdW5jdGlvbiByZXNldFRpbWVTdGFtcChkZWZhdWx0VGltZVN0YW1wKSB7XG4gICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1wibG9nZ2VyXCJdLmxvZygnW21wNC1yZW11eGVyXTogaW5pdFBUUyAmIGluaXREVFMgcmVzZXQnKTtcbiAgICB0aGlzLl9pbml0UFRTID0gdGhpcy5faW5pdERUUyA9IGRlZmF1bHRUaW1lU3RhbXA7XG4gIH07XG5cbiAgX3Byb3RvLnJlc2V0TmV4dFRpbWVzdGFtcCA9IGZ1bmN0aW9uIHJlc2V0TmV4dFRpbWVzdGFtcCgpIHtcbiAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXCJsb2dnZXJcIl0ubG9nKCdbbXA0LXJlbXV4ZXJdOiByZXNldCBuZXh0IHRpbWVzdGFtcCcpO1xuICAgIHRoaXMuaXNWaWRlb0NvbnRpZ3VvdXMgPSBmYWxzZTtcbiAgICB0aGlzLmlzQXVkaW9Db250aWd1b3VzID0gZmFsc2U7XG4gIH07XG5cbiAgX3Byb3RvLnJlc2V0SW5pdFNlZ21lbnQgPSBmdW5jdGlvbiByZXNldEluaXRTZWdtZW50KCkge1xuICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcImxvZ2dlclwiXS5sb2coJ1ttcDQtcmVtdXhlcl06IElTR2VuZXJhdGVkIGZsYWcgcmVzZXQnKTtcbiAgICB0aGlzLklTR2VuZXJhdGVkID0gZmFsc2U7XG4gIH07XG5cbiAgX3Byb3RvLmdldFZpZGVvU3RhcnRQdHMgPSBmdW5jdGlvbiBnZXRWaWRlb1N0YXJ0UHRzKHZpZGVvU2FtcGxlcykge1xuICAgIHZhciByb2xsb3ZlckRldGVjdGVkID0gZmFsc2U7XG4gICAgdmFyIHN0YXJ0UFRTID0gdmlkZW9TYW1wbGVzLnJlZHVjZShmdW5jdGlvbiAobWluUFRTLCBzYW1wbGUpIHtcbiAgICAgIHZhciBkZWx0YSA9IHNhbXBsZS5wdHMgLSBtaW5QVFM7XG5cbiAgICAgIGlmIChkZWx0YSA8IC00Mjk0OTY3Mjk2KSB7XG4gICAgICAgIC8vIDJeMzIsIHNlZSBQVFNOb3JtYWxpemUgZm9yIHJlYXNvbmluZywgYnV0IHdlJ3JlIGhpdHRpbmcgYSByb2xsb3ZlciBoZXJlLCBhbmQgd2UgZG9uJ3Qgd2FudCB0aGF0IHRvIGltcGFjdCB0aGUgdGltZU9mZnNldCBjYWxjdWxhdGlvblxuICAgICAgICByb2xsb3ZlckRldGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZVB0cyhtaW5QVFMsIHNhbXBsZS5wdHMpO1xuICAgICAgfSBlbHNlIGlmIChkZWx0YSA+IDApIHtcbiAgICAgICAgcmV0dXJuIG1pblBUUztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBzYW1wbGUucHRzO1xuICAgICAgfVxuICAgIH0sIHZpZGVvU2FtcGxlc1swXS5wdHMpO1xuXG4gICAgaWYgKHJvbGxvdmVyRGV0ZWN0ZWQpIHtcbiAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcImxvZ2dlclwiXS5kZWJ1ZygnUFRTIHJvbGxvdmVyIGRldGVjdGVkJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0YXJ0UFRTO1xuICB9O1xuXG4gIF9wcm90by5yZW11eCA9IGZ1bmN0aW9uIHJlbXV4KGF1ZGlvVHJhY2ssIHZpZGVvVHJhY2ssIGlkM1RyYWNrLCB0ZXh0VHJhY2ssIHRpbWVPZmZzZXQsIGFjY3VyYXRlVGltZU9mZnNldCwgZmx1c2gsIHBsYXlsaXN0VHlwZSkge1xuICAgIHZhciB2aWRlbztcbiAgICB2YXIgYXVkaW87XG4gICAgdmFyIGluaXRTZWdtZW50O1xuICAgIHZhciB0ZXh0O1xuICAgIHZhciBpZDM7XG4gICAgdmFyIGluZGVwZW5kZW50O1xuICAgIHZhciBhdWRpb1RpbWVPZmZzZXQgPSB0aW1lT2Zmc2V0O1xuICAgIHZhciB2aWRlb1RpbWVPZmZzZXQgPSB0aW1lT2Zmc2V0OyAvLyBJZiB3ZSdyZSByZW11eGluZyBhdWRpbyBhbmQgdmlkZW8gcHJvZ3Jlc3NpdmVseSwgd2FpdCB1bnRpbCB3ZSd2ZSByZWNlaXZlZCBlbm91Z2ggc2FtcGxlcyBmb3IgZWFjaCB0cmFjayBiZWZvcmUgcHJvY2VlZGluZy5cbiAgICAvLyBUaGlzIGlzIGRvbmUgdG8gc3luY2hyb25pemUgdGhlIGF1ZGlvIGFuZCB2aWRlbyBzdHJlYW1zLiBXZSBrbm93IGlmIHRoZSBjdXJyZW50IHNlZ21lbnQgd2lsbCBoYXZlIHNhbXBsZXMgaWYgdGhlIFwicGlkXCJcbiAgICAvLyBwYXJhbWV0ZXIgaXMgZ3JlYXRlciB0aGFuIC0xLiBUaGUgcGlkIGlzIHNldCB3aGVuIHRoZSBQTVQgaXMgcGFyc2VkLCB3aGljaCBjb250YWlucyB0aGUgdHJhY2tzIGxpc3QuXG4gICAgLy8gSG93ZXZlciwgaWYgdGhlIGluaXRTZWdtZW50IGhhcyBhbHJlYWR5IGJlZW4gZ2VuZXJhdGVkLCBvciB3ZSd2ZSByZWFjaGVkIHRoZSBlbmQgb2YgYSBzZWdtZW50IChmbHVzaCksXG4gICAgLy8gdGhlbiB3ZSBjYW4gcmVtdXggb25lIHRyYWNrIHdpdGhvdXQgd2FpdGluZyBmb3IgdGhlIG90aGVyLlxuXG4gICAgdmFyIGhhc0F1ZGlvID0gYXVkaW9UcmFjay5waWQgPiAtMTtcbiAgICB2YXIgaGFzVmlkZW8gPSB2aWRlb1RyYWNrLnBpZCA+IC0xO1xuICAgIHZhciBsZW5ndGggPSB2aWRlb1RyYWNrLnNhbXBsZXMubGVuZ3RoO1xuICAgIHZhciBlbm91Z2hBdWRpb1NhbXBsZXMgPSBhdWRpb1RyYWNrLnNhbXBsZXMubGVuZ3RoID4gMDtcbiAgICB2YXIgZW5vdWdoVmlkZW9TYW1wbGVzID0gbGVuZ3RoID4gMTtcbiAgICB2YXIgY2FuUmVtdXhBdmMgPSAoIWhhc0F1ZGlvIHx8IGVub3VnaEF1ZGlvU2FtcGxlcykgJiYgKCFoYXNWaWRlbyB8fCBlbm91Z2hWaWRlb1NhbXBsZXMpIHx8IHRoaXMuSVNHZW5lcmF0ZWQgfHwgZmx1c2g7XG5cbiAgICBpZiAoY2FuUmVtdXhBdmMpIHtcbiAgICAgIGlmICghdGhpcy5JU0dlbmVyYXRlZCkge1xuICAgICAgICBpbml0U2VnbWVudCA9IHRoaXMuZ2VuZXJhdGVJUyhhdWRpb1RyYWNrLCB2aWRlb1RyYWNrLCB0aW1lT2Zmc2V0KTtcbiAgICAgIH1cblxuICAgICAgdmFyIGlzVmlkZW9Db250aWd1b3VzID0gdGhpcy5pc1ZpZGVvQ29udGlndW91cztcbiAgICAgIHZhciBmaXJzdEtleUZyYW1lSW5kZXggPSAtMTtcblxuICAgICAgaWYgKGVub3VnaFZpZGVvU2FtcGxlcykge1xuICAgICAgICBmaXJzdEtleUZyYW1lSW5kZXggPSBmaW5kS2V5ZnJhbWVJbmRleCh2aWRlb1RyYWNrLnNhbXBsZXMpO1xuXG4gICAgICAgIGlmICghaXNWaWRlb0NvbnRpZ3VvdXMgJiYgdGhpcy5jb25maWcuZm9yY2VLZXlGcmFtZU9uRGlzY29udGludWl0eSkge1xuICAgICAgICAgIGluZGVwZW5kZW50ID0gdHJ1ZTtcblxuICAgICAgICAgIGlmIChmaXJzdEtleUZyYW1lSW5kZXggPiAwKSB7XG4gICAgICAgICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXCJsb2dnZXJcIl0ud2FybihcIlttcDQtcmVtdXhlcl06IERyb3BwZWQgXCIgKyBmaXJzdEtleUZyYW1lSW5kZXggKyBcIiBvdXQgb2YgXCIgKyBsZW5ndGggKyBcIiB2aWRlbyBzYW1wbGVzIGR1ZSB0byBhIG1pc3Npbmcga2V5ZnJhbWVcIik7XG4gICAgICAgICAgICB2YXIgc3RhcnRQVFMgPSB0aGlzLmdldFZpZGVvU3RhcnRQdHModmlkZW9UcmFjay5zYW1wbGVzKTtcbiAgICAgICAgICAgIHZpZGVvVHJhY2suc2FtcGxlcyA9IHZpZGVvVHJhY2suc2FtcGxlcy5zbGljZShmaXJzdEtleUZyYW1lSW5kZXgpO1xuICAgICAgICAgICAgdmlkZW9UcmFjay5kcm9wcGVkICs9IGZpcnN0S2V5RnJhbWVJbmRleDtcbiAgICAgICAgICAgIHZpZGVvVGltZU9mZnNldCArPSAodmlkZW9UcmFjay5zYW1wbGVzWzBdLnB0cyAtIHN0YXJ0UFRTKSAvICh2aWRlb1RyYWNrLnRpbWVzY2FsZSB8fCA5MDAwMCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChmaXJzdEtleUZyYW1lSW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXCJsb2dnZXJcIl0ud2FybihcIlttcDQtcmVtdXhlcl06IE5vIGtleWZyYW1lIGZvdW5kIG91dCBvZiBcIiArIGxlbmd0aCArIFwiIHZpZGVvIHNhbXBsZXNcIik7XG4gICAgICAgICAgICBpbmRlcGVuZGVudCA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5JU0dlbmVyYXRlZCkge1xuICAgICAgICBpZiAoZW5vdWdoQXVkaW9TYW1wbGVzICYmIGVub3VnaFZpZGVvU2FtcGxlcykge1xuICAgICAgICAgIC8vIHRpbWVPZmZzZXQgaXMgZXhwZWN0ZWQgdG8gYmUgdGhlIG9mZnNldCBvZiB0aGUgZmlyc3QgdGltZXN0YW1wIG9mIHRoaXMgZnJhZ21lbnQgKGZpcnN0IERUUylcbiAgICAgICAgICAvLyBpZiBmaXJzdCBhdWRpbyBEVFMgaXMgbm90IGFsaWduZWQgd2l0aCBmaXJzdCB2aWRlbyBEVFMgdGhlbiB3ZSBuZWVkIHRvIHRha2UgdGhhdCBpbnRvIGFjY291bnRcbiAgICAgICAgICAvLyB3aGVuIHByb3ZpZGluZyB0aW1lT2Zmc2V0IHRvIHJlbXV4QXVkaW8gLyByZW11eFZpZGVvLiBpZiB3ZSBkb24ndCBkbyB0aGF0LCB0aGVyZSBtaWdodCBiZSBhIHBlcm1hbmVudCAvIHNtYWxsXG4gICAgICAgICAgLy8gZHJpZnQgYmV0d2VlbiBhdWRpbyBhbmQgdmlkZW8gc3RyZWFtc1xuICAgICAgICAgIHZhciBfc3RhcnRQVFMgPSB0aGlzLmdldFZpZGVvU3RhcnRQdHModmlkZW9UcmFjay5zYW1wbGVzKTtcblxuICAgICAgICAgIHZhciB0c0RlbHRhID0gbm9ybWFsaXplUHRzKGF1ZGlvVHJhY2suc2FtcGxlc1swXS5wdHMsIF9zdGFydFBUUykgLSBfc3RhcnRQVFM7XG5cbiAgICAgICAgICB2YXIgYXVkaW92aWRlb1RpbWVzdGFtcERlbHRhID0gdHNEZWx0YSAvIHZpZGVvVHJhY2suaW5wdXRUaW1lU2NhbGU7XG4gICAgICAgICAgYXVkaW9UaW1lT2Zmc2V0ICs9IE1hdGgubWF4KDAsIGF1ZGlvdmlkZW9UaW1lc3RhbXBEZWx0YSk7XG4gICAgICAgICAgdmlkZW9UaW1lT2Zmc2V0ICs9IE1hdGgubWF4KDAsIC1hdWRpb3ZpZGVvVGltZXN0YW1wRGVsdGEpO1xuICAgICAgICB9IC8vIFB1cnBvc2VmdWxseSByZW11eGluZyBhdWRpbyBiZWZvcmUgdmlkZW8sIHNvIHRoYXQgcmVtdXhWaWRlbyBjYW4gdXNlIG5leHRBdWRpb1B0cywgd2hpY2ggaXMgY2FsY3VsYXRlZCBpbiByZW11eEF1ZGlvLlxuXG5cbiAgICAgICAgaWYgKGVub3VnaEF1ZGlvU2FtcGxlcykge1xuICAgICAgICAgIC8vIGlmIGluaXRTZWdtZW50IHdhcyBnZW5lcmF0ZWQgd2l0aG91dCBhdWRpbyBzYW1wbGVzLCByZWdlbmVyYXRlIGl0IGFnYWluXG4gICAgICAgICAgaWYgKCFhdWRpb1RyYWNrLnNhbXBsZXJhdGUpIHtcbiAgICAgICAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcImxvZ2dlclwiXS53YXJuKCdbbXA0LXJlbXV4ZXJdOiByZWdlbmVyYXRlIEluaXRTZWdtZW50IGFzIGF1ZGlvIGRldGVjdGVkJyk7XG4gICAgICAgICAgICBpbml0U2VnbWVudCA9IHRoaXMuZ2VuZXJhdGVJUyhhdWRpb1RyYWNrLCB2aWRlb1RyYWNrLCB0aW1lT2Zmc2V0KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBhdWRpbyA9IHRoaXMucmVtdXhBdWRpbyhhdWRpb1RyYWNrLCBhdWRpb1RpbWVPZmZzZXQsIHRoaXMuaXNBdWRpb0NvbnRpZ3VvdXMsIGFjY3VyYXRlVGltZU9mZnNldCwgaGFzVmlkZW8gfHwgZW5vdWdoVmlkZW9TYW1wbGVzIHx8IHBsYXlsaXN0VHlwZSA9PT0gX3R5cGVzX2xvYWRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fW1wiUGxheWxpc3RMZXZlbFR5cGVcIl0uQVVESU8gPyB2aWRlb1RpbWVPZmZzZXQgOiB1bmRlZmluZWQpO1xuXG4gICAgICAgICAgaWYgKGVub3VnaFZpZGVvU2FtcGxlcykge1xuICAgICAgICAgICAgdmFyIGF1ZGlvVHJhY2tMZW5ndGggPSBhdWRpbyA/IGF1ZGlvLmVuZFBUUyAtIGF1ZGlvLnN0YXJ0UFRTIDogMDsgLy8gaWYgaW5pdFNlZ21lbnQgd2FzIGdlbmVyYXRlZCB3aXRob3V0IHZpZGVvIHNhbXBsZXMsIHJlZ2VuZXJhdGUgaXQgYWdhaW5cblxuICAgICAgICAgICAgaWYgKCF2aWRlb1RyYWNrLmlucHV0VGltZVNjYWxlKSB7XG4gICAgICAgICAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcImxvZ2dlclwiXS53YXJuKCdbbXA0LXJlbXV4ZXJdOiByZWdlbmVyYXRlIEluaXRTZWdtZW50IGFzIHZpZGVvIGRldGVjdGVkJyk7XG4gICAgICAgICAgICAgIGluaXRTZWdtZW50ID0gdGhpcy5nZW5lcmF0ZUlTKGF1ZGlvVHJhY2ssIHZpZGVvVHJhY2ssIHRpbWVPZmZzZXQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2aWRlbyA9IHRoaXMucmVtdXhWaWRlbyh2aWRlb1RyYWNrLCB2aWRlb1RpbWVPZmZzZXQsIGlzVmlkZW9Db250aWd1b3VzLCBhdWRpb1RyYWNrTGVuZ3RoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZW5vdWdoVmlkZW9TYW1wbGVzKSB7XG4gICAgICAgICAgdmlkZW8gPSB0aGlzLnJlbXV4VmlkZW8odmlkZW9UcmFjaywgdmlkZW9UaW1lT2Zmc2V0LCBpc1ZpZGVvQ29udGlndW91cywgMCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmlkZW8pIHtcbiAgICAgICAgICB2aWRlby5maXJzdEtleUZyYW1lID0gZmlyc3RLZXlGcmFtZUluZGV4O1xuICAgICAgICAgIHZpZGVvLmluZGVwZW5kZW50ID0gZmlyc3RLZXlGcmFtZUluZGV4ICE9PSAtMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gLy8gQWxsb3cgSUQzIGFuZCB0ZXh0IHRvIHJlbXV4LCBldmVuIGlmIG1vcmUgYXVkaW8vdmlkZW8gc2FtcGxlcyBhcmUgcmVxdWlyZWRcblxuXG4gICAgaWYgKHRoaXMuSVNHZW5lcmF0ZWQpIHtcbiAgICAgIGlmIChpZDNUcmFjay5zYW1wbGVzLmxlbmd0aCkge1xuICAgICAgICBpZDMgPSB0aGlzLnJlbXV4SUQzKGlkM1RyYWNrLCB0aW1lT2Zmc2V0KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRleHRUcmFjay5zYW1wbGVzLmxlbmd0aCkge1xuICAgICAgICB0ZXh0ID0gdGhpcy5yZW11eFRleHQodGV4dFRyYWNrLCB0aW1lT2Zmc2V0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgYXVkaW86IGF1ZGlvLFxuICAgICAgdmlkZW86IHZpZGVvLFxuICAgICAgaW5pdFNlZ21lbnQ6IGluaXRTZWdtZW50LFxuICAgICAgaW5kZXBlbmRlbnQ6IGluZGVwZW5kZW50LFxuICAgICAgdGV4dDogdGV4dCxcbiAgICAgIGlkMzogaWQzXG4gICAgfTtcbiAgfTtcblxuICBfcHJvdG8uZ2VuZXJhdGVJUyA9IGZ1bmN0aW9uIGdlbmVyYXRlSVMoYXVkaW9UcmFjaywgdmlkZW9UcmFjaywgdGltZU9mZnNldCkge1xuICAgIHZhciBhdWRpb1NhbXBsZXMgPSBhdWRpb1RyYWNrLnNhbXBsZXM7XG4gICAgdmFyIHZpZGVvU2FtcGxlcyA9IHZpZGVvVHJhY2suc2FtcGxlcztcbiAgICB2YXIgdHlwZVN1cHBvcnRlZCA9IHRoaXMudHlwZVN1cHBvcnRlZDtcbiAgICB2YXIgdHJhY2tzID0ge307XG4gICAgdmFyIGNvbXB1dGVQVFNEVFMgPSAhT2JqZWN0KF9ob21lX3J1bm5lcl93b3JrX2hsc19qc19obHNfanNfc3JjX3BvbHlmaWxsc19udW1iZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImlzRmluaXRlTnVtYmVyXCJdKSh0aGlzLl9pbml0UFRTKTtcbiAgICB2YXIgY29udGFpbmVyID0gJ2F1ZGlvL21wNCc7XG4gICAgdmFyIGluaXRQVFM7XG4gICAgdmFyIGluaXREVFM7XG4gICAgdmFyIHRpbWVzY2FsZTtcblxuICAgIGlmIChjb21wdXRlUFRTRFRTKSB7XG4gICAgICBpbml0UFRTID0gaW5pdERUUyA9IEluZmluaXR5O1xuICAgIH1cblxuICAgIGlmIChhdWRpb1RyYWNrLmNvbmZpZyAmJiBhdWRpb1NhbXBsZXMubGVuZ3RoKSB7XG4gICAgICAvLyBsZXQncyB1c2UgYXVkaW8gc2FtcGxpbmcgcmF0ZSBhcyBNUDQgdGltZSBzY2FsZS5cbiAgICAgIC8vIHJhdGlvbmFsZSBpcyB0aGF0IHRoZXJlIGlzIGEgaW50ZWdlciBuYiBvZiBhdWRpbyBmcmFtZXMgcGVyIGF1ZGlvIHNhbXBsZSAoMTAyNCBmb3IgQUFDKVxuICAgICAgLy8gdXNpbmcgYXVkaW8gc2FtcGxpbmcgcmF0ZSBoZXJlIGhlbHBzIGhhdmluZyBhbiBpbnRlZ2VyIE1QNCBmcmFtZSBkdXJhdGlvblxuICAgICAgLy8gdGhpcyBhdm9pZHMgcG90ZW50aWFsIHJvdW5kaW5nIGlzc3VlIGFuZCBBViBzeW5jIGlzc3VlXG4gICAgICBhdWRpb1RyYWNrLnRpbWVzY2FsZSA9IGF1ZGlvVHJhY2suc2FtcGxlcmF0ZTtcblxuICAgICAgaWYgKCFhdWRpb1RyYWNrLmlzQUFDKSB7XG4gICAgICAgIGlmICh0eXBlU3VwcG9ydGVkLm1wZWcpIHtcbiAgICAgICAgICAvLyBDaHJvbWUgYW5kIFNhZmFyaVxuICAgICAgICAgIGNvbnRhaW5lciA9ICdhdWRpby9tcGVnJztcbiAgICAgICAgICBhdWRpb1RyYWNrLmNvZGVjID0gJyc7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZVN1cHBvcnRlZC5tcDMpIHtcbiAgICAgICAgICAvLyBGaXJlZm94XG4gICAgICAgICAgYXVkaW9UcmFjay5jb2RlYyA9ICdtcDMnO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRyYWNrcy5hdWRpbyA9IHtcbiAgICAgICAgaWQ6ICdhdWRpbycsXG4gICAgICAgIGNvbnRhaW5lcjogY29udGFpbmVyLFxuICAgICAgICBjb2RlYzogYXVkaW9UcmFjay5jb2RlYyxcbiAgICAgICAgaW5pdFNlZ21lbnQ6ICFhdWRpb1RyYWNrLmlzQUFDICYmIHR5cGVTdXBwb3J0ZWQubXBlZyA/IG5ldyBVaW50OEFycmF5KDApIDogX21wNF9nZW5lcmF0b3JfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImRlZmF1bHRcIl0uaW5pdFNlZ21lbnQoW2F1ZGlvVHJhY2tdKSxcbiAgICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgICBjaGFubmVsQ291bnQ6IGF1ZGlvVHJhY2suY2hhbm5lbENvdW50XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGlmIChjb21wdXRlUFRTRFRTKSB7XG4gICAgICAgIHRpbWVzY2FsZSA9IGF1ZGlvVHJhY2suaW5wdXRUaW1lU2NhbGU7IC8vIHJlbWVtYmVyIGZpcnN0IFBUUyBvZiB0aGlzIGRlbXV4aW5nIGNvbnRleHQuIGZvciBhdWRpbywgUFRTID0gRFRTXG5cbiAgICAgICAgaW5pdFBUUyA9IGluaXREVFMgPSBhdWRpb1NhbXBsZXNbMF0ucHRzIC0gTWF0aC5yb3VuZCh0aW1lc2NhbGUgKiB0aW1lT2Zmc2V0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodmlkZW9UcmFjay5zcHMgJiYgdmlkZW9UcmFjay5wcHMgJiYgdmlkZW9TYW1wbGVzLmxlbmd0aCkge1xuICAgICAgLy8gbGV0J3MgdXNlIGlucHV0IHRpbWUgc2NhbGUgYXMgTVA0IHZpZGVvIHRpbWVzY2FsZVxuICAgICAgLy8gd2UgdXNlIGlucHV0IHRpbWUgc2NhbGUgc3RyYWlnaHQgYXdheSB0byBhdm9pZCByb3VuZGluZyBpc3N1ZXMgb24gZnJhbWUgZHVyYXRpb24gLyBjdHMgY29tcHV0YXRpb25cbiAgICAgIHZpZGVvVHJhY2sudGltZXNjYWxlID0gdmlkZW9UcmFjay5pbnB1dFRpbWVTY2FsZTtcbiAgICAgIHRyYWNrcy52aWRlbyA9IHtcbiAgICAgICAgaWQ6ICdtYWluJyxcbiAgICAgICAgY29udGFpbmVyOiAndmlkZW8vbXA0JyxcbiAgICAgICAgY29kZWM6IHZpZGVvVHJhY2suY29kZWMsXG4gICAgICAgIGluaXRTZWdtZW50OiBfbXA0X2dlbmVyYXRvcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiZGVmYXVsdFwiXS5pbml0U2VnbWVudChbdmlkZW9UcmFja10pLFxuICAgICAgICBtZXRhZGF0YToge1xuICAgICAgICAgIHdpZHRoOiB2aWRlb1RyYWNrLndpZHRoLFxuICAgICAgICAgIGhlaWdodDogdmlkZW9UcmFjay5oZWlnaHRcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgaWYgKGNvbXB1dGVQVFNEVFMpIHtcbiAgICAgICAgdGltZXNjYWxlID0gdmlkZW9UcmFjay5pbnB1dFRpbWVTY2FsZTtcbiAgICAgICAgdmFyIHN0YXJ0UFRTID0gdGhpcy5nZXRWaWRlb1N0YXJ0UHRzKHZpZGVvU2FtcGxlcyk7XG4gICAgICAgIHZhciBzdGFydE9mZnNldCA9IE1hdGgucm91bmQodGltZXNjYWxlICogdGltZU9mZnNldCk7XG4gICAgICAgIGluaXREVFMgPSBNYXRoLm1pbihpbml0RFRTLCBub3JtYWxpemVQdHModmlkZW9TYW1wbGVzWzBdLmR0cywgc3RhcnRQVFMpIC0gc3RhcnRPZmZzZXQpO1xuICAgICAgICBpbml0UFRTID0gTWF0aC5taW4oaW5pdFBUUywgc3RhcnRQVFMgLSBzdGFydE9mZnNldCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKE9iamVjdC5rZXlzKHRyYWNrcykubGVuZ3RoKSB7XG4gICAgICB0aGlzLklTR2VuZXJhdGVkID0gdHJ1ZTtcblxuICAgICAgaWYgKGNvbXB1dGVQVFNEVFMpIHtcbiAgICAgICAgdGhpcy5faW5pdFBUUyA9IGluaXRQVFM7XG4gICAgICAgIHRoaXMuX2luaXREVFMgPSBpbml0RFRTO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB0cmFja3M6IHRyYWNrcyxcbiAgICAgICAgaW5pdFBUUzogaW5pdFBUUyxcbiAgICAgICAgdGltZXNjYWxlOiB0aW1lc2NhbGVcbiAgICAgIH07XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5yZW11eFZpZGVvID0gZnVuY3Rpb24gcmVtdXhWaWRlbyh0cmFjaywgdGltZU9mZnNldCwgY29udGlndW91cywgYXVkaW9UcmFja0xlbmd0aCkge1xuICAgIHZhciB0aW1lU2NhbGUgPSB0cmFjay5pbnB1dFRpbWVTY2FsZTtcbiAgICB2YXIgaW5wdXRTYW1wbGVzID0gdHJhY2suc2FtcGxlcztcbiAgICB2YXIgb3V0cHV0U2FtcGxlcyA9IFtdO1xuICAgIHZhciBuYlNhbXBsZXMgPSBpbnB1dFNhbXBsZXMubGVuZ3RoO1xuICAgIHZhciBpbml0UFRTID0gdGhpcy5faW5pdFBUUztcbiAgICB2YXIgbmV4dEF2Y0R0cyA9IHRoaXMubmV4dEF2Y0R0cztcbiAgICB2YXIgb2Zmc2V0ID0gODtcbiAgICB2YXIgbXA0U2FtcGxlRHVyYXRpb247XG4gICAgdmFyIGZpcnN0RFRTO1xuICAgIHZhciBsYXN0RFRTO1xuICAgIHZhciBtaW5QVFMgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgdmFyIG1heFBUUyA9IE51bWJlci5ORUdBVElWRV9JTkZJTklUWTtcbiAgICB2YXIgcHRzRHRzU2hpZnQgPSAwO1xuICAgIHZhciBzb3J0U2FtcGxlcyA9IGZhbHNlOyAvLyBpZiBwYXJzZWQgZnJhZ21lbnQgaXMgY29udGlndW91cyB3aXRoIGxhc3Qgb25lLCBsZXQncyB1c2UgbGFzdCBEVFMgdmFsdWUgYXMgcmVmZXJlbmNlXG5cbiAgICBpZiAoIWNvbnRpZ3VvdXMgfHwgbmV4dEF2Y0R0cyA9PT0gbnVsbCkge1xuICAgICAgdmFyIHB0cyA9IHRpbWVPZmZzZXQgKiB0aW1lU2NhbGU7XG4gICAgICB2YXIgY3RzID0gaW5wdXRTYW1wbGVzWzBdLnB0cyAtIG5vcm1hbGl6ZVB0cyhpbnB1dFNhbXBsZXNbMF0uZHRzLCBpbnB1dFNhbXBsZXNbMF0ucHRzKTsgLy8gaWYgbm90IGNvbnRpZ3VvdXMsIGxldCdzIHVzZSB0YXJnZXQgdGltZU9mZnNldFxuXG4gICAgICBuZXh0QXZjRHRzID0gcHRzIC0gY3RzO1xuICAgIH0gLy8gUFRTIGlzIGNvZGVkIG9uIDMzYml0cywgYW5kIGNhbiBsb29wIGZyb20gLTJeMzIgdG8gMl4zMlxuICAgIC8vIFBUU05vcm1hbGl6ZSB3aWxsIG1ha2UgUFRTL0RUUyB2YWx1ZSBtb25vdG9uaWMsIHdlIHVzZSBsYXN0IGtub3duIERUUyB2YWx1ZSBhcyByZWZlcmVuY2UgdmFsdWVcblxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYlNhbXBsZXM7IGkrKykge1xuICAgICAgdmFyIHNhbXBsZSA9IGlucHV0U2FtcGxlc1tpXTtcbiAgICAgIHNhbXBsZS5wdHMgPSBub3JtYWxpemVQdHMoc2FtcGxlLnB0cyAtIGluaXRQVFMsIG5leHRBdmNEdHMpO1xuICAgICAgc2FtcGxlLmR0cyA9IG5vcm1hbGl6ZVB0cyhzYW1wbGUuZHRzIC0gaW5pdFBUUywgbmV4dEF2Y0R0cyk7XG5cbiAgICAgIGlmIChzYW1wbGUuZHRzID4gc2FtcGxlLnB0cykge1xuICAgICAgICB2YXIgUFRTX0RUU19TSElGVF9UT0xFUkFOQ0VfOTBLSFogPSA5MDAwMCAqIDAuMjtcbiAgICAgICAgcHRzRHRzU2hpZnQgPSBNYXRoLm1heChNYXRoLm1pbihwdHNEdHNTaGlmdCwgc2FtcGxlLnB0cyAtIHNhbXBsZS5kdHMpLCAtMSAqIFBUU19EVFNfU0hJRlRfVE9MRVJBTkNFXzkwS0haKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNhbXBsZS5kdHMgPCBpbnB1dFNhbXBsZXNbaSA+IDAgPyBpIC0gMSA6IGldLmR0cykge1xuICAgICAgICBzb3J0U2FtcGxlcyA9IHRydWU7XG4gICAgICB9XG4gICAgfSAvLyBzb3J0IHZpZGVvIHNhbXBsZXMgYnkgRFRTIHRoZW4gUFRTIHRoZW4gZGVtdXggaWQgb3JkZXJcblxuXG4gICAgaWYgKHNvcnRTYW1wbGVzKSB7XG4gICAgICBpbnB1dFNhbXBsZXMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICB2YXIgZGVsdGFkdHMgPSBhLmR0cyAtIGIuZHRzO1xuICAgICAgICB2YXIgZGVsdGFwdHMgPSBhLnB0cyAtIGIucHRzO1xuICAgICAgICByZXR1cm4gZGVsdGFkdHMgfHwgZGVsdGFwdHM7XG4gICAgICB9KTtcbiAgICB9IC8vIEdldCBmaXJzdC9sYXN0IERUU1xuXG5cbiAgICBmaXJzdERUUyA9IGlucHV0U2FtcGxlc1swXS5kdHM7XG4gICAgbGFzdERUUyA9IGlucHV0U2FtcGxlc1tpbnB1dFNhbXBsZXMubGVuZ3RoIC0gMV0uZHRzOyAvLyBvbiBTYWZhcmkgbGV0J3Mgc2lnbmFsIHRoZSBzYW1lIHNhbXBsZSBkdXJhdGlvbiBmb3IgYWxsIHNhbXBsZXNcbiAgICAvLyBzYW1wbGUgZHVyYXRpb24gKGFzIGV4cGVjdGVkIGJ5IHRydW4gTVA0IGJveGVzKSwgc2hvdWxkIGJlIHRoZSBkZWx0YSBiZXR3ZWVuIHNhbXBsZSBEVFNcbiAgICAvLyBzZXQgdGhpcyBjb25zdGFudCBkdXJhdGlvbiBhcyBiZWluZyB0aGUgYXZnIGRlbHRhIGJldHdlZW4gY29uc2VjdXRpdmUgRFRTLlxuXG4gICAgdmFyIGF2ZXJhZ2VTYW1wbGVEdXJhdGlvbiA9IE1hdGgucm91bmQoKGxhc3REVFMgLSBmaXJzdERUUykgLyAobmJTYW1wbGVzIC0gMSkpOyAvLyBoYW5kbGUgYnJva2VuIHN0cmVhbXMgd2l0aCBQVFMgPCBEVFMsIHRvbGVyYW5jZSB1cCAwLjIgc2Vjb25kc1xuXG4gICAgaWYgKHB0c0R0c1NoaWZ0IDwgMCkge1xuICAgICAgaWYgKHB0c0R0c1NoaWZ0IDwgYXZlcmFnZVNhbXBsZUR1cmF0aW9uICogLTIpIHtcbiAgICAgICAgLy8gRml4IGZvciBcIkNOTiBzcGVjaWFsIHJlcG9ydCwgd2l0aCBDQ1wiIGluIHRlc3Qtc3RyZWFtcyAoaW5jbHVkaW5nIFNhZmFyaSBicm93c2VyKVxuICAgICAgICAvLyBXaXRoIGxhcmdlIFBUUyA8IERUUyBlcnJvcnMgc3VjaCBhcyB0aGlzLCB3ZSB3YW50IHRvIGNvcnJlY3QgQ1RTIHdoaWxlIG1haW50YWluaW5nIGluY3JlYXNpbmcgRFRTIHZhbHVlc1xuICAgICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXCJsb2dnZXJcIl0ud2FybihcIlBUUyA8IERUUyBkZXRlY3RlZCBpbiB2aWRlbyBzYW1wbGVzLCBvZmZzZXR0aW5nIERUUyBmcm9tIFBUUyBieSBcIiArIE9iamVjdChfdXRpbHNfdGltZXNjYWxlX2NvbnZlcnNpb25fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1tcInRvTXNGcm9tTXBlZ1RzQ2xvY2tcIl0pKC1hdmVyYWdlU2FtcGxlRHVyYXRpb24sIHRydWUpICsgXCIgbXNcIik7XG4gICAgICAgIHZhciBsYXN0RHRzID0gcHRzRHRzU2hpZnQ7XG5cbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IG5iU2FtcGxlczsgX2krKykge1xuICAgICAgICAgIGlucHV0U2FtcGxlc1tfaV0uZHRzID0gbGFzdER0cyA9IE1hdGgubWF4KGxhc3REdHMsIGlucHV0U2FtcGxlc1tfaV0ucHRzIC0gYXZlcmFnZVNhbXBsZUR1cmF0aW9uKTtcbiAgICAgICAgICBpbnB1dFNhbXBsZXNbX2ldLnB0cyA9IE1hdGgubWF4KGxhc3REdHMsIGlucHV0U2FtcGxlc1tfaV0ucHRzKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRml4IGZvciBcIkN1c3RvbSBJViB3aXRoIGJhZCBQVFMgRFRTXCIgaW4gdGVzdC1zdHJlYW1zXG4gICAgICAgIC8vIFdpdGggc21hbGxlciBQVFMgPCBEVFMgZXJyb3JzIHdlIGNhbiBzaW1wbHkgbW92ZSBhbGwgRFRTIGJhY2suIFRoaXMgaW5jcmVhc2VzIENUUyB3aXRob3V0IGNhdXNpbmcgYnVmZmVyIGdhcHMgb3IgZGVjb2RlIGVycm9ycyBpbiBTYWZhcmlcbiAgICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1wibG9nZ2VyXCJdLndhcm4oXCJQVFMgPCBEVFMgZGV0ZWN0ZWQgaW4gdmlkZW8gc2FtcGxlcywgc2hpZnRpbmcgRFRTIGJ5IFwiICsgT2JqZWN0KF91dGlsc190aW1lc2NhbGVfY29udmVyc2lvbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fW1widG9Nc0Zyb21NcGVnVHNDbG9ja1wiXSkocHRzRHRzU2hpZnQsIHRydWUpICsgXCIgbXMgdG8gb3ZlcmNvbWUgdGhpcyBpc3N1ZVwiKTtcblxuICAgICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBuYlNhbXBsZXM7IF9pMisrKSB7XG4gICAgICAgICAgaW5wdXRTYW1wbGVzW19pMl0uZHRzID0gaW5wdXRTYW1wbGVzW19pMl0uZHRzICsgcHRzRHRzU2hpZnQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZmlyc3REVFMgPSBpbnB1dFNhbXBsZXNbMF0uZHRzO1xuICAgIH0gLy8gaWYgZnJhZ21lbnQgYXJlIGNvbnRpZ3VvdXMsIGRldGVjdCBob2xlL292ZXJsYXBwaW5nIGJldHdlZW4gZnJhZ21lbnRzXG5cblxuICAgIGlmIChjb250aWd1b3VzKSB7XG4gICAgICAvLyBjaGVjayB0aW1lc3RhbXAgY29udGludWl0eSBhY3Jvc3MgY29uc2VjdXRpdmUgZnJhZ21lbnRzICh0aGlzIGlzIHRvIHJlbW92ZSBpbnRlci1mcmFnbWVudCBnYXAvaG9sZSlcbiAgICAgIHZhciBkZWx0YSA9IGZpcnN0RFRTIC0gbmV4dEF2Y0R0cztcbiAgICAgIHZhciBmb3VuZEhvbGUgPSBkZWx0YSA+IGF2ZXJhZ2VTYW1wbGVEdXJhdGlvbjtcbiAgICAgIHZhciBmb3VuZE92ZXJsYXAgPSBkZWx0YSA8IC0xO1xuXG4gICAgICBpZiAoZm91bmRIb2xlIHx8IGZvdW5kT3ZlcmxhcCkge1xuICAgICAgICBpZiAoZm91bmRIb2xlKSB7XG4gICAgICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1wibG9nZ2VyXCJdLndhcm4oXCJBVkM6IFwiICsgT2JqZWN0KF91dGlsc190aW1lc2NhbGVfY29udmVyc2lvbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fW1widG9Nc0Zyb21NcGVnVHNDbG9ja1wiXSkoZGVsdGEsIHRydWUpICsgXCIgbXMgKFwiICsgZGVsdGEgKyBcImR0cykgaG9sZSBiZXR3ZWVuIGZyYWdtZW50cyBkZXRlY3RlZCwgZmlsbGluZyBpdFwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXCJsb2dnZXJcIl0ud2FybihcIkFWQzogXCIgKyBPYmplY3QoX3V0aWxzX3RpbWVzY2FsZV9jb252ZXJzaW9uX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bXCJ0b01zRnJvbU1wZWdUc0Nsb2NrXCJdKSgtZGVsdGEsIHRydWUpICsgXCIgbXMgKFwiICsgZGVsdGEgKyBcImR0cykgb3ZlcmxhcHBpbmcgYmV0d2VlbiBmcmFnbWVudHMgZGV0ZWN0ZWRcIik7XG4gICAgICAgIH1cblxuICAgICAgICBmaXJzdERUUyA9IG5leHRBdmNEdHM7XG4gICAgICAgIHZhciBmaXJzdFBUUyA9IGlucHV0U2FtcGxlc1swXS5wdHMgLSBkZWx0YTtcbiAgICAgICAgaW5wdXRTYW1wbGVzWzBdLmR0cyA9IGZpcnN0RFRTO1xuICAgICAgICBpbnB1dFNhbXBsZXNbMF0ucHRzID0gZmlyc3RQVFM7XG4gICAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcImxvZ2dlclwiXS5sb2coXCJWaWRlbzogRmlyc3QgUFRTL0RUUyBhZGp1c3RlZDogXCIgKyBPYmplY3QoX3V0aWxzX3RpbWVzY2FsZV9jb252ZXJzaW9uX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bXCJ0b01zRnJvbU1wZWdUc0Nsb2NrXCJdKShmaXJzdFBUUywgdHJ1ZSkgKyBcIi9cIiArIE9iamVjdChfdXRpbHNfdGltZXNjYWxlX2NvbnZlcnNpb25fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1tcInRvTXNGcm9tTXBlZ1RzQ2xvY2tcIl0pKGZpcnN0RFRTLCB0cnVlKSArIFwiLCBkZWx0YTogXCIgKyBPYmplY3QoX3V0aWxzX3RpbWVzY2FsZV9jb252ZXJzaW9uX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bXCJ0b01zRnJvbU1wZWdUc0Nsb2NrXCJdKShkZWx0YSwgdHJ1ZSkgKyBcIiBtc1wiKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocmVxdWlyZXNQb3NpdGl2ZUR0cykge1xuICAgICAgZmlyc3REVFMgPSBNYXRoLm1heCgwLCBmaXJzdERUUyk7XG4gICAgfVxuXG4gICAgdmFyIG5iTmFsdSA9IDA7XG4gICAgdmFyIG5hbHVMZW4gPSAwO1xuXG4gICAgZm9yICh2YXIgX2kzID0gMDsgX2kzIDwgbmJTYW1wbGVzOyBfaTMrKykge1xuICAgICAgLy8gY29tcHV0ZSB0b3RhbC9hdmMgc2FtcGxlIGxlbmd0aCBhbmQgbmIgb2YgTkFMIHVuaXRzXG4gICAgICB2YXIgX3NhbXBsZSA9IGlucHV0U2FtcGxlc1tfaTNdO1xuICAgICAgdmFyIHVuaXRzID0gX3NhbXBsZS51bml0cztcbiAgICAgIHZhciBuYlVuaXRzID0gdW5pdHMubGVuZ3RoO1xuICAgICAgdmFyIHNhbXBsZUxlbiA9IDA7XG5cbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbmJVbml0czsgaisrKSB7XG4gICAgICAgIHNhbXBsZUxlbiArPSB1bml0c1tqXS5kYXRhLmxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgbmFsdUxlbiArPSBzYW1wbGVMZW47XG4gICAgICBuYk5hbHUgKz0gbmJVbml0cztcbiAgICAgIF9zYW1wbGUubGVuZ3RoID0gc2FtcGxlTGVuOyAvLyBub3JtYWxpemUgUFRTL0RUU1xuICAgICAgLy8gZW5zdXJlIHNhbXBsZSBtb25vdG9uaWMgRFRTXG5cbiAgICAgIF9zYW1wbGUuZHRzID0gTWF0aC5tYXgoX3NhbXBsZS5kdHMsIGZpcnN0RFRTKTsgLy8gZW5zdXJlIHRoYXQgY29tcHV0ZWQgdmFsdWUgaXMgZ3JlYXRlciBvciBlcXVhbCB0aGFuIHNhbXBsZSBEVFNcblxuICAgICAgX3NhbXBsZS5wdHMgPSBNYXRoLm1heChfc2FtcGxlLnB0cywgX3NhbXBsZS5kdHMsIDApO1xuICAgICAgbWluUFRTID0gTWF0aC5taW4oX3NhbXBsZS5wdHMsIG1pblBUUyk7XG4gICAgICBtYXhQVFMgPSBNYXRoLm1heChfc2FtcGxlLnB0cywgbWF4UFRTKTtcbiAgICB9XG5cbiAgICBsYXN0RFRTID0gaW5wdXRTYW1wbGVzW25iU2FtcGxlcyAtIDFdLmR0cztcbiAgICAvKiBjb25jYXRlbmF0ZSB0aGUgdmlkZW8gZGF0YSBhbmQgY29uc3RydWN0IHRoZSBtZGF0IGluIHBsYWNlXG4gICAgICAobmVlZCA4IG1vcmUgYnl0ZXMgdG8gZmlsbCBsZW5ndGggYW5kIG1wZGF0IHR5cGUpICovXG5cbiAgICB2YXIgbWRhdFNpemUgPSBuYWx1TGVuICsgNCAqIG5iTmFsdSArIDg7XG4gICAgdmFyIG1kYXQ7XG5cbiAgICB0cnkge1xuICAgICAgbWRhdCA9IG5ldyBVaW50OEFycmF5KG1kYXRTaXplKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRoaXMub2JzZXJ2ZXIuZW1pdChfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJFdmVudHNcIl0uRVJST1IsIF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcIkV2ZW50c1wiXS5FUlJPUiwge1xuICAgICAgICB0eXBlOiBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXCJFcnJvclR5cGVzXCJdLk1VWF9FUlJPUixcbiAgICAgICAgZGV0YWlsczogX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fW1wiRXJyb3JEZXRhaWxzXCJdLlJFTVVYX0FMTE9DX0VSUk9SLFxuICAgICAgICBmYXRhbDogZmFsc2UsXG4gICAgICAgIGJ5dGVzOiBtZGF0U2l6ZSxcbiAgICAgICAgcmVhc29uOiBcImZhaWwgYWxsb2NhdGluZyB2aWRlbyBtZGF0IFwiICsgbWRhdFNpemVcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB2aWV3ID0gbmV3IERhdGFWaWV3KG1kYXQuYnVmZmVyKTtcbiAgICB2aWV3LnNldFVpbnQzMigwLCBtZGF0U2l6ZSk7XG4gICAgbWRhdC5zZXQoX21wNF9nZW5lcmF0b3JfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImRlZmF1bHRcIl0udHlwZXMubWRhdCwgNCk7XG5cbiAgICBmb3IgKHZhciBfaTQgPSAwOyBfaTQgPCBuYlNhbXBsZXM7IF9pNCsrKSB7XG4gICAgICB2YXIgYXZjU2FtcGxlID0gaW5wdXRTYW1wbGVzW19pNF07XG4gICAgICB2YXIgYXZjU2FtcGxlVW5pdHMgPSBhdmNTYW1wbGUudW5pdHM7XG4gICAgICB2YXIgbXA0U2FtcGxlTGVuZ3RoID0gMDsgLy8gY29udmVydCBOQUxVIGJpdHN0cmVhbSB0byBNUDQgZm9ybWF0IChwcmVwZW5kIE5BTFUgd2l0aCBzaXplIGZpZWxkKVxuXG4gICAgICBmb3IgKHZhciBfaiA9IDAsIF9uYlVuaXRzID0gYXZjU2FtcGxlVW5pdHMubGVuZ3RoOyBfaiA8IF9uYlVuaXRzOyBfaisrKSB7XG4gICAgICAgIHZhciB1bml0ID0gYXZjU2FtcGxlVW5pdHNbX2pdO1xuICAgICAgICB2YXIgdW5pdERhdGEgPSB1bml0LmRhdGE7XG4gICAgICAgIHZhciB1bml0RGF0YUxlbiA9IHVuaXQuZGF0YS5ieXRlTGVuZ3RoO1xuICAgICAgICB2aWV3LnNldFVpbnQzMihvZmZzZXQsIHVuaXREYXRhTGVuKTtcbiAgICAgICAgb2Zmc2V0ICs9IDQ7XG4gICAgICAgIG1kYXQuc2V0KHVuaXREYXRhLCBvZmZzZXQpO1xuICAgICAgICBvZmZzZXQgKz0gdW5pdERhdGFMZW47XG4gICAgICAgIG1wNFNhbXBsZUxlbmd0aCArPSA0ICsgdW5pdERhdGFMZW47XG4gICAgICB9IC8vIGV4cGVjdGVkIHNhbXBsZSBkdXJhdGlvbiBpcyB0aGUgRGVjb2RpbmcgVGltZXN0YW1wIGRpZmYgb2YgY29uc2VjdXRpdmUgc2FtcGxlc1xuXG5cbiAgICAgIGlmIChfaTQgPCBuYlNhbXBsZXMgLSAxKSB7XG4gICAgICAgIG1wNFNhbXBsZUR1cmF0aW9uID0gaW5wdXRTYW1wbGVzW19pNCArIDFdLmR0cyAtIGF2Y1NhbXBsZS5kdHM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgY29uZmlnID0gdGhpcy5jb25maWc7XG4gICAgICAgIHZhciBsYXN0RnJhbWVEdXJhdGlvbiA9IGF2Y1NhbXBsZS5kdHMgLSBpbnB1dFNhbXBsZXNbX2k0ID4gMCA/IF9pNCAtIDEgOiBfaTRdLmR0cztcblxuICAgICAgICBpZiAoY29uZmlnLnN0cmV0Y2hTaG9ydFZpZGVvVHJhY2sgJiYgdGhpcy5uZXh0QXVkaW9QdHMgIT09IG51bGwpIHtcbiAgICAgICAgICAvLyBJbiBzb21lIGNhc2VzLCBhIHNlZ21lbnQncyBhdWRpbyB0cmFjayBkdXJhdGlvbiBtYXkgZXhjZWVkIHRoZSB2aWRlbyB0cmFjayBkdXJhdGlvbi5cbiAgICAgICAgICAvLyBTaW5jZSB3ZSd2ZSBhbHJlYWR5IHJlbXV4ZWQgYXVkaW8sIGFuZCB3ZSBrbm93IGhvdyBsb25nIHRoZSBhdWRpbyB0cmFjayBpcywgd2UgbG9vayB0b1xuICAgICAgICAgIC8vIHNlZSBpZiB0aGUgZGVsdGEgdG8gdGhlIG5leHQgc2VnbWVudCBpcyBsb25nZXIgdGhhbiBtYXhCdWZmZXJIb2xlLlxuICAgICAgICAgIC8vIElmIHNvLCBwbGF5YmFjayB3b3VsZCBwb3RlbnRpYWxseSBnZXQgc3R1Y2ssIHNvIHdlIGFydGlmaWNpYWxseSBpbmZsYXRlXG4gICAgICAgICAgLy8gdGhlIGR1cmF0aW9uIG9mIHRoZSBsYXN0IGZyYW1lIHRvIG1pbmltaXplIGFueSBwb3RlbnRpYWwgZ2FwIGJldHdlZW4gc2VnbWVudHMuXG4gICAgICAgICAgdmFyIGdhcFRvbGVyYW5jZSA9IE1hdGguZmxvb3IoY29uZmlnLm1heEJ1ZmZlckhvbGUgKiB0aW1lU2NhbGUpO1xuICAgICAgICAgIHZhciBkZWx0YVRvRnJhbWVFbmQgPSAoYXVkaW9UcmFja0xlbmd0aCA/IG1pblBUUyArIGF1ZGlvVHJhY2tMZW5ndGggKiB0aW1lU2NhbGUgOiB0aGlzLm5leHRBdWRpb1B0cykgLSBhdmNTYW1wbGUucHRzO1xuXG4gICAgICAgICAgaWYgKGRlbHRhVG9GcmFtZUVuZCA+IGdhcFRvbGVyYW5jZSkge1xuICAgICAgICAgICAgLy8gV2Ugc3VidHJhY3QgbGFzdEZyYW1lRHVyYXRpb24gZnJvbSBkZWx0YVRvRnJhbWVFbmQgdG8gdHJ5IHRvIHByZXZlbnQgYW55IHZpZGVvXG4gICAgICAgICAgICAvLyBmcmFtZSBvdmVybGFwLiBtYXhCdWZmZXJIb2xlIHNob3VsZCBiZSA+PiBsYXN0RnJhbWVEdXJhdGlvbiBhbnl3YXkuXG4gICAgICAgICAgICBtcDRTYW1wbGVEdXJhdGlvbiA9IGRlbHRhVG9GcmFtZUVuZCAtIGxhc3RGcmFtZUR1cmF0aW9uO1xuXG4gICAgICAgICAgICBpZiAobXA0U2FtcGxlRHVyYXRpb24gPCAwKSB7XG4gICAgICAgICAgICAgIG1wNFNhbXBsZUR1cmF0aW9uID0gbGFzdEZyYW1lRHVyYXRpb247XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcImxvZ2dlclwiXS5sb2coXCJbbXA0LXJlbXV4ZXJdOiBJdCBpcyBhcHByb3hpbWF0ZWx5IFwiICsgZGVsdGFUb0ZyYW1lRW5kIC8gOTAgKyBcIiBtcyB0byB0aGUgbmV4dCBzZWdtZW50OyB1c2luZyBkdXJhdGlvbiBcIiArIG1wNFNhbXBsZUR1cmF0aW9uIC8gOTAgKyBcIiBtcyBmb3IgdGhlIGxhc3QgdmlkZW8gZnJhbWUuXCIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtcDRTYW1wbGVEdXJhdGlvbiA9IGxhc3RGcmFtZUR1cmF0aW9uO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtcDRTYW1wbGVEdXJhdGlvbiA9IGxhc3RGcmFtZUR1cmF0aW9uO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBjb21wb3NpdGlvblRpbWVPZmZzZXQgPSBNYXRoLnJvdW5kKGF2Y1NhbXBsZS5wdHMgLSBhdmNTYW1wbGUuZHRzKTtcbiAgICAgIG91dHB1dFNhbXBsZXMucHVzaChuZXcgTXA0U2FtcGxlKGF2Y1NhbXBsZS5rZXksIG1wNFNhbXBsZUR1cmF0aW9uLCBtcDRTYW1wbGVMZW5ndGgsIGNvbXBvc2l0aW9uVGltZU9mZnNldCkpO1xuICAgIH1cblxuICAgIGlmIChvdXRwdXRTYW1wbGVzLmxlbmd0aCAmJiBjaHJvbWVWZXJzaW9uICYmIGNocm9tZVZlcnNpb24gPCA3MCkge1xuICAgICAgLy8gQ2hyb21lIHdvcmthcm91bmQsIG1hcmsgZmlyc3Qgc2FtcGxlIGFzIGJlaW5nIGEgUmFuZG9tIEFjY2VzcyBQb2ludCAoa2V5ZnJhbWUpIHRvIGF2b2lkIHNvdXJjZWJ1ZmZlciBhcHBlbmQgaXNzdWVcbiAgICAgIC8vIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0yMjk0MTJcbiAgICAgIHZhciBmbGFncyA9IG91dHB1dFNhbXBsZXNbMF0uZmxhZ3M7XG4gICAgICBmbGFncy5kZXBlbmRzT24gPSAyO1xuICAgICAgZmxhZ3MuaXNOb25TeW5jID0gMDtcbiAgICB9XG5cbiAgICBjb25zb2xlLmFzc2VydChtcDRTYW1wbGVEdXJhdGlvbiAhPT0gdW5kZWZpbmVkLCAnbXA0U2FtcGxlRHVyYXRpb24gbXVzdCBiZSBjb21wdXRlZCcpOyAvLyBuZXh0IEFWQyBzYW1wbGUgRFRTIHNob3VsZCBiZSBlcXVhbCB0byBsYXN0IHNhbXBsZSBEVFMgKyBsYXN0IHNhbXBsZSBkdXJhdGlvbiAoaW4gUEVTIHRpbWVzY2FsZSlcblxuICAgIHRoaXMubmV4dEF2Y0R0cyA9IG5leHRBdmNEdHMgPSBsYXN0RFRTICsgbXA0U2FtcGxlRHVyYXRpb247XG4gICAgdGhpcy5pc1ZpZGVvQ29udGlndW91cyA9IHRydWU7XG4gICAgdmFyIG1vb2YgPSBfbXA0X2dlbmVyYXRvcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiZGVmYXVsdFwiXS5tb29mKHRyYWNrLnNlcXVlbmNlTnVtYmVyKyssIGZpcnN0RFRTLCBfZXh0ZW5kcyh7fSwgdHJhY2ssIHtcbiAgICAgIHNhbXBsZXM6IG91dHB1dFNhbXBsZXNcbiAgICB9KSk7XG4gICAgdmFyIHR5cGUgPSAndmlkZW8nO1xuICAgIHZhciBkYXRhID0ge1xuICAgICAgZGF0YTE6IG1vb2YsXG4gICAgICBkYXRhMjogbWRhdCxcbiAgICAgIHN0YXJ0UFRTOiBtaW5QVFMgLyB0aW1lU2NhbGUsXG4gICAgICBlbmRQVFM6IChtYXhQVFMgKyBtcDRTYW1wbGVEdXJhdGlvbikgLyB0aW1lU2NhbGUsXG4gICAgICBzdGFydERUUzogZmlyc3REVFMgLyB0aW1lU2NhbGUsXG4gICAgICBlbmREVFM6IG5leHRBdmNEdHMgLyB0aW1lU2NhbGUsXG4gICAgICB0eXBlOiB0eXBlLFxuICAgICAgaGFzQXVkaW86IGZhbHNlLFxuICAgICAgaGFzVmlkZW86IHRydWUsXG4gICAgICBuYjogb3V0cHV0U2FtcGxlcy5sZW5ndGgsXG4gICAgICBkcm9wcGVkOiB0cmFjay5kcm9wcGVkXG4gICAgfTtcbiAgICB0cmFjay5zYW1wbGVzID0gW107XG4gICAgdHJhY2suZHJvcHBlZCA9IDA7XG4gICAgY29uc29sZS5hc3NlcnQobWRhdC5sZW5ndGgsICdNREFUIGxlbmd0aCBtdXN0IG5vdCBiZSB6ZXJvJyk7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH07XG5cbiAgX3Byb3RvLnJlbXV4QXVkaW8gPSBmdW5jdGlvbiByZW11eEF1ZGlvKHRyYWNrLCB0aW1lT2Zmc2V0LCBjb250aWd1b3VzLCBhY2N1cmF0ZVRpbWVPZmZzZXQsIHZpZGVvVGltZU9mZnNldCkge1xuICAgIHZhciBpbnB1dFRpbWVTY2FsZSA9IHRyYWNrLmlucHV0VGltZVNjYWxlO1xuICAgIHZhciBtcDR0aW1lU2NhbGUgPSB0cmFjay5zYW1wbGVyYXRlID8gdHJhY2suc2FtcGxlcmF0ZSA6IGlucHV0VGltZVNjYWxlO1xuICAgIHZhciBzY2FsZUZhY3RvciA9IGlucHV0VGltZVNjYWxlIC8gbXA0dGltZVNjYWxlO1xuICAgIHZhciBtcDRTYW1wbGVEdXJhdGlvbiA9IHRyYWNrLmlzQUFDID8gQUFDX1NBTVBMRVNfUEVSX0ZSQU1FIDogTVBFR19BVURJT19TQU1QTEVfUEVSX0ZSQU1FO1xuICAgIHZhciBpbnB1dFNhbXBsZUR1cmF0aW9uID0gbXA0U2FtcGxlRHVyYXRpb24gKiBzY2FsZUZhY3RvcjtcbiAgICB2YXIgaW5pdFBUUyA9IHRoaXMuX2luaXRQVFM7XG4gICAgdmFyIHJhd01QRUcgPSAhdHJhY2suaXNBQUMgJiYgdGhpcy50eXBlU3VwcG9ydGVkLm1wZWc7XG4gICAgdmFyIG91dHB1dFNhbXBsZXMgPSBbXTtcbiAgICB2YXIgaW5wdXRTYW1wbGVzID0gdHJhY2suc2FtcGxlcztcbiAgICB2YXIgb2Zmc2V0ID0gcmF3TVBFRyA/IDAgOiA4O1xuICAgIHZhciBuZXh0QXVkaW9QdHMgPSB0aGlzLm5leHRBdWRpb1B0cyB8fCAtMTsgLy8gd2luZG93LmF1ZGlvU2FtcGxlcyA/IHdpbmRvdy5hdWRpb1NhbXBsZXMucHVzaChpbnB1dFNhbXBsZXMubWFwKHMgPT4gcy5wdHMpKSA6ICh3aW5kb3cuYXVkaW9TYW1wbGVzID0gW2lucHV0U2FtcGxlcy5tYXAocyA9PiBzLnB0cyldKTtcbiAgICAvLyBmb3IgYXVkaW8gc2FtcGxlcywgYWxzbyBjb25zaWRlciBjb25zZWN1dGl2ZSBmcmFnbWVudHMgYXMgYmVpbmcgY29udGlndW91cyAoZXZlbiBpZiBhIGxldmVsIHN3aXRjaCBvY2N1cnMpLFxuICAgIC8vIGZvciBzYWtlIG9mIGNsYXJpdHk6XG4gICAgLy8gY29uc2VjdXRpdmUgZnJhZ21lbnRzIGFyZSBmcmFncyB3aXRoXG4gICAgLy8gIC0gbGVzcyB0aGFuIDEwMG1zIGdhcHMgYmV0d2VlbiBuZXcgdGltZSBvZmZzZXQgKGlmIGFjY3VyYXRlKSBhbmQgbmV4dCBleHBlY3RlZCBQVFMgT1JcbiAgICAvLyAgLSBsZXNzIHRoYW4gMjAgYXVkaW8gZnJhbWVzIGRpc3RhbmNlXG4gICAgLy8gY29udGlndW91cyBmcmFnbWVudHMgYXJlIGNvbnNlY3V0aXZlIGZyYWdtZW50cyBmcm9tIHNhbWUgcXVhbGl0eSBsZXZlbCAoc2FtZSBsZXZlbCwgbmV3IFNOID0gb2xkIFNOICsgMSlcbiAgICAvLyB0aGlzIGhlbHBzIGVuc3VyaW5nIGF1ZGlvIGNvbnRpbnVpdHlcbiAgICAvLyBhbmQgdGhpcyBhbHNvIGF2b2lkcyBhdWRpbyBnbGl0Y2hlcy9jdXQgd2hlbiBzd2l0Y2hpbmcgcXVhbGl0eSwgb3IgcmVwb3J0aW5nIHdyb25nIGR1cmF0aW9uIG9uIGZpcnN0IGF1ZGlvIGZyYW1lXG5cbiAgICB2YXIgdGltZU9mZnNldE1wZWdUUyA9IHRpbWVPZmZzZXQgKiBpbnB1dFRpbWVTY2FsZTtcbiAgICB0aGlzLmlzQXVkaW9Db250aWd1b3VzID0gY29udGlndW91cyA9IGNvbnRpZ3VvdXMgfHwgaW5wdXRTYW1wbGVzLmxlbmd0aCAmJiBuZXh0QXVkaW9QdHMgPiAwICYmIChhY2N1cmF0ZVRpbWVPZmZzZXQgJiYgTWF0aC5hYnModGltZU9mZnNldE1wZWdUUyAtIG5leHRBdWRpb1B0cykgPCA5MDAwIHx8IE1hdGguYWJzKG5vcm1hbGl6ZVB0cyhpbnB1dFNhbXBsZXNbMF0ucHRzIC0gaW5pdFBUUywgdGltZU9mZnNldE1wZWdUUykgLSBuZXh0QXVkaW9QdHMpIDwgMjAgKiBpbnB1dFNhbXBsZUR1cmF0aW9uKTsgLy8gY29tcHV0ZSBub3JtYWxpemVkIFBUU1xuXG4gICAgaW5wdXRTYW1wbGVzLmZvckVhY2goZnVuY3Rpb24gKHNhbXBsZSkge1xuICAgICAgc2FtcGxlLnB0cyA9IG5vcm1hbGl6ZVB0cyhzYW1wbGUucHRzIC0gaW5pdFBUUywgdGltZU9mZnNldE1wZWdUUyk7XG4gICAgfSk7XG5cbiAgICBpZiAoIWNvbnRpZ3VvdXMgfHwgbmV4dEF1ZGlvUHRzIDwgMCkge1xuICAgICAgLy8gZmlsdGVyIG91dCBzYW1wbGUgd2l0aCBuZWdhdGl2ZSBQVFMgdGhhdCBhcmUgbm90IHBsYXlhYmxlIGFueXdheVxuICAgICAgLy8gaWYgd2UgZG9uJ3QgcmVtb3ZlIHRoZXNlIG5lZ2F0aXZlIHNhbXBsZXMsIHRoZXkgd2lsbCBzaGlmdCBhbGwgYXVkaW8gc2FtcGxlcyBmb3J3YXJkLlxuICAgICAgLy8gbGVhZGluZyB0byBhdWRpbyBvdmVybGFwIGJldHdlZW4gY3VycmVudCAvIG5leHQgZnJhZ21lbnRcbiAgICAgIGlucHV0U2FtcGxlcyA9IGlucHV0U2FtcGxlcy5maWx0ZXIoZnVuY3Rpb24gKHNhbXBsZSkge1xuICAgICAgICByZXR1cm4gc2FtcGxlLnB0cyA+PSAwO1xuICAgICAgfSk7IC8vIGluIGNhc2UgYWxsIHNhbXBsZXMgaGF2ZSBuZWdhdGl2ZSBQVFMsIGFuZCBoYXZlIGJlZW4gZmlsdGVyZWQgb3V0LCByZXR1cm4gbm93XG5cbiAgICAgIGlmICghaW5wdXRTYW1wbGVzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh2aWRlb1RpbWVPZmZzZXQgPT09IDApIHtcbiAgICAgICAgLy8gU2V0IHRoZSBzdGFydCB0byAwIHRvIG1hdGNoIHZpZGVvIHNvIHRoYXQgc3RhcnQgZ2FwcyBsYXJnZXIgdGhhbiBpbnB1dFNhbXBsZUR1cmF0aW9uIGFyZSBmaWxsZWQgd2l0aCBzaWxlbmNlXG4gICAgICAgIG5leHRBdWRpb1B0cyA9IDA7XG4gICAgICB9IGVsc2UgaWYgKGFjY3VyYXRlVGltZU9mZnNldCkge1xuICAgICAgICAvLyBXaGVuIG5vdCBzZWVraW5nLCBub3QgbGl2ZSwgYW5kIExldmVsRGV0YWlscy5QVFNLbm93biwgdXNlIGZyYWdtZW50IHN0YXJ0IGFzIHByZWRpY3RlZCBuZXh0IGF1ZGlvIFBUU1xuICAgICAgICBuZXh0QXVkaW9QdHMgPSBNYXRoLm1heCgwLCB0aW1lT2Zmc2V0TXBlZ1RTKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGlmIGZyYWdzIGFyZSBub3QgY29udGlndW91cyBhbmQgaWYgd2UgY2FudCB0cnVzdCB0aW1lIG9mZnNldCwgbGV0J3MgdXNlIGZpcnN0IHNhbXBsZSBQVFMgYXMgbmV4dCBhdWRpbyBQVFNcbiAgICAgICAgbmV4dEF1ZGlvUHRzID0gaW5wdXRTYW1wbGVzWzBdLnB0cztcbiAgICAgIH1cbiAgICB9IC8vIElmIHRoZSBhdWRpbyB0cmFjayBpcyBtaXNzaW5nIHNhbXBsZXMsIHRoZSBmcmFtZXMgc2VlbSB0byBnZXQgXCJsZWZ0LXNoaWZ0ZWRcIiB3aXRoaW4gdGhlXG4gICAgLy8gcmVzdWx0aW5nIG1wNCBzZWdtZW50LCBjYXVzaW5nIHN5bmMgaXNzdWVzIGFuZCBsZWF2aW5nIGdhcHMgYXQgdGhlIGVuZCBvZiB0aGUgYXVkaW8gc2VnbWVudC5cbiAgICAvLyBJbiBhbiBlZmZvcnQgdG8gcHJldmVudCB0aGlzIGZyb20gaGFwcGVuaW5nLCB3ZSBpbmplY3QgZnJhbWVzIGhlcmUgd2hlcmUgdGhlcmUgYXJlIGdhcHMuXG4gICAgLy8gV2hlbiBwb3NzaWJsZSwgd2UgaW5qZWN0IGEgc2lsZW50IGZyYW1lOyB3aGVuIHRoYXQncyBub3QgcG9zc2libGUsIHdlIGR1cGxpY2F0ZSB0aGUgbGFzdFxuICAgIC8vIGZyYW1lLlxuXG5cbiAgICBpZiAodHJhY2suaXNBQUMpIHtcbiAgICAgIHZhciBhbGlnbmVkV2l0aFZpZGVvID0gdmlkZW9UaW1lT2Zmc2V0ICE9PSB1bmRlZmluZWQ7XG4gICAgICB2YXIgbWF4QXVkaW9GcmFtZXNEcmlmdCA9IHRoaXMuY29uZmlnLm1heEF1ZGlvRnJhbWVzRHJpZnQ7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBuZXh0UHRzID0gbmV4dEF1ZGlvUHRzOyBpIDwgaW5wdXRTYW1wbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIEZpcnN0LCBsZXQncyBzZWUgaG93IGZhciBvZmYgdGhpcyBmcmFtZSBpcyBmcm9tIHdoZXJlIHdlIGV4cGVjdCBpdCB0byBiZVxuICAgICAgICB2YXIgc2FtcGxlID0gaW5wdXRTYW1wbGVzW2ldO1xuICAgICAgICB2YXIgcHRzID0gc2FtcGxlLnB0cztcbiAgICAgICAgdmFyIGRlbHRhID0gcHRzIC0gbmV4dFB0cztcbiAgICAgICAgdmFyIGR1cmF0aW9uID0gTWF0aC5hYnMoMTAwMCAqIGRlbHRhIC8gaW5wdXRUaW1lU2NhbGUpOyAvLyBXaGVuIHJlbXV4aW5nIHdpdGggdmlkZW8sIGlmIHdlJ3JlIG92ZXJsYXBwaW5nIGJ5IG1vcmUgdGhhbiBhIGR1cmF0aW9uLCBkcm9wIHRoaXMgc2FtcGxlIHRvIHN0YXkgaW4gc3luY1xuXG4gICAgICAgIGlmIChkZWx0YSA8PSAtbWF4QXVkaW9GcmFtZXNEcmlmdCAqIGlucHV0U2FtcGxlRHVyYXRpb24gJiYgYWxpZ25lZFdpdGhWaWRlbykge1xuICAgICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXCJsb2dnZXJcIl0ud2FybihcIkF1ZGlvIGZyYW1lIEAgXCIgKyAocHRzIC8gaW5wdXRUaW1lU2NhbGUpLnRvRml4ZWQoMykgKyBcInMgb3ZlcmxhcHMgbmV4dEF1ZGlvUHRzIGJ5IFwiICsgTWF0aC5yb3VuZCgxMDAwICogZGVsdGEgLyBpbnB1dFRpbWVTY2FsZSkgKyBcIiBtcy5cIik7XG4gICAgICAgICAgICB0aGlzLm5leHRBdWRpb1B0cyA9IG5leHRBdWRpb1B0cyA9IG5leHRQdHMgPSBwdHM7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgYnJhY2Utc3R5bGVcbiAgICAgICAgLy8gSW5zZXJ0IG1pc3NpbmcgZnJhbWVzIGlmOlxuICAgICAgICAvLyAxOiBXZSdyZSBtb3JlIHRoYW4gbWF4QXVkaW9GcmFtZXNEcmlmdCBmcmFtZSBhd2F5XG4gICAgICAgIC8vIDI6IE5vdCBtb3JlIHRoYW4gTUFYX1NJTEVOVF9GUkFNRV9EVVJBVElPTiBhd2F5XG4gICAgICAgIC8vIDM6IGN1cnJlbnRUaW1lIChha2EgbmV4dFB0c05vcm0pIGlzIG5vdCAwXG4gICAgICAgIC8vIDQ6IHJlbXV4aW5nIHdpdGggdmlkZW8gKHZpZGVvVGltZU9mZnNldCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICBlbHNlIGlmIChkZWx0YSA+PSBtYXhBdWRpb0ZyYW1lc0RyaWZ0ICogaW5wdXRTYW1wbGVEdXJhdGlvbiAmJiBkdXJhdGlvbiA8IE1BWF9TSUxFTlRfRlJBTUVfRFVSQVRJT04gJiYgYWxpZ25lZFdpdGhWaWRlbykge1xuICAgICAgICAgIHZhciBtaXNzaW5nID0gTWF0aC5yb3VuZChkZWx0YSAvIGlucHV0U2FtcGxlRHVyYXRpb24pOyAvLyBBZGp1c3QgbmV4dFB0cyBzbyB0aGF0IHNpbGVudCBzYW1wbGVzIGFyZSBhbGlnbmVkIHdpdGggbWVkaWEgcHRzLiBUaGlzIHdpbGwgcHJldmVudCBtZWRpYSBzYW1wbGVzIGZyb21cbiAgICAgICAgICAvLyBsYXRlciBiZWluZyBzaGlmdGVkIGlmIG5leHRQdHMgaXMgYmFzZWQgb24gdGltZU9mZnNldCBhbmQgZGVsdGEgaXMgbm90IGEgbXVsdGlwbGUgb2YgaW5wdXRTYW1wbGVEdXJhdGlvbi5cblxuICAgICAgICAgIG5leHRQdHMgPSBwdHMgLSBtaXNzaW5nICogaW5wdXRTYW1wbGVEdXJhdGlvbjtcblxuICAgICAgICAgIGlmIChuZXh0UHRzIDwgMCkge1xuICAgICAgICAgICAgbWlzc2luZy0tO1xuICAgICAgICAgICAgbmV4dFB0cyArPSBpbnB1dFNhbXBsZUR1cmF0aW9uO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLm5leHRBdWRpb1B0cyA9IG5leHRBdWRpb1B0cyA9IG5leHRQdHM7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1wibG9nZ2VyXCJdLndhcm4oXCJbbXA0LXJlbXV4ZXJdOiBJbmplY3RpbmcgXCIgKyBtaXNzaW5nICsgXCIgYXVkaW8gZnJhbWUgQCBcIiArIChuZXh0UHRzIC8gaW5wdXRUaW1lU2NhbGUpLnRvRml4ZWQoMykgKyBcInMgZHVlIHRvIFwiICsgTWF0aC5yb3VuZCgxMDAwICogZGVsdGEgLyBpbnB1dFRpbWVTY2FsZSkgKyBcIiBtcyBnYXAuXCIpO1xuXG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtaXNzaW5nOyBqKyspIHtcbiAgICAgICAgICAgIHZhciBuZXdTdGFtcCA9IE1hdGgubWF4KG5leHRQdHMsIDApO1xuICAgICAgICAgICAgdmFyIGZpbGxGcmFtZSA9IF9hYWNfaGVscGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJkZWZhdWx0XCJdLmdldFNpbGVudEZyYW1lKHRyYWNrLm1hbmlmZXN0Q29kZWMgfHwgdHJhY2suY29kZWMsIHRyYWNrLmNoYW5uZWxDb3VudCk7XG5cbiAgICAgICAgICAgIGlmICghZmlsbEZyYW1lKSB7XG4gICAgICAgICAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcImxvZ2dlclwiXS5sb2coJ1ttcDQtcmVtdXhlcl06IFVuYWJsZSB0byBnZXQgc2lsZW50IGZyYW1lIGZvciBnaXZlbiBhdWRpbyBjb2RlYzsgZHVwbGljYXRpbmcgbGFzdCBmcmFtZSBpbnN0ZWFkLicpO1xuICAgICAgICAgICAgICBmaWxsRnJhbWUgPSBzYW1wbGUudW5pdC5zdWJhcnJheSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpbnB1dFNhbXBsZXMuc3BsaWNlKGksIDAsIHtcbiAgICAgICAgICAgICAgdW5pdDogZmlsbEZyYW1lLFxuICAgICAgICAgICAgICBwdHM6IG5ld1N0YW1wXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG5leHRQdHMgKz0gaW5wdXRTYW1wbGVEdXJhdGlvbjtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzYW1wbGUucHRzID0gbmV4dFB0cztcbiAgICAgICAgbmV4dFB0cyArPSBpbnB1dFNhbXBsZUR1cmF0aW9uO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBmaXJzdFBUUyA9IG51bGw7XG4gICAgdmFyIGxhc3RQVFMgPSBudWxsO1xuICAgIHZhciBtZGF0O1xuICAgIHZhciBtZGF0U2l6ZSA9IDA7XG4gICAgdmFyIHNhbXBsZUxlbmd0aCA9IGlucHV0U2FtcGxlcy5sZW5ndGg7XG5cbiAgICB3aGlsZSAoc2FtcGxlTGVuZ3RoLS0pIHtcbiAgICAgIG1kYXRTaXplICs9IGlucHV0U2FtcGxlc1tzYW1wbGVMZW5ndGhdLnVuaXQuYnl0ZUxlbmd0aDtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBfajIgPSAwLCBfbmJTYW1wbGVzID0gaW5wdXRTYW1wbGVzLmxlbmd0aDsgX2oyIDwgX25iU2FtcGxlczsgX2oyKyspIHtcbiAgICAgIHZhciBhdWRpb1NhbXBsZSA9IGlucHV0U2FtcGxlc1tfajJdO1xuICAgICAgdmFyIHVuaXQgPSBhdWRpb1NhbXBsZS51bml0O1xuICAgICAgdmFyIF9wdHMgPSBhdWRpb1NhbXBsZS5wdHM7XG5cbiAgICAgIGlmIChsYXN0UFRTICE9PSBudWxsKSB7XG4gICAgICAgIC8vIElmIHdlIGhhdmUgbW9yZSB0aGFuIG9uZSBzYW1wbGUsIHNldCB0aGUgZHVyYXRpb24gb2YgdGhlIHNhbXBsZSB0byB0aGUgXCJyZWFsXCIgZHVyYXRpb247IHRoZSBQVFMgZGlmZiB3aXRoXG4gICAgICAgIC8vIHRoZSBwcmV2aW91cyBzYW1wbGVcbiAgICAgICAgdmFyIHByZXZTYW1wbGUgPSBvdXRwdXRTYW1wbGVzW19qMiAtIDFdO1xuICAgICAgICBwcmV2U2FtcGxlLmR1cmF0aW9uID0gTWF0aC5yb3VuZCgoX3B0cyAtIGxhc3RQVFMpIC8gc2NhbGVGYWN0b3IpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGNvbnRpZ3VvdXMgJiYgdHJhY2suaXNBQUMpIHtcbiAgICAgICAgICAvLyBzZXQgUFRTL0RUUyB0byBleHBlY3RlZCBQVFMvRFRTXG4gICAgICAgICAgX3B0cyA9IG5leHRBdWRpb1B0cztcbiAgICAgICAgfSAvLyByZW1lbWJlciBmaXJzdCBQVFMgb2Ygb3VyIGF1ZGlvU2FtcGxlc1xuXG5cbiAgICAgICAgZmlyc3RQVFMgPSBfcHRzO1xuXG4gICAgICAgIGlmIChtZGF0U2l6ZSA+IDApIHtcbiAgICAgICAgICAvKiBjb25jYXRlbmF0ZSB0aGUgYXVkaW8gZGF0YSBhbmQgY29uc3RydWN0IHRoZSBtZGF0IGluIHBsYWNlXG4gICAgICAgICAgICAobmVlZCA4IG1vcmUgYnl0ZXMgdG8gZmlsbCBsZW5ndGggYW5kIG1kYXQgdHlwZSkgKi9cbiAgICAgICAgICBtZGF0U2l6ZSArPSBvZmZzZXQ7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgbWRhdCA9IG5ldyBVaW50OEFycmF5KG1kYXRTaXplKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZXIuZW1pdChfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJFdmVudHNcIl0uRVJST1IsIF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcIkV2ZW50c1wiXS5FUlJPUiwge1xuICAgICAgICAgICAgICB0eXBlOiBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXCJFcnJvclR5cGVzXCJdLk1VWF9FUlJPUixcbiAgICAgICAgICAgICAgZGV0YWlsczogX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fW1wiRXJyb3JEZXRhaWxzXCJdLlJFTVVYX0FMTE9DX0VSUk9SLFxuICAgICAgICAgICAgICBmYXRhbDogZmFsc2UsXG4gICAgICAgICAgICAgIGJ5dGVzOiBtZGF0U2l6ZSxcbiAgICAgICAgICAgICAgcmVhc29uOiBcImZhaWwgYWxsb2NhdGluZyBhdWRpbyBtZGF0IFwiICsgbWRhdFNpemVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghcmF3TVBFRykge1xuICAgICAgICAgICAgdmFyIHZpZXcgPSBuZXcgRGF0YVZpZXcobWRhdC5idWZmZXIpO1xuICAgICAgICAgICAgdmlldy5zZXRVaW50MzIoMCwgbWRhdFNpemUpO1xuICAgICAgICAgICAgbWRhdC5zZXQoX21wNF9nZW5lcmF0b3JfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImRlZmF1bHRcIl0udHlwZXMubWRhdCwgNCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIG5vIGF1ZGlvIHNhbXBsZXNcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbWRhdC5zZXQodW5pdCwgb2Zmc2V0KTtcbiAgICAgIHZhciB1bml0TGVuID0gdW5pdC5ieXRlTGVuZ3RoO1xuICAgICAgb2Zmc2V0ICs9IHVuaXRMZW47IC8vIERlZmF1bHQgdGhlIHNhbXBsZSdzIGR1cmF0aW9uIHRvIHRoZSBjb21wdXRlZCBtcDRTYW1wbGVEdXJhdGlvbiwgd2hpY2ggd2lsbCBlaXRoZXIgYmUgMTAyNCBmb3IgQUFDIG9yIDExNTIgZm9yIE1QRUdcbiAgICAgIC8vIEluIHRoZSBjYXNlIHRoYXQgd2UgaGF2ZSAxIHNhbXBsZSwgdGhpcyB3aWxsIGJlIHRoZSBkdXJhdGlvbi4gSWYgd2UgaGF2ZSBtb3JlIHRoYW4gb25lIHNhbXBsZSwgdGhlIGR1cmF0aW9uXG4gICAgICAvLyBiZWNvbWVzIHRoZSBQVFMgZGlmZiB3aXRoIHRoZSBwcmV2aW91cyBzYW1wbGVcblxuICAgICAgb3V0cHV0U2FtcGxlcy5wdXNoKG5ldyBNcDRTYW1wbGUodHJ1ZSwgbXA0U2FtcGxlRHVyYXRpb24sIHVuaXRMZW4sIDApKTtcbiAgICAgIGxhc3RQVFMgPSBfcHRzO1xuICAgIH0gLy8gV2UgY291bGQgZW5kIHVwIHdpdGggbm8gYXVkaW8gc2FtcGxlcyBpZiBhbGwgaW5wdXQgc2FtcGxlcyB3ZXJlIG92ZXJsYXBwaW5nIHdpdGggdGhlIHByZXZpb3VzbHkgcmVtdXhlZCBvbmVzXG5cblxuICAgIHZhciBuYlNhbXBsZXMgPSBvdXRwdXRTYW1wbGVzLmxlbmd0aDtcblxuICAgIGlmICghbmJTYW1wbGVzKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBUaGUgbmV4dCBhdWRpbyBzYW1wbGUgUFRTIHNob3VsZCBiZSBlcXVhbCB0byBsYXN0IHNhbXBsZSBQVFMgKyBkdXJhdGlvblxuXG5cbiAgICB2YXIgbGFzdFNhbXBsZSA9IG91dHB1dFNhbXBsZXNbb3V0cHV0U2FtcGxlcy5sZW5ndGggLSAxXTtcbiAgICB0aGlzLm5leHRBdWRpb1B0cyA9IG5leHRBdWRpb1B0cyA9IGxhc3RQVFMgKyBzY2FsZUZhY3RvciAqIGxhc3RTYW1wbGUuZHVyYXRpb247IC8vIFNldCB0aGUgdHJhY2sgc2FtcGxlcyBmcm9tIGlucHV0U2FtcGxlcyB0byBvdXRwdXRTYW1wbGVzIGJlZm9yZSByZW11eGluZ1xuXG4gICAgdmFyIG1vb2YgPSByYXdNUEVHID8gbmV3IFVpbnQ4QXJyYXkoMCkgOiBfbXA0X2dlbmVyYXRvcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiZGVmYXVsdFwiXS5tb29mKHRyYWNrLnNlcXVlbmNlTnVtYmVyKyssIGZpcnN0UFRTIC8gc2NhbGVGYWN0b3IsIF9leHRlbmRzKHt9LCB0cmFjaywge1xuICAgICAgc2FtcGxlczogb3V0cHV0U2FtcGxlc1xuICAgIH0pKTsgLy8gQ2xlYXIgdGhlIHRyYWNrIHNhbXBsZXMuIFRoaXMgYWxzbyBjbGVhcnMgdGhlIHNhbXBsZXMgYXJyYXkgaW4gdGhlIGRlbXV4ZXIsIHNpbmNlIHRoZSByZWZlcmVuY2UgaXMgc2hhcmVkXG5cbiAgICB0cmFjay5zYW1wbGVzID0gW107XG4gICAgdmFyIHN0YXJ0ID0gZmlyc3RQVFMgLyBpbnB1dFRpbWVTY2FsZTtcbiAgICB2YXIgZW5kID0gbmV4dEF1ZGlvUHRzIC8gaW5wdXRUaW1lU2NhbGU7XG4gICAgdmFyIHR5cGUgPSAnYXVkaW8nO1xuICAgIHZhciBhdWRpb0RhdGEgPSB7XG4gICAgICBkYXRhMTogbW9vZixcbiAgICAgIGRhdGEyOiBtZGF0LFxuICAgICAgc3RhcnRQVFM6IHN0YXJ0LFxuICAgICAgZW5kUFRTOiBlbmQsXG4gICAgICBzdGFydERUUzogc3RhcnQsXG4gICAgICBlbmREVFM6IGVuZCxcbiAgICAgIHR5cGU6IHR5cGUsXG4gICAgICBoYXNBdWRpbzogdHJ1ZSxcbiAgICAgIGhhc1ZpZGVvOiBmYWxzZSxcbiAgICAgIG5iOiBuYlNhbXBsZXNcbiAgICB9O1xuICAgIHRoaXMuaXNBdWRpb0NvbnRpZ3VvdXMgPSB0cnVlO1xuICAgIGNvbnNvbGUuYXNzZXJ0KG1kYXQubGVuZ3RoLCAnTURBVCBsZW5ndGggbXVzdCBub3QgYmUgemVybycpO1xuICAgIHJldHVybiBhdWRpb0RhdGE7XG4gIH07XG5cbiAgX3Byb3RvLnJlbXV4RW1wdHlBdWRpbyA9IGZ1bmN0aW9uIHJlbXV4RW1wdHlBdWRpbyh0cmFjaywgdGltZU9mZnNldCwgY29udGlndW91cywgdmlkZW9EYXRhKSB7XG4gICAgdmFyIGlucHV0VGltZVNjYWxlID0gdHJhY2suaW5wdXRUaW1lU2NhbGU7XG4gICAgdmFyIG1wNHRpbWVTY2FsZSA9IHRyYWNrLnNhbXBsZXJhdGUgPyB0cmFjay5zYW1wbGVyYXRlIDogaW5wdXRUaW1lU2NhbGU7XG4gICAgdmFyIHNjYWxlRmFjdG9yID0gaW5wdXRUaW1lU2NhbGUgLyBtcDR0aW1lU2NhbGU7XG4gICAgdmFyIG5leHRBdWRpb1B0cyA9IHRoaXMubmV4dEF1ZGlvUHRzOyAvLyBzeW5jIHdpdGggdmlkZW8ncyB0aW1lc3RhbXBcblxuICAgIHZhciBzdGFydERUUyA9IChuZXh0QXVkaW9QdHMgIT09IG51bGwgPyBuZXh0QXVkaW9QdHMgOiB2aWRlb0RhdGEuc3RhcnREVFMgKiBpbnB1dFRpbWVTY2FsZSkgKyB0aGlzLl9pbml0RFRTO1xuICAgIHZhciBlbmREVFMgPSB2aWRlb0RhdGEuZW5kRFRTICogaW5wdXRUaW1lU2NhbGUgKyB0aGlzLl9pbml0RFRTOyAvLyBvbmUgc2FtcGxlJ3MgZHVyYXRpb24gdmFsdWVcblxuICAgIHZhciBmcmFtZUR1cmF0aW9uID0gc2NhbGVGYWN0b3IgKiBBQUNfU0FNUExFU19QRVJfRlJBTUU7IC8vIHNhbXBsZXMgY291bnQgb2YgdGhpcyBzZWdtZW50J3MgZHVyYXRpb25cblxuICAgIHZhciBuYlNhbXBsZXMgPSBNYXRoLmNlaWwoKGVuZERUUyAtIHN0YXJ0RFRTKSAvIGZyYW1lRHVyYXRpb24pOyAvLyBzaWxlbnQgZnJhbWVcblxuICAgIHZhciBzaWxlbnRGcmFtZSA9IF9hYWNfaGVscGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJkZWZhdWx0XCJdLmdldFNpbGVudEZyYW1lKHRyYWNrLm1hbmlmZXN0Q29kZWMgfHwgdHJhY2suY29kZWMsIHRyYWNrLmNoYW5uZWxDb3VudCk7XG4gICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1wibG9nZ2VyXCJdLndhcm4oJ1ttcDQtcmVtdXhlcl06IHJlbXV4IGVtcHR5IEF1ZGlvJyk7IC8vIENhbid0IHJlbXV4IGlmIHdlIGNhbid0IGdlbmVyYXRlIGEgc2lsZW50IGZyYW1lLi4uXG5cbiAgICBpZiAoIXNpbGVudEZyYW1lKSB7XG4gICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXCJsb2dnZXJcIl0udHJhY2UoJ1ttcDQtcmVtdXhlcl06IFVuYWJsZSB0byByZW11eEVtcHR5QXVkaW8gc2luY2Ugd2Ugd2VyZSB1bmFibGUgdG8gZ2V0IGEgc2lsZW50IGZyYW1lIGZvciBnaXZlbiBhdWRpbyBjb2RlYycpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBzYW1wbGVzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5iU2FtcGxlczsgaSsrKSB7XG4gICAgICB2YXIgc3RhbXAgPSBzdGFydERUUyArIGkgKiBmcmFtZUR1cmF0aW9uO1xuICAgICAgc2FtcGxlcy5wdXNoKHtcbiAgICAgICAgdW5pdDogc2lsZW50RnJhbWUsXG4gICAgICAgIHB0czogc3RhbXAsXG4gICAgICAgIGR0czogc3RhbXBcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRyYWNrLnNhbXBsZXMgPSBzYW1wbGVzO1xuICAgIHJldHVybiB0aGlzLnJlbXV4QXVkaW8odHJhY2ssIHRpbWVPZmZzZXQsIGNvbnRpZ3VvdXMsIGZhbHNlKTtcbiAgfTtcblxuICBfcHJvdG8ucmVtdXhJRDMgPSBmdW5jdGlvbiByZW11eElEMyh0cmFjaywgdGltZU9mZnNldCkge1xuICAgIHZhciBsZW5ndGggPSB0cmFjay5zYW1wbGVzLmxlbmd0aDtcblxuICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGlucHV0VGltZVNjYWxlID0gdHJhY2suaW5wdXRUaW1lU2NhbGU7XG4gICAgdmFyIGluaXRQVFMgPSB0aGlzLl9pbml0UFRTO1xuICAgIHZhciBpbml0RFRTID0gdGhpcy5faW5pdERUUztcblxuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIHZhciBzYW1wbGUgPSB0cmFjay5zYW1wbGVzW2luZGV4XTsgLy8gc2V0dGluZyBpZDMgcHRzLCBkdHMgdG8gcmVsYXRpdmUgdGltZVxuICAgICAgLy8gdXNpbmcgdGhpcy5faW5pdFBUUyBhbmQgdGhpcy5faW5pdERUUyB0byBjYWxjdWxhdGUgcmVsYXRpdmUgdGltZVxuXG4gICAgICBzYW1wbGUucHRzID0gbm9ybWFsaXplUHRzKHNhbXBsZS5wdHMgLSBpbml0UFRTLCB0aW1lT2Zmc2V0ICogaW5wdXRUaW1lU2NhbGUpIC8gaW5wdXRUaW1lU2NhbGU7XG4gICAgICBzYW1wbGUuZHRzID0gbm9ybWFsaXplUHRzKHNhbXBsZS5kdHMgLSBpbml0RFRTLCB0aW1lT2Zmc2V0ICogaW5wdXRUaW1lU2NhbGUpIC8gaW5wdXRUaW1lU2NhbGU7XG4gICAgfVxuXG4gICAgdmFyIHNhbXBsZXMgPSB0cmFjay5zYW1wbGVzO1xuICAgIHRyYWNrLnNhbXBsZXMgPSBbXTtcbiAgICByZXR1cm4ge1xuICAgICAgc2FtcGxlczogc2FtcGxlc1xuICAgIH07XG4gIH07XG5cbiAgX3Byb3RvLnJlbXV4VGV4dCA9IGZ1bmN0aW9uIHJlbXV4VGV4dCh0cmFjaywgdGltZU9mZnNldCkge1xuICAgIHZhciBsZW5ndGggPSB0cmFjay5zYW1wbGVzLmxlbmd0aDtcblxuICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGlucHV0VGltZVNjYWxlID0gdHJhY2suaW5wdXRUaW1lU2NhbGU7XG4gICAgdmFyIGluaXRQVFMgPSB0aGlzLl9pbml0UFRTO1xuXG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgdmFyIHNhbXBsZSA9IHRyYWNrLnNhbXBsZXNbaW5kZXhdOyAvLyBzZXR0aW5nIHRleHQgcHRzLCBkdHMgdG8gcmVsYXRpdmUgdGltZVxuICAgICAgLy8gdXNpbmcgdGhpcy5faW5pdFBUUyBhbmQgdGhpcy5faW5pdERUUyB0byBjYWxjdWxhdGUgcmVsYXRpdmUgdGltZVxuXG4gICAgICBzYW1wbGUucHRzID0gbm9ybWFsaXplUHRzKHNhbXBsZS5wdHMgLSBpbml0UFRTLCB0aW1lT2Zmc2V0ICogaW5wdXRUaW1lU2NhbGUpIC8gaW5wdXRUaW1lU2NhbGU7XG4gICAgfVxuXG4gICAgdHJhY2suc2FtcGxlcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gYS5wdHMgLSBiLnB0cztcbiAgICB9KTtcbiAgICB2YXIgc2FtcGxlcyA9IHRyYWNrLnNhbXBsZXM7XG4gICAgdHJhY2suc2FtcGxlcyA9IFtdO1xuICAgIHJldHVybiB7XG4gICAgICBzYW1wbGVzOiBzYW1wbGVzXG4gICAgfTtcbiAgfTtcblxuICByZXR1cm4gTVA0UmVtdXhlcjtcbn0oKTtcblxuXG5mdW5jdGlvbiBub3JtYWxpemVQdHModmFsdWUsIHJlZmVyZW5jZSkge1xuICB2YXIgb2Zmc2V0O1xuXG4gIGlmIChyZWZlcmVuY2UgPT09IG51bGwpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICBpZiAocmVmZXJlbmNlIDwgdmFsdWUpIHtcbiAgICAvLyAtIDJeMzNcbiAgICBvZmZzZXQgPSAtODU4OTkzNDU5MjtcbiAgfSBlbHNlIHtcbiAgICAvLyArIDJeMzNcbiAgICBvZmZzZXQgPSA4NTg5OTM0NTkyO1xuICB9XG4gIC8qIFBUUyBpcyAzM2JpdCAoZnJvbSAwIHRvIDJeMzMgLTEpXG4gICAgaWYgZGlmZiBiZXR3ZWVuIHZhbHVlIGFuZCByZWZlcmVuY2UgaXMgYmlnZ2VyIHRoYW4gaGFsZiBvZiB0aGUgYW1wbGl0dWRlICgyXjMyKSB0aGVuIGl0IG1lYW5zIHRoYXRcbiAgICBQVFMgbG9vcGluZyBvY2N1cmVkLiBmaWxsIHRoZSBnYXAgKi9cblxuXG4gIHdoaWxlIChNYXRoLmFicyh2YWx1ZSAtIHJlZmVyZW5jZSkgPiA0Mjk0OTY3Mjk2KSB7XG4gICAgdmFsdWUgKz0gb2Zmc2V0O1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiBmaW5kS2V5ZnJhbWVJbmRleChzYW1wbGVzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc2FtcGxlcy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChzYW1wbGVzW2ldLmtleSkge1xuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xO1xufVxuXG52YXIgTXA0U2FtcGxlID0gZnVuY3Rpb24gTXA0U2FtcGxlKGlzS2V5ZnJhbWUsIGR1cmF0aW9uLCBzaXplLCBjdHMpIHtcbiAgdGhpcy5zaXplID0gdm9pZCAwO1xuICB0aGlzLmR1cmF0aW9uID0gdm9pZCAwO1xuICB0aGlzLmN0cyA9IHZvaWQgMDtcbiAgdGhpcy5mbGFncyA9IHZvaWQgMDtcbiAgdGhpcy5kdXJhdGlvbiA9IGR1cmF0aW9uO1xuICB0aGlzLnNpemUgPSBzaXplO1xuICB0aGlzLmN0cyA9IGN0cztcbiAgdGhpcy5mbGFncyA9IG5ldyBNcDRTYW1wbGVGbGFncyhpc0tleWZyYW1lKTtcbn07XG5cbnZhciBNcDRTYW1wbGVGbGFncyA9IGZ1bmN0aW9uIE1wNFNhbXBsZUZsYWdzKGlzS2V5ZnJhbWUpIHtcbiAgdGhpcy5pc0xlYWRpbmcgPSAwO1xuICB0aGlzLmlzRGVwZW5kZWRPbiA9IDA7XG4gIHRoaXMuaGFzUmVkdW5kYW5jeSA9IDA7XG4gIHRoaXMuZGVncmFkUHJpbyA9IDA7XG4gIHRoaXMuZGVwZW5kc09uID0gMTtcbiAgdGhpcy5pc05vblN5bmMgPSAxO1xuICB0aGlzLmRlcGVuZHNPbiA9IGlzS2V5ZnJhbWUgPyAyIDogMTtcbiAgdGhpcy5pc05vblN5bmMgPSBpc0tleWZyYW1lID8gMCA6IDE7XG59O1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9yZW11eC9wYXNzdGhyb3VnaC1yZW11eGVyLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvcmVtdXgvcGFzc3Rocm91Z2gtcmVtdXhlci50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2hvbWVfcnVubmVyX3dvcmtfaGxzX2pzX2hsc19qc19zcmNfcG9seWZpbGxzX251bWJlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zcmMvcG9seWZpbGxzL251bWJlciAqLyBcIi4vc3JjL3BvbHlmaWxscy9udW1iZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX21wNF90b29sc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvbXA0LXRvb2xzICovIFwiLi9zcmMvdXRpbHMvbXA0LXRvb2xzLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9sb2FkZXJfZnJhZ21lbnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2xvYWRlci9mcmFnbWVudCAqLyBcIi4vc3JjL2xvYWRlci9mcmFnbWVudC50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9sb2dnZXIgKi8gXCIuL3NyYy91dGlscy9sb2dnZXIudHNcIik7XG5cblxuXG5cblxuXG52YXIgUGFzc1Rocm91Z2hSZW11eGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUGFzc1Rocm91Z2hSZW11eGVyKCkge1xuICAgIHRoaXMuZW1pdEluaXRTZWdtZW50ID0gZmFsc2U7XG4gICAgdGhpcy5hdWRpb0NvZGVjID0gdm9pZCAwO1xuICAgIHRoaXMudmlkZW9Db2RlYyA9IHZvaWQgMDtcbiAgICB0aGlzLmluaXREYXRhID0gdm9pZCAwO1xuICAgIHRoaXMuaW5pdFBUUyA9IHZvaWQgMDtcbiAgICB0aGlzLmluaXRUcmFja3MgPSB2b2lkIDA7XG4gICAgdGhpcy5sYXN0RW5kRFRTID0gbnVsbDtcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBQYXNzVGhyb3VnaFJlbXV4ZXIucHJvdG90eXBlO1xuXG4gIF9wcm90by5kZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveSgpIHt9O1xuXG4gIF9wcm90by5yZXNldFRpbWVTdGFtcCA9IGZ1bmN0aW9uIHJlc2V0VGltZVN0YW1wKGRlZmF1bHRJbml0UFRTKSB7XG4gICAgdGhpcy5pbml0UFRTID0gZGVmYXVsdEluaXRQVFM7XG4gICAgdGhpcy5sYXN0RW5kRFRTID0gbnVsbDtcbiAgfTtcblxuICBfcHJvdG8ucmVzZXROZXh0VGltZXN0YW1wID0gZnVuY3Rpb24gcmVzZXROZXh0VGltZXN0YW1wKCkge1xuICAgIHRoaXMubGFzdEVuZERUUyA9IG51bGw7XG4gIH07XG5cbiAgX3Byb3RvLnJlc2V0SW5pdFNlZ21lbnQgPSBmdW5jdGlvbiByZXNldEluaXRTZWdtZW50KGluaXRTZWdtZW50LCBhdWRpb0NvZGVjLCB2aWRlb0NvZGVjKSB7XG4gICAgdGhpcy5hdWRpb0NvZGVjID0gYXVkaW9Db2RlYztcbiAgICB0aGlzLnZpZGVvQ29kZWMgPSB2aWRlb0NvZGVjO1xuICAgIHRoaXMuZ2VuZXJhdGVJbml0U2VnbWVudChpbml0U2VnbWVudCk7XG4gICAgdGhpcy5lbWl0SW5pdFNlZ21lbnQgPSB0cnVlO1xuICB9O1xuXG4gIF9wcm90by5nZW5lcmF0ZUluaXRTZWdtZW50ID0gZnVuY3Rpb24gZ2VuZXJhdGVJbml0U2VnbWVudChpbml0U2VnbWVudCkge1xuICAgIHZhciBhdWRpb0NvZGVjID0gdGhpcy5hdWRpb0NvZGVjLFxuICAgICAgICB2aWRlb0NvZGVjID0gdGhpcy52aWRlb0NvZGVjO1xuXG4gICAgaWYgKCFpbml0U2VnbWVudCB8fCAhaW5pdFNlZ21lbnQuYnl0ZUxlbmd0aCkge1xuICAgICAgdGhpcy5pbml0VHJhY2tzID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5pbml0RGF0YSA9IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgaW5pdERhdGEgPSB0aGlzLmluaXREYXRhID0gT2JqZWN0KF91dGlsc19tcDRfdG9vbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcInBhcnNlSW5pdFNlZ21lbnRcIl0pKGluaXRTZWdtZW50KTsgLy8gR2V0IGNvZGVjIGZyb20gaW5pdFNlZ21lbnQgb3IgZmFsbGJhY2sgdG8gZGVmYXVsdFxuXG4gICAgaWYgKCFhdWRpb0NvZGVjKSB7XG4gICAgICBhdWRpb0NvZGVjID0gZ2V0UGFyc2VkVHJhY2tDb2RlYyhpbml0RGF0YS5hdWRpbywgX2xvYWRlcl9mcmFnbWVudF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiRWxlbWVudGFyeVN0cmVhbVR5cGVzXCJdLkFVRElPKTtcbiAgICB9XG5cbiAgICBpZiAoIXZpZGVvQ29kZWMpIHtcbiAgICAgIHZpZGVvQ29kZWMgPSBnZXRQYXJzZWRUcmFja0NvZGVjKGluaXREYXRhLnZpZGVvLCBfbG9hZGVyX2ZyYWdtZW50X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJFbGVtZW50YXJ5U3RyZWFtVHlwZXNcIl0uVklERU8pO1xuICAgIH1cblxuICAgIHZhciB0cmFja3MgPSB7fTtcblxuICAgIGlmIChpbml0RGF0YS5hdWRpbyAmJiBpbml0RGF0YS52aWRlbykge1xuICAgICAgdHJhY2tzLmF1ZGlvdmlkZW8gPSB7XG4gICAgICAgIGNvbnRhaW5lcjogJ3ZpZGVvL21wNCcsXG4gICAgICAgIGNvZGVjOiBhdWRpb0NvZGVjICsgJywnICsgdmlkZW9Db2RlYyxcbiAgICAgICAgaW5pdFNlZ21lbnQ6IGluaXRTZWdtZW50LFxuICAgICAgICBpZDogJ21haW4nXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoaW5pdERhdGEuYXVkaW8pIHtcbiAgICAgIHRyYWNrcy5hdWRpbyA9IHtcbiAgICAgICAgY29udGFpbmVyOiAnYXVkaW8vbXA0JyxcbiAgICAgICAgY29kZWM6IGF1ZGlvQ29kZWMsXG4gICAgICAgIGluaXRTZWdtZW50OiBpbml0U2VnbWVudCxcbiAgICAgICAgaWQ6ICdhdWRpbydcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChpbml0RGF0YS52aWRlbykge1xuICAgICAgdHJhY2tzLnZpZGVvID0ge1xuICAgICAgICBjb250YWluZXI6ICd2aWRlby9tcDQnLFxuICAgICAgICBjb2RlYzogdmlkZW9Db2RlYyxcbiAgICAgICAgaW5pdFNlZ21lbnQ6IGluaXRTZWdtZW50LFxuICAgICAgICBpZDogJ21haW4nXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJsb2dnZXJcIl0ud2FybignW3Bhc3N0aHJvdWdoLXJlbXV4ZXIudHNdOiBpbml0U2VnbWVudCBkb2VzIG5vdCBjb250YWluIG1vb3Ygb3IgdHJhayBib3hlcy4nKTtcbiAgICB9XG5cbiAgICB0aGlzLmluaXRUcmFja3MgPSB0cmFja3M7XG4gIH07XG5cbiAgX3Byb3RvLnJlbXV4ID0gZnVuY3Rpb24gcmVtdXgoYXVkaW9UcmFjaywgdmlkZW9UcmFjaywgaWQzVHJhY2ssIHRleHRUcmFjaywgdGltZU9mZnNldCkge1xuICAgIHZhciBpbml0UFRTID0gdGhpcy5pbml0UFRTLFxuICAgICAgICBsYXN0RW5kRFRTID0gdGhpcy5sYXN0RW5kRFRTO1xuICAgIHZhciByZXN1bHQgPSB7XG4gICAgICBhdWRpbzogdW5kZWZpbmVkLFxuICAgICAgdmlkZW86IHVuZGVmaW5lZCxcbiAgICAgIHRleHQ6IHRleHRUcmFjayxcbiAgICAgIGlkMzogaWQzVHJhY2ssXG4gICAgICBpbml0U2VnbWVudDogdW5kZWZpbmVkXG4gICAgfTsgLy8gSWYgd2UgaGF2ZW4ndCB5ZXQgc2V0IGEgbGFzdEVuZERUUywgb3IgaXQgd2FzIHJlc2V0LCBzZXQgaXQgdG8gdGhlIHByb3ZpZGVkIHRpbWVPZmZzZXQuIFdlIHdhbnQgdG8gdXNlIHRoZVxuICAgIC8vIGxhc3RFbmREVFMgb3ZlciB0aW1lT2Zmc2V0IHdoZW5ldmVyIHBvc3NpYmxlOyBkdXJpbmcgcHJvZ3Jlc3NpdmUgcGxheWJhY2ssIHRoZSBtZWRpYSBzb3VyY2Ugd2lsbCBub3QgdXBkYXRlXG4gICAgLy8gdGhlIG1lZGlhIGR1cmF0aW9uICh3aGljaCBpcyB3aGF0IHRpbWVPZmZzZXQgaXMgcHJvdmlkZWQgYXMpIGJlZm9yZSB3ZSBuZWVkIHRvIHByb2Nlc3MgdGhlIG5leHQgY2h1bmsuXG5cbiAgICBpZiAoIU9iamVjdChfaG9tZV9ydW5uZXJfd29ya19obHNfanNfaGxzX2pzX3NyY19wb2x5ZmlsbHNfbnVtYmVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJpc0Zpbml0ZU51bWJlclwiXSkobGFzdEVuZERUUykpIHtcbiAgICAgIGxhc3RFbmREVFMgPSB0aGlzLmxhc3RFbmREVFMgPSB0aW1lT2Zmc2V0IHx8IDA7XG4gICAgfSAvLyBUaGUgYmluYXJ5IHNlZ21lbnQgZGF0YSBpcyBhZGRlZCB0byB0aGUgdmlkZW9UcmFjayBpbiB0aGUgbXA0ZGVtdXhlci4gV2UgZG9uJ3QgY2hlY2sgdG8gc2VlIGlmIHRoZSBkYXRhIGlzIG9ubHlcbiAgICAvLyBhdWRpbyBvciB2aWRlbyAob3IgYm90aCk7IGFkZGluZyBpdCB0byB2aWRlbyB3YXMgYW4gYXJiaXRyYXJ5IGNob2ljZS5cblxuXG4gICAgdmFyIGRhdGEgPSB2aWRlb1RyYWNrLnNhbXBsZXM7XG5cbiAgICBpZiAoIWRhdGEgfHwgIWRhdGEubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHZhciBpbml0U2VnbWVudCA9IHtcbiAgICAgIGluaXRQVFM6IHVuZGVmaW5lZCxcbiAgICAgIHRpbWVzY2FsZTogMVxuICAgIH07XG4gICAgdmFyIGluaXREYXRhID0gdGhpcy5pbml0RGF0YTtcblxuICAgIGlmICghaW5pdERhdGEgfHwgIWluaXREYXRhLmxlbmd0aCkge1xuICAgICAgdGhpcy5nZW5lcmF0ZUluaXRTZWdtZW50KGRhdGEpO1xuICAgICAgaW5pdERhdGEgPSB0aGlzLmluaXREYXRhO1xuICAgIH1cblxuICAgIGlmICghaW5pdERhdGEgfHwgIWluaXREYXRhLmxlbmd0aCkge1xuICAgICAgLy8gV2UgY2FuJ3QgcmVtdXggaWYgdGhlIGluaXRTZWdtZW50IGNvdWxkIG5vdCBiZSBnZW5lcmF0ZWRcbiAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcImxvZ2dlclwiXS53YXJuKCdbcGFzc3Rocm91Z2gtcmVtdXhlci50c106IEZhaWxlZCB0byBnZW5lcmF0ZSBpbml0U2VnbWVudC4nKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZW1pdEluaXRTZWdtZW50KSB7XG4gICAgICBpbml0U2VnbWVudC50cmFja3MgPSB0aGlzLmluaXRUcmFja3M7XG4gICAgICB0aGlzLmVtaXRJbml0U2VnbWVudCA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmICghT2JqZWN0KF9ob21lX3J1bm5lcl93b3JrX2hsc19qc19obHNfanNfc3JjX3BvbHlmaWxsc19udW1iZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImlzRmluaXRlTnVtYmVyXCJdKShpbml0UFRTKSkge1xuICAgICAgdGhpcy5pbml0UFRTID0gaW5pdFNlZ21lbnQuaW5pdFBUUyA9IGluaXRQVFMgPSBjb21wdXRlSW5pdFBUUyhpbml0RGF0YSwgZGF0YSwgbGFzdEVuZERUUyk7XG4gICAgfVxuXG4gICAgdmFyIGR1cmF0aW9uID0gT2JqZWN0KF91dGlsc19tcDRfdG9vbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImdldER1cmF0aW9uXCJdKShkYXRhLCBpbml0RGF0YSk7XG4gICAgdmFyIHN0YXJ0RFRTID0gbGFzdEVuZERUUztcbiAgICB2YXIgZW5kRFRTID0gZHVyYXRpb24gKyBzdGFydERUUztcbiAgICBPYmplY3QoX3V0aWxzX21wNF90b29sc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wib2Zmc2V0U3RhcnREVFNcIl0pKGluaXREYXRhLCBkYXRhLCBpbml0UFRTKTtcblxuICAgIGlmIChkdXJhdGlvbiA+IDApIHtcbiAgICAgIHRoaXMubGFzdEVuZERUUyA9IGVuZERUUztcbiAgICB9IGVsc2Uge1xuICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wibG9nZ2VyXCJdLndhcm4oJ0R1cmF0aW9uIHBhcnNlZCBmcm9tIG1wNCBzaG91bGQgYmUgZ3JlYXRlciB0aGFuIHplcm8nKTtcbiAgICAgIHRoaXMucmVzZXROZXh0VGltZXN0YW1wKCk7XG4gICAgfVxuXG4gICAgdmFyIGhhc0F1ZGlvID0gISFpbml0RGF0YS5hdWRpbztcbiAgICB2YXIgaGFzVmlkZW8gPSAhIWluaXREYXRhLnZpZGVvO1xuICAgIHZhciB0eXBlID0gJyc7XG5cbiAgICBpZiAoaGFzQXVkaW8pIHtcbiAgICAgIHR5cGUgKz0gJ2F1ZGlvJztcbiAgICB9XG5cbiAgICBpZiAoaGFzVmlkZW8pIHtcbiAgICAgIHR5cGUgKz0gJ3ZpZGVvJztcbiAgICB9XG5cbiAgICB2YXIgdHJhY2sgPSB7XG4gICAgICBkYXRhMTogZGF0YSxcbiAgICAgIHN0YXJ0UFRTOiBzdGFydERUUyxcbiAgICAgIHN0YXJ0RFRTOiBzdGFydERUUyxcbiAgICAgIGVuZFBUUzogZW5kRFRTLFxuICAgICAgZW5kRFRTOiBlbmREVFMsXG4gICAgICB0eXBlOiB0eXBlLFxuICAgICAgaGFzQXVkaW86IGhhc0F1ZGlvLFxuICAgICAgaGFzVmlkZW86IGhhc1ZpZGVvLFxuICAgICAgbmI6IDEsXG4gICAgICBkcm9wcGVkOiAwXG4gICAgfTtcbiAgICByZXN1bHQuYXVkaW8gPSB0cmFjay50eXBlID09PSAnYXVkaW8nID8gdHJhY2sgOiB1bmRlZmluZWQ7XG4gICAgcmVzdWx0LnZpZGVvID0gdHJhY2sudHlwZSAhPT0gJ2F1ZGlvJyA/IHRyYWNrIDogdW5kZWZpbmVkO1xuICAgIHJlc3VsdC50ZXh0ID0gdGV4dFRyYWNrO1xuICAgIHJlc3VsdC5pZDMgPSBpZDNUcmFjaztcbiAgICByZXN1bHQuaW5pdFNlZ21lbnQgPSBpbml0U2VnbWVudDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIHJldHVybiBQYXNzVGhyb3VnaFJlbXV4ZXI7XG59KCk7XG5cbnZhciBjb21wdXRlSW5pdFBUUyA9IGZ1bmN0aW9uIGNvbXB1dGVJbml0UFRTKGluaXREYXRhLCBkYXRhLCB0aW1lT2Zmc2V0KSB7XG4gIHJldHVybiBPYmplY3QoX3V0aWxzX21wNF90b29sc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiZ2V0U3RhcnREVFNcIl0pKGluaXREYXRhLCBkYXRhKSAtIHRpbWVPZmZzZXQ7XG59O1xuXG5mdW5jdGlvbiBnZXRQYXJzZWRUcmFja0NvZGVjKHRyYWNrLCB0eXBlKSB7XG4gIHZhciBwYXJzZWRDb2RlYyA9IHRyYWNrID09PSBudWxsIHx8IHRyYWNrID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0cmFjay5jb2RlYztcblxuICBpZiAocGFyc2VkQ29kZWMgJiYgcGFyc2VkQ29kZWMubGVuZ3RoID4gNCkge1xuICAgIHJldHVybiBwYXJzZWRDb2RlYztcbiAgfSAvLyBTaW5jZSBtcDQtdG9vbHMgY2Fubm90IHBhcnNlIGZ1bGwgY29kZWMgc3RyaW5nIChzZWUgJ1RPRE86IFBhcnNlIGNvZGVjIGRldGFpbHMnLi4uIGluIG1wNC10b29scylcbiAgLy8gUHJvdmlkZSBkZWZhdWx0cyBiYXNlZCBvbiBjb2RlYyB0eXBlXG4gIC8vIFRoaXMgYWxsb3dzIGZvciBzb21lIHBsYXliYWNrIG9mIHNvbWUgZm1wNCBwbGF5bGlzdHMgd2l0aG91dCBDT0RFQ1MgZGVmaW5lZCBpbiBtYW5pZmVzdFxuXG5cbiAgaWYgKHBhcnNlZENvZGVjID09PSAnaHZjMScpIHtcbiAgICByZXR1cm4gJ2h2YzEuMS5jLkwxMjAuOTAnO1xuICB9XG5cbiAgaWYgKHBhcnNlZENvZGVjID09PSAnYXYwMScpIHtcbiAgICByZXR1cm4gJ2F2MDEuMC4wNE0uMDgnO1xuICB9XG5cbiAgaWYgKHBhcnNlZENvZGVjID09PSAnYXZjMScgfHwgdHlwZSA9PT0gX2xvYWRlcl9mcmFnbWVudF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiRWxlbWVudGFyeVN0cmVhbVR5cGVzXCJdLlZJREVPKSB7XG4gICAgcmV0dXJuICdhdmMxLjQyZTAxZSc7XG4gIH1cblxuICByZXR1cm4gJ21wNGEuNDAuNSc7XG59XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoUGFzc1Rocm91Z2hSZW11eGVyKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvdGFzay1sb29wLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy90YXNrLWxvb3AudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZGVmYXVsdFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIFRhc2tMb29wOyB9KTtcbi8qKlxuICogU3ViLWNsYXNzIHNwZWNpYWxpemF0aW9uIG9mIEV2ZW50SGFuZGxlciBiYXNlIGNsYXNzLlxuICpcbiAqIFRhc2tMb29wIGFsbG93cyB0byBzY2hlZHVsZSBhIHRhc2sgZnVuY3Rpb24gYmVpbmcgY2FsbGVkIChvcHRpb25uYWx5IHJlcGVhdGVkbHkpIG9uIHRoZSBtYWluIGxvb3AsXG4gKiBzY2hlZHVsZWQgYXN5bmNocm9uZW91c2x5LCBhdm9pZGluZyByZWN1cnNpdmUgY2FsbHMgaW4gdGhlIHNhbWUgdGljay5cbiAqXG4gKiBUaGUgdGFzayBpdHNlbGYgaXMgaW1wbGVtZW50ZWQgaW4gYGRvVGlja2AuIEl0IGNhbiBiZSByZXF1ZXN0ZWQgYW5kIGNhbGxlZCBmb3Igc2luZ2xlIGV4ZWN1dGlvblxuICogdXNpbmcgdGhlIGB0aWNrYCBtZXRob2QuXG4gKlxuICogSXQgd2lsbCBiZSBhc3N1cmVkIHRoYXQgdGhlIHRhc2sgZXhlY3V0aW9uIG1ldGhvZCAoYHRpY2tgKSBvbmx5IGdldHMgY2FsbGVkIG9uY2UgcGVyIG1haW4gbG9vcCBcInRpY2tcIixcbiAqIG5vIG1hdHRlciBob3cgb2Z0ZW4gaXQgZ2V0cyByZXF1ZXN0ZWQgZm9yIGV4ZWN1dGlvbi4gRXhlY3V0aW9uIGluIGZ1cnRoZXIgdGlja3Mgd2lsbCBiZSBzY2hlZHVsZWQgYWNjb3JkaW5nbHkuXG4gKlxuICogSWYgZnVydGhlciBleGVjdXRpb24gcmVxdWVzdHMgaGF2ZSBhbHJlYWR5IGJlZW4gc2NoZWR1bGVkIG9uIHRoZSBuZXh0IHRpY2ssIGl0IGNhbiBiZSBjaGVja2VkIHdpdGggYGhhc05leHRUaWNrYCxcbiAqIGFuZCBjYW5jZWxsZWQgd2l0aCBgY2xlYXJOZXh0VGlja2AuXG4gKlxuICogVGhlIHRhc2sgY2FuIGJlIHNjaGVkdWxlZCBhcyBhbiBpbnRlcnZhbCByZXBlYXRlZGx5IHdpdGggYSBwZXJpb2QgYXMgcGFyYW1ldGVyIChzZWUgYHNldEludGVydmFsYCwgYGNsZWFySW50ZXJ2YWxgKS5cbiAqXG4gKiBTdWItY2xhc3NlcyBuZWVkIHRvIGltcGxlbWVudCB0aGUgYGRvVGlja2AgbWV0aG9kIHdoaWNoIHdpbGwgZWZmZWN0aXZlbHkgaGF2ZSB0aGUgdGFzayBleGVjdXRpb24gcm91dGluZS5cbiAqXG4gKiBGdXJ0aGVyIGV4cGxhbmF0aW9uczpcbiAqXG4gKiBUaGUgYmFzZWNsYXNzIGhhcyBhIGB0aWNrYCBtZXRob2QgdGhhdCB3aWxsIHNjaGVkdWxlIHRoZSBkb1RpY2sgY2FsbC4gSXQgbWF5IGJlIGNhbGxlZCBzeW5jaHJvbmVvdXNseVxuICogb25seSBmb3IgYSBzdGFjay1kZXB0aCBvZiBvbmUuIE9uIHJlLWVudHJhbnQgY2FsbHMsIHN1Yi1zZXF1ZW50IGNhbGxzIGFyZSBzY2hlZHVsZWQgZm9yIG5leHQgbWFpbiBsb29wIHRpY2tzLlxuICpcbiAqIFdoZW4gdGhlIHRhc2sgZXhlY3V0aW9uIChgdGlja2AgbWV0aG9kKSBpcyBjYWxsZWQgaW4gcmUtZW50cmFudCB3YXkgdGhpcyBpcyBkZXRlY3RlZCBhbmRcbiAqIHdlIGFyZSBsaW1pdGluZyB0aGUgdGFzayBleGVjdXRpb24gcGVyIGNhbGwgc3RhY2sgdG8gZXhhY3RseSBvbmUsIGJ1dCBzY2hlZHVsaW5nL3Bvc3QtcG9uaW5nIGZ1cnRoZXJcbiAqIHRhc2sgcHJvY2Vzc2luZyBvbiB0aGUgbmV4dCBtYWluIGxvb3AgaXRlcmF0aW9uIChhbHNvIGtub3duIGFzIFwibmV4dCB0aWNrXCIgaW4gdGhlIE5vZGUvSlMgcnVudGltZSBsaW5nbykuXG4gKi9cbnZhciBUYXNrTG9vcCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFRhc2tMb29wKCkge1xuICAgIHRoaXMuX2JvdW5kVGljayA9IHZvaWQgMDtcbiAgICB0aGlzLl90aWNrVGltZXIgPSBudWxsO1xuICAgIHRoaXMuX3RpY2tJbnRlcnZhbCA9IG51bGw7XG4gICAgdGhpcy5fdGlja0NhbGxDb3VudCA9IDA7XG4gICAgdGhpcy5fYm91bmRUaWNrID0gdGhpcy50aWNrLmJpbmQodGhpcyk7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gVGFza0xvb3AucHJvdG90eXBlO1xuXG4gIF9wcm90by5kZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICB0aGlzLm9uSGFuZGxlckRlc3Ryb3lpbmcoKTtcbiAgICB0aGlzLm9uSGFuZGxlckRlc3Ryb3llZCgpO1xuICB9O1xuXG4gIF9wcm90by5vbkhhbmRsZXJEZXN0cm95aW5nID0gZnVuY3Rpb24gb25IYW5kbGVyRGVzdHJveWluZygpIHtcbiAgICAvLyBjbGVhciBhbGwgdGltZXJzIGJlZm9yZSB1bnJlZ2lzdGVyaW5nIGZyb20gZXZlbnQgYnVzXG4gICAgdGhpcy5jbGVhck5leHRUaWNrKCk7XG4gICAgdGhpcy5jbGVhckludGVydmFsKCk7XG4gIH07XG5cbiAgX3Byb3RvLm9uSGFuZGxlckRlc3Ryb3llZCA9IGZ1bmN0aW9uIG9uSGFuZGxlckRlc3Ryb3llZCgpIHt9XG4gIC8qKlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIDtcblxuICBfcHJvdG8uaGFzSW50ZXJ2YWwgPSBmdW5jdGlvbiBoYXNJbnRlcnZhbCgpIHtcbiAgICByZXR1cm4gISF0aGlzLl90aWNrSW50ZXJ2YWw7XG4gIH1cbiAgLyoqXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5oYXNOZXh0VGljayA9IGZ1bmN0aW9uIGhhc05leHRUaWNrKCkge1xuICAgIHJldHVybiAhIXRoaXMuX3RpY2tUaW1lcjtcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IG1pbGxpcyBJbnRlcnZhbCB0aW1lIChtcylcbiAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgd2hlbiBpbnRlcnZhbCBoYXMgYmVlbiBzY2hlZHVsZWQsIGZhbHNlIHdoZW4gYWxyZWFkeSBzY2hlZHVsZWQgKG5vIGVmZmVjdClcbiAgICovXG4gIDtcblxuICBfcHJvdG8uc2V0SW50ZXJ2YWwgPSBmdW5jdGlvbiBzZXRJbnRlcnZhbChtaWxsaXMpIHtcbiAgICBpZiAoIXRoaXMuX3RpY2tJbnRlcnZhbCkge1xuICAgICAgdGhpcy5fdGlja0ludGVydmFsID0gc2VsZi5zZXRJbnRlcnZhbCh0aGlzLl9ib3VuZFRpY2ssIG1pbGxpcyk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLyoqXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIHdoZW4gaW50ZXJ2YWwgd2FzIGNsZWFyZWQsIGZhbHNlIHdoZW4gbm9uZSB3YXMgc2V0IChubyBlZmZlY3QpXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmNsZWFySW50ZXJ2YWwgPSBmdW5jdGlvbiBjbGVhckludGVydmFsKCkge1xuICAgIGlmICh0aGlzLl90aWNrSW50ZXJ2YWwpIHtcbiAgICAgIHNlbGYuY2xlYXJJbnRlcnZhbCh0aGlzLl90aWNrSW50ZXJ2YWwpO1xuICAgICAgdGhpcy5fdGlja0ludGVydmFsID0gbnVsbDtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvKipcbiAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgd2hlbiB0aW1lb3V0IHdhcyBjbGVhcmVkLCBmYWxzZSB3aGVuIG5vbmUgd2FzIHNldCAobm8gZWZmZWN0KVxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5jbGVhck5leHRUaWNrID0gZnVuY3Rpb24gY2xlYXJOZXh0VGljaygpIHtcbiAgICBpZiAodGhpcy5fdGlja1RpbWVyKSB7XG4gICAgICBzZWxmLmNsZWFyVGltZW91dCh0aGlzLl90aWNrVGltZXIpO1xuICAgICAgdGhpcy5fdGlja1RpbWVyID0gbnVsbDtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvKipcbiAgICogV2lsbCBjYWxsIHRoZSBzdWJjbGFzcyBkb1RpY2sgaW1wbGVtZW50YXRpb24gaW4gdGhpcyBtYWluIGxvb3AgdGlja1xuICAgKiBvciBpbiB0aGUgbmV4dCBvbmUgKHZpYSBzZXRUaW1lb3V0KCwwKSkgaW4gY2FzZSBpdCBoYXMgYWxyZWFkeSBiZWVuIGNhbGxlZFxuICAgKiBpbiB0aGlzIHRpY2sgKGluIGNhc2UgdGhpcyBpcyBhIHJlLWVudHJhbnQgY2FsbCkuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnRpY2sgPSBmdW5jdGlvbiB0aWNrKCkge1xuICAgIHRoaXMuX3RpY2tDYWxsQ291bnQrKztcblxuICAgIGlmICh0aGlzLl90aWNrQ2FsbENvdW50ID09PSAxKSB7XG4gICAgICB0aGlzLmRvVGljaygpOyAvLyByZS1lbnRyYW50IGNhbGwgdG8gdGljayBmcm9tIHByZXZpb3VzIGRvVGljayBjYWxsIHN0YWNrXG4gICAgICAvLyAtPiBzY2hlZHVsZSBhIGNhbGwgb24gdGhlIG5leHQgbWFpbiBsb29wIGl0ZXJhdGlvbiB0byBwcm9jZXNzIHRoaXMgdGFzayBwcm9jZXNzaW5nIHJlcXVlc3RcblxuICAgICAgaWYgKHRoaXMuX3RpY2tDYWxsQ291bnQgPiAxKSB7XG4gICAgICAgIC8vIG1ha2Ugc3VyZSBvbmx5IG9uZSB0aW1lciBleGlzdHMgYXQgYW55IHRpbWUgYXQgbWF4XG4gICAgICAgIHRoaXMudGlja0ltbWVkaWF0ZSgpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl90aWNrQ2FsbENvdW50ID0gMDtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLnRpY2tJbW1lZGlhdGUgPSBmdW5jdGlvbiB0aWNrSW1tZWRpYXRlKCkge1xuICAgIHRoaXMuY2xlYXJOZXh0VGljaygpO1xuICAgIHRoaXMuX3RpY2tUaW1lciA9IHNlbGYuc2V0VGltZW91dCh0aGlzLl9ib3VuZFRpY2ssIDApO1xuICB9XG4gIC8qKlxuICAgKiBGb3Igc3ViY2xhc3MgdG8gaW1wbGVtZW50IHRhc2sgbG9naWNcbiAgICogQGFic3RyYWN0XG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmRvVGljayA9IGZ1bmN0aW9uIGRvVGljaygpIHt9O1xuXG4gIHJldHVybiBUYXNrTG9vcDtcbn0oKTtcblxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3R5cGVzL2NtY2QudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy90eXBlcy9jbWNkLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogQ01DRFZlcnNpb24sIENNQ0RPYmplY3RUeXBlLCBDTUNEU3RyZWFtaW5nRm9ybWF0LCBDTUNEU3RyZWFtVHlwZSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJDTUNEVmVyc2lvblwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIENNQ0RWZXJzaW9uOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJDTUNET2JqZWN0VHlwZVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIENNQ0RPYmplY3RUeXBlOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJDTUNEU3RyZWFtaW5nRm9ybWF0XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gQ01DRFN0cmVhbWluZ0Zvcm1hdDsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiQ01DRFN0cmVhbVR5cGVcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBDTUNEU3RyZWFtVHlwZTsgfSk7XG4vKipcbiAqIENNQ0Qgc3BlYyB2ZXJzaW9uXG4gKi9cbnZhciBDTUNEVmVyc2lvbiA9IDE7XG4vKipcbiAqIENNQ0QgT2JqZWN0IFR5cGVcbiAqL1xuXG52YXIgQ01DRE9iamVjdFR5cGU7XG4vKipcbiAqIENNQ0QgU3RyZWFtaW5nIEZvcm1hdFxuICovXG5cbihmdW5jdGlvbiAoQ01DRE9iamVjdFR5cGUpIHtcbiAgQ01DRE9iamVjdFR5cGVbXCJNQU5JRkVTVFwiXSA9IFwibVwiO1xuICBDTUNET2JqZWN0VHlwZVtcIkFVRElPXCJdID0gXCJhXCI7XG4gIENNQ0RPYmplY3RUeXBlW1wiVklERU9cIl0gPSBcInZcIjtcbiAgQ01DRE9iamVjdFR5cGVbXCJNVVhFRFwiXSA9IFwiYXZcIjtcbiAgQ01DRE9iamVjdFR5cGVbXCJJTklUXCJdID0gXCJpXCI7XG4gIENNQ0RPYmplY3RUeXBlW1wiQ0FQVElPTlwiXSA9IFwiY1wiO1xuICBDTUNET2JqZWN0VHlwZVtcIlRJTUVEX1RFWFRcIl0gPSBcInR0XCI7XG4gIENNQ0RPYmplY3RUeXBlW1wiS0VZXCJdID0gXCJrXCI7XG4gIENNQ0RPYmplY3RUeXBlW1wiT1RIRVJcIl0gPSBcIm9cIjtcbn0pKENNQ0RPYmplY3RUeXBlIHx8IChDTUNET2JqZWN0VHlwZSA9IHt9KSk7XG5cbnZhciBDTUNEU3RyZWFtaW5nRm9ybWF0O1xuLyoqXG4gKiBDTUNEIFN0cmVhbWluZyBUeXBlXG4gKi9cblxuKGZ1bmN0aW9uIChDTUNEU3RyZWFtaW5nRm9ybWF0KSB7XG4gIENNQ0RTdHJlYW1pbmdGb3JtYXRbXCJEQVNIXCJdID0gXCJkXCI7XG4gIENNQ0RTdHJlYW1pbmdGb3JtYXRbXCJITFNcIl0gPSBcImhcIjtcbiAgQ01DRFN0cmVhbWluZ0Zvcm1hdFtcIlNNT09USFwiXSA9IFwic1wiO1xuICBDTUNEU3RyZWFtaW5nRm9ybWF0W1wiT1RIRVJcIl0gPSBcIm9cIjtcbn0pKENNQ0RTdHJlYW1pbmdGb3JtYXQgfHwgKENNQ0RTdHJlYW1pbmdGb3JtYXQgPSB7fSkpO1xuXG52YXIgQ01DRFN0cmVhbVR5cGU7XG4vKipcbiAqIENNQ0QgSGVhZGVyc1xuICovXG5cbihmdW5jdGlvbiAoQ01DRFN0cmVhbVR5cGUpIHtcbiAgQ01DRFN0cmVhbVR5cGVbXCJWT0RcIl0gPSBcInZcIjtcbiAgQ01DRFN0cmVhbVR5cGVbXCJMSVZFXCJdID0gXCJsXCI7XG59KShDTUNEU3RyZWFtVHlwZSB8fCAoQ01DRFN0cmVhbVR5cGUgPSB7fSkpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy90eXBlcy9sZXZlbC50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy90eXBlcy9sZXZlbC50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBIbHNTa2lwLCBnZXRTa2lwVmFsdWUsIEhsc1VybFBhcmFtZXRlcnMsIExldmVsICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIkhsc1NraXBcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBIbHNTa2lwOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJnZXRTa2lwVmFsdWVcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBnZXRTa2lwVmFsdWU7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIkhsc1VybFBhcmFtZXRlcnNcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBIbHNVcmxQYXJhbWV0ZXJzOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJMZXZlbFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIExldmVsOyB9KTtcbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxudmFyIEhsc1NraXA7XG5cbihmdW5jdGlvbiAoSGxzU2tpcCkge1xuICBIbHNTa2lwW1wiTm9cIl0gPSBcIlwiO1xuICBIbHNTa2lwW1wiWWVzXCJdID0gXCJZRVNcIjtcbiAgSGxzU2tpcFtcInYyXCJdID0gXCJ2MlwiO1xufSkoSGxzU2tpcCB8fCAoSGxzU2tpcCA9IHt9KSk7XG5cbmZ1bmN0aW9uIGdldFNraXBWYWx1ZShkZXRhaWxzLCBtc24pIHtcbiAgdmFyIGNhblNraXBVbnRpbCA9IGRldGFpbHMuY2FuU2tpcFVudGlsLFxuICAgICAgY2FuU2tpcERhdGVSYW5nZXMgPSBkZXRhaWxzLmNhblNraXBEYXRlUmFuZ2VzLFxuICAgICAgZW5kU04gPSBkZXRhaWxzLmVuZFNOO1xuICB2YXIgc25DaGFuZ2VHb2FsID0gbXNuICE9PSB1bmRlZmluZWQgPyBtc24gLSBlbmRTTiA6IDA7XG5cbiAgaWYgKGNhblNraXBVbnRpbCAmJiBzbkNoYW5nZUdvYWwgPCBjYW5Ta2lwVW50aWwpIHtcbiAgICBpZiAoY2FuU2tpcERhdGVSYW5nZXMpIHtcbiAgICAgIHJldHVybiBIbHNTa2lwLnYyO1xuICAgIH1cblxuICAgIHJldHVybiBIbHNTa2lwLlllcztcbiAgfVxuXG4gIHJldHVybiBIbHNTa2lwLk5vO1xufVxudmFyIEhsc1VybFBhcmFtZXRlcnMgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBIbHNVcmxQYXJhbWV0ZXJzKG1zbiwgcGFydCwgc2tpcCkge1xuICAgIHRoaXMubXNuID0gdm9pZCAwO1xuICAgIHRoaXMucGFydCA9IHZvaWQgMDtcbiAgICB0aGlzLnNraXAgPSB2b2lkIDA7XG4gICAgdGhpcy5tc24gPSBtc247XG4gICAgdGhpcy5wYXJ0ID0gcGFydDtcbiAgICB0aGlzLnNraXAgPSBza2lwO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IEhsc1VybFBhcmFtZXRlcnMucHJvdG90eXBlO1xuXG4gIF9wcm90by5hZGREaXJlY3RpdmVzID0gZnVuY3Rpb24gYWRkRGlyZWN0aXZlcyh1cmkpIHtcbiAgICB2YXIgdXJsID0gbmV3IHNlbGYuVVJMKHVyaSk7XG5cbiAgICBpZiAodGhpcy5tc24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgdXJsLnNlYXJjaFBhcmFtcy5zZXQoJ19ITFNfbXNuJywgdGhpcy5tc24udG9TdHJpbmcoKSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucGFydCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB1cmwuc2VhcmNoUGFyYW1zLnNldCgnX0hMU19wYXJ0JywgdGhpcy5wYXJ0LnRvU3RyaW5nKCkpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnNraXApIHtcbiAgICAgIHVybC5zZWFyY2hQYXJhbXMuc2V0KCdfSExTX3NraXAnLCB0aGlzLnNraXApO1xuICAgIH1cblxuICAgIHJldHVybiB1cmwudG9TdHJpbmcoKTtcbiAgfTtcblxuICByZXR1cm4gSGxzVXJsUGFyYW1ldGVycztcbn0oKTtcbnZhciBMZXZlbCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIExldmVsKGRhdGEpIHtcbiAgICB0aGlzLmF0dHJzID0gdm9pZCAwO1xuICAgIHRoaXMuYXVkaW9Db2RlYyA9IHZvaWQgMDtcbiAgICB0aGlzLmJpdHJhdGUgPSB2b2lkIDA7XG4gICAgdGhpcy5jb2RlY1NldCA9IHZvaWQgMDtcbiAgICB0aGlzLmhlaWdodCA9IHZvaWQgMDtcbiAgICB0aGlzLmlkID0gdm9pZCAwO1xuICAgIHRoaXMubmFtZSA9IHZvaWQgMDtcbiAgICB0aGlzLnZpZGVvQ29kZWMgPSB2b2lkIDA7XG4gICAgdGhpcy53aWR0aCA9IHZvaWQgMDtcbiAgICB0aGlzLnVua25vd25Db2RlY3MgPSB2b2lkIDA7XG4gICAgdGhpcy5hdWRpb0dyb3VwSWRzID0gdm9pZCAwO1xuICAgIHRoaXMuZGV0YWlscyA9IHZvaWQgMDtcbiAgICB0aGlzLmZyYWdtZW50RXJyb3IgPSAwO1xuICAgIHRoaXMubG9hZEVycm9yID0gMDtcbiAgICB0aGlzLmxvYWRlZCA9IHZvaWQgMDtcbiAgICB0aGlzLnJlYWxCaXRyYXRlID0gMDtcbiAgICB0aGlzLnRleHRHcm91cElkcyA9IHZvaWQgMDtcbiAgICB0aGlzLnVybCA9IHZvaWQgMDtcbiAgICB0aGlzLl91cmxJZCA9IDA7XG4gICAgdGhpcy51cmwgPSBbZGF0YS51cmxdO1xuICAgIHRoaXMuYXR0cnMgPSBkYXRhLmF0dHJzO1xuICAgIHRoaXMuYml0cmF0ZSA9IGRhdGEuYml0cmF0ZTtcblxuICAgIGlmIChkYXRhLmRldGFpbHMpIHtcbiAgICAgIHRoaXMuZGV0YWlscyA9IGRhdGEuZGV0YWlscztcbiAgICB9XG5cbiAgICB0aGlzLmlkID0gZGF0YS5pZCB8fCAwO1xuICAgIHRoaXMubmFtZSA9IGRhdGEubmFtZTtcbiAgICB0aGlzLndpZHRoID0gZGF0YS53aWR0aCB8fCAwO1xuICAgIHRoaXMuaGVpZ2h0ID0gZGF0YS5oZWlnaHQgfHwgMDtcbiAgICB0aGlzLmF1ZGlvQ29kZWMgPSBkYXRhLmF1ZGlvQ29kZWM7XG4gICAgdGhpcy52aWRlb0NvZGVjID0gZGF0YS52aWRlb0NvZGVjO1xuICAgIHRoaXMudW5rbm93bkNvZGVjcyA9IGRhdGEudW5rbm93bkNvZGVjcztcbiAgICB0aGlzLmNvZGVjU2V0ID0gW2RhdGEudmlkZW9Db2RlYywgZGF0YS5hdWRpb0NvZGVjXS5maWx0ZXIoZnVuY3Rpb24gKGMpIHtcbiAgICAgIHJldHVybiBjO1xuICAgIH0pLmpvaW4oJywnKS5yZXBsYWNlKC9cXC5bXi4sXSsvZywgJycpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKExldmVsLCBbe1xuICAgIGtleTogXCJtYXhCaXRyYXRlXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gTWF0aC5tYXgodGhpcy5yZWFsQml0cmF0ZSwgdGhpcy5iaXRyYXRlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidXJpXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy51cmxbdGhpcy5fdXJsSWRdIHx8ICcnO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1cmxJZFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3VybElkO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgIHZhciBuZXdWYWx1ZSA9IHZhbHVlICUgdGhpcy51cmwubGVuZ3RoO1xuXG4gICAgICBpZiAodGhpcy5fdXJsSWQgIT09IG5ld1ZhbHVlKSB7XG4gICAgICAgIHRoaXMuZGV0YWlscyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fdXJsSWQgPSBuZXdWYWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTGV2ZWw7XG59KCk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3R5cGVzL2xvYWRlci50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvdHlwZXMvbG9hZGVyLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBQbGF5bGlzdENvbnRleHRUeXBlLCBQbGF5bGlzdExldmVsVHlwZSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJQbGF5bGlzdENvbnRleHRUeXBlXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gUGxheWxpc3RDb250ZXh0VHlwZTsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiUGxheWxpc3RMZXZlbFR5cGVcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBQbGF5bGlzdExldmVsVHlwZTsgfSk7XG52YXIgUGxheWxpc3RDb250ZXh0VHlwZTtcblxuKGZ1bmN0aW9uIChQbGF5bGlzdENvbnRleHRUeXBlKSB7XG4gIFBsYXlsaXN0Q29udGV4dFR5cGVbXCJNQU5JRkVTVFwiXSA9IFwibWFuaWZlc3RcIjtcbiAgUGxheWxpc3RDb250ZXh0VHlwZVtcIkxFVkVMXCJdID0gXCJsZXZlbFwiO1xuICBQbGF5bGlzdENvbnRleHRUeXBlW1wiQVVESU9fVFJBQ0tcIl0gPSBcImF1ZGlvVHJhY2tcIjtcbiAgUGxheWxpc3RDb250ZXh0VHlwZVtcIlNVQlRJVExFX1RSQUNLXCJdID0gXCJzdWJ0aXRsZVRyYWNrXCI7XG59KShQbGF5bGlzdENvbnRleHRUeXBlIHx8IChQbGF5bGlzdENvbnRleHRUeXBlID0ge30pKTtcblxudmFyIFBsYXlsaXN0TGV2ZWxUeXBlO1xuXG4oZnVuY3Rpb24gKFBsYXlsaXN0TGV2ZWxUeXBlKSB7XG4gIFBsYXlsaXN0TGV2ZWxUeXBlW1wiTUFJTlwiXSA9IFwibWFpblwiO1xuICBQbGF5bGlzdExldmVsVHlwZVtcIkFVRElPXCJdID0gXCJhdWRpb1wiO1xuICBQbGF5bGlzdExldmVsVHlwZVtcIlNVQlRJVExFXCJdID0gXCJzdWJ0aXRsZVwiO1xufSkoUGxheWxpc3RMZXZlbFR5cGUgfHwgKFBsYXlsaXN0TGV2ZWxUeXBlID0ge30pKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvdHlwZXMvdHJhbnNtdXhlci50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3R5cGVzL3RyYW5zbXV4ZXIudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBDaHVua01ldGFkYXRhICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIkNodW5rTWV0YWRhdGFcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBDaHVua01ldGFkYXRhOyB9KTtcbnZhciBDaHVua01ldGFkYXRhID0gZnVuY3Rpb24gQ2h1bmtNZXRhZGF0YShsZXZlbCwgc24sIGlkLCBzaXplLCBwYXJ0LCBwYXJ0aWFsKSB7XG4gIGlmIChzaXplID09PSB2b2lkIDApIHtcbiAgICBzaXplID0gMDtcbiAgfVxuXG4gIGlmIChwYXJ0ID09PSB2b2lkIDApIHtcbiAgICBwYXJ0ID0gLTE7XG4gIH1cblxuICBpZiAocGFydGlhbCA9PT0gdm9pZCAwKSB7XG4gICAgcGFydGlhbCA9IGZhbHNlO1xuICB9XG5cbiAgdGhpcy5sZXZlbCA9IHZvaWQgMDtcbiAgdGhpcy5zbiA9IHZvaWQgMDtcbiAgdGhpcy5wYXJ0ID0gdm9pZCAwO1xuICB0aGlzLmlkID0gdm9pZCAwO1xuICB0aGlzLnNpemUgPSB2b2lkIDA7XG4gIHRoaXMucGFydGlhbCA9IHZvaWQgMDtcbiAgdGhpcy50cmFuc211eGluZyA9IGdldE5ld1BlcmZvcm1hbmNlVGltaW5nKCk7XG4gIHRoaXMuYnVmZmVyaW5nID0ge1xuICAgIGF1ZGlvOiBnZXROZXdQZXJmb3JtYW5jZVRpbWluZygpLFxuICAgIHZpZGVvOiBnZXROZXdQZXJmb3JtYW5jZVRpbWluZygpLFxuICAgIGF1ZGlvdmlkZW86IGdldE5ld1BlcmZvcm1hbmNlVGltaW5nKClcbiAgfTtcbiAgdGhpcy5sZXZlbCA9IGxldmVsO1xuICB0aGlzLnNuID0gc247XG4gIHRoaXMuaWQgPSBpZDtcbiAgdGhpcy5zaXplID0gc2l6ZTtcbiAgdGhpcy5wYXJ0ID0gcGFydDtcbiAgdGhpcy5wYXJ0aWFsID0gcGFydGlhbDtcbn07XG5cbmZ1bmN0aW9uIGdldE5ld1BlcmZvcm1hbmNlVGltaW5nKCkge1xuICByZXR1cm4ge1xuICAgIHN0YXJ0OiAwLFxuICAgIGV4ZWN1dGVTdGFydDogMCxcbiAgICBleGVjdXRlRW5kOiAwLFxuICAgIGVuZDogMFxuICB9O1xufVxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy91dGlscy9hdHRyLWxpc3QudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3V0aWxzL2F0dHItbGlzdC50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogQXR0ckxpc3QgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiQXR0ckxpc3RcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBBdHRyTGlzdDsgfSk7XG52YXIgREVDSU1BTF9SRVNPTFVUSU9OX1JFR0VYID0gL14oXFxkKyl4KFxcZCspJC87IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdXNlbGVzcy1lc2NhcGVcblxudmFyIEFUVFJfTElTVF9SRUdFWCA9IC9cXHMqKC4rPylcXHMqPSgoPzpcXFwiLio/XFxcIil8Lio/KSg/Oix8JCkvZzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11c2VsZXNzLWVzY2FwZVxuLy8gYWRhcHRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9rYW5vbmdpbC9ub2RlLW0zdThwYXJzZS9ibG9iL21hc3Rlci9hdHRybGlzdC5qc1xuXG52YXIgQXR0ckxpc3QgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBBdHRyTGlzdChhdHRycykge1xuICAgIGlmICh0eXBlb2YgYXR0cnMgPT09ICdzdHJpbmcnKSB7XG4gICAgICBhdHRycyA9IEF0dHJMaXN0LnBhcnNlQXR0ckxpc3QoYXR0cnMpO1xuICAgIH1cblxuICAgIGZvciAodmFyIGF0dHIgaW4gYXR0cnMpIHtcbiAgICAgIGlmIChhdHRycy5oYXNPd25Qcm9wZXJ0eShhdHRyKSkge1xuICAgICAgICB0aGlzW2F0dHJdID0gYXR0cnNbYXR0cl07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIF9wcm90byA9IEF0dHJMaXN0LnByb3RvdHlwZTtcblxuICBfcHJvdG8uZGVjaW1hbEludGVnZXIgPSBmdW5jdGlvbiBkZWNpbWFsSW50ZWdlcihhdHRyTmFtZSkge1xuICAgIHZhciBpbnRWYWx1ZSA9IHBhcnNlSW50KHRoaXNbYXR0ck5hbWVdLCAxMCk7XG5cbiAgICBpZiAoaW50VmFsdWUgPiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUikge1xuICAgICAgcmV0dXJuIEluZmluaXR5O1xuICAgIH1cblxuICAgIHJldHVybiBpbnRWYWx1ZTtcbiAgfTtcblxuICBfcHJvdG8uaGV4YWRlY2ltYWxJbnRlZ2VyID0gZnVuY3Rpb24gaGV4YWRlY2ltYWxJbnRlZ2VyKGF0dHJOYW1lKSB7XG4gICAgaWYgKHRoaXNbYXR0ck5hbWVdKSB7XG4gICAgICB2YXIgc3RyaW5nVmFsdWUgPSAodGhpc1thdHRyTmFtZV0gfHwgJzB4Jykuc2xpY2UoMik7XG4gICAgICBzdHJpbmdWYWx1ZSA9IChzdHJpbmdWYWx1ZS5sZW5ndGggJiAxID8gJzAnIDogJycpICsgc3RyaW5nVmFsdWU7XG4gICAgICB2YXIgdmFsdWUgPSBuZXcgVWludDhBcnJheShzdHJpbmdWYWx1ZS5sZW5ndGggLyAyKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJpbmdWYWx1ZS5sZW5ndGggLyAyOyBpKyspIHtcbiAgICAgICAgdmFsdWVbaV0gPSBwYXJzZUludChzdHJpbmdWYWx1ZS5zbGljZShpICogMiwgaSAqIDIgKyAyKSwgMTYpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uaGV4YWRlY2ltYWxJbnRlZ2VyQXNOdW1iZXIgPSBmdW5jdGlvbiBoZXhhZGVjaW1hbEludGVnZXJBc051bWJlcihhdHRyTmFtZSkge1xuICAgIHZhciBpbnRWYWx1ZSA9IHBhcnNlSW50KHRoaXNbYXR0ck5hbWVdLCAxNik7XG5cbiAgICBpZiAoaW50VmFsdWUgPiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUikge1xuICAgICAgcmV0dXJuIEluZmluaXR5O1xuICAgIH1cblxuICAgIHJldHVybiBpbnRWYWx1ZTtcbiAgfTtcblxuICBfcHJvdG8uZGVjaW1hbEZsb2F0aW5nUG9pbnQgPSBmdW5jdGlvbiBkZWNpbWFsRmxvYXRpbmdQb2ludChhdHRyTmFtZSkge1xuICAgIHJldHVybiBwYXJzZUZsb2F0KHRoaXNbYXR0ck5hbWVdKTtcbiAgfTtcblxuICBfcHJvdG8ub3B0aW9uYWxGbG9hdCA9IGZ1bmN0aW9uIG9wdGlvbmFsRmxvYXQoYXR0ck5hbWUsIGRlZmF1bHRWYWx1ZSkge1xuICAgIHZhciB2YWx1ZSA9IHRoaXNbYXR0ck5hbWVdO1xuICAgIHJldHVybiB2YWx1ZSA/IHBhcnNlRmxvYXQodmFsdWUpIDogZGVmYXVsdFZhbHVlO1xuICB9O1xuXG4gIF9wcm90by5lbnVtZXJhdGVkU3RyaW5nID0gZnVuY3Rpb24gZW51bWVyYXRlZFN0cmluZyhhdHRyTmFtZSkge1xuICAgIHJldHVybiB0aGlzW2F0dHJOYW1lXTtcbiAgfTtcblxuICBfcHJvdG8uYm9vbCA9IGZ1bmN0aW9uIGJvb2woYXR0ck5hbWUpIHtcbiAgICByZXR1cm4gdGhpc1thdHRyTmFtZV0gPT09ICdZRVMnO1xuICB9O1xuXG4gIF9wcm90by5kZWNpbWFsUmVzb2x1dGlvbiA9IGZ1bmN0aW9uIGRlY2ltYWxSZXNvbHV0aW9uKGF0dHJOYW1lKSB7XG4gICAgdmFyIHJlcyA9IERFQ0lNQUxfUkVTT0xVVElPTl9SRUdFWC5leGVjKHRoaXNbYXR0ck5hbWVdKTtcblxuICAgIGlmIChyZXMgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHdpZHRoOiBwYXJzZUludChyZXNbMV0sIDEwKSxcbiAgICAgIGhlaWdodDogcGFyc2VJbnQocmVzWzJdLCAxMClcbiAgICB9O1xuICB9O1xuXG4gIEF0dHJMaXN0LnBhcnNlQXR0ckxpc3QgPSBmdW5jdGlvbiBwYXJzZUF0dHJMaXN0KGlucHV0KSB7XG4gICAgdmFyIG1hdGNoO1xuICAgIHZhciBhdHRycyA9IHt9O1xuICAgIHZhciBxdW90ZSA9ICdcIic7XG4gICAgQVRUUl9MSVNUX1JFR0VYLmxhc3RJbmRleCA9IDA7XG5cbiAgICB3aGlsZSAoKG1hdGNoID0gQVRUUl9MSVNUX1JFR0VYLmV4ZWMoaW5wdXQpKSAhPT0gbnVsbCkge1xuICAgICAgdmFyIHZhbHVlID0gbWF0Y2hbMl07XG5cbiAgICAgIGlmICh2YWx1ZS5pbmRleE9mKHF1b3RlKSA9PT0gMCAmJiB2YWx1ZS5sYXN0SW5kZXhPZihxdW90ZSkgPT09IHZhbHVlLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5zbGljZSgxLCAtMSk7XG4gICAgICB9XG5cbiAgICAgIGF0dHJzW21hdGNoWzFdXSA9IHZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiBhdHRycztcbiAgfTtcblxuICByZXR1cm4gQXR0ckxpc3Q7XG59KCk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3V0aWxzL2JpbmFyeS1zZWFyY2gudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy91dGlscy9iaW5hcnktc2VhcmNoLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbnZhciBCaW5hcnlTZWFyY2ggPSB7XG4gIC8qKlxuICAgKiBTZWFyY2hlcyBmb3IgYW4gaXRlbSBpbiBhbiBhcnJheSB3aGljaCBtYXRjaGVzIGEgY2VydGFpbiBjb25kaXRpb24uXG4gICAqIFRoaXMgcmVxdWlyZXMgdGhlIGNvbmRpdGlvbiB0byBvbmx5IG1hdGNoIG9uZSBpdGVtIGluIHRoZSBhcnJheSxcbiAgICogYW5kIGZvciB0aGUgYXJyYXkgdG8gYmUgb3JkZXJlZC5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheTxUPn0gbGlzdCBUaGUgYXJyYXkgdG8gc2VhcmNoLlxuICAgKiBAcGFyYW0ge0JpbmFyeVNlYXJjaENvbXBhcmlzb248VD59IGNvbXBhcmlzb25GblxuICAgKiAgICAgIENhbGxlZCBhbmQgcHJvdmlkZWQgYSBjYW5kaWRhdGUgaXRlbSBhcyB0aGUgZmlyc3QgYXJndW1lbnQuXG4gICAqICAgICAgU2hvdWxkIHJldHVybjpcbiAgICogICAgICAgICAgPiAtMSBpZiB0aGUgaXRlbSBzaG91bGQgYmUgbG9jYXRlZCBhdCBhIGxvd2VyIGluZGV4IHRoYW4gdGhlIHByb3ZpZGVkIGl0ZW0uXG4gICAqICAgICAgICAgID4gMSBpZiB0aGUgaXRlbSBzaG91bGQgYmUgbG9jYXRlZCBhdCBhIGhpZ2hlciBpbmRleCB0aGFuIHRoZSBwcm92aWRlZCBpdGVtLlxuICAgKiAgICAgICAgICA+IDAgaWYgdGhlIGl0ZW0gaXMgdGhlIGl0ZW0geW91J3JlIGxvb2tpbmcgZm9yLlxuICAgKlxuICAgKiBAcmV0dXJuIHtUIHwgbnVsbH0gVGhlIG9iamVjdCBpZiBpdCBpcyBmb3VuZCBvciBudWxsIG90aGVyd2lzZS5cbiAgICovXG4gIHNlYXJjaDogZnVuY3Rpb24gc2VhcmNoKGxpc3QsIGNvbXBhcmlzb25Gbikge1xuICAgIHZhciBtaW5JbmRleCA9IDA7XG4gICAgdmFyIG1heEluZGV4ID0gbGlzdC5sZW5ndGggLSAxO1xuICAgIHZhciBjdXJyZW50SW5kZXggPSBudWxsO1xuICAgIHZhciBjdXJyZW50RWxlbWVudCA9IG51bGw7XG5cbiAgICB3aGlsZSAobWluSW5kZXggPD0gbWF4SW5kZXgpIHtcbiAgICAgIGN1cnJlbnRJbmRleCA9IChtaW5JbmRleCArIG1heEluZGV4KSAvIDIgfCAwO1xuICAgICAgY3VycmVudEVsZW1lbnQgPSBsaXN0W2N1cnJlbnRJbmRleF07XG4gICAgICB2YXIgY29tcGFyaXNvblJlc3VsdCA9IGNvbXBhcmlzb25GbihjdXJyZW50RWxlbWVudCk7XG5cbiAgICAgIGlmIChjb21wYXJpc29uUmVzdWx0ID4gMCkge1xuICAgICAgICBtaW5JbmRleCA9IGN1cnJlbnRJbmRleCArIDE7XG4gICAgICB9IGVsc2UgaWYgKGNvbXBhcmlzb25SZXN1bHQgPCAwKSB7XG4gICAgICAgIG1heEluZGV4ID0gY3VycmVudEluZGV4IC0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBjdXJyZW50RWxlbWVudDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoQmluYXJ5U2VhcmNoKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvdXRpbHMvYnVmZmVyLWhlbHBlci50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3V0aWxzL2J1ZmZlci1oZWxwZXIudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBCdWZmZXJIZWxwZXIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiQnVmZmVySGVscGVyXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gQnVmZmVySGVscGVyOyB9KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2xvZ2dlciAqLyBcIi4vc3JjL3V0aWxzL2xvZ2dlci50c1wiKTtcbi8qKlxuICogQG1vZHVsZSBCdWZmZXJIZWxwZXJcbiAqXG4gKiBQcm92aWRpbmcgbWV0aG9kcyBkZWFsaW5nIHdpdGggYnVmZmVyIGxlbmd0aCByZXRyaWV2YWwgZm9yIGV4YW1wbGUuXG4gKlxuICogSW4gZ2VuZXJhbCwgYSBoZWxwZXIgYXJvdW5kIEhUTUw1IE1lZGlhRWxlbWVudCBUaW1lUmFuZ2VzIGdhdGhlcmVkIGZyb20gYGJ1ZmZlcmVkYCBwcm9wZXJ0eS5cbiAqXG4gKiBBbHNvIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0hUTUxNZWRpYUVsZW1lbnQvYnVmZmVyZWRcbiAqL1xuXG52YXIgbm9vcEJ1ZmZlcmVkID0ge1xuICBsZW5ndGg6IDAsXG4gIHN0YXJ0OiBmdW5jdGlvbiBzdGFydCgpIHtcbiAgICByZXR1cm4gMDtcbiAgfSxcbiAgZW5kOiBmdW5jdGlvbiBlbmQoKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbn07XG52YXIgQnVmZmVySGVscGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQnVmZmVySGVscGVyKCkge31cblxuICAvKipcbiAgICogUmV0dXJuIHRydWUgaWYgYG1lZGlhYCdzIGJ1ZmZlcmVkIGluY2x1ZGUgYHBvc2l0aW9uYFxuICAgKiBAcGFyYW0ge0J1ZmZlcmFibGV9IG1lZGlhXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwb3NpdGlvblxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIEJ1ZmZlckhlbHBlci5pc0J1ZmZlcmVkID0gZnVuY3Rpb24gaXNCdWZmZXJlZChtZWRpYSwgcG9zaXRpb24pIHtcbiAgICB0cnkge1xuICAgICAgaWYgKG1lZGlhKSB7XG4gICAgICAgIHZhciBidWZmZXJlZCA9IEJ1ZmZlckhlbHBlci5nZXRCdWZmZXJlZChtZWRpYSk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBidWZmZXJlZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChwb3NpdGlvbiA+PSBidWZmZXJlZC5zdGFydChpKSAmJiBwb3NpdGlvbiA8PSBidWZmZXJlZC5lbmQoaSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7Ly8gdGhpcyBpcyB0byBjYXRjaFxuICAgICAgLy8gSW52YWxpZFN0YXRlRXJyb3I6IEZhaWxlZCB0byByZWFkIHRoZSAnYnVmZmVyZWQnIHByb3BlcnR5IGZyb20gJ1NvdXJjZUJ1ZmZlcic6XG4gICAgICAvLyBUaGlzIFNvdXJjZUJ1ZmZlciBoYXMgYmVlbiByZW1vdmVkIGZyb20gdGhlIHBhcmVudCBtZWRpYSBzb3VyY2VcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgQnVmZmVySGVscGVyLmJ1ZmZlckluZm8gPSBmdW5jdGlvbiBidWZmZXJJbmZvKG1lZGlhLCBwb3MsIG1heEhvbGVEdXJhdGlvbikge1xuICAgIHRyeSB7XG4gICAgICBpZiAobWVkaWEpIHtcbiAgICAgICAgdmFyIHZidWZmZXJlZCA9IEJ1ZmZlckhlbHBlci5nZXRCdWZmZXJlZChtZWRpYSk7XG4gICAgICAgIHZhciBidWZmZXJlZCA9IFtdO1xuICAgICAgICB2YXIgaTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdmJ1ZmZlcmVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgYnVmZmVyZWQucHVzaCh7XG4gICAgICAgICAgICBzdGFydDogdmJ1ZmZlcmVkLnN0YXJ0KGkpLFxuICAgICAgICAgICAgZW5kOiB2YnVmZmVyZWQuZW5kKGkpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5idWZmZXJlZEluZm8oYnVmZmVyZWQsIHBvcywgbWF4SG9sZUR1cmF0aW9uKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikgey8vIHRoaXMgaXMgdG8gY2F0Y2hcbiAgICAgIC8vIEludmFsaWRTdGF0ZUVycm9yOiBGYWlsZWQgdG8gcmVhZCB0aGUgJ2J1ZmZlcmVkJyBwcm9wZXJ0eSBmcm9tICdTb3VyY2VCdWZmZXInOlxuICAgICAgLy8gVGhpcyBTb3VyY2VCdWZmZXIgaGFzIGJlZW4gcmVtb3ZlZCBmcm9tIHRoZSBwYXJlbnQgbWVkaWEgc291cmNlXG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGxlbjogMCxcbiAgICAgIHN0YXJ0OiBwb3MsXG4gICAgICBlbmQ6IHBvcyxcbiAgICAgIG5leHRTdGFydDogdW5kZWZpbmVkXG4gICAgfTtcbiAgfTtcblxuICBCdWZmZXJIZWxwZXIuYnVmZmVyZWRJbmZvID0gZnVuY3Rpb24gYnVmZmVyZWRJbmZvKGJ1ZmZlcmVkLCBwb3MsIG1heEhvbGVEdXJhdGlvbikge1xuICAgIHBvcyA9IE1hdGgubWF4KDAsIHBvcyk7IC8vIHNvcnQgb24gYnVmZmVyLnN0YXJ0L3NtYWxsZXIgZW5kIChJRSBkb2VzIG5vdCBhbHdheXMgcmV0dXJuIHNvcnRlZCBidWZmZXJlZCByYW5nZSlcblxuICAgIGJ1ZmZlcmVkLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHZhciBkaWZmID0gYS5zdGFydCAtIGIuc3RhcnQ7XG5cbiAgICAgIGlmIChkaWZmKSB7XG4gICAgICAgIHJldHVybiBkaWZmO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGIuZW5kIC0gYS5lbmQ7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdmFyIGJ1ZmZlcmVkMiA9IFtdO1xuXG4gICAgaWYgKG1heEhvbGVEdXJhdGlvbikge1xuICAgICAgLy8gdGhlcmUgbWlnaHQgYmUgc29tZSBzbWFsbCBob2xlcyBiZXR3ZWVuIGJ1ZmZlciB0aW1lIHJhbmdlXG4gICAgICAvLyBjb25zaWRlciB0aGF0IGhvbGVzIHNtYWxsZXIgdGhhbiBtYXhIb2xlRHVyYXRpb24gYXJlIGlycmVsZXZhbnQgYW5kIGJ1aWxkIGFub3RoZXJcbiAgICAgIC8vIGJ1ZmZlciB0aW1lIHJhbmdlIHJlcHJlc2VudGF0aW9ucyB0aGF0IGRpc2NhcmRzIHRob3NlIGhvbGVzXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1ZmZlcmVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBidWYybGVuID0gYnVmZmVyZWQyLmxlbmd0aDtcblxuICAgICAgICBpZiAoYnVmMmxlbikge1xuICAgICAgICAgIHZhciBidWYyZW5kID0gYnVmZmVyZWQyW2J1ZjJsZW4gLSAxXS5lbmQ7IC8vIGlmIHNtYWxsIGhvbGUgKHZhbHVlIGJldHdlZW4gMCBvciBtYXhIb2xlRHVyYXRpb24gKSBvciBvdmVybGFwcGluZyAobmVnYXRpdmUpXG5cbiAgICAgICAgICBpZiAoYnVmZmVyZWRbaV0uc3RhcnQgLSBidWYyZW5kIDwgbWF4SG9sZUR1cmF0aW9uKSB7XG4gICAgICAgICAgICAvLyBtZXJnZSBvdmVybGFwcGluZyB0aW1lIHJhbmdlc1xuICAgICAgICAgICAgLy8gdXBkYXRlIGxhc3RSYW5nZS5lbmQgb25seSBpZiBzbWFsbGVyIHRoYW4gaXRlbS5lbmRcbiAgICAgICAgICAgIC8vIGUuZy4gIFsgMSwgMTVdIHdpdGggIFsgMiw4XSA9PiBbIDEsMTVdIChubyBuZWVkIHRvIG1vZGlmeSBsYXN0UmFuZ2UuZW5kKVxuICAgICAgICAgICAgLy8gd2hlcmVhcyBbIDEsIDhdIHdpdGggIFsgMiwxNV0gPT4gWyAxLDE1XSAoIGxhc3RSYW5nZSBzaG91bGQgc3dpdGNoIGZyb20gWzEsOF0gdG8gWzEsMTVdKVxuICAgICAgICAgICAgaWYgKGJ1ZmZlcmVkW2ldLmVuZCA+IGJ1ZjJlbmQpIHtcbiAgICAgICAgICAgICAgYnVmZmVyZWQyW2J1ZjJsZW4gLSAxXS5lbmQgPSBidWZmZXJlZFtpXS5lbmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGJpZyBob2xlXG4gICAgICAgICAgICBidWZmZXJlZDIucHVzaChidWZmZXJlZFtpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGZpcnN0IHZhbHVlXG4gICAgICAgICAgYnVmZmVyZWQyLnB1c2goYnVmZmVyZWRbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGJ1ZmZlcmVkMiA9IGJ1ZmZlcmVkO1xuICAgIH1cblxuICAgIHZhciBidWZmZXJMZW4gPSAwOyAvLyBidWZmZXJTdGFydE5leHQgY2FuIHBvc3NpYmx5IGJlIHVuZGVmaW5lZCBiYXNlZCBvbiB0aGUgY29uZGl0aW9uYWwgbG9naWMgYmVsb3dcblxuICAgIHZhciBidWZmZXJTdGFydE5leHQ7IC8vIGJ1ZmZlclN0YXJ0IGFuZCBidWZmZXJFbmQgYXJlIGJ1ZmZlciBib3VuZGFyaWVzIGFyb3VuZCBjdXJyZW50IHZpZGVvIHBvc2l0aW9uXG5cbiAgICB2YXIgYnVmZmVyU3RhcnQgPSBwb3M7XG4gICAgdmFyIGJ1ZmZlckVuZCA9IHBvcztcblxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBidWZmZXJlZDIubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgc3RhcnQgPSBidWZmZXJlZDJbX2ldLnN0YXJ0O1xuICAgICAgdmFyIGVuZCA9IGJ1ZmZlcmVkMltfaV0uZW5kOyAvLyBsb2dnZXIubG9nKCdidWYgc3RhcnQvZW5kOicgKyBidWZmZXJlZC5zdGFydChpKSArICcvJyArIGJ1ZmZlcmVkLmVuZChpKSk7XG5cbiAgICAgIGlmIChwb3MgKyBtYXhIb2xlRHVyYXRpb24gPj0gc3RhcnQgJiYgcG9zIDwgZW5kKSB7XG4gICAgICAgIC8vIHBsYXkgcG9zaXRpb24gaXMgaW5zaWRlIHRoaXMgYnVmZmVyIFRpbWVSYW5nZSwgcmV0cmlldmUgZW5kIG9mIGJ1ZmZlciBwb3NpdGlvbiBhbmQgYnVmZmVyIGxlbmd0aFxuICAgICAgICBidWZmZXJTdGFydCA9IHN0YXJ0O1xuICAgICAgICBidWZmZXJFbmQgPSBlbmQ7XG4gICAgICAgIGJ1ZmZlckxlbiA9IGJ1ZmZlckVuZCAtIHBvcztcbiAgICAgIH0gZWxzZSBpZiAocG9zICsgbWF4SG9sZUR1cmF0aW9uIDwgc3RhcnQpIHtcbiAgICAgICAgYnVmZmVyU3RhcnROZXh0ID0gc3RhcnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBsZW46IGJ1ZmZlckxlbixcbiAgICAgIHN0YXJ0OiBidWZmZXJTdGFydCB8fCAwLFxuICAgICAgZW5kOiBidWZmZXJFbmQgfHwgMCxcbiAgICAgIG5leHRTdGFydDogYnVmZmVyU3RhcnROZXh0XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogU2FmZSBtZXRob2QgdG8gZ2V0IGJ1ZmZlcmVkIHByb3BlcnR5LlxuICAgKiBTb3VyY2VCdWZmZXIuYnVmZmVyZWQgbWF5IHRocm93IGlmIFNvdXJjZUJ1ZmZlciBpcyByZW1vdmVkIGZyb20gaXQncyBNZWRpYVNvdXJjZVxuICAgKi9cbiAgO1xuXG4gIEJ1ZmZlckhlbHBlci5nZXRCdWZmZXJlZCA9IGZ1bmN0aW9uIGdldEJ1ZmZlcmVkKG1lZGlhKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBtZWRpYS5idWZmZXJlZDtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJsb2dnZXJcIl0ubG9nKCdmYWlsZWQgdG8gZ2V0IG1lZGlhLmJ1ZmZlcmVkJywgZSk7XG4gICAgICByZXR1cm4gbm9vcEJ1ZmZlcmVkO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gQnVmZmVySGVscGVyO1xufSgpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy91dGlscy9jZWEtNjA4LXBhcnNlci50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy91dGlscy9jZWEtNjA4LXBhcnNlci50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBSb3csIENhcHRpb25TY3JlZW4sIGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiUm93XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gUm93OyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJDYXB0aW9uU2NyZWVuXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gQ2FwdGlvblNjcmVlbjsgfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvbG9nZ2VyICovIFwiLi9zcmMvdXRpbHMvbG9nZ2VyLnRzXCIpO1xuXG4vKipcbiAqXG4gKiBUaGlzIGNvZGUgd2FzIHBvcnRlZCBmcm9tIHRoZSBkYXNoLmpzIHByb2plY3QgYXQ6XG4gKiAgIGh0dHBzOi8vZ2l0aHViLmNvbS9EYXNoLUluZHVzdHJ5LUZvcnVtL2Rhc2guanMvYmxvYi9kZXZlbG9wbWVudC9leHRlcm5hbHMvY2VhNjA4LXBhcnNlci5qc1xuICogICBodHRwczovL2dpdGh1Yi5jb20vRGFzaC1JbmR1c3RyeS1Gb3J1bS9kYXNoLmpzL2NvbW1pdC84MjY5YjI2YTc2MWUwODUzYmIyMWQ3ODc4MGVkOTQ1MTQ0ZWNkZDRkI2RpZmYtNzFiYzI5NWEyZDZiNmI3MDkzYTFkMzI5MGQ1M2E0YjJcbiAqXG4gKiBUaGUgb3JpZ2luYWwgY29weXJpZ2h0IGFwcGVhcnMgYmVsb3c6XG4gKlxuICogVGhlIGNvcHlyaWdodCBpbiB0aGlzIHNvZnR3YXJlIGlzIGJlaW5nIG1hZGUgYXZhaWxhYmxlIHVuZGVyIHRoZSBCU0QgTGljZW5zZSxcbiAqIGluY2x1ZGVkIGJlbG93LiBUaGlzIHNvZnR3YXJlIG1heSBiZSBzdWJqZWN0IHRvIG90aGVyIHRoaXJkIHBhcnR5IGFuZCBjb250cmlidXRvclxuICogcmlnaHRzLCBpbmNsdWRpbmcgcGF0ZW50IHJpZ2h0cywgYW5kIG5vIHN1Y2ggcmlnaHRzIGFyZSBncmFudGVkIHVuZGVyIHRoaXMgbGljZW5zZS5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUtMjAxNiwgREFTSCBJbmR1c3RyeSBGb3J1bS5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0IG1vZGlmaWNhdGlvbixcbiAqIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcbiAqICAxLiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsIHRoaXNcbiAqICBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAqICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcbiAqICB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vclxuICogIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG4gKiAgMi4gTmVpdGhlciB0aGUgbmFtZSBvZiBEYXNoIEluZHVzdHJ5IEZvcnVtIG5vciB0aGUgbmFtZXMgb2YgaXRzXG4gKiAgY29udHJpYnV0b3JzIG1heSBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb20gdGhpcyBzb2Z0d2FyZVxuICogIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuICpcbiAqICBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIEFTIElTIEFORCBBTllcbiAqICBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEXG4gKiAgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELlxuICogIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgSE9MREVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsXG4gKiAgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVFxuICogIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1JcbiAqICBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSxcbiAqICBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpXG4gKiAgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEVcbiAqICBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAqL1xuXG4vKipcbiAqICBFeGNlcHRpb25zIGZyb20gcmVndWxhciBBU0NJSS4gQ29kZVBvaW50cyBhcmUgbWFwcGVkIHRvIFVURi0xNiBjb2Rlc1xuICovXG5cbnZhciBzcGVjaWFsQ2VhNjA4Q2hhcnNDb2RlcyA9IHtcbiAgMHgyYTogMHhlMSxcbiAgLy8gbG93ZXJjYXNlIGEsIGFjdXRlIGFjY2VudFxuICAweDVjOiAweGU5LFxuICAvLyBsb3dlcmNhc2UgZSwgYWN1dGUgYWNjZW50XG4gIDB4NWU6IDB4ZWQsXG4gIC8vIGxvd2VyY2FzZSBpLCBhY3V0ZSBhY2NlbnRcbiAgMHg1ZjogMHhmMyxcbiAgLy8gbG93ZXJjYXNlIG8sIGFjdXRlIGFjY2VudFxuICAweDYwOiAweGZhLFxuICAvLyBsb3dlcmNhc2UgdSwgYWN1dGUgYWNjZW50XG4gIDB4N2I6IDB4ZTcsXG4gIC8vIGxvd2VyY2FzZSBjIHdpdGggY2VkaWxsYVxuICAweDdjOiAweGY3LFxuICAvLyBkaXZpc2lvbiBzeW1ib2xcbiAgMHg3ZDogMHhkMSxcbiAgLy8gdXBwZXJjYXNlIE4gdGlsZGVcbiAgMHg3ZTogMHhmMSxcbiAgLy8gbG93ZXJjYXNlIG4gdGlsZGVcbiAgMHg3ZjogMHgyNTg4LFxuICAvLyBGdWxsIGJsb2NrXG4gIC8vIFRISVMgQkxPQ0sgSU5DTFVERVMgVEhFIDE2IEVYVEVOREVEIChUV08tQllURSkgTElORSAyMSBDSEFSQUNURVJTXG4gIC8vIFRIQVQgQ09NRSBGUk9NIEhJIEJZVEU9MHgxMSBBTkQgTE9XIEJFVFdFRU4gMHgzMCBBTkQgMHgzRlxuICAvLyBUSElTIE1FQU5TIFRIQVQgXFx4NTAgTVVTVCBCRSBBRERFRCBUTyBUSEUgVkFMVUVTXG4gIDB4ODA6IDB4YWUsXG4gIC8vIFJlZ2lzdGVyZWQgc3ltYm9sIChSKVxuICAweDgxOiAweGIwLFxuICAvLyBkZWdyZWUgc2lnblxuICAweDgyOiAweGJkLFxuICAvLyAxLzIgc3ltYm9sXG4gIDB4ODM6IDB4YmYsXG4gIC8vIEludmVydGVkIChvcGVuKSBxdWVzdGlvbiBtYXJrXG4gIDB4ODQ6IDB4MjEyMixcbiAgLy8gVHJhZGVtYXJrIHN5bWJvbCAoVE0pXG4gIDB4ODU6IDB4YTIsXG4gIC8vIENlbnRzIHN5bWJvbFxuICAweDg2OiAweGEzLFxuICAvLyBQb3VuZHMgc3RlcmxpbmdcbiAgMHg4NzogMHgyNjZhLFxuICAvLyBNdXNpYyA4J3RoIG5vdGVcbiAgMHg4ODogMHhlMCxcbiAgLy8gbG93ZXJjYXNlIGEsIGdyYXZlIGFjY2VudFxuICAweDg5OiAweDIwLFxuICAvLyB0cmFuc3BhcmVudCBzcGFjZSAocmVndWxhcilcbiAgMHg4YTogMHhlOCxcbiAgLy8gbG93ZXJjYXNlIGUsIGdyYXZlIGFjY2VudFxuICAweDhiOiAweGUyLFxuICAvLyBsb3dlcmNhc2UgYSwgY2lyY3VtZmxleCBhY2NlbnRcbiAgMHg4YzogMHhlYSxcbiAgLy8gbG93ZXJjYXNlIGUsIGNpcmN1bWZsZXggYWNjZW50XG4gIDB4OGQ6IDB4ZWUsXG4gIC8vIGxvd2VyY2FzZSBpLCBjaXJjdW1mbGV4IGFjY2VudFxuICAweDhlOiAweGY0LFxuICAvLyBsb3dlcmNhc2UgbywgY2lyY3VtZmxleCBhY2NlbnRcbiAgMHg4ZjogMHhmYixcbiAgLy8gbG93ZXJjYXNlIHUsIGNpcmN1bWZsZXggYWNjZW50XG4gIC8vIFRISVMgQkxPQ0sgSU5DTFVERVMgVEhFIDMyIEVYVEVOREVEIChUV08tQllURSkgTElORSAyMSBDSEFSQUNURVJTXG4gIC8vIFRIQVQgQ09NRSBGUk9NIEhJIEJZVEU9MHgxMiBBTkQgTE9XIEJFVFdFRU4gMHgyMCBBTkQgMHgzRlxuICAweDkwOiAweGMxLFxuICAvLyBjYXBpdGFsIGxldHRlciBBIHdpdGggYWN1dGVcbiAgMHg5MTogMHhjOSxcbiAgLy8gY2FwaXRhbCBsZXR0ZXIgRSB3aXRoIGFjdXRlXG4gIDB4OTI6IDB4ZDMsXG4gIC8vIGNhcGl0YWwgbGV0dGVyIE8gd2l0aCBhY3V0ZVxuICAweDkzOiAweGRhLFxuICAvLyBjYXBpdGFsIGxldHRlciBVIHdpdGggYWN1dGVcbiAgMHg5NDogMHhkYyxcbiAgLy8gY2FwaXRhbCBsZXR0ZXIgVSB3aXRoIGRpYXJlc2lzXG4gIDB4OTU6IDB4ZmMsXG4gIC8vIGxvd2VyY2FzZSBsZXR0ZXIgVSB3aXRoIGRpYWVyZXNpc1xuICAweDk2OiAweDIwMTgsXG4gIC8vIG9wZW5pbmcgc2luZ2xlIHF1b3RlXG4gIDB4OTc6IDB4YTEsXG4gIC8vIGludmVydGVkIGV4Y2xhbWF0aW9uIG1hcmtcbiAgMHg5ODogMHgyYSxcbiAgLy8gYXN0ZXJpc2tcbiAgMHg5OTogMHgyMDE5LFxuICAvLyBjbG9zaW5nIHNpbmdsZSBxdW90ZVxuICAweDlhOiAweDI1MDEsXG4gIC8vIGJveCBkcmF3aW5ncyBoZWF2eSBob3Jpem9udGFsXG4gIDB4OWI6IDB4YTksXG4gIC8vIGNvcHlyaWdodCBzaWduXG4gIDB4OWM6IDB4MjEyMCxcbiAgLy8gU2VydmljZSBtYXJrXG4gIDB4OWQ6IDB4MjAyMixcbiAgLy8gKHJvdW5kKSBidWxsZXRcbiAgMHg5ZTogMHgyMDFjLFxuICAvLyBMZWZ0IGRvdWJsZSBxdW90YXRpb24gbWFya1xuICAweDlmOiAweDIwMWQsXG4gIC8vIFJpZ2h0IGRvdWJsZSBxdW90YXRpb24gbWFya1xuICAweGEwOiAweGMwLFxuICAvLyB1cHBlcmNhc2UgQSwgZ3JhdmUgYWNjZW50XG4gIDB4YTE6IDB4YzIsXG4gIC8vIHVwcGVyY2FzZSBBLCBjaXJjdW1mbGV4XG4gIDB4YTI6IDB4YzcsXG4gIC8vIHVwcGVyY2FzZSBDIHdpdGggY2VkaWxsYVxuICAweGEzOiAweGM4LFxuICAvLyB1cHBlcmNhc2UgRSwgZ3JhdmUgYWNjZW50XG4gIDB4YTQ6IDB4Y2EsXG4gIC8vIHVwcGVyY2FzZSBFLCBjaXJjdW1mbGV4XG4gIDB4YTU6IDB4Y2IsXG4gIC8vIGNhcGl0YWwgbGV0dGVyIEUgd2l0aCBkaWFyZXNpc1xuICAweGE2OiAweGViLFxuICAvLyBsb3dlcmNhc2UgbGV0dGVyIGUgd2l0aCBkaWFyZXNpc1xuICAweGE3OiAweGNlLFxuICAvLyB1cHBlcmNhc2UgSSwgY2lyY3VtZmxleFxuICAweGE4OiAweGNmLFxuICAvLyB1cHBlcmNhc2UgSSwgd2l0aCBkaWFyZXNpc1xuICAweGE5OiAweGVmLFxuICAvLyBsb3dlcmNhc2UgaSwgd2l0aCBkaWFyZXNpc1xuICAweGFhOiAweGQ0LFxuICAvLyB1cHBlcmNhc2UgTywgY2lyY3VtZmxleFxuICAweGFiOiAweGQ5LFxuICAvLyB1cHBlcmNhc2UgVSwgZ3JhdmUgYWNjZW50XG4gIDB4YWM6IDB4ZjksXG4gIC8vIGxvd2VyY2FzZSB1LCBncmF2ZSBhY2NlbnRcbiAgMHhhZDogMHhkYixcbiAgLy8gdXBwZXJjYXNlIFUsIGNpcmN1bWZsZXhcbiAgMHhhZTogMHhhYixcbiAgLy8gbGVmdC1wb2ludGluZyBkb3VibGUgYW5nbGUgcXVvdGF0aW9uIG1hcmtcbiAgMHhhZjogMHhiYixcbiAgLy8gcmlnaHQtcG9pbnRpbmcgZG91YmxlIGFuZ2xlIHF1b3RhdGlvbiBtYXJrXG4gIC8vIFRISVMgQkxPQ0sgSU5DTFVERVMgVEhFIDMyIEVYVEVOREVEIChUV08tQllURSkgTElORSAyMSBDSEFSQUNURVJTXG4gIC8vIFRIQVQgQ09NRSBGUk9NIEhJIEJZVEU9MHgxMyBBTkQgTE9XIEJFVFdFRU4gMHgyMCBBTkQgMHgzRlxuICAweGIwOiAweGMzLFxuICAvLyBVcHBlcmNhc2UgQSwgdGlsZGVcbiAgMHhiMTogMHhlMyxcbiAgLy8gTG93ZXJjYXNlIGEsIHRpbGRlXG4gIDB4YjI6IDB4Y2QsXG4gIC8vIFVwcGVyY2FzZSBJLCBhY3V0ZSBhY2NlbnRcbiAgMHhiMzogMHhjYyxcbiAgLy8gVXBwZXJjYXNlIEksIGdyYXZlIGFjY2VudFxuICAweGI0OiAweGVjLFxuICAvLyBMb3dlcmNhc2UgaSwgZ3JhdmUgYWNjZW50XG4gIDB4YjU6IDB4ZDIsXG4gIC8vIFVwcGVyY2FzZSBPLCBncmF2ZSBhY2NlbnRcbiAgMHhiNjogMHhmMixcbiAgLy8gTG93ZXJjYXNlIG8sIGdyYXZlIGFjY2VudFxuICAweGI3OiAweGQ1LFxuICAvLyBVcHBlcmNhc2UgTywgdGlsZGVcbiAgMHhiODogMHhmNSxcbiAgLy8gTG93ZXJjYXNlIG8sIHRpbGRlXG4gIDB4Yjk6IDB4N2IsXG4gIC8vIE9wZW4gY3VybHkgYnJhY2VcbiAgMHhiYTogMHg3ZCxcbiAgLy8gQ2xvc2luZyBjdXJseSBicmFjZVxuICAweGJiOiAweDVjLFxuICAvLyBCYWNrc2xhc2hcbiAgMHhiYzogMHg1ZSxcbiAgLy8gQ2FyZXRcbiAgMHhiZDogMHg1ZixcbiAgLy8gVW5kZXJzY29yZVxuICAweGJlOiAweDdjLFxuICAvLyBQaXBlICh2ZXJ0aWNhbCBsaW5lKVxuICAweGJmOiAweDIyM2MsXG4gIC8vIFRpbGRlIG9wZXJhdG9yXG4gIDB4YzA6IDB4YzQsXG4gIC8vIFVwcGVyY2FzZSBBLCB1bWxhdXRcbiAgMHhjMTogMHhlNCxcbiAgLy8gTG93ZXJjYXNlIEEsIHVtbGF1dFxuICAweGMyOiAweGQ2LFxuICAvLyBVcHBlcmNhc2UgTywgdW1sYXV0XG4gIDB4YzM6IDB4ZjYsXG4gIC8vIExvd2VyY2FzZSBvLCB1bWxhdXRcbiAgMHhjNDogMHhkZixcbiAgLy8gRXNzemV0dCAoc2hhcnAgUylcbiAgMHhjNTogMHhhNSxcbiAgLy8gWWVuIHN5bWJvbFxuICAweGM2OiAweGE0LFxuICAvLyBHZW5lcmljIGN1cnJlbmN5IHNpZ25cbiAgMHhjNzogMHgyNTAzLFxuICAvLyBCb3ggZHJhd2luZ3MgaGVhdnkgdmVydGljYWxcbiAgMHhjODogMHhjNSxcbiAgLy8gVXBwZXJjYXNlIEEsIHJpbmdcbiAgMHhjOTogMHhlNSxcbiAgLy8gTG93ZXJjYXNlIEEsIHJpbmdcbiAgMHhjYTogMHhkOCxcbiAgLy8gVXBwZXJjYXNlIE8sIHN0cm9rZVxuICAweGNiOiAweGY4LFxuICAvLyBMb3dlcmNhc2Ugbywgc3Ryb2tcbiAgMHhjYzogMHgyNTBmLFxuICAvLyBCb3ggZHJhd2luZ3MgaGVhdnkgZG93biBhbmQgcmlnaHRcbiAgMHhjZDogMHgyNTEzLFxuICAvLyBCb3ggZHJhd2luZ3MgaGVhdnkgZG93biBhbmQgbGVmdFxuICAweGNlOiAweDI1MTcsXG4gIC8vIEJveCBkcmF3aW5ncyBoZWF2eSB1cCBhbmQgcmlnaHRcbiAgMHhjZjogMHgyNTFiIC8vIEJveCBkcmF3aW5ncyBoZWF2eSB1cCBhbmQgbGVmdFxuXG59O1xuLyoqXG4gKiBVdGlsc1xuICovXG5cbnZhciBnZXRDaGFyRm9yQnl0ZSA9IGZ1bmN0aW9uIGdldENoYXJGb3JCeXRlKF9ieXRlKSB7XG4gIHZhciBjaGFyQ29kZSA9IF9ieXRlO1xuXG4gIGlmIChzcGVjaWFsQ2VhNjA4Q2hhcnNDb2Rlcy5oYXNPd25Qcm9wZXJ0eShfYnl0ZSkpIHtcbiAgICBjaGFyQ29kZSA9IHNwZWNpYWxDZWE2MDhDaGFyc0NvZGVzW19ieXRlXTtcbiAgfVxuXG4gIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoYXJDb2RlKTtcbn07XG5cbnZhciBOUl9ST1dTID0gMTU7XG52YXIgTlJfQ09MUyA9IDEwMDsgLy8gVGFibGVzIHRvIGxvb2sgdXAgcm93IGZyb20gUEFDIGRhdGFcblxudmFyIHJvd3NMb3dDaDEgPSB7XG4gIDB4MTE6IDEsXG4gIDB4MTI6IDMsXG4gIDB4MTU6IDUsXG4gIDB4MTY6IDcsXG4gIDB4MTc6IDksXG4gIDB4MTA6IDExLFxuICAweDEzOiAxMixcbiAgMHgxNDogMTRcbn07XG52YXIgcm93c0hpZ2hDaDEgPSB7XG4gIDB4MTE6IDIsXG4gIDB4MTI6IDQsXG4gIDB4MTU6IDYsXG4gIDB4MTY6IDgsXG4gIDB4MTc6IDEwLFxuICAweDEzOiAxMyxcbiAgMHgxNDogMTVcbn07XG52YXIgcm93c0xvd0NoMiA9IHtcbiAgMHgxOTogMSxcbiAgMHgxYTogMyxcbiAgMHgxZDogNSxcbiAgMHgxZTogNyxcbiAgMHgxZjogOSxcbiAgMHgxODogMTEsXG4gIDB4MWI6IDEyLFxuICAweDFjOiAxNFxufTtcbnZhciByb3dzSGlnaENoMiA9IHtcbiAgMHgxOTogMixcbiAgMHgxYTogNCxcbiAgMHgxZDogNixcbiAgMHgxZTogOCxcbiAgMHgxZjogMTAsXG4gIDB4MWI6IDEzLFxuICAweDFjOiAxNVxufTtcbnZhciBiYWNrZ3JvdW5kQ29sb3JzID0gWyd3aGl0ZScsICdncmVlbicsICdibHVlJywgJ2N5YW4nLCAncmVkJywgJ3llbGxvdycsICdtYWdlbnRhJywgJ2JsYWNrJywgJ3RyYW5zcGFyZW50J107XG52YXIgVmVyYm9zZUxldmVsO1xuXG4oZnVuY3Rpb24gKFZlcmJvc2VMZXZlbCkge1xuICBWZXJib3NlTGV2ZWxbVmVyYm9zZUxldmVsW1wiRVJST1JcIl0gPSAwXSA9IFwiRVJST1JcIjtcbiAgVmVyYm9zZUxldmVsW1ZlcmJvc2VMZXZlbFtcIlRFWFRcIl0gPSAxXSA9IFwiVEVYVFwiO1xuICBWZXJib3NlTGV2ZWxbVmVyYm9zZUxldmVsW1wiV0FSTklOR1wiXSA9IDJdID0gXCJXQVJOSU5HXCI7XG4gIFZlcmJvc2VMZXZlbFtWZXJib3NlTGV2ZWxbXCJJTkZPXCJdID0gMl0gPSBcIklORk9cIjtcbiAgVmVyYm9zZUxldmVsW1ZlcmJvc2VMZXZlbFtcIkRFQlVHXCJdID0gM10gPSBcIkRFQlVHXCI7XG4gIFZlcmJvc2VMZXZlbFtWZXJib3NlTGV2ZWxbXCJEQVRBXCJdID0gM10gPSBcIkRBVEFcIjtcbn0pKFZlcmJvc2VMZXZlbCB8fCAoVmVyYm9zZUxldmVsID0ge30pKTtcblxudmFyIENhcHRpb25zTG9nZ2VyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQ2FwdGlvbnNMb2dnZXIoKSB7XG4gICAgdGhpcy50aW1lID0gbnVsbDtcbiAgICB0aGlzLnZlcmJvc2VMZXZlbCA9IFZlcmJvc2VMZXZlbC5FUlJPUjtcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBDYXB0aW9uc0xvZ2dlci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmxvZyA9IGZ1bmN0aW9uIGxvZyhzZXZlcml0eSwgbXNnKSB7XG4gICAgaWYgKHRoaXMudmVyYm9zZUxldmVsID49IHNldmVyaXR5KSB7XG4gICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJsb2dnZXJcIl0ubG9nKHRoaXMudGltZSArIFwiIFtcIiArIHNldmVyaXR5ICsgXCJdIFwiICsgbXNnKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIENhcHRpb25zTG9nZ2VyO1xufSgpO1xuXG52YXIgbnVtQXJyYXlUb0hleEFycmF5ID0gZnVuY3Rpb24gbnVtQXJyYXlUb0hleEFycmF5KG51bUFycmF5KSB7XG4gIHZhciBoZXhBcnJheSA9IFtdO1xuXG4gIGZvciAodmFyIGogPSAwOyBqIDwgbnVtQXJyYXkubGVuZ3RoOyBqKyspIHtcbiAgICBoZXhBcnJheS5wdXNoKG51bUFycmF5W2pdLnRvU3RyaW5nKDE2KSk7XG4gIH1cblxuICByZXR1cm4gaGV4QXJyYXk7XG59O1xuXG52YXIgUGVuU3RhdGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBQZW5TdGF0ZShmb3JlZ3JvdW5kLCB1bmRlcmxpbmUsIGl0YWxpY3MsIGJhY2tncm91bmQsIGZsYXNoKSB7XG4gICAgdGhpcy5mb3JlZ3JvdW5kID0gdm9pZCAwO1xuICAgIHRoaXMudW5kZXJsaW5lID0gdm9pZCAwO1xuICAgIHRoaXMuaXRhbGljcyA9IHZvaWQgMDtcbiAgICB0aGlzLmJhY2tncm91bmQgPSB2b2lkIDA7XG4gICAgdGhpcy5mbGFzaCA9IHZvaWQgMDtcbiAgICB0aGlzLmZvcmVncm91bmQgPSBmb3JlZ3JvdW5kIHx8ICd3aGl0ZSc7XG4gICAgdGhpcy51bmRlcmxpbmUgPSB1bmRlcmxpbmUgfHwgZmFsc2U7XG4gICAgdGhpcy5pdGFsaWNzID0gaXRhbGljcyB8fCBmYWxzZTtcbiAgICB0aGlzLmJhY2tncm91bmQgPSBiYWNrZ3JvdW5kIHx8ICdibGFjayc7XG4gICAgdGhpcy5mbGFzaCA9IGZsYXNoIHx8IGZhbHNlO1xuICB9XG5cbiAgdmFyIF9wcm90bzIgPSBQZW5TdGF0ZS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvMi5yZXNldCA9IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgIHRoaXMuZm9yZWdyb3VuZCA9ICd3aGl0ZSc7XG4gICAgdGhpcy51bmRlcmxpbmUgPSBmYWxzZTtcbiAgICB0aGlzLml0YWxpY3MgPSBmYWxzZTtcbiAgICB0aGlzLmJhY2tncm91bmQgPSAnYmxhY2snO1xuICAgIHRoaXMuZmxhc2ggPSBmYWxzZTtcbiAgfTtcblxuICBfcHJvdG8yLnNldFN0eWxlcyA9IGZ1bmN0aW9uIHNldFN0eWxlcyhzdHlsZXMpIHtcbiAgICB2YXIgYXR0cmlicyA9IFsnZm9yZWdyb3VuZCcsICd1bmRlcmxpbmUnLCAnaXRhbGljcycsICdiYWNrZ3JvdW5kJywgJ2ZsYXNoJ107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGF0dHJpYnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzdHlsZSA9IGF0dHJpYnNbaV07XG5cbiAgICAgIGlmIChzdHlsZXMuaGFzT3duUHJvcGVydHkoc3R5bGUpKSB7XG4gICAgICAgIHRoaXNbc3R5bGVdID0gc3R5bGVzW3N0eWxlXTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvMi5pc0RlZmF1bHQgPSBmdW5jdGlvbiBpc0RlZmF1bHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZm9yZWdyb3VuZCA9PT0gJ3doaXRlJyAmJiAhdGhpcy51bmRlcmxpbmUgJiYgIXRoaXMuaXRhbGljcyAmJiB0aGlzLmJhY2tncm91bmQgPT09ICdibGFjaycgJiYgIXRoaXMuZmxhc2g7XG4gIH07XG5cbiAgX3Byb3RvMi5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMob3RoZXIpIHtcbiAgICByZXR1cm4gdGhpcy5mb3JlZ3JvdW5kID09PSBvdGhlci5mb3JlZ3JvdW5kICYmIHRoaXMudW5kZXJsaW5lID09PSBvdGhlci51bmRlcmxpbmUgJiYgdGhpcy5pdGFsaWNzID09PSBvdGhlci5pdGFsaWNzICYmIHRoaXMuYmFja2dyb3VuZCA9PT0gb3RoZXIuYmFja2dyb3VuZCAmJiB0aGlzLmZsYXNoID09PSBvdGhlci5mbGFzaDtcbiAgfTtcblxuICBfcHJvdG8yLmNvcHkgPSBmdW5jdGlvbiBjb3B5KG5ld1BlblN0YXRlKSB7XG4gICAgdGhpcy5mb3JlZ3JvdW5kID0gbmV3UGVuU3RhdGUuZm9yZWdyb3VuZDtcbiAgICB0aGlzLnVuZGVybGluZSA9IG5ld1BlblN0YXRlLnVuZGVybGluZTtcbiAgICB0aGlzLml0YWxpY3MgPSBuZXdQZW5TdGF0ZS5pdGFsaWNzO1xuICAgIHRoaXMuYmFja2dyb3VuZCA9IG5ld1BlblN0YXRlLmJhY2tncm91bmQ7XG4gICAgdGhpcy5mbGFzaCA9IG5ld1BlblN0YXRlLmZsYXNoO1xuICB9O1xuXG4gIF9wcm90bzIudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gJ2NvbG9yPScgKyB0aGlzLmZvcmVncm91bmQgKyAnLCB1bmRlcmxpbmU9JyArIHRoaXMudW5kZXJsaW5lICsgJywgaXRhbGljcz0nICsgdGhpcy5pdGFsaWNzICsgJywgYmFja2dyb3VuZD0nICsgdGhpcy5iYWNrZ3JvdW5kICsgJywgZmxhc2g9JyArIHRoaXMuZmxhc2g7XG4gIH07XG5cbiAgcmV0dXJuIFBlblN0YXRlO1xufSgpO1xuLyoqXG4gKiBVbmljb2RlIGNoYXJhY3RlciB3aXRoIHN0eWxpbmcgYW5kIGJhY2tncm91bmQuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuXG5cbnZhciBTdHlsZWRVbmljb2RlQ2hhciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFN0eWxlZFVuaWNvZGVDaGFyKHVjaGFyLCBmb3JlZ3JvdW5kLCB1bmRlcmxpbmUsIGl0YWxpY3MsIGJhY2tncm91bmQsIGZsYXNoKSB7XG4gICAgdGhpcy51Y2hhciA9IHZvaWQgMDtcbiAgICB0aGlzLnBlblN0YXRlID0gdm9pZCAwO1xuICAgIHRoaXMudWNoYXIgPSB1Y2hhciB8fCAnICc7IC8vIHVuaWNvZGUgY2hhcmFjdGVyXG5cbiAgICB0aGlzLnBlblN0YXRlID0gbmV3IFBlblN0YXRlKGZvcmVncm91bmQsIHVuZGVybGluZSwgaXRhbGljcywgYmFja2dyb3VuZCwgZmxhc2gpO1xuICB9XG5cbiAgdmFyIF9wcm90bzMgPSBTdHlsZWRVbmljb2RlQ2hhci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvMy5yZXNldCA9IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgIHRoaXMudWNoYXIgPSAnICc7XG4gICAgdGhpcy5wZW5TdGF0ZS5yZXNldCgpO1xuICB9O1xuXG4gIF9wcm90bzMuc2V0Q2hhciA9IGZ1bmN0aW9uIHNldENoYXIodWNoYXIsIG5ld1BlblN0YXRlKSB7XG4gICAgdGhpcy51Y2hhciA9IHVjaGFyO1xuICAgIHRoaXMucGVuU3RhdGUuY29weShuZXdQZW5TdGF0ZSk7XG4gIH07XG5cbiAgX3Byb3RvMy5zZXRQZW5TdGF0ZSA9IGZ1bmN0aW9uIHNldFBlblN0YXRlKG5ld1BlblN0YXRlKSB7XG4gICAgdGhpcy5wZW5TdGF0ZS5jb3B5KG5ld1BlblN0YXRlKTtcbiAgfTtcblxuICBfcHJvdG8zLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyhvdGhlcikge1xuICAgIHJldHVybiB0aGlzLnVjaGFyID09PSBvdGhlci51Y2hhciAmJiB0aGlzLnBlblN0YXRlLmVxdWFscyhvdGhlci5wZW5TdGF0ZSk7XG4gIH07XG5cbiAgX3Byb3RvMy5jb3B5ID0gZnVuY3Rpb24gY29weShuZXdDaGFyKSB7XG4gICAgdGhpcy51Y2hhciA9IG5ld0NoYXIudWNoYXI7XG4gICAgdGhpcy5wZW5TdGF0ZS5jb3B5KG5ld0NoYXIucGVuU3RhdGUpO1xuICB9O1xuXG4gIF9wcm90bzMuaXNFbXB0eSA9IGZ1bmN0aW9uIGlzRW1wdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMudWNoYXIgPT09ICcgJyAmJiB0aGlzLnBlblN0YXRlLmlzRGVmYXVsdCgpO1xuICB9O1xuXG4gIHJldHVybiBTdHlsZWRVbmljb2RlQ2hhcjtcbn0oKTtcbi8qKlxuICogQ0VBLTYwOCByb3cgY29uc2lzdGluZyBvZiBOUl9DT0xTIGluc3RhbmNlcyBvZiBTdHlsZWRVbmljb2RlQ2hhci5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5cblxudmFyIFJvdyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFJvdyhsb2dnZXIpIHtcbiAgICB0aGlzLmNoYXJzID0gdm9pZCAwO1xuICAgIHRoaXMucG9zID0gdm9pZCAwO1xuICAgIHRoaXMuY3VyclBlblN0YXRlID0gdm9pZCAwO1xuICAgIHRoaXMuY3VlU3RhcnRUaW1lID0gdm9pZCAwO1xuICAgIHRoaXMubG9nZ2VyID0gdm9pZCAwO1xuICAgIHRoaXMuY2hhcnMgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTlJfQ09MUzsgaSsrKSB7XG4gICAgICB0aGlzLmNoYXJzLnB1c2gobmV3IFN0eWxlZFVuaWNvZGVDaGFyKCkpO1xuICAgIH1cblxuICAgIHRoaXMubG9nZ2VyID0gbG9nZ2VyO1xuICAgIHRoaXMucG9zID0gMDtcbiAgICB0aGlzLmN1cnJQZW5TdGF0ZSA9IG5ldyBQZW5TdGF0ZSgpO1xuICB9XG5cbiAgdmFyIF9wcm90bzQgPSBSb3cucHJvdG90eXBlO1xuXG4gIF9wcm90bzQuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzKG90aGVyKSB7XG4gICAgdmFyIGVxdWFsID0gdHJ1ZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTlJfQ09MUzsgaSsrKSB7XG4gICAgICBpZiAoIXRoaXMuY2hhcnNbaV0uZXF1YWxzKG90aGVyLmNoYXJzW2ldKSkge1xuICAgICAgICBlcXVhbCA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZXF1YWw7XG4gIH07XG5cbiAgX3Byb3RvNC5jb3B5ID0gZnVuY3Rpb24gY29weShvdGhlcikge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTlJfQ09MUzsgaSsrKSB7XG4gICAgICB0aGlzLmNoYXJzW2ldLmNvcHkob3RoZXIuY2hhcnNbaV0pO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG80LmlzRW1wdHkgPSBmdW5jdGlvbiBpc0VtcHR5KCkge1xuICAgIHZhciBlbXB0eSA9IHRydWU7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IE5SX0NPTFM7IGkrKykge1xuICAgICAgaWYgKCF0aGlzLmNoYXJzW2ldLmlzRW1wdHkoKSkge1xuICAgICAgICBlbXB0eSA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZW1wdHk7XG4gIH1cbiAgLyoqXG4gICAqICBTZXQgdGhlIGN1cnNvciB0byBhIHZhbGlkIGNvbHVtbi5cbiAgICovXG4gIDtcblxuICBfcHJvdG80LnNldEN1cnNvciA9IGZ1bmN0aW9uIHNldEN1cnNvcihhYnNQb3MpIHtcbiAgICBpZiAodGhpcy5wb3MgIT09IGFic1Bvcykge1xuICAgICAgdGhpcy5wb3MgPSBhYnNQb3M7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucG9zIDwgMCkge1xuICAgICAgdGhpcy5sb2dnZXIubG9nKFZlcmJvc2VMZXZlbC5ERUJVRywgJ05lZ2F0aXZlIGN1cnNvciBwb3NpdGlvbiAnICsgdGhpcy5wb3MpO1xuICAgICAgdGhpcy5wb3MgPSAwO1xuICAgIH0gZWxzZSBpZiAodGhpcy5wb3MgPiBOUl9DT0xTKSB7XG4gICAgICB0aGlzLmxvZ2dlci5sb2coVmVyYm9zZUxldmVsLkRFQlVHLCAnVG9vIGxhcmdlIGN1cnNvciBwb3NpdGlvbiAnICsgdGhpcy5wb3MpO1xuICAgICAgdGhpcy5wb3MgPSBOUl9DT0xTO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogTW92ZSB0aGUgY3Vyc29yIHJlbGF0aXZlIHRvIGN1cnJlbnQgcG9zaXRpb24uXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvNC5tb3ZlQ3Vyc29yID0gZnVuY3Rpb24gbW92ZUN1cnNvcihyZWxQb3MpIHtcbiAgICB2YXIgbmV3UG9zID0gdGhpcy5wb3MgKyByZWxQb3M7XG5cbiAgICBpZiAocmVsUG9zID4gMSkge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMucG9zICsgMTsgaSA8IG5ld1BvcyArIDE7IGkrKykge1xuICAgICAgICB0aGlzLmNoYXJzW2ldLnNldFBlblN0YXRlKHRoaXMuY3VyclBlblN0YXRlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnNldEN1cnNvcihuZXdQb3MpO1xuICB9XG4gIC8qKlxuICAgKiBCYWNrc3BhY2UsIG1vdmUgb25lIHN0ZXAgYmFjayBhbmQgY2xlYXIgY2hhcmFjdGVyLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90bzQuYmFja1NwYWNlID0gZnVuY3Rpb24gYmFja1NwYWNlKCkge1xuICAgIHRoaXMubW92ZUN1cnNvcigtMSk7XG4gICAgdGhpcy5jaGFyc1t0aGlzLnBvc10uc2V0Q2hhcignICcsIHRoaXMuY3VyclBlblN0YXRlKTtcbiAgfTtcblxuICBfcHJvdG80Lmluc2VydENoYXIgPSBmdW5jdGlvbiBpbnNlcnRDaGFyKF9ieXRlMikge1xuICAgIGlmIChfYnl0ZTIgPj0gMHg5MCkge1xuICAgICAgLy8gRXh0ZW5kZWQgY2hhclxuICAgICAgdGhpcy5iYWNrU3BhY2UoKTtcbiAgICB9XG5cbiAgICB2YXIgX2NoYXIgPSBnZXRDaGFyRm9yQnl0ZShfYnl0ZTIpO1xuXG4gICAgaWYgKHRoaXMucG9zID49IE5SX0NPTFMpIHtcbiAgICAgIHRoaXMubG9nZ2VyLmxvZyhWZXJib3NlTGV2ZWwuRVJST1IsICdDYW5ub3QgaW5zZXJ0ICcgKyBfYnl0ZTIudG9TdHJpbmcoMTYpICsgJyAoJyArIF9jaGFyICsgJykgYXQgcG9zaXRpb24gJyArIHRoaXMucG9zICsgJy4gU2tpcHBpbmcgaXQhJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5jaGFyc1t0aGlzLnBvc10uc2V0Q2hhcihfY2hhciwgdGhpcy5jdXJyUGVuU3RhdGUpO1xuICAgIHRoaXMubW92ZUN1cnNvcigxKTtcbiAgfTtcblxuICBfcHJvdG80LmNsZWFyRnJvbVBvcyA9IGZ1bmN0aW9uIGNsZWFyRnJvbVBvcyhzdGFydFBvcykge1xuICAgIHZhciBpO1xuXG4gICAgZm9yIChpID0gc3RhcnRQb3M7IGkgPCBOUl9DT0xTOyBpKyspIHtcbiAgICAgIHRoaXMuY2hhcnNbaV0ucmVzZXQoKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvNC5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgIHRoaXMuY2xlYXJGcm9tUG9zKDApO1xuICAgIHRoaXMucG9zID0gMDtcbiAgICB0aGlzLmN1cnJQZW5TdGF0ZS5yZXNldCgpO1xuICB9O1xuXG4gIF9wcm90bzQuY2xlYXJUb0VuZE9mUm93ID0gZnVuY3Rpb24gY2xlYXJUb0VuZE9mUm93KCkge1xuICAgIHRoaXMuY2xlYXJGcm9tUG9zKHRoaXMucG9zKTtcbiAgfTtcblxuICBfcHJvdG80LmdldFRleHRTdHJpbmcgPSBmdW5jdGlvbiBnZXRUZXh0U3RyaW5nKCkge1xuICAgIHZhciBjaGFycyA9IFtdO1xuICAgIHZhciBlbXB0eSA9IHRydWU7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IE5SX0NPTFM7IGkrKykge1xuICAgICAgdmFyIF9jaGFyMiA9IHRoaXMuY2hhcnNbaV0udWNoYXI7XG5cbiAgICAgIGlmIChfY2hhcjIgIT09ICcgJykge1xuICAgICAgICBlbXB0eSA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBjaGFycy5wdXNoKF9jaGFyMik7XG4gICAgfVxuXG4gICAgaWYgKGVtcHR5KSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjaGFycy5qb2luKCcnKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvNC5zZXRQZW5TdHlsZXMgPSBmdW5jdGlvbiBzZXRQZW5TdHlsZXMoc3R5bGVzKSB7XG4gICAgdGhpcy5jdXJyUGVuU3RhdGUuc2V0U3R5bGVzKHN0eWxlcyk7XG4gICAgdmFyIGN1cnJDaGFyID0gdGhpcy5jaGFyc1t0aGlzLnBvc107XG4gICAgY3VyckNoYXIuc2V0UGVuU3RhdGUodGhpcy5jdXJyUGVuU3RhdGUpO1xuICB9O1xuXG4gIHJldHVybiBSb3c7XG59KCk7XG4vKipcbiAqIEtlZXAgYSBDRUEtNjA4IHNjcmVlbiBvZiAzMngxNSBzdHlsZWQgY2hhcmFjdGVyc1xuICogQGNvbnN0cnVjdG9yXG4gKi9cblxudmFyIENhcHRpb25TY3JlZW4gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBDYXB0aW9uU2NyZWVuKGxvZ2dlcikge1xuICAgIHRoaXMucm93cyA9IHZvaWQgMDtcbiAgICB0aGlzLmN1cnJSb3cgPSB2b2lkIDA7XG4gICAgdGhpcy5uclJvbGxVcFJvd3MgPSB2b2lkIDA7XG4gICAgdGhpcy5sYXN0T3V0cHV0U2NyZWVuID0gdm9pZCAwO1xuICAgIHRoaXMubG9nZ2VyID0gdm9pZCAwO1xuICAgIHRoaXMucm93cyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOUl9ST1dTOyBpKyspIHtcbiAgICAgIHRoaXMucm93cy5wdXNoKG5ldyBSb3cobG9nZ2VyKSk7XG4gICAgfSAvLyBOb3RlIHRoYXQgd2UgdXNlIHplcm8tYmFzZWQgbnVtYmVyaW5nICgwLTE0KVxuXG5cbiAgICB0aGlzLmxvZ2dlciA9IGxvZ2dlcjtcbiAgICB0aGlzLmN1cnJSb3cgPSBOUl9ST1dTIC0gMTtcbiAgICB0aGlzLm5yUm9sbFVwUm93cyA9IG51bGw7XG4gICAgdGhpcy5sYXN0T3V0cHV0U2NyZWVuID0gbnVsbDtcbiAgICB0aGlzLnJlc2V0KCk7XG4gIH1cblxuICB2YXIgX3Byb3RvNSA9IENhcHRpb25TY3JlZW4ucHJvdG90eXBlO1xuXG4gIF9wcm90bzUucmVzZXQgPSBmdW5jdGlvbiByZXNldCgpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IE5SX1JPV1M7IGkrKykge1xuICAgICAgdGhpcy5yb3dzW2ldLmNsZWFyKCk7XG4gICAgfVxuXG4gICAgdGhpcy5jdXJyUm93ID0gTlJfUk9XUyAtIDE7XG4gIH07XG5cbiAgX3Byb3RvNS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMob3RoZXIpIHtcbiAgICB2YXIgZXF1YWwgPSB0cnVlO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOUl9ST1dTOyBpKyspIHtcbiAgICAgIGlmICghdGhpcy5yb3dzW2ldLmVxdWFscyhvdGhlci5yb3dzW2ldKSkge1xuICAgICAgICBlcXVhbCA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZXF1YWw7XG4gIH07XG5cbiAgX3Byb3RvNS5jb3B5ID0gZnVuY3Rpb24gY29weShvdGhlcikge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTlJfUk9XUzsgaSsrKSB7XG4gICAgICB0aGlzLnJvd3NbaV0uY29weShvdGhlci5yb3dzW2ldKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvNS5pc0VtcHR5ID0gZnVuY3Rpb24gaXNFbXB0eSgpIHtcbiAgICB2YXIgZW1wdHkgPSB0cnVlO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOUl9ST1dTOyBpKyspIHtcbiAgICAgIGlmICghdGhpcy5yb3dzW2ldLmlzRW1wdHkoKSkge1xuICAgICAgICBlbXB0eSA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZW1wdHk7XG4gIH07XG5cbiAgX3Byb3RvNS5iYWNrU3BhY2UgPSBmdW5jdGlvbiBiYWNrU3BhY2UoKSB7XG4gICAgdmFyIHJvdyA9IHRoaXMucm93c1t0aGlzLmN1cnJSb3ddO1xuICAgIHJvdy5iYWNrU3BhY2UoKTtcbiAgfTtcblxuICBfcHJvdG81LmNsZWFyVG9FbmRPZlJvdyA9IGZ1bmN0aW9uIGNsZWFyVG9FbmRPZlJvdygpIHtcbiAgICB2YXIgcm93ID0gdGhpcy5yb3dzW3RoaXMuY3VyclJvd107XG4gICAgcm93LmNsZWFyVG9FbmRPZlJvdygpO1xuICB9XG4gIC8qKlxuICAgKiBJbnNlcnQgYSBjaGFyYWN0ZXIgKHdpdGhvdXQgc3R5bGluZykgaW4gdGhlIGN1cnJlbnQgcm93LlxuICAgKi9cbiAgO1xuXG4gIF9wcm90bzUuaW5zZXJ0Q2hhciA9IGZ1bmN0aW9uIGluc2VydENoYXIoX2NoYXIzKSB7XG4gICAgdmFyIHJvdyA9IHRoaXMucm93c1t0aGlzLmN1cnJSb3ddO1xuICAgIHJvdy5pbnNlcnRDaGFyKF9jaGFyMyk7XG4gIH07XG5cbiAgX3Byb3RvNS5zZXRQZW4gPSBmdW5jdGlvbiBzZXRQZW4oc3R5bGVzKSB7XG4gICAgdmFyIHJvdyA9IHRoaXMucm93c1t0aGlzLmN1cnJSb3ddO1xuICAgIHJvdy5zZXRQZW5TdHlsZXMoc3R5bGVzKTtcbiAgfTtcblxuICBfcHJvdG81Lm1vdmVDdXJzb3IgPSBmdW5jdGlvbiBtb3ZlQ3Vyc29yKHJlbFBvcykge1xuICAgIHZhciByb3cgPSB0aGlzLnJvd3NbdGhpcy5jdXJyUm93XTtcbiAgICByb3cubW92ZUN1cnNvcihyZWxQb3MpO1xuICB9O1xuXG4gIF9wcm90bzUuc2V0Q3Vyc29yID0gZnVuY3Rpb24gc2V0Q3Vyc29yKGFic1Bvcykge1xuICAgIHRoaXMubG9nZ2VyLmxvZyhWZXJib3NlTGV2ZWwuSU5GTywgJ3NldEN1cnNvcjogJyArIGFic1Bvcyk7XG4gICAgdmFyIHJvdyA9IHRoaXMucm93c1t0aGlzLmN1cnJSb3ddO1xuICAgIHJvdy5zZXRDdXJzb3IoYWJzUG9zKTtcbiAgfTtcblxuICBfcHJvdG81LnNldFBBQyA9IGZ1bmN0aW9uIHNldFBBQyhwYWNEYXRhKSB7XG4gICAgdGhpcy5sb2dnZXIubG9nKFZlcmJvc2VMZXZlbC5JTkZPLCAncGFjRGF0YSA9ICcgKyBKU09OLnN0cmluZ2lmeShwYWNEYXRhKSk7XG4gICAgdmFyIG5ld1JvdyA9IHBhY0RhdGEucm93IC0gMTtcblxuICAgIGlmICh0aGlzLm5yUm9sbFVwUm93cyAmJiBuZXdSb3cgPCB0aGlzLm5yUm9sbFVwUm93cyAtIDEpIHtcbiAgICAgIG5ld1JvdyA9IHRoaXMubnJSb2xsVXBSb3dzIC0gMTtcbiAgICB9IC8vIE1ha2Ugc3VyZSB0aGlzIG9ubHkgYWZmZWN0cyBSb2xsLXVwIENhcHRpb25zIGJ5IGNoZWNraW5nIHRoaXMubnJSb2xsVXBSb3dzXG5cblxuICAgIGlmICh0aGlzLm5yUm9sbFVwUm93cyAmJiB0aGlzLmN1cnJSb3cgIT09IG5ld1Jvdykge1xuICAgICAgLy8gY2xlYXIgYWxsIHJvd3MgZmlyc3RcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTlJfUk9XUzsgaSsrKSB7XG4gICAgICAgIHRoaXMucm93c1tpXS5jbGVhcigpO1xuICAgICAgfSAvLyBDb3B5IHRoaXMubnJSb2xsVXBSb3dzIHJvd3MgZnJvbSBsYXN0T3V0cHV0U2NyZWVuIGFuZCBwbGFjZSBpdCBpbiB0aGUgbmV3Um93IGxvY2F0aW9uXG4gICAgICAvLyB0b3BSb3dJbmRleCAtIHRoZSBzdGFydCBvZiByb3dzIHRvIGNvcHkgKGluY2x1c2l2ZSBpbmRleClcblxuXG4gICAgICB2YXIgdG9wUm93SW5kZXggPSB0aGlzLmN1cnJSb3cgKyAxIC0gdGhpcy5uclJvbGxVcFJvd3M7IC8vIFdlIG9ubHkgY29weSBpZiB0aGUgbGFzdCBwb3NpdGlvbiB3YXMgYWxyZWFkeSBzaG93bi5cbiAgICAgIC8vIFdlIHVzZSB0aGUgY3VlU3RhcnRUaW1lIHZhbHVlIHRvIGNoZWNrIHRoaXMuXG5cbiAgICAgIHZhciBsYXN0T3V0cHV0U2NyZWVuID0gdGhpcy5sYXN0T3V0cHV0U2NyZWVuO1xuXG4gICAgICBpZiAobGFzdE91dHB1dFNjcmVlbikge1xuICAgICAgICB2YXIgcHJldkxpbmVUaW1lID0gbGFzdE91dHB1dFNjcmVlbi5yb3dzW3RvcFJvd0luZGV4XS5jdWVTdGFydFRpbWU7XG4gICAgICAgIHZhciB0aW1lID0gdGhpcy5sb2dnZXIudGltZTtcblxuICAgICAgICBpZiAocHJldkxpbmVUaW1lICYmIHRpbWUgIT09IG51bGwgJiYgcHJldkxpbmVUaW1lIDwgdGltZSkge1xuICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCB0aGlzLm5yUm9sbFVwUm93czsgX2krKykge1xuICAgICAgICAgICAgdGhpcy5yb3dzW25ld1JvdyAtIHRoaXMubnJSb2xsVXBSb3dzICsgX2kgKyAxXS5jb3B5KGxhc3RPdXRwdXRTY3JlZW4ucm93c1t0b3BSb3dJbmRleCArIF9pXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5jdXJyUm93ID0gbmV3Um93O1xuICAgIHZhciByb3cgPSB0aGlzLnJvd3NbdGhpcy5jdXJyUm93XTtcblxuICAgIGlmIChwYWNEYXRhLmluZGVudCAhPT0gbnVsbCkge1xuICAgICAgdmFyIGluZGVudCA9IHBhY0RhdGEuaW5kZW50O1xuICAgICAgdmFyIHByZXZQb3MgPSBNYXRoLm1heChpbmRlbnQgLSAxLCAwKTtcbiAgICAgIHJvdy5zZXRDdXJzb3IocGFjRGF0YS5pbmRlbnQpO1xuICAgICAgcGFjRGF0YS5jb2xvciA9IHJvdy5jaGFyc1twcmV2UG9zXS5wZW5TdGF0ZS5mb3JlZ3JvdW5kO1xuICAgIH1cblxuICAgIHZhciBzdHlsZXMgPSB7XG4gICAgICBmb3JlZ3JvdW5kOiBwYWNEYXRhLmNvbG9yLFxuICAgICAgdW5kZXJsaW5lOiBwYWNEYXRhLnVuZGVybGluZSxcbiAgICAgIGl0YWxpY3M6IHBhY0RhdGEuaXRhbGljcyxcbiAgICAgIGJhY2tncm91bmQ6ICdibGFjaycsXG4gICAgICBmbGFzaDogZmFsc2VcbiAgICB9O1xuICAgIHRoaXMuc2V0UGVuKHN0eWxlcyk7XG4gIH1cbiAgLyoqXG4gICAqIFNldCBiYWNrZ3JvdW5kL2V4dHJhIGZvcmVncm91bmQsIGJ1dCBmaXJzdCBkbyBiYWNrX3NwYWNlLCBhbmQgdGhlbiBpbnNlcnQgc3BhY2UgKGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5KS5cbiAgICovXG4gIDtcblxuICBfcHJvdG81LnNldEJrZ0RhdGEgPSBmdW5jdGlvbiBzZXRCa2dEYXRhKGJrZ0RhdGEpIHtcbiAgICB0aGlzLmxvZ2dlci5sb2coVmVyYm9zZUxldmVsLklORk8sICdia2dEYXRhID0gJyArIEpTT04uc3RyaW5naWZ5KGJrZ0RhdGEpKTtcbiAgICB0aGlzLmJhY2tTcGFjZSgpO1xuICAgIHRoaXMuc2V0UGVuKGJrZ0RhdGEpO1xuICAgIHRoaXMuaW5zZXJ0Q2hhcigweDIwKTsgLy8gU3BhY2VcbiAgfTtcblxuICBfcHJvdG81LnNldFJvbGxVcFJvd3MgPSBmdW5jdGlvbiBzZXRSb2xsVXBSb3dzKG5yUm93cykge1xuICAgIHRoaXMubnJSb2xsVXBSb3dzID0gbnJSb3dzO1xuICB9O1xuXG4gIF9wcm90bzUucm9sbFVwID0gZnVuY3Rpb24gcm9sbFVwKCkge1xuICAgIGlmICh0aGlzLm5yUm9sbFVwUm93cyA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5sb2dnZXIubG9nKFZlcmJvc2VMZXZlbC5ERUJVRywgJ3JvbGxfdXAgYnV0IG5yUm9sbFVwUm93cyBub3Qgc2V0IHlldCcpO1xuICAgICAgcmV0dXJuOyAvLyBOb3QgcHJvcGVybHkgc2V0dXBcbiAgICB9XG5cbiAgICB0aGlzLmxvZ2dlci5sb2coVmVyYm9zZUxldmVsLlRFWFQsIHRoaXMuZ2V0RGlzcGxheVRleHQoKSk7XG4gICAgdmFyIHRvcFJvd0luZGV4ID0gdGhpcy5jdXJyUm93ICsgMSAtIHRoaXMubnJSb2xsVXBSb3dzO1xuICAgIHZhciB0b3BSb3cgPSB0aGlzLnJvd3Muc3BsaWNlKHRvcFJvd0luZGV4LCAxKVswXTtcbiAgICB0b3BSb3cuY2xlYXIoKTtcbiAgICB0aGlzLnJvd3Muc3BsaWNlKHRoaXMuY3VyclJvdywgMCwgdG9wUm93KTtcbiAgICB0aGlzLmxvZ2dlci5sb2coVmVyYm9zZUxldmVsLklORk8sICdSb2xsaW5nIHVwJyk7IC8vIHRoaXMubG9nZ2VyLmxvZyhWZXJib3NlTGV2ZWwuVEVYVCwgdGhpcy5nZXRfZGlzcGxheV90ZXh0KCkpXG4gIH1cbiAgLyoqXG4gICAqIEdldCBhbGwgbm9uLWVtcHR5IHJvd3Mgd2l0aCBhcyB1bmljb2RlIHRleHQuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvNS5nZXREaXNwbGF5VGV4dCA9IGZ1bmN0aW9uIGdldERpc3BsYXlUZXh0KGFzT25lUm93KSB7XG4gICAgYXNPbmVSb3cgPSBhc09uZVJvdyB8fCBmYWxzZTtcbiAgICB2YXIgZGlzcGxheVRleHQgPSBbXTtcbiAgICB2YXIgdGV4dCA9ICcnO1xuICAgIHZhciByb3dOciA9IC0xO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOUl9ST1dTOyBpKyspIHtcbiAgICAgIHZhciByb3dUZXh0ID0gdGhpcy5yb3dzW2ldLmdldFRleHRTdHJpbmcoKTtcblxuICAgICAgaWYgKHJvd1RleHQpIHtcbiAgICAgICAgcm93TnIgPSBpICsgMTtcblxuICAgICAgICBpZiAoYXNPbmVSb3cpIHtcbiAgICAgICAgICBkaXNwbGF5VGV4dC5wdXNoKCdSb3cgJyArIHJvd05yICsgXCI6ICdcIiArIHJvd1RleHQgKyBcIidcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGlzcGxheVRleHQucHVzaChyb3dUZXh0LnRyaW0oKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZGlzcGxheVRleHQubGVuZ3RoID4gMCkge1xuICAgICAgaWYgKGFzT25lUm93KSB7XG4gICAgICAgIHRleHQgPSAnWycgKyBkaXNwbGF5VGV4dC5qb2luKCcgfCAnKSArICddJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRleHQgPSBkaXNwbGF5VGV4dC5qb2luKCdcXG4nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGV4dDtcbiAgfTtcblxuICBfcHJvdG81LmdldFRleHRBbmRGb3JtYXQgPSBmdW5jdGlvbiBnZXRUZXh0QW5kRm9ybWF0KCkge1xuICAgIHJldHVybiB0aGlzLnJvd3M7XG4gIH07XG5cbiAgcmV0dXJuIENhcHRpb25TY3JlZW47XG59KCk7IC8vIHZhciBtb2RlcyA9IFsnTU9ERV9ST0xMLVVQJywgJ01PREVfUE9QLU9OJywgJ01PREVfUEFJTlQtT04nLCAnTU9ERV9URVhUJ107XG5cbnZhciBDZWE2MDhDaGFubmVsID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQ2VhNjA4Q2hhbm5lbChjaGFubmVsTnVtYmVyLCBvdXRwdXRGaWx0ZXIsIGxvZ2dlcikge1xuICAgIHRoaXMuY2hOciA9IHZvaWQgMDtcbiAgICB0aGlzLm91dHB1dEZpbHRlciA9IHZvaWQgMDtcbiAgICB0aGlzLm1vZGUgPSB2b2lkIDA7XG4gICAgdGhpcy52ZXJib3NlID0gdm9pZCAwO1xuICAgIHRoaXMuZGlzcGxheWVkTWVtb3J5ID0gdm9pZCAwO1xuICAgIHRoaXMubm9uRGlzcGxheWVkTWVtb3J5ID0gdm9pZCAwO1xuICAgIHRoaXMubGFzdE91dHB1dFNjcmVlbiA9IHZvaWQgMDtcbiAgICB0aGlzLmN1cnJSb2xsVXBSb3cgPSB2b2lkIDA7XG4gICAgdGhpcy53cml0ZVNjcmVlbiA9IHZvaWQgMDtcbiAgICB0aGlzLmN1ZVN0YXJ0VGltZSA9IHZvaWQgMDtcbiAgICB0aGlzLmxvZ2dlciA9IHZvaWQgMDtcbiAgICB0aGlzLmNoTnIgPSBjaGFubmVsTnVtYmVyO1xuICAgIHRoaXMub3V0cHV0RmlsdGVyID0gb3V0cHV0RmlsdGVyO1xuICAgIHRoaXMubW9kZSA9IG51bGw7XG4gICAgdGhpcy52ZXJib3NlID0gMDtcbiAgICB0aGlzLmRpc3BsYXllZE1lbW9yeSA9IG5ldyBDYXB0aW9uU2NyZWVuKGxvZ2dlcik7XG4gICAgdGhpcy5ub25EaXNwbGF5ZWRNZW1vcnkgPSBuZXcgQ2FwdGlvblNjcmVlbihsb2dnZXIpO1xuICAgIHRoaXMubGFzdE91dHB1dFNjcmVlbiA9IG5ldyBDYXB0aW9uU2NyZWVuKGxvZ2dlcik7XG4gICAgdGhpcy5jdXJyUm9sbFVwUm93ID0gdGhpcy5kaXNwbGF5ZWRNZW1vcnkucm93c1tOUl9ST1dTIC0gMV07XG4gICAgdGhpcy53cml0ZVNjcmVlbiA9IHRoaXMuZGlzcGxheWVkTWVtb3J5O1xuICAgIHRoaXMubW9kZSA9IG51bGw7XG4gICAgdGhpcy5jdWVTdGFydFRpbWUgPSBudWxsOyAvLyBLZWVwcyB0cmFjayBvZiB3aGVyZSBhIGN1ZSBzdGFydGVkLlxuXG4gICAgdGhpcy5sb2dnZXIgPSBsb2dnZXI7XG4gIH1cblxuICB2YXIgX3Byb3RvNiA9IENlYTYwOENoYW5uZWwucHJvdG90eXBlO1xuXG4gIF9wcm90bzYucmVzZXQgPSBmdW5jdGlvbiByZXNldCgpIHtcbiAgICB0aGlzLm1vZGUgPSBudWxsO1xuICAgIHRoaXMuZGlzcGxheWVkTWVtb3J5LnJlc2V0KCk7XG4gICAgdGhpcy5ub25EaXNwbGF5ZWRNZW1vcnkucmVzZXQoKTtcbiAgICB0aGlzLmxhc3RPdXRwdXRTY3JlZW4ucmVzZXQoKTtcbiAgICB0aGlzLm91dHB1dEZpbHRlci5yZXNldCgpO1xuICAgIHRoaXMuY3VyclJvbGxVcFJvdyA9IHRoaXMuZGlzcGxheWVkTWVtb3J5LnJvd3NbTlJfUk9XUyAtIDFdO1xuICAgIHRoaXMud3JpdGVTY3JlZW4gPSB0aGlzLmRpc3BsYXllZE1lbW9yeTtcbiAgICB0aGlzLm1vZGUgPSBudWxsO1xuICAgIHRoaXMuY3VlU3RhcnRUaW1lID0gbnVsbDtcbiAgfTtcblxuICBfcHJvdG82LmdldEhhbmRsZXIgPSBmdW5jdGlvbiBnZXRIYW5kbGVyKCkge1xuICAgIHJldHVybiB0aGlzLm91dHB1dEZpbHRlcjtcbiAgfTtcblxuICBfcHJvdG82LnNldEhhbmRsZXIgPSBmdW5jdGlvbiBzZXRIYW5kbGVyKG5ld0hhbmRsZXIpIHtcbiAgICB0aGlzLm91dHB1dEZpbHRlciA9IG5ld0hhbmRsZXI7XG4gIH07XG5cbiAgX3Byb3RvNi5zZXRQQUMgPSBmdW5jdGlvbiBzZXRQQUMocGFjRGF0YSkge1xuICAgIHRoaXMud3JpdGVTY3JlZW4uc2V0UEFDKHBhY0RhdGEpO1xuICB9O1xuXG4gIF9wcm90bzYuc2V0QmtnRGF0YSA9IGZ1bmN0aW9uIHNldEJrZ0RhdGEoYmtnRGF0YSkge1xuICAgIHRoaXMud3JpdGVTY3JlZW4uc2V0QmtnRGF0YShia2dEYXRhKTtcbiAgfTtcblxuICBfcHJvdG82LnNldE1vZGUgPSBmdW5jdGlvbiBzZXRNb2RlKG5ld01vZGUpIHtcbiAgICBpZiAobmV3TW9kZSA9PT0gdGhpcy5tb2RlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5tb2RlID0gbmV3TW9kZTtcbiAgICB0aGlzLmxvZ2dlci5sb2coVmVyYm9zZUxldmVsLklORk8sICdNT0RFPScgKyBuZXdNb2RlKTtcblxuICAgIGlmICh0aGlzLm1vZGUgPT09ICdNT0RFX1BPUC1PTicpIHtcbiAgICAgIHRoaXMud3JpdGVTY3JlZW4gPSB0aGlzLm5vbkRpc3BsYXllZE1lbW9yeTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy53cml0ZVNjcmVlbiA9IHRoaXMuZGlzcGxheWVkTWVtb3J5O1xuICAgICAgdGhpcy53cml0ZVNjcmVlbi5yZXNldCgpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLm1vZGUgIT09ICdNT0RFX1JPTEwtVVAnKSB7XG4gICAgICB0aGlzLmRpc3BsYXllZE1lbW9yeS5uclJvbGxVcFJvd3MgPSBudWxsO1xuICAgICAgdGhpcy5ub25EaXNwbGF5ZWRNZW1vcnkubnJSb2xsVXBSb3dzID0gbnVsbDtcbiAgICB9XG5cbiAgICB0aGlzLm1vZGUgPSBuZXdNb2RlO1xuICB9O1xuXG4gIF9wcm90bzYuaW5zZXJ0Q2hhcnMgPSBmdW5jdGlvbiBpbnNlcnRDaGFycyhjaGFycykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMud3JpdGVTY3JlZW4uaW5zZXJ0Q2hhcihjaGFyc1tpXSk7XG4gICAgfVxuXG4gICAgdmFyIHNjcmVlbiA9IHRoaXMud3JpdGVTY3JlZW4gPT09IHRoaXMuZGlzcGxheWVkTWVtb3J5ID8gJ0RJU1AnIDogJ05PTl9ESVNQJztcbiAgICB0aGlzLmxvZ2dlci5sb2coVmVyYm9zZUxldmVsLklORk8sIHNjcmVlbiArICc6ICcgKyB0aGlzLndyaXRlU2NyZWVuLmdldERpc3BsYXlUZXh0KHRydWUpKTtcblxuICAgIGlmICh0aGlzLm1vZGUgPT09ICdNT0RFX1BBSU5ULU9OJyB8fCB0aGlzLm1vZGUgPT09ICdNT0RFX1JPTEwtVVAnKSB7XG4gICAgICB0aGlzLmxvZ2dlci5sb2coVmVyYm9zZUxldmVsLlRFWFQsICdESVNQTEFZRUQ6ICcgKyB0aGlzLmRpc3BsYXllZE1lbW9yeS5nZXREaXNwbGF5VGV4dCh0cnVlKSk7XG4gICAgICB0aGlzLm91dHB1dERhdGFVcGRhdGUoKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvNi5jY1JDTCA9IGZ1bmN0aW9uIGNjUkNMKCkge1xuICAgIC8vIFJlc3VtZSBDYXB0aW9uIExvYWRpbmcgKHN3aXRjaCBtb2RlIHRvIFBvcCBPbilcbiAgICB0aGlzLmxvZ2dlci5sb2coVmVyYm9zZUxldmVsLklORk8sICdSQ0wgLSBSZXN1bWUgQ2FwdGlvbiBMb2FkaW5nJyk7XG4gICAgdGhpcy5zZXRNb2RlKCdNT0RFX1BPUC1PTicpO1xuICB9O1xuXG4gIF9wcm90bzYuY2NCUyA9IGZ1bmN0aW9uIGNjQlMoKSB7XG4gICAgLy8gQmFja1NwYWNlXG4gICAgdGhpcy5sb2dnZXIubG9nKFZlcmJvc2VMZXZlbC5JTkZPLCAnQlMgLSBCYWNrU3BhY2UnKTtcblxuICAgIGlmICh0aGlzLm1vZGUgPT09ICdNT0RFX1RFWFQnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy53cml0ZVNjcmVlbi5iYWNrU3BhY2UoKTtcblxuICAgIGlmICh0aGlzLndyaXRlU2NyZWVuID09PSB0aGlzLmRpc3BsYXllZE1lbW9yeSkge1xuICAgICAgdGhpcy5vdXRwdXREYXRhVXBkYXRlKCk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90bzYuY2NBT0YgPSBmdW5jdGlvbiBjY0FPRigpIHsvLyBSZXNlcnZlZCAoZm9ybWVybHkgQWxhcm0gT2ZmKVxuICB9O1xuXG4gIF9wcm90bzYuY2NBT04gPSBmdW5jdGlvbiBjY0FPTigpIHsvLyBSZXNlcnZlZCAoZm9ybWVybHkgQWxhcm0gT24pXG4gIH07XG5cbiAgX3Byb3RvNi5jY0RFUiA9IGZ1bmN0aW9uIGNjREVSKCkge1xuICAgIC8vIERlbGV0ZSB0byBFbmQgb2YgUm93XG4gICAgdGhpcy5sb2dnZXIubG9nKFZlcmJvc2VMZXZlbC5JTkZPLCAnREVSLSBEZWxldGUgdG8gRW5kIG9mIFJvdycpO1xuICAgIHRoaXMud3JpdGVTY3JlZW4uY2xlYXJUb0VuZE9mUm93KCk7XG4gICAgdGhpcy5vdXRwdXREYXRhVXBkYXRlKCk7XG4gIH07XG5cbiAgX3Byb3RvNi5jY1JVID0gZnVuY3Rpb24gY2NSVShuclJvd3MpIHtcbiAgICAvLyBSb2xsLVVwIENhcHRpb25zLTIsMyxvciA0IFJvd3NcbiAgICB0aGlzLmxvZ2dlci5sb2coVmVyYm9zZUxldmVsLklORk8sICdSVSgnICsgbnJSb3dzICsgJykgLSBSb2xsIFVwJyk7XG4gICAgdGhpcy53cml0ZVNjcmVlbiA9IHRoaXMuZGlzcGxheWVkTWVtb3J5O1xuICAgIHRoaXMuc2V0TW9kZSgnTU9ERV9ST0xMLVVQJyk7XG4gICAgdGhpcy53cml0ZVNjcmVlbi5zZXRSb2xsVXBSb3dzKG5yUm93cyk7XG4gIH07XG5cbiAgX3Byb3RvNi5jY0ZPTiA9IGZ1bmN0aW9uIGNjRk9OKCkge1xuICAgIC8vIEZsYXNoIE9uXG4gICAgdGhpcy5sb2dnZXIubG9nKFZlcmJvc2VMZXZlbC5JTkZPLCAnRk9OIC0gRmxhc2ggT24nKTtcbiAgICB0aGlzLndyaXRlU2NyZWVuLnNldFBlbih7XG4gICAgICBmbGFzaDogdHJ1ZVxuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90bzYuY2NSREMgPSBmdW5jdGlvbiBjY1JEQygpIHtcbiAgICAvLyBSZXN1bWUgRGlyZWN0IENhcHRpb25pbmcgKHN3aXRjaCBtb2RlIHRvIFBhaW50T24pXG4gICAgdGhpcy5sb2dnZXIubG9nKFZlcmJvc2VMZXZlbC5JTkZPLCAnUkRDIC0gUmVzdW1lIERpcmVjdCBDYXB0aW9uaW5nJyk7XG4gICAgdGhpcy5zZXRNb2RlKCdNT0RFX1BBSU5ULU9OJyk7XG4gIH07XG5cbiAgX3Byb3RvNi5jY1RSID0gZnVuY3Rpb24gY2NUUigpIHtcbiAgICAvLyBUZXh0IFJlc3RhcnQgaW4gdGV4dCBtb2RlIChub3Qgc3VwcG9ydGVkLCBob3dldmVyKVxuICAgIHRoaXMubG9nZ2VyLmxvZyhWZXJib3NlTGV2ZWwuSU5GTywgJ1RSJyk7XG4gICAgdGhpcy5zZXRNb2RlKCdNT0RFX1RFWFQnKTtcbiAgfTtcblxuICBfcHJvdG82LmNjUlREID0gZnVuY3Rpb24gY2NSVEQoKSB7XG4gICAgLy8gUmVzdW1lIFRleHQgRGlzcGxheSBpbiBUZXh0IG1vZGUgKG5vdCBzdXBwb3J0ZWQsIGhvd2V2ZXIpXG4gICAgdGhpcy5sb2dnZXIubG9nKFZlcmJvc2VMZXZlbC5JTkZPLCAnUlREJyk7XG4gICAgdGhpcy5zZXRNb2RlKCdNT0RFX1RFWFQnKTtcbiAgfTtcblxuICBfcHJvdG82LmNjRURNID0gZnVuY3Rpb24gY2NFRE0oKSB7XG4gICAgLy8gRXJhc2UgRGlzcGxheWVkIE1lbW9yeVxuICAgIHRoaXMubG9nZ2VyLmxvZyhWZXJib3NlTGV2ZWwuSU5GTywgJ0VETSAtIEVyYXNlIERpc3BsYXllZCBNZW1vcnknKTtcbiAgICB0aGlzLmRpc3BsYXllZE1lbW9yeS5yZXNldCgpO1xuICAgIHRoaXMub3V0cHV0RGF0YVVwZGF0ZSh0cnVlKTtcbiAgfTtcblxuICBfcHJvdG82LmNjQ1IgPSBmdW5jdGlvbiBjY0NSKCkge1xuICAgIC8vIENhcnJpYWdlIFJldHVyblxuICAgIHRoaXMubG9nZ2VyLmxvZyhWZXJib3NlTGV2ZWwuSU5GTywgJ0NSIC0gQ2FycmlhZ2UgUmV0dXJuJyk7XG4gICAgdGhpcy53cml0ZVNjcmVlbi5yb2xsVXAoKTtcbiAgICB0aGlzLm91dHB1dERhdGFVcGRhdGUodHJ1ZSk7XG4gIH07XG5cbiAgX3Byb3RvNi5jY0VOTSA9IGZ1bmN0aW9uIGNjRU5NKCkge1xuICAgIC8vIEVyYXNlIE5vbi1EaXNwbGF5ZWQgTWVtb3J5XG4gICAgdGhpcy5sb2dnZXIubG9nKFZlcmJvc2VMZXZlbC5JTkZPLCAnRU5NIC0gRXJhc2UgTm9uLWRpc3BsYXllZCBNZW1vcnknKTtcbiAgICB0aGlzLm5vbkRpc3BsYXllZE1lbW9yeS5yZXNldCgpO1xuICB9O1xuXG4gIF9wcm90bzYuY2NFT0MgPSBmdW5jdGlvbiBjY0VPQygpIHtcbiAgICAvLyBFbmQgb2YgQ2FwdGlvbiAoRmxpcCBNZW1vcmllcylcbiAgICB0aGlzLmxvZ2dlci5sb2coVmVyYm9zZUxldmVsLklORk8sICdFT0MgLSBFbmQgT2YgQ2FwdGlvbicpO1xuXG4gICAgaWYgKHRoaXMubW9kZSA9PT0gJ01PREVfUE9QLU9OJykge1xuICAgICAgdmFyIHRtcCA9IHRoaXMuZGlzcGxheWVkTWVtb3J5O1xuICAgICAgdGhpcy5kaXNwbGF5ZWRNZW1vcnkgPSB0aGlzLm5vbkRpc3BsYXllZE1lbW9yeTtcbiAgICAgIHRoaXMubm9uRGlzcGxheWVkTWVtb3J5ID0gdG1wO1xuICAgICAgdGhpcy53cml0ZVNjcmVlbiA9IHRoaXMubm9uRGlzcGxheWVkTWVtb3J5O1xuICAgICAgdGhpcy5sb2dnZXIubG9nKFZlcmJvc2VMZXZlbC5URVhULCAnRElTUDogJyArIHRoaXMuZGlzcGxheWVkTWVtb3J5LmdldERpc3BsYXlUZXh0KCkpO1xuICAgIH1cblxuICAgIHRoaXMub3V0cHV0RGF0YVVwZGF0ZSh0cnVlKTtcbiAgfTtcblxuICBfcHJvdG82LmNjVE8gPSBmdW5jdGlvbiBjY1RPKG5yQ29scykge1xuICAgIC8vIFRhYiBPZmZzZXQgMSwyLCBvciAzIGNvbHVtbnNcbiAgICB0aGlzLmxvZ2dlci5sb2coVmVyYm9zZUxldmVsLklORk8sICdUTygnICsgbnJDb2xzICsgJykgLSBUYWIgT2Zmc2V0Jyk7XG4gICAgdGhpcy53cml0ZVNjcmVlbi5tb3ZlQ3Vyc29yKG5yQ29scyk7XG4gIH07XG5cbiAgX3Byb3RvNi5jY01JRFJPVyA9IGZ1bmN0aW9uIGNjTUlEUk9XKHNlY29uZEJ5dGUpIHtcbiAgICAvLyBQYXJzZSBNSURST1cgY29tbWFuZFxuICAgIHZhciBzdHlsZXMgPSB7XG4gICAgICBmbGFzaDogZmFsc2VcbiAgICB9O1xuICAgIHN0eWxlcy51bmRlcmxpbmUgPSBzZWNvbmRCeXRlICUgMiA9PT0gMTtcbiAgICBzdHlsZXMuaXRhbGljcyA9IHNlY29uZEJ5dGUgPj0gMHgyZTtcblxuICAgIGlmICghc3R5bGVzLml0YWxpY3MpIHtcbiAgICAgIHZhciBjb2xvckluZGV4ID0gTWF0aC5mbG9vcihzZWNvbmRCeXRlIC8gMikgLSAweDEwO1xuICAgICAgdmFyIGNvbG9ycyA9IFsnd2hpdGUnLCAnZ3JlZW4nLCAnYmx1ZScsICdjeWFuJywgJ3JlZCcsICd5ZWxsb3cnLCAnbWFnZW50YSddO1xuICAgICAgc3R5bGVzLmZvcmVncm91bmQgPSBjb2xvcnNbY29sb3JJbmRleF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0eWxlcy5mb3JlZ3JvdW5kID0gJ3doaXRlJztcbiAgICB9XG5cbiAgICB0aGlzLmxvZ2dlci5sb2coVmVyYm9zZUxldmVsLklORk8sICdNSURST1c6ICcgKyBKU09OLnN0cmluZ2lmeShzdHlsZXMpKTtcbiAgICB0aGlzLndyaXRlU2NyZWVuLnNldFBlbihzdHlsZXMpO1xuICB9O1xuXG4gIF9wcm90bzYub3V0cHV0RGF0YVVwZGF0ZSA9IGZ1bmN0aW9uIG91dHB1dERhdGFVcGRhdGUoZGlzcGF0Y2gpIHtcbiAgICBpZiAoZGlzcGF0Y2ggPT09IHZvaWQgMCkge1xuICAgICAgZGlzcGF0Y2ggPSBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgdGltZSA9IHRoaXMubG9nZ2VyLnRpbWU7XG5cbiAgICBpZiAodGltZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLm91dHB1dEZpbHRlcikge1xuICAgICAgaWYgKHRoaXMuY3VlU3RhcnRUaW1lID09PSBudWxsICYmICF0aGlzLmRpc3BsYXllZE1lbW9yeS5pc0VtcHR5KCkpIHtcbiAgICAgICAgLy8gU3RhcnQgb2YgYSBuZXcgY3VlXG4gICAgICAgIHRoaXMuY3VlU3RhcnRUaW1lID0gdGltZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghdGhpcy5kaXNwbGF5ZWRNZW1vcnkuZXF1YWxzKHRoaXMubGFzdE91dHB1dFNjcmVlbikpIHtcbiAgICAgICAgICB0aGlzLm91dHB1dEZpbHRlci5uZXdDdWUodGhpcy5jdWVTdGFydFRpbWUsIHRpbWUsIHRoaXMubGFzdE91dHB1dFNjcmVlbik7XG5cbiAgICAgICAgICBpZiAoZGlzcGF0Y2ggJiYgdGhpcy5vdXRwdXRGaWx0ZXIuZGlzcGF0Y2hDdWUpIHtcbiAgICAgICAgICAgIHRoaXMub3V0cHV0RmlsdGVyLmRpc3BhdGNoQ3VlKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5jdWVTdGFydFRpbWUgPSB0aGlzLmRpc3BsYXllZE1lbW9yeS5pc0VtcHR5KCkgPyBudWxsIDogdGltZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLmxhc3RPdXRwdXRTY3JlZW4uY29weSh0aGlzLmRpc3BsYXllZE1lbW9yeSk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90bzYuY3VlU3BsaXRBdFRpbWUgPSBmdW5jdGlvbiBjdWVTcGxpdEF0VGltZSh0KSB7XG4gICAgaWYgKHRoaXMub3V0cHV0RmlsdGVyKSB7XG4gICAgICBpZiAoIXRoaXMuZGlzcGxheWVkTWVtb3J5LmlzRW1wdHkoKSkge1xuICAgICAgICBpZiAodGhpcy5vdXRwdXRGaWx0ZXIubmV3Q3VlKSB7XG4gICAgICAgICAgdGhpcy5vdXRwdXRGaWx0ZXIubmV3Q3VlKHRoaXMuY3VlU3RhcnRUaW1lLCB0LCB0aGlzLmRpc3BsYXllZE1lbW9yeSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmN1ZVN0YXJ0VGltZSA9IHQ7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBDZWE2MDhDaGFubmVsO1xufSgpO1xuXG52YXIgQ2VhNjA4UGFyc2VyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQ2VhNjA4UGFyc2VyKGZpZWxkLCBvdXQxLCBvdXQyKSB7XG4gICAgdGhpcy5jaGFubmVscyA9IHZvaWQgMDtcbiAgICB0aGlzLmN1cnJlbnRDaGFubmVsID0gMDtcbiAgICB0aGlzLmNtZEhpc3RvcnkgPSB2b2lkIDA7XG4gICAgdGhpcy5sb2dnZXIgPSB2b2lkIDA7XG4gICAgdmFyIGxvZ2dlciA9IG5ldyBDYXB0aW9uc0xvZ2dlcigpO1xuICAgIHRoaXMuY2hhbm5lbHMgPSBbbnVsbCwgbmV3IENlYTYwOENoYW5uZWwoZmllbGQsIG91dDEsIGxvZ2dlciksIG5ldyBDZWE2MDhDaGFubmVsKGZpZWxkICsgMSwgb3V0MiwgbG9nZ2VyKV07XG4gICAgdGhpcy5jbWRIaXN0b3J5ID0gY3JlYXRlQ21kSGlzdG9yeSgpO1xuICAgIHRoaXMubG9nZ2VyID0gbG9nZ2VyO1xuICB9XG5cbiAgdmFyIF9wcm90bzcgPSBDZWE2MDhQYXJzZXIucHJvdG90eXBlO1xuXG4gIF9wcm90bzcuZ2V0SGFuZGxlciA9IGZ1bmN0aW9uIGdldEhhbmRsZXIoY2hhbm5lbCkge1xuICAgIHJldHVybiB0aGlzLmNoYW5uZWxzW2NoYW5uZWxdLmdldEhhbmRsZXIoKTtcbiAgfTtcblxuICBfcHJvdG83LnNldEhhbmRsZXIgPSBmdW5jdGlvbiBzZXRIYW5kbGVyKGNoYW5uZWwsIG5ld0hhbmRsZXIpIHtcbiAgICB0aGlzLmNoYW5uZWxzW2NoYW5uZWxdLnNldEhhbmRsZXIobmV3SGFuZGxlcik7XG4gIH1cbiAgLyoqXG4gICAqIEFkZCBkYXRhIGZvciB0aW1lIHQgaW4gZm9ybXMgb2YgbGlzdCBvZiBieXRlcyAodW5zaWduZWQgaW50cykuIFRoZSBieXRlcyBhcmUgdHJlYXRlZCBhcyBwYWlycy5cbiAgICovXG4gIDtcblxuICBfcHJvdG83LmFkZERhdGEgPSBmdW5jdGlvbiBhZGREYXRhKHRpbWUsIGJ5dGVMaXN0KSB7XG4gICAgdmFyIGNtZEZvdW5kO1xuICAgIHZhciBhO1xuICAgIHZhciBiO1xuICAgIHZhciBjaGFyc0ZvdW5kID0gZmFsc2U7XG4gICAgdGhpcy5sb2dnZXIudGltZSA9IHRpbWU7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVMaXN0Lmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICBhID0gYnl0ZUxpc3RbaV0gJiAweDdmO1xuICAgICAgYiA9IGJ5dGVMaXN0W2kgKyAxXSAmIDB4N2Y7XG5cbiAgICAgIGlmIChhID09PSAwICYmIGIgPT09IDApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmxvZ2dlci5sb2coVmVyYm9zZUxldmVsLkRBVEEsICdbJyArIG51bUFycmF5VG9IZXhBcnJheShbYnl0ZUxpc3RbaV0sIGJ5dGVMaXN0W2kgKyAxXV0pICsgJ10gLT4gKCcgKyBudW1BcnJheVRvSGV4QXJyYXkoW2EsIGJdKSArICcpJyk7XG4gICAgICB9XG5cbiAgICAgIGNtZEZvdW5kID0gdGhpcy5wYXJzZUNtZChhLCBiKTtcblxuICAgICAgaWYgKCFjbWRGb3VuZCkge1xuICAgICAgICBjbWRGb3VuZCA9IHRoaXMucGFyc2VNaWRyb3coYSwgYik7XG4gICAgICB9XG5cbiAgICAgIGlmICghY21kRm91bmQpIHtcbiAgICAgICAgY21kRm91bmQgPSB0aGlzLnBhcnNlUEFDKGEsIGIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWNtZEZvdW5kKSB7XG4gICAgICAgIGNtZEZvdW5kID0gdGhpcy5wYXJzZUJhY2tncm91bmRBdHRyaWJ1dGVzKGEsIGIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWNtZEZvdW5kKSB7XG4gICAgICAgIGNoYXJzRm91bmQgPSB0aGlzLnBhcnNlQ2hhcnMoYSwgYik7XG5cbiAgICAgICAgaWYgKGNoYXJzRm91bmQpIHtcbiAgICAgICAgICB2YXIgY3VyckNoTnIgPSB0aGlzLmN1cnJlbnRDaGFubmVsO1xuXG4gICAgICAgICAgaWYgKGN1cnJDaE5yICYmIGN1cnJDaE5yID4gMCkge1xuICAgICAgICAgICAgdmFyIGNoYW5uZWwgPSB0aGlzLmNoYW5uZWxzW2N1cnJDaE5yXTtcbiAgICAgICAgICAgIGNoYW5uZWwuaW5zZXJ0Q2hhcnMoY2hhcnNGb3VuZCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmxvZyhWZXJib3NlTGV2ZWwuV0FSTklORywgJ05vIGNoYW5uZWwgZm91bmQgeWV0LiBURVhULU1PREU/Jyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghY21kRm91bmQgJiYgIWNoYXJzRm91bmQpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIubG9nKFZlcmJvc2VMZXZlbC5XQVJOSU5HLCBcIkNvdWxkbid0IHBhcnNlIGNsZWFuZWQgZGF0YSBcIiArIG51bUFycmF5VG9IZXhBcnJheShbYSwgYl0pICsgJyBvcmlnOiAnICsgbnVtQXJyYXlUb0hleEFycmF5KFtieXRlTGlzdFtpXSwgYnl0ZUxpc3RbaSArIDFdXSkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogUGFyc2UgQ29tbWFuZC5cbiAgICogQHJldHVybnMge0Jvb2xlYW59IFRlbGxzIGlmIGEgY29tbWFuZCB3YXMgZm91bmRcbiAgICovXG4gIDtcblxuICBfcHJvdG83LnBhcnNlQ21kID0gZnVuY3Rpb24gcGFyc2VDbWQoYSwgYikge1xuICAgIHZhciBjbWRIaXN0b3J5ID0gdGhpcy5jbWRIaXN0b3J5O1xuICAgIHZhciBjb25kMSA9IChhID09PSAweDE0IHx8IGEgPT09IDB4MWMgfHwgYSA9PT0gMHgxNSB8fCBhID09PSAweDFkKSAmJiBiID49IDB4MjAgJiYgYiA8PSAweDJmO1xuICAgIHZhciBjb25kMiA9IChhID09PSAweDE3IHx8IGEgPT09IDB4MWYpICYmIGIgPj0gMHgyMSAmJiBiIDw9IDB4MjM7XG5cbiAgICBpZiAoIShjb25kMSB8fCBjb25kMikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoaGFzQ21kUmVwZWF0ZWQoYSwgYiwgY21kSGlzdG9yeSkpIHtcbiAgICAgIHNldExhc3RDbWQobnVsbCwgbnVsbCwgY21kSGlzdG9yeSk7XG4gICAgICB0aGlzLmxvZ2dlci5sb2coVmVyYm9zZUxldmVsLkRFQlVHLCAnUmVwZWF0ZWQgY29tbWFuZCAoJyArIG51bUFycmF5VG9IZXhBcnJheShbYSwgYl0pICsgJykgaXMgZHJvcHBlZCcpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgdmFyIGNoTnIgPSBhID09PSAweDE0IHx8IGEgPT09IDB4MTUgfHwgYSA9PT0gMHgxNyA/IDEgOiAyO1xuICAgIHZhciBjaGFubmVsID0gdGhpcy5jaGFubmVsc1tjaE5yXTtcblxuICAgIGlmIChhID09PSAweDE0IHx8IGEgPT09IDB4MTUgfHwgYSA9PT0gMHgxYyB8fCBhID09PSAweDFkKSB7XG4gICAgICBpZiAoYiA9PT0gMHgyMCkge1xuICAgICAgICBjaGFubmVsLmNjUkNMKCk7XG4gICAgICB9IGVsc2UgaWYgKGIgPT09IDB4MjEpIHtcbiAgICAgICAgY2hhbm5lbC5jY0JTKCk7XG4gICAgICB9IGVsc2UgaWYgKGIgPT09IDB4MjIpIHtcbiAgICAgICAgY2hhbm5lbC5jY0FPRigpO1xuICAgICAgfSBlbHNlIGlmIChiID09PSAweDIzKSB7XG4gICAgICAgIGNoYW5uZWwuY2NBT04oKTtcbiAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyNCkge1xuICAgICAgICBjaGFubmVsLmNjREVSKCk7XG4gICAgICB9IGVsc2UgaWYgKGIgPT09IDB4MjUpIHtcbiAgICAgICAgY2hhbm5lbC5jY1JVKDIpO1xuICAgICAgfSBlbHNlIGlmIChiID09PSAweDI2KSB7XG4gICAgICAgIGNoYW5uZWwuY2NSVSgzKTtcbiAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyNykge1xuICAgICAgICBjaGFubmVsLmNjUlUoNCk7XG4gICAgICB9IGVsc2UgaWYgKGIgPT09IDB4MjgpIHtcbiAgICAgICAgY2hhbm5lbC5jY0ZPTigpO1xuICAgICAgfSBlbHNlIGlmIChiID09PSAweDI5KSB7XG4gICAgICAgIGNoYW5uZWwuY2NSREMoKTtcbiAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyYSkge1xuICAgICAgICBjaGFubmVsLmNjVFIoKTtcbiAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyYikge1xuICAgICAgICBjaGFubmVsLmNjUlREKCk7XG4gICAgICB9IGVsc2UgaWYgKGIgPT09IDB4MmMpIHtcbiAgICAgICAgY2hhbm5lbC5jY0VETSgpO1xuICAgICAgfSBlbHNlIGlmIChiID09PSAweDJkKSB7XG4gICAgICAgIGNoYW5uZWwuY2NDUigpO1xuICAgICAgfSBlbHNlIGlmIChiID09PSAweDJlKSB7XG4gICAgICAgIGNoYW5uZWwuY2NFTk0oKTtcbiAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyZikge1xuICAgICAgICBjaGFubmVsLmNjRU9DKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGEgPT0gMHgxNyB8fCBhID09IDB4MUZcbiAgICAgIGNoYW5uZWwuY2NUTyhiIC0gMHgyMCk7XG4gICAgfVxuXG4gICAgc2V0TGFzdENtZChhLCBiLCBjbWRIaXN0b3J5KTtcbiAgICB0aGlzLmN1cnJlbnRDaGFubmVsID0gY2hOcjtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogUGFyc2UgbWlkcm93IHN0eWxpbmcgY29tbWFuZFxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICovXG4gIDtcblxuICBfcHJvdG83LnBhcnNlTWlkcm93ID0gZnVuY3Rpb24gcGFyc2VNaWRyb3coYSwgYikge1xuICAgIHZhciBjaE5yID0gMDtcblxuICAgIGlmICgoYSA9PT0gMHgxMSB8fCBhID09PSAweDE5KSAmJiBiID49IDB4MjAgJiYgYiA8PSAweDJmKSB7XG4gICAgICBpZiAoYSA9PT0gMHgxMSkge1xuICAgICAgICBjaE5yID0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNoTnIgPSAyO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2hOciAhPT0gdGhpcy5jdXJyZW50Q2hhbm5lbCkge1xuICAgICAgICB0aGlzLmxvZ2dlci5sb2coVmVyYm9zZUxldmVsLkVSUk9SLCAnTWlzbWF0Y2ggY2hhbm5lbCBpbiBtaWRyb3cgcGFyc2luZycpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHZhciBjaGFubmVsID0gdGhpcy5jaGFubmVsc1tjaE5yXTtcblxuICAgICAgaWYgKCFjaGFubmVsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgY2hhbm5lbC5jY01JRFJPVyhiKTtcbiAgICAgIHRoaXMubG9nZ2VyLmxvZyhWZXJib3NlTGV2ZWwuREVCVUcsICdNSURST1cgKCcgKyBudW1BcnJheVRvSGV4QXJyYXkoW2EsIGJdKSArICcpJyk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLyoqXG4gICAqIFBhcnNlIFByZWFibGUgQWNjZXNzIENvZGVzIChUYWJsZSA1MykuXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBUZWxscyBpZiBQQUMgZm91bmRcbiAgICovXG4gIDtcblxuICBfcHJvdG83LnBhcnNlUEFDID0gZnVuY3Rpb24gcGFyc2VQQUMoYSwgYikge1xuICAgIHZhciByb3c7XG4gICAgdmFyIGNtZEhpc3RvcnkgPSB0aGlzLmNtZEhpc3Rvcnk7XG4gICAgdmFyIGNhc2UxID0gKGEgPj0gMHgxMSAmJiBhIDw9IDB4MTcgfHwgYSA+PSAweDE5ICYmIGEgPD0gMHgxZikgJiYgYiA+PSAweDQwICYmIGIgPD0gMHg3ZjtcbiAgICB2YXIgY2FzZTIgPSAoYSA9PT0gMHgxMCB8fCBhID09PSAweDE4KSAmJiBiID49IDB4NDAgJiYgYiA8PSAweDVmO1xuXG4gICAgaWYgKCEoY2FzZTEgfHwgY2FzZTIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGhhc0NtZFJlcGVhdGVkKGEsIGIsIGNtZEhpc3RvcnkpKSB7XG4gICAgICBzZXRMYXN0Q21kKG51bGwsIG51bGwsIGNtZEhpc3RvcnkpO1xuICAgICAgcmV0dXJuIHRydWU7IC8vIFJlcGVhdGVkIGNvbW1hbmRzIGFyZSBkcm9wcGVkIChvbmNlKVxuICAgIH1cblxuICAgIHZhciBjaE5yID0gYSA8PSAweDE3ID8gMSA6IDI7XG5cbiAgICBpZiAoYiA+PSAweDQwICYmIGIgPD0gMHg1Zikge1xuICAgICAgcm93ID0gY2hOciA9PT0gMSA/IHJvd3NMb3dDaDFbYV0gOiByb3dzTG93Q2gyW2FdO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyAweDYwIDw9IGIgPD0gMHg3RlxuICAgICAgcm93ID0gY2hOciA9PT0gMSA/IHJvd3NIaWdoQ2gxW2FdIDogcm93c0hpZ2hDaDJbYV07XG4gICAgfVxuXG4gICAgdmFyIGNoYW5uZWwgPSB0aGlzLmNoYW5uZWxzW2NoTnJdO1xuXG4gICAgaWYgKCFjaGFubmVsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY2hhbm5lbC5zZXRQQUModGhpcy5pbnRlcnByZXRQQUMocm93LCBiKSk7XG4gICAgc2V0TGFzdENtZChhLCBiLCBjbWRIaXN0b3J5KTtcbiAgICB0aGlzLmN1cnJlbnRDaGFubmVsID0gY2hOcjtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogSW50ZXJwcmV0IHRoZSBzZWNvbmQgYnl0ZSBvZiB0aGUgcGFjLCBhbmQgcmV0dXJuIHRoZSBpbmZvcm1hdGlvbi5cbiAgICogQHJldHVybnMge09iamVjdH0gcGFjRGF0YSB3aXRoIHN0eWxlIHBhcmFtZXRlcnMuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvNy5pbnRlcnByZXRQQUMgPSBmdW5jdGlvbiBpbnRlcnByZXRQQUMocm93LCBfYnl0ZTMpIHtcbiAgICB2YXIgcGFjSW5kZXg7XG4gICAgdmFyIHBhY0RhdGEgPSB7XG4gICAgICBjb2xvcjogbnVsbCxcbiAgICAgIGl0YWxpY3M6IGZhbHNlLFxuICAgICAgaW5kZW50OiBudWxsLFxuICAgICAgdW5kZXJsaW5lOiBmYWxzZSxcbiAgICAgIHJvdzogcm93XG4gICAgfTtcblxuICAgIGlmIChfYnl0ZTMgPiAweDVmKSB7XG4gICAgICBwYWNJbmRleCA9IF9ieXRlMyAtIDB4NjA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhY0luZGV4ID0gX2J5dGUzIC0gMHg0MDtcbiAgICB9XG5cbiAgICBwYWNEYXRhLnVuZGVybGluZSA9IChwYWNJbmRleCAmIDEpID09PSAxO1xuXG4gICAgaWYgKHBhY0luZGV4IDw9IDB4ZCkge1xuICAgICAgcGFjRGF0YS5jb2xvciA9IFsnd2hpdGUnLCAnZ3JlZW4nLCAnYmx1ZScsICdjeWFuJywgJ3JlZCcsICd5ZWxsb3cnLCAnbWFnZW50YScsICd3aGl0ZSddW01hdGguZmxvb3IocGFjSW5kZXggLyAyKV07XG4gICAgfSBlbHNlIGlmIChwYWNJbmRleCA8PSAweGYpIHtcbiAgICAgIHBhY0RhdGEuaXRhbGljcyA9IHRydWU7XG4gICAgICBwYWNEYXRhLmNvbG9yID0gJ3doaXRlJztcbiAgICB9IGVsc2Uge1xuICAgICAgcGFjRGF0YS5pbmRlbnQgPSBNYXRoLmZsb29yKChwYWNJbmRleCAtIDB4MTApIC8gMikgKiA0O1xuICAgIH1cblxuICAgIHJldHVybiBwYWNEYXRhOyAvLyBOb3RlIHRoYXQgcm93IGhhcyB6ZXJvIG9mZnNldC4gVGhlIHNwZWMgdXNlcyAxLlxuICB9XG4gIC8qKlxuICAgKiBQYXJzZSBjaGFyYWN0ZXJzLlxuICAgKiBAcmV0dXJucyBBbiBhcnJheSB3aXRoIDEgdG8gMiBjb2RlcyBjb3JyZXNwb25kaW5nIHRvIGNoYXJzLCBpZiBmb3VuZC4gbnVsbCBvdGhlcndpc2UuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvNy5wYXJzZUNoYXJzID0gZnVuY3Rpb24gcGFyc2VDaGFycyhhLCBiKSB7XG4gICAgdmFyIGNoYW5uZWxOcjtcbiAgICB2YXIgY2hhckNvZGVzID0gbnVsbDtcbiAgICB2YXIgY2hhckNvZGUxID0gbnVsbDtcblxuICAgIGlmIChhID49IDB4MTkpIHtcbiAgICAgIGNoYW5uZWxOciA9IDI7XG4gICAgICBjaGFyQ29kZTEgPSBhIC0gODtcbiAgICB9IGVsc2Uge1xuICAgICAgY2hhbm5lbE5yID0gMTtcbiAgICAgIGNoYXJDb2RlMSA9IGE7XG4gICAgfVxuXG4gICAgaWYgKGNoYXJDb2RlMSA+PSAweDExICYmIGNoYXJDb2RlMSA8PSAweDEzKSB7XG4gICAgICAvLyBTcGVjaWFsIGNoYXJhY3RlclxuICAgICAgdmFyIG9uZUNvZGU7XG5cbiAgICAgIGlmIChjaGFyQ29kZTEgPT09IDB4MTEpIHtcbiAgICAgICAgb25lQ29kZSA9IGIgKyAweDUwO1xuICAgICAgfSBlbHNlIGlmIChjaGFyQ29kZTEgPT09IDB4MTIpIHtcbiAgICAgICAgb25lQ29kZSA9IGIgKyAweDcwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb25lQ29kZSA9IGIgKyAweDkwO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmxvZ2dlci5sb2coVmVyYm9zZUxldmVsLklORk8sIFwiU3BlY2lhbCBjaGFyICdcIiArIGdldENoYXJGb3JCeXRlKG9uZUNvZGUpICsgXCInIGluIGNoYW5uZWwgXCIgKyBjaGFubmVsTnIpO1xuICAgICAgY2hhckNvZGVzID0gW29uZUNvZGVdO1xuICAgIH0gZWxzZSBpZiAoYSA+PSAweDIwICYmIGEgPD0gMHg3Zikge1xuICAgICAgY2hhckNvZGVzID0gYiA9PT0gMCA/IFthXSA6IFthLCBiXTtcbiAgICB9XG5cbiAgICBpZiAoY2hhckNvZGVzKSB7XG4gICAgICB2YXIgaGV4Q29kZXMgPSBudW1BcnJheVRvSGV4QXJyYXkoY2hhckNvZGVzKTtcbiAgICAgIHRoaXMubG9nZ2VyLmxvZyhWZXJib3NlTGV2ZWwuREVCVUcsICdDaGFyIGNvZGVzID0gICcgKyBoZXhDb2Rlcy5qb2luKCcsJykpO1xuICAgICAgc2V0TGFzdENtZChhLCBiLCB0aGlzLmNtZEhpc3RvcnkpO1xuICAgIH1cblxuICAgIHJldHVybiBjaGFyQ29kZXM7XG4gIH1cbiAgLyoqXG4gICAqIFBhcnNlIGV4dGVuZGVkIGJhY2tncm91bmQgYXR0cmlidXRlcyBhcyB3ZWxsIGFzIG5ldyBmb3JlZ3JvdW5kIGNvbG9yIGJsYWNrLlxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gVGVsbHMgaWYgYmFja2dyb3VuZCBhdHRyaWJ1dGVzIGFyZSBmb3VuZFxuICAgKi9cbiAgO1xuXG4gIF9wcm90bzcucGFyc2VCYWNrZ3JvdW5kQXR0cmlidXRlcyA9IGZ1bmN0aW9uIHBhcnNlQmFja2dyb3VuZEF0dHJpYnV0ZXMoYSwgYikge1xuICAgIHZhciBjYXNlMSA9IChhID09PSAweDEwIHx8IGEgPT09IDB4MTgpICYmIGIgPj0gMHgyMCAmJiBiIDw9IDB4MmY7XG4gICAgdmFyIGNhc2UyID0gKGEgPT09IDB4MTcgfHwgYSA9PT0gMHgxZikgJiYgYiA+PSAweDJkICYmIGIgPD0gMHgyZjtcblxuICAgIGlmICghKGNhc2UxIHx8IGNhc2UyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBpbmRleDtcbiAgICB2YXIgYmtnRGF0YSA9IHt9O1xuXG4gICAgaWYgKGEgPT09IDB4MTAgfHwgYSA9PT0gMHgxOCkge1xuICAgICAgaW5kZXggPSBNYXRoLmZsb29yKChiIC0gMHgyMCkgLyAyKTtcbiAgICAgIGJrZ0RhdGEuYmFja2dyb3VuZCA9IGJhY2tncm91bmRDb2xvcnNbaW5kZXhdO1xuXG4gICAgICBpZiAoYiAlIDIgPT09IDEpIHtcbiAgICAgICAgYmtnRGF0YS5iYWNrZ3JvdW5kID0gYmtnRGF0YS5iYWNrZ3JvdW5kICsgJ19zZW1pJztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGIgPT09IDB4MmQpIHtcbiAgICAgIGJrZ0RhdGEuYmFja2dyb3VuZCA9ICd0cmFuc3BhcmVudCc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJrZ0RhdGEuZm9yZWdyb3VuZCA9ICdibGFjayc7XG5cbiAgICAgIGlmIChiID09PSAweDJmKSB7XG4gICAgICAgIGJrZ0RhdGEudW5kZXJsaW5lID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgY2hOciA9IGEgPD0gMHgxNyA/IDEgOiAyO1xuICAgIHZhciBjaGFubmVsID0gdGhpcy5jaGFubmVsc1tjaE5yXTtcbiAgICBjaGFubmVsLnNldEJrZ0RhdGEoYmtnRGF0YSk7XG4gICAgc2V0TGFzdENtZChhLCBiLCB0aGlzLmNtZEhpc3RvcnkpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXNldCBzdGF0ZSBvZiBwYXJzZXIgYW5kIGl0cyBjaGFubmVscy5cbiAgICovXG4gIDtcblxuICBfcHJvdG83LnJlc2V0ID0gZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBPYmplY3Qua2V5cyh0aGlzLmNoYW5uZWxzKS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNoYW5uZWwgPSB0aGlzLmNoYW5uZWxzW2ldO1xuXG4gICAgICBpZiAoY2hhbm5lbCkge1xuICAgICAgICBjaGFubmVsLnJlc2V0KCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5jbWRIaXN0b3J5ID0gY3JlYXRlQ21kSGlzdG9yeSgpO1xuICB9XG4gIC8qKlxuICAgKiBUcmlnZ2VyIHRoZSBnZW5lcmF0aW9uIG9mIGEgY3VlLCBhbmQgdGhlIHN0YXJ0IG9mIGEgbmV3IG9uZSBpZiBkaXNwbGF5U2NyZWVucyBhcmUgbm90IGVtcHR5LlxuICAgKi9cbiAgO1xuXG4gIF9wcm90bzcuY3VlU3BsaXRBdFRpbWUgPSBmdW5jdGlvbiBjdWVTcGxpdEF0VGltZSh0KSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNoYW5uZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2hhbm5lbCA9IHRoaXMuY2hhbm5lbHNbaV07XG5cbiAgICAgIGlmIChjaGFubmVsKSB7XG4gICAgICAgIGNoYW5uZWwuY3VlU3BsaXRBdFRpbWUodCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBDZWE2MDhQYXJzZXI7XG59KCk7XG5cbmZ1bmN0aW9uIHNldExhc3RDbWQoYSwgYiwgY21kSGlzdG9yeSkge1xuICBjbWRIaXN0b3J5LmEgPSBhO1xuICBjbWRIaXN0b3J5LmIgPSBiO1xufVxuXG5mdW5jdGlvbiBoYXNDbWRSZXBlYXRlZChhLCBiLCBjbWRIaXN0b3J5KSB7XG4gIHJldHVybiBjbWRIaXN0b3J5LmEgPT09IGEgJiYgY21kSGlzdG9yeS5iID09PSBiO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVDbWRIaXN0b3J5KCkge1xuICByZXR1cm4ge1xuICAgIGE6IG51bGwsXG4gICAgYjogbnVsbFxuICB9O1xufVxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKENlYTYwOFBhcnNlcik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3V0aWxzL2NvZGVjcy50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvdXRpbHMvY29kZWNzLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBpc0NvZGVjVHlwZSwgaXNDb2RlY1N1cHBvcnRlZEluTXA0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImlzQ29kZWNUeXBlXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gaXNDb2RlY1R5cGU7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImlzQ29kZWNTdXBwb3J0ZWRJbk1wNFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGlzQ29kZWNTdXBwb3J0ZWRJbk1wNDsgfSk7XG4vLyBmcm9tIGh0dHA6Ly9tcDRyYS5vcmcvY29kZWNzLmh0bWxcbnZhciBzYW1wbGVFbnRyeUNvZGVzSVNPID0ge1xuICBhdWRpbzoge1xuICAgIGEzZHM6IHRydWUsXG4gICAgJ2FjLTMnOiB0cnVlLFxuICAgICdhYy00JzogdHJ1ZSxcbiAgICBhbGFjOiB0cnVlLFxuICAgIGFsYXc6IHRydWUsXG4gICAgZHJhMTogdHJ1ZSxcbiAgICAnZHRzKyc6IHRydWUsXG4gICAgJ2R0cy0nOiB0cnVlLFxuICAgIGR0c2M6IHRydWUsXG4gICAgZHRzZTogdHJ1ZSxcbiAgICBkdHNoOiB0cnVlLFxuICAgICdlYy0zJzogdHJ1ZSxcbiAgICBlbmNhOiB0cnVlLFxuICAgIGc3MTk6IHRydWUsXG4gICAgZzcyNjogdHJ1ZSxcbiAgICBtNGFlOiB0cnVlLFxuICAgIG1oYTE6IHRydWUsXG4gICAgbWhhMjogdHJ1ZSxcbiAgICBtaG0xOiB0cnVlLFxuICAgIG1obTI6IHRydWUsXG4gICAgbWxwYTogdHJ1ZSxcbiAgICBtcDRhOiB0cnVlLFxuICAgICdyYXcgJzogdHJ1ZSxcbiAgICBPcHVzOiB0cnVlLFxuICAgIHNhbXI6IHRydWUsXG4gICAgc2F3YjogdHJ1ZSxcbiAgICBzYXdwOiB0cnVlLFxuICAgIHNldmM6IHRydWUsXG4gICAgc3FjcDogdHJ1ZSxcbiAgICBzc212OiB0cnVlLFxuICAgIHR3b3M6IHRydWUsXG4gICAgdWxhdzogdHJ1ZVxuICB9LFxuICB2aWRlbzoge1xuICAgIGF2YzE6IHRydWUsXG4gICAgYXZjMjogdHJ1ZSxcbiAgICBhdmMzOiB0cnVlLFxuICAgIGF2YzQ6IHRydWUsXG4gICAgYXZjcDogdHJ1ZSxcbiAgICBhdjAxOiB0cnVlLFxuICAgIGRyYWM6IHRydWUsXG4gICAgZHZhdjogdHJ1ZSxcbiAgICBkdmhlOiB0cnVlLFxuICAgIGVuY3Y6IHRydWUsXG4gICAgaGV2MTogdHJ1ZSxcbiAgICBodmMxOiB0cnVlLFxuICAgIG1qcDI6IHRydWUsXG4gICAgbXA0djogdHJ1ZSxcbiAgICBtdmMxOiB0cnVlLFxuICAgIG12YzI6IHRydWUsXG4gICAgbXZjMzogdHJ1ZSxcbiAgICBtdmM0OiB0cnVlLFxuICAgIHJlc3Y6IHRydWUsXG4gICAgcnY2MDogdHJ1ZSxcbiAgICBzMjYzOiB0cnVlLFxuICAgIHN2YzE6IHRydWUsXG4gICAgc3ZjMjogdHJ1ZSxcbiAgICAndmMtMSc6IHRydWUsXG4gICAgdnAwODogdHJ1ZSxcbiAgICB2cDA5OiB0cnVlXG4gIH0sXG4gIHRleHQ6IHtcbiAgICBzdHBwOiB0cnVlLFxuICAgIHd2dHQ6IHRydWVcbiAgfVxufTtcbmZ1bmN0aW9uIGlzQ29kZWNUeXBlKGNvZGVjLCB0eXBlKSB7XG4gIHZhciB0eXBlQ29kZXMgPSBzYW1wbGVFbnRyeUNvZGVzSVNPW3R5cGVdO1xuICByZXR1cm4gISF0eXBlQ29kZXMgJiYgdHlwZUNvZGVzW2NvZGVjLnNsaWNlKDAsIDQpXSA9PT0gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGlzQ29kZWNTdXBwb3J0ZWRJbk1wNChjb2RlYywgdHlwZSkge1xuICByZXR1cm4gTWVkaWFTb3VyY2UuaXNUeXBlU3VwcG9ydGVkKCh0eXBlIHx8ICd2aWRlbycpICsgXCIvbXA0O2NvZGVjcz1cXFwiXCIgKyBjb2RlYyArIFwiXFxcIlwiKTtcbn1cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvdXRpbHMvY3Vlcy50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3V0aWxzL2N1ZXMudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF92dHRwYXJzZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdnR0cGFyc2VyICovIFwiLi9zcmMvdXRpbHMvdnR0cGFyc2VyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF93ZWJ2dHRfcGFyc2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3dlYnZ0dC1wYXJzZXIgKi8gXCIuL3NyYy91dGlscy93ZWJ2dHQtcGFyc2VyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF90ZXh0dHJhY2tfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdGV4dHRyYWNrLXV0aWxzICovIFwiLi9zcmMvdXRpbHMvdGV4dHRyYWNrLXV0aWxzLnRzXCIpO1xuXG5cblxudmFyIFdISVRFU1BBQ0VfQ0hBUiA9IC9cXHMvO1xudmFyIEN1ZXMgPSB7XG4gIG5ld0N1ZTogZnVuY3Rpb24gbmV3Q3VlKHRyYWNrLCBzdGFydFRpbWUsIGVuZFRpbWUsIGNhcHRpb25TY3JlZW4pIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgdmFyIHJvdzsgLy8gdGhlIHR5cGUgZGF0YSBzdGF0ZXMgdGhpcyBpcyBWVFRDdWUsIGJ1dCBpdCBjYW4gcG90ZW50aWFsbHkgYmUgYSBUZXh0VHJhY2tDdWUgb24gb2xkIGJyb3dzZXJzXG5cbiAgICB2YXIgY3VlO1xuICAgIHZhciBpbmRlbnRpbmc7XG4gICAgdmFyIGluZGVudDtcbiAgICB2YXIgdGV4dDtcbiAgICB2YXIgQ3VlID0gc2VsZi5WVFRDdWUgfHwgc2VsZi5UZXh0VHJhY2tDdWU7XG5cbiAgICBmb3IgKHZhciByID0gMDsgciA8IGNhcHRpb25TY3JlZW4ucm93cy5sZW5ndGg7IHIrKykge1xuICAgICAgcm93ID0gY2FwdGlvblNjcmVlbi5yb3dzW3JdO1xuICAgICAgaW5kZW50aW5nID0gdHJ1ZTtcbiAgICAgIGluZGVudCA9IDA7XG4gICAgICB0ZXh0ID0gJyc7XG5cbiAgICAgIGlmICghcm93LmlzRW1wdHkoKSkge1xuICAgICAgICBmb3IgKHZhciBjID0gMDsgYyA8IHJvdy5jaGFycy5sZW5ndGg7IGMrKykge1xuICAgICAgICAgIGlmIChXSElURVNQQUNFX0NIQVIudGVzdChyb3cuY2hhcnNbY10udWNoYXIpICYmIGluZGVudGluZykge1xuICAgICAgICAgICAgaW5kZW50Kys7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRleHQgKz0gcm93LmNoYXJzW2NdLnVjaGFyO1xuICAgICAgICAgICAgaW5kZW50aW5nID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIFRvIGJlIHVzZWQgZm9yIGNsZWFuaW5nLXVwIG9ycGhhbmVkIHJvbGwtdXAgY2FwdGlvbnNcblxuXG4gICAgICAgIHJvdy5jdWVTdGFydFRpbWUgPSBzdGFydFRpbWU7IC8vIEdpdmUgYSBzbGlnaHQgYnVtcCB0byB0aGUgZW5kVGltZSBpZiBpdCdzIGVxdWFsIHRvIHN0YXJ0VGltZSB0byBhdm9pZCBhIFN5bnRheEVycm9yIGluIElFXG5cbiAgICAgICAgaWYgKHN0YXJ0VGltZSA9PT0gZW5kVGltZSkge1xuICAgICAgICAgIGVuZFRpbWUgKz0gMC4wMDAxO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGluZGVudCA+PSAxNikge1xuICAgICAgICAgIGluZGVudC0tO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGluZGVudCsrO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGN1ZVRleHQgPSBPYmplY3QoX3Z0dHBhcnNlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiZml4TGluZUJyZWFrc1wiXSkodGV4dC50cmltKCkpO1xuICAgICAgICB2YXIgaWQgPSBPYmplY3QoX3dlYnZ0dF9wYXJzZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImdlbmVyYXRlQ3VlSWRcIl0pKHN0YXJ0VGltZSwgZW5kVGltZSwgY3VlVGV4dCk7IC8vIElmIHRoaXMgY3VlIGFscmVhZHkgZXhpc3RzIGluIHRoZSB0cmFjayBkbyBub3QgcHVzaCBpdFxuXG4gICAgICAgIGlmICghdHJhY2sgfHwgIXRyYWNrLmN1ZXMgfHwgIXRyYWNrLmN1ZXMuZ2V0Q3VlQnlJZChpZCkpIHtcbiAgICAgICAgICBjdWUgPSBuZXcgQ3VlKHN0YXJ0VGltZSwgZW5kVGltZSwgY3VlVGV4dCk7XG4gICAgICAgICAgY3VlLmlkID0gaWQ7XG4gICAgICAgICAgY3VlLmxpbmUgPSByICsgMTtcbiAgICAgICAgICBjdWUuYWxpZ24gPSAnbGVmdCc7IC8vIENsYW1wIHRoZSBwb3NpdGlvbiBiZXR3ZWVuIDEwIGFuZCA4MCBwZXJjZW50IChDRUEtNjA4IFBBQyBpbmRlbnQgY29kZSlcbiAgICAgICAgICAvLyBodHRwczovL2R2Y3MudzMub3JnL2hnL3RleHQtdHJhY2tzL3Jhdy1maWxlL2RlZmF1bHQvNjA4dG9WVFQvNjA4dG9WVFQuaHRtbCNwb3NpdGlvbmluZy1pbi1jZWEtNjA4XG4gICAgICAgICAgLy8gRmlyZWZveCB0aHJvd3MgYW4gZXhjZXB0aW9uIGFuZCBjYXB0aW9ucyBicmVhayB3aXRoIG91dCBvZiBib3VuZHMgMC0xMDAgdmFsdWVzXG5cbiAgICAgICAgICBjdWUucG9zaXRpb24gPSAxMCArIE1hdGgubWluKDgwLCBNYXRoLmZsb29yKGluZGVudCAqIDggLyAzMikgKiAxMCk7XG4gICAgICAgICAgcmVzdWx0LnB1c2goY3VlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0cmFjayAmJiByZXN1bHQubGVuZ3RoKSB7XG4gICAgICAvLyBTb3J0IGJvdHRvbSBjdWVzIGluIHJldmVyc2Ugb3JkZXIgc28gdGhhdCB0aGV5IHJlbmRlciBpbiBsaW5lIG9yZGVyIHdoZW4gb3ZlcmxhcHBpbmcgaW4gQ2hyb21lXG4gICAgICByZXN1bHQuc29ydChmdW5jdGlvbiAoY3VlQSwgY3VlQikge1xuICAgICAgICBpZiAoY3VlQS5saW5lID09PSAnYXV0bycgfHwgY3VlQi5saW5lID09PSAnYXV0bycpIHtcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjdWVBLmxpbmUgPiA4ICYmIGN1ZUIubGluZSA+IDgpIHtcbiAgICAgICAgICByZXR1cm4gY3VlQi5saW5lIC0gY3VlQS5saW5lO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGN1ZUEubGluZSAtIGN1ZUIubGluZTtcbiAgICAgIH0pO1xuICAgICAgcmVzdWx0LmZvckVhY2goZnVuY3Rpb24gKGN1ZSkge1xuICAgICAgICByZXR1cm4gT2JqZWN0KF90ZXh0dHJhY2tfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImFkZEN1ZVRvVHJhY2tcIl0pKHRyYWNrLCBjdWUpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoQ3Vlcyk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3V0aWxzL2Rpc2NvbnRpbnVpdGllcy50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvdXRpbHMvZGlzY29udGludWl0aWVzLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBmaW5kRmlyc3RGcmFnV2l0aENDLCBzaG91bGRBbGlnbk9uRGlzY29udGludWl0aWVzLCBmaW5kRGlzY29udGludW91c1JlZmVyZW5jZUZyYWcsIGFkanVzdFNsaWRpbmdTdGFydCwgYWxpZ25TdHJlYW0sIGFsaWduUERULCBhbGlnbkZyYWdtZW50QnlQRFREZWx0YSwgYWxpZ25NZWRpYVBsYXlsaXN0QnlQRFQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZmluZEZpcnN0RnJhZ1dpdGhDQ1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGZpbmRGaXJzdEZyYWdXaXRoQ0M7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcInNob3VsZEFsaWduT25EaXNjb250aW51aXRpZXNcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBzaG91bGRBbGlnbk9uRGlzY29udGludWl0aWVzOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJmaW5kRGlzY29udGludW91c1JlZmVyZW5jZUZyYWdcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBmaW5kRGlzY29udGludW91c1JlZmVyZW5jZUZyYWc7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImFkanVzdFNsaWRpbmdTdGFydFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGFkanVzdFNsaWRpbmdTdGFydDsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiYWxpZ25TdHJlYW1cIiwgZnVuY3Rpb24oKSB7IHJldHVybiBhbGlnblN0cmVhbTsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiYWxpZ25QRFRcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBhbGlnblBEVDsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiYWxpZ25GcmFnbWVudEJ5UERURGVsdGFcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBhbGlnbkZyYWdtZW50QnlQRFREZWx0YTsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiYWxpZ25NZWRpYVBsYXlsaXN0QnlQRFRcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBhbGlnbk1lZGlhUGxheWxpc3RCeVBEVDsgfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2hvbWVfcnVubmVyX3dvcmtfaGxzX2pzX2hsc19qc19zcmNfcG9seWZpbGxzX251bWJlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zcmMvcG9seWZpbGxzL251bWJlciAqLyBcIi4vc3JjL3BvbHlmaWxscy9udW1iZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9sb2dnZXIgKi8gXCIuL3NyYy91dGlscy9sb2dnZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2NvbnRyb2xsZXJfbGV2ZWxfaGVscGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9jb250cm9sbGVyL2xldmVsLWhlbHBlciAqLyBcIi4vc3JjL2NvbnRyb2xsZXIvbGV2ZWwtaGVscGVyLnRzXCIpO1xuXG5cblxuXG5mdW5jdGlvbiBmaW5kRmlyc3RGcmFnV2l0aENDKGZyYWdtZW50cywgY2MpIHtcbiAgdmFyIGZpcnN0RnJhZyA9IG51bGw7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGZyYWdtZW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciBjdXJyZW50RnJhZyA9IGZyYWdtZW50c1tpXTtcblxuICAgIGlmIChjdXJyZW50RnJhZyAmJiBjdXJyZW50RnJhZy5jYyA9PT0gY2MpIHtcbiAgICAgIGZpcnN0RnJhZyA9IGN1cnJlbnRGcmFnO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZpcnN0RnJhZztcbn1cbmZ1bmN0aW9uIHNob3VsZEFsaWduT25EaXNjb250aW51aXRpZXMobGFzdEZyYWcsIGxhc3RMZXZlbCwgZGV0YWlscykge1xuICBpZiAobGFzdExldmVsLmRldGFpbHMpIHtcbiAgICBpZiAoZGV0YWlscy5lbmRDQyA+IGRldGFpbHMuc3RhcnRDQyB8fCBsYXN0RnJhZyAmJiBsYXN0RnJhZy5jYyA8IGRldGFpbHMuc3RhcnRDQykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufSAvLyBGaW5kIHRoZSBmaXJzdCBmcmFnIGluIHRoZSBwcmV2aW91cyBsZXZlbCB3aGljaCBtYXRjaGVzIHRoZSBDQyBvZiB0aGUgZmlyc3QgZnJhZyBvZiB0aGUgbmV3IGxldmVsXG5cbmZ1bmN0aW9uIGZpbmREaXNjb250aW51b3VzUmVmZXJlbmNlRnJhZyhwcmV2RGV0YWlscywgY3VyRGV0YWlscykge1xuICB2YXIgcHJldkZyYWdzID0gcHJldkRldGFpbHMuZnJhZ21lbnRzO1xuICB2YXIgY3VyRnJhZ3MgPSBjdXJEZXRhaWxzLmZyYWdtZW50cztcblxuICBpZiAoIWN1ckZyYWdzLmxlbmd0aCB8fCAhcHJldkZyYWdzLmxlbmd0aCkge1xuICAgIF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImxvZ2dlclwiXS5sb2coJ05vIGZyYWdtZW50cyB0byBhbGlnbicpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBwcmV2U3RhcnRGcmFnID0gZmluZEZpcnN0RnJhZ1dpdGhDQyhwcmV2RnJhZ3MsIGN1ckZyYWdzWzBdLmNjKTtcblxuICBpZiAoIXByZXZTdGFydEZyYWcgfHwgcHJldlN0YXJ0RnJhZyAmJiAhcHJldlN0YXJ0RnJhZy5zdGFydFBUUykge1xuICAgIF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImxvZ2dlclwiXS5sb2coJ05vIGZyYWcgaW4gcHJldmlvdXMgbGV2ZWwgdG8gYWxpZ24gb24nKTtcbiAgICByZXR1cm47XG4gIH1cblxuICByZXR1cm4gcHJldlN0YXJ0RnJhZztcbn1cblxuZnVuY3Rpb24gYWRqdXN0RnJhZ21lbnRTdGFydChmcmFnLCBzbGlkaW5nKSB7XG4gIGlmIChmcmFnKSB7XG4gICAgdmFyIHN0YXJ0ID0gZnJhZy5zdGFydCArIHNsaWRpbmc7XG4gICAgZnJhZy5zdGFydCA9IGZyYWcuc3RhcnRQVFMgPSBzdGFydDtcbiAgICBmcmFnLmVuZFBUUyA9IHN0YXJ0ICsgZnJhZy5kdXJhdGlvbjtcbiAgfVxufVxuXG5mdW5jdGlvbiBhZGp1c3RTbGlkaW5nU3RhcnQoc2xpZGluZywgZGV0YWlscykge1xuICAvLyBVcGRhdGUgc2VnbWVudHNcbiAgdmFyIGZyYWdtZW50cyA9IGRldGFpbHMuZnJhZ21lbnRzO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBmcmFnbWVudHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBhZGp1c3RGcmFnbWVudFN0YXJ0KGZyYWdtZW50c1tpXSwgc2xpZGluZyk7XG4gIH0gLy8gVXBkYXRlIExMLUhMUyBwYXJ0cyBhdCB0aGUgZW5kIG9mIHRoZSBwbGF5bGlzdFxuXG5cbiAgaWYgKGRldGFpbHMuZnJhZ21lbnRIaW50KSB7XG4gICAgYWRqdXN0RnJhZ21lbnRTdGFydChkZXRhaWxzLmZyYWdtZW50SGludCwgc2xpZGluZyk7XG4gIH1cblxuICBkZXRhaWxzLmFsaWduZWRTbGlkaW5nID0gdHJ1ZTtcbn1cbi8qKlxuICogVXNpbmcgdGhlIHBhcmFtZXRlcnMgb2YgdGhlIGxhc3QgbGV2ZWwsIHRoaXMgZnVuY3Rpb24gY29tcHV0ZXMgUFRTJyBvZiB0aGUgbmV3IGZyYWdtZW50cyBzbyB0aGF0IHRoZXkgZm9ybSBhXG4gKiBjb250aWd1b3VzIHN0cmVhbSB3aXRoIHRoZSBsYXN0IGZyYWdtZW50cy5cbiAqIFRoZSBQVFMgb2YgYSBmcmFnbWVudCBsZXRzIEhscy5qcyBrbm93IHdoZXJlIGl0IGZpdHMgaW50byBhIHN0cmVhbSAtIGJ5IGtub3dpbmcgZXZlcnkgUFRTLCB3ZSBrbm93IHdoaWNoIGZyYWdtZW50IHRvXG4gKiBkb3dubG9hZCBhdCBhbnkgZ2l2ZW4gdGltZS4gUFRTIGlzIG5vcm1hbGx5IGNvbXB1dGVkIHdoZW4gdGhlIGZyYWdtZW50IGlzIGRlbXV4ZWQsIHNvIHRha2luZyB0aGlzIHN0ZXAgc2F2ZXMgdXMgdGltZVxuICogYW5kIGFuIGV4dHJhIGRvd25sb2FkLlxuICogQHBhcmFtIGxhc3RGcmFnXG4gKiBAcGFyYW0gbGFzdExldmVsXG4gKiBAcGFyYW0gZGV0YWlsc1xuICovXG5cbmZ1bmN0aW9uIGFsaWduU3RyZWFtKGxhc3RGcmFnLCBsYXN0TGV2ZWwsIGRldGFpbHMpIHtcbiAgaWYgKCFsYXN0TGV2ZWwpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBhbGlnbkRpc2NvbnRpbnVpdGllcyhsYXN0RnJhZywgZGV0YWlscywgbGFzdExldmVsKTtcblxuICBpZiAoIWRldGFpbHMuYWxpZ25lZFNsaWRpbmcgJiYgbGFzdExldmVsLmRldGFpbHMpIHtcbiAgICAvLyBJZiB0aGUgUFRTIHdhc24ndCBmaWd1cmVkIG91dCB2aWEgZGlzY29udGludWl0eSBzZXF1ZW5jZSB0aGF0IG1lYW5zIHRoZXJlIHdhcyBubyBDQyBpbmNyZWFzZSB3aXRoaW4gdGhlIGxldmVsLlxuICAgIC8vIEFsaWduaW5nIHZpYSBQcm9ncmFtIERhdGUgVGltZSBzaG91bGQgdGhlcmVmb3JlIGJlIHJlbGlhYmxlLCBzaW5jZSBQRFQgc2hvdWxkIGJlIHRoZSBzYW1lIHdpdGhpbiB0aGUgc2FtZVxuICAgIC8vIGRpc2NvbnRpbnVpdHkgc2VxdWVuY2UuXG4gICAgYWxpZ25QRFQoZGV0YWlscywgbGFzdExldmVsLmRldGFpbHMpO1xuICB9XG5cbiAgaWYgKCFkZXRhaWxzLmFsaWduZWRTbGlkaW5nICYmIGxhc3RMZXZlbC5kZXRhaWxzICYmICFkZXRhaWxzLnNraXBwZWRTZWdtZW50cykge1xuICAgIC8vIFRyeSB0byBhbGlnbiBvbiBzbiBzbyB0aGF0IHdlIHBpY2sgYSBiZXR0ZXIgc3RhcnQgZnJhZ21lbnQuXG4gICAgLy8gRG8gbm90IHBlcmZvcm0gdGhpcyBvbiBwbGF5bGlzdHMgd2l0aCBkZWx0YSB1cGRhdGVzIGFzIHRoaXMgaXMgb25seSB0byBhbGlnbiBsZXZlbHMgb24gc3dpdGNoXG4gICAgLy8gYW5kIGFkanVzdFNsaWRpbmcgb25seSBhZGp1c3RzIGZyYWdtZW50cyBhZnRlciBza2lwcGVkU2VnbWVudHMuXG4gICAgT2JqZWN0KF9jb250cm9sbGVyX2xldmVsX2hlbHBlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiYWRqdXN0U2xpZGluZ1wiXSkobGFzdExldmVsLmRldGFpbHMsIGRldGFpbHMpO1xuICB9XG59XG4vKipcbiAqIENvbXB1dGVzIHRoZSBQVFMgaWYgYSBuZXcgbGV2ZWwncyBmcmFnbWVudHMgdXNpbmcgdGhlIFBUUyBvZiBhIGZyYWdtZW50IGluIHRoZSBsYXN0IGxldmVsIHdoaWNoIHNoYXJlcyB0aGUgc2FtZVxuICogZGlzY29udGludWl0eSBzZXF1ZW5jZS5cbiAqIEBwYXJhbSBsYXN0RnJhZyAtIFRoZSBsYXN0IEZyYWdtZW50IHdoaWNoIHNoYXJlcyB0aGUgc2FtZSBkaXNjb250aW51aXR5IHNlcXVlbmNlXG4gKiBAcGFyYW0gbGFzdExldmVsIC0gVGhlIGRldGFpbHMgb2YgdGhlIGxhc3QgbG9hZGVkIGxldmVsXG4gKiBAcGFyYW0gZGV0YWlscyAtIFRoZSBkZXRhaWxzIG9mIHRoZSBuZXcgbGV2ZWxcbiAqL1xuXG5mdW5jdGlvbiBhbGlnbkRpc2NvbnRpbnVpdGllcyhsYXN0RnJhZywgZGV0YWlscywgbGFzdExldmVsKSB7XG4gIGlmIChzaG91bGRBbGlnbk9uRGlzY29udGludWl0aWVzKGxhc3RGcmFnLCBsYXN0TGV2ZWwsIGRldGFpbHMpKSB7XG4gICAgdmFyIHJlZmVyZW5jZUZyYWcgPSBmaW5kRGlzY29udGludW91c1JlZmVyZW5jZUZyYWcobGFzdExldmVsLmRldGFpbHMsIGRldGFpbHMpO1xuXG4gICAgaWYgKHJlZmVyZW5jZUZyYWcgJiYgT2JqZWN0KF9ob21lX3J1bm5lcl93b3JrX2hsc19qc19obHNfanNfc3JjX3BvbHlmaWxsc19udW1iZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImlzRmluaXRlTnVtYmVyXCJdKShyZWZlcmVuY2VGcmFnLnN0YXJ0KSkge1xuICAgICAgX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wibG9nZ2VyXCJdLmxvZyhcIkFkanVzdGluZyBQVFMgdXNpbmcgbGFzdCBsZXZlbCBkdWUgdG8gQ0MgaW5jcmVhc2Ugd2l0aGluIGN1cnJlbnQgbGV2ZWwgXCIgKyBkZXRhaWxzLnVybCk7XG4gICAgICBhZGp1c3RTbGlkaW5nU3RhcnQocmVmZXJlbmNlRnJhZy5zdGFydCwgZGV0YWlscyk7XG4gICAgfVxuICB9XG59XG4vKipcbiAqIENvbXB1dGVzIHRoZSBQVFMgb2YgYSBuZXcgbGV2ZWwncyBmcmFnbWVudHMgdXNpbmcgdGhlIGRpZmZlcmVuY2UgaW4gUHJvZ3JhbSBEYXRlIFRpbWUgZnJvbSB0aGUgbGFzdCBsZXZlbC5cbiAqIEBwYXJhbSBkZXRhaWxzIC0gVGhlIGRldGFpbHMgb2YgdGhlIG5ldyBsZXZlbFxuICogQHBhcmFtIGxhc3REZXRhaWxzIC0gVGhlIGRldGFpbHMgb2YgdGhlIGxhc3QgbG9hZGVkIGxldmVsXG4gKi9cblxuXG5mdW5jdGlvbiBhbGlnblBEVChkZXRhaWxzLCBsYXN0RGV0YWlscykge1xuICAvLyBUaGlzIGNoZWNrIHByb3RlY3RzIHRoZSB1bnNhZmUgXCIhXCIgdXNhZ2UgYmVsb3cgZm9yIG51bGwgcHJvZ3JhbSBkYXRlIHRpbWUgYWNjZXNzLlxuICBpZiAoIWxhc3REZXRhaWxzLmZyYWdtZW50cy5sZW5ndGggfHwgIWRldGFpbHMuaGFzUHJvZ3JhbURhdGVUaW1lIHx8ICFsYXN0RGV0YWlscy5oYXNQcm9ncmFtRGF0ZVRpbWUpIHtcbiAgICByZXR1cm47XG4gIH0gLy8gaWYgbGFzdCBsZXZlbCBzbGlkaW5nIGlzIDEwMDAgYW5kIGl0cyBmaXJzdCBmcmFnIFBST0dSQU0tREFURS1USU1FIGlzIDIwMTctMDgtMjAgMToxMDowMCBBTVxuICAvLyBhbmQgaWYgbmV3IGRldGFpbHMgZmlyc3QgZnJhZyBQUk9HUkFNIERBVEUtVElNRSBpcyAyMDE3LTA4LTIwIDE6MTA6MDggQU1cbiAgLy8gdGhlbiB3ZSBjYW4gZGVkdWNlIHRoYXQgcGxheWxpc3QgQiBzbGlkaW5nIGlzIDEwMDArOCA9IDEwMDhzXG5cblxuICB2YXIgbGFzdFBEVCA9IGxhc3REZXRhaWxzLmZyYWdtZW50c1swXS5wcm9ncmFtRGF0ZVRpbWU7IC8vIGhhc1Byb2dyYW1EYXRlVGltZSBjaGVjayBhYm92ZSBtYWtlcyB0aGlzIHNhZmUuXG5cbiAgdmFyIG5ld1BEVCA9IGRldGFpbHMuZnJhZ21lbnRzWzBdLnByb2dyYW1EYXRlVGltZTsgLy8gZGF0ZSBkaWZmIGlzIGluIG1zLiBmcmFnLnN0YXJ0IGlzIGluIHNlY29uZHNcblxuICB2YXIgc2xpZGluZyA9IChuZXdQRFQgLSBsYXN0UERUKSAvIDEwMDAgKyBsYXN0RGV0YWlscy5mcmFnbWVudHNbMF0uc3RhcnQ7XG5cbiAgaWYgKHNsaWRpbmcgJiYgT2JqZWN0KF9ob21lX3J1bm5lcl93b3JrX2hsc19qc19obHNfanNfc3JjX3BvbHlmaWxsc19udW1iZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImlzRmluaXRlTnVtYmVyXCJdKShzbGlkaW5nKSkge1xuICAgIF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImxvZ2dlclwiXS5sb2coXCJBZGp1c3RpbmcgUFRTIHVzaW5nIHByb2dyYW1EYXRlVGltZSBkZWx0YSBcIiArIChuZXdQRFQgLSBsYXN0UERUKSArIFwibXMsIHNsaWRpbmc6XCIgKyBzbGlkaW5nLnRvRml4ZWQoMykgKyBcIiBcIiArIGRldGFpbHMudXJsICsgXCIgXCIpO1xuICAgIGFkanVzdFNsaWRpbmdTdGFydChzbGlkaW5nLCBkZXRhaWxzKTtcbiAgfVxufVxuZnVuY3Rpb24gYWxpZ25GcmFnbWVudEJ5UERURGVsdGEoZnJhZywgZGVsdGEpIHtcbiAgdmFyIHByb2dyYW1EYXRlVGltZSA9IGZyYWcucHJvZ3JhbURhdGVUaW1lO1xuICBpZiAoIXByb2dyYW1EYXRlVGltZSkgcmV0dXJuO1xuICB2YXIgc3RhcnQgPSAocHJvZ3JhbURhdGVUaW1lIC0gZGVsdGEpIC8gMTAwMDtcbiAgZnJhZy5zdGFydCA9IGZyYWcuc3RhcnRQVFMgPSBzdGFydDtcbiAgZnJhZy5lbmRQVFMgPSBzdGFydCArIGZyYWcuZHVyYXRpb247XG59XG4vKipcbiAqIEVuc3VyZXMgYXBwcm9wcmlhdGUgdGltZS1hbGlnbm1lbnQgYmV0d2VlbiByZW5kaXRpb25zIGJhc2VkIG9uIFBEVC4gVW5saWtlIGBhbGlnblBEVGAsIHdoaWNoIGFkanVzdHNcbiAqIHRoZSB0aW1lbGluZSBiYXNlZCBvbiB0aGUgZGVsdGEgYmV0d2VlbiBQRFRzIG9mIHRoZSAwdGggZnJhZ21lbnQgb2YgdHdvIHBsYXlsaXN0cy9gTGV2ZWxEZXRhaWxzYCxcbiAqIHRoaXMgZnVuY3Rpb24gYXNzdW1lcyB0aGUgdGltZWxpbmVzIHJlcHJlc2VudGVkIGluIGByZWZEZXRhaWxzYCBhcmUgYWNjdXJhdGUsIGluY2x1ZGluZyB0aGUgUERUcyxcbiAqIGFuZCB1c2VzIHRoZSBcIndhbGxjbG9ja1wiL1BEVCB0aW1lbGluZSBhcyBhIGNyb3NzLXJlZmVyZW5jZSB0byBgZGV0YWlsc2AsIGFkanVzdGluZyB0aGUgcHJlc2VudGF0aW9uXG4gKiB0aW1lcy90aW1lbGluZXMgb2YgYGRldGFpbHNgIGFjY29yZGluZ2x5LlxuICogR2l2ZW4gdGhlIGFzeW5jaHJvbm91cyBuYXR1cmUgb2YgZmV0Y2hlcyBhbmQgaW5pdGlhbCBsb2FkcyBvZiBsaXZlIGBtYWluYCBhbmQgYXVkaW8vc3VidGl0bGUgdHJhY2tzLFxuICogdGhlIHByaW1hcnkgcHVycG9zZSBvZiB0aGlzIGZ1bmN0aW9uIGlzIHRvIGVuc3VyZSB0aGUgXCJsb2NhbCB0aW1lbGluZXNcIiBvZiBhdWRpby9zdWJ0aXRsZSB0cmFja3NcbiAqIGFyZSBhbGlnbmVkIHRvIHRoZSBtYWluL3ZpZGVvIHRpbWVsaW5lLCB1c2luZyBQRFQgYXMgdGhlIGNyb3NzLXJlZmVyZW5jZS9cImFuY2hvclwiIHRoYXQgc2hvdWxkXG4gKiBiZSBjb25zaXN0ZW50IGFjcm9zcyBwbGF5bGlzdHMsIHBlciB0aGUgSExTIHNwZWMuXG4gKiBAcGFyYW0gZGV0YWlscyAtIFRoZSBkZXRhaWxzIG9mIHRoZSByZW5kaXRpb24geW91J2QgbGlrZSB0byB0aW1lLWFsaWduIChlLmcuIGFuIGF1ZGlvIHJlbmRpdGlvbikuXG4gKiBAcGFyYW0gcmVmRGV0YWlscyAtIFRoZSBkZXRhaWxzIG9mIHRoZSByZWZlcmVuY2UgcmVuZGl0aW9uIHdpdGggc3RhcnQgYW5kIFBEVCB0aW1lcyBmb3IgYWxpZ25tZW50LlxuICovXG5cbmZ1bmN0aW9uIGFsaWduTWVkaWFQbGF5bGlzdEJ5UERUKGRldGFpbHMsIHJlZkRldGFpbHMpIHtcbiAgLy8gVGhpcyBjaGVjayBwcm90ZWN0cyB0aGUgdW5zYWZlIFwiIVwiIHVzYWdlIGJlbG93IGZvciBudWxsIHByb2dyYW0gZGF0ZSB0aW1lIGFjY2Vzcy5cbiAgaWYgKCFyZWZEZXRhaWxzLmZyYWdtZW50cy5sZW5ndGggfHwgIWRldGFpbHMuaGFzUHJvZ3JhbURhdGVUaW1lIHx8ICFyZWZEZXRhaWxzLmhhc1Byb2dyYW1EYXRlVGltZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciByZWZQRFQgPSByZWZEZXRhaWxzLmZyYWdtZW50c1swXS5wcm9ncmFtRGF0ZVRpbWU7IC8vIGhhc1Byb2dyYW1EYXRlVGltZSBjaGVjayBhYm92ZSBtYWtlcyB0aGlzIHNhZmUuXG5cbiAgdmFyIHJlZlN0YXJ0ID0gcmVmRGV0YWlscy5mcmFnbWVudHNbMF0uc3RhcnQ7IC8vIFVzZSB0aGUgZGVsdGEgYmV0d2VlbiB0aGUgcmVmZXJlbmNlIGRldGFpbHMnIHByZXNlbnRhdGlvbiB0aW1lbGluZSdzIHN0YXJ0IHRpbWUgYW5kIGl0cyBQRFRcbiAgLy8gdG8gYWxpZ24gdGhlIG90aGVyIHJlbmR0aW9uJ3MgdGltZWxpbmUuXG5cbiAgdmFyIGRlbHRhID0gcmVmUERUIC0gcmVmU3RhcnQgKiAxMDAwOyAvLyBQZXIgc3BlYzogXCJJZiBhbnkgTWVkaWEgUGxheWxpc3QgaW4gYSBNYXN0ZXIgUGxheWxpc3QgY29udGFpbnMgYW4gRVhULVgtUFJPR1JBTS1EQVRFLVRJTUUgdGFnLCB0aGVuIGFsbFxuICAvLyBNZWRpYSBQbGF5bGlzdHMgaW4gdGhhdCBNYXN0ZXIgUGxheWxpc3QgTVVTVCBjb250YWluIEVYVC1YLVBST0dSQU0tREFURS1USU1FIHRhZ3Mgd2l0aCBjb25zaXN0ZW50IG1hcHBpbmdzXG4gIC8vIG9mIGRhdGUgYW5kIHRpbWUgdG8gbWVkaWEgdGltZXN0YW1wcy5cIlxuICAvLyBTbyB3ZSBzaG91bGQgYmUgYWJsZSB0byB1c2UgZWFjaCByZW5kaXRpb24ncyBQRFQgYXMgYSByZWZlcmVuY2UgdGltZSBhbmQgdXNlIHRoZSBkZWx0YSB0byBjb21wdXRlIG91ciByZWxldmFudFxuICAvLyBzdGFydCBhbmQgZW5kIHRpbWVzLlxuICAvLyBOT1RFOiBUaGlzIGNvZGUgYXNzdW1lcyBlYWNoIGxldmVsL2RldGFpbHMgdGltZWxpbmVzIGhhdmUgYWxyZWFkeSBiZWVuIG1hZGUgXCJpbnRlcm5hbGx5IGNvbnNpc3RlbnRcIlxuXG4gIGRldGFpbHMuZnJhZ21lbnRzLmZvckVhY2goZnVuY3Rpb24gKGZyYWcpIHtcbiAgICBhbGlnbkZyYWdtZW50QnlQRFREZWx0YShmcmFnLCBkZWx0YSk7XG4gIH0pO1xuXG4gIGlmIChkZXRhaWxzLmZyYWdtZW50SGludCkge1xuICAgIGFsaWduRnJhZ21lbnRCeVBEVERlbHRhKGRldGFpbHMuZnJhZ21lbnRIaW50LCBkZWx0YSk7XG4gIH1cblxuICBkZXRhaWxzLmFsaWduZWRTbGlkaW5nID0gdHJ1ZTtcbn1cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvdXRpbHMvZXdtYS1iYW5kd2lkdGgtZXN0aW1hdG9yLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy91dGlscy9ld21hLWJhbmR3aWR0aC1lc3RpbWF0b3IudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2V3bWFfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL2V3bWEgKi8gXCIuL3NyYy91dGlscy9ld21hLnRzXCIpO1xuLypcbiAqIEVXTUEgQmFuZHdpZHRoIEVzdGltYXRvclxuICogIC0gaGVhdmlseSBpbnNwaXJlZCBmcm9tIHNoYWthLXBsYXllclxuICogVHJhY2tzIGJhbmR3aWR0aCBzYW1wbGVzIGFuZCBlc3RpbWF0ZXMgYXZhaWxhYmxlIGJhbmR3aWR0aC5cbiAqIEJhc2VkIG9uIHRoZSBtaW5pbXVtIG9mIHR3byBleHBvbmVudGlhbGx5LXdlaWdodGVkIG1vdmluZyBhdmVyYWdlcyB3aXRoXG4gKiBkaWZmZXJlbnQgaGFsZi1saXZlcy5cbiAqL1xuXG5cbnZhciBFd21hQmFuZFdpZHRoRXN0aW1hdG9yID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRXdtYUJhbmRXaWR0aEVzdGltYXRvcihzbG93LCBmYXN0LCBkZWZhdWx0RXN0aW1hdGUpIHtcbiAgICB0aGlzLmRlZmF1bHRFc3RpbWF0ZV8gPSB2b2lkIDA7XG4gICAgdGhpcy5taW5XZWlnaHRfID0gdm9pZCAwO1xuICAgIHRoaXMubWluRGVsYXlNc18gPSB2b2lkIDA7XG4gICAgdGhpcy5zbG93XyA9IHZvaWQgMDtcbiAgICB0aGlzLmZhc3RfID0gdm9pZCAwO1xuICAgIHRoaXMuZGVmYXVsdEVzdGltYXRlXyA9IGRlZmF1bHRFc3RpbWF0ZTtcbiAgICB0aGlzLm1pbldlaWdodF8gPSAwLjAwMTtcbiAgICB0aGlzLm1pbkRlbGF5TXNfID0gNTA7XG4gICAgdGhpcy5zbG93XyA9IG5ldyBfdXRpbHNfZXdtYV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiZGVmYXVsdFwiXShzbG93KTtcbiAgICB0aGlzLmZhc3RfID0gbmV3IF91dGlsc19ld21hX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJkZWZhdWx0XCJdKGZhc3QpO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IEV3bWFCYW5kV2lkdGhFc3RpbWF0b3IucHJvdG90eXBlO1xuXG4gIF9wcm90by51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUoc2xvdywgZmFzdCkge1xuICAgIHZhciBzbG93XyA9IHRoaXMuc2xvd18sXG4gICAgICAgIGZhc3RfID0gdGhpcy5mYXN0XztcblxuICAgIGlmICh0aGlzLnNsb3dfLmhhbGZMaWZlICE9PSBzbG93KSB7XG4gICAgICB0aGlzLnNsb3dfID0gbmV3IF91dGlsc19ld21hX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJkZWZhdWx0XCJdKHNsb3csIHNsb3dfLmdldEVzdGltYXRlKCksIHNsb3dfLmdldFRvdGFsV2VpZ2h0KCkpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmZhc3RfLmhhbGZMaWZlICE9PSBmYXN0KSB7XG4gICAgICB0aGlzLmZhc3RfID0gbmV3IF91dGlsc19ld21hX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJkZWZhdWx0XCJdKGZhc3QsIGZhc3RfLmdldEVzdGltYXRlKCksIGZhc3RfLmdldFRvdGFsV2VpZ2h0KCkpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uc2FtcGxlID0gZnVuY3Rpb24gc2FtcGxlKGR1cmF0aW9uTXMsIG51bUJ5dGVzKSB7XG4gICAgZHVyYXRpb25NcyA9IE1hdGgubWF4KGR1cmF0aW9uTXMsIHRoaXMubWluRGVsYXlNc18pO1xuICAgIHZhciBudW1CaXRzID0gOCAqIG51bUJ5dGVzOyAvLyB3ZWlnaHQgaXMgZHVyYXRpb24gaW4gc2Vjb25kc1xuXG4gICAgdmFyIGR1cmF0aW9uUyA9IGR1cmF0aW9uTXMgLyAxMDAwOyAvLyB2YWx1ZSBpcyBiYW5kd2lkdGggaW4gYml0cy9zXG5cbiAgICB2YXIgYmFuZHdpZHRoSW5CcHMgPSBudW1CaXRzIC8gZHVyYXRpb25TO1xuICAgIHRoaXMuZmFzdF8uc2FtcGxlKGR1cmF0aW9uUywgYmFuZHdpZHRoSW5CcHMpO1xuICAgIHRoaXMuc2xvd18uc2FtcGxlKGR1cmF0aW9uUywgYmFuZHdpZHRoSW5CcHMpO1xuICB9O1xuXG4gIF9wcm90by5jYW5Fc3RpbWF0ZSA9IGZ1bmN0aW9uIGNhbkVzdGltYXRlKCkge1xuICAgIHZhciBmYXN0ID0gdGhpcy5mYXN0XztcbiAgICByZXR1cm4gZmFzdCAmJiBmYXN0LmdldFRvdGFsV2VpZ2h0KCkgPj0gdGhpcy5taW5XZWlnaHRfO1xuICB9O1xuXG4gIF9wcm90by5nZXRFc3RpbWF0ZSA9IGZ1bmN0aW9uIGdldEVzdGltYXRlKCkge1xuICAgIGlmICh0aGlzLmNhbkVzdGltYXRlKCkpIHtcbiAgICAgIC8vIGNvbnNvbGUubG9nKCdzbG93IGVzdGltYXRlOicrIE1hdGgucm91bmQodGhpcy5zbG93Xy5nZXRFc3RpbWF0ZSgpKSk7XG4gICAgICAvLyBjb25zb2xlLmxvZygnZmFzdCBlc3RpbWF0ZTonKyBNYXRoLnJvdW5kKHRoaXMuZmFzdF8uZ2V0RXN0aW1hdGUoKSkpO1xuICAgICAgLy8gVGFrZSB0aGUgbWluaW11bSBvZiB0aGVzZSB0d28gZXN0aW1hdGVzLiAgVGhpcyBzaG91bGQgaGF2ZSB0aGUgZWZmZWN0IG9mXG4gICAgICAvLyBhZGFwdGluZyBkb3duIHF1aWNrbHksIGJ1dCB1cCBtb3JlIHNsb3dseS5cbiAgICAgIHJldHVybiBNYXRoLm1pbih0aGlzLmZhc3RfLmdldEVzdGltYXRlKCksIHRoaXMuc2xvd18uZ2V0RXN0aW1hdGUoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmRlZmF1bHRFc3RpbWF0ZV87XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5kZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveSgpIHt9O1xuXG4gIHJldHVybiBFd21hQmFuZFdpZHRoRXN0aW1hdG9yO1xufSgpO1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKEV3bWFCYW5kV2lkdGhFc3RpbWF0b3IpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy91dGlscy9ld21hLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvdXRpbHMvZXdtYS50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKlxuICogY29tcHV0ZSBhbiBFeHBvbmVudGlhbCBXZWlnaHRlZCBtb3ZpbmcgYXZlcmFnZVxuICogLSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Nb3ZpbmdfYXZlcmFnZSNFeHBvbmVudGlhbF9tb3ZpbmdfYXZlcmFnZVxuICogIC0gaGVhdmlseSBpbnNwaXJlZCBmcm9tIHNoYWthLXBsYXllclxuICovXG52YXIgRVdNQSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8vICBBYm91dCBoYWxmIG9mIHRoZSBlc3RpbWF0ZWQgdmFsdWUgd2lsbCBiZSBmcm9tIHRoZSBsYXN0IHxoYWxmTGlmZXwgc2FtcGxlcyBieSB3ZWlnaHQuXG4gIGZ1bmN0aW9uIEVXTUEoaGFsZkxpZmUsIGVzdGltYXRlLCB3ZWlnaHQpIHtcbiAgICBpZiAoZXN0aW1hdGUgPT09IHZvaWQgMCkge1xuICAgICAgZXN0aW1hdGUgPSAwO1xuICAgIH1cblxuICAgIGlmICh3ZWlnaHQgPT09IHZvaWQgMCkge1xuICAgICAgd2VpZ2h0ID0gMDtcbiAgICB9XG5cbiAgICB0aGlzLmhhbGZMaWZlID0gdm9pZCAwO1xuICAgIHRoaXMuYWxwaGFfID0gdm9pZCAwO1xuICAgIHRoaXMuZXN0aW1hdGVfID0gdm9pZCAwO1xuICAgIHRoaXMudG90YWxXZWlnaHRfID0gdm9pZCAwO1xuICAgIHRoaXMuaGFsZkxpZmUgPSBoYWxmTGlmZTsgLy8gTGFyZ2VyIHZhbHVlcyBvZiBhbHBoYSBleHBpcmUgaGlzdG9yaWNhbCBkYXRhIG1vcmUgc2xvd2x5LlxuXG4gICAgdGhpcy5hbHBoYV8gPSBoYWxmTGlmZSA/IE1hdGguZXhwKE1hdGgubG9nKDAuNSkgLyBoYWxmTGlmZSkgOiAwO1xuICAgIHRoaXMuZXN0aW1hdGVfID0gZXN0aW1hdGU7XG4gICAgdGhpcy50b3RhbFdlaWdodF8gPSB3ZWlnaHQ7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gRVdNQS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLnNhbXBsZSA9IGZ1bmN0aW9uIHNhbXBsZSh3ZWlnaHQsIHZhbHVlKSB7XG4gICAgdmFyIGFkakFscGhhID0gTWF0aC5wb3codGhpcy5hbHBoYV8sIHdlaWdodCk7XG4gICAgdGhpcy5lc3RpbWF0ZV8gPSB2YWx1ZSAqICgxIC0gYWRqQWxwaGEpICsgYWRqQWxwaGEgKiB0aGlzLmVzdGltYXRlXztcbiAgICB0aGlzLnRvdGFsV2VpZ2h0XyArPSB3ZWlnaHQ7XG4gIH07XG5cbiAgX3Byb3RvLmdldFRvdGFsV2VpZ2h0ID0gZnVuY3Rpb24gZ2V0VG90YWxXZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMudG90YWxXZWlnaHRfO1xuICB9O1xuXG4gIF9wcm90by5nZXRFc3RpbWF0ZSA9IGZ1bmN0aW9uIGdldEVzdGltYXRlKCkge1xuICAgIGlmICh0aGlzLmFscGhhXykge1xuICAgICAgdmFyIHplcm9GYWN0b3IgPSAxIC0gTWF0aC5wb3codGhpcy5hbHBoYV8sIHRoaXMudG90YWxXZWlnaHRfKTtcblxuICAgICAgaWYgKHplcm9GYWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXN0aW1hdGVfIC8gemVyb0ZhY3RvcjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5lc3RpbWF0ZV87XG4gIH07XG5cbiAgcmV0dXJuIEVXTUE7XG59KCk7XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoRVdNQSk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3V0aWxzL2ZldGNoLWxvYWRlci50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvdXRpbHMvZmV0Y2gtbG9hZGVyLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBmZXRjaFN1cHBvcnRlZCwgZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJmZXRjaFN1cHBvcnRlZFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGZldGNoU3VwcG9ydGVkOyB9KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfaG9tZV9ydW5uZXJfd29ya19obHNfanNfaGxzX2pzX3NyY19wb2x5ZmlsbHNfbnVtYmVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3NyYy9wb2x5ZmlsbHMvbnVtYmVyICovIFwiLi9zcmMvcG9seWZpbGxzL251bWJlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbG9hZGVyX2xvYWRfc3RhdHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2xvYWRlci9sb2FkLXN0YXRzICovIFwiLi9zcmMvbG9hZGVyL2xvYWQtc3RhdHMudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2RlbXV4X2NodW5rX2NhY2hlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9kZW11eC9jaHVuay1jYWNoZSAqLyBcIi4vc3JjL2RlbXV4L2NodW5rLWNhY2hlLnRzXCIpO1xuXG5cblxuZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7IHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzOyBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpIHsgdmFyIF9jYWNoZSA9IHR5cGVvZiBNYXAgPT09IFwiZnVuY3Rpb25cIiA/IG5ldyBNYXAoKSA6IHVuZGVmaW5lZDsgX3dyYXBOYXRpdmVTdXBlciA9IGZ1bmN0aW9uIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpIHsgaWYgKENsYXNzID09PSBudWxsIHx8ICFfaXNOYXRpdmVGdW5jdGlvbihDbGFzcykpIHJldHVybiBDbGFzczsgaWYgKHR5cGVvZiBDbGFzcyAhPT0gXCJmdW5jdGlvblwiKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBpZiAodHlwZW9mIF9jYWNoZSAhPT0gXCJ1bmRlZmluZWRcIikgeyBpZiAoX2NhY2hlLmhhcyhDbGFzcykpIHJldHVybiBfY2FjaGUuZ2V0KENsYXNzKTsgX2NhY2hlLnNldChDbGFzcywgV3JhcHBlcik7IH0gZnVuY3Rpb24gV3JhcHBlcigpIHsgcmV0dXJuIF9jb25zdHJ1Y3QoQ2xhc3MsIGFyZ3VtZW50cywgX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yKTsgfSBXcmFwcGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBXcmFwcGVyLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyByZXR1cm4gX3NldFByb3RvdHlwZU9mKFdyYXBwZXIsIENsYXNzKTsgfTsgcmV0dXJuIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9jb25zdHJ1Y3QoUGFyZW50LCBhcmdzLCBDbGFzcykgeyBpZiAoX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpKSB7IF9jb25zdHJ1Y3QgPSBSZWZsZWN0LmNvbnN0cnVjdDsgfSBlbHNlIHsgX2NvbnN0cnVjdCA9IGZ1bmN0aW9uIF9jb25zdHJ1Y3QoUGFyZW50LCBhcmdzLCBDbGFzcykgeyB2YXIgYSA9IFtudWxsXTsgYS5wdXNoLmFwcGx5KGEsIGFyZ3MpOyB2YXIgQ29uc3RydWN0b3IgPSBGdW5jdGlvbi5iaW5kLmFwcGx5KFBhcmVudCwgYSk7IHZhciBpbnN0YW5jZSA9IG5ldyBDb25zdHJ1Y3RvcigpOyBpZiAoQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihpbnN0YW5jZSwgQ2xhc3MucHJvdG90eXBlKTsgcmV0dXJuIGluc3RhbmNlOyB9OyB9IHJldHVybiBfY29uc3RydWN0LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZUZ1bmN0aW9uKGZuKSB7IHJldHVybiBGdW5jdGlvbi50b1N0cmluZy5jYWxsKGZuKS5pbmRleE9mKFwiW25hdGl2ZSBjb2RlXVwiKSAhPT0gLTE7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxuXG5mdW5jdGlvbiBfZXh0ZW5kcygpIHsgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxuXG5cblxuZnVuY3Rpb24gZmV0Y2hTdXBwb3J0ZWQoKSB7XG4gIGlmICggLy8gQHRzLWlnbm9yZVxuICBzZWxmLmZldGNoICYmIHNlbGYuQWJvcnRDb250cm9sbGVyICYmIHNlbGYuUmVhZGFibGVTdHJlYW0gJiYgc2VsZi5SZXF1ZXN0KSB7XG4gICAgdHJ5IHtcbiAgICAgIG5ldyBzZWxmLlJlYWRhYmxlU3RyZWFtKHt9KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLyogbm9vcCAqL1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxudmFyIEZldGNoTG9hZGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRmV0Y2hMb2FkZXIoY29uZmlnXG4gIC8qIEhsc0NvbmZpZyAqL1xuICApIHtcbiAgICB0aGlzLmZldGNoU2V0dXAgPSB2b2lkIDA7XG4gICAgdGhpcy5yZXF1ZXN0VGltZW91dCA9IHZvaWQgMDtcbiAgICB0aGlzLnJlcXVlc3QgPSB2b2lkIDA7XG4gICAgdGhpcy5yZXNwb25zZSA9IHZvaWQgMDtcbiAgICB0aGlzLmNvbnRyb2xsZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5jb250ZXh0ID0gdm9pZCAwO1xuICAgIHRoaXMuY29uZmlnID0gbnVsbDtcbiAgICB0aGlzLmNhbGxiYWNrcyA9IG51bGw7XG4gICAgdGhpcy5zdGF0cyA9IHZvaWQgMDtcbiAgICB0aGlzLmxvYWRlciA9IG51bGw7XG4gICAgdGhpcy5mZXRjaFNldHVwID0gY29uZmlnLmZldGNoU2V0dXAgfHwgZ2V0UmVxdWVzdDtcbiAgICB0aGlzLmNvbnRyb2xsZXIgPSBuZXcgc2VsZi5BYm9ydENvbnRyb2xsZXIoKTtcbiAgICB0aGlzLnN0YXRzID0gbmV3IF9sb2FkZXJfbG9hZF9zdGF0c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiTG9hZFN0YXRzXCJdKCk7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gRmV0Y2hMb2FkZXIucHJvdG90eXBlO1xuXG4gIF9wcm90by5kZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICB0aGlzLmxvYWRlciA9IHRoaXMuY2FsbGJhY2tzID0gbnVsbDtcbiAgICB0aGlzLmFib3J0SW50ZXJuYWwoKTtcbiAgfTtcblxuICBfcHJvdG8uYWJvcnRJbnRlcm5hbCA9IGZ1bmN0aW9uIGFib3J0SW50ZXJuYWwoKSB7XG4gICAgdmFyIHJlc3BvbnNlID0gdGhpcy5yZXNwb25zZTtcblxuICAgIGlmICghcmVzcG9uc2UgfHwgIXJlc3BvbnNlLm9rKSB7XG4gICAgICB0aGlzLnN0YXRzLmFib3J0ZWQgPSB0cnVlO1xuICAgICAgdGhpcy5jb250cm9sbGVyLmFib3J0KCk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5hYm9ydCA9IGZ1bmN0aW9uIGFib3J0KCkge1xuICAgIHZhciBfdGhpcyRjYWxsYmFja3M7XG5cbiAgICB0aGlzLmFib3J0SW50ZXJuYWwoKTtcblxuICAgIGlmICgoX3RoaXMkY2FsbGJhY2tzID0gdGhpcy5jYWxsYmFja3MpICE9PSBudWxsICYmIF90aGlzJGNhbGxiYWNrcyAhPT0gdm9pZCAwICYmIF90aGlzJGNhbGxiYWNrcy5vbkFib3J0KSB7XG4gICAgICB0aGlzLmNhbGxiYWNrcy5vbkFib3J0KHRoaXMuc3RhdHMsIHRoaXMuY29udGV4dCwgdGhpcy5yZXNwb25zZSk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5sb2FkID0gZnVuY3Rpb24gbG9hZChjb250ZXh0LCBjb25maWcsIGNhbGxiYWNrcykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgc3RhdHMgPSB0aGlzLnN0YXRzO1xuXG4gICAgaWYgKHN0YXRzLmxvYWRpbmcuc3RhcnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTG9hZGVyIGNhbiBvbmx5IGJlIHVzZWQgb25jZS4nKTtcbiAgICB9XG5cbiAgICBzdGF0cy5sb2FkaW5nLnN0YXJ0ID0gc2VsZi5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICB2YXIgaW5pdFBhcmFtcyA9IGdldFJlcXVlc3RQYXJhbWV0ZXJzKGNvbnRleHQsIHRoaXMuY29udHJvbGxlci5zaWduYWwpO1xuICAgIHZhciBvblByb2dyZXNzID0gY2FsbGJhY2tzLm9uUHJvZ3Jlc3M7XG4gICAgdmFyIGlzQXJyYXlCdWZmZXIgPSBjb250ZXh0LnJlc3BvbnNlVHlwZSA9PT0gJ2FycmF5YnVmZmVyJztcbiAgICB2YXIgTEVOR1RIID0gaXNBcnJheUJ1ZmZlciA/ICdieXRlTGVuZ3RoJyA6ICdsZW5ndGgnO1xuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgdGhpcy5jYWxsYmFja3MgPSBjYWxsYmFja3M7XG4gICAgdGhpcy5yZXF1ZXN0ID0gdGhpcy5mZXRjaFNldHVwKGNvbnRleHQsIGluaXRQYXJhbXMpO1xuICAgIHNlbGYuY2xlYXJUaW1lb3V0KHRoaXMucmVxdWVzdFRpbWVvdXQpO1xuICAgIHRoaXMucmVxdWVzdFRpbWVvdXQgPSBzZWxmLnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMuYWJvcnRJbnRlcm5hbCgpO1xuXG4gICAgICBjYWxsYmFja3Mub25UaW1lb3V0KHN0YXRzLCBjb250ZXh0LCBfdGhpcy5yZXNwb25zZSk7XG4gICAgfSwgY29uZmlnLnRpbWVvdXQpO1xuICAgIHNlbGYuZmV0Y2godGhpcy5yZXF1ZXN0KS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgX3RoaXMucmVzcG9uc2UgPSBfdGhpcy5sb2FkZXIgPSByZXNwb25zZTtcblxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICB2YXIgc3RhdHVzID0gcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICAgICAgc3RhdHVzVGV4dCA9IHJlc3BvbnNlLnN0YXR1c1RleHQ7XG4gICAgICAgIHRocm93IG5ldyBGZXRjaEVycm9yKHN0YXR1c1RleHQgfHwgJ2ZldGNoLCBiYWQgbmV0d29yayByZXNwb25zZScsIHN0YXR1cywgcmVzcG9uc2UpO1xuICAgICAgfVxuXG4gICAgICBzdGF0cy5sb2FkaW5nLmZpcnN0ID0gTWF0aC5tYXgoc2VsZi5wZXJmb3JtYW5jZS5ub3coKSwgc3RhdHMubG9hZGluZy5zdGFydCk7XG4gICAgICBzdGF0cy50b3RhbCA9IHBhcnNlSW50KHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCdDb250ZW50LUxlbmd0aCcpIHx8ICcwJyk7XG5cbiAgICAgIGlmIChvblByb2dyZXNzICYmIE9iamVjdChfaG9tZV9ydW5uZXJfd29ya19obHNfanNfaGxzX2pzX3NyY19wb2x5ZmlsbHNfbnVtYmVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJpc0Zpbml0ZU51bWJlclwiXSkoY29uZmlnLmhpZ2hXYXRlck1hcmspKSB7XG4gICAgICAgIHJldHVybiBfdGhpcy5sb2FkUHJvZ3Jlc3NpdmVseShyZXNwb25zZSwgc3RhdHMsIGNvbnRleHQsIGNvbmZpZy5oaWdoV2F0ZXJNYXJrLCBvblByb2dyZXNzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmFycmF5QnVmZmVyKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXNwb25zZS50ZXh0KCk7XG4gICAgfSkudGhlbihmdW5jdGlvbiAocmVzcG9uc2VEYXRhKSB7XG4gICAgICB2YXIgcmVzcG9uc2UgPSBfdGhpcy5yZXNwb25zZTtcbiAgICAgIHNlbGYuY2xlYXJUaW1lb3V0KF90aGlzLnJlcXVlc3RUaW1lb3V0KTtcbiAgICAgIHN0YXRzLmxvYWRpbmcuZW5kID0gTWF0aC5tYXgoc2VsZi5wZXJmb3JtYW5jZS5ub3coKSwgc3RhdHMubG9hZGluZy5maXJzdCk7XG4gICAgICBzdGF0cy5sb2FkZWQgPSBzdGF0cy50b3RhbCA9IHJlc3BvbnNlRGF0YVtMRU5HVEhdO1xuICAgICAgdmFyIGxvYWRlclJlc3BvbnNlID0ge1xuICAgICAgICB1cmw6IHJlc3BvbnNlLnVybCxcbiAgICAgICAgZGF0YTogcmVzcG9uc2VEYXRhXG4gICAgICB9O1xuXG4gICAgICBpZiAob25Qcm9ncmVzcyAmJiAhT2JqZWN0KF9ob21lX3J1bm5lcl93b3JrX2hsc19qc19obHNfanNfc3JjX3BvbHlmaWxsc19udW1iZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImlzRmluaXRlTnVtYmVyXCJdKShjb25maWcuaGlnaFdhdGVyTWFyaykpIHtcbiAgICAgICAgb25Qcm9ncmVzcyhzdGF0cywgY29udGV4dCwgcmVzcG9uc2VEYXRhLCByZXNwb25zZSk7XG4gICAgICB9XG5cbiAgICAgIGNhbGxiYWNrcy5vblN1Y2Nlc3MobG9hZGVyUmVzcG9uc2UsIHN0YXRzLCBjb250ZXh0LCByZXNwb25zZSk7XG4gICAgfSkuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICBzZWxmLmNsZWFyVGltZW91dChfdGhpcy5yZXF1ZXN0VGltZW91dCk7XG5cbiAgICAgIGlmIChzdGF0cy5hYm9ydGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gQ09SUyBlcnJvcnMgcmVzdWx0IGluIGFuIHVuZGVmaW5lZCBjb2RlLiBTZXQgaXQgdG8gMCBoZXJlIHRvIGFsaWduIHdpdGggWEhSJ3MgYmVoYXZpb3JcblxuXG4gICAgICB2YXIgY29kZSA9IGVycm9yLmNvZGUgfHwgMDtcbiAgICAgIGNhbGxiYWNrcy5vbkVycm9yKHtcbiAgICAgICAgY29kZTogY29kZSxcbiAgICAgICAgdGV4dDogZXJyb3IubWVzc2FnZVxuICAgICAgfSwgY29udGV4dCwgZXJyb3IuZGV0YWlscyk7XG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLmdldENhY2hlQWdlID0gZnVuY3Rpb24gZ2V0Q2FjaGVBZ2UoKSB7XG4gICAgdmFyIHJlc3VsdCA9IG51bGw7XG5cbiAgICBpZiAodGhpcy5yZXNwb25zZSkge1xuICAgICAgdmFyIGFnZUhlYWRlciA9IHRoaXMucmVzcG9uc2UuaGVhZGVycy5nZXQoJ2FnZScpO1xuICAgICAgcmVzdWx0ID0gYWdlSGVhZGVyID8gcGFyc2VGbG9hdChhZ2VIZWFkZXIpIDogbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIF9wcm90by5sb2FkUHJvZ3Jlc3NpdmVseSA9IGZ1bmN0aW9uIGxvYWRQcm9ncmVzc2l2ZWx5KHJlc3BvbnNlLCBzdGF0cywgY29udGV4dCwgaGlnaFdhdGVyTWFyaywgb25Qcm9ncmVzcykge1xuICAgIGlmIChoaWdoV2F0ZXJNYXJrID09PSB2b2lkIDApIHtcbiAgICAgIGhpZ2hXYXRlck1hcmsgPSAwO1xuICAgIH1cblxuICAgIHZhciBjaHVua0NhY2hlID0gbmV3IF9kZW11eF9jaHVua19jYWNoZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiZGVmYXVsdFwiXSgpO1xuICAgIHZhciByZWFkZXIgPSByZXNwb25zZS5ib2R5LmdldFJlYWRlcigpO1xuXG4gICAgdmFyIHB1bXAgPSBmdW5jdGlvbiBwdW1wKCkge1xuICAgICAgcmV0dXJuIHJlYWRlci5yZWFkKCkudGhlbihmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICBpZiAoZGF0YS5kb25lKSB7XG4gICAgICAgICAgaWYgKGNodW5rQ2FjaGUuZGF0YUxlbmd0aCkge1xuICAgICAgICAgICAgb25Qcm9ncmVzcyhzdGF0cywgY29udGV4dCwgY2h1bmtDYWNoZS5mbHVzaCgpLCByZXNwb25zZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShuZXcgQXJyYXlCdWZmZXIoMCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNodW5rID0gZGF0YS52YWx1ZTtcbiAgICAgICAgdmFyIGxlbiA9IGNodW5rLmxlbmd0aDtcbiAgICAgICAgc3RhdHMubG9hZGVkICs9IGxlbjtcblxuICAgICAgICBpZiAobGVuIDwgaGlnaFdhdGVyTWFyayB8fCBjaHVua0NhY2hlLmRhdGFMZW5ndGgpIHtcbiAgICAgICAgICAvLyBUaGUgY3VycmVudCBjaHVuayBpcyB0b28gc21hbGwgdG8gdG8gYmUgZW1pdHRlZCBvciB0aGUgY2FjaGUgYWxyZWFkeSBoYXMgZGF0YVxuICAgICAgICAgIC8vIFB1c2ggaXQgdG8gdGhlIGNhY2hlXG4gICAgICAgICAgY2h1bmtDYWNoZS5wdXNoKGNodW5rKTtcblxuICAgICAgICAgIGlmIChjaHVua0NhY2hlLmRhdGFMZW5ndGggPj0gaGlnaFdhdGVyTWFyaykge1xuICAgICAgICAgICAgLy8gZmx1c2ggaW4gb3JkZXIgdG8gam9pbiB0aGUgdHlwZWQgYXJyYXlzXG4gICAgICAgICAgICBvblByb2dyZXNzKHN0YXRzLCBjb250ZXh0LCBjaHVua0NhY2hlLmZsdXNoKCksIHJlc3BvbnNlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gSWYgdGhlcmUncyBub3RoaW5nIGNhY2hlZCBhbHJlYWR5LCBhbmQgdGhlIGNoYWNoZSBpcyBsYXJnZSBlbm91Z2hcbiAgICAgICAgICAvLyBqdXN0IGVtaXQgdGhlIHByb2dyZXNzIGV2ZW50XG4gICAgICAgICAgb25Qcm9ncmVzcyhzdGF0cywgY29udGV4dCwgY2h1bmssIHJlc3BvbnNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwdW1wKCk7XG4gICAgICB9KS5jYXRjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8qIGFib3J0ZWQgKi9cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHB1bXAoKTtcbiAgfTtcblxuICByZXR1cm4gRmV0Y2hMb2FkZXI7XG59KCk7XG5cbmZ1bmN0aW9uIGdldFJlcXVlc3RQYXJhbWV0ZXJzKGNvbnRleHQsIHNpZ25hbCkge1xuICB2YXIgaW5pdFBhcmFtcyA9IHtcbiAgICBtZXRob2Q6ICdHRVQnLFxuICAgIG1vZGU6ICdjb3JzJyxcbiAgICBjcmVkZW50aWFsczogJ3NhbWUtb3JpZ2luJyxcbiAgICBzaWduYWw6IHNpZ25hbCxcbiAgICBoZWFkZXJzOiBuZXcgc2VsZi5IZWFkZXJzKF9leHRlbmRzKHt9LCBjb250ZXh0LmhlYWRlcnMpKVxuICB9O1xuXG4gIGlmIChjb250ZXh0LnJhbmdlRW5kKSB7XG4gICAgaW5pdFBhcmFtcy5oZWFkZXJzLnNldCgnUmFuZ2UnLCAnYnl0ZXM9JyArIGNvbnRleHQucmFuZ2VTdGFydCArICctJyArIFN0cmluZyhjb250ZXh0LnJhbmdlRW5kIC0gMSkpO1xuICB9XG5cbiAgcmV0dXJuIGluaXRQYXJhbXM7XG59XG5cbmZ1bmN0aW9uIGdldFJlcXVlc3QoY29udGV4dCwgaW5pdFBhcmFtcykge1xuICByZXR1cm4gbmV3IHNlbGYuUmVxdWVzdChjb250ZXh0LnVybCwgaW5pdFBhcmFtcyk7XG59XG5cbnZhciBGZXRjaEVycm9yID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRXJyb3IpIHtcbiAgX2luaGVyaXRzTG9vc2UoRmV0Y2hFcnJvciwgX0Vycm9yKTtcblxuICBmdW5jdGlvbiBGZXRjaEVycm9yKG1lc3NhZ2UsIGNvZGUsIGRldGFpbHMpIHtcbiAgICB2YXIgX3RoaXMyO1xuXG4gICAgX3RoaXMyID0gX0Vycm9yLmNhbGwodGhpcywgbWVzc2FnZSkgfHwgdGhpcztcbiAgICBfdGhpczIuY29kZSA9IHZvaWQgMDtcbiAgICBfdGhpczIuZGV0YWlscyA9IHZvaWQgMDtcbiAgICBfdGhpczIuY29kZSA9IGNvZGU7XG4gICAgX3RoaXMyLmRldGFpbHMgPSBkZXRhaWxzO1xuICAgIHJldHVybiBfdGhpczI7XG4gIH1cblxuICByZXR1cm4gRmV0Y2hFcnJvcjtcbn0oIC8qI19fUFVSRV9fKi9fd3JhcE5hdGl2ZVN1cGVyKEVycm9yKSk7XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoRmV0Y2hMb2FkZXIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy91dGlscy9pbXNjMS10dG1sLXBhcnNlci50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy91dGlscy9pbXNjMS10dG1sLXBhcnNlci50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBJTVNDMV9DT0RFQywgcGFyc2VJTVNDMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJJTVNDMV9DT0RFQ1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIElNU0MxX0NPREVDOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJwYXJzZUlNU0MxXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gcGFyc2VJTVNDMTsgfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX21wNF90b29sc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9tcDQtdG9vbHMgKi8gXCIuL3NyYy91dGlscy9tcDQtdG9vbHMudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3Z0dHBhcnNlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi92dHRwYXJzZXIgKi8gXCIuL3NyYy91dGlscy92dHRwYXJzZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3Z0dGN1ZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi92dHRjdWUgKi8gXCIuL3NyYy91dGlscy92dHRjdWUudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2RlbXV4X2lkM19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZGVtdXgvaWQzICovIFwiLi9zcmMvZGVtdXgvaWQzLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF90aW1lc2NhbGVfY29udmVyc2lvbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi90aW1lc2NhbGUtY29udmVyc2lvbiAqLyBcIi4vc3JjL3V0aWxzL3RpbWVzY2FsZS1jb252ZXJzaW9uLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF93ZWJ2dHRfcGFyc2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3dlYnZ0dC1wYXJzZXIgKi8gXCIuL3NyYy91dGlscy93ZWJ2dHQtcGFyc2VyLnRzXCIpO1xuZnVuY3Rpb24gX2V4dGVuZHMoKSB7IF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTsgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH1cblxuXG5cblxuXG5cblxudmFyIElNU0MxX0NPREVDID0gJ3N0cHAudHRtbC5pbTF0JzsgLy8gVGltZSBmb3JtYXQ6IGg6bTpzOmZyYW1lcyguc3ViZnJhbWVzKVxuXG52YXIgSE1TRl9SRUdFWCA9IC9eKFxcZHsyLH0pOihcXGR7Mn0pOihcXGR7Mn0pOihcXGR7Mn0pXFwuPyhcXGQrKT8kLzsgLy8gVGltZSBmb3JtYXQ6IGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIGZyYW1lcywgdGlja3NcblxudmFyIFRJTUVfVU5JVF9SRUdFWCA9IC9eKFxcZCooPzpcXC5cXGQqKT8pKGh8bXxzfG1zfGZ8dCkkLztcbnZhciB0ZXh0QWxpZ25Ub0xpbmVBbGlnbiA9IHtcbiAgbGVmdDogJ3N0YXJ0JyxcbiAgY2VudGVyOiAnY2VudGVyJyxcbiAgcmlnaHQ6ICdlbmQnLFxuICBzdGFydDogJ3N0YXJ0JyxcbiAgZW5kOiAnZW5kJ1xufTtcbmZ1bmN0aW9uIHBhcnNlSU1TQzEocGF5bG9hZCwgaW5pdFBUUywgdGltZXNjYWxlLCBjYWxsQmFjaywgZXJyb3JDYWxsQmFjaykge1xuICB2YXIgcmVzdWx0cyA9IE9iamVjdChfbXA0X3Rvb2xzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJmaW5kQm94XCJdKShuZXcgVWludDhBcnJheShwYXlsb2FkKSwgWydtZGF0J10pO1xuXG4gIGlmIChyZXN1bHRzLmxlbmd0aCA9PT0gMCkge1xuICAgIGVycm9yQ2FsbEJhY2sobmV3IEVycm9yKCdDb3VsZCBub3QgcGFyc2UgSU1TQzEgbWRhdCcpKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgbWRhdCA9IHJlc3VsdHNbMF07XG4gIHZhciB0dG1sID0gT2JqZWN0KF9kZW11eF9pZDNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcInV0ZjhBcnJheVRvU3RyXCJdKShuZXcgVWludDhBcnJheShwYXlsb2FkLCBtZGF0LnN0YXJ0LCBtZGF0LmVuZCAtIG1kYXQuc3RhcnQpKTtcbiAgdmFyIHN5bmNUaW1lID0gT2JqZWN0KF90aW1lc2NhbGVfY29udmVyc2lvbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fW1widG9UaW1lc2NhbGVGcm9tU2NhbGVcIl0pKGluaXRQVFMsIDEsIHRpbWVzY2FsZSk7XG5cbiAgdHJ5IHtcbiAgICBjYWxsQmFjayhwYXJzZVRUTUwodHRtbCwgc3luY1RpbWUpKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBlcnJvckNhbGxCYWNrKGVycm9yKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwYXJzZVRUTUwodHRtbCwgc3luY1RpbWUpIHtcbiAgdmFyIHBhcnNlciA9IG5ldyBET01QYXJzZXIoKTtcbiAgdmFyIHhtbERvYyA9IHBhcnNlci5wYXJzZUZyb21TdHJpbmcodHRtbCwgJ3RleHQveG1sJyk7XG4gIHZhciB0dCA9IHhtbERvYy5nZXRFbGVtZW50c0J5VGFnTmFtZSgndHQnKVswXTtcblxuICBpZiAoIXR0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHR0bWwnKTtcbiAgfVxuXG4gIHZhciBkZWZhdWx0UmF0ZUluZm8gPSB7XG4gICAgZnJhbWVSYXRlOiAzMCxcbiAgICBzdWJGcmFtZVJhdGU6IDEsXG4gICAgZnJhbWVSYXRlTXVsdGlwbGllcjogMCxcbiAgICB0aWNrUmF0ZTogMFxuICB9O1xuICB2YXIgcmF0ZUluZm8gPSBPYmplY3Qua2V5cyhkZWZhdWx0UmF0ZUluZm8pLnJlZHVjZShmdW5jdGlvbiAocmVzdWx0LCBrZXkpIHtcbiAgICByZXN1bHRba2V5XSA9IHR0LmdldEF0dHJpYnV0ZShcInR0cDpcIiArIGtleSkgfHwgZGVmYXVsdFJhdGVJbmZvW2tleV07XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSwge30pO1xuICB2YXIgdHJpbSA9IHR0LmdldEF0dHJpYnV0ZSgneG1sOnNwYWNlJykgIT09ICdwcmVzZXJ2ZSc7XG4gIHZhciBzdHlsZUVsZW1lbnRzID0gY29sbGVjdGlvblRvRGljdGlvbmFyeShnZXRFbGVtZW50Q29sbGVjdGlvbih0dCwgJ3N0eWxpbmcnLCAnc3R5bGUnKSk7XG4gIHZhciByZWdpb25FbGVtZW50cyA9IGNvbGxlY3Rpb25Ub0RpY3Rpb25hcnkoZ2V0RWxlbWVudENvbGxlY3Rpb24odHQsICdsYXlvdXQnLCAncmVnaW9uJykpO1xuICB2YXIgY3VlRWxlbWVudHMgPSBnZXRFbGVtZW50Q29sbGVjdGlvbih0dCwgJ2JvZHknLCAnW2JlZ2luXScpO1xuICByZXR1cm4gW10ubWFwLmNhbGwoY3VlRWxlbWVudHMsIGZ1bmN0aW9uIChjdWVFbGVtZW50KSB7XG4gICAgdmFyIGN1ZVRleHQgPSBnZXRUZXh0Q29udGVudChjdWVFbGVtZW50LCB0cmltKTtcblxuICAgIGlmICghY3VlVGV4dCB8fCAhY3VlRWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2JlZ2luJykpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBzdGFydFRpbWUgPSBwYXJzZVR0bWxUaW1lKGN1ZUVsZW1lbnQuZ2V0QXR0cmlidXRlKCdiZWdpbicpLCByYXRlSW5mbyk7XG4gICAgdmFyIGR1cmF0aW9uID0gcGFyc2VUdG1sVGltZShjdWVFbGVtZW50LmdldEF0dHJpYnV0ZSgnZHVyJyksIHJhdGVJbmZvKTtcbiAgICB2YXIgZW5kVGltZSA9IHBhcnNlVHRtbFRpbWUoY3VlRWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2VuZCcpLCByYXRlSW5mbyk7XG5cbiAgICBpZiAoc3RhcnRUaW1lID09PSBudWxsKSB7XG4gICAgICB0aHJvdyB0aW1lc3RhbXBQYXJzaW5nRXJyb3IoY3VlRWxlbWVudCk7XG4gICAgfVxuXG4gICAgaWYgKGVuZFRpbWUgPT09IG51bGwpIHtcbiAgICAgIGlmIChkdXJhdGlvbiA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyB0aW1lc3RhbXBQYXJzaW5nRXJyb3IoY3VlRWxlbWVudCk7XG4gICAgICB9XG5cbiAgICAgIGVuZFRpbWUgPSBzdGFydFRpbWUgKyBkdXJhdGlvbjtcbiAgICB9XG5cbiAgICB2YXIgY3VlID0gbmV3IF92dHRjdWVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImRlZmF1bHRcIl0oc3RhcnRUaW1lIC0gc3luY1RpbWUsIGVuZFRpbWUgLSBzeW5jVGltZSwgY3VlVGV4dCk7XG4gICAgY3VlLmlkID0gT2JqZWN0KF93ZWJ2dHRfcGFyc2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXCJnZW5lcmF0ZUN1ZUlkXCJdKShjdWUuc3RhcnRUaW1lLCBjdWUuZW5kVGltZSwgY3VlLnRleHQpO1xuICAgIHZhciByZWdpb24gPSByZWdpb25FbGVtZW50c1tjdWVFbGVtZW50LmdldEF0dHJpYnV0ZSgncmVnaW9uJyldO1xuICAgIHZhciBzdHlsZSA9IHN0eWxlRWxlbWVudHNbY3VlRWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3N0eWxlJyldOyAvLyBUT0RPOiBBZGQgcmVnaW9ucyB0byB0cmFjayBhbmQgY3VlIChvcmlnaW4gYW5kIGV4dGVuZClcbiAgICAvLyBUaGVzZSB2YWx1ZXMgYXJlIGhhcmQtY29kZWQgKGZvciBub3cpIHRvIHNpbXVsYXRlIHJlZ2lvbiBzZXR0aW5ncyBpbiB0aGUgZGVtb1xuXG4gICAgY3VlLnBvc2l0aW9uID0gMTA7XG4gICAgY3VlLnNpemUgPSA4MDsgLy8gQXBwbHkgc3R5bGVzIHRvIGN1ZVxuXG4gICAgdmFyIHN0eWxlcyA9IGdldFR0bWxTdHlsZXMocmVnaW9uLCBzdHlsZSk7XG4gICAgdmFyIHRleHRBbGlnbiA9IHN0eWxlcy50ZXh0QWxpZ247XG5cbiAgICBpZiAodGV4dEFsaWduKSB7XG4gICAgICAvLyBjdWUucG9zaXRpb25BbGlnbiBub3Qgc2V0dGFibGUgaW4gRkZ+MjAxNlxuICAgICAgdmFyIGxpbmVBbGlnbiA9IHRleHRBbGlnblRvTGluZUFsaWduW3RleHRBbGlnbl07XG5cbiAgICAgIGlmIChsaW5lQWxpZ24pIHtcbiAgICAgICAgY3VlLmxpbmVBbGlnbiA9IGxpbmVBbGlnbjtcbiAgICAgIH1cblxuICAgICAgY3VlLmFsaWduID0gdGV4dEFsaWduO1xuICAgIH1cblxuICAgIF9leHRlbmRzKGN1ZSwgc3R5bGVzKTtcblxuICAgIHJldHVybiBjdWU7XG4gIH0pLmZpbHRlcihmdW5jdGlvbiAoY3VlKSB7XG4gICAgcmV0dXJuIGN1ZSAhPT0gbnVsbDtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldEVsZW1lbnRDb2xsZWN0aW9uKGZyb21FbGVtZW50LCBwYXJlbnROYW1lLCBjaGlsZE5hbWUpIHtcbiAgdmFyIHBhcmVudCA9IGZyb21FbGVtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKHBhcmVudE5hbWUpWzBdO1xuXG4gIGlmIChwYXJlbnQpIHtcbiAgICByZXR1cm4gW10uc2xpY2UuY2FsbChwYXJlbnQucXVlcnlTZWxlY3RvckFsbChjaGlsZE5hbWUpKTtcbiAgfVxuXG4gIHJldHVybiBbXTtcbn1cblxuZnVuY3Rpb24gY29sbGVjdGlvblRvRGljdGlvbmFyeShlbGVtZW50c1dpdGhJZCkge1xuICByZXR1cm4gZWxlbWVudHNXaXRoSWQucmVkdWNlKGZ1bmN0aW9uIChkaWN0LCBlbGVtZW50KSB7XG4gICAgdmFyIGlkID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3htbDppZCcpO1xuXG4gICAgaWYgKGlkKSB7XG4gICAgICBkaWN0W2lkXSA9IGVsZW1lbnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRpY3Q7XG4gIH0sIHt9KTtcbn1cblxuZnVuY3Rpb24gZ2V0VGV4dENvbnRlbnQoZWxlbWVudCwgdHJpbSkge1xuICByZXR1cm4gW10uc2xpY2UuY2FsbChlbGVtZW50LmNoaWxkTm9kZXMpLnJlZHVjZShmdW5jdGlvbiAoc3RyLCBub2RlLCBpKSB7XG4gICAgdmFyIF9ub2RlJGNoaWxkTm9kZXM7XG5cbiAgICBpZiAobm9kZS5ub2RlTmFtZSA9PT0gJ2JyJyAmJiBpKSB7XG4gICAgICByZXR1cm4gc3RyICsgJ1xcbic7XG4gICAgfVxuXG4gICAgaWYgKChfbm9kZSRjaGlsZE5vZGVzID0gbm9kZS5jaGlsZE5vZGVzKSAhPT0gbnVsbCAmJiBfbm9kZSRjaGlsZE5vZGVzICE9PSB2b2lkIDAgJiYgX25vZGUkY2hpbGROb2Rlcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBnZXRUZXh0Q29udGVudChub2RlLCB0cmltKTtcbiAgICB9IGVsc2UgaWYgKHRyaW0pIHtcbiAgICAgIHJldHVybiBzdHIgKyBub2RlLnRleHRDb250ZW50LnRyaW0oKS5yZXBsYWNlKC9cXHMrL2csICcgJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0ciArIG5vZGUudGV4dENvbnRlbnQ7XG4gIH0sICcnKTtcbn1cblxuZnVuY3Rpb24gZ2V0VHRtbFN0eWxlcyhyZWdpb24sIHN0eWxlKSB7XG4gIHZhciB0dHNOcyA9ICdodHRwOi8vd3d3LnczLm9yZy9ucy90dG1sI3N0eWxpbmcnO1xuICB2YXIgc3R5bGVBdHRyaWJ1dGVzID0gWydkaXNwbGF5QWxpZ24nLCAndGV4dEFsaWduJywgJ2NvbG9yJywgJ2JhY2tncm91bmRDb2xvcicsICdmb250U2l6ZScsICdmb250RmFtaWx5JyAvLyAnZm9udFdlaWdodCcsXG4gIC8vICdsaW5lSGVpZ2h0JyxcbiAgLy8gJ3dyYXBPcHRpb24nLFxuICAvLyAnZm9udFN0eWxlJyxcbiAgLy8gJ2RpcmVjdGlvbicsXG4gIC8vICd3cml0aW5nTW9kZSdcbiAgXTtcbiAgcmV0dXJuIHN0eWxlQXR0cmlidXRlcy5yZWR1Y2UoZnVuY3Rpb24gKHN0eWxlcywgbmFtZSkge1xuICAgIHZhciB2YWx1ZSA9IGdldEF0dHJpYnV0ZU5TKHN0eWxlLCB0dHNOcywgbmFtZSkgfHwgZ2V0QXR0cmlidXRlTlMocmVnaW9uLCB0dHNOcywgbmFtZSk7XG5cbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIHN0eWxlc1tuYW1lXSA9IHZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiBzdHlsZXM7XG4gIH0sIHt9KTtcbn1cblxuZnVuY3Rpb24gZ2V0QXR0cmlidXRlTlMoZWxlbWVudCwgbnMsIG5hbWUpIHtcbiAgcmV0dXJuIGVsZW1lbnQuaGFzQXR0cmlidXRlTlMobnMsIG5hbWUpID8gZWxlbWVudC5nZXRBdHRyaWJ1dGVOUyhucywgbmFtZSkgOiBudWxsO1xufVxuXG5mdW5jdGlvbiB0aW1lc3RhbXBQYXJzaW5nRXJyb3Iobm9kZSkge1xuICByZXR1cm4gbmV3IEVycm9yKFwiQ291bGQgbm90IHBhcnNlIHR0bWwgdGltZXN0YW1wIFwiICsgbm9kZSk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlVHRtbFRpbWUodGltZUF0dHJpYnV0ZVZhbHVlLCByYXRlSW5mbykge1xuICBpZiAoIXRpbWVBdHRyaWJ1dGVWYWx1ZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIHNlY29uZHMgPSBPYmplY3QoX3Z0dHBhcnNlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wicGFyc2VUaW1lU3RhbXBcIl0pKHRpbWVBdHRyaWJ1dGVWYWx1ZSk7XG5cbiAgaWYgKHNlY29uZHMgPT09IG51bGwpIHtcbiAgICBpZiAoSE1TRl9SRUdFWC50ZXN0KHRpbWVBdHRyaWJ1dGVWYWx1ZSkpIHtcbiAgICAgIHNlY29uZHMgPSBwYXJzZUhvdXJzTWludXRlc1NlY29uZHNGcmFtZXModGltZUF0dHJpYnV0ZVZhbHVlLCByYXRlSW5mbyk7XG4gICAgfSBlbHNlIGlmIChUSU1FX1VOSVRfUkVHRVgudGVzdCh0aW1lQXR0cmlidXRlVmFsdWUpKSB7XG4gICAgICBzZWNvbmRzID0gcGFyc2VUaW1lVW5pdHModGltZUF0dHJpYnV0ZVZhbHVlLCByYXRlSW5mbyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHNlY29uZHM7XG59XG5cbmZ1bmN0aW9uIHBhcnNlSG91cnNNaW51dGVzU2Vjb25kc0ZyYW1lcyh0aW1lQXR0cmlidXRlVmFsdWUsIHJhdGVJbmZvKSB7XG4gIHZhciBtID0gSE1TRl9SRUdFWC5leGVjKHRpbWVBdHRyaWJ1dGVWYWx1ZSk7XG4gIHZhciBmcmFtZXMgPSAobVs0XSB8IDApICsgKG1bNV0gfCAwKSAvIHJhdGVJbmZvLnN1YkZyYW1lUmF0ZTtcbiAgcmV0dXJuIChtWzFdIHwgMCkgKiAzNjAwICsgKG1bMl0gfCAwKSAqIDYwICsgKG1bM10gfCAwKSArIGZyYW1lcyAvIHJhdGVJbmZvLmZyYW1lUmF0ZTtcbn1cblxuZnVuY3Rpb24gcGFyc2VUaW1lVW5pdHModGltZUF0dHJpYnV0ZVZhbHVlLCByYXRlSW5mbykge1xuICB2YXIgbSA9IFRJTUVfVU5JVF9SRUdFWC5leGVjKHRpbWVBdHRyaWJ1dGVWYWx1ZSk7XG4gIHZhciB2YWx1ZSA9IE51bWJlcihtWzFdKTtcbiAgdmFyIHVuaXQgPSBtWzJdO1xuXG4gIHN3aXRjaCAodW5pdCkge1xuICAgIGNhc2UgJ2gnOlxuICAgICAgcmV0dXJuIHZhbHVlICogMzYwMDtcblxuICAgIGNhc2UgJ20nOlxuICAgICAgcmV0dXJuIHZhbHVlICogNjA7XG5cbiAgICBjYXNlICdtcyc6XG4gICAgICByZXR1cm4gdmFsdWUgKiAxMDAwO1xuXG4gICAgY2FzZSAnZic6XG4gICAgICByZXR1cm4gdmFsdWUgLyByYXRlSW5mby5mcmFtZVJhdGU7XG5cbiAgICBjYXNlICd0JzpcbiAgICAgIHJldHVybiB2YWx1ZSAvIHJhdGVJbmZvLnRpY2tSYXRlO1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy91dGlscy9sb2dnZXIudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3V0aWxzL2xvZ2dlci50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZW5hYmxlTG9ncywgbG9nZ2VyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImVuYWJsZUxvZ3NcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBlbmFibGVMb2dzOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJsb2dnZXJcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBsb2dnZXI7IH0pO1xudmFyIG5vb3AgPSBmdW5jdGlvbiBub29wKCkge307XG5cbnZhciBmYWtlTG9nZ2VyID0ge1xuICB0cmFjZTogbm9vcCxcbiAgZGVidWc6IG5vb3AsXG4gIGxvZzogbm9vcCxcbiAgd2Fybjogbm9vcCxcbiAgaW5mbzogbm9vcCxcbiAgZXJyb3I6IG5vb3Bcbn07XG52YXIgZXhwb3J0ZWRMb2dnZXIgPSBmYWtlTG9nZ2VyOyAvLyBsZXQgbGFzdENhbGxUaW1lO1xuLy8gZnVuY3Rpb24gZm9ybWF0TXNnV2l0aFRpbWVJbmZvKHR5cGUsIG1zZykge1xuLy8gICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuLy8gICBjb25zdCBkaWZmID0gbGFzdENhbGxUaW1lID8gJysnICsgKG5vdyAtIGxhc3RDYWxsVGltZSkgOiAnMCc7XG4vLyAgIGxhc3RDYWxsVGltZSA9IG5vdztcbi8vICAgbXNnID0gKG5ldyBEYXRlKG5vdykpLnRvSVNPU3RyaW5nKCkgKyAnIHwgWycgKyAgdHlwZSArICddID4gJyArIG1zZyArICcgKCAnICsgZGlmZiArICcgbXMgKSc7XG4vLyAgIHJldHVybiBtc2c7XG4vLyB9XG5cbmZ1bmN0aW9uIGNvbnNvbGVQcmludEZuKHR5cGUpIHtcbiAgdmFyIGZ1bmMgPSBzZWxmLmNvbnNvbGVbdHlwZV07XG5cbiAgaWYgKGZ1bmMpIHtcbiAgICByZXR1cm4gZnVuYy5iaW5kKHNlbGYuY29uc29sZSwgXCJbXCIgKyB0eXBlICsgXCJdID5cIik7XG4gIH1cblxuICByZXR1cm4gbm9vcDtcbn1cblxuZnVuY3Rpb24gZXhwb3J0TG9nZ2VyRnVuY3Rpb25zKGRlYnVnQ29uZmlnKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBmdW5jdGlvbnMgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGZ1bmN0aW9uc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICBmdW5jdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgIGV4cG9ydGVkTG9nZ2VyW3R5cGVdID0gZGVidWdDb25maWdbdHlwZV0gPyBkZWJ1Z0NvbmZpZ1t0eXBlXS5iaW5kKGRlYnVnQ29uZmlnKSA6IGNvbnNvbGVQcmludEZuKHR5cGUpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZW5hYmxlTG9ncyhkZWJ1Z0NvbmZpZykge1xuICAvLyBjaGVjayB0aGF0IGNvbnNvbGUgaXMgYXZhaWxhYmxlXG4gIGlmIChzZWxmLmNvbnNvbGUgJiYgZGVidWdDb25maWcgPT09IHRydWUgfHwgdHlwZW9mIGRlYnVnQ29uZmlnID09PSAnb2JqZWN0Jykge1xuICAgIGV4cG9ydExvZ2dlckZ1bmN0aW9ucyhkZWJ1Z0NvbmZpZywgLy8gUmVtb3ZlIG91dCBmcm9tIGxpc3QgaGVyZSB0byBoYXJkLWRpc2FibGUgYSBsb2ctbGV2ZWxcbiAgICAvLyAndHJhY2UnLFxuICAgICdkZWJ1ZycsICdsb2cnLCAnaW5mbycsICd3YXJuJywgJ2Vycm9yJyk7IC8vIFNvbWUgYnJvd3NlcnMgZG9uJ3QgYWxsb3cgdG8gdXNlIGJpbmQgb24gY29uc29sZSBvYmplY3QgYW55d2F5XG4gICAgLy8gZmFsbGJhY2sgdG8gZGVmYXVsdCBpZiBuZWVkZWRcblxuICAgIHRyeSB7XG4gICAgICBleHBvcnRlZExvZ2dlci5sb2coKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBleHBvcnRlZExvZ2dlciA9IGZha2VMb2dnZXI7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGV4cG9ydGVkTG9nZ2VyID0gZmFrZUxvZ2dlcjtcbiAgfVxufVxudmFyIGxvZ2dlciA9IGV4cG9ydGVkTG9nZ2VyO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy91dGlscy9tZWRpYWtleXMtaGVscGVyLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvdXRpbHMvbWVkaWFrZXlzLWhlbHBlci50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IEtleVN5c3RlbXMsIHJlcXVlc3RNZWRpYUtleVN5c3RlbUFjY2VzcyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJLZXlTeXN0ZW1zXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gS2V5U3lzdGVtczsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwicmVxdWVzdE1lZGlhS2V5U3lzdGVtQWNjZXNzXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gcmVxdWVzdE1lZGlhS2V5U3lzdGVtQWNjZXNzOyB9KTtcbi8qKlxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTmF2aWdhdG9yL3JlcXVlc3RNZWRpYUtleVN5c3RlbUFjY2Vzc1xuICovXG52YXIgS2V5U3lzdGVtcztcblxuKGZ1bmN0aW9uIChLZXlTeXN0ZW1zKSB7XG4gIEtleVN5c3RlbXNbXCJXSURFVklORVwiXSA9IFwiY29tLndpZGV2aW5lLmFscGhhXCI7XG4gIEtleVN5c3RlbXNbXCJQTEFZUkVBRFlcIl0gPSBcImNvbS5taWNyb3NvZnQucGxheXJlYWR5XCI7XG59KShLZXlTeXN0ZW1zIHx8IChLZXlTeXN0ZW1zID0ge30pKTtcblxudmFyIHJlcXVlc3RNZWRpYUtleVN5c3RlbUFjY2VzcyA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyAmJiBzZWxmLm5hdmlnYXRvciAmJiBzZWxmLm5hdmlnYXRvci5yZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3MpIHtcbiAgICByZXR1cm4gc2VsZi5uYXZpZ2F0b3IucmVxdWVzdE1lZGlhS2V5U3lzdGVtQWNjZXNzLmJpbmQoc2VsZi5uYXZpZ2F0b3IpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59KCk7XG5cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy91dGlscy9tZWRpYXNvdXJjZS1oZWxwZXIudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3V0aWxzL21lZGlhc291cmNlLWhlbHBlci50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZ2V0TWVkaWFTb3VyY2UgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZ2V0TWVkaWFTb3VyY2VcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBnZXRNZWRpYVNvdXJjZTsgfSk7XG4vKipcbiAqIE1lZGlhU291cmNlIGhlbHBlclxuICovXG5mdW5jdGlvbiBnZXRNZWRpYVNvdXJjZSgpIHtcbiAgcmV0dXJuIHNlbGYuTWVkaWFTb3VyY2UgfHwgc2VsZi5XZWJLaXRNZWRpYVNvdXJjZTtcbn1cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvdXRpbHMvbXA0LXRvb2xzLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy91dGlscy9tcDQtdG9vbHMudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGJpbjJzdHIsIHJlYWRVaW50MTYsIHJlYWRVaW50MzIsIHdyaXRlVWludDMyLCBmaW5kQm94LCBwYXJzZVNlZ21lbnRJbmRleCwgcGFyc2VJbml0U2VnbWVudCwgZ2V0U3RhcnREVFMsIGdldER1cmF0aW9uLCBjb21wdXRlUmF3RHVyYXRpb25Gcm9tU2FtcGxlcywgb2Zmc2V0U3RhcnREVFMsIHNlZ21lbnRWYWxpZFJhbmdlLCBhcHBlbmRVaW50OEFycmF5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImJpbjJzdHJcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBiaW4yc3RyOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJyZWFkVWludDE2XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gcmVhZFVpbnQxNjsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwicmVhZFVpbnQzMlwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHJlYWRVaW50MzI7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIndyaXRlVWludDMyXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gd3JpdGVVaW50MzI7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImZpbmRCb3hcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBmaW5kQm94OyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJwYXJzZVNlZ21lbnRJbmRleFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHBhcnNlU2VnbWVudEluZGV4OyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJwYXJzZUluaXRTZWdtZW50XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gcGFyc2VJbml0U2VnbWVudDsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZ2V0U3RhcnREVFNcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBnZXRTdGFydERUUzsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZ2V0RHVyYXRpb25cIiwgZnVuY3Rpb24oKSB7IHJldHVybiBnZXREdXJhdGlvbjsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiY29tcHV0ZVJhd0R1cmF0aW9uRnJvbVNhbXBsZXNcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBjb21wdXRlUmF3RHVyYXRpb25Gcm9tU2FtcGxlczsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwib2Zmc2V0U3RhcnREVFNcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBvZmZzZXRTdGFydERUUzsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwic2VnbWVudFZhbGlkUmFuZ2VcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBzZWdtZW50VmFsaWRSYW5nZTsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiYXBwZW5kVWludDhBcnJheVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGFwcGVuZFVpbnQ4QXJyYXk7IH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF90eXBlZF9hcnJheV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi90eXBlZC1hcnJheSAqLyBcIi4vc3JjL3V0aWxzL3R5cGVkLWFycmF5LnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9sb2FkZXJfZnJhZ21lbnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2xvYWRlci9mcmFnbWVudCAqLyBcIi4vc3JjL2xvYWRlci9mcmFnbWVudC50c1wiKTtcblxuXG52YXIgVUlOVDMyX01BWCA9IE1hdGgucG93KDIsIDMyKSAtIDE7XG52YXIgcHVzaCA9IFtdLnB1c2g7XG5mdW5jdGlvbiBiaW4yc3RyKGRhdGEpIHtcbiAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgZGF0YSk7XG59XG5mdW5jdGlvbiByZWFkVWludDE2KGJ1ZmZlciwgb2Zmc2V0KSB7XG4gIGlmICgnZGF0YScgaW4gYnVmZmVyKSB7XG4gICAgb2Zmc2V0ICs9IGJ1ZmZlci5zdGFydDtcbiAgICBidWZmZXIgPSBidWZmZXIuZGF0YTtcbiAgfVxuXG4gIHZhciB2YWwgPSBidWZmZXJbb2Zmc2V0XSA8PCA4IHwgYnVmZmVyW29mZnNldCArIDFdO1xuICByZXR1cm4gdmFsIDwgMCA/IDY1NTM2ICsgdmFsIDogdmFsO1xufVxuZnVuY3Rpb24gcmVhZFVpbnQzMihidWZmZXIsIG9mZnNldCkge1xuICBpZiAoJ2RhdGEnIGluIGJ1ZmZlcikge1xuICAgIG9mZnNldCArPSBidWZmZXIuc3RhcnQ7XG4gICAgYnVmZmVyID0gYnVmZmVyLmRhdGE7XG4gIH1cblxuICB2YXIgdmFsID0gYnVmZmVyW29mZnNldF0gPDwgMjQgfCBidWZmZXJbb2Zmc2V0ICsgMV0gPDwgMTYgfCBidWZmZXJbb2Zmc2V0ICsgMl0gPDwgOCB8IGJ1ZmZlcltvZmZzZXQgKyAzXTtcbiAgcmV0dXJuIHZhbCA8IDAgPyA0Mjk0OTY3Mjk2ICsgdmFsIDogdmFsO1xufVxuZnVuY3Rpb24gd3JpdGVVaW50MzIoYnVmZmVyLCBvZmZzZXQsIHZhbHVlKSB7XG4gIGlmICgnZGF0YScgaW4gYnVmZmVyKSB7XG4gICAgb2Zmc2V0ICs9IGJ1ZmZlci5zdGFydDtcbiAgICBidWZmZXIgPSBidWZmZXIuZGF0YTtcbiAgfVxuXG4gIGJ1ZmZlcltvZmZzZXRdID0gdmFsdWUgPj4gMjQ7XG4gIGJ1ZmZlcltvZmZzZXQgKyAxXSA9IHZhbHVlID4+IDE2ICYgMHhmZjtcbiAgYnVmZmVyW29mZnNldCArIDJdID0gdmFsdWUgPj4gOCAmIDB4ZmY7XG4gIGJ1ZmZlcltvZmZzZXQgKyAzXSA9IHZhbHVlICYgMHhmZjtcbn0gLy8gRmluZCB0aGUgZGF0YSBmb3IgYSBib3ggc3BlY2lmaWVkIGJ5IGl0cyBwYXRoXG5cbmZ1bmN0aW9uIGZpbmRCb3goaW5wdXQsIHBhdGgpIHtcbiAgdmFyIHJlc3VsdHMgPSBbXTtcblxuICBpZiAoIXBhdGgubGVuZ3RoKSB7XG4gICAgLy8gc2hvcnQtY2lyY3VpdCB0aGUgc2VhcmNoIGZvciBlbXB0eSBwYXRoc1xuICAgIHJldHVybiByZXN1bHRzO1xuICB9XG5cbiAgdmFyIGRhdGE7XG4gIHZhciBzdGFydDtcbiAgdmFyIGVuZDtcblxuICBpZiAoJ2RhdGEnIGluIGlucHV0KSB7XG4gICAgZGF0YSA9IGlucHV0LmRhdGE7XG4gICAgc3RhcnQgPSBpbnB1dC5zdGFydDtcbiAgICBlbmQgPSBpbnB1dC5lbmQ7XG4gIH0gZWxzZSB7XG4gICAgZGF0YSA9IGlucHV0O1xuICAgIHN0YXJ0ID0gMDtcbiAgICBlbmQgPSBkYXRhLmJ5dGVMZW5ndGg7XG4gIH1cblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7KSB7XG4gICAgdmFyIHNpemUgPSByZWFkVWludDMyKGRhdGEsIGkpO1xuICAgIHZhciB0eXBlID0gYmluMnN0cihkYXRhLnN1YmFycmF5KGkgKyA0LCBpICsgOCkpO1xuICAgIHZhciBlbmRib3ggPSBzaXplID4gMSA/IGkgKyBzaXplIDogZW5kO1xuXG4gICAgaWYgKHR5cGUgPT09IHBhdGhbMF0pIHtcbiAgICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAvLyB0aGlzIGlzIHRoZSBlbmQgb2YgdGhlIHBhdGggYW5kIHdlJ3ZlIGZvdW5kIHRoZSBib3ggd2Ugd2VyZVxuICAgICAgICAvLyBsb29raW5nIGZvclxuICAgICAgICByZXN1bHRzLnB1c2goe1xuICAgICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgICAgc3RhcnQ6IGkgKyA4LFxuICAgICAgICAgIGVuZDogZW5kYm94XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gcmVjdXJzaXZlbHkgc2VhcmNoIGZvciB0aGUgbmV4dCBib3ggYWxvbmcgdGhlIHBhdGhcbiAgICAgICAgdmFyIHN1YnJlc3VsdHMgPSBmaW5kQm94KHtcbiAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICAgIHN0YXJ0OiBpICsgOCxcbiAgICAgICAgICBlbmQ6IGVuZGJveFxuICAgICAgICB9LCBwYXRoLnNsaWNlKDEpKTtcblxuICAgICAgICBpZiAoc3VicmVzdWx0cy5sZW5ndGgpIHtcbiAgICAgICAgICBwdXNoLmFwcGx5KHJlc3VsdHMsIHN1YnJlc3VsdHMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaSA9IGVuZGJveDtcbiAgfSAvLyB3ZSd2ZSBmaW5pc2hlZCBzZWFyY2hpbmcgYWxsIG9mIGRhdGFcblxuXG4gIHJldHVybiByZXN1bHRzO1xufVxuZnVuY3Rpb24gcGFyc2VTZWdtZW50SW5kZXgoaW5pdFNlZ21lbnQpIHtcbiAgdmFyIG1vb3ZCb3ggPSBmaW5kQm94KGluaXRTZWdtZW50LCBbJ21vb3YnXSk7XG4gIHZhciBtb292ID0gbW9vdkJveFswXTtcbiAgdmFyIG1vb3ZFbmRPZmZzZXQgPSBtb292ID8gbW9vdi5lbmQgOiBudWxsOyAvLyB3ZSBuZWVkIHRoaXMgaW4gY2FzZSB3ZSBuZWVkIHRvIGNob3Agb2YgZ2FyYmFnZSBvZiB0aGUgZW5kIG9mIGN1cnJlbnQgZGF0YVxuXG4gIHZhciBzaWR4Qm94ID0gZmluZEJveChpbml0U2VnbWVudCwgWydzaWR4J10pO1xuXG4gIGlmICghc2lkeEJveCB8fCAhc2lkeEJveFswXSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIHJlZmVyZW5jZXMgPSBbXTtcbiAgdmFyIHNpZHggPSBzaWR4Qm94WzBdO1xuICB2YXIgdmVyc2lvbiA9IHNpZHguZGF0YVswXTsgLy8gc2V0IGluaXRpYWwgb2Zmc2V0LCB3ZSBza2lwIHRoZSByZWZlcmVuY2UgSUQgKG5vdCBuZWVkZWQpXG5cbiAgdmFyIGluZGV4ID0gdmVyc2lvbiA9PT0gMCA/IDggOiAxNjtcbiAgdmFyIHRpbWVzY2FsZSA9IHJlYWRVaW50MzIoc2lkeCwgaW5kZXgpO1xuICBpbmRleCArPSA0OyAvLyBUT0RPOiBwYXJzZSBlYXJsaWVzdFByZXNlbnRhdGlvblRpbWUgYW5kIGZpcnN0T2Zmc2V0XG4gIC8vIHVzdWFsbHkgemVybyBpbiBvdXIgY2FzZVxuXG4gIHZhciBlYXJsaWVzdFByZXNlbnRhdGlvblRpbWUgPSAwO1xuICB2YXIgZmlyc3RPZmZzZXQgPSAwO1xuXG4gIGlmICh2ZXJzaW9uID09PSAwKSB7XG4gICAgaW5kZXggKz0gODtcbiAgfSBlbHNlIHtcbiAgICBpbmRleCArPSAxNjtcbiAgfSAvLyBza2lwIHJlc2VydmVkXG5cblxuICBpbmRleCArPSAyO1xuICB2YXIgc3RhcnRCeXRlID0gc2lkeC5lbmQgKyBmaXJzdE9mZnNldDtcbiAgdmFyIHJlZmVyZW5jZXNDb3VudCA9IHJlYWRVaW50MTYoc2lkeCwgaW5kZXgpO1xuICBpbmRleCArPSAyO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcmVmZXJlbmNlc0NvdW50OyBpKyspIHtcbiAgICB2YXIgcmVmZXJlbmNlSW5kZXggPSBpbmRleDtcbiAgICB2YXIgcmVmZXJlbmNlSW5mbyA9IHJlYWRVaW50MzIoc2lkeCwgcmVmZXJlbmNlSW5kZXgpO1xuICAgIHJlZmVyZW5jZUluZGV4ICs9IDQ7XG4gICAgdmFyIHJlZmVyZW5jZVNpemUgPSByZWZlcmVuY2VJbmZvICYgMHg3ZmZmZmZmZjtcbiAgICB2YXIgcmVmZXJlbmNlVHlwZSA9IChyZWZlcmVuY2VJbmZvICYgMHg4MDAwMDAwMCkgPj4+IDMxO1xuXG4gICAgaWYgKHJlZmVyZW5jZVR5cGUgPT09IDEpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICBjb25zb2xlLndhcm4oJ1NJRFggaGFzIGhpZXJhcmNoaWNhbCByZWZlcmVuY2VzIChub3Qgc3VwcG9ydGVkKScpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIHN1YnNlZ21lbnREdXJhdGlvbiA9IHJlYWRVaW50MzIoc2lkeCwgcmVmZXJlbmNlSW5kZXgpO1xuICAgIHJlZmVyZW5jZUluZGV4ICs9IDQ7XG4gICAgcmVmZXJlbmNlcy5wdXNoKHtcbiAgICAgIHJlZmVyZW5jZVNpemU6IHJlZmVyZW5jZVNpemUsXG4gICAgICBzdWJzZWdtZW50RHVyYXRpb246IHN1YnNlZ21lbnREdXJhdGlvbixcbiAgICAgIC8vIHVuc2NhbGVkXG4gICAgICBpbmZvOiB7XG4gICAgICAgIGR1cmF0aW9uOiBzdWJzZWdtZW50RHVyYXRpb24gLyB0aW1lc2NhbGUsXG4gICAgICAgIHN0YXJ0OiBzdGFydEJ5dGUsXG4gICAgICAgIGVuZDogc3RhcnRCeXRlICsgcmVmZXJlbmNlU2l6ZSAtIDFcbiAgICAgIH1cbiAgICB9KTtcbiAgICBzdGFydEJ5dGUgKz0gcmVmZXJlbmNlU2l6ZTsgLy8gU2tpcHBpbmcgMSBiaXQgZm9yIHxzdGFydHNXaXRoU2FwfCwgMyBiaXRzIGZvciB8c2FwVHlwZXwsIGFuZCAyOCBiaXRzXG4gICAgLy8gZm9yIHxzYXBEZWx0YXwuXG5cbiAgICByZWZlcmVuY2VJbmRleCArPSA0OyAvLyBza2lwIHRvIG5leHQgcmVmXG5cbiAgICBpbmRleCA9IHJlZmVyZW5jZUluZGV4O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBlYXJsaWVzdFByZXNlbnRhdGlvblRpbWU6IGVhcmxpZXN0UHJlc2VudGF0aW9uVGltZSxcbiAgICB0aW1lc2NhbGU6IHRpbWVzY2FsZSxcbiAgICB2ZXJzaW9uOiB2ZXJzaW9uLFxuICAgIHJlZmVyZW5jZXNDb3VudDogcmVmZXJlbmNlc0NvdW50LFxuICAgIHJlZmVyZW5jZXM6IHJlZmVyZW5jZXMsXG4gICAgbW9vdkVuZE9mZnNldDogbW9vdkVuZE9mZnNldFxuICB9O1xufVxuLyoqXG4gKiBQYXJzZXMgYW4gTVA0IGluaXRpYWxpemF0aW9uIHNlZ21lbnQgYW5kIGV4dHJhY3RzIHN0cmVhbSB0eXBlIGFuZFxuICogdGltZXNjYWxlIHZhbHVlcyBmb3IgYW55IGRlY2xhcmVkIHRyYWNrcy4gVGltZXNjYWxlIHZhbHVlcyBpbmRpY2F0ZSB0aGVcbiAqIG51bWJlciBvZiBjbG9jayB0aWNrcyBwZXIgc2Vjb25kIHRvIGFzc3VtZSBmb3IgdGltZS1iYXNlZCB2YWx1ZXNcbiAqIGVsc2V3aGVyZSBpbiB0aGUgTVA0LlxuICpcbiAqIFRvIGRldGVybWluZSB0aGUgc3RhcnQgdGltZSBvZiBhbiBNUDQsIHlvdSBuZWVkIHR3byBwaWVjZXMgb2ZcbiAqIGluZm9ybWF0aW9uOiB0aGUgdGltZXNjYWxlIHVuaXQgYW5kIHRoZSBlYXJsaWVzdCBiYXNlIG1lZGlhIGRlY29kZVxuICogdGltZS4gTXVsdGlwbGUgdGltZXNjYWxlcyBjYW4gYmUgc3BlY2lmaWVkIHdpdGhpbiBhbiBNUDQgYnV0IHRoZVxuICogYmFzZSBtZWRpYSBkZWNvZGUgdGltZSBpcyBhbHdheXMgZXhwcmVzc2VkIGluIHRoZSB0aW1lc2NhbGUgZnJvbVxuICogdGhlIG1lZGlhIGhlYWRlciBib3ggZm9yIHRoZSB0cmFjazpcbiAqIGBgYFxuICogbW9vdiA+IHRyYWsgPiBtZGlhID4gbWRoZC50aW1lc2NhbGVcbiAqIG1vb3YgPiB0cmFrID4gbWRpYSA+IGhkbHJcbiAqIGBgYFxuICogQHBhcmFtIGluaXRTZWdtZW50IHtVaW50OEFycmF5fSB0aGUgYnl0ZXMgb2YgdGhlIGluaXQgc2VnbWVudFxuICogQHJldHVybiB7SW5pdERhdGF9IGEgaGFzaCBvZiB0cmFjayB0eXBlIHRvIHRpbWVzY2FsZSB2YWx1ZXMgb3IgbnVsbCBpZlxuICogdGhlIGluaXQgc2VnbWVudCBpcyBtYWxmb3JtZWQuXG4gKi9cblxuZnVuY3Rpb24gcGFyc2VJbml0U2VnbWVudChpbml0U2VnbWVudCkge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHZhciB0cmFrcyA9IGZpbmRCb3goaW5pdFNlZ21lbnQsIFsnbW9vdicsICd0cmFrJ10pO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdHJha3MubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdHJhayA9IHRyYWtzW2ldO1xuICAgIHZhciB0a2hkID0gZmluZEJveCh0cmFrLCBbJ3RraGQnXSlbMF07XG5cbiAgICBpZiAodGtoZCkge1xuICAgICAgdmFyIHZlcnNpb24gPSB0a2hkLmRhdGFbdGtoZC5zdGFydF07XG5cbiAgICAgIHZhciBfaW5kZXggPSB2ZXJzaW9uID09PSAwID8gMTIgOiAyMDtcblxuICAgICAgdmFyIHRyYWNrSWQgPSByZWFkVWludDMyKHRraGQsIF9pbmRleCk7XG4gICAgICB2YXIgbWRoZCA9IGZpbmRCb3godHJhaywgWydtZGlhJywgJ21kaGQnXSlbMF07XG5cbiAgICAgIGlmIChtZGhkKSB7XG4gICAgICAgIHZlcnNpb24gPSBtZGhkLmRhdGFbbWRoZC5zdGFydF07XG4gICAgICAgIF9pbmRleCA9IHZlcnNpb24gPT09IDAgPyAxMiA6IDIwO1xuICAgICAgICB2YXIgdGltZXNjYWxlID0gcmVhZFVpbnQzMihtZGhkLCBfaW5kZXgpO1xuICAgICAgICB2YXIgaGRsciA9IGZpbmRCb3godHJhaywgWydtZGlhJywgJ2hkbHInXSlbMF07XG5cbiAgICAgICAgaWYgKGhkbHIpIHtcbiAgICAgICAgICB2YXIgaGRsclR5cGUgPSBiaW4yc3RyKGhkbHIuZGF0YS5zdWJhcnJheShoZGxyLnN0YXJ0ICsgOCwgaGRsci5zdGFydCArIDEyKSk7XG4gICAgICAgICAgdmFyIHR5cGUgPSB7XG4gICAgICAgICAgICBzb3VuOiBfbG9hZGVyX2ZyYWdtZW50X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFbGVtZW50YXJ5U3RyZWFtVHlwZXNcIl0uQVVESU8sXG4gICAgICAgICAgICB2aWRlOiBfbG9hZGVyX2ZyYWdtZW50X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFbGVtZW50YXJ5U3RyZWFtVHlwZXNcIl0uVklERU9cbiAgICAgICAgICB9W2hkbHJUeXBlXTtcblxuICAgICAgICAgIGlmICh0eXBlKSB7XG4gICAgICAgICAgICAvLyBQYXJzZSBjb2RlYyBkZXRhaWxzXG4gICAgICAgICAgICB2YXIgc3RzZCA9IGZpbmRCb3godHJhaywgWydtZGlhJywgJ21pbmYnLCAnc3RibCcsICdzdHNkJ10pWzBdO1xuICAgICAgICAgICAgdmFyIGNvZGVjID0gdm9pZCAwO1xuXG4gICAgICAgICAgICBpZiAoc3RzZCkge1xuICAgICAgICAgICAgICBjb2RlYyA9IGJpbjJzdHIoc3RzZC5kYXRhLnN1YmFycmF5KHN0c2Quc3RhcnQgKyAxMiwgc3RzZC5zdGFydCArIDE2KSk7IC8vIFRPRE86IFBhcnNlIGNvZGVjIGRldGFpbHMgdG8gYmUgYWJsZSB0byBidWlsZCBNSU1FIHR5cGUuXG4gICAgICAgICAgICAgIC8vIHN0c2Quc3RhcnQgKz0gODtcbiAgICAgICAgICAgICAgLy8gY29uc3QgY29kZWNCb3ggPSBmaW5kQm94KHN0c2QsIFtjb2RlY10pWzBdO1xuICAgICAgICAgICAgICAvLyBpZiAoY29kZWNCb3gpIHtcbiAgICAgICAgICAgICAgLy8gICBUT0RPOiBDb2RlYyBwYXJzaW5nIHN1cHBvcnQgZm9yIGF2YzEsIG1wNGEsIGhldmMsIGF2MDEuLi5cbiAgICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXN1bHRbdHJhY2tJZF0gPSB7XG4gICAgICAgICAgICAgIHRpbWVzY2FsZTogdGltZXNjYWxlLFxuICAgICAgICAgICAgICB0eXBlOiB0eXBlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmVzdWx0W3R5cGVdID0ge1xuICAgICAgICAgICAgICB0aW1lc2NhbGU6IHRpbWVzY2FsZSxcbiAgICAgICAgICAgICAgaWQ6IHRyYWNrSWQsXG4gICAgICAgICAgICAgIGNvZGVjOiBjb2RlY1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgdHJleCA9IGZpbmRCb3goaW5pdFNlZ21lbnQsIFsnbW9vdicsICdtdmV4JywgJ3RyZXgnXSk7XG4gIHRyZXguZm9yRWFjaChmdW5jdGlvbiAodHJleCkge1xuICAgIHZhciB0cmFja0lkID0gcmVhZFVpbnQzMih0cmV4LCA0KTtcbiAgICB2YXIgdHJhY2sgPSByZXN1bHRbdHJhY2tJZF07XG5cbiAgICBpZiAodHJhY2spIHtcbiAgICAgIHRyYWNrLmRlZmF1bHQgPSB7XG4gICAgICAgIGR1cmF0aW9uOiByZWFkVWludDMyKHRyZXgsIDEyKSxcbiAgICAgICAgZmxhZ3M6IHJlYWRVaW50MzIodHJleCwgMjApXG4gICAgICB9O1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIERldGVybWluZSB0aGUgYmFzZSBtZWRpYSBkZWNvZGUgc3RhcnQgdGltZSwgaW4gc2Vjb25kcywgZm9yIGFuIE1QNFxuICogZnJhZ21lbnQuIElmIG11bHRpcGxlIGZyYWdtZW50cyBhcmUgc3BlY2lmaWVkLCB0aGUgZWFybGllc3QgdGltZSBpc1xuICogcmV0dXJuZWQuXG4gKlxuICogVGhlIGJhc2UgbWVkaWEgZGVjb2RlIHRpbWUgY2FuIGJlIHBhcnNlZCBmcm9tIHRyYWNrIGZyYWdtZW50XG4gKiBtZXRhZGF0YTpcbiAqIGBgYFxuICogbW9vZiA+IHRyYWYgPiB0ZmR0LmJhc2VNZWRpYURlY29kZVRpbWVcbiAqIGBgYFxuICogSXQgcmVxdWlyZXMgdGhlIHRpbWVzY2FsZSB2YWx1ZSBmcm9tIHRoZSBtZGhkIHRvIGludGVycHJldC5cbiAqXG4gKiBAcGFyYW0gaW5pdERhdGEge0luaXREYXRhfSBhIGhhc2ggb2YgdHJhY2sgdHlwZSB0byB0aW1lc2NhbGUgdmFsdWVzXG4gKiBAcGFyYW0gZm1wNCB7VWludDhBcnJheX0gdGhlIGJ5dGVzIG9mIHRoZSBtcDQgZnJhZ21lbnRcbiAqIEByZXR1cm4ge251bWJlcn0gdGhlIGVhcmxpZXN0IGJhc2UgbWVkaWEgZGVjb2RlIHN0YXJ0IHRpbWUgZm9yIHRoZVxuICogZnJhZ21lbnQsIGluIHNlY29uZHNcbiAqL1xuXG5mdW5jdGlvbiBnZXRTdGFydERUUyhpbml0RGF0YSwgZm1wNCkge1xuICAvLyB3ZSBuZWVkIGluZm8gZnJvbSB0d28gY2hpbGRyZW4gb2YgZWFjaCB0cmFjayBmcmFnbWVudCBib3hcbiAgcmV0dXJuIGZpbmRCb3goZm1wNCwgWydtb29mJywgJ3RyYWYnXSkucmVkdWNlKGZ1bmN0aW9uIChyZXN1bHQsIHRyYWYpIHtcbiAgICB2YXIgdGZkdCA9IGZpbmRCb3godHJhZiwgWyd0ZmR0J10pWzBdO1xuICAgIHZhciB2ZXJzaW9uID0gdGZkdC5kYXRhW3RmZHQuc3RhcnRdO1xuICAgIHZhciBzdGFydCA9IGZpbmRCb3godHJhZiwgWyd0ZmhkJ10pLnJlZHVjZShmdW5jdGlvbiAocmVzdWx0LCB0ZmhkKSB7XG4gICAgICAvLyBnZXQgdGhlIHRyYWNrIGlkIGZyb20gdGhlIHRmaGRcbiAgICAgIHZhciBpZCA9IHJlYWRVaW50MzIodGZoZCwgNCk7XG4gICAgICB2YXIgdHJhY2sgPSBpbml0RGF0YVtpZF07XG5cbiAgICAgIGlmICh0cmFjaykge1xuICAgICAgICB2YXIgYmFzZVRpbWUgPSByZWFkVWludDMyKHRmZHQsIDQpO1xuXG4gICAgICAgIGlmICh2ZXJzaW9uID09PSAxKSB7XG4gICAgICAgICAgYmFzZVRpbWUgKj0gTWF0aC5wb3coMiwgMzIpO1xuICAgICAgICAgIGJhc2VUaW1lICs9IHJlYWRVaW50MzIodGZkdCwgOCk7XG4gICAgICAgIH0gLy8gYXNzdW1lIGEgOTBrSHogY2xvY2sgaWYgbm8gdGltZXNjYWxlIHdhcyBzcGVjaWZpZWRcblxuXG4gICAgICAgIHZhciBzY2FsZSA9IHRyYWNrLnRpbWVzY2FsZSB8fCA5MGUzOyAvLyBjb252ZXJ0IGJhc2UgdGltZSB0byBzZWNvbmRzXG5cbiAgICAgICAgdmFyIHN0YXJ0VGltZSA9IGJhc2VUaW1lIC8gc2NhbGU7XG5cbiAgICAgICAgaWYgKGlzRmluaXRlKHN0YXJ0VGltZSkgJiYgKHJlc3VsdCA9PT0gbnVsbCB8fCBzdGFydFRpbWUgPCByZXN1bHQpKSB7XG4gICAgICAgICAgcmV0dXJuIHN0YXJ0VGltZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sIG51bGwpO1xuXG4gICAgaWYgKHN0YXJ0ICE9PSBudWxsICYmIGlzRmluaXRlKHN0YXJ0KSAmJiAocmVzdWx0ID09PSBudWxsIHx8IHN0YXJ0IDwgcmVzdWx0KSkge1xuICAgICAgcmV0dXJuIHN0YXJ0O1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sIG51bGwpIHx8IDA7XG59XG4vKlxuICBGb3IgUmVmZXJlbmNlOlxuICBhbGlnbmVkKDgpIGNsYXNzIFRyYWNrRnJhZ21lbnRIZWFkZXJCb3hcbiAgICAgICAgICAgZXh0ZW5kcyBGdWxsQm94KOKAmHRmaGTigJksIDAsIHRmX2ZsYWdzKXtcbiAgICAgdW5zaWduZWQgaW50KDMyKSAgdHJhY2tfSUQ7XG4gICAgIC8vIGFsbCB0aGUgZm9sbG93aW5nIGFyZSBvcHRpb25hbCBmaWVsZHNcbiAgICAgdW5zaWduZWQgaW50KDY0KSAgYmFzZV9kYXRhX29mZnNldDtcbiAgICAgdW5zaWduZWQgaW50KDMyKSAgc2FtcGxlX2Rlc2NyaXB0aW9uX2luZGV4O1xuICAgICB1bnNpZ25lZCBpbnQoMzIpICBkZWZhdWx0X3NhbXBsZV9kdXJhdGlvbjtcbiAgICAgdW5zaWduZWQgaW50KDMyKSAgZGVmYXVsdF9zYW1wbGVfc2l6ZTtcbiAgICAgdW5zaWduZWQgaW50KDMyKSAgZGVmYXVsdF9zYW1wbGVfZmxhZ3NcbiAgfVxuICovXG5cbmZ1bmN0aW9uIGdldER1cmF0aW9uKGRhdGEsIGluaXREYXRhKSB7XG4gIHZhciByYXdEdXJhdGlvbiA9IDA7XG4gIHZhciB2aWRlb0R1cmF0aW9uID0gMDtcbiAgdmFyIGF1ZGlvRHVyYXRpb24gPSAwO1xuICB2YXIgdHJhZnMgPSBmaW5kQm94KGRhdGEsIFsnbW9vZicsICd0cmFmJ10pO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdHJhZnMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdHJhZiA9IHRyYWZzW2ldOyAvLyBUaGVyZSBpcyBvbmx5IG9uZSB0ZmhkICYgdHJ1biBwZXIgdHJhZlxuICAgIC8vIFRoaXMgaXMgdHJ1ZSBmb3IgQ01BRiBzdHlsZSBjb250ZW50LCBhbmQgd2Ugc2hvdWxkIHBlcmhhcHMgY2hlY2sgdGhlIGZ0eXBcbiAgICAvLyBhbmQgb25seSBsb29rIGZvciBhIHNpbmdsZSB0cnVuIHRoZW4sIGJ1dCBmb3IgSVNPQk1GRiB3ZSBzaG91bGQgY2hlY2tcbiAgICAvLyBmb3IgbXVsdGlwbGUgdHJhY2sgcnVucy5cblxuICAgIHZhciB0ZmhkID0gZmluZEJveCh0cmFmLCBbJ3RmaGQnXSlbMF07IC8vIGdldCB0aGUgdHJhY2sgaWQgZnJvbSB0aGUgdGZoZFxuXG4gICAgdmFyIGlkID0gcmVhZFVpbnQzMih0ZmhkLCA0KTtcbiAgICB2YXIgdHJhY2sgPSBpbml0RGF0YVtpZF07XG5cbiAgICBpZiAoIXRyYWNrKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIgdHJhY2tEZWZhdWx0ID0gdHJhY2suZGVmYXVsdDtcbiAgICB2YXIgdGZoZEZsYWdzID0gcmVhZFVpbnQzMih0ZmhkLCAwKSB8ICh0cmFja0RlZmF1bHQgPT09IG51bGwgfHwgdHJhY2tEZWZhdWx0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0cmFja0RlZmF1bHQuZmxhZ3MpO1xuICAgIHZhciBzYW1wbGVEdXJhdGlvbiA9IHRyYWNrRGVmYXVsdCA9PT0gbnVsbCB8fCB0cmFja0RlZmF1bHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRyYWNrRGVmYXVsdC5kdXJhdGlvbjtcblxuICAgIGlmICh0ZmhkRmxhZ3MgJiAweDAwMDAwOCkge1xuICAgICAgLy8gMHgwMDAwMDggaW5kaWNhdGVzIHRoZSBwcmVzZW5jZSBvZiB0aGUgZGVmYXVsdF9zYW1wbGVfZHVyYXRpb24gZmllbGRcbiAgICAgIGlmICh0ZmhkRmxhZ3MgJiAweDAwMDAwMikge1xuICAgICAgICAvLyAweDAwMDAwMiBpbmRpY2F0ZXMgdGhlIHByZXNlbmNlIG9mIHRoZSBzYW1wbGVfZGVzY3JpcHRpb25faW5kZXggZmllbGQsIHdoaWNoIHByZWNlZGVzIGRlZmF1bHRfc2FtcGxlX2R1cmF0aW9uXG4gICAgICAgIC8vIElmIHByZXNlbnQsIHRoZSBkZWZhdWx0X3NhbXBsZV9kdXJhdGlvbiBleGlzdHMgYXQgYnl0ZSBvZmZzZXQgMTJcbiAgICAgICAgc2FtcGxlRHVyYXRpb24gPSByZWFkVWludDMyKHRmaGQsIDEyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE90aGVyd2lzZSwgdGhlIGR1cmF0aW9uIGlzIGF0IGJ5dGUgb2Zmc2V0IDhcbiAgICAgICAgc2FtcGxlRHVyYXRpb24gPSByZWFkVWludDMyKHRmaGQsIDgpO1xuICAgICAgfVxuICAgIH0gLy8gYXNzdW1lIGEgOTBrSHogY2xvY2sgaWYgbm8gdGltZXNjYWxlIHdhcyBzcGVjaWZpZWRcblxuXG4gICAgdmFyIHRpbWVzY2FsZSA9IHRyYWNrLnRpbWVzY2FsZSB8fCA5MGUzO1xuICAgIHZhciB0cnVucyA9IGZpbmRCb3godHJhZiwgWyd0cnVuJ10pO1xuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCB0cnVucy5sZW5ndGg7IGorKykge1xuICAgICAgcmF3RHVyYXRpb24gPSBjb21wdXRlUmF3RHVyYXRpb25Gcm9tU2FtcGxlcyh0cnVuc1tqXSk7XG5cbiAgICAgIGlmICghcmF3RHVyYXRpb24gJiYgc2FtcGxlRHVyYXRpb24pIHtcbiAgICAgICAgdmFyIHNhbXBsZUNvdW50ID0gcmVhZFVpbnQzMih0cnVuc1tqXSwgNCk7XG4gICAgICAgIHJhd0R1cmF0aW9uID0gc2FtcGxlRHVyYXRpb24gKiBzYW1wbGVDb3VudDtcbiAgICAgIH1cblxuICAgICAgaWYgKHRyYWNrLnR5cGUgPT09IF9sb2FkZXJfZnJhZ21lbnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkVsZW1lbnRhcnlTdHJlYW1UeXBlc1wiXS5WSURFTykge1xuICAgICAgICB2aWRlb0R1cmF0aW9uICs9IHJhd0R1cmF0aW9uIC8gdGltZXNjYWxlO1xuICAgICAgfSBlbHNlIGlmICh0cmFjay50eXBlID09PSBfbG9hZGVyX2ZyYWdtZW50X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFbGVtZW50YXJ5U3RyZWFtVHlwZXNcIl0uQVVESU8pIHtcbiAgICAgICAgYXVkaW9EdXJhdGlvbiArPSByYXdEdXJhdGlvbiAvIHRpbWVzY2FsZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAodmlkZW9EdXJhdGlvbiA9PT0gMCAmJiBhdWRpb0R1cmF0aW9uID09PSAwKSB7XG4gICAgLy8gSWYgZHVyYXRpb24gc2FtcGxlcyBhcmUgbm90IGF2YWlsYWJsZSBpbiB0aGUgdHJhZiB1c2Ugc2lkeCBzdWJzZWdtZW50X2R1cmF0aW9uXG4gICAgdmFyIHNpZHggPSBwYXJzZVNlZ21lbnRJbmRleChkYXRhKTtcblxuICAgIGlmIChzaWR4ICE9PSBudWxsICYmIHNpZHggIT09IHZvaWQgMCAmJiBzaWR4LnJlZmVyZW5jZXMpIHtcbiAgICAgIHJldHVybiBzaWR4LnJlZmVyZW5jZXMucmVkdWNlKGZ1bmN0aW9uIChkdXIsIHJlZikge1xuICAgICAgICByZXR1cm4gZHVyICsgcmVmLmluZm8uZHVyYXRpb24gfHwgMDtcbiAgICAgIH0sIDApO1xuICAgIH1cbiAgfVxuXG4gIGlmICh2aWRlb0R1cmF0aW9uKSB7XG4gICAgcmV0dXJuIHZpZGVvRHVyYXRpb247XG4gIH1cblxuICByZXR1cm4gYXVkaW9EdXJhdGlvbjtcbn1cbi8qXG4gIEZvciBSZWZlcmVuY2U6XG4gIGFsaWduZWQoOCkgY2xhc3MgVHJhY2tSdW5Cb3hcbiAgICAgICAgICAgZXh0ZW5kcyBGdWxsQm94KOKAmHRydW7igJksIHZlcnNpb24sIHRyX2ZsYWdzKSB7XG4gICAgIHVuc2lnbmVkIGludCgzMikgIHNhbXBsZV9jb3VudDtcbiAgICAgLy8gdGhlIGZvbGxvd2luZyBhcmUgb3B0aW9uYWwgZmllbGRzXG4gICAgIHNpZ25lZCBpbnQoMzIpIGRhdGFfb2Zmc2V0O1xuICAgICB1bnNpZ25lZCBpbnQoMzIpICBmaXJzdF9zYW1wbGVfZmxhZ3M7XG4gICAgIC8vIGFsbCBmaWVsZHMgaW4gdGhlIGZvbGxvd2luZyBhcnJheSBhcmUgb3B0aW9uYWxcbiAgICAge1xuICAgICAgICB1bnNpZ25lZCBpbnQoMzIpICBzYW1wbGVfZHVyYXRpb247XG4gICAgICAgIHVuc2lnbmVkIGludCgzMikgIHNhbXBsZV9zaXplO1xuICAgICAgICB1bnNpZ25lZCBpbnQoMzIpICBzYW1wbGVfZmxhZ3NcbiAgICAgICAgaWYgKHZlcnNpb24gPT0gMClcbiAgICAgICAgICAgeyB1bnNpZ25lZCBpbnQoMzIpXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgeyBzaWduZWQgaW50KDMyKVxuICAgICB9WyBzYW1wbGVfY291bnQgXVxuICB9XG4gKi9cblxuZnVuY3Rpb24gY29tcHV0ZVJhd0R1cmF0aW9uRnJvbVNhbXBsZXModHJ1bikge1xuICB2YXIgZmxhZ3MgPSByZWFkVWludDMyKHRydW4sIDApOyAvLyBGbGFncyBhcmUgYXQgb2Zmc2V0IDAsIG5vbi1vcHRpb25hbCBzYW1wbGVfY291bnQgaXMgYXQgb2Zmc2V0IDQuIFRoZXJlZm9yZSB3ZSBzdGFydCA4IGJ5dGVzIGluLlxuICAvLyBFYWNoIGZpZWxkIGlzIGFuIGludDMyLCB3aGljaCBpcyA0IGJ5dGVzXG5cbiAgdmFyIG9mZnNldCA9IDg7IC8vIGRhdGEtb2Zmc2V0LXByZXNlbnQgZmxhZ1xuXG4gIGlmIChmbGFncyAmIDB4MDAwMDAxKSB7XG4gICAgb2Zmc2V0ICs9IDQ7XG4gIH0gLy8gZmlyc3Qtc2FtcGxlLWZsYWdzLXByZXNlbnQgZmxhZ1xuXG5cbiAgaWYgKGZsYWdzICYgMHgwMDAwMDQpIHtcbiAgICBvZmZzZXQgKz0gNDtcbiAgfVxuXG4gIHZhciBkdXJhdGlvbiA9IDA7XG4gIHZhciBzYW1wbGVDb3VudCA9IHJlYWRVaW50MzIodHJ1biwgNCk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzYW1wbGVDb3VudDsgaSsrKSB7XG4gICAgLy8gc2FtcGxlLWR1cmF0aW9uLXByZXNlbnQgZmxhZ1xuICAgIGlmIChmbGFncyAmIDB4MDAwMTAwKSB7XG4gICAgICB2YXIgc2FtcGxlRHVyYXRpb24gPSByZWFkVWludDMyKHRydW4sIG9mZnNldCk7XG4gICAgICBkdXJhdGlvbiArPSBzYW1wbGVEdXJhdGlvbjtcbiAgICAgIG9mZnNldCArPSA0O1xuICAgIH0gLy8gc2FtcGxlLXNpemUtcHJlc2VudCBmbGFnXG5cblxuICAgIGlmIChmbGFncyAmIDB4MDAwMjAwKSB7XG4gICAgICBvZmZzZXQgKz0gNDtcbiAgICB9IC8vIHNhbXBsZS1mbGFncy1wcmVzZW50IGZsYWdcblxuXG4gICAgaWYgKGZsYWdzICYgMHgwMDA0MDApIHtcbiAgICAgIG9mZnNldCArPSA0O1xuICAgIH0gLy8gc2FtcGxlLWNvbXBvc2l0aW9uLXRpbWUtb2Zmc2V0cy1wcmVzZW50IGZsYWdcblxuXG4gICAgaWYgKGZsYWdzICYgMHgwMDA4MDApIHtcbiAgICAgIG9mZnNldCArPSA0O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkdXJhdGlvbjtcbn1cbmZ1bmN0aW9uIG9mZnNldFN0YXJ0RFRTKGluaXREYXRhLCBmbXA0LCB0aW1lT2Zmc2V0KSB7XG4gIGZpbmRCb3goZm1wNCwgWydtb29mJywgJ3RyYWYnXSkuZm9yRWFjaChmdW5jdGlvbiAodHJhZikge1xuICAgIGZpbmRCb3godHJhZiwgWyd0ZmhkJ10pLmZvckVhY2goZnVuY3Rpb24gKHRmaGQpIHtcbiAgICAgIC8vIGdldCB0aGUgdHJhY2sgaWQgZnJvbSB0aGUgdGZoZFxuICAgICAgdmFyIGlkID0gcmVhZFVpbnQzMih0ZmhkLCA0KTtcbiAgICAgIHZhciB0cmFjayA9IGluaXREYXRhW2lkXTtcblxuICAgICAgaWYgKCF0cmFjaykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIGFzc3VtZSBhIDkwa0h6IGNsb2NrIGlmIG5vIHRpbWVzY2FsZSB3YXMgc3BlY2lmaWVkXG5cblxuICAgICAgdmFyIHRpbWVzY2FsZSA9IHRyYWNrLnRpbWVzY2FsZSB8fCA5MGUzOyAvLyBnZXQgdGhlIGJhc2UgbWVkaWEgZGVjb2RlIHRpbWUgZnJvbSB0aGUgdGZkdFxuXG4gICAgICBmaW5kQm94KHRyYWYsIFsndGZkdCddKS5mb3JFYWNoKGZ1bmN0aW9uICh0ZmR0KSB7XG4gICAgICAgIHZhciB2ZXJzaW9uID0gdGZkdC5kYXRhW3RmZHQuc3RhcnRdO1xuICAgICAgICB2YXIgYmFzZU1lZGlhRGVjb2RlVGltZSA9IHJlYWRVaW50MzIodGZkdCwgNCk7XG5cbiAgICAgICAgaWYgKHZlcnNpb24gPT09IDApIHtcbiAgICAgICAgICB3cml0ZVVpbnQzMih0ZmR0LCA0LCBiYXNlTWVkaWFEZWNvZGVUaW1lIC0gdGltZU9mZnNldCAqIHRpbWVzY2FsZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYmFzZU1lZGlhRGVjb2RlVGltZSAqPSBNYXRoLnBvdygyLCAzMik7XG4gICAgICAgICAgYmFzZU1lZGlhRGVjb2RlVGltZSArPSByZWFkVWludDMyKHRmZHQsIDgpO1xuICAgICAgICAgIGJhc2VNZWRpYURlY29kZVRpbWUgLT0gdGltZU9mZnNldCAqIHRpbWVzY2FsZTtcbiAgICAgICAgICBiYXNlTWVkaWFEZWNvZGVUaW1lID0gTWF0aC5tYXgoYmFzZU1lZGlhRGVjb2RlVGltZSwgMCk7XG4gICAgICAgICAgdmFyIHVwcGVyID0gTWF0aC5mbG9vcihiYXNlTWVkaWFEZWNvZGVUaW1lIC8gKFVJTlQzMl9NQVggKyAxKSk7XG4gICAgICAgICAgdmFyIGxvd2VyID0gTWF0aC5mbG9vcihiYXNlTWVkaWFEZWNvZGVUaW1lICUgKFVJTlQzMl9NQVggKyAxKSk7XG4gICAgICAgICAgd3JpdGVVaW50MzIodGZkdCwgNCwgdXBwZXIpO1xuICAgICAgICAgIHdyaXRlVWludDMyKHRmZHQsIDgsIGxvd2VyKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xufSAvLyBUT0RPOiBDaGVjayBpZiB0aGUgbGFzdCBtb29mK21kYXQgcGFpciBpcyBwYXJ0IG9mIHRoZSB2YWxpZCByYW5nZVxuXG5mdW5jdGlvbiBzZWdtZW50VmFsaWRSYW5nZShkYXRhKSB7XG4gIHZhciBzZWdtZW50ZWRSYW5nZSA9IHtcbiAgICB2YWxpZDogbnVsbCxcbiAgICByZW1haW5kZXI6IG51bGxcbiAgfTtcbiAgdmFyIG1vb2ZzID0gZmluZEJveChkYXRhLCBbJ21vb2YnXSk7XG5cbiAgaWYgKCFtb29mcykge1xuICAgIHJldHVybiBzZWdtZW50ZWRSYW5nZTtcbiAgfSBlbHNlIGlmIChtb29mcy5sZW5ndGggPCAyKSB7XG4gICAgc2VnbWVudGVkUmFuZ2UucmVtYWluZGVyID0gZGF0YTtcbiAgICByZXR1cm4gc2VnbWVudGVkUmFuZ2U7XG4gIH1cblxuICB2YXIgbGFzdCA9IG1vb2ZzW21vb2ZzLmxlbmd0aCAtIDFdOyAvLyBPZmZzZXQgYnkgOCBieXRlczsgZmluZEJveCBvZmZzZXRzIHRoZSBzdGFydCBieSBhcyBtdWNoXG5cbiAgc2VnbWVudGVkUmFuZ2UudmFsaWQgPSBPYmplY3QoX3R5cGVkX2FycmF5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJzbGljZVVpbnQ4XCJdKShkYXRhLCAwLCBsYXN0LnN0YXJ0IC0gOCk7XG4gIHNlZ21lbnRlZFJhbmdlLnJlbWFpbmRlciA9IE9iamVjdChfdHlwZWRfYXJyYXlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcInNsaWNlVWludDhcIl0pKGRhdGEsIGxhc3Quc3RhcnQgLSA4KTtcbiAgcmV0dXJuIHNlZ21lbnRlZFJhbmdlO1xufVxuZnVuY3Rpb24gYXBwZW5kVWludDhBcnJheShkYXRhMSwgZGF0YTIpIHtcbiAgdmFyIHRlbXAgPSBuZXcgVWludDhBcnJheShkYXRhMS5sZW5ndGggKyBkYXRhMi5sZW5ndGgpO1xuICB0ZW1wLnNldChkYXRhMSk7XG4gIHRlbXAuc2V0KGRhdGEyLCBkYXRhMS5sZW5ndGgpO1xuICByZXR1cm4gdGVtcDtcbn1cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvdXRpbHMvb3V0cHV0LWZpbHRlci50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3V0aWxzL291dHB1dC1maWx0ZXIudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImRlZmF1bHRcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBPdXRwdXRGaWx0ZXI7IH0pO1xudmFyIE91dHB1dEZpbHRlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIE91dHB1dEZpbHRlcih0aW1lbGluZUNvbnRyb2xsZXIsIHRyYWNrTmFtZSkge1xuICAgIHRoaXMudGltZWxpbmVDb250cm9sbGVyID0gdm9pZCAwO1xuICAgIHRoaXMuY3VlUmFuZ2VzID0gW107XG4gICAgdGhpcy50cmFja05hbWUgPSB2b2lkIDA7XG4gICAgdGhpcy5zdGFydFRpbWUgPSBudWxsO1xuICAgIHRoaXMuZW5kVGltZSA9IG51bGw7XG4gICAgdGhpcy5zY3JlZW4gPSBudWxsO1xuICAgIHRoaXMudGltZWxpbmVDb250cm9sbGVyID0gdGltZWxpbmVDb250cm9sbGVyO1xuICAgIHRoaXMudHJhY2tOYW1lID0gdHJhY2tOYW1lO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IE91dHB1dEZpbHRlci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmRpc3BhdGNoQ3VlID0gZnVuY3Rpb24gZGlzcGF0Y2hDdWUoKSB7XG4gICAgaWYgKHRoaXMuc3RhcnRUaW1lID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy50aW1lbGluZUNvbnRyb2xsZXIuYWRkQ3Vlcyh0aGlzLnRyYWNrTmFtZSwgdGhpcy5zdGFydFRpbWUsIHRoaXMuZW5kVGltZSwgdGhpcy5zY3JlZW4sIHRoaXMuY3VlUmFuZ2VzKTtcbiAgICB0aGlzLnN0YXJ0VGltZSA9IG51bGw7XG4gIH07XG5cbiAgX3Byb3RvLm5ld0N1ZSA9IGZ1bmN0aW9uIG5ld0N1ZShzdGFydFRpbWUsIGVuZFRpbWUsIHNjcmVlbikge1xuICAgIGlmICh0aGlzLnN0YXJ0VGltZSA9PT0gbnVsbCB8fCB0aGlzLnN0YXJ0VGltZSA+IHN0YXJ0VGltZSkge1xuICAgICAgdGhpcy5zdGFydFRpbWUgPSBzdGFydFRpbWU7XG4gICAgfVxuXG4gICAgdGhpcy5lbmRUaW1lID0gZW5kVGltZTtcbiAgICB0aGlzLnNjcmVlbiA9IHNjcmVlbjtcbiAgICB0aGlzLnRpbWVsaW5lQ29udHJvbGxlci5jcmVhdGVDYXB0aW9uc1RyYWNrKHRoaXMudHJhY2tOYW1lKTtcbiAgfTtcblxuICBfcHJvdG8ucmVzZXQgPSBmdW5jdGlvbiByZXNldCgpIHtcbiAgICB0aGlzLmN1ZVJhbmdlcyA9IFtdO1xuICAgIHRoaXMuc3RhcnRUaW1lID0gbnVsbDtcbiAgfTtcblxuICByZXR1cm4gT3V0cHV0RmlsdGVyO1xufSgpO1xuXG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvdXRpbHMvdGV4dHRyYWNrLXV0aWxzLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy91dGlscy90ZXh0dHJhY2stdXRpbHMudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IHNlbmRBZGRUcmFja0V2ZW50LCBhZGRDdWVUb1RyYWNrLCBjbGVhckN1cnJlbnRDdWVzLCByZW1vdmVDdWVzSW5SYW5nZSwgZ2V0Q3Vlc0luUmFuZ2UgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwic2VuZEFkZFRyYWNrRXZlbnRcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBzZW5kQWRkVHJhY2tFdmVudDsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiYWRkQ3VlVG9UcmFja1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGFkZEN1ZVRvVHJhY2s7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImNsZWFyQ3VycmVudEN1ZXNcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBjbGVhckN1cnJlbnRDdWVzOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJyZW1vdmVDdWVzSW5SYW5nZVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHJlbW92ZUN1ZXNJblJhbmdlOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJnZXRDdWVzSW5SYW5nZVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGdldEN1ZXNJblJhbmdlOyB9KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2xvZ2dlciAqLyBcIi4vc3JjL3V0aWxzL2xvZ2dlci50c1wiKTtcblxuZnVuY3Rpb24gc2VuZEFkZFRyYWNrRXZlbnQodHJhY2ssIHZpZGVvRWwpIHtcbiAgdmFyIGV2ZW50O1xuXG4gIHRyeSB7XG4gICAgZXZlbnQgPSBuZXcgRXZlbnQoJ2FkZHRyYWNrJyk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIC8vIGZvciBJRTExXG4gICAgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcbiAgICBldmVudC5pbml0RXZlbnQoJ2FkZHRyYWNrJywgZmFsc2UsIGZhbHNlKTtcbiAgfVxuXG4gIGV2ZW50LnRyYWNrID0gdHJhY2s7XG4gIHZpZGVvRWwuZGlzcGF0Y2hFdmVudChldmVudCk7XG59XG5mdW5jdGlvbiBhZGRDdWVUb1RyYWNrKHRyYWNrLCBjdWUpIHtcbiAgLy8gU29tZXRpbWVzIHRoZXJlIGFyZSBjdWUgb3ZlcmxhcHMgb24gc2VnbWVudGVkIHZ0dHMgc28gdGhlIHNhbWVcbiAgLy8gY3VlIGNhbiBhcHBlYXIgbW9yZSB0aGFuIG9uY2UgaW4gZGlmZmVyZW50IHZ0dCBmaWxlcy5cbiAgLy8gVGhpcyBhdm9pZCBzaG93aW5nIGR1cGxpY2F0ZWQgY3VlcyB3aXRoIHNhbWUgdGltZWNvZGUgYW5kIHRleHQuXG4gIHZhciBtb2RlID0gdHJhY2subW9kZTtcblxuICBpZiAobW9kZSA9PT0gJ2Rpc2FibGVkJykge1xuICAgIHRyYWNrLm1vZGUgPSAnaGlkZGVuJztcbiAgfVxuXG4gIGlmICh0cmFjay5jdWVzICYmICF0cmFjay5jdWVzLmdldEN1ZUJ5SWQoY3VlLmlkKSkge1xuICAgIHRyeSB7XG4gICAgICB0cmFjay5hZGRDdWUoY3VlKTtcblxuICAgICAgaWYgKCF0cmFjay5jdWVzLmdldEN1ZUJ5SWQoY3VlLmlkKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhZGRDdWUgaXMgZmFpbGVkIGZvcjogXCIgKyBjdWUpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wibG9nZ2VyXCJdLmRlYnVnKFwiW3RleHR0cmFjay11dGlsc106IFwiICsgZXJyKTtcbiAgICAgIHZhciB0ZXh0VHJhY2tDdWUgPSBuZXcgc2VsZi5UZXh0VHJhY2tDdWUoY3VlLnN0YXJ0VGltZSwgY3VlLmVuZFRpbWUsIGN1ZS50ZXh0KTtcbiAgICAgIHRleHRUcmFja0N1ZS5pZCA9IGN1ZS5pZDtcbiAgICAgIHRyYWNrLmFkZEN1ZSh0ZXh0VHJhY2tDdWUpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChtb2RlID09PSAnZGlzYWJsZWQnKSB7XG4gICAgdHJhY2subW9kZSA9IG1vZGU7XG4gIH1cbn1cbmZ1bmN0aW9uIGNsZWFyQ3VycmVudEN1ZXModHJhY2spIHtcbiAgLy8gV2hlbiB0cmFjay5tb2RlIGlzIGRpc2FibGVkLCB0cmFjay5jdWVzIHdpbGwgYmUgbnVsbC5cbiAgLy8gVG8gZ3VhcmFudGVlIHRoZSByZW1vdmFsIG9mIGN1ZXMsIHdlIG5lZWQgdG8gdGVtcG9yYXJpbHlcbiAgLy8gY2hhbmdlIHRoZSBtb2RlIHRvIGhpZGRlblxuICB2YXIgbW9kZSA9IHRyYWNrLm1vZGU7XG5cbiAgaWYgKG1vZGUgPT09ICdkaXNhYmxlZCcpIHtcbiAgICB0cmFjay5tb2RlID0gJ2hpZGRlbic7XG4gIH1cblxuICBpZiAodHJhY2suY3Vlcykge1xuICAgIGZvciAodmFyIGkgPSB0cmFjay5jdWVzLmxlbmd0aDsgaS0tOykge1xuICAgICAgdHJhY2sucmVtb3ZlQ3VlKHRyYWNrLmN1ZXNbaV0pO1xuICAgIH1cbiAgfVxuXG4gIGlmIChtb2RlID09PSAnZGlzYWJsZWQnKSB7XG4gICAgdHJhY2subW9kZSA9IG1vZGU7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlbW92ZUN1ZXNJblJhbmdlKHRyYWNrLCBzdGFydCwgZW5kKSB7XG4gIHZhciBtb2RlID0gdHJhY2subW9kZTtcblxuICBpZiAobW9kZSA9PT0gJ2Rpc2FibGVkJykge1xuICAgIHRyYWNrLm1vZGUgPSAnaGlkZGVuJztcbiAgfVxuXG4gIGlmICh0cmFjay5jdWVzICYmIHRyYWNrLmN1ZXMubGVuZ3RoID4gMCkge1xuICAgIHZhciBjdWVzID0gZ2V0Q3Vlc0luUmFuZ2UodHJhY2suY3Vlcywgc3RhcnQsIGVuZCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGN1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRyYWNrLnJlbW92ZUN1ZShjdWVzW2ldKTtcbiAgICB9XG4gIH1cblxuICBpZiAobW9kZSA9PT0gJ2Rpc2FibGVkJykge1xuICAgIHRyYWNrLm1vZGUgPSBtb2RlO1xuICB9XG59IC8vIEZpbmQgZmlyc3QgY3VlIHN0YXJ0aW5nIGFmdGVyIGdpdmVuIHRpbWUuXG4vLyBNb2RpZmllZCB2ZXJzaW9uIG9mIGJpbmFyeSBzZWFyY2ggTyhsb2cobikpLlxuXG5mdW5jdGlvbiBnZXRGaXJzdEN1ZUluZGV4QWZ0ZXJUaW1lKGN1ZXMsIHRpbWUpIHtcbiAgLy8gSWYgZmlyc3QgY3VlIHN0YXJ0cyBhZnRlciB0aW1lLCBzdGFydCB0aGVyZVxuICBpZiAodGltZSA8IGN1ZXNbMF0uc3RhcnRUaW1lKSB7XG4gICAgcmV0dXJuIDA7XG4gIH0gLy8gSWYgdGhlIGxhc3QgY3VlIGVuZHMgYmVmb3JlIHRpbWUgdGhlcmUgaXMgbm8gb3ZlcmxhcFxuXG5cbiAgdmFyIGxlbiA9IGN1ZXMubGVuZ3RoIC0gMTtcblxuICBpZiAodGltZSA+IGN1ZXNbbGVuXS5lbmRUaW1lKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgdmFyIGxlZnQgPSAwO1xuICB2YXIgcmlnaHQgPSBsZW47XG5cbiAgd2hpbGUgKGxlZnQgPD0gcmlnaHQpIHtcbiAgICB2YXIgbWlkID0gTWF0aC5mbG9vcigocmlnaHQgKyBsZWZ0KSAvIDIpO1xuXG4gICAgaWYgKHRpbWUgPCBjdWVzW21pZF0uc3RhcnRUaW1lKSB7XG4gICAgICByaWdodCA9IG1pZCAtIDE7XG4gICAgfSBlbHNlIGlmICh0aW1lID4gY3Vlc1ttaWRdLnN0YXJ0VGltZSAmJiBsZWZ0IDwgbGVuKSB7XG4gICAgICBsZWZ0ID0gbWlkICsgMTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgaXQncyBub3QgbG93ZXIgb3IgaGlnaGVyLCBpdCBtdXN0IGJlIGVxdWFsLlxuICAgICAgcmV0dXJuIG1pZDtcbiAgICB9XG4gIH0gLy8gQXQgdGhpcyBwb2ludCwgbGVmdCBhbmQgcmlnaHQgaGF2ZSBzd2FwcGVkLlxuICAvLyBObyBkaXJlY3QgbWF0Y2ggd2FzIGZvdW5kLCBsZWZ0IG9yIHJpZ2h0IGVsZW1lbnQgbXVzdCBiZSB0aGUgY2xvc2VzdC4gQ2hlY2sgd2hpY2ggb25lIGhhcyB0aGUgc21hbGxlc3QgZGlmZi5cblxuXG4gIHJldHVybiBjdWVzW2xlZnRdLnN0YXJ0VGltZSAtIHRpbWUgPCB0aW1lIC0gY3Vlc1tyaWdodF0uc3RhcnRUaW1lID8gbGVmdCA6IHJpZ2h0O1xufVxuXG5mdW5jdGlvbiBnZXRDdWVzSW5SYW5nZShjdWVzLCBzdGFydCwgZW5kKSB7XG4gIHZhciBjdWVzRm91bmQgPSBbXTtcbiAgdmFyIGZpcnN0Q3VlSW5SYW5nZSA9IGdldEZpcnN0Q3VlSW5kZXhBZnRlclRpbWUoY3Vlcywgc3RhcnQpO1xuXG4gIGlmIChmaXJzdEN1ZUluUmFuZ2UgPiAtMSkge1xuICAgIGZvciAodmFyIGkgPSBmaXJzdEN1ZUluUmFuZ2UsIGxlbiA9IGN1ZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHZhciBjdWUgPSBjdWVzW2ldO1xuXG4gICAgICBpZiAoY3VlLnN0YXJ0VGltZSA+PSBzdGFydCAmJiBjdWUuZW5kVGltZSA8PSBlbmQpIHtcbiAgICAgICAgY3Vlc0ZvdW5kLnB1c2goY3VlKTtcbiAgICAgIH0gZWxzZSBpZiAoY3VlLnN0YXJ0VGltZSA+IGVuZCkge1xuICAgICAgICByZXR1cm4gY3Vlc0ZvdW5kO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjdWVzRm91bmQ7XG59XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3V0aWxzL3RpbWUtcmFuZ2VzLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3V0aWxzL3RpbWUtcmFuZ2VzLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKipcbiAqICBUaW1lUmFuZ2VzIHRvIHN0cmluZyBoZWxwZXJcbiAqL1xudmFyIFRpbWVSYW5nZXMgPSB7XG4gIHRvU3RyaW5nOiBmdW5jdGlvbiB0b1N0cmluZyhyKSB7XG4gICAgdmFyIGxvZyA9ICcnO1xuICAgIHZhciBsZW4gPSByLmxlbmd0aDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGxvZyArPSAnWycgKyByLnN0YXJ0KGkpLnRvRml4ZWQoMykgKyAnLCcgKyByLmVuZChpKS50b0ZpeGVkKDMpICsgJ10nO1xuICAgIH1cblxuICAgIHJldHVybiBsb2c7XG4gIH1cbn07XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKFRpbWVSYW5nZXMpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy91dGlscy90aW1lc2NhbGUtY29udmVyc2lvbi50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy91dGlscy90aW1lc2NhbGUtY29udmVyc2lvbi50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiB0b1RpbWVzY2FsZUZyb21CYXNlLCB0b1RpbWVzY2FsZUZyb21TY2FsZSwgdG9Nc0Zyb21NcGVnVHNDbG9jaywgdG9NcGVnVHNDbG9ja0Zyb21UaW1lc2NhbGUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwidG9UaW1lc2NhbGVGcm9tQmFzZVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHRvVGltZXNjYWxlRnJvbUJhc2U7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcInRvVGltZXNjYWxlRnJvbVNjYWxlXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gdG9UaW1lc2NhbGVGcm9tU2NhbGU7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcInRvTXNGcm9tTXBlZ1RzQ2xvY2tcIiwgZnVuY3Rpb24oKSB7IHJldHVybiB0b01zRnJvbU1wZWdUc0Nsb2NrOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJ0b01wZWdUc0Nsb2NrRnJvbVRpbWVzY2FsZVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHRvTXBlZ1RzQ2xvY2tGcm9tVGltZXNjYWxlOyB9KTtcbnZhciBNUEVHX1RTX0NMT0NLX0ZSRVFfSFogPSA5MDAwMDtcbmZ1bmN0aW9uIHRvVGltZXNjYWxlRnJvbUJhc2UodmFsdWUsIGRlc3RTY2FsZSwgc3JjQmFzZSwgcm91bmQpIHtcbiAgaWYgKHNyY0Jhc2UgPT09IHZvaWQgMCkge1xuICAgIHNyY0Jhc2UgPSAxO1xuICB9XG5cbiAgaWYgKHJvdW5kID09PSB2b2lkIDApIHtcbiAgICByb3VuZCA9IGZhbHNlO1xuICB9XG5cbiAgdmFyIHJlc3VsdCA9IHZhbHVlICogZGVzdFNjYWxlICogc3JjQmFzZTsgLy8gZXF1aXZhbGVudCB0byBgKHZhbHVlICogc2NhbGUpIC8gKDEgLyBiYXNlKWBcblxuICByZXR1cm4gcm91bmQgPyBNYXRoLnJvdW5kKHJlc3VsdCkgOiByZXN1bHQ7XG59XG5mdW5jdGlvbiB0b1RpbWVzY2FsZUZyb21TY2FsZSh2YWx1ZSwgZGVzdFNjYWxlLCBzcmNTY2FsZSwgcm91bmQpIHtcbiAgaWYgKHNyY1NjYWxlID09PSB2b2lkIDApIHtcbiAgICBzcmNTY2FsZSA9IDE7XG4gIH1cblxuICBpZiAocm91bmQgPT09IHZvaWQgMCkge1xuICAgIHJvdW5kID0gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdG9UaW1lc2NhbGVGcm9tQmFzZSh2YWx1ZSwgZGVzdFNjYWxlLCAxIC8gc3JjU2NhbGUsIHJvdW5kKTtcbn1cbmZ1bmN0aW9uIHRvTXNGcm9tTXBlZ1RzQ2xvY2sodmFsdWUsIHJvdW5kKSB7XG4gIGlmIChyb3VuZCA9PT0gdm9pZCAwKSB7XG4gICAgcm91bmQgPSBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0b1RpbWVzY2FsZUZyb21CYXNlKHZhbHVlLCAxMDAwLCAxIC8gTVBFR19UU19DTE9DS19GUkVRX0haLCByb3VuZCk7XG59XG5mdW5jdGlvbiB0b01wZWdUc0Nsb2NrRnJvbVRpbWVzY2FsZSh2YWx1ZSwgc3JjU2NhbGUpIHtcbiAgaWYgKHNyY1NjYWxlID09PSB2b2lkIDApIHtcbiAgICBzcmNTY2FsZSA9IDE7XG4gIH1cblxuICByZXR1cm4gdG9UaW1lc2NhbGVGcm9tQmFzZSh2YWx1ZSwgTVBFR19UU19DTE9DS19GUkVRX0haLCAxIC8gc3JjU2NhbGUpO1xufVxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy91dGlscy90eXBlZC1hcnJheS50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy91dGlscy90eXBlZC1hcnJheS50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBzbGljZVVpbnQ4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcInNsaWNlVWludDhcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBzbGljZVVpbnQ4OyB9KTtcbmZ1bmN0aW9uIHNsaWNlVWludDgoYXJyYXksIHN0YXJ0LCBlbmQpIHtcbiAgLy8gQHRzLWV4cGVjdC1lcnJvciBUaGlzIHBvbHlmaWxscyBJRTExIHVzYWdlIG9mIFVpbnQ4QXJyYXkgc2xpY2UuXG4gIC8vIEl0IGFsd2F5cyBleGlzdHMgaW4gdGhlIFR5cGVTY3JpcHQgZGVmaW5pdGlvbiBzbyBmYWlscywgYnV0IGl0IGZhaWxzIGF0IHJ1bnRpbWUgb24gSUUxMS5cbiAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNsaWNlID8gYXJyYXkuc2xpY2Uoc3RhcnQsIGVuZCkgOiBuZXcgVWludDhBcnJheShBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcnJheSwgc3RhcnQsIGVuZCkpO1xufVxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy91dGlscy92dHRjdWUudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3V0aWxzL3Z0dGN1ZS50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTMgdnR0LmpzIENvbnRyaWJ1dG9yc1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSAnTGljZW5zZScpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiAnQVMgSVMnIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9ICgoZnVuY3Rpb24gKCkge1xuICBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnICYmIHNlbGYuVlRUQ3VlKSB7XG4gICAgcmV0dXJuIHNlbGYuVlRUQ3VlO1xuICB9XG5cbiAgdmFyIEFsbG93ZWREaXJlY3Rpb25zID0gWycnLCAnbHInLCAncmwnXTtcbiAgdmFyIEFsbG93ZWRBbGlnbm1lbnRzID0gWydzdGFydCcsICdtaWRkbGUnLCAnZW5kJywgJ2xlZnQnLCAncmlnaHQnXTtcblxuICBmdW5jdGlvbiBpc0FsbG93ZWRWYWx1ZShhbGxvd2VkLCB2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSAvLyBuZWNlc3NhcnkgZm9yIGFzc3VyaW5nIHRoZSBnZW5lcmljIGNvbmZvcm1zIHRvIHRoZSBBcnJheSBpbnRlcmZhY2VcblxuXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGFsbG93ZWQpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSAvLyByZXNldCB0aGUgdHlwZSBzbyB0aGF0IHRoZSBuZXh0IG5hcnJvd2luZyB3b3JrcyB3ZWxsXG5cblxuICAgIHZhciBsY1ZhbHVlID0gdmFsdWUudG9Mb3dlckNhc2UoKTsgLy8gdXNlIHRoZSBhbGxvdyBsaXN0IHRvIG5hcnJvdyB0aGUgdHlwZSB0byBhIHNwZWNpZmljIHN1YnNldCBvZiBzdHJpbmdzXG5cbiAgICBpZiAofmFsbG93ZWQuaW5kZXhPZihsY1ZhbHVlKSkge1xuICAgICAgcmV0dXJuIGxjVmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gZmluZERpcmVjdGlvblNldHRpbmcodmFsdWUpIHtcbiAgICByZXR1cm4gaXNBbGxvd2VkVmFsdWUoQWxsb3dlZERpcmVjdGlvbnMsIHZhbHVlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmRBbGlnblNldHRpbmcodmFsdWUpIHtcbiAgICByZXR1cm4gaXNBbGxvd2VkVmFsdWUoQWxsb3dlZEFsaWdubWVudHMsIHZhbHVlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGV4dGVuZChvYmopIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgcmVzdCA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICByZXN0W19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICB2YXIgaSA9IDE7XG5cbiAgICBmb3IgKDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNvYmogPSBhcmd1bWVudHNbaV07XG5cbiAgICAgIGZvciAodmFyIHAgaW4gY29iaikge1xuICAgICAgICBvYmpbcF0gPSBjb2JqW3BdO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICBmdW5jdGlvbiBWVFRDdWUoc3RhcnRUaW1lLCBlbmRUaW1lLCB0ZXh0KSB7XG4gICAgdmFyIGN1ZSA9IHRoaXM7XG4gICAgdmFyIGJhc2VPYmogPSB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTaGltIGltcGxlbWVudGF0aW9uIHNwZWNpZmljIHByb3BlcnRpZXMuIFRoZXNlIHByb3BlcnRpZXMgYXJlIG5vdCBpblxuICAgICAqIHRoZSBzcGVjLlxuICAgICAqL1xuICAgIC8vIExldHMgdXMga25vdyB3aGVuIHRoZSBWVFRDdWUncyBkYXRhIGhhcyBjaGFuZ2VkIGluIHN1Y2ggYSB3YXkgdGhhdCB3ZSBuZWVkXG4gICAgLy8gdG8gcmVjb21wdXRlIGl0cyBkaXNwbGF5IHN0YXRlLiBUaGlzIGxldHMgdXMgY29tcHV0ZSBpdHMgZGlzcGxheSBzdGF0ZVxuICAgIC8vIGxhemlseS5cblxuICAgIGN1ZS5oYXNCZWVuUmVzZXQgPSBmYWxzZTtcbiAgICAvKipcbiAgICAgKiBWVFRDdWUgYW5kIFRleHRUcmFja0N1ZSBwcm9wZXJ0aWVzXG4gICAgICogaHR0cDovL2Rldi53My5vcmcvaHRtbDUvd2VidnR0LyN2dHRjdWUtaW50ZXJmYWNlXG4gICAgICovXG5cbiAgICB2YXIgX2lkID0gJyc7XG4gICAgdmFyIF9wYXVzZU9uRXhpdCA9IGZhbHNlO1xuICAgIHZhciBfc3RhcnRUaW1lID0gc3RhcnRUaW1lO1xuICAgIHZhciBfZW5kVGltZSA9IGVuZFRpbWU7XG4gICAgdmFyIF90ZXh0ID0gdGV4dDtcbiAgICB2YXIgX3JlZ2lvbiA9IG51bGw7XG4gICAgdmFyIF92ZXJ0aWNhbCA9ICcnO1xuICAgIHZhciBfc25hcFRvTGluZXMgPSB0cnVlO1xuICAgIHZhciBfbGluZSA9ICdhdXRvJztcbiAgICB2YXIgX2xpbmVBbGlnbiA9ICdzdGFydCc7XG4gICAgdmFyIF9wb3NpdGlvbiA9IDUwO1xuICAgIHZhciBfcG9zaXRpb25BbGlnbiA9ICdtaWRkbGUnO1xuICAgIHZhciBfc2l6ZSA9IDUwO1xuICAgIHZhciBfYWxpZ24gPSAnbWlkZGxlJztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLCAnaWQnLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gX2lkO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgIF9pZCA9ICcnICsgdmFsdWU7XG4gICAgICB9XG4gICAgfSkpO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsICdwYXVzZU9uRXhpdCcsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBfcGF1c2VPbkV4aXQ7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgX3BhdXNlT25FeGl0ID0gISF2YWx1ZTtcbiAgICAgIH1cbiAgICB9KSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSwgJ3N0YXJ0VGltZScsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBfc3RhcnRUaW1lO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignU3RhcnQgdGltZSBtdXN0IGJlIHNldCB0byBhIG51bWJlci4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIF9zdGFydFRpbWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5oYXNCZWVuUmVzZXQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pKTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLCAnZW5kVGltZScsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBfZW5kVGltZTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0VuZCB0aW1lIG11c3QgYmUgc2V0IHRvIGEgbnVtYmVyLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgX2VuZFRpbWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5oYXNCZWVuUmVzZXQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pKTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLCAndGV4dCcsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBfdGV4dDtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICBfdGV4dCA9ICcnICsgdmFsdWU7XG4gICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KSk7IC8vIHRvZG86IGltcGxlbWVudCBWVFRSZWdpb24gcG9seWZpbGw/XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLCAncmVnaW9uJywgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIF9yZWdpb247XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgX3JlZ2lvbiA9IHZhbHVlO1xuICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XG4gICAgICB9XG4gICAgfSkpO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsICd2ZXJ0aWNhbCcsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBfdmVydGljYWw7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgdmFyIHNldHRpbmcgPSBmaW5kRGlyZWN0aW9uU2V0dGluZyh2YWx1ZSk7IC8vIEhhdmUgdG8gY2hlY2sgZm9yIGZhbHNlIGJlY2F1c2UgdGhlIHNldHRpbmcgYW4gYmUgYW4gZW1wdHkgc3RyaW5nLlxuXG4gICAgICAgIGlmIChzZXR0aW5nID09PSBmYWxzZSkge1xuICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignQW4gaW52YWxpZCBvciBpbGxlZ2FsIHN0cmluZyB3YXMgc3BlY2lmaWVkLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgX3ZlcnRpY2FsID0gc2V0dGluZztcbiAgICAgICAgdGhpcy5oYXNCZWVuUmVzZXQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pKTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLCAnc25hcFRvTGluZXMnLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gX3NuYXBUb0xpbmVzO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgIF9zbmFwVG9MaW5lcyA9ICEhdmFsdWU7XG4gICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSwgJ2xpbmUnLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gX2xpbmU7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicgJiYgdmFsdWUgIT09ICdhdXRvJykge1xuICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignQW4gaW52YWxpZCBudW1iZXIgb3IgaWxsZWdhbCBzdHJpbmcgd2FzIHNwZWNpZmllZC4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIF9saW5lID0gdmFsdWU7XG4gICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSwgJ2xpbmVBbGlnbicsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBfbGluZUFsaWduO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgIHZhciBzZXR0aW5nID0gZmluZEFsaWduU2V0dGluZyh2YWx1ZSk7XG5cbiAgICAgICAgaWYgKCFzZXR0aW5nKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdBbiBpbnZhbGlkIG9yIGlsbGVnYWwgc3RyaW5nIHdhcyBzcGVjaWZpZWQuJyk7XG4gICAgICAgIH1cblxuICAgICAgICBfbGluZUFsaWduID0gc2V0dGluZztcbiAgICAgICAgdGhpcy5oYXNCZWVuUmVzZXQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pKTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLCAncG9zaXRpb24nLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gX3Bvc2l0aW9uO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA8IDAgfHwgdmFsdWUgPiAxMDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Bvc2l0aW9uIG11c3QgYmUgYmV0d2VlbiAwIGFuZCAxMDAuJyk7XG4gICAgICAgIH1cblxuICAgICAgICBfcG9zaXRpb24gPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5oYXNCZWVuUmVzZXQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pKTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLCAncG9zaXRpb25BbGlnbicsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBfcG9zaXRpb25BbGlnbjtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICB2YXIgc2V0dGluZyA9IGZpbmRBbGlnblNldHRpbmcodmFsdWUpO1xuXG4gICAgICAgIGlmICghc2V0dGluZykge1xuICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignQW4gaW52YWxpZCBvciBpbGxlZ2FsIHN0cmluZyB3YXMgc3BlY2lmaWVkLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgX3Bvc2l0aW9uQWxpZ24gPSBzZXR0aW5nO1xuICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XG4gICAgICB9XG4gICAgfSkpO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsICdzaXplJywgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIF9zaXplO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA8IDAgfHwgdmFsdWUgPiAxMDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NpemUgbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDEwMC4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIF9zaXplID0gdmFsdWU7XG4gICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSwgJ2FsaWduJywgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIF9hbGlnbjtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICB2YXIgc2V0dGluZyA9IGZpbmRBbGlnblNldHRpbmcodmFsdWUpO1xuXG4gICAgICAgIGlmICghc2V0dGluZykge1xuICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignQW4gaW52YWxpZCBvciBpbGxlZ2FsIHN0cmluZyB3YXMgc3BlY2lmaWVkLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgX2FsaWduID0gc2V0dGluZztcbiAgICAgICAgdGhpcy5oYXNCZWVuUmVzZXQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pKTtcbiAgICAvKipcbiAgICAgKiBPdGhlciA8dHJhY2s+IHNwZWMgZGVmaW5lZCBwcm9wZXJ0aWVzXG4gICAgICovXG4gICAgLy8gaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvdGhlLXZpZGVvLWVsZW1lbnQuaHRtbCN0ZXh0LXRyYWNrLWN1ZS1kaXNwbGF5LXN0YXRlXG5cbiAgICBjdWUuZGlzcGxheVN0YXRlID0gdW5kZWZpbmVkO1xuICB9XG4gIC8qKlxuICAgKiBWVFRDdWUgbWV0aG9kc1xuICAgKi9cblxuXG4gIFZUVEN1ZS5wcm90b3R5cGUuZ2V0Q3VlQXNIVE1MID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIEFzc3VtZSBXZWJWVFQuY29udmVydEN1ZVRvRE9NVHJlZSBpcyBvbiB0aGUgZ2xvYmFsLlxuICAgIHZhciBXZWJWVFQgPSBzZWxmLldlYlZUVDtcbiAgICByZXR1cm4gV2ViVlRULmNvbnZlcnRDdWVUb0RPTVRyZWUoc2VsZiwgdGhpcy50ZXh0KTtcbiAgfTsgLy8gdGhpcyBpcyBhIHBvbHlmaWxsIGhhY2tcblxuXG4gIHJldHVybiBWVFRDdWU7XG59KSgpKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvdXRpbHMvdnR0cGFyc2VyLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy91dGlscy92dHRwYXJzZXIudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IHBhcnNlVGltZVN0YW1wLCBmaXhMaW5lQnJlYWtzLCBWVFRQYXJzZXIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwicGFyc2VUaW1lU3RhbXBcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBwYXJzZVRpbWVTdGFtcDsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZml4TGluZUJyZWFrc1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGZpeExpbmVCcmVha3M7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlZUVFBhcnNlclwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIFZUVFBhcnNlcjsgfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3Z0dGN1ZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi92dHRjdWUgKi8gXCIuL3NyYy91dGlscy92dHRjdWUudHNcIik7XG4vKlxuICogU291cmNlOiBodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS92dHQuanMvYmxvYi9tYXN0ZXIvZGlzdC92dHQuanNcbiAqL1xuXG5cbnZhciBTdHJpbmdEZWNvZGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gU3RyaW5nRGVjb2RlcigpIHt9XG5cbiAgdmFyIF9wcm90byA9IFN0cmluZ0RlY29kZXIucHJvdG90eXBlO1xuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgX3Byb3RvLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShkYXRhLCBvcHRpb25zKSB7XG4gICAgaWYgKCFkYXRhKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBkYXRhICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFcnJvciAtIGV4cGVjdGVkIHN0cmluZyBkYXRhLicpO1xuICAgIH1cblxuICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoZW5jb2RlVVJJQ29tcG9uZW50KGRhdGEpKTtcbiAgfTtcblxuICByZXR1cm4gU3RyaW5nRGVjb2Rlcjtcbn0oKTsgLy8gVHJ5IHRvIHBhcnNlIGlucHV0IGFzIGEgdGltZSBzdGFtcC5cblxuXG5mdW5jdGlvbiBwYXJzZVRpbWVTdGFtcChpbnB1dCkge1xuICBmdW5jdGlvbiBjb21wdXRlU2Vjb25kcyhoLCBtLCBzLCBmKSB7XG4gICAgcmV0dXJuIChoIHwgMCkgKiAzNjAwICsgKG0gfCAwKSAqIDYwICsgKHMgfCAwKSArIHBhcnNlRmxvYXQoZiB8fCAwKTtcbiAgfVxuXG4gIHZhciBtID0gaW5wdXQubWF0Y2goL14oPzooXFxkKyk6KT8oXFxkezJ9KTooXFxkezJ9KShcXC5cXGQrKT8vKTtcblxuICBpZiAoIW0pIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmIChwYXJzZUZsb2F0KG1bMl0pID4gNTkpIHtcbiAgICAvLyBUaW1lc3RhbXAgdGFrZXMgdGhlIGZvcm0gb2YgW2hvdXJzXTpbbWludXRlc10uW21pbGxpc2Vjb25kc11cbiAgICAvLyBGaXJzdCBwb3NpdGlvbiBpcyBob3VycyBhcyBpdCdzIG92ZXIgNTkuXG4gICAgcmV0dXJuIGNvbXB1dGVTZWNvbmRzKG1bMl0sIG1bM10sIDAsIG1bNF0pO1xuICB9IC8vIFRpbWVzdGFtcCB0YWtlcyB0aGUgZm9ybSBvZiBbaG91cnMgKG9wdGlvbmFsKV06W21pbnV0ZXNdOltzZWNvbmRzXS5bbWlsbGlzZWNvbmRzXVxuXG5cbiAgcmV0dXJuIGNvbXB1dGVTZWNvbmRzKG1bMV0sIG1bMl0sIG1bM10sIG1bNF0pO1xufSAvLyBBIHNldHRpbmdzIG9iamVjdCBob2xkcyBrZXkvdmFsdWUgcGFpcnMgYW5kIHdpbGwgaWdub3JlIGFueXRoaW5nIGJ1dCB0aGUgZmlyc3Rcbi8vIGFzc2lnbm1lbnQgdG8gYSBzcGVjaWZpYyBrZXkuXG5cbnZhciBTZXR0aW5ncyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFNldHRpbmdzKCkge1xuICAgIHRoaXMudmFsdWVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgfVxuXG4gIHZhciBfcHJvdG8yID0gU2V0dGluZ3MucHJvdG90eXBlO1xuXG4gIC8vIE9ubHkgYWNjZXB0IHRoZSBmaXJzdCBhc3NpZ25tZW50IHRvIGFueSBrZXkuXG4gIF9wcm90bzIuc2V0ID0gZnVuY3Rpb24gc2V0KGssIHYpIHtcbiAgICBpZiAoIXRoaXMuZ2V0KGspICYmIHYgIT09ICcnKSB7XG4gICAgICB0aGlzLnZhbHVlc1trXSA9IHY7XG4gICAgfVxuICB9IC8vIFJldHVybiB0aGUgdmFsdWUgZm9yIGEga2V5LCBvciBhIGRlZmF1bHQgdmFsdWUuXG4gIC8vIElmICdkZWZhdWx0S2V5JyBpcyBwYXNzZWQgdGhlbiAnZGZsdCcgaXMgYXNzdW1lZCB0byBiZSBhbiBvYmplY3Qgd2l0aFxuICAvLyBhIG51bWJlciBvZiBwb3NzaWJsZSBkZWZhdWx0IHZhbHVlcyBhcyBwcm9wZXJ0aWVzIHdoZXJlICdkZWZhdWx0S2V5JyBpc1xuICAvLyB0aGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0aGF0IHdpbGwgYmUgY2hvc2VuOyBvdGhlcndpc2UgaXQncyBhc3N1bWVkIHRvIGJlXG4gIC8vIGEgc2luZ2xlIHZhbHVlLlxuICA7XG5cbiAgX3Byb3RvMi5nZXQgPSBmdW5jdGlvbiBnZXQoaywgZGZsdCwgZGVmYXVsdEtleSkge1xuICAgIGlmIChkZWZhdWx0S2V5KSB7XG4gICAgICByZXR1cm4gdGhpcy5oYXMoaykgPyB0aGlzLnZhbHVlc1trXSA6IGRmbHRbZGVmYXVsdEtleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuaGFzKGspID8gdGhpcy52YWx1ZXNba10gOiBkZmx0O1xuICB9IC8vIENoZWNrIHdoZXRoZXIgd2UgaGF2ZSBhIHZhbHVlIGZvciBhIGtleS5cbiAgO1xuXG4gIF9wcm90bzIuaGFzID0gZnVuY3Rpb24gaGFzKGspIHtcbiAgICByZXR1cm4gayBpbiB0aGlzLnZhbHVlcztcbiAgfSAvLyBBY2NlcHQgYSBzZXR0aW5nIGlmIGl0cyBvbmUgb2YgdGhlIGdpdmVuIGFsdGVybmF0aXZlcy5cbiAgO1xuXG4gIF9wcm90bzIuYWx0ID0gZnVuY3Rpb24gYWx0KGssIHYsIGEpIHtcbiAgICBmb3IgKHZhciBuID0gMDsgbiA8IGEubGVuZ3RoOyArK24pIHtcbiAgICAgIGlmICh2ID09PSBhW25dKSB7XG4gICAgICAgIHRoaXMuc2V0KGssIHYpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gQWNjZXB0IGEgc2V0dGluZyBpZiBpdHMgYSB2YWxpZCAoc2lnbmVkKSBpbnRlZ2VyLlxuICA7XG5cbiAgX3Byb3RvMi5pbnRlZ2VyID0gZnVuY3Rpb24gaW50ZWdlcihrLCB2KSB7XG4gICAgaWYgKC9eLT9cXGQrJC8udGVzdCh2KSkge1xuICAgICAgLy8gaW50ZWdlclxuICAgICAgdGhpcy5zZXQoaywgcGFyc2VJbnQodiwgMTApKTtcbiAgICB9XG4gIH0gLy8gQWNjZXB0IGEgc2V0dGluZyBpZiBpdHMgYSB2YWxpZCBwZXJjZW50YWdlLlxuICA7XG5cbiAgX3Byb3RvMi5wZXJjZW50ID0gZnVuY3Rpb24gcGVyY2VudChrLCB2KSB7XG4gICAgaWYgKC9eKFtcXGRdezEsM30pKFxcLltcXGRdKik/JSQvLnRlc3QodikpIHtcbiAgICAgIHZhciBwZXJjZW50ID0gcGFyc2VGbG9hdCh2KTtcblxuICAgICAgaWYgKHBlcmNlbnQgPj0gMCAmJiBwZXJjZW50IDw9IDEwMCkge1xuICAgICAgICB0aGlzLnNldChrLCBwZXJjZW50KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIHJldHVybiBTZXR0aW5ncztcbn0oKTsgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIHBhcnNlIGlucHV0IGludG8gZ3JvdXBzIHNlcGFyYXRlZCBieSAnZ3JvdXBEZWxpbScsIGFuZFxuLy8gaW50ZXJwcmV0IGVhY2ggZ3JvdXAgYXMgYSBrZXkvdmFsdWUgcGFpciBzZXBhcmF0ZWQgYnkgJ2tleVZhbHVlRGVsaW0nLlxuXG5cbmZ1bmN0aW9uIHBhcnNlT3B0aW9ucyhpbnB1dCwgY2FsbGJhY2ssIGtleVZhbHVlRGVsaW0sIGdyb3VwRGVsaW0pIHtcbiAgdmFyIGdyb3VwcyA9IGdyb3VwRGVsaW0gPyBpbnB1dC5zcGxpdChncm91cERlbGltKSA6IFtpbnB1dF07XG5cbiAgZm9yICh2YXIgaSBpbiBncm91cHMpIHtcbiAgICBpZiAodHlwZW9mIGdyb3Vwc1tpXSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHZhciBrdiA9IGdyb3Vwc1tpXS5zcGxpdChrZXlWYWx1ZURlbGltKTtcblxuICAgIGlmIChrdi5sZW5ndGggIT09IDIpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHZhciBfayA9IGt2WzBdO1xuICAgIHZhciBfdiA9IGt2WzFdO1xuICAgIGNhbGxiYWNrKF9rLCBfdik7XG4gIH1cbn1cblxudmFyIGRlZmF1bHRzID0gbmV3IF92dHRjdWVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImRlZmF1bHRcIl0oMCwgMCwgJycpOyAvLyAnbWlkZGxlJyB3YXMgY2hhbmdlZCB0byAnY2VudGVyJyBpbiB0aGUgc3BlYzogaHR0cHM6Ly9naXRodWIuY29tL3czYy93ZWJ2dHQvcHVsbC8yNDRcbi8vICBTYWZhcmkgZG9lc24ndCB5ZXQgc3VwcG9ydCB0aGlzIGNoYW5nZSwgYnV0IEZGIGFuZCBDaHJvbWUgZG8uXG5cbnZhciBjZW50ZXIgPSBkZWZhdWx0cy5hbGlnbiA9PT0gJ21pZGRsZScgPyAnbWlkZGxlJyA6ICdjZW50ZXInO1xuXG5mdW5jdGlvbiBwYXJzZUN1ZShpbnB1dCwgY3VlLCByZWdpb25MaXN0KSB7XG4gIC8vIFJlbWVtYmVyIHRoZSBvcmlnaW5hbCBpbnB1dCBpZiB3ZSBuZWVkIHRvIHRocm93IGFuIGVycm9yLlxuICB2YXIgb0lucHV0ID0gaW5wdXQ7IC8vIDQuMSBXZWJWVFQgdGltZXN0YW1wXG5cbiAgZnVuY3Rpb24gY29uc3VtZVRpbWVTdGFtcCgpIHtcbiAgICB2YXIgdHMgPSBwYXJzZVRpbWVTdGFtcChpbnB1dCk7XG5cbiAgICBpZiAodHMgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTWFsZm9ybWVkIHRpbWVzdGFtcDogJyArIG9JbnB1dCk7XG4gICAgfSAvLyBSZW1vdmUgdGltZSBzdGFtcCBmcm9tIGlucHV0LlxuXG5cbiAgICBpbnB1dCA9IGlucHV0LnJlcGxhY2UoL15bXlxcc2EtekEtWi1dKy8sICcnKTtcbiAgICByZXR1cm4gdHM7XG4gIH0gLy8gNC40LjIgV2ViVlRUIGN1ZSBzZXR0aW5nc1xuXG5cbiAgZnVuY3Rpb24gY29uc3VtZUN1ZVNldHRpbmdzKGlucHV0LCBjdWUpIHtcbiAgICB2YXIgc2V0dGluZ3MgPSBuZXcgU2V0dGluZ3MoKTtcbiAgICBwYXJzZU9wdGlvbnMoaW5wdXQsIGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgICB2YXIgdmFscztcblxuICAgICAgc3dpdGNoIChrKSB7XG4gICAgICAgIGNhc2UgJ3JlZ2lvbic6XG4gICAgICAgICAgLy8gRmluZCB0aGUgbGFzdCByZWdpb24gd2UgcGFyc2VkIHdpdGggdGhlIHNhbWUgcmVnaW9uIGlkLlxuICAgICAgICAgIGZvciAodmFyIGkgPSByZWdpb25MaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBpZiAocmVnaW9uTGlzdFtpXS5pZCA9PT0gdikge1xuICAgICAgICAgICAgICBzZXR0aW5ncy5zZXQoaywgcmVnaW9uTGlzdFtpXS5yZWdpb24pO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICd2ZXJ0aWNhbCc6XG4gICAgICAgICAgc2V0dGluZ3MuYWx0KGssIHYsIFsncmwnLCAnbHInXSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnbGluZSc6XG4gICAgICAgICAgdmFscyA9IHYuc3BsaXQoJywnKTtcbiAgICAgICAgICBzZXR0aW5ncy5pbnRlZ2VyKGssIHZhbHNbMF0pO1xuXG4gICAgICAgICAgaWYgKHNldHRpbmdzLnBlcmNlbnQoaywgdmFsc1swXSkpIHtcbiAgICAgICAgICAgIHNldHRpbmdzLnNldCgnc25hcFRvTGluZXMnLCBmYWxzZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc2V0dGluZ3MuYWx0KGssIHZhbHNbMF0sIFsnYXV0byddKTtcblxuICAgICAgICAgIGlmICh2YWxzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgc2V0dGluZ3MuYWx0KCdsaW5lQWxpZ24nLCB2YWxzWzFdLCBbJ3N0YXJ0JywgY2VudGVyLCAnZW5kJ10pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3Bvc2l0aW9uJzpcbiAgICAgICAgICB2YWxzID0gdi5zcGxpdCgnLCcpO1xuICAgICAgICAgIHNldHRpbmdzLnBlcmNlbnQoaywgdmFsc1swXSk7XG5cbiAgICAgICAgICBpZiAodmFscy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgIHNldHRpbmdzLmFsdCgncG9zaXRpb25BbGlnbicsIHZhbHNbMV0sIFsnc3RhcnQnLCBjZW50ZXIsICdlbmQnLCAnbGluZS1sZWZ0JywgJ2xpbmUtcmlnaHQnLCAnYXV0byddKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdzaXplJzpcbiAgICAgICAgICBzZXR0aW5ncy5wZXJjZW50KGssIHYpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2FsaWduJzpcbiAgICAgICAgICBzZXR0aW5ncy5hbHQoaywgdiwgWydzdGFydCcsIGNlbnRlciwgJ2VuZCcsICdsZWZ0JywgJ3JpZ2h0J10pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0sIC86LywgL1xccy8pOyAvLyBBcHBseSBkZWZhdWx0IHZhbHVlcyBmb3IgYW55IG1pc3NpbmcgZmllbGRzLlxuXG4gICAgY3VlLnJlZ2lvbiA9IHNldHRpbmdzLmdldCgncmVnaW9uJywgbnVsbCk7XG4gICAgY3VlLnZlcnRpY2FsID0gc2V0dGluZ3MuZ2V0KCd2ZXJ0aWNhbCcsICcnKTtcbiAgICB2YXIgbGluZSA9IHNldHRpbmdzLmdldCgnbGluZScsICdhdXRvJyk7XG5cbiAgICBpZiAobGluZSA9PT0gJ2F1dG8nICYmIGRlZmF1bHRzLmxpbmUgPT09IC0xKSB7XG4gICAgICAvLyBzZXQgbnVtZXJpYyBsaW5lIG51bWJlciBmb3IgU2FmYXJpXG4gICAgICBsaW5lID0gLTE7XG4gICAgfVxuXG4gICAgY3VlLmxpbmUgPSBsaW5lO1xuICAgIGN1ZS5saW5lQWxpZ24gPSBzZXR0aW5ncy5nZXQoJ2xpbmVBbGlnbicsICdzdGFydCcpO1xuICAgIGN1ZS5zbmFwVG9MaW5lcyA9IHNldHRpbmdzLmdldCgnc25hcFRvTGluZXMnLCB0cnVlKTtcbiAgICBjdWUuc2l6ZSA9IHNldHRpbmdzLmdldCgnc2l6ZScsIDEwMCk7XG4gICAgY3VlLmFsaWduID0gc2V0dGluZ3MuZ2V0KCdhbGlnbicsIGNlbnRlcik7XG4gICAgdmFyIHBvc2l0aW9uID0gc2V0dGluZ3MuZ2V0KCdwb3NpdGlvbicsICdhdXRvJyk7XG5cbiAgICBpZiAocG9zaXRpb24gPT09ICdhdXRvJyAmJiBkZWZhdWx0cy5wb3NpdGlvbiA9PT0gNTApIHtcbiAgICAgIC8vIHNldCBudW1lcmljIHBvc2l0aW9uIGZvciBTYWZhcmlcbiAgICAgIHBvc2l0aW9uID0gY3VlLmFsaWduID09PSAnc3RhcnQnIHx8IGN1ZS5hbGlnbiA9PT0gJ2xlZnQnID8gMCA6IGN1ZS5hbGlnbiA9PT0gJ2VuZCcgfHwgY3VlLmFsaWduID09PSAncmlnaHQnID8gMTAwIDogNTA7XG4gICAgfVxuXG4gICAgY3VlLnBvc2l0aW9uID0gcG9zaXRpb247XG4gIH1cblxuICBmdW5jdGlvbiBza2lwV2hpdGVzcGFjZSgpIHtcbiAgICBpbnB1dCA9IGlucHV0LnJlcGxhY2UoL15cXHMrLywgJycpO1xuICB9IC8vIDQuMSBXZWJWVFQgY3VlIHRpbWluZ3MuXG5cblxuICBza2lwV2hpdGVzcGFjZSgpO1xuICBjdWUuc3RhcnRUaW1lID0gY29uc3VtZVRpbWVTdGFtcCgpOyAvLyAoMSkgY29sbGVjdCBjdWUgc3RhcnQgdGltZVxuXG4gIHNraXBXaGl0ZXNwYWNlKCk7XG5cbiAgaWYgKGlucHV0LnN1YnN0cigwLCAzKSAhPT0gJy0tPicpIHtcbiAgICAvLyAoMykgbmV4dCBjaGFyYWN0ZXJzIG11c3QgbWF0Y2ggJy0tPidcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJNYWxmb3JtZWQgdGltZSBzdGFtcCAodGltZSBzdGFtcHMgbXVzdCBiZSBzZXBhcmF0ZWQgYnkgJy0tPicpOiBcIiArIG9JbnB1dCk7XG4gIH1cblxuICBpbnB1dCA9IGlucHV0LnN1YnN0cigzKTtcbiAgc2tpcFdoaXRlc3BhY2UoKTtcbiAgY3VlLmVuZFRpbWUgPSBjb25zdW1lVGltZVN0YW1wKCk7IC8vICg1KSBjb2xsZWN0IGN1ZSBlbmQgdGltZVxuICAvLyA0LjEgV2ViVlRUIGN1ZSBzZXR0aW5ncyBsaXN0LlxuXG4gIHNraXBXaGl0ZXNwYWNlKCk7XG4gIGNvbnN1bWVDdWVTZXR0aW5ncyhpbnB1dCwgY3VlKTtcbn1cblxuZnVuY3Rpb24gZml4TGluZUJyZWFrcyhpbnB1dCkge1xuICByZXR1cm4gaW5wdXQucmVwbGFjZSgvPGJyKD86IFxcLyk/Pi9naSwgJ1xcbicpO1xufVxudmFyIFZUVFBhcnNlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFZUVFBhcnNlcigpIHtcbiAgICB0aGlzLnN0YXRlID0gJ0lOSVRJQUwnO1xuICAgIHRoaXMuYnVmZmVyID0gJyc7XG4gICAgdGhpcy5kZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIoKTtcbiAgICB0aGlzLnJlZ2lvbkxpc3QgPSBbXTtcbiAgICB0aGlzLmN1ZSA9IG51bGw7XG4gICAgdGhpcy5vbmN1ZSA9IHZvaWQgMDtcbiAgICB0aGlzLm9ucGFyc2luZ2Vycm9yID0gdm9pZCAwO1xuICAgIHRoaXMub25mbHVzaCA9IHZvaWQgMDtcbiAgfVxuXG4gIHZhciBfcHJvdG8zID0gVlRUUGFyc2VyLnByb3RvdHlwZTtcblxuICBfcHJvdG8zLnBhcnNlID0gZnVuY3Rpb24gcGFyc2UoZGF0YSkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7IC8vIElmIHRoZXJlIGlzIG5vIGRhdGEgdGhlbiB3ZSB3b24ndCBkZWNvZGUgaXQsIGJ1dCB3aWxsIGp1c3QgdHJ5IHRvIHBhcnNlXG4gICAgLy8gd2hhdGV2ZXIgaXMgaW4gYnVmZmVyIGFscmVhZHkuIFRoaXMgbWF5IG9jY3VyIGluIGNpcmN1bXN0YW5jZXMsIGZvclxuICAgIC8vIGV4YW1wbGUgd2hlbiBmbHVzaCgpIGlzIGNhbGxlZC5cblxuXG4gICAgaWYgKGRhdGEpIHtcbiAgICAgIC8vIFRyeSB0byBkZWNvZGUgdGhlIGRhdGEgdGhhdCB3ZSByZWNlaXZlZC5cbiAgICAgIF90aGlzLmJ1ZmZlciArPSBfdGhpcy5kZWNvZGVyLmRlY29kZShkYXRhLCB7XG4gICAgICAgIHN0cmVhbTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29sbGVjdE5leHRMaW5lKCkge1xuICAgICAgdmFyIGJ1ZmZlciA9IF90aGlzLmJ1ZmZlcjtcbiAgICAgIHZhciBwb3MgPSAwO1xuICAgICAgYnVmZmVyID0gZml4TGluZUJyZWFrcyhidWZmZXIpO1xuXG4gICAgICB3aGlsZSAocG9zIDwgYnVmZmVyLmxlbmd0aCAmJiBidWZmZXJbcG9zXSAhPT0gJ1xccicgJiYgYnVmZmVyW3Bvc10gIT09ICdcXG4nKSB7XG4gICAgICAgICsrcG9zO1xuICAgICAgfVxuXG4gICAgICB2YXIgbGluZSA9IGJ1ZmZlci5zdWJzdHIoMCwgcG9zKTsgLy8gQWR2YW5jZSB0aGUgYnVmZmVyIGVhcmx5IGluIGNhc2Ugd2UgZmFpbCBiZWxvdy5cblxuICAgICAgaWYgKGJ1ZmZlcltwb3NdID09PSAnXFxyJykge1xuICAgICAgICArK3BvcztcbiAgICAgIH1cblxuICAgICAgaWYgKGJ1ZmZlcltwb3NdID09PSAnXFxuJykge1xuICAgICAgICArK3BvcztcbiAgICAgIH1cblxuICAgICAgX3RoaXMuYnVmZmVyID0gYnVmZmVyLnN1YnN0cihwb3MpO1xuICAgICAgcmV0dXJuIGxpbmU7XG4gICAgfSAvLyAzLjIgV2ViVlRUIG1ldGFkYXRhIGhlYWRlciBzeW50YXhcblxuXG4gICAgZnVuY3Rpb24gcGFyc2VIZWFkZXIoaW5wdXQpIHtcbiAgICAgIHBhcnNlT3B0aW9ucyhpbnB1dCwgZnVuY3Rpb24gKGssIHYpIHsvLyBzd2l0Y2ggKGspIHtcbiAgICAgICAgLy8gY2FzZSAncmVnaW9uJzpcbiAgICAgICAgLy8gMy4zIFdlYlZUVCByZWdpb24gbWV0YWRhdGEgaGVhZGVyIHN5bnRheFxuICAgICAgICAvLyBjb25zb2xlLmxvZygncGFyc2UgcmVnaW9uJywgdik7XG4gICAgICAgIC8vIHBhcnNlUmVnaW9uKHYpO1xuICAgICAgICAvLyBicmVhaztcbiAgICAgICAgLy8gfVxuICAgICAgfSwgLzovKTtcbiAgICB9IC8vIDUuMSBXZWJWVFQgZmlsZSBwYXJzaW5nLlxuXG5cbiAgICB0cnkge1xuICAgICAgdmFyIGxpbmUgPSAnJztcblxuICAgICAgaWYgKF90aGlzLnN0YXRlID09PSAnSU5JVElBTCcpIHtcbiAgICAgICAgLy8gV2UgY2FuJ3Qgc3RhcnQgcGFyc2luZyB1bnRpbCB3ZSBoYXZlIHRoZSBmaXJzdCBsaW5lLlxuICAgICAgICBpZiAoIS9cXHJcXG58XFxuLy50ZXN0KF90aGlzLmJ1ZmZlcikpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIGxpbmUgPSBjb2xsZWN0TmV4dExpbmUoKTsgLy8gc3RyaXAgb2YgVVRGLTggQk9NIGlmIGFueVxuICAgICAgICAvLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CeXRlX29yZGVyX21hcmsjVVRGLThcblxuICAgICAgICB2YXIgbSA9IGxpbmUubWF0Y2goL14ow6/Cu8K/KT9XRUJWVFQoWyBcXHRdLiopPyQvKTtcblxuICAgICAgICBpZiAoIW0gfHwgIW1bMF0pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01hbGZvcm1lZCBXZWJWVFQgc2lnbmF0dXJlLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXMuc3RhdGUgPSAnSEVBREVSJztcbiAgICAgIH1cblxuICAgICAgdmFyIGFscmVhZHlDb2xsZWN0ZWRMaW5lID0gZmFsc2U7XG5cbiAgICAgIHdoaWxlIChfdGhpcy5idWZmZXIpIHtcbiAgICAgICAgLy8gV2UgY2FuJ3QgcGFyc2UgYSBsaW5lIHVudGlsIHdlIGhhdmUgdGhlIGZ1bGwgbGluZS5cbiAgICAgICAgaWYgKCEvXFxyXFxufFxcbi8udGVzdChfdGhpcy5idWZmZXIpKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWFscmVhZHlDb2xsZWN0ZWRMaW5lKSB7XG4gICAgICAgICAgbGluZSA9IGNvbGxlY3ROZXh0TGluZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFscmVhZHlDb2xsZWN0ZWRMaW5lID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBzd2l0Y2ggKF90aGlzLnN0YXRlKSB7XG4gICAgICAgICAgY2FzZSAnSEVBREVSJzpcbiAgICAgICAgICAgIC8vIDEzLTE4IC0gQWxsb3cgYSBoZWFkZXIgKG1ldGFkYXRhKSB1bmRlciB0aGUgV0VCVlRUIGxpbmUuXG4gICAgICAgICAgICBpZiAoLzovLnRlc3QobGluZSkpIHtcbiAgICAgICAgICAgICAgcGFyc2VIZWFkZXIobGluZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFsaW5lKSB7XG4gICAgICAgICAgICAgIC8vIEFuIGVtcHR5IGxpbmUgdGVybWluYXRlcyB0aGUgaGVhZGVyIGFuZCBzdGFydHMgdGhlIGJvZHkgKGN1ZXMpLlxuICAgICAgICAgICAgICBfdGhpcy5zdGF0ZSA9ICdJRCc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgICAgY2FzZSAnTk9URSc6XG4gICAgICAgICAgICAvLyBJZ25vcmUgTk9URSBibG9ja3MuXG4gICAgICAgICAgICBpZiAoIWxpbmUpIHtcbiAgICAgICAgICAgICAgX3RoaXMuc3RhdGUgPSAnSUQnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICAgIGNhc2UgJ0lEJzpcbiAgICAgICAgICAgIC8vIENoZWNrIGZvciB0aGUgc3RhcnQgb2YgTk9URSBibG9ja3MuXG4gICAgICAgICAgICBpZiAoL15OT1RFKCR8WyBcXHRdKS8udGVzdChsaW5lKSkge1xuICAgICAgICAgICAgICBfdGhpcy5zdGF0ZSA9ICdOT1RFJztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9IC8vIDE5LTI5IC0gQWxsb3cgYW55IG51bWJlciBvZiBsaW5lIHRlcm1pbmF0b3JzLCB0aGVuIGluaXRpYWxpemUgbmV3IGN1ZSB2YWx1ZXMuXG5cblxuICAgICAgICAgICAgaWYgKCFsaW5lKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfdGhpcy5jdWUgPSBuZXcgX3Z0dGN1ZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiZGVmYXVsdFwiXSgwLCAwLCAnJyk7XG4gICAgICAgICAgICBfdGhpcy5zdGF0ZSA9ICdDVUUnOyAvLyAzMC0zOSAtIENoZWNrIGlmIHNlbGYgbGluZSBjb250YWlucyBhbiBvcHRpb25hbCBpZGVudGlmaWVyIG9yIHRpbWluZyBkYXRhLlxuXG4gICAgICAgICAgICBpZiAobGluZS5pbmRleE9mKCctLT4nKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgX3RoaXMuY3VlLmlkID0gbGluZTtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBQcm9jZXNzIGxpbmUgYXMgc3RhcnQgb2YgYSBjdWUuXG5cbiAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG5cbiAgICAgICAgICBjYXNlICdDVUUnOlxuICAgICAgICAgICAgLy8gNDAgLSBDb2xsZWN0IGN1ZSB0aW1pbmdzIGFuZCBzZXR0aW5ncy5cbiAgICAgICAgICAgIGlmICghX3RoaXMuY3VlKSB7XG4gICAgICAgICAgICAgIF90aGlzLnN0YXRlID0gJ0JBRENVRSc7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBwYXJzZUN1ZShsaW5lLCBfdGhpcy5jdWUsIF90aGlzLnJlZ2lvbkxpc3QpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAvLyBJbiBjYXNlIG9mIGFuIGVycm9yIGlnbm9yZSByZXN0IG9mIHRoZSBjdWUuXG4gICAgICAgICAgICAgIF90aGlzLmN1ZSA9IG51bGw7XG4gICAgICAgICAgICAgIF90aGlzLnN0YXRlID0gJ0JBRENVRSc7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfdGhpcy5zdGF0ZSA9ICdDVUVURVhUJztcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgICAgY2FzZSAnQ1VFVEVYVCc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHZhciBoYXNTdWJzdHJpbmcgPSBsaW5lLmluZGV4T2YoJy0tPicpICE9PSAtMTsgLy8gMzQgLSBJZiB3ZSBoYXZlIGFuIGVtcHR5IGxpbmUgdGhlbiByZXBvcnQgdGhlIGN1ZS5cbiAgICAgICAgICAgICAgLy8gMzUgLSBJZiB3ZSBoYXZlIHRoZSBzcGVjaWFsIHN1YnN0cmluZyAnLS0+JyB0aGVuIHJlcG9ydCB0aGUgY3VlLFxuICAgICAgICAgICAgICAvLyBidXQgZG8gbm90IGNvbGxlY3QgdGhlIGxpbmUgYXMgd2UgbmVlZCB0byBwcm9jZXNzIHRoZSBjdXJyZW50XG4gICAgICAgICAgICAgIC8vIG9uZSBhcyBhIG5ldyBjdWUuXG5cbiAgICAgICAgICAgICAgaWYgKCFsaW5lIHx8IGhhc1N1YnN0cmluZyAmJiAoYWxyZWFkeUNvbGxlY3RlZExpbmUgPSB0cnVlKSkge1xuICAgICAgICAgICAgICAgIC8vIFdlIGFyZSBkb25lIHBhcnNpbmcgc2VsZiBjdWUuXG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLm9uY3VlICYmIF90aGlzLmN1ZSkge1xuICAgICAgICAgICAgICAgICAgX3RoaXMub25jdWUoX3RoaXMuY3VlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBfdGhpcy5jdWUgPSBudWxsO1xuICAgICAgICAgICAgICAgIF90aGlzLnN0YXRlID0gJ0lEJztcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChfdGhpcy5jdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChfdGhpcy5jdWUudGV4dCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmN1ZS50ZXh0ICs9ICdcXG4nO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgX3RoaXMuY3VlLnRleHQgKz0gbGluZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgICAgY2FzZSAnQkFEQ1VFJzpcbiAgICAgICAgICAgIC8vIDU0LTYyIC0gQ29sbGVjdCBhbmQgZGlzY2FyZCB0aGUgcmVtYWluaW5nIGN1ZS5cbiAgICAgICAgICAgIGlmICghbGluZSkge1xuICAgICAgICAgICAgICBfdGhpcy5zdGF0ZSA9ICdJRCc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIElmIHdlIGFyZSBjdXJyZW50bHkgcGFyc2luZyBhIGN1ZSwgcmVwb3J0IHdoYXQgd2UgaGF2ZS5cbiAgICAgIGlmIChfdGhpcy5zdGF0ZSA9PT0gJ0NVRVRFWFQnICYmIF90aGlzLmN1ZSAmJiBfdGhpcy5vbmN1ZSkge1xuICAgICAgICBfdGhpcy5vbmN1ZShfdGhpcy5jdWUpO1xuICAgICAgfVxuXG4gICAgICBfdGhpcy5jdWUgPSBudWxsOyAvLyBFbnRlciBCQURXRUJWVFQgc3RhdGUgaWYgaGVhZGVyIHdhcyBub3QgcGFyc2VkIGNvcnJlY3RseSBvdGhlcndpc2VcbiAgICAgIC8vIGFub3RoZXIgZXhjZXB0aW9uIG9jY3VycmVkIHNvIGVudGVyIEJBRENVRSBzdGF0ZS5cblxuICAgICAgX3RoaXMuc3RhdGUgPSBfdGhpcy5zdGF0ZSA9PT0gJ0lOSVRJQUwnID8gJ0JBRFdFQlZUVCcgOiAnQkFEQ1VFJztcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8zLmZsdXNoID0gZnVuY3Rpb24gZmx1c2goKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHRyeSB7XG4gICAgICAvLyBGaW5pc2ggZGVjb2RpbmcgdGhlIHN0cmVhbS5cbiAgICAgIC8vIF90aGlzLmJ1ZmZlciArPSBfdGhpcy5kZWNvZGVyLmRlY29kZSgpO1xuICAgICAgLy8gU3ludGhlc2l6ZSB0aGUgZW5kIG9mIHRoZSBjdXJyZW50IGN1ZSBvciByZWdpb24uXG4gICAgICBpZiAoX3RoaXMuY3VlIHx8IF90aGlzLnN0YXRlID09PSAnSEVBREVSJykge1xuICAgICAgICBfdGhpcy5idWZmZXIgKz0gJ1xcblxcbic7XG5cbiAgICAgICAgX3RoaXMucGFyc2UoKTtcbiAgICAgIH0gLy8gSWYgd2UndmUgZmx1c2hlZCwgcGFyc2VkLCBhbmQgd2UncmUgc3RpbGwgb24gdGhlIElOSVRJQUwgc3RhdGUgdGhlblxuICAgICAgLy8gdGhhdCBtZWFucyB3ZSBkb24ndCBoYXZlIGVub3VnaCBvZiB0aGUgc3RyZWFtIHRvIHBhcnNlIHRoZSBmaXJzdFxuICAgICAgLy8gbGluZS5cblxuXG4gICAgICBpZiAoX3RoaXMuc3RhdGUgPT09ICdJTklUSUFMJyB8fCBfdGhpcy5zdGF0ZSA9PT0gJ0JBRFdFQlZUVCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNYWxmb3JtZWQgV2ViVlRUIHNpZ25hdHVyZS4nKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoX3RoaXMub25wYXJzaW5nZXJyb3IpIHtcbiAgICAgICAgX3RoaXMub25wYXJzaW5nZXJyb3IoZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKF90aGlzLm9uZmx1c2gpIHtcbiAgICAgIF90aGlzLm9uZmx1c2goKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICByZXR1cm4gVlRUUGFyc2VyO1xufSgpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy91dGlscy93ZWJ2dHQtcGFyc2VyLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvdXRpbHMvd2VidnR0LXBhcnNlci50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGdlbmVyYXRlQ3VlSWQsIHBhcnNlV2ViVlRUICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImdlbmVyYXRlQ3VlSWRcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBnZW5lcmF0ZUN1ZUlkOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJwYXJzZVdlYlZUVFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHBhcnNlV2ViVlRUOyB9KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfaG9tZV9ydW5uZXJfd29ya19obHNfanNfaGxzX2pzX3NyY19wb2x5ZmlsbHNfbnVtYmVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3NyYy9wb2x5ZmlsbHMvbnVtYmVyICovIFwiLi9zcmMvcG9seWZpbGxzL251bWJlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdnR0cGFyc2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3Z0dHBhcnNlciAqLyBcIi4vc3JjL3V0aWxzL3Z0dHBhcnNlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZGVtdXhfaWQzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9kZW11eC9pZDMgKi8gXCIuL3NyYy9kZW11eC9pZDMudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3RpbWVzY2FsZV9jb252ZXJzaW9uX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3RpbWVzY2FsZS1jb252ZXJzaW9uICovIFwiLi9zcmMvdXRpbHMvdGltZXNjYWxlLWNvbnZlcnNpb24udHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3JlbXV4X21wNF9yZW11eGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9yZW11eC9tcDQtcmVtdXhlciAqLyBcIi4vc3JjL3JlbXV4L21wNC1yZW11eGVyLnRzXCIpO1xuXG5cblxuXG5cblxuXG5cbnZhciBMSU5FQlJFQUtTID0gL1xcclxcbnxcXG5cXHJ8XFxufFxcci9nOyAvLyBTdHJpbmcucHJvdG90eXBlLnN0YXJ0c1dpdGggaXMgbm90IHN1cHBvcnRlZCBpbiBJRTExXG5cbnZhciBzdGFydHNXaXRoID0gZnVuY3Rpb24gc3RhcnRzV2l0aChpbnB1dFN0cmluZywgc2VhcmNoU3RyaW5nLCBwb3NpdGlvbikge1xuICBpZiAocG9zaXRpb24gPT09IHZvaWQgMCkge1xuICAgIHBvc2l0aW9uID0gMDtcbiAgfVxuXG4gIHJldHVybiBpbnB1dFN0cmluZy5zdWJzdHIocG9zaXRpb24sIHNlYXJjaFN0cmluZy5sZW5ndGgpID09PSBzZWFyY2hTdHJpbmc7XG59O1xuXG52YXIgY3VlU3RyaW5nMm1pbGxpcyA9IGZ1bmN0aW9uIGN1ZVN0cmluZzJtaWxsaXModGltZVN0cmluZykge1xuICB2YXIgdHMgPSBwYXJzZUludCh0aW1lU3RyaW5nLnN1YnN0cigtMykpO1xuICB2YXIgc2VjcyA9IHBhcnNlSW50KHRpbWVTdHJpbmcuc3Vic3RyKC02LCAyKSk7XG4gIHZhciBtaW5zID0gcGFyc2VJbnQodGltZVN0cmluZy5zdWJzdHIoLTksIDIpKTtcbiAgdmFyIGhvdXJzID0gdGltZVN0cmluZy5sZW5ndGggPiA5ID8gcGFyc2VJbnQodGltZVN0cmluZy5zdWJzdHIoMCwgdGltZVN0cmluZy5pbmRleE9mKCc6JykpKSA6IDA7XG5cbiAgaWYgKCFPYmplY3QoX2hvbWVfcnVubmVyX3dvcmtfaGxzX2pzX2hsc19qc19zcmNfcG9seWZpbGxzX251bWJlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiaXNGaW5pdGVOdW1iZXJcIl0pKHRzKSB8fCAhT2JqZWN0KF9ob21lX3J1bm5lcl93b3JrX2hsc19qc19obHNfanNfc3JjX3BvbHlmaWxsc19udW1iZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImlzRmluaXRlTnVtYmVyXCJdKShzZWNzKSB8fCAhT2JqZWN0KF9ob21lX3J1bm5lcl93b3JrX2hsc19qc19obHNfanNfc3JjX3BvbHlmaWxsc19udW1iZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImlzRmluaXRlTnVtYmVyXCJdKShtaW5zKSB8fCAhT2JqZWN0KF9ob21lX3J1bm5lcl93b3JrX2hsc19qc19obHNfanNfc3JjX3BvbHlmaWxsc19udW1iZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImlzRmluaXRlTnVtYmVyXCJdKShob3VycykpIHtcbiAgICB0aHJvdyBFcnJvcihcIk1hbGZvcm1lZCBYLVRJTUVTVEFNUC1NQVA6IExvY2FsOlwiICsgdGltZVN0cmluZyk7XG4gIH1cblxuICB0cyArPSAxMDAwICogc2VjcztcbiAgdHMgKz0gNjAgKiAxMDAwICogbWlucztcbiAgdHMgKz0gNjAgKiA2MCAqIDEwMDAgKiBob3VycztcbiAgcmV0dXJuIHRzO1xufTsgLy8gRnJvbSBodHRwczovL2dpdGh1Yi5jb20vZGFya3NreWFwcC9zdHJpbmctaGFzaFxuXG5cbnZhciBoYXNoID0gZnVuY3Rpb24gaGFzaCh0ZXh0KSB7XG4gIHZhciBoYXNoID0gNTM4MTtcbiAgdmFyIGkgPSB0ZXh0Lmxlbmd0aDtcblxuICB3aGlsZSAoaSkge1xuICAgIGhhc2ggPSBoYXNoICogMzMgXiB0ZXh0LmNoYXJDb2RlQXQoLS1pKTtcbiAgfVxuXG4gIHJldHVybiAoaGFzaCA+Pj4gMCkudG9TdHJpbmcoKTtcbn07IC8vIENyZWF0ZSBhIHVuaXF1ZSBoYXNoIGlkIGZvciBhIGN1ZSBiYXNlZCBvbiBzdGFydC9lbmQgdGltZXMgYW5kIHRleHQuXG4vLyBUaGlzIGhlbHBzIHRpbWVsaW5lLWNvbnRyb2xsZXIgdG8gYXZvaWQgc2hvd2luZyByZXBlYXRlZCBjYXB0aW9ucy5cblxuXG5mdW5jdGlvbiBnZW5lcmF0ZUN1ZUlkKHN0YXJ0VGltZSwgZW5kVGltZSwgdGV4dCkge1xuICByZXR1cm4gaGFzaChzdGFydFRpbWUudG9TdHJpbmcoKSkgKyBoYXNoKGVuZFRpbWUudG9TdHJpbmcoKSkgKyBoYXNoKHRleHQpO1xufVxuXG52YXIgY2FsY3VsYXRlT2Zmc2V0ID0gZnVuY3Rpb24gY2FsY3VsYXRlT2Zmc2V0KHZ0dENDcywgY2MsIHByZXNlbnRhdGlvblRpbWUpIHtcbiAgdmFyIGN1cnJDQyA9IHZ0dENDc1tjY107XG4gIHZhciBwcmV2Q0MgPSB2dHRDQ3NbY3VyckNDLnByZXZDQ107IC8vIFRoaXMgaXMgdGhlIGZpcnN0IGRpc2NvbnRpbnVpdHkgb3IgY3VlcyBoYXZlIGJlZW4gcHJvY2Vzc2VkIHNpbmNlIHRoZSBsYXN0IGRpc2NvbnRpbnVpdHlcbiAgLy8gT2Zmc2V0ID0gY3VycmVudCBkaXNjb250aW51aXR5IHRpbWVcblxuICBpZiAoIXByZXZDQyB8fCAhcHJldkNDLm5ldyAmJiBjdXJyQ0MubmV3KSB7XG4gICAgdnR0Q0NzLmNjT2Zmc2V0ID0gdnR0Q0NzLnByZXNlbnRhdGlvbk9mZnNldCA9IGN1cnJDQy5zdGFydDtcbiAgICBjdXJyQ0MubmV3ID0gZmFsc2U7XG4gICAgcmV0dXJuO1xuICB9IC8vIFRoZXJlIGhhdmUgYmVlbiBkaXNjb250aW51aXRpZXMgc2luY2UgY3VlcyB3ZXJlIGxhc3QgcGFyc2VkLlxuICAvLyBPZmZzZXQgPSB0aW1lIGVsYXBzZWRcblxuXG4gIHdoaWxlICgoX3ByZXZDQyA9IHByZXZDQykgIT09IG51bGwgJiYgX3ByZXZDQyAhPT0gdm9pZCAwICYmIF9wcmV2Q0MubmV3KSB7XG4gICAgdmFyIF9wcmV2Q0M7XG5cbiAgICB2dHRDQ3MuY2NPZmZzZXQgKz0gY3VyckNDLnN0YXJ0IC0gcHJldkNDLnN0YXJ0O1xuICAgIGN1cnJDQy5uZXcgPSBmYWxzZTtcbiAgICBjdXJyQ0MgPSBwcmV2Q0M7XG4gICAgcHJldkNDID0gdnR0Q0NzW2N1cnJDQy5wcmV2Q0NdO1xuICB9XG5cbiAgdnR0Q0NzLnByZXNlbnRhdGlvbk9mZnNldCA9IHByZXNlbnRhdGlvblRpbWU7XG59O1xuXG5mdW5jdGlvbiBwYXJzZVdlYlZUVCh2dHRCeXRlQXJyYXksIGluaXRQVFMsIHRpbWVzY2FsZSwgdnR0Q0NzLCBjYywgdGltZU9mZnNldCwgY2FsbEJhY2ssIGVycm9yQ2FsbEJhY2spIHtcbiAgdmFyIHBhcnNlciA9IG5ldyBfdnR0cGFyc2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJWVFRQYXJzZXJcIl0oKTsgLy8gQ29udmVydCBieXRlQXJyYXkgaW50byBzdHJpbmcsIHJlcGxhY2luZyBhbnkgc29tZXdoYXQgZXhvdGljIGxpbmVmZWVkcyB3aXRoIFwiXFxuXCIsIHRoZW4gc3BsaXQgb24gdGhhdCBjaGFyYWN0ZXIuXG4gIC8vIFVpbnQ4QXJyYXkucHJvdG90eXBlLnJlZHVjZSBpcyBub3QgaW1wbGVtZW50ZWQgaW4gSUUxMVxuXG4gIHZhciB2dHRMaW5lcyA9IE9iamVjdChfZGVtdXhfaWQzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJ1dGY4QXJyYXlUb1N0clwiXSkobmV3IFVpbnQ4QXJyYXkodnR0Qnl0ZUFycmF5KSkudHJpbSgpLnJlcGxhY2UoTElORUJSRUFLUywgJ1xcbicpLnNwbGl0KCdcXG4nKTtcbiAgdmFyIGN1ZXMgPSBbXTtcbiAgdmFyIGluaXRQVFM5MEh6ID0gT2JqZWN0KF90aW1lc2NhbGVfY29udmVyc2lvbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1widG9NcGVnVHNDbG9ja0Zyb21UaW1lc2NhbGVcIl0pKGluaXRQVFMsIHRpbWVzY2FsZSk7XG4gIHZhciBjdWVUaW1lID0gJzAwOjAwLjAwMCc7XG4gIHZhciB0aW1lc3RhbXBNYXBNUEVHVFMgPSAwO1xuICB2YXIgdGltZXN0YW1wTWFwTE9DQUwgPSAwO1xuICB2YXIgcGFyc2luZ0Vycm9yO1xuICB2YXIgaW5IZWFkZXIgPSB0cnVlO1xuICB2YXIgdGltZXN0YW1wTWFwID0gZmFsc2U7XG5cbiAgcGFyc2VyLm9uY3VlID0gZnVuY3Rpb24gKGN1ZSkge1xuICAgIC8vIEFkanVzdCBjdWUgdGltaW5nOyBjbGFtcCBjdWVzIHRvIHN0YXJ0IG5vIGVhcmxpZXIgdGhhbiAtIGFuZCBkcm9wIGN1ZXMgdGhhdCBkb24ndCBlbmQgYWZ0ZXIgLSAwIG9uIHRpbWVsaW5lLlxuICAgIHZhciBjdXJyQ0MgPSB2dHRDQ3NbY2NdO1xuICAgIHZhciBjdWVPZmZzZXQgPSB2dHRDQ3MuY2NPZmZzZXQ7IC8vIENhbGN1bGF0ZSBzdWJ0aXRsZSBQVFMgb2Zmc2V0XG5cbiAgICB2YXIgd2ViVnR0TXBlZ1RzTWFwT2Zmc2V0ID0gKHRpbWVzdGFtcE1hcE1QRUdUUyAtIGluaXRQVFM5MEh6KSAvIDkwMDAwOyAvLyBVcGRhdGUgb2Zmc2V0cyBmb3IgbmV3IGRpc2NvbnRpbnVpdGllc1xuXG4gICAgaWYgKGN1cnJDQyAhPT0gbnVsbCAmJiBjdXJyQ0MgIT09IHZvaWQgMCAmJiBjdXJyQ0MubmV3KSB7XG4gICAgICBpZiAodGltZXN0YW1wTWFwTE9DQUwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBXaGVuIGxvY2FsIHRpbWUgaXMgcHJvdmlkZWQsIG9mZnNldCA9IGRpc2NvbnRpbnVpdHkgc3RhcnQgdGltZSAtIGxvY2FsIHRpbWVcbiAgICAgICAgY3VlT2Zmc2V0ID0gdnR0Q0NzLmNjT2Zmc2V0ID0gY3VyckNDLnN0YXJ0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FsY3VsYXRlT2Zmc2V0KHZ0dENDcywgY2MsIHdlYlZ0dE1wZWdUc01hcE9mZnNldCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHdlYlZ0dE1wZWdUc01hcE9mZnNldCkge1xuICAgICAgLy8gSWYgd2UgaGF2ZSBNUEVHVFMsIG9mZnNldCA9IHByZXNlbnRhdGlvbiB0aW1lICsgZGlzY29udGludWl0eSBvZmZzZXRcbiAgICAgIGN1ZU9mZnNldCA9IHdlYlZ0dE1wZWdUc01hcE9mZnNldCAtIHZ0dENDcy5wcmVzZW50YXRpb25PZmZzZXQ7XG4gICAgfVxuXG4gICAgaWYgKHRpbWVzdGFtcE1hcCkge1xuICAgICAgdmFyIGR1cmF0aW9uID0gY3VlLmVuZFRpbWUgLSBjdWUuc3RhcnRUaW1lO1xuICAgICAgdmFyIHN0YXJ0VGltZSA9IE9iamVjdChfcmVtdXhfbXA0X3JlbXV4ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1tcIm5vcm1hbGl6ZVB0c1wiXSkoKGN1ZS5zdGFydFRpbWUgKyBjdWVPZmZzZXQgLSB0aW1lc3RhbXBNYXBMT0NBTCkgKiA5MDAwMCwgdGltZU9mZnNldCAqIDkwMDAwKSAvIDkwMDAwO1xuICAgICAgY3VlLnN0YXJ0VGltZSA9IHN0YXJ0VGltZTtcbiAgICAgIGN1ZS5lbmRUaW1lID0gc3RhcnRUaW1lICsgZHVyYXRpb247XG4gICAgfSAvL3RyaW0gdHJhaWxpbmcgd2VidnR0IGJsb2NrIHdoaXRlc3BhY2VzXG5cblxuICAgIHZhciB0ZXh0ID0gY3VlLnRleHQudHJpbSgpOyAvLyBGaXggZW5jb2Rpbmcgb2Ygc3BlY2lhbCBjaGFyYWN0ZXJzXG5cbiAgICBjdWUudGV4dCA9IGRlY29kZVVSSUNvbXBvbmVudChlbmNvZGVVUklDb21wb25lbnQodGV4dCkpOyAvLyBJZiB0aGUgY3VlIHdhcyBub3QgYXNzaWduZWQgYW4gaWQgZnJvbSB0aGUgVlRUIGZpbGUgKGxpbmUgYWJvdmUgdGhlIGNvbnRlbnQpLCBjcmVhdGUgb25lLlxuXG4gICAgaWYgKCFjdWUuaWQpIHtcbiAgICAgIGN1ZS5pZCA9IGdlbmVyYXRlQ3VlSWQoY3VlLnN0YXJ0VGltZSwgY3VlLmVuZFRpbWUsIHRleHQpO1xuICAgIH1cblxuICAgIGlmIChjdWUuZW5kVGltZSA+IDApIHtcbiAgICAgIGN1ZXMucHVzaChjdWUpO1xuICAgIH1cbiAgfTtcblxuICBwYXJzZXIub25wYXJzaW5nZXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICBwYXJzaW5nRXJyb3IgPSBlcnJvcjtcbiAgfTtcblxuICBwYXJzZXIub25mbHVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAocGFyc2luZ0Vycm9yKSB7XG4gICAgICBlcnJvckNhbGxCYWNrKHBhcnNpbmdFcnJvcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY2FsbEJhY2soY3Vlcyk7XG4gIH07IC8vIEdvIHRocm91Z2ggY29udGVudHMgbGluZSBieSBsaW5lLlxuXG5cbiAgdnR0TGluZXMuZm9yRWFjaChmdW5jdGlvbiAobGluZSkge1xuICAgIGlmIChpbkhlYWRlcikge1xuICAgICAgLy8gTG9vayBmb3IgWC1USU1FU1RBTVAtTUFQIGluIGhlYWRlci5cbiAgICAgIGlmIChzdGFydHNXaXRoKGxpbmUsICdYLVRJTUVTVEFNUC1NQVA9JykpIHtcbiAgICAgICAgLy8gT25jZSBmb3VuZCwgbm8gbW9yZSBhcmUgYWxsb3dlZCBhbnl3YXksIHNvIHN0b3Agc2VhcmNoaW5nLlxuICAgICAgICBpbkhlYWRlciA9IGZhbHNlO1xuICAgICAgICB0aW1lc3RhbXBNYXAgPSB0cnVlOyAvLyBFeHRyYWN0IExPQ0FMIGFuZCBNUEVHVFMuXG5cbiAgICAgICAgbGluZS5zdWJzdHIoMTYpLnNwbGl0KCcsJykuZm9yRWFjaChmdW5jdGlvbiAodGltZXN0YW1wKSB7XG4gICAgICAgICAgaWYgKHN0YXJ0c1dpdGgodGltZXN0YW1wLCAnTE9DQUw6JykpIHtcbiAgICAgICAgICAgIGN1ZVRpbWUgPSB0aW1lc3RhbXAuc3Vic3RyKDYpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc3RhcnRzV2l0aCh0aW1lc3RhbXAsICdNUEVHVFM6JykpIHtcbiAgICAgICAgICAgIHRpbWVzdGFtcE1hcE1QRUdUUyA9IHBhcnNlSW50KHRpbWVzdGFtcC5zdWJzdHIoNykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBDb252ZXJ0IGN1ZSB0aW1lIHRvIHNlY29uZHNcbiAgICAgICAgICB0aW1lc3RhbXBNYXBMT0NBTCA9IGN1ZVN0cmluZzJtaWxsaXMoY3VlVGltZSkgLyAxMDAwO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIHRpbWVzdGFtcE1hcCA9IGZhbHNlO1xuICAgICAgICAgIHBhcnNpbmdFcnJvciA9IGVycm9yO1xuICAgICAgICB9IC8vIFJldHVybiB3aXRob3V0IHBhcnNpbmcgWC1USU1FU1RBTVAtTUFQIGxpbmUuXG5cblxuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2UgaWYgKGxpbmUgPT09ICcnKSB7XG4gICAgICAgIGluSGVhZGVyID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSAvLyBQYXJzZSBsaW5lIGJ5IGRlZmF1bHQuXG5cblxuICAgIHBhcnNlci5wYXJzZShsaW5lICsgJ1xcbicpO1xuICB9KTtcbiAgcGFyc2VyLmZsdXNoKCk7XG59XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3V0aWxzL3hoci1sb2FkZXIudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy91dGlscy94aHItbG9hZGVyLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9sb2dnZXIgKi8gXCIuL3NyYy91dGlscy9sb2dnZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2xvYWRlcl9sb2FkX3N0YXRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9sb2FkZXIvbG9hZC1zdGF0cyAqLyBcIi4vc3JjL2xvYWRlci9sb2FkLXN0YXRzLnRzXCIpO1xuXG5cbnZhciBBR0VfSEVBREVSX0xJTkVfUkVHRVggPSAvXmFnZTpcXHMqW1xcZC5dK1xccyokL207XG5cbnZhciBYaHJMb2FkZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBYaHJMb2FkZXIoY29uZmlnXG4gIC8qIEhsc0NvbmZpZyAqL1xuICApIHtcbiAgICB0aGlzLnhoclNldHVwID0gdm9pZCAwO1xuICAgIHRoaXMucmVxdWVzdFRpbWVvdXQgPSB2b2lkIDA7XG4gICAgdGhpcy5yZXRyeVRpbWVvdXQgPSB2b2lkIDA7XG4gICAgdGhpcy5yZXRyeURlbGF5ID0gdm9pZCAwO1xuICAgIHRoaXMuY29uZmlnID0gbnVsbDtcbiAgICB0aGlzLmNhbGxiYWNrcyA9IG51bGw7XG4gICAgdGhpcy5jb250ZXh0ID0gdm9pZCAwO1xuICAgIHRoaXMubG9hZGVyID0gbnVsbDtcbiAgICB0aGlzLnN0YXRzID0gdm9pZCAwO1xuICAgIHRoaXMueGhyU2V0dXAgPSBjb25maWcgPyBjb25maWcueGhyU2V0dXAgOiBudWxsO1xuICAgIHRoaXMuc3RhdHMgPSBuZXcgX2xvYWRlcl9sb2FkX3N0YXRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJMb2FkU3RhdHNcIl0oKTtcbiAgICB0aGlzLnJldHJ5RGVsYXkgPSAwO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFhockxvYWRlci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgIHRoaXMuY2FsbGJhY2tzID0gbnVsbDtcbiAgICB0aGlzLmFib3J0SW50ZXJuYWwoKTtcbiAgICB0aGlzLmxvYWRlciA9IG51bGw7XG4gICAgdGhpcy5jb25maWcgPSBudWxsO1xuICB9O1xuXG4gIF9wcm90by5hYm9ydEludGVybmFsID0gZnVuY3Rpb24gYWJvcnRJbnRlcm5hbCgpIHtcbiAgICB2YXIgbG9hZGVyID0gdGhpcy5sb2FkZXI7XG4gICAgc2VsZi5jbGVhclRpbWVvdXQodGhpcy5yZXF1ZXN0VGltZW91dCk7XG4gICAgc2VsZi5jbGVhclRpbWVvdXQodGhpcy5yZXRyeVRpbWVvdXQpO1xuXG4gICAgaWYgKGxvYWRlcikge1xuICAgICAgbG9hZGVyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG4gICAgICBsb2FkZXIub25wcm9ncmVzcyA9IG51bGw7XG5cbiAgICAgIGlmIChsb2FkZXIucmVhZHlTdGF0ZSAhPT0gNCkge1xuICAgICAgICB0aGlzLnN0YXRzLmFib3J0ZWQgPSB0cnVlO1xuICAgICAgICBsb2FkZXIuYWJvcnQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmFib3J0ID0gZnVuY3Rpb24gYWJvcnQoKSB7XG4gICAgdmFyIF90aGlzJGNhbGxiYWNrcztcblxuICAgIHRoaXMuYWJvcnRJbnRlcm5hbCgpO1xuXG4gICAgaWYgKChfdGhpcyRjYWxsYmFja3MgPSB0aGlzLmNhbGxiYWNrcykgIT09IG51bGwgJiYgX3RoaXMkY2FsbGJhY2tzICE9PSB2b2lkIDAgJiYgX3RoaXMkY2FsbGJhY2tzLm9uQWJvcnQpIHtcbiAgICAgIHRoaXMuY2FsbGJhY2tzLm9uQWJvcnQodGhpcy5zdGF0cywgdGhpcy5jb250ZXh0LCB0aGlzLmxvYWRlcik7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5sb2FkID0gZnVuY3Rpb24gbG9hZChjb250ZXh0LCBjb25maWcsIGNhbGxiYWNrcykge1xuICAgIGlmICh0aGlzLnN0YXRzLmxvYWRpbmcuc3RhcnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTG9hZGVyIGNhbiBvbmx5IGJlIHVzZWQgb25jZS4nKTtcbiAgICB9XG5cbiAgICB0aGlzLnN0YXRzLmxvYWRpbmcuc3RhcnQgPSBzZWxmLnBlcmZvcm1hbmNlLm5vdygpO1xuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgdGhpcy5jYWxsYmFja3MgPSBjYWxsYmFja3M7XG4gICAgdGhpcy5yZXRyeURlbGF5ID0gY29uZmlnLnJldHJ5RGVsYXk7XG4gICAgdGhpcy5sb2FkSW50ZXJuYWwoKTtcbiAgfTtcblxuICBfcHJvdG8ubG9hZEludGVybmFsID0gZnVuY3Rpb24gbG9hZEludGVybmFsKCkge1xuICAgIHZhciBjb25maWcgPSB0aGlzLmNvbmZpZyxcbiAgICAgICAgY29udGV4dCA9IHRoaXMuY29udGV4dDtcblxuICAgIGlmICghY29uZmlnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHhociA9IHRoaXMubG9hZGVyID0gbmV3IHNlbGYuWE1MSHR0cFJlcXVlc3QoKTtcbiAgICB2YXIgc3RhdHMgPSB0aGlzLnN0YXRzO1xuICAgIHN0YXRzLmxvYWRpbmcuZmlyc3QgPSAwO1xuICAgIHN0YXRzLmxvYWRlZCA9IDA7XG4gICAgdmFyIHhoclNldHVwID0gdGhpcy54aHJTZXR1cDtcblxuICAgIHRyeSB7XG4gICAgICBpZiAoeGhyU2V0dXApIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB4aHJTZXR1cCh4aHIsIGNvbnRleHQudXJsKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIC8vIGZpeCB4aHJTZXR1cDogKHhociwgdXJsKSA9PiB7eGhyLnNldFJlcXVlc3RIZWFkZXIoXCJDb250ZW50LUxhbmd1YWdlXCIsIFwidGVzdFwiKTt9XG4gICAgICAgICAgLy8gbm90IHdvcmtpbmcsIGFzIHhoci5zZXRSZXF1ZXN0SGVhZGVyIGV4cGVjdHMgeGhyLnJlYWR5U3RhdGUgPT09IE9QRU5cbiAgICAgICAgICB4aHIub3BlbignR0VUJywgY29udGV4dC51cmwsIHRydWUpO1xuICAgICAgICAgIHhoclNldHVwKHhociwgY29udGV4dC51cmwpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICgheGhyLnJlYWR5U3RhdGUpIHtcbiAgICAgICAgeGhyLm9wZW4oJ0dFVCcsIGNvbnRleHQudXJsLCB0cnVlKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGhlYWRlcnMgPSB0aGlzLmNvbnRleHQuaGVhZGVycztcblxuICAgICAgaWYgKGhlYWRlcnMpIHtcbiAgICAgICAgZm9yICh2YXIgaGVhZGVyIGluIGhlYWRlcnMpIHtcbiAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihoZWFkZXIsIGhlYWRlcnNbaGVhZGVyXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBJRTExIHRocm93cyBhbiBleGNlcHRpb24gb24geGhyLm9wZW4gaWYgYXR0ZW1wdGluZyB0byBhY2Nlc3MgYW4gSFRUUCByZXNvdXJjZSBvdmVyIEhUVFBTXG4gICAgICB0aGlzLmNhbGxiYWNrcy5vbkVycm9yKHtcbiAgICAgICAgY29kZTogeGhyLnN0YXR1cyxcbiAgICAgICAgdGV4dDogZS5tZXNzYWdlXG4gICAgICB9LCBjb250ZXh0LCB4aHIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChjb250ZXh0LnJhbmdlRW5kKSB7XG4gICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcignUmFuZ2UnLCAnYnl0ZXM9JyArIGNvbnRleHQucmFuZ2VTdGFydCArICctJyArIChjb250ZXh0LnJhbmdlRW5kIC0gMSkpO1xuICAgIH1cblxuICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSB0aGlzLnJlYWR5c3RhdGVjaGFuZ2UuYmluZCh0aGlzKTtcbiAgICB4aHIub25wcm9ncmVzcyA9IHRoaXMubG9hZHByb2dyZXNzLmJpbmQodGhpcyk7XG4gICAgeGhyLnJlc3BvbnNlVHlwZSA9IGNvbnRleHQucmVzcG9uc2VUeXBlOyAvLyBzZXR1cCB0aW1lb3V0IGJlZm9yZSB3ZSBwZXJmb3JtIHJlcXVlc3RcblxuICAgIHNlbGYuY2xlYXJUaW1lb3V0KHRoaXMucmVxdWVzdFRpbWVvdXQpO1xuICAgIHRoaXMucmVxdWVzdFRpbWVvdXQgPSBzZWxmLnNldFRpbWVvdXQodGhpcy5sb2FkdGltZW91dC5iaW5kKHRoaXMpLCBjb25maWcudGltZW91dCk7XG4gICAgeGhyLnNlbmQoKTtcbiAgfTtcblxuICBfcHJvdG8ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uIHJlYWR5c3RhdGVjaGFuZ2UoKSB7XG4gICAgdmFyIGNvbnRleHQgPSB0aGlzLmNvbnRleHQsXG4gICAgICAgIHhociA9IHRoaXMubG9hZGVyLFxuICAgICAgICBzdGF0cyA9IHRoaXMuc3RhdHM7XG5cbiAgICBpZiAoIWNvbnRleHQgfHwgIXhocikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciByZWFkeVN0YXRlID0geGhyLnJlYWR5U3RhdGU7XG4gICAgdmFyIGNvbmZpZyA9IHRoaXMuY29uZmlnOyAvLyBkb24ndCBwcm9jZWVkIGlmIHhociBoYXMgYmVlbiBhYm9ydGVkXG5cbiAgICBpZiAoc3RhdHMuYWJvcnRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gPj0gSEVBREVSU19SRUNFSVZFRFxuXG5cbiAgICBpZiAocmVhZHlTdGF0ZSA+PSAyKSB7XG4gICAgICAvLyBjbGVhciB4aHIgdGltZW91dCBhbmQgcmVhcm0gaXQgaWYgcmVhZHlTdGF0ZSBsZXNzIHRoYW4gNFxuICAgICAgc2VsZi5jbGVhclRpbWVvdXQodGhpcy5yZXF1ZXN0VGltZW91dCk7XG5cbiAgICAgIGlmIChzdGF0cy5sb2FkaW5nLmZpcnN0ID09PSAwKSB7XG4gICAgICAgIHN0YXRzLmxvYWRpbmcuZmlyc3QgPSBNYXRoLm1heChzZWxmLnBlcmZvcm1hbmNlLm5vdygpLCBzdGF0cy5sb2FkaW5nLnN0YXJ0KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlYWR5U3RhdGUgPT09IDQpIHtcbiAgICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG4gICAgICAgIHhoci5vbnByb2dyZXNzID0gbnVsbDtcbiAgICAgICAgdmFyIHN0YXR1cyA9IHhoci5zdGF0dXM7IC8vIGh0dHAgc3RhdHVzIGJldHdlZW4gMjAwIHRvIDI5OSBhcmUgYWxsIHN1Y2Nlc3NmdWxcblxuICAgICAgICBpZiAoc3RhdHVzID49IDIwMCAmJiBzdGF0dXMgPCAzMDApIHtcbiAgICAgICAgICBzdGF0cy5sb2FkaW5nLmVuZCA9IE1hdGgubWF4KHNlbGYucGVyZm9ybWFuY2Uubm93KCksIHN0YXRzLmxvYWRpbmcuZmlyc3QpO1xuICAgICAgICAgIHZhciBkYXRhO1xuICAgICAgICAgIHZhciBsZW47XG5cbiAgICAgICAgICBpZiAoY29udGV4dC5yZXNwb25zZVR5cGUgPT09ICdhcnJheWJ1ZmZlcicpIHtcbiAgICAgICAgICAgIGRhdGEgPSB4aHIucmVzcG9uc2U7XG4gICAgICAgICAgICBsZW4gPSBkYXRhLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRhdGEgPSB4aHIucmVzcG9uc2VUZXh0O1xuICAgICAgICAgICAgbGVuID0gZGF0YS5sZW5ndGg7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc3RhdHMubG9hZGVkID0gc3RhdHMudG90YWwgPSBsZW47XG5cbiAgICAgICAgICBpZiAoIXRoaXMuY2FsbGJhY2tzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIG9uUHJvZ3Jlc3MgPSB0aGlzLmNhbGxiYWNrcy5vblByb2dyZXNzO1xuXG4gICAgICAgICAgaWYgKG9uUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgIG9uUHJvZ3Jlc3Moc3RhdHMsIGNvbnRleHQsIGRhdGEsIHhocik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCF0aGlzLmNhbGxiYWNrcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciByZXNwb25zZSA9IHtcbiAgICAgICAgICAgIHVybDogeGhyLnJlc3BvbnNlVVJMLFxuICAgICAgICAgICAgZGF0YTogZGF0YVxuICAgICAgICAgIH07XG4gICAgICAgICAgdGhpcy5jYWxsYmFja3Mub25TdWNjZXNzKHJlc3BvbnNlLCBzdGF0cywgY29udGV4dCwgeGhyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBpZiBtYXggbmIgb2YgcmV0cmllcyByZWFjaGVkIG9yIGlmIGh0dHAgc3RhdHVzIGJldHdlZW4gNDAwIGFuZCA0OTkgKHN1Y2ggZXJyb3IgY2Fubm90IGJlIHJlY292ZXJlZCwgcmV0cnlpbmcgaXMgdXNlbGVzcyksIHJldHVybiBlcnJvclxuICAgICAgICAgIGlmIChzdGF0cy5yZXRyeSA+PSBjb25maWcubWF4UmV0cnkgfHwgc3RhdHVzID49IDQwMCAmJiBzdGF0dXMgPCA0OTkpIHtcbiAgICAgICAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImxvZ2dlclwiXS5lcnJvcihzdGF0dXMgKyBcIiB3aGlsZSBsb2FkaW5nIFwiICsgY29udGV4dC51cmwpO1xuICAgICAgICAgICAgdGhpcy5jYWxsYmFja3Mub25FcnJvcih7XG4gICAgICAgICAgICAgIGNvZGU6IHN0YXR1cyxcbiAgICAgICAgICAgICAgdGV4dDogeGhyLnN0YXR1c1RleHRcbiAgICAgICAgICAgIH0sIGNvbnRleHQsIHhocik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHJldHJ5XG4gICAgICAgICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJsb2dnZXJcIl0ud2FybihzdGF0dXMgKyBcIiB3aGlsZSBsb2FkaW5nIFwiICsgY29udGV4dC51cmwgKyBcIiwgcmV0cnlpbmcgaW4gXCIgKyB0aGlzLnJldHJ5RGVsYXkgKyBcIi4uLlwiKTsgLy8gYWJvcnQgYW5kIHJlc2V0IGludGVybmFsIHN0YXRlXG5cbiAgICAgICAgICAgIHRoaXMuYWJvcnRJbnRlcm5hbCgpO1xuICAgICAgICAgICAgdGhpcy5sb2FkZXIgPSBudWxsOyAvLyBzY2hlZHVsZSByZXRyeVxuXG4gICAgICAgICAgICBzZWxmLmNsZWFyVGltZW91dCh0aGlzLnJldHJ5VGltZW91dCk7XG4gICAgICAgICAgICB0aGlzLnJldHJ5VGltZW91dCA9IHNlbGYuc2V0VGltZW91dCh0aGlzLmxvYWRJbnRlcm5hbC5iaW5kKHRoaXMpLCB0aGlzLnJldHJ5RGVsYXkpOyAvLyBzZXQgZXhwb25lbnRpYWwgYmFja29mZlxuXG4gICAgICAgICAgICB0aGlzLnJldHJ5RGVsYXkgPSBNYXRoLm1pbigyICogdGhpcy5yZXRyeURlbGF5LCBjb25maWcubWF4UmV0cnlEZWxheSk7XG4gICAgICAgICAgICBzdGF0cy5yZXRyeSsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gcmVhZHlTdGF0ZSA+PSAyIEFORCByZWFkeVN0YXRlICE9PTQgKHJlYWR5U3RhdGUgPSBIRUFERVJTX1JFQ0VJVkVEIHx8IExPQURJTkcpIHJlYXJtIHRpbWVvdXQgYXMgeGhyIG5vdCBmaW5pc2hlZCB5ZXRcbiAgICAgICAgc2VsZi5jbGVhclRpbWVvdXQodGhpcy5yZXF1ZXN0VGltZW91dCk7XG4gICAgICAgIHRoaXMucmVxdWVzdFRpbWVvdXQgPSBzZWxmLnNldFRpbWVvdXQodGhpcy5sb2FkdGltZW91dC5iaW5kKHRoaXMpLCBjb25maWcudGltZW91dCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5sb2FkdGltZW91dCA9IGZ1bmN0aW9uIGxvYWR0aW1lb3V0KCkge1xuICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImxvZ2dlclwiXS53YXJuKFwidGltZW91dCB3aGlsZSBsb2FkaW5nIFwiICsgdGhpcy5jb250ZXh0LnVybCk7XG4gICAgdmFyIGNhbGxiYWNrcyA9IHRoaXMuY2FsbGJhY2tzO1xuXG4gICAgaWYgKGNhbGxiYWNrcykge1xuICAgICAgdGhpcy5hYm9ydEludGVybmFsKCk7XG4gICAgICBjYWxsYmFja3Mub25UaW1lb3V0KHRoaXMuc3RhdHMsIHRoaXMuY29udGV4dCwgdGhpcy5sb2FkZXIpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8ubG9hZHByb2dyZXNzID0gZnVuY3Rpb24gbG9hZHByb2dyZXNzKGV2ZW50KSB7XG4gICAgdmFyIHN0YXRzID0gdGhpcy5zdGF0cztcbiAgICBzdGF0cy5sb2FkZWQgPSBldmVudC5sb2FkZWQ7XG5cbiAgICBpZiAoZXZlbnQubGVuZ3RoQ29tcHV0YWJsZSkge1xuICAgICAgc3RhdHMudG90YWwgPSBldmVudC50b3RhbDtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmdldENhY2hlQWdlID0gZnVuY3Rpb24gZ2V0Q2FjaGVBZ2UoKSB7XG4gICAgdmFyIHJlc3VsdCA9IG51bGw7XG5cbiAgICBpZiAodGhpcy5sb2FkZXIgJiYgQUdFX0hFQURFUl9MSU5FX1JFR0VYLnRlc3QodGhpcy5sb2FkZXIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkpKSB7XG4gICAgICB2YXIgYWdlSGVhZGVyID0gdGhpcy5sb2FkZXIuZ2V0UmVzcG9uc2VIZWFkZXIoJ2FnZScpO1xuICAgICAgcmVzdWx0ID0gYWdlSGVhZGVyID8gcGFyc2VGbG9hdChhZ2VIZWFkZXIpIDogbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIHJldHVybiBYaHJMb2FkZXI7XG59KCk7XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoWGhyTG9hZGVyKTtcblxuLyoqKi8gfSlcblxuLyoqKioqKi8gfSlbXCJkZWZhdWx0XCJdO1xufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1obHMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/hls.js/dist/hls.js\n");

/***/ }),

/***/ "./node_modules/moment/moment.js":
/*!***************************************!*\
  !*** ./node_modules/moment/moment.js ***!
  \***************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\n//! moment.js\n//! version : 2.29.4\n//! authors : Tim Wood, Iskren Chernev, Moment.js contributors\n//! license : MIT\n//! momentjs.com\n\n;(function (global, factory) {\n     true ? module.exports = factory() :\n    0\n}(this, (function () { 'use strict';\n\n    var hookCallback;\n\n    function hooks() {\n        return hookCallback.apply(null, arguments);\n    }\n\n    // This is done to register the method called with moment()\n    // without creating circular dependencies.\n    function setHookCallback(callback) {\n        hookCallback = callback;\n    }\n\n    function isArray(input) {\n        return (\n            input instanceof Array ||\n            Object.prototype.toString.call(input) === '[object Array]'\n        );\n    }\n\n    function isObject(input) {\n        // IE8 will treat undefined and null as object if it wasn't for\n        // input != null\n        return (\n            input != null &&\n            Object.prototype.toString.call(input) === '[object Object]'\n        );\n    }\n\n    function hasOwnProp(a, b) {\n        return Object.prototype.hasOwnProperty.call(a, b);\n    }\n\n    function isObjectEmpty(obj) {\n        if (Object.getOwnPropertyNames) {\n            return Object.getOwnPropertyNames(obj).length === 0;\n        } else {\n            var k;\n            for (k in obj) {\n                if (hasOwnProp(obj, k)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n\n    function isUndefined(input) {\n        return input === void 0;\n    }\n\n    function isNumber(input) {\n        return (\n            typeof input === 'number' ||\n            Object.prototype.toString.call(input) === '[object Number]'\n        );\n    }\n\n    function isDate(input) {\n        return (\n            input instanceof Date ||\n            Object.prototype.toString.call(input) === '[object Date]'\n        );\n    }\n\n    function map(arr, fn) {\n        var res = [],\n            i,\n            arrLen = arr.length;\n        for (i = 0; i < arrLen; ++i) {\n            res.push(fn(arr[i], i));\n        }\n        return res;\n    }\n\n    function extend(a, b) {\n        for (var i in b) {\n            if (hasOwnProp(b, i)) {\n                a[i] = b[i];\n            }\n        }\n\n        if (hasOwnProp(b, 'toString')) {\n            a.toString = b.toString;\n        }\n\n        if (hasOwnProp(b, 'valueOf')) {\n            a.valueOf = b.valueOf;\n        }\n\n        return a;\n    }\n\n    function createUTC(input, format, locale, strict) {\n        return createLocalOrUTC(input, format, locale, strict, true).utc();\n    }\n\n    function defaultParsingFlags() {\n        // We need to deep clone this object.\n        return {\n            empty: false,\n            unusedTokens: [],\n            unusedInput: [],\n            overflow: -2,\n            charsLeftOver: 0,\n            nullInput: false,\n            invalidEra: null,\n            invalidMonth: null,\n            invalidFormat: false,\n            userInvalidated: false,\n            iso: false,\n            parsedDateParts: [],\n            era: null,\n            meridiem: null,\n            rfc2822: false,\n            weekdayMismatch: false,\n        };\n    }\n\n    function getParsingFlags(m) {\n        if (m._pf == null) {\n            m._pf = defaultParsingFlags();\n        }\n        return m._pf;\n    }\n\n    var some;\n    if (Array.prototype.some) {\n        some = Array.prototype.some;\n    } else {\n        some = function (fun) {\n            var t = Object(this),\n                len = t.length >>> 0,\n                i;\n\n            for (i = 0; i < len; i++) {\n                if (i in t && fun.call(this, t[i], i, t)) {\n                    return true;\n                }\n            }\n\n            return false;\n        };\n    }\n\n    function isValid(m) {\n        if (m._isValid == null) {\n            var flags = getParsingFlags(m),\n                parsedParts = some.call(flags.parsedDateParts, function (i) {\n                    return i != null;\n                }),\n                isNowValid =\n                    !isNaN(m._d.getTime()) &&\n                    flags.overflow < 0 &&\n                    !flags.empty &&\n                    !flags.invalidEra &&\n                    !flags.invalidMonth &&\n                    !flags.invalidWeekday &&\n                    !flags.weekdayMismatch &&\n                    !flags.nullInput &&\n                    !flags.invalidFormat &&\n                    !flags.userInvalidated &&\n                    (!flags.meridiem || (flags.meridiem && parsedParts));\n\n            if (m._strict) {\n                isNowValid =\n                    isNowValid &&\n                    flags.charsLeftOver === 0 &&\n                    flags.unusedTokens.length === 0 &&\n                    flags.bigHour === undefined;\n            }\n\n            if (Object.isFrozen == null || !Object.isFrozen(m)) {\n                m._isValid = isNowValid;\n            } else {\n                return isNowValid;\n            }\n        }\n        return m._isValid;\n    }\n\n    function createInvalid(flags) {\n        var m = createUTC(NaN);\n        if (flags != null) {\n            extend(getParsingFlags(m), flags);\n        } else {\n            getParsingFlags(m).userInvalidated = true;\n        }\n\n        return m;\n    }\n\n    // Plugins that add properties should also add the key here (null value),\n    // so we can properly clone ourselves.\n    var momentProperties = (hooks.momentProperties = []),\n        updateInProgress = false;\n\n    function copyConfig(to, from) {\n        var i,\n            prop,\n            val,\n            momentPropertiesLen = momentProperties.length;\n\n        if (!isUndefined(from._isAMomentObject)) {\n            to._isAMomentObject = from._isAMomentObject;\n        }\n        if (!isUndefined(from._i)) {\n            to._i = from._i;\n        }\n        if (!isUndefined(from._f)) {\n            to._f = from._f;\n        }\n        if (!isUndefined(from._l)) {\n            to._l = from._l;\n        }\n        if (!isUndefined(from._strict)) {\n            to._strict = from._strict;\n        }\n        if (!isUndefined(from._tzm)) {\n            to._tzm = from._tzm;\n        }\n        if (!isUndefined(from._isUTC)) {\n            to._isUTC = from._isUTC;\n        }\n        if (!isUndefined(from._offset)) {\n            to._offset = from._offset;\n        }\n        if (!isUndefined(from._pf)) {\n            to._pf = getParsingFlags(from);\n        }\n        if (!isUndefined(from._locale)) {\n            to._locale = from._locale;\n        }\n\n        if (momentPropertiesLen > 0) {\n            for (i = 0; i < momentPropertiesLen; i++) {\n                prop = momentProperties[i];\n                val = from[prop];\n                if (!isUndefined(val)) {\n                    to[prop] = val;\n                }\n            }\n        }\n\n        return to;\n    }\n\n    // Moment prototype object\n    function Moment(config) {\n        copyConfig(this, config);\n        this._d = new Date(config._d != null ? config._d.getTime() : NaN);\n        if (!this.isValid()) {\n            this._d = new Date(NaN);\n        }\n        // Prevent infinite loop in case updateOffset creates new moment\n        // objects.\n        if (updateInProgress === false) {\n            updateInProgress = true;\n            hooks.updateOffset(this);\n            updateInProgress = false;\n        }\n    }\n\n    function isMoment(obj) {\n        return (\n            obj instanceof Moment || (obj != null && obj._isAMomentObject != null)\n        );\n    }\n\n    function warn(msg) {\n        if (\n            hooks.suppressDeprecationWarnings === false &&\n            typeof console !== 'undefined' &&\n            console.warn\n        ) {\n            console.warn('Deprecation warning: ' + msg);\n        }\n    }\n\n    function deprecate(msg, fn) {\n        var firstTime = true;\n\n        return extend(function () {\n            if (hooks.deprecationHandler != null) {\n                hooks.deprecationHandler(null, msg);\n            }\n            if (firstTime) {\n                var args = [],\n                    arg,\n                    i,\n                    key,\n                    argLen = arguments.length;\n                for (i = 0; i < argLen; i++) {\n                    arg = '';\n                    if (typeof arguments[i] === 'object') {\n                        arg += '\\n[' + i + '] ';\n                        for (key in arguments[0]) {\n                            if (hasOwnProp(arguments[0], key)) {\n                                arg += key + ': ' + arguments[0][key] + ', ';\n                            }\n                        }\n                        arg = arg.slice(0, -2); // Remove trailing comma and space\n                    } else {\n                        arg = arguments[i];\n                    }\n                    args.push(arg);\n                }\n                warn(\n                    msg +\n                        '\\nArguments: ' +\n                        Array.prototype.slice.call(args).join('') +\n                        '\\n' +\n                        new Error().stack\n                );\n                firstTime = false;\n            }\n            return fn.apply(this, arguments);\n        }, fn);\n    }\n\n    var deprecations = {};\n\n    function deprecateSimple(name, msg) {\n        if (hooks.deprecationHandler != null) {\n            hooks.deprecationHandler(name, msg);\n        }\n        if (!deprecations[name]) {\n            warn(msg);\n            deprecations[name] = true;\n        }\n    }\n\n    hooks.suppressDeprecationWarnings = false;\n    hooks.deprecationHandler = null;\n\n    function isFunction(input) {\n        return (\n            (typeof Function !== 'undefined' && input instanceof Function) ||\n            Object.prototype.toString.call(input) === '[object Function]'\n        );\n    }\n\n    function set(config) {\n        var prop, i;\n        for (i in config) {\n            if (hasOwnProp(config, i)) {\n                prop = config[i];\n                if (isFunction(prop)) {\n                    this[i] = prop;\n                } else {\n                    this['_' + i] = prop;\n                }\n            }\n        }\n        this._config = config;\n        // Lenient ordinal parsing accepts just a number in addition to\n        // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.\n        // TODO: Remove \"ordinalParse\" fallback in next major release.\n        this._dayOfMonthOrdinalParseLenient = new RegExp(\n            (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) +\n                '|' +\n                /\\d{1,2}/.source\n        );\n    }\n\n    function mergeConfigs(parentConfig, childConfig) {\n        var res = extend({}, parentConfig),\n            prop;\n        for (prop in childConfig) {\n            if (hasOwnProp(childConfig, prop)) {\n                if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {\n                    res[prop] = {};\n                    extend(res[prop], parentConfig[prop]);\n                    extend(res[prop], childConfig[prop]);\n                } else if (childConfig[prop] != null) {\n                    res[prop] = childConfig[prop];\n                } else {\n                    delete res[prop];\n                }\n            }\n        }\n        for (prop in parentConfig) {\n            if (\n                hasOwnProp(parentConfig, prop) &&\n                !hasOwnProp(childConfig, prop) &&\n                isObject(parentConfig[prop])\n            ) {\n                // make sure changes to properties don't modify parent config\n                res[prop] = extend({}, res[prop]);\n            }\n        }\n        return res;\n    }\n\n    function Locale(config) {\n        if (config != null) {\n            this.set(config);\n        }\n    }\n\n    var keys;\n\n    if (Object.keys) {\n        keys = Object.keys;\n    } else {\n        keys = function (obj) {\n            var i,\n                res = [];\n            for (i in obj) {\n                if (hasOwnProp(obj, i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        };\n    }\n\n    var defaultCalendar = {\n        sameDay: '[Today at] LT',\n        nextDay: '[Tomorrow at] LT',\n        nextWeek: 'dddd [at] LT',\n        lastDay: '[Yesterday at] LT',\n        lastWeek: '[Last] dddd [at] LT',\n        sameElse: 'L',\n    };\n\n    function calendar(key, mom, now) {\n        var output = this._calendar[key] || this._calendar['sameElse'];\n        return isFunction(output) ? output.call(mom, now) : output;\n    }\n\n    function zeroFill(number, targetLength, forceSign) {\n        var absNumber = '' + Math.abs(number),\n            zerosToFill = targetLength - absNumber.length,\n            sign = number >= 0;\n        return (\n            (sign ? (forceSign ? '+' : '') : '-') +\n            Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) +\n            absNumber\n        );\n    }\n\n    var formattingTokens =\n            /(\\[[^\\[]*\\])|(\\\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g,\n        localFormattingTokens = /(\\[[^\\[]*\\])|(\\\\)?(LTS|LT|LL?L?L?|l{1,4})/g,\n        formatFunctions = {},\n        formatTokenFunctions = {};\n\n    // token:    'M'\n    // padded:   ['MM', 2]\n    // ordinal:  'Mo'\n    // callback: function () { this.month() + 1 }\n    function addFormatToken(token, padded, ordinal, callback) {\n        var func = callback;\n        if (typeof callback === 'string') {\n            func = function () {\n                return this[callback]();\n            };\n        }\n        if (token) {\n            formatTokenFunctions[token] = func;\n        }\n        if (padded) {\n            formatTokenFunctions[padded[0]] = function () {\n                return zeroFill(func.apply(this, arguments), padded[1], padded[2]);\n            };\n        }\n        if (ordinal) {\n            formatTokenFunctions[ordinal] = function () {\n                return this.localeData().ordinal(\n                    func.apply(this, arguments),\n                    token\n                );\n            };\n        }\n    }\n\n    function removeFormattingTokens(input) {\n        if (input.match(/\\[[\\s\\S]/)) {\n            return input.replace(/^\\[|\\]$/g, '');\n        }\n        return input.replace(/\\\\/g, '');\n    }\n\n    function makeFormatFunction(format) {\n        var array = format.match(formattingTokens),\n            i,\n            length;\n\n        for (i = 0, length = array.length; i < length; i++) {\n            if (formatTokenFunctions[array[i]]) {\n                array[i] = formatTokenFunctions[array[i]];\n            } else {\n                array[i] = removeFormattingTokens(array[i]);\n            }\n        }\n\n        return function (mom) {\n            var output = '',\n                i;\n            for (i = 0; i < length; i++) {\n                output += isFunction(array[i])\n                    ? array[i].call(mom, format)\n                    : array[i];\n            }\n            return output;\n        };\n    }\n\n    // format date using native date object\n    function formatMoment(m, format) {\n        if (!m.isValid()) {\n            return m.localeData().invalidDate();\n        }\n\n        format = expandFormat(format, m.localeData());\n        formatFunctions[format] =\n            formatFunctions[format] || makeFormatFunction(format);\n\n        return formatFunctions[format](m);\n    }\n\n    function expandFormat(format, locale) {\n        var i = 5;\n\n        function replaceLongDateFormatTokens(input) {\n            return locale.longDateFormat(input) || input;\n        }\n\n        localFormattingTokens.lastIndex = 0;\n        while (i >= 0 && localFormattingTokens.test(format)) {\n            format = format.replace(\n                localFormattingTokens,\n                replaceLongDateFormatTokens\n            );\n            localFormattingTokens.lastIndex = 0;\n            i -= 1;\n        }\n\n        return format;\n    }\n\n    var defaultLongDateFormat = {\n        LTS: 'h:mm:ss A',\n        LT: 'h:mm A',\n        L: 'MM/DD/YYYY',\n        LL: 'MMMM D, YYYY',\n        LLL: 'MMMM D, YYYY h:mm A',\n        LLLL: 'dddd, MMMM D, YYYY h:mm A',\n    };\n\n    function longDateFormat(key) {\n        var format = this._longDateFormat[key],\n            formatUpper = this._longDateFormat[key.toUpperCase()];\n\n        if (format || !formatUpper) {\n            return format;\n        }\n\n        this._longDateFormat[key] = formatUpper\n            .match(formattingTokens)\n            .map(function (tok) {\n                if (\n                    tok === 'MMMM' ||\n                    tok === 'MM' ||\n                    tok === 'DD' ||\n                    tok === 'dddd'\n                ) {\n                    return tok.slice(1);\n                }\n                return tok;\n            })\n            .join('');\n\n        return this._longDateFormat[key];\n    }\n\n    var defaultInvalidDate = 'Invalid date';\n\n    function invalidDate() {\n        return this._invalidDate;\n    }\n\n    var defaultOrdinal = '%d',\n        defaultDayOfMonthOrdinalParse = /\\d{1,2}/;\n\n    function ordinal(number) {\n        return this._ordinal.replace('%d', number);\n    }\n\n    var defaultRelativeTime = {\n        future: 'in %s',\n        past: '%s ago',\n        s: 'a few seconds',\n        ss: '%d seconds',\n        m: 'a minute',\n        mm: '%d minutes',\n        h: 'an hour',\n        hh: '%d hours',\n        d: 'a day',\n        dd: '%d days',\n        w: 'a week',\n        ww: '%d weeks',\n        M: 'a month',\n        MM: '%d months',\n        y: 'a year',\n        yy: '%d years',\n    };\n\n    function relativeTime(number, withoutSuffix, string, isFuture) {\n        var output = this._relativeTime[string];\n        return isFunction(output)\n            ? output(number, withoutSuffix, string, isFuture)\n            : output.replace(/%d/i, number);\n    }\n\n    function pastFuture(diff, output) {\n        var format = this._relativeTime[diff > 0 ? 'future' : 'past'];\n        return isFunction(format) ? format(output) : format.replace(/%s/i, output);\n    }\n\n    var aliases = {};\n\n    function addUnitAlias(unit, shorthand) {\n        var lowerCase = unit.toLowerCase();\n        aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;\n    }\n\n    function normalizeUnits(units) {\n        return typeof units === 'string'\n            ? aliases[units] || aliases[units.toLowerCase()]\n            : undefined;\n    }\n\n    function normalizeObjectUnits(inputObject) {\n        var normalizedInput = {},\n            normalizedProp,\n            prop;\n\n        for (prop in inputObject) {\n            if (hasOwnProp(inputObject, prop)) {\n                normalizedProp = normalizeUnits(prop);\n                if (normalizedProp) {\n                    normalizedInput[normalizedProp] = inputObject[prop];\n                }\n            }\n        }\n\n        return normalizedInput;\n    }\n\n    var priorities = {};\n\n    function addUnitPriority(unit, priority) {\n        priorities[unit] = priority;\n    }\n\n    function getPrioritizedUnits(unitsObj) {\n        var units = [],\n            u;\n        for (u in unitsObj) {\n            if (hasOwnProp(unitsObj, u)) {\n                units.push({ unit: u, priority: priorities[u] });\n            }\n        }\n        units.sort(function (a, b) {\n            return a.priority - b.priority;\n        });\n        return units;\n    }\n\n    function isLeapYear(year) {\n        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;\n    }\n\n    function absFloor(number) {\n        if (number < 0) {\n            // -0 -> 0\n            return Math.ceil(number) || 0;\n        } else {\n            return Math.floor(number);\n        }\n    }\n\n    function toInt(argumentForCoercion) {\n        var coercedNumber = +argumentForCoercion,\n            value = 0;\n\n        if (coercedNumber !== 0 && isFinite(coercedNumber)) {\n            value = absFloor(coercedNumber);\n        }\n\n        return value;\n    }\n\n    function makeGetSet(unit, keepTime) {\n        return function (value) {\n            if (value != null) {\n                set$1(this, unit, value);\n                hooks.updateOffset(this, keepTime);\n                return this;\n            } else {\n                return get(this, unit);\n            }\n        };\n    }\n\n    function get(mom, unit) {\n        return mom.isValid()\n            ? mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]()\n            : NaN;\n    }\n\n    function set$1(mom, unit, value) {\n        if (mom.isValid() && !isNaN(value)) {\n            if (\n                unit === 'FullYear' &&\n                isLeapYear(mom.year()) &&\n                mom.month() === 1 &&\n                mom.date() === 29\n            ) {\n                value = toInt(value);\n                mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](\n                    value,\n                    mom.month(),\n                    daysInMonth(value, mom.month())\n                );\n            } else {\n                mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);\n            }\n        }\n    }\n\n    // MOMENTS\n\n    function stringGet(units) {\n        units = normalizeUnits(units);\n        if (isFunction(this[units])) {\n            return this[units]();\n        }\n        return this;\n    }\n\n    function stringSet(units, value) {\n        if (typeof units === 'object') {\n            units = normalizeObjectUnits(units);\n            var prioritized = getPrioritizedUnits(units),\n                i,\n                prioritizedLen = prioritized.length;\n            for (i = 0; i < prioritizedLen; i++) {\n                this[prioritized[i].unit](units[prioritized[i].unit]);\n            }\n        } else {\n            units = normalizeUnits(units);\n            if (isFunction(this[units])) {\n                return this[units](value);\n            }\n        }\n        return this;\n    }\n\n    var match1 = /\\d/, //       0 - 9\n        match2 = /\\d\\d/, //      00 - 99\n        match3 = /\\d{3}/, //     000 - 999\n        match4 = /\\d{4}/, //    0000 - 9999\n        match6 = /[+-]?\\d{6}/, // -999999 - 999999\n        match1to2 = /\\d\\d?/, //       0 - 99\n        match3to4 = /\\d\\d\\d\\d?/, //     999 - 9999\n        match5to6 = /\\d\\d\\d\\d\\d\\d?/, //   99999 - 999999\n        match1to3 = /\\d{1,3}/, //       0 - 999\n        match1to4 = /\\d{1,4}/, //       0 - 9999\n        match1to6 = /[+-]?\\d{1,6}/, // -999999 - 999999\n        matchUnsigned = /\\d+/, //       0 - inf\n        matchSigned = /[+-]?\\d+/, //    -inf - inf\n        matchOffset = /Z|[+-]\\d\\d:?\\d\\d/gi, // +00:00 -00:00 +0000 -0000 or Z\n        matchShortOffset = /Z|[+-]\\d\\d(?::?\\d\\d)?/gi, // +00 -00 +00:00 -00:00 +0000 -0000 or Z\n        matchTimestamp = /[+-]?\\d+(\\.\\d{1,3})?/, // 123456789 123456789.123\n        // any word (or two) characters or numbers including two/three word month in arabic.\n        // includes scottish gaelic two word and hyphenated months\n        matchWord =\n            /[0-9]{0,256}['a-z\\u00A0-\\u05FF\\u0700-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFF07\\uFF10-\\uFFEF]{1,256}|[\\u0600-\\u06FF\\/]{1,256}(\\s*?[\\u0600-\\u06FF]{1,256}){1,2}/i,\n        regexes;\n\n    regexes = {};\n\n    function addRegexToken(token, regex, strictRegex) {\n        regexes[token] = isFunction(regex)\n            ? regex\n            : function (isStrict, localeData) {\n                  return isStrict && strictRegex ? strictRegex : regex;\n              };\n    }\n\n    function getParseRegexForToken(token, config) {\n        if (!hasOwnProp(regexes, token)) {\n            return new RegExp(unescapeFormat(token));\n        }\n\n        return regexes[token](config._strict, config._locale);\n    }\n\n    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript\n    function unescapeFormat(s) {\n        return regexEscape(\n            s\n                .replace('\\\\', '')\n                .replace(\n                    /\\\\(\\[)|\\\\(\\])|\\[([^\\]\\[]*)\\]|\\\\(.)/g,\n                    function (matched, p1, p2, p3, p4) {\n                        return p1 || p2 || p3 || p4;\n                    }\n                )\n        );\n    }\n\n    function regexEscape(s) {\n        return s.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n    }\n\n    var tokens = {};\n\n    function addParseToken(token, callback) {\n        var i,\n            func = callback,\n            tokenLen;\n        if (typeof token === 'string') {\n            token = [token];\n        }\n        if (isNumber(callback)) {\n            func = function (input, array) {\n                array[callback] = toInt(input);\n            };\n        }\n        tokenLen = token.length;\n        for (i = 0; i < tokenLen; i++) {\n            tokens[token[i]] = func;\n        }\n    }\n\n    function addWeekParseToken(token, callback) {\n        addParseToken(token, function (input, array, config, token) {\n            config._w = config._w || {};\n            callback(input, config._w, config, token);\n        });\n    }\n\n    function addTimeToArrayFromToken(token, input, config) {\n        if (input != null && hasOwnProp(tokens, token)) {\n            tokens[token](input, config._a, config, token);\n        }\n    }\n\n    var YEAR = 0,\n        MONTH = 1,\n        DATE = 2,\n        HOUR = 3,\n        MINUTE = 4,\n        SECOND = 5,\n        MILLISECOND = 6,\n        WEEK = 7,\n        WEEKDAY = 8;\n\n    function mod(n, x) {\n        return ((n % x) + x) % x;\n    }\n\n    var indexOf;\n\n    if (Array.prototype.indexOf) {\n        indexOf = Array.prototype.indexOf;\n    } else {\n        indexOf = function (o) {\n            // I know\n            var i;\n            for (i = 0; i < this.length; ++i) {\n                if (this[i] === o) {\n                    return i;\n                }\n            }\n            return -1;\n        };\n    }\n\n    function daysInMonth(year, month) {\n        if (isNaN(year) || isNaN(month)) {\n            return NaN;\n        }\n        var modMonth = mod(month, 12);\n        year += (month - modMonth) / 12;\n        return modMonth === 1\n            ? isLeapYear(year)\n                ? 29\n                : 28\n            : 31 - ((modMonth % 7) % 2);\n    }\n\n    // FORMATTING\n\n    addFormatToken('M', ['MM', 2], 'Mo', function () {\n        return this.month() + 1;\n    });\n\n    addFormatToken('MMM', 0, 0, function (format) {\n        return this.localeData().monthsShort(this, format);\n    });\n\n    addFormatToken('MMMM', 0, 0, function (format) {\n        return this.localeData().months(this, format);\n    });\n\n    // ALIASES\n\n    addUnitAlias('month', 'M');\n\n    // PRIORITY\n\n    addUnitPriority('month', 8);\n\n    // PARSING\n\n    addRegexToken('M', match1to2);\n    addRegexToken('MM', match1to2, match2);\n    addRegexToken('MMM', function (isStrict, locale) {\n        return locale.monthsShortRegex(isStrict);\n    });\n    addRegexToken('MMMM', function (isStrict, locale) {\n        return locale.monthsRegex(isStrict);\n    });\n\n    addParseToken(['M', 'MM'], function (input, array) {\n        array[MONTH] = toInt(input) - 1;\n    });\n\n    addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {\n        var month = config._locale.monthsParse(input, token, config._strict);\n        // if we didn't find a month name, mark the date as invalid.\n        if (month != null) {\n            array[MONTH] = month;\n        } else {\n            getParsingFlags(config).invalidMonth = input;\n        }\n    });\n\n    // LOCALES\n\n    var defaultLocaleMonths =\n            'January_February_March_April_May_June_July_August_September_October_November_December'.split(\n                '_'\n            ),\n        defaultLocaleMonthsShort =\n            'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),\n        MONTHS_IN_FORMAT = /D[oD]?(\\[[^\\[\\]]*\\]|\\s)+MMMM?/,\n        defaultMonthsShortRegex = matchWord,\n        defaultMonthsRegex = matchWord;\n\n    function localeMonths(m, format) {\n        if (!m) {\n            return isArray(this._months)\n                ? this._months\n                : this._months['standalone'];\n        }\n        return isArray(this._months)\n            ? this._months[m.month()]\n            : this._months[\n                  (this._months.isFormat || MONTHS_IN_FORMAT).test(format)\n                      ? 'format'\n                      : 'standalone'\n              ][m.month()];\n    }\n\n    function localeMonthsShort(m, format) {\n        if (!m) {\n            return isArray(this._monthsShort)\n                ? this._monthsShort\n                : this._monthsShort['standalone'];\n        }\n        return isArray(this._monthsShort)\n            ? this._monthsShort[m.month()]\n            : this._monthsShort[\n                  MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'\n              ][m.month()];\n    }\n\n    function handleStrictParse(monthName, format, strict) {\n        var i,\n            ii,\n            mom,\n            llc = monthName.toLocaleLowerCase();\n        if (!this._monthsParse) {\n            // this is not used\n            this._monthsParse = [];\n            this._longMonthsParse = [];\n            this._shortMonthsParse = [];\n            for (i = 0; i < 12; ++i) {\n                mom = createUTC([2000, i]);\n                this._shortMonthsParse[i] = this.monthsShort(\n                    mom,\n                    ''\n                ).toLocaleLowerCase();\n                this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();\n            }\n        }\n\n        if (strict) {\n            if (format === 'MMM') {\n                ii = indexOf.call(this._shortMonthsParse, llc);\n                return ii !== -1 ? ii : null;\n            } else {\n                ii = indexOf.call(this._longMonthsParse, llc);\n                return ii !== -1 ? ii : null;\n            }\n        } else {\n            if (format === 'MMM') {\n                ii = indexOf.call(this._shortMonthsParse, llc);\n                if (ii !== -1) {\n                    return ii;\n                }\n                ii = indexOf.call(this._longMonthsParse, llc);\n                return ii !== -1 ? ii : null;\n            } else {\n                ii = indexOf.call(this._longMonthsParse, llc);\n                if (ii !== -1) {\n                    return ii;\n                }\n                ii = indexOf.call(this._shortMonthsParse, llc);\n                return ii !== -1 ? ii : null;\n            }\n        }\n    }\n\n    function localeMonthsParse(monthName, format, strict) {\n        var i, mom, regex;\n\n        if (this._monthsParseExact) {\n            return handleStrictParse.call(this, monthName, format, strict);\n        }\n\n        if (!this._monthsParse) {\n            this._monthsParse = [];\n            this._longMonthsParse = [];\n            this._shortMonthsParse = [];\n        }\n\n        // TODO: add sorting\n        // Sorting makes sure if one month (or abbr) is a prefix of another\n        // see sorting in computeMonthsParse\n        for (i = 0; i < 12; i++) {\n            // make the regex if we don't have it already\n            mom = createUTC([2000, i]);\n            if (strict && !this._longMonthsParse[i]) {\n                this._longMonthsParse[i] = new RegExp(\n                    '^' + this.months(mom, '').replace('.', '') + '$',\n                    'i'\n                );\n                this._shortMonthsParse[i] = new RegExp(\n                    '^' + this.monthsShort(mom, '').replace('.', '') + '$',\n                    'i'\n                );\n            }\n            if (!strict && !this._monthsParse[i]) {\n                regex =\n                    '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');\n                this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');\n            }\n            // test the regex\n            if (\n                strict &&\n                format === 'MMMM' &&\n                this._longMonthsParse[i].test(monthName)\n            ) {\n                return i;\n            } else if (\n                strict &&\n                format === 'MMM' &&\n                this._shortMonthsParse[i].test(monthName)\n            ) {\n                return i;\n            } else if (!strict && this._monthsParse[i].test(monthName)) {\n                return i;\n            }\n        }\n    }\n\n    // MOMENTS\n\n    function setMonth(mom, value) {\n        var dayOfMonth;\n\n        if (!mom.isValid()) {\n            // No op\n            return mom;\n        }\n\n        if (typeof value === 'string') {\n            if (/^\\d+$/.test(value)) {\n                value = toInt(value);\n            } else {\n                value = mom.localeData().monthsParse(value);\n                // TODO: Another silent failure?\n                if (!isNumber(value)) {\n                    return mom;\n                }\n            }\n        }\n\n        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));\n        mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);\n        return mom;\n    }\n\n    function getSetMonth(value) {\n        if (value != null) {\n            setMonth(this, value);\n            hooks.updateOffset(this, true);\n            return this;\n        } else {\n            return get(this, 'Month');\n        }\n    }\n\n    function getDaysInMonth() {\n        return daysInMonth(this.year(), this.month());\n    }\n\n    function monthsShortRegex(isStrict) {\n        if (this._monthsParseExact) {\n            if (!hasOwnProp(this, '_monthsRegex')) {\n                computeMonthsParse.call(this);\n            }\n            if (isStrict) {\n                return this._monthsShortStrictRegex;\n            } else {\n                return this._monthsShortRegex;\n            }\n        } else {\n            if (!hasOwnProp(this, '_monthsShortRegex')) {\n                this._monthsShortRegex = defaultMonthsShortRegex;\n            }\n            return this._monthsShortStrictRegex && isStrict\n                ? this._monthsShortStrictRegex\n                : this._monthsShortRegex;\n        }\n    }\n\n    function monthsRegex(isStrict) {\n        if (this._monthsParseExact) {\n            if (!hasOwnProp(this, '_monthsRegex')) {\n                computeMonthsParse.call(this);\n            }\n            if (isStrict) {\n                return this._monthsStrictRegex;\n            } else {\n                return this._monthsRegex;\n            }\n        } else {\n            if (!hasOwnProp(this, '_monthsRegex')) {\n                this._monthsRegex = defaultMonthsRegex;\n            }\n            return this._monthsStrictRegex && isStrict\n                ? this._monthsStrictRegex\n                : this._monthsRegex;\n        }\n    }\n\n    function computeMonthsParse() {\n        function cmpLenRev(a, b) {\n            return b.length - a.length;\n        }\n\n        var shortPieces = [],\n            longPieces = [],\n            mixedPieces = [],\n            i,\n            mom;\n        for (i = 0; i < 12; i++) {\n            // make the regex if we don't have it already\n            mom = createUTC([2000, i]);\n            shortPieces.push(this.monthsShort(mom, ''));\n            longPieces.push(this.months(mom, ''));\n            mixedPieces.push(this.months(mom, ''));\n            mixedPieces.push(this.monthsShort(mom, ''));\n        }\n        // Sorting makes sure if one month (or abbr) is a prefix of another it\n        // will match the longer piece.\n        shortPieces.sort(cmpLenRev);\n        longPieces.sort(cmpLenRev);\n        mixedPieces.sort(cmpLenRev);\n        for (i = 0; i < 12; i++) {\n            shortPieces[i] = regexEscape(shortPieces[i]);\n            longPieces[i] = regexEscape(longPieces[i]);\n        }\n        for (i = 0; i < 24; i++) {\n            mixedPieces[i] = regexEscape(mixedPieces[i]);\n        }\n\n        this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');\n        this._monthsShortRegex = this._monthsRegex;\n        this._monthsStrictRegex = new RegExp(\n            '^(' + longPieces.join('|') + ')',\n            'i'\n        );\n        this._monthsShortStrictRegex = new RegExp(\n            '^(' + shortPieces.join('|') + ')',\n            'i'\n        );\n    }\n\n    // FORMATTING\n\n    addFormatToken('Y', 0, 0, function () {\n        var y = this.year();\n        return y <= 9999 ? zeroFill(y, 4) : '+' + y;\n    });\n\n    addFormatToken(0, ['YY', 2], 0, function () {\n        return this.year() % 100;\n    });\n\n    addFormatToken(0, ['YYYY', 4], 0, 'year');\n    addFormatToken(0, ['YYYYY', 5], 0, 'year');\n    addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');\n\n    // ALIASES\n\n    addUnitAlias('year', 'y');\n\n    // PRIORITIES\n\n    addUnitPriority('year', 1);\n\n    // PARSING\n\n    addRegexToken('Y', matchSigned);\n    addRegexToken('YY', match1to2, match2);\n    addRegexToken('YYYY', match1to4, match4);\n    addRegexToken('YYYYY', match1to6, match6);\n    addRegexToken('YYYYYY', match1to6, match6);\n\n    addParseToken(['YYYYY', 'YYYYYY'], YEAR);\n    addParseToken('YYYY', function (input, array) {\n        array[YEAR] =\n            input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);\n    });\n    addParseToken('YY', function (input, array) {\n        array[YEAR] = hooks.parseTwoDigitYear(input);\n    });\n    addParseToken('Y', function (input, array) {\n        array[YEAR] = parseInt(input, 10);\n    });\n\n    // HELPERS\n\n    function daysInYear(year) {\n        return isLeapYear(year) ? 366 : 365;\n    }\n\n    // HOOKS\n\n    hooks.parseTwoDigitYear = function (input) {\n        return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);\n    };\n\n    // MOMENTS\n\n    var getSetYear = makeGetSet('FullYear', true);\n\n    function getIsLeapYear() {\n        return isLeapYear(this.year());\n    }\n\n    function createDate(y, m, d, h, M, s, ms) {\n        // can't just apply() to create a date:\n        // https://stackoverflow.com/q/181348\n        var date;\n        // the date constructor remaps years 0-99 to 1900-1999\n        if (y < 100 && y >= 0) {\n            // preserve leap years using a full 400 year cycle, then reset\n            date = new Date(y + 400, m, d, h, M, s, ms);\n            if (isFinite(date.getFullYear())) {\n                date.setFullYear(y);\n            }\n        } else {\n            date = new Date(y, m, d, h, M, s, ms);\n        }\n\n        return date;\n    }\n\n    function createUTCDate(y) {\n        var date, args;\n        // the Date.UTC function remaps years 0-99 to 1900-1999\n        if (y < 100 && y >= 0) {\n            args = Array.prototype.slice.call(arguments);\n            // preserve leap years using a full 400 year cycle, then reset\n            args[0] = y + 400;\n            date = new Date(Date.UTC.apply(null, args));\n            if (isFinite(date.getUTCFullYear())) {\n                date.setUTCFullYear(y);\n            }\n        } else {\n            date = new Date(Date.UTC.apply(null, arguments));\n        }\n\n        return date;\n    }\n\n    // start-of-first-week - start-of-year\n    function firstWeekOffset(year, dow, doy) {\n        var // first-week day -- which january is always in the first week (4 for iso, 1 for other)\n            fwd = 7 + dow - doy,\n            // first-week day local weekday -- which local weekday is fwd\n            fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;\n\n        return -fwdlw + fwd - 1;\n    }\n\n    // https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday\n    function dayOfYearFromWeeks(year, week, weekday, dow, doy) {\n        var localWeekday = (7 + weekday - dow) % 7,\n            weekOffset = firstWeekOffset(year, dow, doy),\n            dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,\n            resYear,\n            resDayOfYear;\n\n        if (dayOfYear <= 0) {\n            resYear = year - 1;\n            resDayOfYear = daysInYear(resYear) + dayOfYear;\n        } else if (dayOfYear > daysInYear(year)) {\n            resYear = year + 1;\n            resDayOfYear = dayOfYear - daysInYear(year);\n        } else {\n            resYear = year;\n            resDayOfYear = dayOfYear;\n        }\n\n        return {\n            year: resYear,\n            dayOfYear: resDayOfYear,\n        };\n    }\n\n    function weekOfYear(mom, dow, doy) {\n        var weekOffset = firstWeekOffset(mom.year(), dow, doy),\n            week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,\n            resWeek,\n            resYear;\n\n        if (week < 1) {\n            resYear = mom.year() - 1;\n            resWeek = week + weeksInYear(resYear, dow, doy);\n        } else if (week > weeksInYear(mom.year(), dow, doy)) {\n            resWeek = week - weeksInYear(mom.year(), dow, doy);\n            resYear = mom.year() + 1;\n        } else {\n            resYear = mom.year();\n            resWeek = week;\n        }\n\n        return {\n            week: resWeek,\n            year: resYear,\n        };\n    }\n\n    function weeksInYear(year, dow, doy) {\n        var weekOffset = firstWeekOffset(year, dow, doy),\n            weekOffsetNext = firstWeekOffset(year + 1, dow, doy);\n        return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;\n    }\n\n    // FORMATTING\n\n    addFormatToken('w', ['ww', 2], 'wo', 'week');\n    addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');\n\n    // ALIASES\n\n    addUnitAlias('week', 'w');\n    addUnitAlias('isoWeek', 'W');\n\n    // PRIORITIES\n\n    addUnitPriority('week', 5);\n    addUnitPriority('isoWeek', 5);\n\n    // PARSING\n\n    addRegexToken('w', match1to2);\n    addRegexToken('ww', match1to2, match2);\n    addRegexToken('W', match1to2);\n    addRegexToken('WW', match1to2, match2);\n\n    addWeekParseToken(\n        ['w', 'ww', 'W', 'WW'],\n        function (input, week, config, token) {\n            week[token.substr(0, 1)] = toInt(input);\n        }\n    );\n\n    // HELPERS\n\n    // LOCALES\n\n    function localeWeek(mom) {\n        return weekOfYear(mom, this._week.dow, this._week.doy).week;\n    }\n\n    var defaultLocaleWeek = {\n        dow: 0, // Sunday is the first day of the week.\n        doy: 6, // The week that contains Jan 6th is the first week of the year.\n    };\n\n    function localeFirstDayOfWeek() {\n        return this._week.dow;\n    }\n\n    function localeFirstDayOfYear() {\n        return this._week.doy;\n    }\n\n    // MOMENTS\n\n    function getSetWeek(input) {\n        var week = this.localeData().week(this);\n        return input == null ? week : this.add((input - week) * 7, 'd');\n    }\n\n    function getSetISOWeek(input) {\n        var week = weekOfYear(this, 1, 4).week;\n        return input == null ? week : this.add((input - week) * 7, 'd');\n    }\n\n    // FORMATTING\n\n    addFormatToken('d', 0, 'do', 'day');\n\n    addFormatToken('dd', 0, 0, function (format) {\n        return this.localeData().weekdaysMin(this, format);\n    });\n\n    addFormatToken('ddd', 0, 0, function (format) {\n        return this.localeData().weekdaysShort(this, format);\n    });\n\n    addFormatToken('dddd', 0, 0, function (format) {\n        return this.localeData().weekdays(this, format);\n    });\n\n    addFormatToken('e', 0, 0, 'weekday');\n    addFormatToken('E', 0, 0, 'isoWeekday');\n\n    // ALIASES\n\n    addUnitAlias('day', 'd');\n    addUnitAlias('weekday', 'e');\n    addUnitAlias('isoWeekday', 'E');\n\n    // PRIORITY\n    addUnitPriority('day', 11);\n    addUnitPriority('weekday', 11);\n    addUnitPriority('isoWeekday', 11);\n\n    // PARSING\n\n    addRegexToken('d', match1to2);\n    addRegexToken('e', match1to2);\n    addRegexToken('E', match1to2);\n    addRegexToken('dd', function (isStrict, locale) {\n        return locale.weekdaysMinRegex(isStrict);\n    });\n    addRegexToken('ddd', function (isStrict, locale) {\n        return locale.weekdaysShortRegex(isStrict);\n    });\n    addRegexToken('dddd', function (isStrict, locale) {\n        return locale.weekdaysRegex(isStrict);\n    });\n\n    addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {\n        var weekday = config._locale.weekdaysParse(input, token, config._strict);\n        // if we didn't get a weekday name, mark the date as invalid\n        if (weekday != null) {\n            week.d = weekday;\n        } else {\n            getParsingFlags(config).invalidWeekday = input;\n        }\n    });\n\n    addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {\n        week[token] = toInt(input);\n    });\n\n    // HELPERS\n\n    function parseWeekday(input, locale) {\n        if (typeof input !== 'string') {\n            return input;\n        }\n\n        if (!isNaN(input)) {\n            return parseInt(input, 10);\n        }\n\n        input = locale.weekdaysParse(input);\n        if (typeof input === 'number') {\n            return input;\n        }\n\n        return null;\n    }\n\n    function parseIsoWeekday(input, locale) {\n        if (typeof input === 'string') {\n            return locale.weekdaysParse(input) % 7 || 7;\n        }\n        return isNaN(input) ? null : input;\n    }\n\n    // LOCALES\n    function shiftWeekdays(ws, n) {\n        return ws.slice(n, 7).concat(ws.slice(0, n));\n    }\n\n    var defaultLocaleWeekdays =\n            'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),\n        defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),\n        defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),\n        defaultWeekdaysRegex = matchWord,\n        defaultWeekdaysShortRegex = matchWord,\n        defaultWeekdaysMinRegex = matchWord;\n\n    function localeWeekdays(m, format) {\n        var weekdays = isArray(this._weekdays)\n            ? this._weekdays\n            : this._weekdays[\n                  m && m !== true && this._weekdays.isFormat.test(format)\n                      ? 'format'\n                      : 'standalone'\n              ];\n        return m === true\n            ? shiftWeekdays(weekdays, this._week.dow)\n            : m\n            ? weekdays[m.day()]\n            : weekdays;\n    }\n\n    function localeWeekdaysShort(m) {\n        return m === true\n            ? shiftWeekdays(this._weekdaysShort, this._week.dow)\n            : m\n            ? this._weekdaysShort[m.day()]\n            : this._weekdaysShort;\n    }\n\n    function localeWeekdaysMin(m) {\n        return m === true\n            ? shiftWeekdays(this._weekdaysMin, this._week.dow)\n            : m\n            ? this._weekdaysMin[m.day()]\n            : this._weekdaysMin;\n    }\n\n    function handleStrictParse$1(weekdayName, format, strict) {\n        var i,\n            ii,\n            mom,\n            llc = weekdayName.toLocaleLowerCase();\n        if (!this._weekdaysParse) {\n            this._weekdaysParse = [];\n            this._shortWeekdaysParse = [];\n            this._minWeekdaysParse = [];\n\n            for (i = 0; i < 7; ++i) {\n                mom = createUTC([2000, 1]).day(i);\n                this._minWeekdaysParse[i] = this.weekdaysMin(\n                    mom,\n                    ''\n                ).toLocaleLowerCase();\n                this._shortWeekdaysParse[i] = this.weekdaysShort(\n                    mom,\n                    ''\n                ).toLocaleLowerCase();\n                this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();\n            }\n        }\n\n        if (strict) {\n            if (format === 'dddd') {\n                ii = indexOf.call(this._weekdaysParse, llc);\n                return ii !== -1 ? ii : null;\n            } else if (format === 'ddd') {\n                ii = indexOf.call(this._shortWeekdaysParse, llc);\n                return ii !== -1 ? ii : null;\n            } else {\n                ii = indexOf.call(this._minWeekdaysParse, llc);\n                return ii !== -1 ? ii : null;\n            }\n        } else {\n            if (format === 'dddd') {\n                ii = indexOf.call(this._weekdaysParse, llc);\n                if (ii !== -1) {\n                    return ii;\n                }\n                ii = indexOf.call(this._shortWeekdaysParse, llc);\n                if (ii !== -1) {\n                    return ii;\n                }\n                ii = indexOf.call(this._minWeekdaysParse, llc);\n                return ii !== -1 ? ii : null;\n            } else if (format === 'ddd') {\n                ii = indexOf.call(this._shortWeekdaysParse, llc);\n                if (ii !== -1) {\n                    return ii;\n                }\n                ii = indexOf.call(this._weekdaysParse, llc);\n                if (ii !== -1) {\n                    return ii;\n                }\n                ii = indexOf.call(this._minWeekdaysParse, llc);\n                return ii !== -1 ? ii : null;\n            } else {\n                ii = indexOf.call(this._minWeekdaysParse, llc);\n                if (ii !== -1) {\n                    return ii;\n                }\n                ii = indexOf.call(this._weekdaysParse, llc);\n                if (ii !== -1) {\n                    return ii;\n                }\n                ii = indexOf.call(this._shortWeekdaysParse, llc);\n                return ii !== -1 ? ii : null;\n            }\n        }\n    }\n\n    function localeWeekdaysParse(weekdayName, format, strict) {\n        var i, mom, regex;\n\n        if (this._weekdaysParseExact) {\n            return handleStrictParse$1.call(this, weekdayName, format, strict);\n        }\n\n        if (!this._weekdaysParse) {\n            this._weekdaysParse = [];\n            this._minWeekdaysParse = [];\n            this._shortWeekdaysParse = [];\n            this._fullWeekdaysParse = [];\n        }\n\n        for (i = 0; i < 7; i++) {\n            // make the regex if we don't have it already\n\n            mom = createUTC([2000, 1]).day(i);\n            if (strict && !this._fullWeekdaysParse[i]) {\n                this._fullWeekdaysParse[i] = new RegExp(\n                    '^' + this.weekdays(mom, '').replace('.', '\\\\.?') + '$',\n                    'i'\n                );\n                this._shortWeekdaysParse[i] = new RegExp(\n                    '^' + this.weekdaysShort(mom, '').replace('.', '\\\\.?') + '$',\n                    'i'\n                );\n                this._minWeekdaysParse[i] = new RegExp(\n                    '^' + this.weekdaysMin(mom, '').replace('.', '\\\\.?') + '$',\n                    'i'\n                );\n            }\n            if (!this._weekdaysParse[i]) {\n                regex =\n                    '^' +\n                    this.weekdays(mom, '') +\n                    '|^' +\n                    this.weekdaysShort(mom, '') +\n                    '|^' +\n                    this.weekdaysMin(mom, '');\n                this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');\n            }\n            // test the regex\n            if (\n                strict &&\n                format === 'dddd' &&\n                this._fullWeekdaysParse[i].test(weekdayName)\n            ) {\n                return i;\n            } else if (\n                strict &&\n                format === 'ddd' &&\n                this._shortWeekdaysParse[i].test(weekdayName)\n            ) {\n                return i;\n            } else if (\n                strict &&\n                format === 'dd' &&\n                this._minWeekdaysParse[i].test(weekdayName)\n            ) {\n                return i;\n            } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {\n                return i;\n            }\n        }\n    }\n\n    // MOMENTS\n\n    function getSetDayOfWeek(input) {\n        if (!this.isValid()) {\n            return input != null ? this : NaN;\n        }\n        var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();\n        if (input != null) {\n            input = parseWeekday(input, this.localeData());\n            return this.add(input - day, 'd');\n        } else {\n            return day;\n        }\n    }\n\n    function getSetLocaleDayOfWeek(input) {\n        if (!this.isValid()) {\n            return input != null ? this : NaN;\n        }\n        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;\n        return input == null ? weekday : this.add(input - weekday, 'd');\n    }\n\n    function getSetISODayOfWeek(input) {\n        if (!this.isValid()) {\n            return input != null ? this : NaN;\n        }\n\n        // behaves the same as moment#day except\n        // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)\n        // as a setter, sunday should belong to the previous week.\n\n        if (input != null) {\n            var weekday = parseIsoWeekday(input, this.localeData());\n            return this.day(this.day() % 7 ? weekday : weekday - 7);\n        } else {\n            return this.day() || 7;\n        }\n    }\n\n    function weekdaysRegex(isStrict) {\n        if (this._weekdaysParseExact) {\n            if (!hasOwnProp(this, '_weekdaysRegex')) {\n                computeWeekdaysParse.call(this);\n            }\n            if (isStrict) {\n                return this._weekdaysStrictRegex;\n            } else {\n                return this._weekdaysRegex;\n            }\n        } else {\n            if (!hasOwnProp(this, '_weekdaysRegex')) {\n                this._weekdaysRegex = defaultWeekdaysRegex;\n            }\n            return this._weekdaysStrictRegex && isStrict\n                ? this._weekdaysStrictRegex\n                : this._weekdaysRegex;\n        }\n    }\n\n    function weekdaysShortRegex(isStrict) {\n        if (this._weekdaysParseExact) {\n            if (!hasOwnProp(this, '_weekdaysRegex')) {\n                computeWeekdaysParse.call(this);\n            }\n            if (isStrict) {\n                return this._weekdaysShortStrictRegex;\n            } else {\n                return this._weekdaysShortRegex;\n            }\n        } else {\n            if (!hasOwnProp(this, '_weekdaysShortRegex')) {\n                this._weekdaysShortRegex = defaultWeekdaysShortRegex;\n            }\n            return this._weekdaysShortStrictRegex && isStrict\n                ? this._weekdaysShortStrictRegex\n                : this._weekdaysShortRegex;\n        }\n    }\n\n    function weekdaysMinRegex(isStrict) {\n        if (this._weekdaysParseExact) {\n            if (!hasOwnProp(this, '_weekdaysRegex')) {\n                computeWeekdaysParse.call(this);\n            }\n            if (isStrict) {\n                return this._weekdaysMinStrictRegex;\n            } else {\n                return this._weekdaysMinRegex;\n            }\n        } else {\n            if (!hasOwnProp(this, '_weekdaysMinRegex')) {\n                this._weekdaysMinRegex = defaultWeekdaysMinRegex;\n            }\n            return this._weekdaysMinStrictRegex && isStrict\n                ? this._weekdaysMinStrictRegex\n                : this._weekdaysMinRegex;\n        }\n    }\n\n    function computeWeekdaysParse() {\n        function cmpLenRev(a, b) {\n            return b.length - a.length;\n        }\n\n        var minPieces = [],\n            shortPieces = [],\n            longPieces = [],\n            mixedPieces = [],\n            i,\n            mom,\n            minp,\n            shortp,\n            longp;\n        for (i = 0; i < 7; i++) {\n            // make the regex if we don't have it already\n            mom = createUTC([2000, 1]).day(i);\n            minp = regexEscape(this.weekdaysMin(mom, ''));\n            shortp = regexEscape(this.weekdaysShort(mom, ''));\n            longp = regexEscape(this.weekdays(mom, ''));\n            minPieces.push(minp);\n            shortPieces.push(shortp);\n            longPieces.push(longp);\n            mixedPieces.push(minp);\n            mixedPieces.push(shortp);\n            mixedPieces.push(longp);\n        }\n        // Sorting makes sure if one weekday (or abbr) is a prefix of another it\n        // will match the longer piece.\n        minPieces.sort(cmpLenRev);\n        shortPieces.sort(cmpLenRev);\n        longPieces.sort(cmpLenRev);\n        mixedPieces.sort(cmpLenRev);\n\n        this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');\n        this._weekdaysShortRegex = this._weekdaysRegex;\n        this._weekdaysMinRegex = this._weekdaysRegex;\n\n        this._weekdaysStrictRegex = new RegExp(\n            '^(' + longPieces.join('|') + ')',\n            'i'\n        );\n        this._weekdaysShortStrictRegex = new RegExp(\n            '^(' + shortPieces.join('|') + ')',\n            'i'\n        );\n        this._weekdaysMinStrictRegex = new RegExp(\n            '^(' + minPieces.join('|') + ')',\n            'i'\n        );\n    }\n\n    // FORMATTING\n\n    function hFormat() {\n        return this.hours() % 12 || 12;\n    }\n\n    function kFormat() {\n        return this.hours() || 24;\n    }\n\n    addFormatToken('H', ['HH', 2], 0, 'hour');\n    addFormatToken('h', ['hh', 2], 0, hFormat);\n    addFormatToken('k', ['kk', 2], 0, kFormat);\n\n    addFormatToken('hmm', 0, 0, function () {\n        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);\n    });\n\n    addFormatToken('hmmss', 0, 0, function () {\n        return (\n            '' +\n            hFormat.apply(this) +\n            zeroFill(this.minutes(), 2) +\n            zeroFill(this.seconds(), 2)\n        );\n    });\n\n    addFormatToken('Hmm', 0, 0, function () {\n        return '' + this.hours() + zeroFill(this.minutes(), 2);\n    });\n\n    addFormatToken('Hmmss', 0, 0, function () {\n        return (\n            '' +\n            this.hours() +\n            zeroFill(this.minutes(), 2) +\n            zeroFill(this.seconds(), 2)\n        );\n    });\n\n    function meridiem(token, lowercase) {\n        addFormatToken(token, 0, 0, function () {\n            return this.localeData().meridiem(\n                this.hours(),\n                this.minutes(),\n                lowercase\n            );\n        });\n    }\n\n    meridiem('a', true);\n    meridiem('A', false);\n\n    // ALIASES\n\n    addUnitAlias('hour', 'h');\n\n    // PRIORITY\n    addUnitPriority('hour', 13);\n\n    // PARSING\n\n    function matchMeridiem(isStrict, locale) {\n        return locale._meridiemParse;\n    }\n\n    addRegexToken('a', matchMeridiem);\n    addRegexToken('A', matchMeridiem);\n    addRegexToken('H', match1to2);\n    addRegexToken('h', match1to2);\n    addRegexToken('k', match1to2);\n    addRegexToken('HH', match1to2, match2);\n    addRegexToken('hh', match1to2, match2);\n    addRegexToken('kk', match1to2, match2);\n\n    addRegexToken('hmm', match3to4);\n    addRegexToken('hmmss', match5to6);\n    addRegexToken('Hmm', match3to4);\n    addRegexToken('Hmmss', match5to6);\n\n    addParseToken(['H', 'HH'], HOUR);\n    addParseToken(['k', 'kk'], function (input, array, config) {\n        var kInput = toInt(input);\n        array[HOUR] = kInput === 24 ? 0 : kInput;\n    });\n    addParseToken(['a', 'A'], function (input, array, config) {\n        config._isPm = config._locale.isPM(input);\n        config._meridiem = input;\n    });\n    addParseToken(['h', 'hh'], function (input, array, config) {\n        array[HOUR] = toInt(input);\n        getParsingFlags(config).bigHour = true;\n    });\n    addParseToken('hmm', function (input, array, config) {\n        var pos = input.length - 2;\n        array[HOUR] = toInt(input.substr(0, pos));\n        array[MINUTE] = toInt(input.substr(pos));\n        getParsingFlags(config).bigHour = true;\n    });\n    addParseToken('hmmss', function (input, array, config) {\n        var pos1 = input.length - 4,\n            pos2 = input.length - 2;\n        array[HOUR] = toInt(input.substr(0, pos1));\n        array[MINUTE] = toInt(input.substr(pos1, 2));\n        array[SECOND] = toInt(input.substr(pos2));\n        getParsingFlags(config).bigHour = true;\n    });\n    addParseToken('Hmm', function (input, array, config) {\n        var pos = input.length - 2;\n        array[HOUR] = toInt(input.substr(0, pos));\n        array[MINUTE] = toInt(input.substr(pos));\n    });\n    addParseToken('Hmmss', function (input, array, config) {\n        var pos1 = input.length - 4,\n            pos2 = input.length - 2;\n        array[HOUR] = toInt(input.substr(0, pos1));\n        array[MINUTE] = toInt(input.substr(pos1, 2));\n        array[SECOND] = toInt(input.substr(pos2));\n    });\n\n    // LOCALES\n\n    function localeIsPM(input) {\n        // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays\n        // Using charAt should be more compatible.\n        return (input + '').toLowerCase().charAt(0) === 'p';\n    }\n\n    var defaultLocaleMeridiemParse = /[ap]\\.?m?\\.?/i,\n        // Setting the hour should keep the time, because the user explicitly\n        // specified which hour they want. So trying to maintain the same hour (in\n        // a new timezone) makes sense. Adding/subtracting hours does not follow\n        // this rule.\n        getSetHour = makeGetSet('Hours', true);\n\n    function localeMeridiem(hours, minutes, isLower) {\n        if (hours > 11) {\n            return isLower ? 'pm' : 'PM';\n        } else {\n            return isLower ? 'am' : 'AM';\n        }\n    }\n\n    var baseConfig = {\n        calendar: defaultCalendar,\n        longDateFormat: defaultLongDateFormat,\n        invalidDate: defaultInvalidDate,\n        ordinal: defaultOrdinal,\n        dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,\n        relativeTime: defaultRelativeTime,\n\n        months: defaultLocaleMonths,\n        monthsShort: defaultLocaleMonthsShort,\n\n        week: defaultLocaleWeek,\n\n        weekdays: defaultLocaleWeekdays,\n        weekdaysMin: defaultLocaleWeekdaysMin,\n        weekdaysShort: defaultLocaleWeekdaysShort,\n\n        meridiemParse: defaultLocaleMeridiemParse,\n    };\n\n    // internal storage for locale config files\n    var locales = {},\n        localeFamilies = {},\n        globalLocale;\n\n    function commonPrefix(arr1, arr2) {\n        var i,\n            minl = Math.min(arr1.length, arr2.length);\n        for (i = 0; i < minl; i += 1) {\n            if (arr1[i] !== arr2[i]) {\n                return i;\n            }\n        }\n        return minl;\n    }\n\n    function normalizeLocale(key) {\n        return key ? key.toLowerCase().replace('_', '-') : key;\n    }\n\n    // pick the locale from the array\n    // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each\n    // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root\n    function chooseLocale(names) {\n        var i = 0,\n            j,\n            next,\n            locale,\n            split;\n\n        while (i < names.length) {\n            split = normalizeLocale(names[i]).split('-');\n            j = split.length;\n            next = normalizeLocale(names[i + 1]);\n            next = next ? next.split('-') : null;\n            while (j > 0) {\n                locale = loadLocale(split.slice(0, j).join('-'));\n                if (locale) {\n                    return locale;\n                }\n                if (\n                    next &&\n                    next.length >= j &&\n                    commonPrefix(split, next) >= j - 1\n                ) {\n                    //the next array item is better than a shallower substring of this one\n                    break;\n                }\n                j--;\n            }\n            i++;\n        }\n        return globalLocale;\n    }\n\n    function isLocaleNameSane(name) {\n        // Prevent names that look like filesystem paths, i.e contain '/' or '\\'\n        return name.match('^[^/\\\\\\\\]*$') != null;\n    }\n\n    function loadLocale(name) {\n        var oldLocale = null,\n            aliasedRequire;\n        // TODO: Find a better way to register and load all the locales in Node\n        if (\n            locales[name] === undefined &&\n            \"object\" !== 'undefined' &&\n            module &&\n            module.exports &&\n            isLocaleNameSane(name)\n        ) {\n            try {\n                oldLocale = globalLocale._abbr;\n                aliasedRequire = undefined;\n                Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'undefined'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\n                getSetGlobalLocale(oldLocale);\n            } catch (e) {\n                // mark as not found to avoid repeating expensive file require call causing high CPU\n                // when trying to find en-US, en_US, en-us for every format call\n                locales[name] = null; // null means not found\n            }\n        }\n        return locales[name];\n    }\n\n    // This function will load locale and then set the global locale.  If\n    // no arguments are passed in, it will simply return the current global\n    // locale key.\n    function getSetGlobalLocale(key, values) {\n        var data;\n        if (key) {\n            if (isUndefined(values)) {\n                data = getLocale(key);\n            } else {\n                data = defineLocale(key, values);\n            }\n\n            if (data) {\n                // moment.duration._locale = moment._locale = data;\n                globalLocale = data;\n            } else {\n                if (typeof console !== 'undefined' && console.warn) {\n                    //warn user if arguments are passed but the locale could not be set\n                    console.warn(\n                        'Locale ' + key + ' not found. Did you forget to load it?'\n                    );\n                }\n            }\n        }\n\n        return globalLocale._abbr;\n    }\n\n    function defineLocale(name, config) {\n        if (config !== null) {\n            var locale,\n                parentConfig = baseConfig;\n            config.abbr = name;\n            if (locales[name] != null) {\n                deprecateSimple(\n                    'defineLocaleOverride',\n                    'use moment.updateLocale(localeName, config) to change ' +\n                        'an existing locale. moment.defineLocale(localeName, ' +\n                        'config) should only be used for creating a new locale ' +\n                        'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.'\n                );\n                parentConfig = locales[name]._config;\n            } else if (config.parentLocale != null) {\n                if (locales[config.parentLocale] != null) {\n                    parentConfig = locales[config.parentLocale]._config;\n                } else {\n                    locale = loadLocale(config.parentLocale);\n                    if (locale != null) {\n                        parentConfig = locale._config;\n                    } else {\n                        if (!localeFamilies[config.parentLocale]) {\n                            localeFamilies[config.parentLocale] = [];\n                        }\n                        localeFamilies[config.parentLocale].push({\n                            name: name,\n                            config: config,\n                        });\n                        return null;\n                    }\n                }\n            }\n            locales[name] = new Locale(mergeConfigs(parentConfig, config));\n\n            if (localeFamilies[name]) {\n                localeFamilies[name].forEach(function (x) {\n                    defineLocale(x.name, x.config);\n                });\n            }\n\n            // backwards compat for now: also set the locale\n            // make sure we set the locale AFTER all child locales have been\n            // created, so we won't end up with the child locale set.\n            getSetGlobalLocale(name);\n\n            return locales[name];\n        } else {\n            // useful for testing\n            delete locales[name];\n            return null;\n        }\n    }\n\n    function updateLocale(name, config) {\n        if (config != null) {\n            var locale,\n                tmpLocale,\n                parentConfig = baseConfig;\n\n            if (locales[name] != null && locales[name].parentLocale != null) {\n                // Update existing child locale in-place to avoid memory-leaks\n                locales[name].set(mergeConfigs(locales[name]._config, config));\n            } else {\n                // MERGE\n                tmpLocale = loadLocale(name);\n                if (tmpLocale != null) {\n                    parentConfig = tmpLocale._config;\n                }\n                config = mergeConfigs(parentConfig, config);\n                if (tmpLocale == null) {\n                    // updateLocale is called for creating a new locale\n                    // Set abbr so it will have a name (getters return\n                    // undefined otherwise).\n                    config.abbr = name;\n                }\n                locale = new Locale(config);\n                locale.parentLocale = locales[name];\n                locales[name] = locale;\n            }\n\n            // backwards compat for now: also set the locale\n            getSetGlobalLocale(name);\n        } else {\n            // pass null for config to unupdate, useful for tests\n            if (locales[name] != null) {\n                if (locales[name].parentLocale != null) {\n                    locales[name] = locales[name].parentLocale;\n                    if (name === getSetGlobalLocale()) {\n                        getSetGlobalLocale(name);\n                    }\n                } else if (locales[name] != null) {\n                    delete locales[name];\n                }\n            }\n        }\n        return locales[name];\n    }\n\n    // returns locale data\n    function getLocale(key) {\n        var locale;\n\n        if (key && key._locale && key._locale._abbr) {\n            key = key._locale._abbr;\n        }\n\n        if (!key) {\n            return globalLocale;\n        }\n\n        if (!isArray(key)) {\n            //short-circuit everything else\n            locale = loadLocale(key);\n            if (locale) {\n                return locale;\n            }\n            key = [key];\n        }\n\n        return chooseLocale(key);\n    }\n\n    function listLocales() {\n        return keys(locales);\n    }\n\n    function checkOverflow(m) {\n        var overflow,\n            a = m._a;\n\n        if (a && getParsingFlags(m).overflow === -2) {\n            overflow =\n                a[MONTH] < 0 || a[MONTH] > 11\n                    ? MONTH\n                    : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH])\n                    ? DATE\n                    : a[HOUR] < 0 ||\n                      a[HOUR] > 24 ||\n                      (a[HOUR] === 24 &&\n                          (a[MINUTE] !== 0 ||\n                              a[SECOND] !== 0 ||\n                              a[MILLISECOND] !== 0))\n                    ? HOUR\n                    : a[MINUTE] < 0 || a[MINUTE] > 59\n                    ? MINUTE\n                    : a[SECOND] < 0 || a[SECOND] > 59\n                    ? SECOND\n                    : a[MILLISECOND] < 0 || a[MILLISECOND] > 999\n                    ? MILLISECOND\n                    : -1;\n\n            if (\n                getParsingFlags(m)._overflowDayOfYear &&\n                (overflow < YEAR || overflow > DATE)\n            ) {\n                overflow = DATE;\n            }\n            if (getParsingFlags(m)._overflowWeeks && overflow === -1) {\n                overflow = WEEK;\n            }\n            if (getParsingFlags(m)._overflowWeekday && overflow === -1) {\n                overflow = WEEKDAY;\n            }\n\n            getParsingFlags(m).overflow = overflow;\n        }\n\n        return m;\n    }\n\n    // iso 8601 regex\n    // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)\n    var extendedIsoRegex =\n            /^\\s*((?:[+-]\\d{6}|\\d{4})-(?:\\d\\d-\\d\\d|W\\d\\d-\\d|W\\d\\d|\\d\\d\\d|\\d\\d))(?:(T| )(\\d\\d(?::\\d\\d(?::\\d\\d(?:[.,]\\d+)?)?)?)([+-]\\d\\d(?::?\\d\\d)?|\\s*Z)?)?$/,\n        basicIsoRegex =\n            /^\\s*((?:[+-]\\d{6}|\\d{4})(?:\\d\\d\\d\\d|W\\d\\d\\d|W\\d\\d|\\d\\d\\d|\\d\\d|))(?:(T| )(\\d\\d(?:\\d\\d(?:\\d\\d(?:[.,]\\d+)?)?)?)([+-]\\d\\d(?::?\\d\\d)?|\\s*Z)?)?$/,\n        tzRegex = /Z|[+-]\\d\\d(?::?\\d\\d)?/,\n        isoDates = [\n            ['YYYYYY-MM-DD', /[+-]\\d{6}-\\d\\d-\\d\\d/],\n            ['YYYY-MM-DD', /\\d{4}-\\d\\d-\\d\\d/],\n            ['GGGG-[W]WW-E', /\\d{4}-W\\d\\d-\\d/],\n            ['GGGG-[W]WW', /\\d{4}-W\\d\\d/, false],\n            ['YYYY-DDD', /\\d{4}-\\d{3}/],\n            ['YYYY-MM', /\\d{4}-\\d\\d/, false],\n            ['YYYYYYMMDD', /[+-]\\d{10}/],\n            ['YYYYMMDD', /\\d{8}/],\n            ['GGGG[W]WWE', /\\d{4}W\\d{3}/],\n            ['GGGG[W]WW', /\\d{4}W\\d{2}/, false],\n            ['YYYYDDD', /\\d{7}/],\n            ['YYYYMM', /\\d{6}/, false],\n            ['YYYY', /\\d{4}/, false],\n        ],\n        // iso time formats and regexes\n        isoTimes = [\n            ['HH:mm:ss.SSSS', /\\d\\d:\\d\\d:\\d\\d\\.\\d+/],\n            ['HH:mm:ss,SSSS', /\\d\\d:\\d\\d:\\d\\d,\\d+/],\n            ['HH:mm:ss', /\\d\\d:\\d\\d:\\d\\d/],\n            ['HH:mm', /\\d\\d:\\d\\d/],\n            ['HHmmss.SSSS', /\\d\\d\\d\\d\\d\\d\\.\\d+/],\n            ['HHmmss,SSSS', /\\d\\d\\d\\d\\d\\d,\\d+/],\n            ['HHmmss', /\\d\\d\\d\\d\\d\\d/],\n            ['HHmm', /\\d\\d\\d\\d/],\n            ['HH', /\\d\\d/],\n        ],\n        aspNetJsonRegex = /^\\/?Date\\((-?\\d+)/i,\n        // RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3\n        rfc2822 =\n            /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\\s)?(\\d{1,2})\\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\\s(\\d{2,4})\\s(\\d\\d):(\\d\\d)(?::(\\d\\d))?\\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\\d{4}))$/,\n        obsOffsets = {\n            UT: 0,\n            GMT: 0,\n            EDT: -4 * 60,\n            EST: -5 * 60,\n            CDT: -5 * 60,\n            CST: -6 * 60,\n            MDT: -6 * 60,\n            MST: -7 * 60,\n            PDT: -7 * 60,\n            PST: -8 * 60,\n        };\n\n    // date from iso format\n    function configFromISO(config) {\n        var i,\n            l,\n            string = config._i,\n            match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),\n            allowTime,\n            dateFormat,\n            timeFormat,\n            tzFormat,\n            isoDatesLen = isoDates.length,\n            isoTimesLen = isoTimes.length;\n\n        if (match) {\n            getParsingFlags(config).iso = true;\n            for (i = 0, l = isoDatesLen; i < l; i++) {\n                if (isoDates[i][1].exec(match[1])) {\n                    dateFormat = isoDates[i][0];\n                    allowTime = isoDates[i][2] !== false;\n                    break;\n                }\n            }\n            if (dateFormat == null) {\n                config._isValid = false;\n                return;\n            }\n            if (match[3]) {\n                for (i = 0, l = isoTimesLen; i < l; i++) {\n                    if (isoTimes[i][1].exec(match[3])) {\n                        // match[2] should be 'T' or space\n                        timeFormat = (match[2] || ' ') + isoTimes[i][0];\n                        break;\n                    }\n                }\n                if (timeFormat == null) {\n                    config._isValid = false;\n                    return;\n                }\n            }\n            if (!allowTime && timeFormat != null) {\n                config._isValid = false;\n                return;\n            }\n            if (match[4]) {\n                if (tzRegex.exec(match[4])) {\n                    tzFormat = 'Z';\n                } else {\n                    config._isValid = false;\n                    return;\n                }\n            }\n            config._f = dateFormat + (timeFormat || '') + (tzFormat || '');\n            configFromStringAndFormat(config);\n        } else {\n            config._isValid = false;\n        }\n    }\n\n    function extractFromRFC2822Strings(\n        yearStr,\n        monthStr,\n        dayStr,\n        hourStr,\n        minuteStr,\n        secondStr\n    ) {\n        var result = [\n            untruncateYear(yearStr),\n            defaultLocaleMonthsShort.indexOf(monthStr),\n            parseInt(dayStr, 10),\n            parseInt(hourStr, 10),\n            parseInt(minuteStr, 10),\n        ];\n\n        if (secondStr) {\n            result.push(parseInt(secondStr, 10));\n        }\n\n        return result;\n    }\n\n    function untruncateYear(yearStr) {\n        var year = parseInt(yearStr, 10);\n        if (year <= 49) {\n            return 2000 + year;\n        } else if (year <= 999) {\n            return 1900 + year;\n        }\n        return year;\n    }\n\n    function preprocessRFC2822(s) {\n        // Remove comments and folding whitespace and replace multiple-spaces with a single space\n        return s\n            .replace(/\\([^()]*\\)|[\\n\\t]/g, ' ')\n            .replace(/(\\s\\s+)/g, ' ')\n            .replace(/^\\s\\s*/, '')\n            .replace(/\\s\\s*$/, '');\n    }\n\n    function checkWeekday(weekdayStr, parsedInput, config) {\n        if (weekdayStr) {\n            // TODO: Replace the vanilla JS Date object with an independent day-of-week check.\n            var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr),\n                weekdayActual = new Date(\n                    parsedInput[0],\n                    parsedInput[1],\n                    parsedInput[2]\n                ).getDay();\n            if (weekdayProvided !== weekdayActual) {\n                getParsingFlags(config).weekdayMismatch = true;\n                config._isValid = false;\n                return false;\n            }\n        }\n        return true;\n    }\n\n    function calculateOffset(obsOffset, militaryOffset, numOffset) {\n        if (obsOffset) {\n            return obsOffsets[obsOffset];\n        } else if (militaryOffset) {\n            // the only allowed military tz is Z\n            return 0;\n        } else {\n            var hm = parseInt(numOffset, 10),\n                m = hm % 100,\n                h = (hm - m) / 100;\n            return h * 60 + m;\n        }\n    }\n\n    // date and time from ref 2822 format\n    function configFromRFC2822(config) {\n        var match = rfc2822.exec(preprocessRFC2822(config._i)),\n            parsedArray;\n        if (match) {\n            parsedArray = extractFromRFC2822Strings(\n                match[4],\n                match[3],\n                match[2],\n                match[5],\n                match[6],\n                match[7]\n            );\n            if (!checkWeekday(match[1], parsedArray, config)) {\n                return;\n            }\n\n            config._a = parsedArray;\n            config._tzm = calculateOffset(match[8], match[9], match[10]);\n\n            config._d = createUTCDate.apply(null, config._a);\n            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);\n\n            getParsingFlags(config).rfc2822 = true;\n        } else {\n            config._isValid = false;\n        }\n    }\n\n    // date from 1) ASP.NET, 2) ISO, 3) RFC 2822 formats, or 4) optional fallback if parsing isn't strict\n    function configFromString(config) {\n        var matched = aspNetJsonRegex.exec(config._i);\n        if (matched !== null) {\n            config._d = new Date(+matched[1]);\n            return;\n        }\n\n        configFromISO(config);\n        if (config._isValid === false) {\n            delete config._isValid;\n        } else {\n            return;\n        }\n\n        configFromRFC2822(config);\n        if (config._isValid === false) {\n            delete config._isValid;\n        } else {\n            return;\n        }\n\n        if (config._strict) {\n            config._isValid = false;\n        } else {\n            // Final attempt, use Input Fallback\n            hooks.createFromInputFallback(config);\n        }\n    }\n\n    hooks.createFromInputFallback = deprecate(\n        'value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' +\n            'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' +\n            'discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.',\n        function (config) {\n            config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));\n        }\n    );\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function currentDateArray(config) {\n        // hooks is actually the exported moment object\n        var nowValue = new Date(hooks.now());\n        if (config._useUTC) {\n            return [\n                nowValue.getUTCFullYear(),\n                nowValue.getUTCMonth(),\n                nowValue.getUTCDate(),\n            ];\n        }\n        return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];\n    }\n\n    // convert an array to a date.\n    // the array should mirror the parameters below\n    // note: all values past the year are optional and will default to the lowest possible value.\n    // [year, month, day , hour, minute, second, millisecond]\n    function configFromArray(config) {\n        var i,\n            date,\n            input = [],\n            currentDate,\n            expectedWeekday,\n            yearToUse;\n\n        if (config._d) {\n            return;\n        }\n\n        currentDate = currentDateArray(config);\n\n        //compute day of the year from weeks and weekdays\n        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {\n            dayOfYearFromWeekInfo(config);\n        }\n\n        //if the day of the year is set, figure out what it is\n        if (config._dayOfYear != null) {\n            yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);\n\n            if (\n                config._dayOfYear > daysInYear(yearToUse) ||\n                config._dayOfYear === 0\n            ) {\n                getParsingFlags(config)._overflowDayOfYear = true;\n            }\n\n            date = createUTCDate(yearToUse, 0, config._dayOfYear);\n            config._a[MONTH] = date.getUTCMonth();\n            config._a[DATE] = date.getUTCDate();\n        }\n\n        // Default to current date.\n        // * if no year, month, day of month are given, default to today\n        // * if day of month is given, default month and year\n        // * if month is given, default only year\n        // * if year is given, don't default anything\n        for (i = 0; i < 3 && config._a[i] == null; ++i) {\n            config._a[i] = input[i] = currentDate[i];\n        }\n\n        // Zero out whatever was not defaulted, including time\n        for (; i < 7; i++) {\n            config._a[i] = input[i] =\n                config._a[i] == null ? (i === 2 ? 1 : 0) : config._a[i];\n        }\n\n        // Check for 24:00:00.000\n        if (\n            config._a[HOUR] === 24 &&\n            config._a[MINUTE] === 0 &&\n            config._a[SECOND] === 0 &&\n            config._a[MILLISECOND] === 0\n        ) {\n            config._nextDay = true;\n            config._a[HOUR] = 0;\n        }\n\n        config._d = (config._useUTC ? createUTCDate : createDate).apply(\n            null,\n            input\n        );\n        expectedWeekday = config._useUTC\n            ? config._d.getUTCDay()\n            : config._d.getDay();\n\n        // Apply timezone offset from input. The actual utcOffset can be changed\n        // with parseZone.\n        if (config._tzm != null) {\n            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);\n        }\n\n        if (config._nextDay) {\n            config._a[HOUR] = 24;\n        }\n\n        // check for mismatching day of week\n        if (\n            config._w &&\n            typeof config._w.d !== 'undefined' &&\n            config._w.d !== expectedWeekday\n        ) {\n            getParsingFlags(config).weekdayMismatch = true;\n        }\n    }\n\n    function dayOfYearFromWeekInfo(config) {\n        var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow, curWeek;\n\n        w = config._w;\n        if (w.GG != null || w.W != null || w.E != null) {\n            dow = 1;\n            doy = 4;\n\n            // TODO: We need to take the current isoWeekYear, but that depends on\n            // how we interpret now (local, utc, fixed offset). So create\n            // a now version of current config (take local/utc/offset flags, and\n            // create now).\n            weekYear = defaults(\n                w.GG,\n                config._a[YEAR],\n                weekOfYear(createLocal(), 1, 4).year\n            );\n            week = defaults(w.W, 1);\n            weekday = defaults(w.E, 1);\n            if (weekday < 1 || weekday > 7) {\n                weekdayOverflow = true;\n            }\n        } else {\n            dow = config._locale._week.dow;\n            doy = config._locale._week.doy;\n\n            curWeek = weekOfYear(createLocal(), dow, doy);\n\n            weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);\n\n            // Default to current week.\n            week = defaults(w.w, curWeek.week);\n\n            if (w.d != null) {\n                // weekday -- low day numbers are considered next week\n                weekday = w.d;\n                if (weekday < 0 || weekday > 6) {\n                    weekdayOverflow = true;\n                }\n            } else if (w.e != null) {\n                // local weekday -- counting starts from beginning of week\n                weekday = w.e + dow;\n                if (w.e < 0 || w.e > 6) {\n                    weekdayOverflow = true;\n                }\n            } else {\n                // default to beginning of week\n                weekday = dow;\n            }\n        }\n        if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {\n            getParsingFlags(config)._overflowWeeks = true;\n        } else if (weekdayOverflow != null) {\n            getParsingFlags(config)._overflowWeekday = true;\n        } else {\n            temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);\n            config._a[YEAR] = temp.year;\n            config._dayOfYear = temp.dayOfYear;\n        }\n    }\n\n    // constant that refers to the ISO standard\n    hooks.ISO_8601 = function () {};\n\n    // constant that refers to the RFC 2822 form\n    hooks.RFC_2822 = function () {};\n\n    // date from string and format string\n    function configFromStringAndFormat(config) {\n        // TODO: Move this to another part of the creation flow to prevent circular deps\n        if (config._f === hooks.ISO_8601) {\n            configFromISO(config);\n            return;\n        }\n        if (config._f === hooks.RFC_2822) {\n            configFromRFC2822(config);\n            return;\n        }\n        config._a = [];\n        getParsingFlags(config).empty = true;\n\n        // This array is used to make a Date, either with `new Date` or `Date.UTC`\n        var string = '' + config._i,\n            i,\n            parsedInput,\n            tokens,\n            token,\n            skipped,\n            stringLength = string.length,\n            totalParsedInputLength = 0,\n            era,\n            tokenLen;\n\n        tokens =\n            expandFormat(config._f, config._locale).match(formattingTokens) || [];\n        tokenLen = tokens.length;\n        for (i = 0; i < tokenLen; i++) {\n            token = tokens[i];\n            parsedInput = (string.match(getParseRegexForToken(token, config)) ||\n                [])[0];\n            if (parsedInput) {\n                skipped = string.substr(0, string.indexOf(parsedInput));\n                if (skipped.length > 0) {\n                    getParsingFlags(config).unusedInput.push(skipped);\n                }\n                string = string.slice(\n                    string.indexOf(parsedInput) + parsedInput.length\n                );\n                totalParsedInputLength += parsedInput.length;\n            }\n            // don't parse if it's not a known token\n            if (formatTokenFunctions[token]) {\n                if (parsedInput) {\n                    getParsingFlags(config).empty = false;\n                } else {\n                    getParsingFlags(config).unusedTokens.push(token);\n                }\n                addTimeToArrayFromToken(token, parsedInput, config);\n            } else if (config._strict && !parsedInput) {\n                getParsingFlags(config).unusedTokens.push(token);\n            }\n        }\n\n        // add remaining unparsed input length to the string\n        getParsingFlags(config).charsLeftOver =\n            stringLength - totalParsedInputLength;\n        if (string.length > 0) {\n            getParsingFlags(config).unusedInput.push(string);\n        }\n\n        // clear _12h flag if hour is <= 12\n        if (\n            config._a[HOUR] <= 12 &&\n            getParsingFlags(config).bigHour === true &&\n            config._a[HOUR] > 0\n        ) {\n            getParsingFlags(config).bigHour = undefined;\n        }\n\n        getParsingFlags(config).parsedDateParts = config._a.slice(0);\n        getParsingFlags(config).meridiem = config._meridiem;\n        // handle meridiem\n        config._a[HOUR] = meridiemFixWrap(\n            config._locale,\n            config._a[HOUR],\n            config._meridiem\n        );\n\n        // handle era\n        era = getParsingFlags(config).era;\n        if (era !== null) {\n            config._a[YEAR] = config._locale.erasConvertYear(era, config._a[YEAR]);\n        }\n\n        configFromArray(config);\n        checkOverflow(config);\n    }\n\n    function meridiemFixWrap(locale, hour, meridiem) {\n        var isPm;\n\n        if (meridiem == null) {\n            // nothing to do\n            return hour;\n        }\n        if (locale.meridiemHour != null) {\n            return locale.meridiemHour(hour, meridiem);\n        } else if (locale.isPM != null) {\n            // Fallback\n            isPm = locale.isPM(meridiem);\n            if (isPm && hour < 12) {\n                hour += 12;\n            }\n            if (!isPm && hour === 12) {\n                hour = 0;\n            }\n            return hour;\n        } else {\n            // this is not supposed to happen\n            return hour;\n        }\n    }\n\n    // date from string and array of format strings\n    function configFromStringAndArray(config) {\n        var tempConfig,\n            bestMoment,\n            scoreToBeat,\n            i,\n            currentScore,\n            validFormatFound,\n            bestFormatIsValid = false,\n            configfLen = config._f.length;\n\n        if (configfLen === 0) {\n            getParsingFlags(config).invalidFormat = true;\n            config._d = new Date(NaN);\n            return;\n        }\n\n        for (i = 0; i < configfLen; i++) {\n            currentScore = 0;\n            validFormatFound = false;\n            tempConfig = copyConfig({}, config);\n            if (config._useUTC != null) {\n                tempConfig._useUTC = config._useUTC;\n            }\n            tempConfig._f = config._f[i];\n            configFromStringAndFormat(tempConfig);\n\n            if (isValid(tempConfig)) {\n                validFormatFound = true;\n            }\n\n            // if there is any input that was not parsed add a penalty for that format\n            currentScore += getParsingFlags(tempConfig).charsLeftOver;\n\n            //or tokens\n            currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;\n\n            getParsingFlags(tempConfig).score = currentScore;\n\n            if (!bestFormatIsValid) {\n                if (\n                    scoreToBeat == null ||\n                    currentScore < scoreToBeat ||\n                    validFormatFound\n                ) {\n                    scoreToBeat = currentScore;\n                    bestMoment = tempConfig;\n                    if (validFormatFound) {\n                        bestFormatIsValid = true;\n                    }\n                }\n            } else {\n                if (currentScore < scoreToBeat) {\n                    scoreToBeat = currentScore;\n                    bestMoment = tempConfig;\n                }\n            }\n        }\n\n        extend(config, bestMoment || tempConfig);\n    }\n\n    function configFromObject(config) {\n        if (config._d) {\n            return;\n        }\n\n        var i = normalizeObjectUnits(config._i),\n            dayOrDate = i.day === undefined ? i.date : i.day;\n        config._a = map(\n            [i.year, i.month, dayOrDate, i.hour, i.minute, i.second, i.millisecond],\n            function (obj) {\n                return obj && parseInt(obj, 10);\n            }\n        );\n\n        configFromArray(config);\n    }\n\n    function createFromConfig(config) {\n        var res = new Moment(checkOverflow(prepareConfig(config)));\n        if (res._nextDay) {\n            // Adding is smart enough around DST\n            res.add(1, 'd');\n            res._nextDay = undefined;\n        }\n\n        return res;\n    }\n\n    function prepareConfig(config) {\n        var input = config._i,\n            format = config._f;\n\n        config._locale = config._locale || getLocale(config._l);\n\n        if (input === null || (format === undefined && input === '')) {\n            return createInvalid({ nullInput: true });\n        }\n\n        if (typeof input === 'string') {\n            config._i = input = config._locale.preparse(input);\n        }\n\n        if (isMoment(input)) {\n            return new Moment(checkOverflow(input));\n        } else if (isDate(input)) {\n            config._d = input;\n        } else if (isArray(format)) {\n            configFromStringAndArray(config);\n        } else if (format) {\n            configFromStringAndFormat(config);\n        } else {\n            configFromInput(config);\n        }\n\n        if (!isValid(config)) {\n            config._d = null;\n        }\n\n        return config;\n    }\n\n    function configFromInput(config) {\n        var input = config._i;\n        if (isUndefined(input)) {\n            config._d = new Date(hooks.now());\n        } else if (isDate(input)) {\n            config._d = new Date(input.valueOf());\n        } else if (typeof input === 'string') {\n            configFromString(config);\n        } else if (isArray(input)) {\n            config._a = map(input.slice(0), function (obj) {\n                return parseInt(obj, 10);\n            });\n            configFromArray(config);\n        } else if (isObject(input)) {\n            configFromObject(config);\n        } else if (isNumber(input)) {\n            // from milliseconds\n            config._d = new Date(input);\n        } else {\n            hooks.createFromInputFallback(config);\n        }\n    }\n\n    function createLocalOrUTC(input, format, locale, strict, isUTC) {\n        var c = {};\n\n        if (format === true || format === false) {\n            strict = format;\n            format = undefined;\n        }\n\n        if (locale === true || locale === false) {\n            strict = locale;\n            locale = undefined;\n        }\n\n        if (\n            (isObject(input) && isObjectEmpty(input)) ||\n            (isArray(input) && input.length === 0)\n        ) {\n            input = undefined;\n        }\n        // object construction must be done this way.\n        // https://github.com/moment/moment/issues/1423\n        c._isAMomentObject = true;\n        c._useUTC = c._isUTC = isUTC;\n        c._l = locale;\n        c._i = input;\n        c._f = format;\n        c._strict = strict;\n\n        return createFromConfig(c);\n    }\n\n    function createLocal(input, format, locale, strict) {\n        return createLocalOrUTC(input, format, locale, strict, false);\n    }\n\n    var prototypeMin = deprecate(\n            'moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/',\n            function () {\n                var other = createLocal.apply(null, arguments);\n                if (this.isValid() && other.isValid()) {\n                    return other < this ? this : other;\n                } else {\n                    return createInvalid();\n                }\n            }\n        ),\n        prototypeMax = deprecate(\n            'moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/',\n            function () {\n                var other = createLocal.apply(null, arguments);\n                if (this.isValid() && other.isValid()) {\n                    return other > this ? this : other;\n                } else {\n                    return createInvalid();\n                }\n            }\n        );\n\n    // Pick a moment m from moments so that m[fn](other) is true for all\n    // other. This relies on the function fn to be transitive.\n    //\n    // moments should either be an array of moment objects or an array, whose\n    // first element is an array of moment objects.\n    function pickBy(fn, moments) {\n        var res, i;\n        if (moments.length === 1 && isArray(moments[0])) {\n            moments = moments[0];\n        }\n        if (!moments.length) {\n            return createLocal();\n        }\n        res = moments[0];\n        for (i = 1; i < moments.length; ++i) {\n            if (!moments[i].isValid() || moments[i][fn](res)) {\n                res = moments[i];\n            }\n        }\n        return res;\n    }\n\n    // TODO: Use [].sort instead?\n    function min() {\n        var args = [].slice.call(arguments, 0);\n\n        return pickBy('isBefore', args);\n    }\n\n    function max() {\n        var args = [].slice.call(arguments, 0);\n\n        return pickBy('isAfter', args);\n    }\n\n    var now = function () {\n        return Date.now ? Date.now() : +new Date();\n    };\n\n    var ordering = [\n        'year',\n        'quarter',\n        'month',\n        'week',\n        'day',\n        'hour',\n        'minute',\n        'second',\n        'millisecond',\n    ];\n\n    function isDurationValid(m) {\n        var key,\n            unitHasDecimal = false,\n            i,\n            orderLen = ordering.length;\n        for (key in m) {\n            if (\n                hasOwnProp(m, key) &&\n                !(\n                    indexOf.call(ordering, key) !== -1 &&\n                    (m[key] == null || !isNaN(m[key]))\n                )\n            ) {\n                return false;\n            }\n        }\n\n        for (i = 0; i < orderLen; ++i) {\n            if (m[ordering[i]]) {\n                if (unitHasDecimal) {\n                    return false; // only allow non-integers for smallest unit\n                }\n                if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {\n                    unitHasDecimal = true;\n                }\n            }\n        }\n\n        return true;\n    }\n\n    function isValid$1() {\n        return this._isValid;\n    }\n\n    function createInvalid$1() {\n        return createDuration(NaN);\n    }\n\n    function Duration(duration) {\n        var normalizedInput = normalizeObjectUnits(duration),\n            years = normalizedInput.year || 0,\n            quarters = normalizedInput.quarter || 0,\n            months = normalizedInput.month || 0,\n            weeks = normalizedInput.week || normalizedInput.isoWeek || 0,\n            days = normalizedInput.day || 0,\n            hours = normalizedInput.hour || 0,\n            minutes = normalizedInput.minute || 0,\n            seconds = normalizedInput.second || 0,\n            milliseconds = normalizedInput.millisecond || 0;\n\n        this._isValid = isDurationValid(normalizedInput);\n\n        // representation for dateAddRemove\n        this._milliseconds =\n            +milliseconds +\n            seconds * 1e3 + // 1000\n            minutes * 6e4 + // 1000 * 60\n            hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978\n        // Because of dateAddRemove treats 24 hours as different from a\n        // day when working around DST, we need to store them separately\n        this._days = +days + weeks * 7;\n        // It is impossible to translate months into days without knowing\n        // which months you are are talking about, so we have to store\n        // it separately.\n        this._months = +months + quarters * 3 + years * 12;\n\n        this._data = {};\n\n        this._locale = getLocale();\n\n        this._bubble();\n    }\n\n    function isDuration(obj) {\n        return obj instanceof Duration;\n    }\n\n    function absRound(number) {\n        if (number < 0) {\n            return Math.round(-1 * number) * -1;\n        } else {\n            return Math.round(number);\n        }\n    }\n\n    // compare two arrays, return the number of differences\n    function compareArrays(array1, array2, dontConvert) {\n        var len = Math.min(array1.length, array2.length),\n            lengthDiff = Math.abs(array1.length - array2.length),\n            diffs = 0,\n            i;\n        for (i = 0; i < len; i++) {\n            if (\n                (dontConvert && array1[i] !== array2[i]) ||\n                (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))\n            ) {\n                diffs++;\n            }\n        }\n        return diffs + lengthDiff;\n    }\n\n    // FORMATTING\n\n    function offset(token, separator) {\n        addFormatToken(token, 0, 0, function () {\n            var offset = this.utcOffset(),\n                sign = '+';\n            if (offset < 0) {\n                offset = -offset;\n                sign = '-';\n            }\n            return (\n                sign +\n                zeroFill(~~(offset / 60), 2) +\n                separator +\n                zeroFill(~~offset % 60, 2)\n            );\n        });\n    }\n\n    offset('Z', ':');\n    offset('ZZ', '');\n\n    // PARSING\n\n    addRegexToken('Z', matchShortOffset);\n    addRegexToken('ZZ', matchShortOffset);\n    addParseToken(['Z', 'ZZ'], function (input, array, config) {\n        config._useUTC = true;\n        config._tzm = offsetFromString(matchShortOffset, input);\n    });\n\n    // HELPERS\n\n    // timezone chunker\n    // '+10:00' > ['10',  '00']\n    // '-1530'  > ['-15', '30']\n    var chunkOffset = /([\\+\\-]|\\d\\d)/gi;\n\n    function offsetFromString(matcher, string) {\n        var matches = (string || '').match(matcher),\n            chunk,\n            parts,\n            minutes;\n\n        if (matches === null) {\n            return null;\n        }\n\n        chunk = matches[matches.length - 1] || [];\n        parts = (chunk + '').match(chunkOffset) || ['-', 0, 0];\n        minutes = +(parts[1] * 60) + toInt(parts[2]);\n\n        return minutes === 0 ? 0 : parts[0] === '+' ? minutes : -minutes;\n    }\n\n    // Return a moment from input, that is local/utc/zone equivalent to model.\n    function cloneWithOffset(input, model) {\n        var res, diff;\n        if (model._isUTC) {\n            res = model.clone();\n            diff =\n                (isMoment(input) || isDate(input)\n                    ? input.valueOf()\n                    : createLocal(input).valueOf()) - res.valueOf();\n            // Use low-level api, because this fn is low-level api.\n            res._d.setTime(res._d.valueOf() + diff);\n            hooks.updateOffset(res, false);\n            return res;\n        } else {\n            return createLocal(input).local();\n        }\n    }\n\n    function getDateOffset(m) {\n        // On Firefox.24 Date#getTimezoneOffset returns a floating point.\n        // https://github.com/moment/moment/pull/1871\n        return -Math.round(m._d.getTimezoneOffset());\n    }\n\n    // HOOKS\n\n    // This function will be called whenever a moment is mutated.\n    // It is intended to keep the offset in sync with the timezone.\n    hooks.updateOffset = function () {};\n\n    // MOMENTS\n\n    // keepLocalTime = true means only change the timezone, without\n    // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->\n    // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset\n    // +0200, so we adjust the time as needed, to be valid.\n    //\n    // Keeping the time actually adds/subtracts (one hour)\n    // from the actual represented time. That is why we call updateOffset\n    // a second time. In case it wants us to change the offset again\n    // _changeInProgress == true case, then we have to adjust, because\n    // there is no such time in the given timezone.\n    function getSetOffset(input, keepLocalTime, keepMinutes) {\n        var offset = this._offset || 0,\n            localAdjust;\n        if (!this.isValid()) {\n            return input != null ? this : NaN;\n        }\n        if (input != null) {\n            if (typeof input === 'string') {\n                input = offsetFromString(matchShortOffset, input);\n                if (input === null) {\n                    return this;\n                }\n            } else if (Math.abs(input) < 16 && !keepMinutes) {\n                input = input * 60;\n            }\n            if (!this._isUTC && keepLocalTime) {\n                localAdjust = getDateOffset(this);\n            }\n            this._offset = input;\n            this._isUTC = true;\n            if (localAdjust != null) {\n                this.add(localAdjust, 'm');\n            }\n            if (offset !== input) {\n                if (!keepLocalTime || this._changeInProgress) {\n                    addSubtract(\n                        this,\n                        createDuration(input - offset, 'm'),\n                        1,\n                        false\n                    );\n                } else if (!this._changeInProgress) {\n                    this._changeInProgress = true;\n                    hooks.updateOffset(this, true);\n                    this._changeInProgress = null;\n                }\n            }\n            return this;\n        } else {\n            return this._isUTC ? offset : getDateOffset(this);\n        }\n    }\n\n    function getSetZone(input, keepLocalTime) {\n        if (input != null) {\n            if (typeof input !== 'string') {\n                input = -input;\n            }\n\n            this.utcOffset(input, keepLocalTime);\n\n            return this;\n        } else {\n            return -this.utcOffset();\n        }\n    }\n\n    function setOffsetToUTC(keepLocalTime) {\n        return this.utcOffset(0, keepLocalTime);\n    }\n\n    function setOffsetToLocal(keepLocalTime) {\n        if (this._isUTC) {\n            this.utcOffset(0, keepLocalTime);\n            this._isUTC = false;\n\n            if (keepLocalTime) {\n                this.subtract(getDateOffset(this), 'm');\n            }\n        }\n        return this;\n    }\n\n    function setOffsetToParsedOffset() {\n        if (this._tzm != null) {\n            this.utcOffset(this._tzm, false, true);\n        } else if (typeof this._i === 'string') {\n            var tZone = offsetFromString(matchOffset, this._i);\n            if (tZone != null) {\n                this.utcOffset(tZone);\n            } else {\n                this.utcOffset(0, true);\n            }\n        }\n        return this;\n    }\n\n    function hasAlignedHourOffset(input) {\n        if (!this.isValid()) {\n            return false;\n        }\n        input = input ? createLocal(input).utcOffset() : 0;\n\n        return (this.utcOffset() - input) % 60 === 0;\n    }\n\n    function isDaylightSavingTime() {\n        return (\n            this.utcOffset() > this.clone().month(0).utcOffset() ||\n            this.utcOffset() > this.clone().month(5).utcOffset()\n        );\n    }\n\n    function isDaylightSavingTimeShifted() {\n        if (!isUndefined(this._isDSTShifted)) {\n            return this._isDSTShifted;\n        }\n\n        var c = {},\n            other;\n\n        copyConfig(c, this);\n        c = prepareConfig(c);\n\n        if (c._a) {\n            other = c._isUTC ? createUTC(c._a) : createLocal(c._a);\n            this._isDSTShifted =\n                this.isValid() && compareArrays(c._a, other.toArray()) > 0;\n        } else {\n            this._isDSTShifted = false;\n        }\n\n        return this._isDSTShifted;\n    }\n\n    function isLocal() {\n        return this.isValid() ? !this._isUTC : false;\n    }\n\n    function isUtcOffset() {\n        return this.isValid() ? this._isUTC : false;\n    }\n\n    function isUtc() {\n        return this.isValid() ? this._isUTC && this._offset === 0 : false;\n    }\n\n    // ASP.NET json date format regex\n    var aspNetRegex = /^(-|\\+)?(?:(\\d*)[. ])?(\\d+):(\\d+)(?::(\\d+)(\\.\\d*)?)?$/,\n        // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html\n        // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere\n        // and further modified to allow for strings containing both week and day\n        isoRegex =\n            /^(-|\\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;\n\n    function createDuration(input, key) {\n        var duration = input,\n            // matching against regexp is expensive, do it on demand\n            match = null,\n            sign,\n            ret,\n            diffRes;\n\n        if (isDuration(input)) {\n            duration = {\n                ms: input._milliseconds,\n                d: input._days,\n                M: input._months,\n            };\n        } else if (isNumber(input) || !isNaN(+input)) {\n            duration = {};\n            if (key) {\n                duration[key] = +input;\n            } else {\n                duration.milliseconds = +input;\n            }\n        } else if ((match = aspNetRegex.exec(input))) {\n            sign = match[1] === '-' ? -1 : 1;\n            duration = {\n                y: 0,\n                d: toInt(match[DATE]) * sign,\n                h: toInt(match[HOUR]) * sign,\n                m: toInt(match[MINUTE]) * sign,\n                s: toInt(match[SECOND]) * sign,\n                ms: toInt(absRound(match[MILLISECOND] * 1000)) * sign, // the millisecond decimal point is included in the match\n            };\n        } else if ((match = isoRegex.exec(input))) {\n            sign = match[1] === '-' ? -1 : 1;\n            duration = {\n                y: parseIso(match[2], sign),\n                M: parseIso(match[3], sign),\n                w: parseIso(match[4], sign),\n                d: parseIso(match[5], sign),\n                h: parseIso(match[6], sign),\n                m: parseIso(match[7], sign),\n                s: parseIso(match[8], sign),\n            };\n        } else if (duration == null) {\n            // checks for null or undefined\n            duration = {};\n        } else if (\n            typeof duration === 'object' &&\n            ('from' in duration || 'to' in duration)\n        ) {\n            diffRes = momentsDifference(\n                createLocal(duration.from),\n                createLocal(duration.to)\n            );\n\n            duration = {};\n            duration.ms = diffRes.milliseconds;\n            duration.M = diffRes.months;\n        }\n\n        ret = new Duration(duration);\n\n        if (isDuration(input) && hasOwnProp(input, '_locale')) {\n            ret._locale = input._locale;\n        }\n\n        if (isDuration(input) && hasOwnProp(input, '_isValid')) {\n            ret._isValid = input._isValid;\n        }\n\n        return ret;\n    }\n\n    createDuration.fn = Duration.prototype;\n    createDuration.invalid = createInvalid$1;\n\n    function parseIso(inp, sign) {\n        // We'd normally use ~~inp for this, but unfortunately it also\n        // converts floats to ints.\n        // inp may be undefined, so careful calling replace on it.\n        var res = inp && parseFloat(inp.replace(',', '.'));\n        // apply sign while we're at it\n        return (isNaN(res) ? 0 : res) * sign;\n    }\n\n    function positiveMomentsDifference(base, other) {\n        var res = {};\n\n        res.months =\n            other.month() - base.month() + (other.year() - base.year()) * 12;\n        if (base.clone().add(res.months, 'M').isAfter(other)) {\n            --res.months;\n        }\n\n        res.milliseconds = +other - +base.clone().add(res.months, 'M');\n\n        return res;\n    }\n\n    function momentsDifference(base, other) {\n        var res;\n        if (!(base.isValid() && other.isValid())) {\n            return { milliseconds: 0, months: 0 };\n        }\n\n        other = cloneWithOffset(other, base);\n        if (base.isBefore(other)) {\n            res = positiveMomentsDifference(base, other);\n        } else {\n            res = positiveMomentsDifference(other, base);\n            res.milliseconds = -res.milliseconds;\n            res.months = -res.months;\n        }\n\n        return res;\n    }\n\n    // TODO: remove 'name' arg after deprecation is removed\n    function createAdder(direction, name) {\n        return function (val, period) {\n            var dur, tmp;\n            //invert the arguments, but complain about it\n            if (period !== null && !isNaN(+period)) {\n                deprecateSimple(\n                    name,\n                    'moment().' +\n                        name +\n                        '(period, number) is deprecated. Please use moment().' +\n                        name +\n                        '(number, period). ' +\n                        'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.'\n                );\n                tmp = val;\n                val = period;\n                period = tmp;\n            }\n\n            dur = createDuration(val, period);\n            addSubtract(this, dur, direction);\n            return this;\n        };\n    }\n\n    function addSubtract(mom, duration, isAdding, updateOffset) {\n        var milliseconds = duration._milliseconds,\n            days = absRound(duration._days),\n            months = absRound(duration._months);\n\n        if (!mom.isValid()) {\n            // No op\n            return;\n        }\n\n        updateOffset = updateOffset == null ? true : updateOffset;\n\n        if (months) {\n            setMonth(mom, get(mom, 'Month') + months * isAdding);\n        }\n        if (days) {\n            set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);\n        }\n        if (milliseconds) {\n            mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);\n        }\n        if (updateOffset) {\n            hooks.updateOffset(mom, days || months);\n        }\n    }\n\n    var add = createAdder(1, 'add'),\n        subtract = createAdder(-1, 'subtract');\n\n    function isString(input) {\n        return typeof input === 'string' || input instanceof String;\n    }\n\n    // type MomentInput = Moment | Date | string | number | (number | string)[] | MomentInputObject | void; // null | undefined\n    function isMomentInput(input) {\n        return (\n            isMoment(input) ||\n            isDate(input) ||\n            isString(input) ||\n            isNumber(input) ||\n            isNumberOrStringArray(input) ||\n            isMomentInputObject(input) ||\n            input === null ||\n            input === undefined\n        );\n    }\n\n    function isMomentInputObject(input) {\n        var objectTest = isObject(input) && !isObjectEmpty(input),\n            propertyTest = false,\n            properties = [\n                'years',\n                'year',\n                'y',\n                'months',\n                'month',\n                'M',\n                'days',\n                'day',\n                'd',\n                'dates',\n                'date',\n                'D',\n                'hours',\n                'hour',\n                'h',\n                'minutes',\n                'minute',\n                'm',\n                'seconds',\n                'second',\n                's',\n                'milliseconds',\n                'millisecond',\n                'ms',\n            ],\n            i,\n            property,\n            propertyLen = properties.length;\n\n        for (i = 0; i < propertyLen; i += 1) {\n            property = properties[i];\n            propertyTest = propertyTest || hasOwnProp(input, property);\n        }\n\n        return objectTest && propertyTest;\n    }\n\n    function isNumberOrStringArray(input) {\n        var arrayTest = isArray(input),\n            dataTypeTest = false;\n        if (arrayTest) {\n            dataTypeTest =\n                input.filter(function (item) {\n                    return !isNumber(item) && isString(input);\n                }).length === 0;\n        }\n        return arrayTest && dataTypeTest;\n    }\n\n    function isCalendarSpec(input) {\n        var objectTest = isObject(input) && !isObjectEmpty(input),\n            propertyTest = false,\n            properties = [\n                'sameDay',\n                'nextDay',\n                'lastDay',\n                'nextWeek',\n                'lastWeek',\n                'sameElse',\n            ],\n            i,\n            property;\n\n        for (i = 0; i < properties.length; i += 1) {\n            property = properties[i];\n            propertyTest = propertyTest || hasOwnProp(input, property);\n        }\n\n        return objectTest && propertyTest;\n    }\n\n    function getCalendarFormat(myMoment, now) {\n        var diff = myMoment.diff(now, 'days', true);\n        return diff < -6\n            ? 'sameElse'\n            : diff < -1\n            ? 'lastWeek'\n            : diff < 0\n            ? 'lastDay'\n            : diff < 1\n            ? 'sameDay'\n            : diff < 2\n            ? 'nextDay'\n            : diff < 7\n            ? 'nextWeek'\n            : 'sameElse';\n    }\n\n    function calendar$1(time, formats) {\n        // Support for single parameter, formats only overload to the calendar function\n        if (arguments.length === 1) {\n            if (!arguments[0]) {\n                time = undefined;\n                formats = undefined;\n            } else if (isMomentInput(arguments[0])) {\n                time = arguments[0];\n                formats = undefined;\n            } else if (isCalendarSpec(arguments[0])) {\n                formats = arguments[0];\n                time = undefined;\n            }\n        }\n        // We want to compare the start of today, vs this.\n        // Getting start-of-today depends on whether we're local/utc/offset or not.\n        var now = time || createLocal(),\n            sod = cloneWithOffset(now, this).startOf('day'),\n            format = hooks.calendarFormat(this, sod) || 'sameElse',\n            output =\n                formats &&\n                (isFunction(formats[format])\n                    ? formats[format].call(this, now)\n                    : formats[format]);\n\n        return this.format(\n            output || this.localeData().calendar(format, this, createLocal(now))\n        );\n    }\n\n    function clone() {\n        return new Moment(this);\n    }\n\n    function isAfter(input, units) {\n        var localInput = isMoment(input) ? input : createLocal(input);\n        if (!(this.isValid() && localInput.isValid())) {\n            return false;\n        }\n        units = normalizeUnits(units) || 'millisecond';\n        if (units === 'millisecond') {\n            return this.valueOf() > localInput.valueOf();\n        } else {\n            return localInput.valueOf() < this.clone().startOf(units).valueOf();\n        }\n    }\n\n    function isBefore(input, units) {\n        var localInput = isMoment(input) ? input : createLocal(input);\n        if (!(this.isValid() && localInput.isValid())) {\n            return false;\n        }\n        units = normalizeUnits(units) || 'millisecond';\n        if (units === 'millisecond') {\n            return this.valueOf() < localInput.valueOf();\n        } else {\n            return this.clone().endOf(units).valueOf() < localInput.valueOf();\n        }\n    }\n\n    function isBetween(from, to, units, inclusivity) {\n        var localFrom = isMoment(from) ? from : createLocal(from),\n            localTo = isMoment(to) ? to : createLocal(to);\n        if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {\n            return false;\n        }\n        inclusivity = inclusivity || '()';\n        return (\n            (inclusivity[0] === '('\n                ? this.isAfter(localFrom, units)\n                : !this.isBefore(localFrom, units)) &&\n            (inclusivity[1] === ')'\n                ? this.isBefore(localTo, units)\n                : !this.isAfter(localTo, units))\n        );\n    }\n\n    function isSame(input, units) {\n        var localInput = isMoment(input) ? input : createLocal(input),\n            inputMs;\n        if (!(this.isValid() && localInput.isValid())) {\n            return false;\n        }\n        units = normalizeUnits(units) || 'millisecond';\n        if (units === 'millisecond') {\n            return this.valueOf() === localInput.valueOf();\n        } else {\n            inputMs = localInput.valueOf();\n            return (\n                this.clone().startOf(units).valueOf() <= inputMs &&\n                inputMs <= this.clone().endOf(units).valueOf()\n            );\n        }\n    }\n\n    function isSameOrAfter(input, units) {\n        return this.isSame(input, units) || this.isAfter(input, units);\n    }\n\n    function isSameOrBefore(input, units) {\n        return this.isSame(input, units) || this.isBefore(input, units);\n    }\n\n    function diff(input, units, asFloat) {\n        var that, zoneDelta, output;\n\n        if (!this.isValid()) {\n            return NaN;\n        }\n\n        that = cloneWithOffset(input, this);\n\n        if (!that.isValid()) {\n            return NaN;\n        }\n\n        zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;\n\n        units = normalizeUnits(units);\n\n        switch (units) {\n            case 'year':\n                output = monthDiff(this, that) / 12;\n                break;\n            case 'month':\n                output = monthDiff(this, that);\n                break;\n            case 'quarter':\n                output = monthDiff(this, that) / 3;\n                break;\n            case 'second':\n                output = (this - that) / 1e3;\n                break; // 1000\n            case 'minute':\n                output = (this - that) / 6e4;\n                break; // 1000 * 60\n            case 'hour':\n                output = (this - that) / 36e5;\n                break; // 1000 * 60 * 60\n            case 'day':\n                output = (this - that - zoneDelta) / 864e5;\n                break; // 1000 * 60 * 60 * 24, negate dst\n            case 'week':\n                output = (this - that - zoneDelta) / 6048e5;\n                break; // 1000 * 60 * 60 * 24 * 7, negate dst\n            default:\n                output = this - that;\n        }\n\n        return asFloat ? output : absFloor(output);\n    }\n\n    function monthDiff(a, b) {\n        if (a.date() < b.date()) {\n            // end-of-month calculations work correct when the start month has more\n            // days than the end month.\n            return -monthDiff(b, a);\n        }\n        // difference in months\n        var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()),\n            // b is in (anchor - 1 month, anchor + 1 month)\n            anchor = a.clone().add(wholeMonthDiff, 'months'),\n            anchor2,\n            adjust;\n\n        if (b - anchor < 0) {\n            anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');\n            // linear across the month\n            adjust = (b - anchor) / (anchor - anchor2);\n        } else {\n            anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');\n            // linear across the month\n            adjust = (b - anchor) / (anchor2 - anchor);\n        }\n\n        //check for negative zero, return zero if negative zero\n        return -(wholeMonthDiff + adjust) || 0;\n    }\n\n    hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';\n    hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';\n\n    function toString() {\n        return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');\n    }\n\n    function toISOString(keepOffset) {\n        if (!this.isValid()) {\n            return null;\n        }\n        var utc = keepOffset !== true,\n            m = utc ? this.clone().utc() : this;\n        if (m.year() < 0 || m.year() > 9999) {\n            return formatMoment(\n                m,\n                utc\n                    ? 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]'\n                    : 'YYYYYY-MM-DD[T]HH:mm:ss.SSSZ'\n            );\n        }\n        if (isFunction(Date.prototype.toISOString)) {\n            // native implementation is ~50x faster, use it when we can\n            if (utc) {\n                return this.toDate().toISOString();\n            } else {\n                return new Date(this.valueOf() + this.utcOffset() * 60 * 1000)\n                    .toISOString()\n                    .replace('Z', formatMoment(m, 'Z'));\n            }\n        }\n        return formatMoment(\n            m,\n            utc ? 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYY-MM-DD[T]HH:mm:ss.SSSZ'\n        );\n    }\n\n    /**\n     * Return a human readable representation of a moment that can\n     * also be evaluated to get a new moment which is the same\n     *\n     * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects\n     */\n    function inspect() {\n        if (!this.isValid()) {\n            return 'moment.invalid(/* ' + this._i + ' */)';\n        }\n        var func = 'moment',\n            zone = '',\n            prefix,\n            year,\n            datetime,\n            suffix;\n        if (!this.isLocal()) {\n            func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';\n            zone = 'Z';\n        }\n        prefix = '[' + func + '(\"]';\n        year = 0 <= this.year() && this.year() <= 9999 ? 'YYYY' : 'YYYYYY';\n        datetime = '-MM-DD[T]HH:mm:ss.SSS';\n        suffix = zone + '[\")]';\n\n        return this.format(prefix + year + datetime + suffix);\n    }\n\n    function format(inputString) {\n        if (!inputString) {\n            inputString = this.isUtc()\n                ? hooks.defaultFormatUtc\n                : hooks.defaultFormat;\n        }\n        var output = formatMoment(this, inputString);\n        return this.localeData().postformat(output);\n    }\n\n    function from(time, withoutSuffix) {\n        if (\n            this.isValid() &&\n            ((isMoment(time) && time.isValid()) || createLocal(time).isValid())\n        ) {\n            return createDuration({ to: this, from: time })\n                .locale(this.locale())\n                .humanize(!withoutSuffix);\n        } else {\n            return this.localeData().invalidDate();\n        }\n    }\n\n    function fromNow(withoutSuffix) {\n        return this.from(createLocal(), withoutSuffix);\n    }\n\n    function to(time, withoutSuffix) {\n        if (\n            this.isValid() &&\n            ((isMoment(time) && time.isValid()) || createLocal(time).isValid())\n        ) {\n            return createDuration({ from: this, to: time })\n                .locale(this.locale())\n                .humanize(!withoutSuffix);\n        } else {\n            return this.localeData().invalidDate();\n        }\n    }\n\n    function toNow(withoutSuffix) {\n        return this.to(createLocal(), withoutSuffix);\n    }\n\n    // If passed a locale key, it will set the locale for this\n    // instance.  Otherwise, it will return the locale configuration\n    // variables for this instance.\n    function locale(key) {\n        var newLocaleData;\n\n        if (key === undefined) {\n            return this._locale._abbr;\n        } else {\n            newLocaleData = getLocale(key);\n            if (newLocaleData != null) {\n                this._locale = newLocaleData;\n            }\n            return this;\n        }\n    }\n\n    var lang = deprecate(\n        'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',\n        function (key) {\n            if (key === undefined) {\n                return this.localeData();\n            } else {\n                return this.locale(key);\n            }\n        }\n    );\n\n    function localeData() {\n        return this._locale;\n    }\n\n    var MS_PER_SECOND = 1000,\n        MS_PER_MINUTE = 60 * MS_PER_SECOND,\n        MS_PER_HOUR = 60 * MS_PER_MINUTE,\n        MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;\n\n    // actual modulo - handles negative numbers (for dates before 1970):\n    function mod$1(dividend, divisor) {\n        return ((dividend % divisor) + divisor) % divisor;\n    }\n\n    function localStartOfDate(y, m, d) {\n        // the date constructor remaps years 0-99 to 1900-1999\n        if (y < 100 && y >= 0) {\n            // preserve leap years using a full 400 year cycle, then reset\n            return new Date(y + 400, m, d) - MS_PER_400_YEARS;\n        } else {\n            return new Date(y, m, d).valueOf();\n        }\n    }\n\n    function utcStartOfDate(y, m, d) {\n        // Date.UTC remaps years 0-99 to 1900-1999\n        if (y < 100 && y >= 0) {\n            // preserve leap years using a full 400 year cycle, then reset\n            return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;\n        } else {\n            return Date.UTC(y, m, d);\n        }\n    }\n\n    function startOf(units) {\n        var time, startOfDate;\n        units = normalizeUnits(units);\n        if (units === undefined || units === 'millisecond' || !this.isValid()) {\n            return this;\n        }\n\n        startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;\n\n        switch (units) {\n            case 'year':\n                time = startOfDate(this.year(), 0, 1);\n                break;\n            case 'quarter':\n                time = startOfDate(\n                    this.year(),\n                    this.month() - (this.month() % 3),\n                    1\n                );\n                break;\n            case 'month':\n                time = startOfDate(this.year(), this.month(), 1);\n                break;\n            case 'week':\n                time = startOfDate(\n                    this.year(),\n                    this.month(),\n                    this.date() - this.weekday()\n                );\n                break;\n            case 'isoWeek':\n                time = startOfDate(\n                    this.year(),\n                    this.month(),\n                    this.date() - (this.isoWeekday() - 1)\n                );\n                break;\n            case 'day':\n            case 'date':\n                time = startOfDate(this.year(), this.month(), this.date());\n                break;\n            case 'hour':\n                time = this._d.valueOf();\n                time -= mod$1(\n                    time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),\n                    MS_PER_HOUR\n                );\n                break;\n            case 'minute':\n                time = this._d.valueOf();\n                time -= mod$1(time, MS_PER_MINUTE);\n                break;\n            case 'second':\n                time = this._d.valueOf();\n                time -= mod$1(time, MS_PER_SECOND);\n                break;\n        }\n\n        this._d.setTime(time);\n        hooks.updateOffset(this, true);\n        return this;\n    }\n\n    function endOf(units) {\n        var time, startOfDate;\n        units = normalizeUnits(units);\n        if (units === undefined || units === 'millisecond' || !this.isValid()) {\n            return this;\n        }\n\n        startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;\n\n        switch (units) {\n            case 'year':\n                time = startOfDate(this.year() + 1, 0, 1) - 1;\n                break;\n            case 'quarter':\n                time =\n                    startOfDate(\n                        this.year(),\n                        this.month() - (this.month() % 3) + 3,\n                        1\n                    ) - 1;\n                break;\n            case 'month':\n                time = startOfDate(this.year(), this.month() + 1, 1) - 1;\n                break;\n            case 'week':\n                time =\n                    startOfDate(\n                        this.year(),\n                        this.month(),\n                        this.date() - this.weekday() + 7\n                    ) - 1;\n                break;\n            case 'isoWeek':\n                time =\n                    startOfDate(\n                        this.year(),\n                        this.month(),\n                        this.date() - (this.isoWeekday() - 1) + 7\n                    ) - 1;\n                break;\n            case 'day':\n            case 'date':\n                time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;\n                break;\n            case 'hour':\n                time = this._d.valueOf();\n                time +=\n                    MS_PER_HOUR -\n                    mod$1(\n                        time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),\n                        MS_PER_HOUR\n                    ) -\n                    1;\n                break;\n            case 'minute':\n                time = this._d.valueOf();\n                time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;\n                break;\n            case 'second':\n                time = this._d.valueOf();\n                time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;\n                break;\n        }\n\n        this._d.setTime(time);\n        hooks.updateOffset(this, true);\n        return this;\n    }\n\n    function valueOf() {\n        return this._d.valueOf() - (this._offset || 0) * 60000;\n    }\n\n    function unix() {\n        return Math.floor(this.valueOf() / 1000);\n    }\n\n    function toDate() {\n        return new Date(this.valueOf());\n    }\n\n    function toArray() {\n        var m = this;\n        return [\n            m.year(),\n            m.month(),\n            m.date(),\n            m.hour(),\n            m.minute(),\n            m.second(),\n            m.millisecond(),\n        ];\n    }\n\n    function toObject() {\n        var m = this;\n        return {\n            years: m.year(),\n            months: m.month(),\n            date: m.date(),\n            hours: m.hours(),\n            minutes: m.minutes(),\n            seconds: m.seconds(),\n            milliseconds: m.milliseconds(),\n        };\n    }\n\n    function toJSON() {\n        // new Date(NaN).toJSON() === null\n        return this.isValid() ? this.toISOString() : null;\n    }\n\n    function isValid$2() {\n        return isValid(this);\n    }\n\n    function parsingFlags() {\n        return extend({}, getParsingFlags(this));\n    }\n\n    function invalidAt() {\n        return getParsingFlags(this).overflow;\n    }\n\n    function creationData() {\n        return {\n            input: this._i,\n            format: this._f,\n            locale: this._locale,\n            isUTC: this._isUTC,\n            strict: this._strict,\n        };\n    }\n\n    addFormatToken('N', 0, 0, 'eraAbbr');\n    addFormatToken('NN', 0, 0, 'eraAbbr');\n    addFormatToken('NNN', 0, 0, 'eraAbbr');\n    addFormatToken('NNNN', 0, 0, 'eraName');\n    addFormatToken('NNNNN', 0, 0, 'eraNarrow');\n\n    addFormatToken('y', ['y', 1], 'yo', 'eraYear');\n    addFormatToken('y', ['yy', 2], 0, 'eraYear');\n    addFormatToken('y', ['yyy', 3], 0, 'eraYear');\n    addFormatToken('y', ['yyyy', 4], 0, 'eraYear');\n\n    addRegexToken('N', matchEraAbbr);\n    addRegexToken('NN', matchEraAbbr);\n    addRegexToken('NNN', matchEraAbbr);\n    addRegexToken('NNNN', matchEraName);\n    addRegexToken('NNNNN', matchEraNarrow);\n\n    addParseToken(\n        ['N', 'NN', 'NNN', 'NNNN', 'NNNNN'],\n        function (input, array, config, token) {\n            var era = config._locale.erasParse(input, token, config._strict);\n            if (era) {\n                getParsingFlags(config).era = era;\n            } else {\n                getParsingFlags(config).invalidEra = input;\n            }\n        }\n    );\n\n    addRegexToken('y', matchUnsigned);\n    addRegexToken('yy', matchUnsigned);\n    addRegexToken('yyy', matchUnsigned);\n    addRegexToken('yyyy', matchUnsigned);\n    addRegexToken('yo', matchEraYearOrdinal);\n\n    addParseToken(['y', 'yy', 'yyy', 'yyyy'], YEAR);\n    addParseToken(['yo'], function (input, array, config, token) {\n        var match;\n        if (config._locale._eraYearOrdinalRegex) {\n            match = input.match(config._locale._eraYearOrdinalRegex);\n        }\n\n        if (config._locale.eraYearOrdinalParse) {\n            array[YEAR] = config._locale.eraYearOrdinalParse(input, match);\n        } else {\n            array[YEAR] = parseInt(input, 10);\n        }\n    });\n\n    function localeEras(m, format) {\n        var i,\n            l,\n            date,\n            eras = this._eras || getLocale('en')._eras;\n        for (i = 0, l = eras.length; i < l; ++i) {\n            switch (typeof eras[i].since) {\n                case 'string':\n                    // truncate time\n                    date = hooks(eras[i].since).startOf('day');\n                    eras[i].since = date.valueOf();\n                    break;\n            }\n\n            switch (typeof eras[i].until) {\n                case 'undefined':\n                    eras[i].until = +Infinity;\n                    break;\n                case 'string':\n                    // truncate time\n                    date = hooks(eras[i].until).startOf('day').valueOf();\n                    eras[i].until = date.valueOf();\n                    break;\n            }\n        }\n        return eras;\n    }\n\n    function localeErasParse(eraName, format, strict) {\n        var i,\n            l,\n            eras = this.eras(),\n            name,\n            abbr,\n            narrow;\n        eraName = eraName.toUpperCase();\n\n        for (i = 0, l = eras.length; i < l; ++i) {\n            name = eras[i].name.toUpperCase();\n            abbr = eras[i].abbr.toUpperCase();\n            narrow = eras[i].narrow.toUpperCase();\n\n            if (strict) {\n                switch (format) {\n                    case 'N':\n                    case 'NN':\n                    case 'NNN':\n                        if (abbr === eraName) {\n                            return eras[i];\n                        }\n                        break;\n\n                    case 'NNNN':\n                        if (name === eraName) {\n                            return eras[i];\n                        }\n                        break;\n\n                    case 'NNNNN':\n                        if (narrow === eraName) {\n                            return eras[i];\n                        }\n                        break;\n                }\n            } else if ([name, abbr, narrow].indexOf(eraName) >= 0) {\n                return eras[i];\n            }\n        }\n    }\n\n    function localeErasConvertYear(era, year) {\n        var dir = era.since <= era.until ? +1 : -1;\n        if (year === undefined) {\n            return hooks(era.since).year();\n        } else {\n            return hooks(era.since).year() + (year - era.offset) * dir;\n        }\n    }\n\n    function getEraName() {\n        var i,\n            l,\n            val,\n            eras = this.localeData().eras();\n        for (i = 0, l = eras.length; i < l; ++i) {\n            // truncate time\n            val = this.clone().startOf('day').valueOf();\n\n            if (eras[i].since <= val && val <= eras[i].until) {\n                return eras[i].name;\n            }\n            if (eras[i].until <= val && val <= eras[i].since) {\n                return eras[i].name;\n            }\n        }\n\n        return '';\n    }\n\n    function getEraNarrow() {\n        var i,\n            l,\n            val,\n            eras = this.localeData().eras();\n        for (i = 0, l = eras.length; i < l; ++i) {\n            // truncate time\n            val = this.clone().startOf('day').valueOf();\n\n            if (eras[i].since <= val && val <= eras[i].until) {\n                return eras[i].narrow;\n            }\n            if (eras[i].until <= val && val <= eras[i].since) {\n                return eras[i].narrow;\n            }\n        }\n\n        return '';\n    }\n\n    function getEraAbbr() {\n        var i,\n            l,\n            val,\n            eras = this.localeData().eras();\n        for (i = 0, l = eras.length; i < l; ++i) {\n            // truncate time\n            val = this.clone().startOf('day').valueOf();\n\n            if (eras[i].since <= val && val <= eras[i].until) {\n                return eras[i].abbr;\n            }\n            if (eras[i].until <= val && val <= eras[i].since) {\n                return eras[i].abbr;\n            }\n        }\n\n        return '';\n    }\n\n    function getEraYear() {\n        var i,\n            l,\n            dir,\n            val,\n            eras = this.localeData().eras();\n        for (i = 0, l = eras.length; i < l; ++i) {\n            dir = eras[i].since <= eras[i].until ? +1 : -1;\n\n            // truncate time\n            val = this.clone().startOf('day').valueOf();\n\n            if (\n                (eras[i].since <= val && val <= eras[i].until) ||\n                (eras[i].until <= val && val <= eras[i].since)\n            ) {\n                return (\n                    (this.year() - hooks(eras[i].since).year()) * dir +\n                    eras[i].offset\n                );\n            }\n        }\n\n        return this.year();\n    }\n\n    function erasNameRegex(isStrict) {\n        if (!hasOwnProp(this, '_erasNameRegex')) {\n            computeErasParse.call(this);\n        }\n        return isStrict ? this._erasNameRegex : this._erasRegex;\n    }\n\n    function erasAbbrRegex(isStrict) {\n        if (!hasOwnProp(this, '_erasAbbrRegex')) {\n            computeErasParse.call(this);\n        }\n        return isStrict ? this._erasAbbrRegex : this._erasRegex;\n    }\n\n    function erasNarrowRegex(isStrict) {\n        if (!hasOwnProp(this, '_erasNarrowRegex')) {\n            computeErasParse.call(this);\n        }\n        return isStrict ? this._erasNarrowRegex : this._erasRegex;\n    }\n\n    function matchEraAbbr(isStrict, locale) {\n        return locale.erasAbbrRegex(isStrict);\n    }\n\n    function matchEraName(isStrict, locale) {\n        return locale.erasNameRegex(isStrict);\n    }\n\n    function matchEraNarrow(isStrict, locale) {\n        return locale.erasNarrowRegex(isStrict);\n    }\n\n    function matchEraYearOrdinal(isStrict, locale) {\n        return locale._eraYearOrdinalRegex || matchUnsigned;\n    }\n\n    function computeErasParse() {\n        var abbrPieces = [],\n            namePieces = [],\n            narrowPieces = [],\n            mixedPieces = [],\n            i,\n            l,\n            eras = this.eras();\n\n        for (i = 0, l = eras.length; i < l; ++i) {\n            namePieces.push(regexEscape(eras[i].name));\n            abbrPieces.push(regexEscape(eras[i].abbr));\n            narrowPieces.push(regexEscape(eras[i].narrow));\n\n            mixedPieces.push(regexEscape(eras[i].name));\n            mixedPieces.push(regexEscape(eras[i].abbr));\n            mixedPieces.push(regexEscape(eras[i].narrow));\n        }\n\n        this._erasRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');\n        this._erasNameRegex = new RegExp('^(' + namePieces.join('|') + ')', 'i');\n        this._erasAbbrRegex = new RegExp('^(' + abbrPieces.join('|') + ')', 'i');\n        this._erasNarrowRegex = new RegExp(\n            '^(' + narrowPieces.join('|') + ')',\n            'i'\n        );\n    }\n\n    // FORMATTING\n\n    addFormatToken(0, ['gg', 2], 0, function () {\n        return this.weekYear() % 100;\n    });\n\n    addFormatToken(0, ['GG', 2], 0, function () {\n        return this.isoWeekYear() % 100;\n    });\n\n    function addWeekYearFormatToken(token, getter) {\n        addFormatToken(0, [token, token.length], 0, getter);\n    }\n\n    addWeekYearFormatToken('gggg', 'weekYear');\n    addWeekYearFormatToken('ggggg', 'weekYear');\n    addWeekYearFormatToken('GGGG', 'isoWeekYear');\n    addWeekYearFormatToken('GGGGG', 'isoWeekYear');\n\n    // ALIASES\n\n    addUnitAlias('weekYear', 'gg');\n    addUnitAlias('isoWeekYear', 'GG');\n\n    // PRIORITY\n\n    addUnitPriority('weekYear', 1);\n    addUnitPriority('isoWeekYear', 1);\n\n    // PARSING\n\n    addRegexToken('G', matchSigned);\n    addRegexToken('g', matchSigned);\n    addRegexToken('GG', match1to2, match2);\n    addRegexToken('gg', match1to2, match2);\n    addRegexToken('GGGG', match1to4, match4);\n    addRegexToken('gggg', match1to4, match4);\n    addRegexToken('GGGGG', match1to6, match6);\n    addRegexToken('ggggg', match1to6, match6);\n\n    addWeekParseToken(\n        ['gggg', 'ggggg', 'GGGG', 'GGGGG'],\n        function (input, week, config, token) {\n            week[token.substr(0, 2)] = toInt(input);\n        }\n    );\n\n    addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {\n        week[token] = hooks.parseTwoDigitYear(input);\n    });\n\n    // MOMENTS\n\n    function getSetWeekYear(input) {\n        return getSetWeekYearHelper.call(\n            this,\n            input,\n            this.week(),\n            this.weekday(),\n            this.localeData()._week.dow,\n            this.localeData()._week.doy\n        );\n    }\n\n    function getSetISOWeekYear(input) {\n        return getSetWeekYearHelper.call(\n            this,\n            input,\n            this.isoWeek(),\n            this.isoWeekday(),\n            1,\n            4\n        );\n    }\n\n    function getISOWeeksInYear() {\n        return weeksInYear(this.year(), 1, 4);\n    }\n\n    function getISOWeeksInISOWeekYear() {\n        return weeksInYear(this.isoWeekYear(), 1, 4);\n    }\n\n    function getWeeksInYear() {\n        var weekInfo = this.localeData()._week;\n        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);\n    }\n\n    function getWeeksInWeekYear() {\n        var weekInfo = this.localeData()._week;\n        return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);\n    }\n\n    function getSetWeekYearHelper(input, week, weekday, dow, doy) {\n        var weeksTarget;\n        if (input == null) {\n            return weekOfYear(this, dow, doy).year;\n        } else {\n            weeksTarget = weeksInYear(input, dow, doy);\n            if (week > weeksTarget) {\n                week = weeksTarget;\n            }\n            return setWeekAll.call(this, input, week, weekday, dow, doy);\n        }\n    }\n\n    function setWeekAll(weekYear, week, weekday, dow, doy) {\n        var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),\n            date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);\n\n        this.year(date.getUTCFullYear());\n        this.month(date.getUTCMonth());\n        this.date(date.getUTCDate());\n        return this;\n    }\n\n    // FORMATTING\n\n    addFormatToken('Q', 0, 'Qo', 'quarter');\n\n    // ALIASES\n\n    addUnitAlias('quarter', 'Q');\n\n    // PRIORITY\n\n    addUnitPriority('quarter', 7);\n\n    // PARSING\n\n    addRegexToken('Q', match1);\n    addParseToken('Q', function (input, array) {\n        array[MONTH] = (toInt(input) - 1) * 3;\n    });\n\n    // MOMENTS\n\n    function getSetQuarter(input) {\n        return input == null\n            ? Math.ceil((this.month() + 1) / 3)\n            : this.month((input - 1) * 3 + (this.month() % 3));\n    }\n\n    // FORMATTING\n\n    addFormatToken('D', ['DD', 2], 'Do', 'date');\n\n    // ALIASES\n\n    addUnitAlias('date', 'D');\n\n    // PRIORITY\n    addUnitPriority('date', 9);\n\n    // PARSING\n\n    addRegexToken('D', match1to2);\n    addRegexToken('DD', match1to2, match2);\n    addRegexToken('Do', function (isStrict, locale) {\n        // TODO: Remove \"ordinalParse\" fallback in next major release.\n        return isStrict\n            ? locale._dayOfMonthOrdinalParse || locale._ordinalParse\n            : locale._dayOfMonthOrdinalParseLenient;\n    });\n\n    addParseToken(['D', 'DD'], DATE);\n    addParseToken('Do', function (input, array) {\n        array[DATE] = toInt(input.match(match1to2)[0]);\n    });\n\n    // MOMENTS\n\n    var getSetDayOfMonth = makeGetSet('Date', true);\n\n    // FORMATTING\n\n    addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');\n\n    // ALIASES\n\n    addUnitAlias('dayOfYear', 'DDD');\n\n    // PRIORITY\n    addUnitPriority('dayOfYear', 4);\n\n    // PARSING\n\n    addRegexToken('DDD', match1to3);\n    addRegexToken('DDDD', match3);\n    addParseToken(['DDD', 'DDDD'], function (input, array, config) {\n        config._dayOfYear = toInt(input);\n    });\n\n    // HELPERS\n\n    // MOMENTS\n\n    function getSetDayOfYear(input) {\n        var dayOfYear =\n            Math.round(\n                (this.clone().startOf('day') - this.clone().startOf('year')) / 864e5\n            ) + 1;\n        return input == null ? dayOfYear : this.add(input - dayOfYear, 'd');\n    }\n\n    // FORMATTING\n\n    addFormatToken('m', ['mm', 2], 0, 'minute');\n\n    // ALIASES\n\n    addUnitAlias('minute', 'm');\n\n    // PRIORITY\n\n    addUnitPriority('minute', 14);\n\n    // PARSING\n\n    addRegexToken('m', match1to2);\n    addRegexToken('mm', match1to2, match2);\n    addParseToken(['m', 'mm'], MINUTE);\n\n    // MOMENTS\n\n    var getSetMinute = makeGetSet('Minutes', false);\n\n    // FORMATTING\n\n    addFormatToken('s', ['ss', 2], 0, 'second');\n\n    // ALIASES\n\n    addUnitAlias('second', 's');\n\n    // PRIORITY\n\n    addUnitPriority('second', 15);\n\n    // PARSING\n\n    addRegexToken('s', match1to2);\n    addRegexToken('ss', match1to2, match2);\n    addParseToken(['s', 'ss'], SECOND);\n\n    // MOMENTS\n\n    var getSetSecond = makeGetSet('Seconds', false);\n\n    // FORMATTING\n\n    addFormatToken('S', 0, 0, function () {\n        return ~~(this.millisecond() / 100);\n    });\n\n    addFormatToken(0, ['SS', 2], 0, function () {\n        return ~~(this.millisecond() / 10);\n    });\n\n    addFormatToken(0, ['SSS', 3], 0, 'millisecond');\n    addFormatToken(0, ['SSSS', 4], 0, function () {\n        return this.millisecond() * 10;\n    });\n    addFormatToken(0, ['SSSSS', 5], 0, function () {\n        return this.millisecond() * 100;\n    });\n    addFormatToken(0, ['SSSSSS', 6], 0, function () {\n        return this.millisecond() * 1000;\n    });\n    addFormatToken(0, ['SSSSSSS', 7], 0, function () {\n        return this.millisecond() * 10000;\n    });\n    addFormatToken(0, ['SSSSSSSS', 8], 0, function () {\n        return this.millisecond() * 100000;\n    });\n    addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {\n        return this.millisecond() * 1000000;\n    });\n\n    // ALIASES\n\n    addUnitAlias('millisecond', 'ms');\n\n    // PRIORITY\n\n    addUnitPriority('millisecond', 16);\n\n    // PARSING\n\n    addRegexToken('S', match1to3, match1);\n    addRegexToken('SS', match1to3, match2);\n    addRegexToken('SSS', match1to3, match3);\n\n    var token, getSetMillisecond;\n    for (token = 'SSSS'; token.length <= 9; token += 'S') {\n        addRegexToken(token, matchUnsigned);\n    }\n\n    function parseMs(input, array) {\n        array[MILLISECOND] = toInt(('0.' + input) * 1000);\n    }\n\n    for (token = 'S'; token.length <= 9; token += 'S') {\n        addParseToken(token, parseMs);\n    }\n\n    getSetMillisecond = makeGetSet('Milliseconds', false);\n\n    // FORMATTING\n\n    addFormatToken('z', 0, 0, 'zoneAbbr');\n    addFormatToken('zz', 0, 0, 'zoneName');\n\n    // MOMENTS\n\n    function getZoneAbbr() {\n        return this._isUTC ? 'UTC' : '';\n    }\n\n    function getZoneName() {\n        return this._isUTC ? 'Coordinated Universal Time' : '';\n    }\n\n    var proto = Moment.prototype;\n\n    proto.add = add;\n    proto.calendar = calendar$1;\n    proto.clone = clone;\n    proto.diff = diff;\n    proto.endOf = endOf;\n    proto.format = format;\n    proto.from = from;\n    proto.fromNow = fromNow;\n    proto.to = to;\n    proto.toNow = toNow;\n    proto.get = stringGet;\n    proto.invalidAt = invalidAt;\n    proto.isAfter = isAfter;\n    proto.isBefore = isBefore;\n    proto.isBetween = isBetween;\n    proto.isSame = isSame;\n    proto.isSameOrAfter = isSameOrAfter;\n    proto.isSameOrBefore = isSameOrBefore;\n    proto.isValid = isValid$2;\n    proto.lang = lang;\n    proto.locale = locale;\n    proto.localeData = localeData;\n    proto.max = prototypeMax;\n    proto.min = prototypeMin;\n    proto.parsingFlags = parsingFlags;\n    proto.set = stringSet;\n    proto.startOf = startOf;\n    proto.subtract = subtract;\n    proto.toArray = toArray;\n    proto.toObject = toObject;\n    proto.toDate = toDate;\n    proto.toISOString = toISOString;\n    proto.inspect = inspect;\n    if (typeof Symbol !== 'undefined' && Symbol.for != null) {\n        proto[Symbol.for('nodejs.util.inspect.custom')] = function () {\n            return 'Moment<' + this.format() + '>';\n        };\n    }\n    proto.toJSON = toJSON;\n    proto.toString = toString;\n    proto.unix = unix;\n    proto.valueOf = valueOf;\n    proto.creationData = creationData;\n    proto.eraName = getEraName;\n    proto.eraNarrow = getEraNarrow;\n    proto.eraAbbr = getEraAbbr;\n    proto.eraYear = getEraYear;\n    proto.year = getSetYear;\n    proto.isLeapYear = getIsLeapYear;\n    proto.weekYear = getSetWeekYear;\n    proto.isoWeekYear = getSetISOWeekYear;\n    proto.quarter = proto.quarters = getSetQuarter;\n    proto.month = getSetMonth;\n    proto.daysInMonth = getDaysInMonth;\n    proto.week = proto.weeks = getSetWeek;\n    proto.isoWeek = proto.isoWeeks = getSetISOWeek;\n    proto.weeksInYear = getWeeksInYear;\n    proto.weeksInWeekYear = getWeeksInWeekYear;\n    proto.isoWeeksInYear = getISOWeeksInYear;\n    proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;\n    proto.date = getSetDayOfMonth;\n    proto.day = proto.days = getSetDayOfWeek;\n    proto.weekday = getSetLocaleDayOfWeek;\n    proto.isoWeekday = getSetISODayOfWeek;\n    proto.dayOfYear = getSetDayOfYear;\n    proto.hour = proto.hours = getSetHour;\n    proto.minute = proto.minutes = getSetMinute;\n    proto.second = proto.seconds = getSetSecond;\n    proto.millisecond = proto.milliseconds = getSetMillisecond;\n    proto.utcOffset = getSetOffset;\n    proto.utc = setOffsetToUTC;\n    proto.local = setOffsetToLocal;\n    proto.parseZone = setOffsetToParsedOffset;\n    proto.hasAlignedHourOffset = hasAlignedHourOffset;\n    proto.isDST = isDaylightSavingTime;\n    proto.isLocal = isLocal;\n    proto.isUtcOffset = isUtcOffset;\n    proto.isUtc = isUtc;\n    proto.isUTC = isUtc;\n    proto.zoneAbbr = getZoneAbbr;\n    proto.zoneName = getZoneName;\n    proto.dates = deprecate(\n        'dates accessor is deprecated. Use date instead.',\n        getSetDayOfMonth\n    );\n    proto.months = deprecate(\n        'months accessor is deprecated. Use month instead',\n        getSetMonth\n    );\n    proto.years = deprecate(\n        'years accessor is deprecated. Use year instead',\n        getSetYear\n    );\n    proto.zone = deprecate(\n        'moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/',\n        getSetZone\n    );\n    proto.isDSTShifted = deprecate(\n        'isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information',\n        isDaylightSavingTimeShifted\n    );\n\n    function createUnix(input) {\n        return createLocal(input * 1000);\n    }\n\n    function createInZone() {\n        return createLocal.apply(null, arguments).parseZone();\n    }\n\n    function preParsePostFormat(string) {\n        return string;\n    }\n\n    var proto$1 = Locale.prototype;\n\n    proto$1.calendar = calendar;\n    proto$1.longDateFormat = longDateFormat;\n    proto$1.invalidDate = invalidDate;\n    proto$1.ordinal = ordinal;\n    proto$1.preparse = preParsePostFormat;\n    proto$1.postformat = preParsePostFormat;\n    proto$1.relativeTime = relativeTime;\n    proto$1.pastFuture = pastFuture;\n    proto$1.set = set;\n    proto$1.eras = localeEras;\n    proto$1.erasParse = localeErasParse;\n    proto$1.erasConvertYear = localeErasConvertYear;\n    proto$1.erasAbbrRegex = erasAbbrRegex;\n    proto$1.erasNameRegex = erasNameRegex;\n    proto$1.erasNarrowRegex = erasNarrowRegex;\n\n    proto$1.months = localeMonths;\n    proto$1.monthsShort = localeMonthsShort;\n    proto$1.monthsParse = localeMonthsParse;\n    proto$1.monthsRegex = monthsRegex;\n    proto$1.monthsShortRegex = monthsShortRegex;\n    proto$1.week = localeWeek;\n    proto$1.firstDayOfYear = localeFirstDayOfYear;\n    proto$1.firstDayOfWeek = localeFirstDayOfWeek;\n\n    proto$1.weekdays = localeWeekdays;\n    proto$1.weekdaysMin = localeWeekdaysMin;\n    proto$1.weekdaysShort = localeWeekdaysShort;\n    proto$1.weekdaysParse = localeWeekdaysParse;\n\n    proto$1.weekdaysRegex = weekdaysRegex;\n    proto$1.weekdaysShortRegex = weekdaysShortRegex;\n    proto$1.weekdaysMinRegex = weekdaysMinRegex;\n\n    proto$1.isPM = localeIsPM;\n    proto$1.meridiem = localeMeridiem;\n\n    function get$1(format, index, field, setter) {\n        var locale = getLocale(),\n            utc = createUTC().set(setter, index);\n        return locale[field](utc, format);\n    }\n\n    function listMonthsImpl(format, index, field) {\n        if (isNumber(format)) {\n            index = format;\n            format = undefined;\n        }\n\n        format = format || '';\n\n        if (index != null) {\n            return get$1(format, index, field, 'month');\n        }\n\n        var i,\n            out = [];\n        for (i = 0; i < 12; i++) {\n            out[i] = get$1(format, i, field, 'month');\n        }\n        return out;\n    }\n\n    // ()\n    // (5)\n    // (fmt, 5)\n    // (fmt)\n    // (true)\n    // (true, 5)\n    // (true, fmt, 5)\n    // (true, fmt)\n    function listWeekdaysImpl(localeSorted, format, index, field) {\n        if (typeof localeSorted === 'boolean') {\n            if (isNumber(format)) {\n                index = format;\n                format = undefined;\n            }\n\n            format = format || '';\n        } else {\n            format = localeSorted;\n            index = format;\n            localeSorted = false;\n\n            if (isNumber(format)) {\n                index = format;\n                format = undefined;\n            }\n\n            format = format || '';\n        }\n\n        var locale = getLocale(),\n            shift = localeSorted ? locale._week.dow : 0,\n            i,\n            out = [];\n\n        if (index != null) {\n            return get$1(format, (index + shift) % 7, field, 'day');\n        }\n\n        for (i = 0; i < 7; i++) {\n            out[i] = get$1(format, (i + shift) % 7, field, 'day');\n        }\n        return out;\n    }\n\n    function listMonths(format, index) {\n        return listMonthsImpl(format, index, 'months');\n    }\n\n    function listMonthsShort(format, index) {\n        return listMonthsImpl(format, index, 'monthsShort');\n    }\n\n    function listWeekdays(localeSorted, format, index) {\n        return listWeekdaysImpl(localeSorted, format, index, 'weekdays');\n    }\n\n    function listWeekdaysShort(localeSorted, format, index) {\n        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');\n    }\n\n    function listWeekdaysMin(localeSorted, format, index) {\n        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');\n    }\n\n    getSetGlobalLocale('en', {\n        eras: [\n            {\n                since: '0001-01-01',\n                until: +Infinity,\n                offset: 1,\n                name: 'Anno Domini',\n                narrow: 'AD',\n                abbr: 'AD',\n            },\n            {\n                since: '0000-12-31',\n                until: -Infinity,\n                offset: 1,\n                name: 'Before Christ',\n                narrow: 'BC',\n                abbr: 'BC',\n            },\n        ],\n        dayOfMonthOrdinalParse: /\\d{1,2}(th|st|nd|rd)/,\n        ordinal: function (number) {\n            var b = number % 10,\n                output =\n                    toInt((number % 100) / 10) === 1\n                        ? 'th'\n                        : b === 1\n                        ? 'st'\n                        : b === 2\n                        ? 'nd'\n                        : b === 3\n                        ? 'rd'\n                        : 'th';\n            return number + output;\n        },\n    });\n\n    // Side effect imports\n\n    hooks.lang = deprecate(\n        'moment.lang is deprecated. Use moment.locale instead.',\n        getSetGlobalLocale\n    );\n    hooks.langData = deprecate(\n        'moment.langData is deprecated. Use moment.localeData instead.',\n        getLocale\n    );\n\n    var mathAbs = Math.abs;\n\n    function abs() {\n        var data = this._data;\n\n        this._milliseconds = mathAbs(this._milliseconds);\n        this._days = mathAbs(this._days);\n        this._months = mathAbs(this._months);\n\n        data.milliseconds = mathAbs(data.milliseconds);\n        data.seconds = mathAbs(data.seconds);\n        data.minutes = mathAbs(data.minutes);\n        data.hours = mathAbs(data.hours);\n        data.months = mathAbs(data.months);\n        data.years = mathAbs(data.years);\n\n        return this;\n    }\n\n    function addSubtract$1(duration, input, value, direction) {\n        var other = createDuration(input, value);\n\n        duration._milliseconds += direction * other._milliseconds;\n        duration._days += direction * other._days;\n        duration._months += direction * other._months;\n\n        return duration._bubble();\n    }\n\n    // supports only 2.0-style add(1, 's') or add(duration)\n    function add$1(input, value) {\n        return addSubtract$1(this, input, value, 1);\n    }\n\n    // supports only 2.0-style subtract(1, 's') or subtract(duration)\n    function subtract$1(input, value) {\n        return addSubtract$1(this, input, value, -1);\n    }\n\n    function absCeil(number) {\n        if (number < 0) {\n            return Math.floor(number);\n        } else {\n            return Math.ceil(number);\n        }\n    }\n\n    function bubble() {\n        var milliseconds = this._milliseconds,\n            days = this._days,\n            months = this._months,\n            data = this._data,\n            seconds,\n            minutes,\n            hours,\n            years,\n            monthsFromDays;\n\n        // if we have a mix of positive and negative values, bubble down first\n        // check: https://github.com/moment/moment/issues/2166\n        if (\n            !(\n                (milliseconds >= 0 && days >= 0 && months >= 0) ||\n                (milliseconds <= 0 && days <= 0 && months <= 0)\n            )\n        ) {\n            milliseconds += absCeil(monthsToDays(months) + days) * 864e5;\n            days = 0;\n            months = 0;\n        }\n\n        // The following code bubbles up values, see the tests for\n        // examples of what that means.\n        data.milliseconds = milliseconds % 1000;\n\n        seconds = absFloor(milliseconds / 1000);\n        data.seconds = seconds % 60;\n\n        minutes = absFloor(seconds / 60);\n        data.minutes = minutes % 60;\n\n        hours = absFloor(minutes / 60);\n        data.hours = hours % 24;\n\n        days += absFloor(hours / 24);\n\n        // convert days to months\n        monthsFromDays = absFloor(daysToMonths(days));\n        months += monthsFromDays;\n        days -= absCeil(monthsToDays(monthsFromDays));\n\n        // 12 months -> 1 year\n        years = absFloor(months / 12);\n        months %= 12;\n\n        data.days = days;\n        data.months = months;\n        data.years = years;\n\n        return this;\n    }\n\n    function daysToMonths(days) {\n        // 400 years have 146097 days (taking into account leap year rules)\n        // 400 years have 12 months === 4800\n        return (days * 4800) / 146097;\n    }\n\n    function monthsToDays(months) {\n        // the reverse of daysToMonths\n        return (months * 146097) / 4800;\n    }\n\n    function as(units) {\n        if (!this.isValid()) {\n            return NaN;\n        }\n        var days,\n            months,\n            milliseconds = this._milliseconds;\n\n        units = normalizeUnits(units);\n\n        if (units === 'month' || units === 'quarter' || units === 'year') {\n            days = this._days + milliseconds / 864e5;\n            months = this._months + daysToMonths(days);\n            switch (units) {\n                case 'month':\n                    return months;\n                case 'quarter':\n                    return months / 3;\n                case 'year':\n                    return months / 12;\n            }\n        } else {\n            // handle milliseconds separately because of floating point math errors (issue #1867)\n            days = this._days + Math.round(monthsToDays(this._months));\n            switch (units) {\n                case 'week':\n                    return days / 7 + milliseconds / 6048e5;\n                case 'day':\n                    return days + milliseconds / 864e5;\n                case 'hour':\n                    return days * 24 + milliseconds / 36e5;\n                case 'minute':\n                    return days * 1440 + milliseconds / 6e4;\n                case 'second':\n                    return days * 86400 + milliseconds / 1000;\n                // Math.floor prevents floating point math errors here\n                case 'millisecond':\n                    return Math.floor(days * 864e5) + milliseconds;\n                default:\n                    throw new Error('Unknown unit ' + units);\n            }\n        }\n    }\n\n    // TODO: Use this.as('ms')?\n    function valueOf$1() {\n        if (!this.isValid()) {\n            return NaN;\n        }\n        return (\n            this._milliseconds +\n            this._days * 864e5 +\n            (this._months % 12) * 2592e6 +\n            toInt(this._months / 12) * 31536e6\n        );\n    }\n\n    function makeAs(alias) {\n        return function () {\n            return this.as(alias);\n        };\n    }\n\n    var asMilliseconds = makeAs('ms'),\n        asSeconds = makeAs('s'),\n        asMinutes = makeAs('m'),\n        asHours = makeAs('h'),\n        asDays = makeAs('d'),\n        asWeeks = makeAs('w'),\n        asMonths = makeAs('M'),\n        asQuarters = makeAs('Q'),\n        asYears = makeAs('y');\n\n    function clone$1() {\n        return createDuration(this);\n    }\n\n    function get$2(units) {\n        units = normalizeUnits(units);\n        return this.isValid() ? this[units + 's']() : NaN;\n    }\n\n    function makeGetter(name) {\n        return function () {\n            return this.isValid() ? this._data[name] : NaN;\n        };\n    }\n\n    var milliseconds = makeGetter('milliseconds'),\n        seconds = makeGetter('seconds'),\n        minutes = makeGetter('minutes'),\n        hours = makeGetter('hours'),\n        days = makeGetter('days'),\n        months = makeGetter('months'),\n        years = makeGetter('years');\n\n    function weeks() {\n        return absFloor(this.days() / 7);\n    }\n\n    var round = Math.round,\n        thresholds = {\n            ss: 44, // a few seconds to seconds\n            s: 45, // seconds to minute\n            m: 45, // minutes to hour\n            h: 22, // hours to day\n            d: 26, // days to month/week\n            w: null, // weeks to month\n            M: 11, // months to year\n        };\n\n    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize\n    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {\n        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);\n    }\n\n    function relativeTime$1(posNegDuration, withoutSuffix, thresholds, locale) {\n        var duration = createDuration(posNegDuration).abs(),\n            seconds = round(duration.as('s')),\n            minutes = round(duration.as('m')),\n            hours = round(duration.as('h')),\n            days = round(duration.as('d')),\n            months = round(duration.as('M')),\n            weeks = round(duration.as('w')),\n            years = round(duration.as('y')),\n            a =\n                (seconds <= thresholds.ss && ['s', seconds]) ||\n                (seconds < thresholds.s && ['ss', seconds]) ||\n                (minutes <= 1 && ['m']) ||\n                (minutes < thresholds.m && ['mm', minutes]) ||\n                (hours <= 1 && ['h']) ||\n                (hours < thresholds.h && ['hh', hours]) ||\n                (days <= 1 && ['d']) ||\n                (days < thresholds.d && ['dd', days]);\n\n        if (thresholds.w != null) {\n            a =\n                a ||\n                (weeks <= 1 && ['w']) ||\n                (weeks < thresholds.w && ['ww', weeks]);\n        }\n        a = a ||\n            (months <= 1 && ['M']) ||\n            (months < thresholds.M && ['MM', months]) ||\n            (years <= 1 && ['y']) || ['yy', years];\n\n        a[2] = withoutSuffix;\n        a[3] = +posNegDuration > 0;\n        a[4] = locale;\n        return substituteTimeAgo.apply(null, a);\n    }\n\n    // This function allows you to set the rounding function for relative time strings\n    function getSetRelativeTimeRounding(roundingFunction) {\n        if (roundingFunction === undefined) {\n            return round;\n        }\n        if (typeof roundingFunction === 'function') {\n            round = roundingFunction;\n            return true;\n        }\n        return false;\n    }\n\n    // This function allows you to set a threshold for relative time strings\n    function getSetRelativeTimeThreshold(threshold, limit) {\n        if (thresholds[threshold] === undefined) {\n            return false;\n        }\n        if (limit === undefined) {\n            return thresholds[threshold];\n        }\n        thresholds[threshold] = limit;\n        if (threshold === 's') {\n            thresholds.ss = limit - 1;\n        }\n        return true;\n    }\n\n    function humanize(argWithSuffix, argThresholds) {\n        if (!this.isValid()) {\n            return this.localeData().invalidDate();\n        }\n\n        var withSuffix = false,\n            th = thresholds,\n            locale,\n            output;\n\n        if (typeof argWithSuffix === 'object') {\n            argThresholds = argWithSuffix;\n            argWithSuffix = false;\n        }\n        if (typeof argWithSuffix === 'boolean') {\n            withSuffix = argWithSuffix;\n        }\n        if (typeof argThresholds === 'object') {\n            th = Object.assign({}, thresholds, argThresholds);\n            if (argThresholds.s != null && argThresholds.ss == null) {\n                th.ss = argThresholds.s - 1;\n            }\n        }\n\n        locale = this.localeData();\n        output = relativeTime$1(this, !withSuffix, th, locale);\n\n        if (withSuffix) {\n            output = locale.pastFuture(+this, output);\n        }\n\n        return locale.postformat(output);\n    }\n\n    var abs$1 = Math.abs;\n\n    function sign(x) {\n        return (x > 0) - (x < 0) || +x;\n    }\n\n    function toISOString$1() {\n        // for ISO strings we do not use the normal bubbling rules:\n        //  * milliseconds bubble up until they become hours\n        //  * days do not bubble at all\n        //  * months bubble up until they become years\n        // This is because there is no context-free conversion between hours and days\n        // (think of clock changes)\n        // and also not between days and months (28-31 days per month)\n        if (!this.isValid()) {\n            return this.localeData().invalidDate();\n        }\n\n        var seconds = abs$1(this._milliseconds) / 1000,\n            days = abs$1(this._days),\n            months = abs$1(this._months),\n            minutes,\n            hours,\n            years,\n            s,\n            total = this.asSeconds(),\n            totalSign,\n            ymSign,\n            daysSign,\n            hmsSign;\n\n        if (!total) {\n            // this is the same as C#'s (Noda) and python (isodate)...\n            // but not other JS (goog.date)\n            return 'P0D';\n        }\n\n        // 3600 seconds -> 60 minutes -> 1 hour\n        minutes = absFloor(seconds / 60);\n        hours = absFloor(minutes / 60);\n        seconds %= 60;\n        minutes %= 60;\n\n        // 12 months -> 1 year\n        years = absFloor(months / 12);\n        months %= 12;\n\n        // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js\n        s = seconds ? seconds.toFixed(3).replace(/\\.?0+$/, '') : '';\n\n        totalSign = total < 0 ? '-' : '';\n        ymSign = sign(this._months) !== sign(total) ? '-' : '';\n        daysSign = sign(this._days) !== sign(total) ? '-' : '';\n        hmsSign = sign(this._milliseconds) !== sign(total) ? '-' : '';\n\n        return (\n            totalSign +\n            'P' +\n            (years ? ymSign + years + 'Y' : '') +\n            (months ? ymSign + months + 'M' : '') +\n            (days ? daysSign + days + 'D' : '') +\n            (hours || minutes || seconds ? 'T' : '') +\n            (hours ? hmsSign + hours + 'H' : '') +\n            (minutes ? hmsSign + minutes + 'M' : '') +\n            (seconds ? hmsSign + s + 'S' : '')\n        );\n    }\n\n    var proto$2 = Duration.prototype;\n\n    proto$2.isValid = isValid$1;\n    proto$2.abs = abs;\n    proto$2.add = add$1;\n    proto$2.subtract = subtract$1;\n    proto$2.as = as;\n    proto$2.asMilliseconds = asMilliseconds;\n    proto$2.asSeconds = asSeconds;\n    proto$2.asMinutes = asMinutes;\n    proto$2.asHours = asHours;\n    proto$2.asDays = asDays;\n    proto$2.asWeeks = asWeeks;\n    proto$2.asMonths = asMonths;\n    proto$2.asQuarters = asQuarters;\n    proto$2.asYears = asYears;\n    proto$2.valueOf = valueOf$1;\n    proto$2._bubble = bubble;\n    proto$2.clone = clone$1;\n    proto$2.get = get$2;\n    proto$2.milliseconds = milliseconds;\n    proto$2.seconds = seconds;\n    proto$2.minutes = minutes;\n    proto$2.hours = hours;\n    proto$2.days = days;\n    proto$2.weeks = weeks;\n    proto$2.months = months;\n    proto$2.years = years;\n    proto$2.humanize = humanize;\n    proto$2.toISOString = toISOString$1;\n    proto$2.toString = toISOString$1;\n    proto$2.toJSON = toISOString$1;\n    proto$2.locale = locale;\n    proto$2.localeData = localeData;\n\n    proto$2.toIsoString = deprecate(\n        'toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)',\n        toISOString$1\n    );\n    proto$2.lang = lang;\n\n    // FORMATTING\n\n    addFormatToken('X', 0, 0, 'unix');\n    addFormatToken('x', 0, 0, 'valueOf');\n\n    // PARSING\n\n    addRegexToken('x', matchSigned);\n    addRegexToken('X', matchTimestamp);\n    addParseToken('X', function (input, array, config) {\n        config._d = new Date(parseFloat(input) * 1000);\n    });\n    addParseToken('x', function (input, array, config) {\n        config._d = new Date(toInt(input));\n    });\n\n    //! moment.js\n\n    hooks.version = '2.29.4';\n\n    setHookCallback(createLocal);\n\n    hooks.fn = proto;\n    hooks.min = min;\n    hooks.max = max;\n    hooks.now = now;\n    hooks.utc = createUTC;\n    hooks.unix = createUnix;\n    hooks.months = listMonths;\n    hooks.isDate = isDate;\n    hooks.locale = getSetGlobalLocale;\n    hooks.invalid = createInvalid;\n    hooks.duration = createDuration;\n    hooks.isMoment = isMoment;\n    hooks.weekdays = listWeekdays;\n    hooks.parseZone = createInZone;\n    hooks.localeData = getLocale;\n    hooks.isDuration = isDuration;\n    hooks.monthsShort = listMonthsShort;\n    hooks.weekdaysMin = listWeekdaysMin;\n    hooks.defineLocale = defineLocale;\n    hooks.updateLocale = updateLocale;\n    hooks.locales = listLocales;\n    hooks.weekdaysShort = listWeekdaysShort;\n    hooks.normalizeUnits = normalizeUnits;\n    hooks.relativeTimeRounding = getSetRelativeTimeRounding;\n    hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;\n    hooks.calendarFormat = getCalendarFormat;\n    hooks.prototype = proto;\n\n    // currently HTML5 input type only supports 24-hour formats\n    hooks.HTML5_FMT = {\n        DATETIME_LOCAL: 'YYYY-MM-DDTHH:mm', // <input type=\"datetime-local\" />\n        DATETIME_LOCAL_SECONDS: 'YYYY-MM-DDTHH:mm:ss', // <input type=\"datetime-local\" step=\"1\" />\n        DATETIME_LOCAL_MS: 'YYYY-MM-DDTHH:mm:ss.SSS', // <input type=\"datetime-local\" step=\"0.001\" />\n        DATE: 'YYYY-MM-DD', // <input type=\"date\" />\n        TIME: 'HH:mm', // <input type=\"time\" />\n        TIME_SECONDS: 'HH:mm:ss', // <input type=\"time\" step=\"1\" />\n        TIME_MS: 'HH:mm:ss.SSS', // <input type=\"time\" step=\"0.001\" />\n        WEEK: 'GGGG-[W]WW', // <input type=\"week\" />\n        MONTH: 'YYYY-MM', // <input type=\"month\" />\n    };\n\n    return hooks;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbW9tZW50L21vbWVudC5qcy5qcyIsIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0QsSUFBSSxLQUE0RDtBQUNoRSxJQUFJLENBQ3lCO0FBQzdCLENBQUMsc0JBQXNCOztBQUV2Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF3QixTQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLHlCQUF5QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFlBQVk7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRCxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixJQUFJO0FBQ3hCO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0dBQXdHLElBQUksd0JBQXdCLElBQUksdURBQXVELElBQUk7QUFDbk0scUVBQXFFLElBQUk7QUFDekUsNEJBQTRCO0FBQzVCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJDQUEyQyxZQUFZO0FBQ3ZEO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixZQUFZO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRDQUE0QyxJQUFJOztBQUVoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGtDQUFrQztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7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QUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLE9BQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixPQUFPO0FBQzNCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FB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QVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsK0JBQStCO0FBQ25EO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLG1DQUFtQyxpQkFBaUI7QUFDcEQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0I7QUFDbEI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsNEdBQTRHO0FBQzVHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQix1QkFBdUI7QUFDM0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLHNCQUFzQjtBQUMxRDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxzQkFBc0I7QUFDMUQ7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0I7QUFDeEI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUNBQXFDLE9BQU87QUFDNUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLE9BQU87QUFDNUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLE9BQU87QUFDNUM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlCQUF5QixtQkFBbUI7QUFDNUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLG1CQUFtQjtBQUN6QztBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0Esb0NBQW9DLElBQUk7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL21vbWVudC9tb21lbnQuanM/OTM4MCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyEgbW9tZW50LmpzXG4vLyEgdmVyc2lvbiA6IDIuMjkuNFxuLy8hIGF1dGhvcnMgOiBUaW0gV29vZCwgSXNrcmVuIENoZXJuZXYsIE1vbWVudC5qcyBjb250cmlidXRvcnNcbi8vISBsaWNlbnNlIDogTUlUXG4vLyEgbW9tZW50anMuY29tXG5cbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcbiAgICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoZmFjdG9yeSkgOlxuICAgIGdsb2JhbC5tb21lbnQgPSBmYWN0b3J5KClcbn0odGhpcywgKGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIGhvb2tDYWxsYmFjaztcblxuICAgIGZ1bmN0aW9uIGhvb2tzKCkge1xuICAgICAgICByZXR1cm4gaG9va0NhbGxiYWNrLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgLy8gVGhpcyBpcyBkb25lIHRvIHJlZ2lzdGVyIHRoZSBtZXRob2QgY2FsbGVkIHdpdGggbW9tZW50KClcbiAgICAvLyB3aXRob3V0IGNyZWF0aW5nIGNpcmN1bGFyIGRlcGVuZGVuY2llcy5cbiAgICBmdW5jdGlvbiBzZXRIb29rQ2FsbGJhY2soY2FsbGJhY2spIHtcbiAgICAgICAgaG9va0NhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNBcnJheShpbnB1dCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgaW5wdXQgaW5zdGFuY2VvZiBBcnJheSB8fFxuICAgICAgICAgICAgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGlucHV0KSA9PT0gJ1tvYmplY3QgQXJyYXldJ1xuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzT2JqZWN0KGlucHV0KSB7XG4gICAgICAgIC8vIElFOCB3aWxsIHRyZWF0IHVuZGVmaW5lZCBhbmQgbnVsbCBhcyBvYmplY3QgaWYgaXQgd2Fzbid0IGZvclxuICAgICAgICAvLyBpbnB1dCAhPSBudWxsXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBpbnB1dCAhPSBudWxsICYmXG4gICAgICAgICAgICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSAnW29iamVjdCBPYmplY3RdJ1xuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhc093blByb3AoYSwgYikge1xuICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGEsIGIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzT2JqZWN0RW1wdHkob2JqKSB7XG4gICAgICAgIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcykge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9iaikubGVuZ3RoID09PSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGs7XG4gICAgICAgICAgICBmb3IgKGsgaW4gb2JqKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhc093blByb3Aob2JqLCBrKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1VuZGVmaW5lZChpbnB1dCkge1xuICAgICAgICByZXR1cm4gaW5wdXQgPT09IHZvaWQgMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc051bWJlcihpbnB1dCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgdHlwZW9mIGlucHV0ID09PSAnbnVtYmVyJyB8fFxuICAgICAgICAgICAgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGlucHV0KSA9PT0gJ1tvYmplY3QgTnVtYmVyXSdcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0RhdGUoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIGlucHV0IGluc3RhbmNlb2YgRGF0ZSB8fFxuICAgICAgICAgICAgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGlucHV0KSA9PT0gJ1tvYmplY3QgRGF0ZV0nXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFwKGFyciwgZm4pIHtcbiAgICAgICAgdmFyIHJlcyA9IFtdLFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIGFyckxlbiA9IGFyci5sZW5ndGg7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBhcnJMZW47ICsraSkge1xuICAgICAgICAgICAgcmVzLnB1c2goZm4oYXJyW2ldLCBpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBleHRlbmQoYSwgYikge1xuICAgICAgICBmb3IgKHZhciBpIGluIGIpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wKGIsIGkpKSB7XG4gICAgICAgICAgICAgICAgYVtpXSA9IGJbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGFzT3duUHJvcChiLCAndG9TdHJpbmcnKSkge1xuICAgICAgICAgICAgYS50b1N0cmluZyA9IGIudG9TdHJpbmc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGFzT3duUHJvcChiLCAndmFsdWVPZicpKSB7XG4gICAgICAgICAgICBhLnZhbHVlT2YgPSBiLnZhbHVlT2Y7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVVVEMoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUxvY2FsT3JVVEMoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QsIHRydWUpLnV0YygpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlZmF1bHRQYXJzaW5nRmxhZ3MoKSB7XG4gICAgICAgIC8vIFdlIG5lZWQgdG8gZGVlcCBjbG9uZSB0aGlzIG9iamVjdC5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGVtcHR5OiBmYWxzZSxcbiAgICAgICAgICAgIHVudXNlZFRva2VuczogW10sXG4gICAgICAgICAgICB1bnVzZWRJbnB1dDogW10sXG4gICAgICAgICAgICBvdmVyZmxvdzogLTIsXG4gICAgICAgICAgICBjaGFyc0xlZnRPdmVyOiAwLFxuICAgICAgICAgICAgbnVsbElucHV0OiBmYWxzZSxcbiAgICAgICAgICAgIGludmFsaWRFcmE6IG51bGwsXG4gICAgICAgICAgICBpbnZhbGlkTW9udGg6IG51bGwsXG4gICAgICAgICAgICBpbnZhbGlkRm9ybWF0OiBmYWxzZSxcbiAgICAgICAgICAgIHVzZXJJbnZhbGlkYXRlZDogZmFsc2UsXG4gICAgICAgICAgICBpc286IGZhbHNlLFxuICAgICAgICAgICAgcGFyc2VkRGF0ZVBhcnRzOiBbXSxcbiAgICAgICAgICAgIGVyYTogbnVsbCxcbiAgICAgICAgICAgIG1lcmlkaWVtOiBudWxsLFxuICAgICAgICAgICAgcmZjMjgyMjogZmFsc2UsXG4gICAgICAgICAgICB3ZWVrZGF5TWlzbWF0Y2g6IGZhbHNlLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFBhcnNpbmdGbGFncyhtKSB7XG4gICAgICAgIGlmIChtLl9wZiA9PSBudWxsKSB7XG4gICAgICAgICAgICBtLl9wZiA9IGRlZmF1bHRQYXJzaW5nRmxhZ3MoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbS5fcGY7XG4gICAgfVxuXG4gICAgdmFyIHNvbWU7XG4gICAgaWYgKEFycmF5LnByb3RvdHlwZS5zb21lKSB7XG4gICAgICAgIHNvbWUgPSBBcnJheS5wcm90b3R5cGUuc29tZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBzb21lID0gZnVuY3Rpb24gKGZ1bikge1xuICAgICAgICAgICAgdmFyIHQgPSBPYmplY3QodGhpcyksXG4gICAgICAgICAgICAgICAgbGVuID0gdC5sZW5ndGggPj4+IDAsXG4gICAgICAgICAgICAgICAgaTtcblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgaW4gdCAmJiBmdW4uY2FsbCh0aGlzLCB0W2ldLCBpLCB0KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1ZhbGlkKG0pIHtcbiAgICAgICAgaWYgKG0uX2lzVmFsaWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIGZsYWdzID0gZ2V0UGFyc2luZ0ZsYWdzKG0pLFxuICAgICAgICAgICAgICAgIHBhcnNlZFBhcnRzID0gc29tZS5jYWxsKGZsYWdzLnBhcnNlZERhdGVQYXJ0cywgZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGkgIT0gbnVsbDtcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBpc05vd1ZhbGlkID1cbiAgICAgICAgICAgICAgICAgICAgIWlzTmFOKG0uX2QuZ2V0VGltZSgpKSAmJlxuICAgICAgICAgICAgICAgICAgICBmbGFncy5vdmVyZmxvdyA8IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgIWZsYWdzLmVtcHR5ICYmXG4gICAgICAgICAgICAgICAgICAgICFmbGFncy5pbnZhbGlkRXJhICYmXG4gICAgICAgICAgICAgICAgICAgICFmbGFncy5pbnZhbGlkTW9udGggJiZcbiAgICAgICAgICAgICAgICAgICAgIWZsYWdzLmludmFsaWRXZWVrZGF5ICYmXG4gICAgICAgICAgICAgICAgICAgICFmbGFncy53ZWVrZGF5TWlzbWF0Y2ggJiZcbiAgICAgICAgICAgICAgICAgICAgIWZsYWdzLm51bGxJbnB1dCAmJlxuICAgICAgICAgICAgICAgICAgICAhZmxhZ3MuaW52YWxpZEZvcm1hdCAmJlxuICAgICAgICAgICAgICAgICAgICAhZmxhZ3MudXNlckludmFsaWRhdGVkICYmXG4gICAgICAgICAgICAgICAgICAgICghZmxhZ3MubWVyaWRpZW0gfHwgKGZsYWdzLm1lcmlkaWVtICYmIHBhcnNlZFBhcnRzKSk7XG5cbiAgICAgICAgICAgIGlmIChtLl9zdHJpY3QpIHtcbiAgICAgICAgICAgICAgICBpc05vd1ZhbGlkID1cbiAgICAgICAgICAgICAgICAgICAgaXNOb3dWYWxpZCAmJlxuICAgICAgICAgICAgICAgICAgICBmbGFncy5jaGFyc0xlZnRPdmVyID09PSAwICYmXG4gICAgICAgICAgICAgICAgICAgIGZsYWdzLnVudXNlZFRva2Vucy5sZW5ndGggPT09IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgZmxhZ3MuYmlnSG91ciA9PT0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoT2JqZWN0LmlzRnJvemVuID09IG51bGwgfHwgIU9iamVjdC5pc0Zyb3plbihtKSkge1xuICAgICAgICAgICAgICAgIG0uX2lzVmFsaWQgPSBpc05vd1ZhbGlkO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNOb3dWYWxpZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbS5faXNWYWxpZDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVJbnZhbGlkKGZsYWdzKSB7XG4gICAgICAgIHZhciBtID0gY3JlYXRlVVRDKE5hTik7XG4gICAgICAgIGlmIChmbGFncyAhPSBudWxsKSB7XG4gICAgICAgICAgICBleHRlbmQoZ2V0UGFyc2luZ0ZsYWdzKG0pLCBmbGFncyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MobSkudXNlckludmFsaWRhdGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtO1xuICAgIH1cblxuICAgIC8vIFBsdWdpbnMgdGhhdCBhZGQgcHJvcGVydGllcyBzaG91bGQgYWxzbyBhZGQgdGhlIGtleSBoZXJlIChudWxsIHZhbHVlKSxcbiAgICAvLyBzbyB3ZSBjYW4gcHJvcGVybHkgY2xvbmUgb3Vyc2VsdmVzLlxuICAgIHZhciBtb21lbnRQcm9wZXJ0aWVzID0gKGhvb2tzLm1vbWVudFByb3BlcnRpZXMgPSBbXSksXG4gICAgICAgIHVwZGF0ZUluUHJvZ3Jlc3MgPSBmYWxzZTtcblxuICAgIGZ1bmN0aW9uIGNvcHlDb25maWcodG8sIGZyb20pIHtcbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgICBwcm9wLFxuICAgICAgICAgICAgdmFsLFxuICAgICAgICAgICAgbW9tZW50UHJvcGVydGllc0xlbiA9IG1vbWVudFByb3BlcnRpZXMubGVuZ3RoO1xuXG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5faXNBTW9tZW50T2JqZWN0KSkge1xuICAgICAgICAgICAgdG8uX2lzQU1vbWVudE9iamVjdCA9IGZyb20uX2lzQU1vbWVudE9iamVjdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX2kpKSB7XG4gICAgICAgICAgICB0by5faSA9IGZyb20uX2k7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9mKSkge1xuICAgICAgICAgICAgdG8uX2YgPSBmcm9tLl9mO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5fbCkpIHtcbiAgICAgICAgICAgIHRvLl9sID0gZnJvbS5fbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX3N0cmljdCkpIHtcbiAgICAgICAgICAgIHRvLl9zdHJpY3QgPSBmcm9tLl9zdHJpY3Q7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl90em0pKSB7XG4gICAgICAgICAgICB0by5fdHptID0gZnJvbS5fdHptO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5faXNVVEMpKSB7XG4gICAgICAgICAgICB0by5faXNVVEMgPSBmcm9tLl9pc1VUQztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX29mZnNldCkpIHtcbiAgICAgICAgICAgIHRvLl9vZmZzZXQgPSBmcm9tLl9vZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9wZikpIHtcbiAgICAgICAgICAgIHRvLl9wZiA9IGdldFBhcnNpbmdGbGFncyhmcm9tKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX2xvY2FsZSkpIHtcbiAgICAgICAgICAgIHRvLl9sb2NhbGUgPSBmcm9tLl9sb2NhbGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobW9tZW50UHJvcGVydGllc0xlbiA+IDApIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBtb21lbnRQcm9wZXJ0aWVzTGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBwcm9wID0gbW9tZW50UHJvcGVydGllc1tpXTtcbiAgICAgICAgICAgICAgICB2YWwgPSBmcm9tW3Byb3BdO1xuICAgICAgICAgICAgICAgIGlmICghaXNVbmRlZmluZWQodmFsKSkge1xuICAgICAgICAgICAgICAgICAgICB0b1twcm9wXSA9IHZhbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdG87XG4gICAgfVxuXG4gICAgLy8gTW9tZW50IHByb3RvdHlwZSBvYmplY3RcbiAgICBmdW5jdGlvbiBNb21lbnQoY29uZmlnKSB7XG4gICAgICAgIGNvcHlDb25maWcodGhpcywgY29uZmlnKTtcbiAgICAgICAgdGhpcy5fZCA9IG5ldyBEYXRlKGNvbmZpZy5fZCAhPSBudWxsID8gY29uZmlnLl9kLmdldFRpbWUoKSA6IE5hTik7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHRoaXMuX2QgPSBuZXcgRGF0ZShOYU4pO1xuICAgICAgICB9XG4gICAgICAgIC8vIFByZXZlbnQgaW5maW5pdGUgbG9vcCBpbiBjYXNlIHVwZGF0ZU9mZnNldCBjcmVhdGVzIG5ldyBtb21lbnRcbiAgICAgICAgLy8gb2JqZWN0cy5cbiAgICAgICAgaWYgKHVwZGF0ZUluUHJvZ3Jlc3MgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB1cGRhdGVJblByb2dyZXNzID0gdHJ1ZTtcbiAgICAgICAgICAgIGhvb2tzLnVwZGF0ZU9mZnNldCh0aGlzKTtcbiAgICAgICAgICAgIHVwZGF0ZUluUHJvZ3Jlc3MgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzTW9tZW50KG9iaikge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgb2JqIGluc3RhbmNlb2YgTW9tZW50IHx8IChvYmogIT0gbnVsbCAmJiBvYmouX2lzQU1vbWVudE9iamVjdCAhPSBudWxsKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdhcm4obXNnKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIGhvb2tzLnN1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5ncyA9PT0gZmFsc2UgJiZcbiAgICAgICAgICAgIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgY29uc29sZS53YXJuXG4gICAgICAgICkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdEZXByZWNhdGlvbiB3YXJuaW5nOiAnICsgbXNnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlcHJlY2F0ZShtc2csIGZuKSB7XG4gICAgICAgIHZhciBmaXJzdFRpbWUgPSB0cnVlO1xuXG4gICAgICAgIHJldHVybiBleHRlbmQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGhvb2tzLmRlcHJlY2F0aW9uSGFuZGxlciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaG9va3MuZGVwcmVjYXRpb25IYW5kbGVyKG51bGwsIG1zZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZmlyc3RUaW1lKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXSxcbiAgICAgICAgICAgICAgICAgICAgYXJnLFxuICAgICAgICAgICAgICAgICAgICBpLFxuICAgICAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgICAgIGFyZ0xlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGFyZ0xlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZyA9ICcnO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1tpXSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZyArPSAnXFxuWycgKyBpICsgJ10gJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoa2V5IGluIGFyZ3VtZW50c1swXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wKGFyZ3VtZW50c1swXSwga2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmcgKz0ga2V5ICsgJzogJyArIGFyZ3VtZW50c1swXVtrZXldICsgJywgJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmcgPSBhcmcuc2xpY2UoMCwgLTIpOyAvLyBSZW1vdmUgdHJhaWxpbmcgY29tbWEgYW5kIHNwYWNlXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmcgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYXJncy5wdXNoKGFyZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAgICAgICAgIG1zZyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnXFxuQXJndW1lbnRzOiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3MpLmpvaW4oJycpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdcXG4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBFcnJvcigpLnN0YWNrXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBmaXJzdFRpbWUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9LCBmbik7XG4gICAgfVxuXG4gICAgdmFyIGRlcHJlY2F0aW9ucyA9IHt9O1xuXG4gICAgZnVuY3Rpb24gZGVwcmVjYXRlU2ltcGxlKG5hbWUsIG1zZykge1xuICAgICAgICBpZiAoaG9va3MuZGVwcmVjYXRpb25IYW5kbGVyICE9IG51bGwpIHtcbiAgICAgICAgICAgIGhvb2tzLmRlcHJlY2F0aW9uSGFuZGxlcihuYW1lLCBtc2cpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZGVwcmVjYXRpb25zW25hbWVdKSB7XG4gICAgICAgICAgICB3YXJuKG1zZyk7XG4gICAgICAgICAgICBkZXByZWNhdGlvbnNbbmFtZV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaG9va3Muc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmdzID0gZmFsc2U7XG4gICAgaG9va3MuZGVwcmVjYXRpb25IYW5kbGVyID0gbnVsbDtcblxuICAgIGZ1bmN0aW9uIGlzRnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICh0eXBlb2YgRnVuY3Rpb24gIT09ICd1bmRlZmluZWQnICYmIGlucHV0IGluc3RhbmNlb2YgRnVuY3Rpb24pIHx8XG4gICAgICAgICAgICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSAnW29iamVjdCBGdW5jdGlvbl0nXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0KGNvbmZpZykge1xuICAgICAgICB2YXIgcHJvcCwgaTtcbiAgICAgICAgZm9yIChpIGluIGNvbmZpZykge1xuICAgICAgICAgICAgaWYgKGhhc093blByb3AoY29uZmlnLCBpKSkge1xuICAgICAgICAgICAgICAgIHByb3AgPSBjb25maWdbaV07XG4gICAgICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24ocHJvcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1tpXSA9IHByb3A7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1snXycgKyBpXSA9IHByb3A7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NvbmZpZyA9IGNvbmZpZztcbiAgICAgICAgLy8gTGVuaWVudCBvcmRpbmFsIHBhcnNpbmcgYWNjZXB0cyBqdXN0IGEgbnVtYmVyIGluIGFkZGl0aW9uIHRvXG4gICAgICAgIC8vIG51bWJlciArIChwb3NzaWJseSkgc3R1ZmYgY29taW5nIGZyb20gX2RheU9mTW9udGhPcmRpbmFsUGFyc2UuXG4gICAgICAgIC8vIFRPRE86IFJlbW92ZSBcIm9yZGluYWxQYXJzZVwiIGZhbGxiYWNrIGluIG5leHQgbWFqb3IgcmVsZWFzZS5cbiAgICAgICAgdGhpcy5fZGF5T2ZNb250aE9yZGluYWxQYXJzZUxlbmllbnQgPSBuZXcgUmVnRXhwKFxuICAgICAgICAgICAgKHRoaXMuX2RheU9mTW9udGhPcmRpbmFsUGFyc2Uuc291cmNlIHx8IHRoaXMuX29yZGluYWxQYXJzZS5zb3VyY2UpICtcbiAgICAgICAgICAgICAgICAnfCcgK1xuICAgICAgICAgICAgICAgIC9cXGR7MSwyfS8uc291cmNlXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWVyZ2VDb25maWdzKHBhcmVudENvbmZpZywgY2hpbGRDb25maWcpIHtcbiAgICAgICAgdmFyIHJlcyA9IGV4dGVuZCh7fSwgcGFyZW50Q29uZmlnKSxcbiAgICAgICAgICAgIHByb3A7XG4gICAgICAgIGZvciAocHJvcCBpbiBjaGlsZENvbmZpZykge1xuICAgICAgICAgICAgaWYgKGhhc093blByb3AoY2hpbGRDb25maWcsIHByb3ApKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzT2JqZWN0KHBhcmVudENvbmZpZ1twcm9wXSkgJiYgaXNPYmplY3QoY2hpbGRDb25maWdbcHJvcF0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc1twcm9wXSA9IHt9O1xuICAgICAgICAgICAgICAgICAgICBleHRlbmQocmVzW3Byb3BdLCBwYXJlbnRDb25maWdbcHJvcF0pO1xuICAgICAgICAgICAgICAgICAgICBleHRlbmQocmVzW3Byb3BdLCBjaGlsZENvbmZpZ1twcm9wXSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjaGlsZENvbmZpZ1twcm9wXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc1twcm9wXSA9IGNoaWxkQ29uZmlnW3Byb3BdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSByZXNbcHJvcF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAocHJvcCBpbiBwYXJlbnRDb25maWcpIHtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBoYXNPd25Qcm9wKHBhcmVudENvbmZpZywgcHJvcCkgJiZcbiAgICAgICAgICAgICAgICAhaGFzT3duUHJvcChjaGlsZENvbmZpZywgcHJvcCkgJiZcbiAgICAgICAgICAgICAgICBpc09iamVjdChwYXJlbnRDb25maWdbcHJvcF0pXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAvLyBtYWtlIHN1cmUgY2hhbmdlcyB0byBwcm9wZXJ0aWVzIGRvbid0IG1vZGlmeSBwYXJlbnQgY29uZmlnXG4gICAgICAgICAgICAgICAgcmVzW3Byb3BdID0gZXh0ZW5kKHt9LCByZXNbcHJvcF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gTG9jYWxlKGNvbmZpZykge1xuICAgICAgICBpZiAoY29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0KGNvbmZpZyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIga2V5cztcblxuICAgIGlmIChPYmplY3Qua2V5cykge1xuICAgICAgICBrZXlzID0gT2JqZWN0LmtleXM7XG4gICAgfSBlbHNlIHtcbiAgICAgICAga2V5cyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgIHZhciBpLFxuICAgICAgICAgICAgICAgIHJlcyA9IFtdO1xuICAgICAgICAgICAgZm9yIChpIGluIG9iaikge1xuICAgICAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wKG9iaiwgaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzLnB1c2goaSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdENhbGVuZGFyID0ge1xuICAgICAgICBzYW1lRGF5OiAnW1RvZGF5IGF0XSBMVCcsXG4gICAgICAgIG5leHREYXk6ICdbVG9tb3Jyb3cgYXRdIExUJyxcbiAgICAgICAgbmV4dFdlZWs6ICdkZGRkIFthdF0gTFQnLFxuICAgICAgICBsYXN0RGF5OiAnW1llc3RlcmRheSBhdF0gTFQnLFxuICAgICAgICBsYXN0V2VlazogJ1tMYXN0XSBkZGRkIFthdF0gTFQnLFxuICAgICAgICBzYW1lRWxzZTogJ0wnLFxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBjYWxlbmRhcihrZXksIG1vbSwgbm93KSB7XG4gICAgICAgIHZhciBvdXRwdXQgPSB0aGlzLl9jYWxlbmRhcltrZXldIHx8IHRoaXMuX2NhbGVuZGFyWydzYW1lRWxzZSddO1xuICAgICAgICByZXR1cm4gaXNGdW5jdGlvbihvdXRwdXQpID8gb3V0cHV0LmNhbGwobW9tLCBub3cpIDogb3V0cHV0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHplcm9GaWxsKG51bWJlciwgdGFyZ2V0TGVuZ3RoLCBmb3JjZVNpZ24pIHtcbiAgICAgICAgdmFyIGFic051bWJlciA9ICcnICsgTWF0aC5hYnMobnVtYmVyKSxcbiAgICAgICAgICAgIHplcm9zVG9GaWxsID0gdGFyZ2V0TGVuZ3RoIC0gYWJzTnVtYmVyLmxlbmd0aCxcbiAgICAgICAgICAgIHNpZ24gPSBudW1iZXIgPj0gMDtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIChzaWduID8gKGZvcmNlU2lnbiA/ICcrJyA6ICcnKSA6ICctJykgK1xuICAgICAgICAgICAgTWF0aC5wb3coMTAsIE1hdGgubWF4KDAsIHplcm9zVG9GaWxsKSkudG9TdHJpbmcoKS5zdWJzdHIoMSkgK1xuICAgICAgICAgICAgYWJzTnVtYmVyXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgdmFyIGZvcm1hdHRpbmdUb2tlbnMgPVxuICAgICAgICAgICAgLyhcXFtbXlxcW10qXFxdKXwoXFxcXCk/KFtIaF1tbShzcyk/fE1vfE1NP00/TT98RG98REREb3xERD9EP0Q/fGRkZD9kP3xkbz98d1tvfHddP3xXW298V10/fFFvP3xOezEsNX18WVlZWVlZfFlZWVlZfFlZWVl8WVl8eXsyLDR9fHlvP3xnZyhnZ2c/KT98R0coR0dHPyk/fGV8RXxhfEF8aGg/fEhIP3xraz98bW0/fHNzP3xTezEsOX18eHxYfHp6P3xaWj98LikvZyxcbiAgICAgICAgbG9jYWxGb3JtYXR0aW5nVG9rZW5zID0gLyhcXFtbXlxcW10qXFxdKXwoXFxcXCk/KExUU3xMVHxMTD9MP0w/fGx7MSw0fSkvZyxcbiAgICAgICAgZm9ybWF0RnVuY3Rpb25zID0ge30sXG4gICAgICAgIGZvcm1hdFRva2VuRnVuY3Rpb25zID0ge307XG5cbiAgICAvLyB0b2tlbjogICAgJ00nXG4gICAgLy8gcGFkZGVkOiAgIFsnTU0nLCAyXVxuICAgIC8vIG9yZGluYWw6ICAnTW8nXG4gICAgLy8gY2FsbGJhY2s6IGZ1bmN0aW9uICgpIHsgdGhpcy5tb250aCgpICsgMSB9XG4gICAgZnVuY3Rpb24gYWRkRm9ybWF0VG9rZW4odG9rZW4sIHBhZGRlZCwgb3JkaW5hbCwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGZ1bmMgPSBjYWxsYmFjaztcbiAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbY2FsbGJhY2tdKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b2tlbikge1xuICAgICAgICAgICAgZm9ybWF0VG9rZW5GdW5jdGlvbnNbdG9rZW5dID0gZnVuYztcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFkZGVkKSB7XG4gICAgICAgICAgICBmb3JtYXRUb2tlbkZ1bmN0aW9uc1twYWRkZWRbMF1dID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB6ZXJvRmlsbChmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksIHBhZGRlZFsxXSwgcGFkZGVkWzJdKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9yZGluYWwpIHtcbiAgICAgICAgICAgIGZvcm1hdFRva2VuRnVuY3Rpb25zW29yZGluYWxdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5vcmRpbmFsKFxuICAgICAgICAgICAgICAgICAgICBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksXG4gICAgICAgICAgICAgICAgICAgIHRva2VuXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZW1vdmVGb3JtYXR0aW5nVG9rZW5zKGlucHV0KSB7XG4gICAgICAgIGlmIChpbnB1dC5tYXRjaCgvXFxbW1xcc1xcU10vKSkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0LnJlcGxhY2UoL15cXFt8XFxdJC9nLCAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlucHV0LnJlcGxhY2UoL1xcXFwvZywgJycpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1ha2VGb3JtYXRGdW5jdGlvbihmb3JtYXQpIHtcbiAgICAgICAgdmFyIGFycmF5ID0gZm9ybWF0Lm1hdGNoKGZvcm1hdHRpbmdUb2tlbnMpLFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIGxlbmd0aDtcblxuICAgICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBhcnJheS5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGZvcm1hdFRva2VuRnVuY3Rpb25zW2FycmF5W2ldXSkge1xuICAgICAgICAgICAgICAgIGFycmF5W2ldID0gZm9ybWF0VG9rZW5GdW5jdGlvbnNbYXJyYXlbaV1dO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhcnJheVtpXSA9IHJlbW92ZUZvcm1hdHRpbmdUb2tlbnMoYXJyYXlbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChtb20pIHtcbiAgICAgICAgICAgIHZhciBvdXRwdXQgPSAnJyxcbiAgICAgICAgICAgICAgICBpO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0ICs9IGlzRnVuY3Rpb24oYXJyYXlbaV0pXG4gICAgICAgICAgICAgICAgICAgID8gYXJyYXlbaV0uY2FsbChtb20sIGZvcm1hdClcbiAgICAgICAgICAgICAgICAgICAgOiBhcnJheVtpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gZm9ybWF0IGRhdGUgdXNpbmcgbmF0aXZlIGRhdGUgb2JqZWN0XG4gICAgZnVuY3Rpb24gZm9ybWF0TW9tZW50KG0sIGZvcm1hdCkge1xuICAgICAgICBpZiAoIW0uaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gbS5sb2NhbGVEYXRhKCkuaW52YWxpZERhdGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvcm1hdCA9IGV4cGFuZEZvcm1hdChmb3JtYXQsIG0ubG9jYWxlRGF0YSgpKTtcbiAgICAgICAgZm9ybWF0RnVuY3Rpb25zW2Zvcm1hdF0gPVxuICAgICAgICAgICAgZm9ybWF0RnVuY3Rpb25zW2Zvcm1hdF0gfHwgbWFrZUZvcm1hdEZ1bmN0aW9uKGZvcm1hdCk7XG5cbiAgICAgICAgcmV0dXJuIGZvcm1hdEZ1bmN0aW9uc1tmb3JtYXRdKG0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGV4cGFuZEZvcm1hdChmb3JtYXQsIGxvY2FsZSkge1xuICAgICAgICB2YXIgaSA9IDU7XG5cbiAgICAgICAgZnVuY3Rpb24gcmVwbGFjZUxvbmdEYXRlRm9ybWF0VG9rZW5zKGlucHV0KSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxlLmxvbmdEYXRlRm9ybWF0KGlucHV0KSB8fCBpbnB1dDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxvY2FsRm9ybWF0dGluZ1Rva2Vucy5sYXN0SW5kZXggPSAwO1xuICAgICAgICB3aGlsZSAoaSA+PSAwICYmIGxvY2FsRm9ybWF0dGluZ1Rva2Vucy50ZXN0KGZvcm1hdCkpIHtcbiAgICAgICAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKFxuICAgICAgICAgICAgICAgIGxvY2FsRm9ybWF0dGluZ1Rva2VucyxcbiAgICAgICAgICAgICAgICByZXBsYWNlTG9uZ0RhdGVGb3JtYXRUb2tlbnNcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBsb2NhbEZvcm1hdHRpbmdUb2tlbnMubGFzdEluZGV4ID0gMDtcbiAgICAgICAgICAgIGkgLT0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmb3JtYXQ7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRMb25nRGF0ZUZvcm1hdCA9IHtcbiAgICAgICAgTFRTOiAnaDptbTpzcyBBJyxcbiAgICAgICAgTFQ6ICdoOm1tIEEnLFxuICAgICAgICBMOiAnTU0vREQvWVlZWScsXG4gICAgICAgIExMOiAnTU1NTSBELCBZWVlZJyxcbiAgICAgICAgTExMOiAnTU1NTSBELCBZWVlZIGg6bW0gQScsXG4gICAgICAgIExMTEw6ICdkZGRkLCBNTU1NIEQsIFlZWVkgaDptbSBBJyxcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gbG9uZ0RhdGVGb3JtYXQoa2V5KSB7XG4gICAgICAgIHZhciBmb3JtYXQgPSB0aGlzLl9sb25nRGF0ZUZvcm1hdFtrZXldLFxuICAgICAgICAgICAgZm9ybWF0VXBwZXIgPSB0aGlzLl9sb25nRGF0ZUZvcm1hdFtrZXkudG9VcHBlckNhc2UoKV07XG5cbiAgICAgICAgaWYgKGZvcm1hdCB8fCAhZm9ybWF0VXBwZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBmb3JtYXQ7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9sb25nRGF0ZUZvcm1hdFtrZXldID0gZm9ybWF0VXBwZXJcbiAgICAgICAgICAgIC5tYXRjaChmb3JtYXR0aW5nVG9rZW5zKVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAodG9rKSB7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICB0b2sgPT09ICdNTU1NJyB8fFxuICAgICAgICAgICAgICAgICAgICB0b2sgPT09ICdNTScgfHxcbiAgICAgICAgICAgICAgICAgICAgdG9rID09PSAnREQnIHx8XG4gICAgICAgICAgICAgICAgICAgIHRvayA9PT0gJ2RkZGQnXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0b2suc2xpY2UoMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0b2s7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmpvaW4oJycpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9sb25nRGF0ZUZvcm1hdFtrZXldO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0SW52YWxpZERhdGUgPSAnSW52YWxpZCBkYXRlJztcblxuICAgIGZ1bmN0aW9uIGludmFsaWREYXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW52YWxpZERhdGU7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRPcmRpbmFsID0gJyVkJyxcbiAgICAgICAgZGVmYXVsdERheU9mTW9udGhPcmRpbmFsUGFyc2UgPSAvXFxkezEsMn0vO1xuXG4gICAgZnVuY3Rpb24gb3JkaW5hbChudW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29yZGluYWwucmVwbGFjZSgnJWQnLCBudW1iZXIpO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0UmVsYXRpdmVUaW1lID0ge1xuICAgICAgICBmdXR1cmU6ICdpbiAlcycsXG4gICAgICAgIHBhc3Q6ICclcyBhZ28nLFxuICAgICAgICBzOiAnYSBmZXcgc2Vjb25kcycsXG4gICAgICAgIHNzOiAnJWQgc2Vjb25kcycsXG4gICAgICAgIG06ICdhIG1pbnV0ZScsXG4gICAgICAgIG1tOiAnJWQgbWludXRlcycsXG4gICAgICAgIGg6ICdhbiBob3VyJyxcbiAgICAgICAgaGg6ICclZCBob3VycycsXG4gICAgICAgIGQ6ICdhIGRheScsXG4gICAgICAgIGRkOiAnJWQgZGF5cycsXG4gICAgICAgIHc6ICdhIHdlZWsnLFxuICAgICAgICB3dzogJyVkIHdlZWtzJyxcbiAgICAgICAgTTogJ2EgbW9udGgnLFxuICAgICAgICBNTTogJyVkIG1vbnRocycsXG4gICAgICAgIHk6ICdhIHllYXInLFxuICAgICAgICB5eTogJyVkIHllYXJzJyxcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gcmVsYXRpdmVUaW1lKG51bWJlciwgd2l0aG91dFN1ZmZpeCwgc3RyaW5nLCBpc0Z1dHVyZSkge1xuICAgICAgICB2YXIgb3V0cHV0ID0gdGhpcy5fcmVsYXRpdmVUaW1lW3N0cmluZ107XG4gICAgICAgIHJldHVybiBpc0Z1bmN0aW9uKG91dHB1dClcbiAgICAgICAgICAgID8gb3V0cHV0KG51bWJlciwgd2l0aG91dFN1ZmZpeCwgc3RyaW5nLCBpc0Z1dHVyZSlcbiAgICAgICAgICAgIDogb3V0cHV0LnJlcGxhY2UoLyVkL2ksIG51bWJlcik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFzdEZ1dHVyZShkaWZmLCBvdXRwdXQpIHtcbiAgICAgICAgdmFyIGZvcm1hdCA9IHRoaXMuX3JlbGF0aXZlVGltZVtkaWZmID4gMCA/ICdmdXR1cmUnIDogJ3Bhc3QnXTtcbiAgICAgICAgcmV0dXJuIGlzRnVuY3Rpb24oZm9ybWF0KSA/IGZvcm1hdChvdXRwdXQpIDogZm9ybWF0LnJlcGxhY2UoLyVzL2ksIG91dHB1dCk7XG4gICAgfVxuXG4gICAgdmFyIGFsaWFzZXMgPSB7fTtcblxuICAgIGZ1bmN0aW9uIGFkZFVuaXRBbGlhcyh1bml0LCBzaG9ydGhhbmQpIHtcbiAgICAgICAgdmFyIGxvd2VyQ2FzZSA9IHVuaXQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgYWxpYXNlc1tsb3dlckNhc2VdID0gYWxpYXNlc1tsb3dlckNhc2UgKyAncyddID0gYWxpYXNlc1tzaG9ydGhhbmRdID0gdW5pdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBub3JtYWxpemVVbml0cyh1bml0cykge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHVuaXRzID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgPyBhbGlhc2VzW3VuaXRzXSB8fCBhbGlhc2VzW3VuaXRzLnRvTG93ZXJDYXNlKCldXG4gICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBub3JtYWxpemVPYmplY3RVbml0cyhpbnB1dE9iamVjdCkge1xuICAgICAgICB2YXIgbm9ybWFsaXplZElucHV0ID0ge30sXG4gICAgICAgICAgICBub3JtYWxpemVkUHJvcCxcbiAgICAgICAgICAgIHByb3A7XG5cbiAgICAgICAgZm9yIChwcm9wIGluIGlucHV0T2JqZWN0KSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcChpbnB1dE9iamVjdCwgcHJvcCkpIHtcbiAgICAgICAgICAgICAgICBub3JtYWxpemVkUHJvcCA9IG5vcm1hbGl6ZVVuaXRzKHByb3ApO1xuICAgICAgICAgICAgICAgIGlmIChub3JtYWxpemVkUHJvcCkge1xuICAgICAgICAgICAgICAgICAgICBub3JtYWxpemVkSW5wdXRbbm9ybWFsaXplZFByb3BdID0gaW5wdXRPYmplY3RbcHJvcF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZWRJbnB1dDtcbiAgICB9XG5cbiAgICB2YXIgcHJpb3JpdGllcyA9IHt9O1xuXG4gICAgZnVuY3Rpb24gYWRkVW5pdFByaW9yaXR5KHVuaXQsIHByaW9yaXR5KSB7XG4gICAgICAgIHByaW9yaXRpZXNbdW5pdF0gPSBwcmlvcml0eTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRQcmlvcml0aXplZFVuaXRzKHVuaXRzT2JqKSB7XG4gICAgICAgIHZhciB1bml0cyA9IFtdLFxuICAgICAgICAgICAgdTtcbiAgICAgICAgZm9yICh1IGluIHVuaXRzT2JqKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcCh1bml0c09iaiwgdSkpIHtcbiAgICAgICAgICAgICAgICB1bml0cy5wdXNoKHsgdW5pdDogdSwgcHJpb3JpdHk6IHByaW9yaXRpZXNbdV0gfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdW5pdHMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGEucHJpb3JpdHkgLSBiLnByaW9yaXR5O1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHVuaXRzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzTGVhcFllYXIoeWVhcikge1xuICAgICAgICByZXR1cm4gKHllYXIgJSA0ID09PSAwICYmIHllYXIgJSAxMDAgIT09IDApIHx8IHllYXIgJSA0MDAgPT09IDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWJzRmxvb3IobnVtYmVyKSB7XG4gICAgICAgIGlmIChudW1iZXIgPCAwKSB7XG4gICAgICAgICAgICAvLyAtMCAtPiAwXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5jZWlsKG51bWJlcikgfHwgMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmZsb29yKG51bWJlcik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b0ludChhcmd1bWVudEZvckNvZXJjaW9uKSB7XG4gICAgICAgIHZhciBjb2VyY2VkTnVtYmVyID0gK2FyZ3VtZW50Rm9yQ29lcmNpb24sXG4gICAgICAgICAgICB2YWx1ZSA9IDA7XG5cbiAgICAgICAgaWYgKGNvZXJjZWROdW1iZXIgIT09IDAgJiYgaXNGaW5pdGUoY29lcmNlZE51bWJlcikpIHtcbiAgICAgICAgICAgIHZhbHVlID0gYWJzRmxvb3IoY29lcmNlZE51bWJlcik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFrZUdldFNldCh1bml0LCBrZWVwVGltZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHNldCQxKHRoaXMsIHVuaXQsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICBob29rcy51cGRhdGVPZmZzZXQodGhpcywga2VlcFRpbWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0KHRoaXMsIHVuaXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldChtb20sIHVuaXQpIHtcbiAgICAgICAgcmV0dXJuIG1vbS5pc1ZhbGlkKClcbiAgICAgICAgICAgID8gbW9tLl9kWydnZXQnICsgKG1vbS5faXNVVEMgPyAnVVRDJyA6ICcnKSArIHVuaXRdKClcbiAgICAgICAgICAgIDogTmFOO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldCQxKG1vbSwgdW5pdCwgdmFsdWUpIHtcbiAgICAgICAgaWYgKG1vbS5pc1ZhbGlkKCkgJiYgIWlzTmFOKHZhbHVlKSkge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIHVuaXQgPT09ICdGdWxsWWVhcicgJiZcbiAgICAgICAgICAgICAgICBpc0xlYXBZZWFyKG1vbS55ZWFyKCkpICYmXG4gICAgICAgICAgICAgICAgbW9tLm1vbnRoKCkgPT09IDEgJiZcbiAgICAgICAgICAgICAgICBtb20uZGF0ZSgpID09PSAyOVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB0b0ludCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgbW9tLl9kWydzZXQnICsgKG1vbS5faXNVVEMgPyAnVVRDJyA6ICcnKSArIHVuaXRdKFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgbW9tLm1vbnRoKCksXG4gICAgICAgICAgICAgICAgICAgIGRheXNJbk1vbnRoKHZhbHVlLCBtb20ubW9udGgoKSlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtb20uX2RbJ3NldCcgKyAobW9tLl9pc1VUQyA/ICdVVEMnIDogJycpICsgdW5pdF0odmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgZnVuY3Rpb24gc3RyaW5nR2V0KHVuaXRzKSB7XG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuICAgICAgICBpZiAoaXNGdW5jdGlvbih0aGlzW3VuaXRzXSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzW3VuaXRzXSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN0cmluZ1NldCh1bml0cywgdmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB1bml0cyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHVuaXRzID0gbm9ybWFsaXplT2JqZWN0VW5pdHModW5pdHMpO1xuICAgICAgICAgICAgdmFyIHByaW9yaXRpemVkID0gZ2V0UHJpb3JpdGl6ZWRVbml0cyh1bml0cyksXG4gICAgICAgICAgICAgICAgaSxcbiAgICAgICAgICAgICAgICBwcmlvcml0aXplZExlbiA9IHByaW9yaXRpemVkLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBwcmlvcml0aXplZExlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpc1twcmlvcml0aXplZFtpXS51bml0XSh1bml0c1twcmlvcml0aXplZFtpXS51bml0XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcbiAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKHRoaXNbdW5pdHNdKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzW3VuaXRzXSh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdmFyIG1hdGNoMSA9IC9cXGQvLCAvLyAgICAgICAwIC0gOVxuICAgICAgICBtYXRjaDIgPSAvXFxkXFxkLywgLy8gICAgICAwMCAtIDk5XG4gICAgICAgIG1hdGNoMyA9IC9cXGR7M30vLCAvLyAgICAgMDAwIC0gOTk5XG4gICAgICAgIG1hdGNoNCA9IC9cXGR7NH0vLCAvLyAgICAwMDAwIC0gOTk5OVxuICAgICAgICBtYXRjaDYgPSAvWystXT9cXGR7Nn0vLCAvLyAtOTk5OTk5IC0gOTk5OTk5XG4gICAgICAgIG1hdGNoMXRvMiA9IC9cXGRcXGQ/LywgLy8gICAgICAgMCAtIDk5XG4gICAgICAgIG1hdGNoM3RvNCA9IC9cXGRcXGRcXGRcXGQ/LywgLy8gICAgIDk5OSAtIDk5OTlcbiAgICAgICAgbWF0Y2g1dG82ID0gL1xcZFxcZFxcZFxcZFxcZFxcZD8vLCAvLyAgIDk5OTk5IC0gOTk5OTk5XG4gICAgICAgIG1hdGNoMXRvMyA9IC9cXGR7MSwzfS8sIC8vICAgICAgIDAgLSA5OTlcbiAgICAgICAgbWF0Y2gxdG80ID0gL1xcZHsxLDR9LywgLy8gICAgICAgMCAtIDk5OTlcbiAgICAgICAgbWF0Y2gxdG82ID0gL1srLV0/XFxkezEsNn0vLCAvLyAtOTk5OTk5IC0gOTk5OTk5XG4gICAgICAgIG1hdGNoVW5zaWduZWQgPSAvXFxkKy8sIC8vICAgICAgIDAgLSBpbmZcbiAgICAgICAgbWF0Y2hTaWduZWQgPSAvWystXT9cXGQrLywgLy8gICAgLWluZiAtIGluZlxuICAgICAgICBtYXRjaE9mZnNldCA9IC9afFsrLV1cXGRcXGQ6P1xcZFxcZC9naSwgLy8gKzAwOjAwIC0wMDowMCArMDAwMCAtMDAwMCBvciBaXG4gICAgICAgIG1hdGNoU2hvcnRPZmZzZXQgPSAvWnxbKy1dXFxkXFxkKD86Oj9cXGRcXGQpPy9naSwgLy8gKzAwIC0wMCArMDA6MDAgLTAwOjAwICswMDAwIC0wMDAwIG9yIFpcbiAgICAgICAgbWF0Y2hUaW1lc3RhbXAgPSAvWystXT9cXGQrKFxcLlxcZHsxLDN9KT8vLCAvLyAxMjM0NTY3ODkgMTIzNDU2Nzg5LjEyM1xuICAgICAgICAvLyBhbnkgd29yZCAob3IgdHdvKSBjaGFyYWN0ZXJzIG9yIG51bWJlcnMgaW5jbHVkaW5nIHR3by90aHJlZSB3b3JkIG1vbnRoIGluIGFyYWJpYy5cbiAgICAgICAgLy8gaW5jbHVkZXMgc2NvdHRpc2ggZ2FlbGljIHR3byB3b3JkIGFuZCBoeXBoZW5hdGVkIG1vbnRoc1xuICAgICAgICBtYXRjaFdvcmQgPVxuICAgICAgICAgICAgL1swLTldezAsMjU2fVsnYS16XFx1MDBBMC1cXHUwNUZGXFx1MDcwMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRjA3XFx1RkYxMC1cXHVGRkVGXXsxLDI1Nn18W1xcdTA2MDAtXFx1MDZGRlxcL117MSwyNTZ9KFxccyo/W1xcdTA2MDAtXFx1MDZGRl17MSwyNTZ9KXsxLDJ9L2ksXG4gICAgICAgIHJlZ2V4ZXM7XG5cbiAgICByZWdleGVzID0ge307XG5cbiAgICBmdW5jdGlvbiBhZGRSZWdleFRva2VuKHRva2VuLCByZWdleCwgc3RyaWN0UmVnZXgpIHtcbiAgICAgICAgcmVnZXhlc1t0b2tlbl0gPSBpc0Z1bmN0aW9uKHJlZ2V4KVxuICAgICAgICAgICAgPyByZWdleFxuICAgICAgICAgICAgOiBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZURhdGEpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBpc1N0cmljdCAmJiBzdHJpY3RSZWdleCA/IHN0cmljdFJlZ2V4IDogcmVnZXg7XG4gICAgICAgICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0UGFyc2VSZWdleEZvclRva2VuKHRva2VuLCBjb25maWcpIHtcbiAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHJlZ2V4ZXMsIHRva2VuKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAodW5lc2NhcGVGb3JtYXQodG9rZW4pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZWdleGVzW3Rva2VuXShjb25maWcuX3N0cmljdCwgY29uZmlnLl9sb2NhbGUpO1xuICAgIH1cblxuICAgIC8vIENvZGUgZnJvbSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzM1NjE0OTMvaXMtdGhlcmUtYS1yZWdleHAtZXNjYXBlLWZ1bmN0aW9uLWluLWphdmFzY3JpcHRcbiAgICBmdW5jdGlvbiB1bmVzY2FwZUZvcm1hdChzKSB7XG4gICAgICAgIHJldHVybiByZWdleEVzY2FwZShcbiAgICAgICAgICAgIHNcbiAgICAgICAgICAgICAgICAucmVwbGFjZSgnXFxcXCcsICcnKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKFxuICAgICAgICAgICAgICAgICAgICAvXFxcXChcXFspfFxcXFwoXFxdKXxcXFsoW15cXF1cXFtdKilcXF18XFxcXCguKS9nLFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAobWF0Y2hlZCwgcDEsIHAyLCBwMywgcDQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwMSB8fCBwMiB8fCBwMyB8fCBwNDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWdleEVzY2FwZShzKSB7XG4gICAgICAgIHJldHVybiBzLnJlcGxhY2UoL1stXFwvXFxcXF4kKis/LigpfFtcXF17fV0vZywgJ1xcXFwkJicpO1xuICAgIH1cblxuICAgIHZhciB0b2tlbnMgPSB7fTtcblxuICAgIGZ1bmN0aW9uIGFkZFBhcnNlVG9rZW4odG9rZW4sIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBpLFxuICAgICAgICAgICAgZnVuYyA9IGNhbGxiYWNrLFxuICAgICAgICAgICAgdG9rZW5MZW47XG4gICAgICAgIGlmICh0eXBlb2YgdG9rZW4gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0b2tlbiA9IFt0b2tlbl07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTnVtYmVyKGNhbGxiYWNrKSkge1xuICAgICAgICAgICAgZnVuYyA9IGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgICAgICAgICBhcnJheVtjYWxsYmFja10gPSB0b0ludChpbnB1dCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHRva2VuTGVuID0gdG9rZW4ubGVuZ3RoO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdG9rZW5MZW47IGkrKykge1xuICAgICAgICAgICAgdG9rZW5zW3Rva2VuW2ldXSA9IGZ1bmM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRXZWVrUGFyc2VUb2tlbih0b2tlbiwgY2FsbGJhY2spIHtcbiAgICAgICAgYWRkUGFyc2VUb2tlbih0b2tlbiwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnLCB0b2tlbikge1xuICAgICAgICAgICAgY29uZmlnLl93ID0gY29uZmlnLl93IHx8IHt9O1xuICAgICAgICAgICAgY2FsbGJhY2soaW5wdXQsIGNvbmZpZy5fdywgY29uZmlnLCB0b2tlbik7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZFRpbWVUb0FycmF5RnJvbVRva2VuKHRva2VuLCBpbnB1dCwgY29uZmlnKSB7XG4gICAgICAgIGlmIChpbnB1dCAhPSBudWxsICYmIGhhc093blByb3AodG9rZW5zLCB0b2tlbikpIHtcbiAgICAgICAgICAgIHRva2Vuc1t0b2tlbl0oaW5wdXQsIGNvbmZpZy5fYSwgY29uZmlnLCB0b2tlbik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgWUVBUiA9IDAsXG4gICAgICAgIE1PTlRIID0gMSxcbiAgICAgICAgREFURSA9IDIsXG4gICAgICAgIEhPVVIgPSAzLFxuICAgICAgICBNSU5VVEUgPSA0LFxuICAgICAgICBTRUNPTkQgPSA1LFxuICAgICAgICBNSUxMSVNFQ09ORCA9IDYsXG4gICAgICAgIFdFRUsgPSA3LFxuICAgICAgICBXRUVLREFZID0gODtcblxuICAgIGZ1bmN0aW9uIG1vZChuLCB4KSB7XG4gICAgICAgIHJldHVybiAoKG4gJSB4KSArIHgpICUgeDtcbiAgICB9XG5cbiAgICB2YXIgaW5kZXhPZjtcblxuICAgIGlmIChBcnJheS5wcm90b3R5cGUuaW5kZXhPZikge1xuICAgICAgICBpbmRleE9mID0gQXJyYXkucHJvdG90eXBlLmluZGV4T2Y7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaW5kZXhPZiA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgICAgICAvLyBJIGtub3dcbiAgICAgICAgICAgIHZhciBpO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpc1tpXSA9PT0gbykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGF5c0luTW9udGgoeWVhciwgbW9udGgpIHtcbiAgICAgICAgaWYgKGlzTmFOKHllYXIpIHx8IGlzTmFOKG1vbnRoKSkge1xuICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbW9kTW9udGggPSBtb2QobW9udGgsIDEyKTtcbiAgICAgICAgeWVhciArPSAobW9udGggLSBtb2RNb250aCkgLyAxMjtcbiAgICAgICAgcmV0dXJuIG1vZE1vbnRoID09PSAxXG4gICAgICAgICAgICA/IGlzTGVhcFllYXIoeWVhcilcbiAgICAgICAgICAgICAgICA/IDI5XG4gICAgICAgICAgICAgICAgOiAyOFxuICAgICAgICAgICAgOiAzMSAtICgobW9kTW9udGggJSA3KSAlIDIpO1xuICAgIH1cblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdNJywgWydNTScsIDJdLCAnTW8nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vbnRoKCkgKyAxO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ01NTScsIDAsIDAsIGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLm1vbnRoc1Nob3J0KHRoaXMsIGZvcm1hdCk7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignTU1NTScsIDAsIDAsIGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLm1vbnRocyh0aGlzLCBmb3JtYXQpO1xuICAgIH0pO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdtb250aCcsICdNJyk7XG5cbiAgICAvLyBQUklPUklUWVxuXG4gICAgYWRkVW5pdFByaW9yaXR5KCdtb250aCcsIDgpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignTScsIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignTU0nLCBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbignTU1NJywgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS5tb250aHNTaG9ydFJlZ2V4KGlzU3RyaWN0KTtcbiAgICB9KTtcbiAgICBhZGRSZWdleFRva2VuKCdNTU1NJywgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS5tb250aHNSZWdleChpc1N0cmljdCk7XG4gICAgfSk7XG5cbiAgICBhZGRQYXJzZVRva2VuKFsnTScsICdNTSddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgIGFycmF5W01PTlRIXSA9IHRvSW50KGlucHV0KSAtIDE7XG4gICAgfSk7XG5cbiAgICBhZGRQYXJzZVRva2VuKFsnTU1NJywgJ01NTU0nXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnLCB0b2tlbikge1xuICAgICAgICB2YXIgbW9udGggPSBjb25maWcuX2xvY2FsZS5tb250aHNQYXJzZShpbnB1dCwgdG9rZW4sIGNvbmZpZy5fc3RyaWN0KTtcbiAgICAgICAgLy8gaWYgd2UgZGlkbid0IGZpbmQgYSBtb250aCBuYW1lLCBtYXJrIHRoZSBkYXRlIGFzIGludmFsaWQuXG4gICAgICAgIGlmIChtb250aCAhPSBudWxsKSB7XG4gICAgICAgICAgICBhcnJheVtNT05USF0gPSBtb250aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmludmFsaWRNb250aCA9IGlucHV0O1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBMT0NBTEVTXG5cbiAgICB2YXIgZGVmYXVsdExvY2FsZU1vbnRocyA9XG4gICAgICAgICAgICAnSmFudWFyeV9GZWJydWFyeV9NYXJjaF9BcHJpbF9NYXlfSnVuZV9KdWx5X0F1Z3VzdF9TZXB0ZW1iZXJfT2N0b2Jlcl9Ob3ZlbWJlcl9EZWNlbWJlcicuc3BsaXQoXG4gICAgICAgICAgICAgICAgJ18nXG4gICAgICAgICAgICApLFxuICAgICAgICBkZWZhdWx0TG9jYWxlTW9udGhzU2hvcnQgPVxuICAgICAgICAgICAgJ0phbl9GZWJfTWFyX0Fwcl9NYXlfSnVuX0p1bF9BdWdfU2VwX09jdF9Ob3ZfRGVjJy5zcGxpdCgnXycpLFxuICAgICAgICBNT05USFNfSU5fRk9STUFUID0gL0Rbb0RdPyhcXFtbXlxcW1xcXV0qXFxdfFxccykrTU1NTT8vLFxuICAgICAgICBkZWZhdWx0TW9udGhzU2hvcnRSZWdleCA9IG1hdGNoV29yZCxcbiAgICAgICAgZGVmYXVsdE1vbnRoc1JlZ2V4ID0gbWF0Y2hXb3JkO1xuXG4gICAgZnVuY3Rpb24gbG9jYWxlTW9udGhzKG0sIGZvcm1hdCkge1xuICAgICAgICBpZiAoIW0pIHtcbiAgICAgICAgICAgIHJldHVybiBpc0FycmF5KHRoaXMuX21vbnRocylcbiAgICAgICAgICAgICAgICA/IHRoaXMuX21vbnRoc1xuICAgICAgICAgICAgICAgIDogdGhpcy5fbW9udGhzWydzdGFuZGFsb25lJ107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzQXJyYXkodGhpcy5fbW9udGhzKVxuICAgICAgICAgICAgPyB0aGlzLl9tb250aHNbbS5tb250aCgpXVxuICAgICAgICAgICAgOiB0aGlzLl9tb250aHNbXG4gICAgICAgICAgICAgICAgICAodGhpcy5fbW9udGhzLmlzRm9ybWF0IHx8IE1PTlRIU19JTl9GT1JNQVQpLnRlc3QoZm9ybWF0KVxuICAgICAgICAgICAgICAgICAgICAgID8gJ2Zvcm1hdCdcbiAgICAgICAgICAgICAgICAgICAgICA6ICdzdGFuZGFsb25lJ1xuICAgICAgICAgICAgICBdW20ubW9udGgoKV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9jYWxlTW9udGhzU2hvcnQobSwgZm9ybWF0KSB7XG4gICAgICAgIGlmICghbSkge1xuICAgICAgICAgICAgcmV0dXJuIGlzQXJyYXkodGhpcy5fbW9udGhzU2hvcnQpXG4gICAgICAgICAgICAgICAgPyB0aGlzLl9tb250aHNTaG9ydFxuICAgICAgICAgICAgICAgIDogdGhpcy5fbW9udGhzU2hvcnRbJ3N0YW5kYWxvbmUnXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXNBcnJheSh0aGlzLl9tb250aHNTaG9ydClcbiAgICAgICAgICAgID8gdGhpcy5fbW9udGhzU2hvcnRbbS5tb250aCgpXVxuICAgICAgICAgICAgOiB0aGlzLl9tb250aHNTaG9ydFtcbiAgICAgICAgICAgICAgICAgIE1PTlRIU19JTl9GT1JNQVQudGVzdChmb3JtYXQpID8gJ2Zvcm1hdCcgOiAnc3RhbmRhbG9uZSdcbiAgICAgICAgICAgICAgXVttLm1vbnRoKCldO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhbmRsZVN0cmljdFBhcnNlKG1vbnRoTmFtZSwgZm9ybWF0LCBzdHJpY3QpIHtcbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgICBpaSxcbiAgICAgICAgICAgIG1vbSxcbiAgICAgICAgICAgIGxsYyA9IG1vbnRoTmFtZS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoIXRoaXMuX21vbnRoc1BhcnNlKSB7XG4gICAgICAgICAgICAvLyB0aGlzIGlzIG5vdCB1c2VkXG4gICAgICAgICAgICB0aGlzLl9tb250aHNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fbG9uZ01vbnRoc1BhcnNlID0gW107XG4gICAgICAgICAgICB0aGlzLl9zaG9ydE1vbnRoc1BhcnNlID0gW107XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTI7ICsraSkge1xuICAgICAgICAgICAgICAgIG1vbSA9IGNyZWF0ZVVUQyhbMjAwMCwgaV0pO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Nob3J0TW9udGhzUGFyc2VbaV0gPSB0aGlzLm1vbnRoc1Nob3J0KFxuICAgICAgICAgICAgICAgICAgICBtb20sXG4gICAgICAgICAgICAgICAgICAgICcnXG4gICAgICAgICAgICAgICAgKS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2xvbmdNb250aHNQYXJzZVtpXSA9IHRoaXMubW9udGhzKG1vbSwgJycpLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RyaWN0KSB7XG4gICAgICAgICAgICBpZiAoZm9ybWF0ID09PSAnTU1NJykge1xuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0TW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbG9uZ01vbnRoc1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoZm9ybWF0ID09PSAnTU1NJykge1xuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0TW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX2xvbmdNb250aHNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9sb25nTW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0TW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvY2FsZU1vbnRoc1BhcnNlKG1vbnRoTmFtZSwgZm9ybWF0LCBzdHJpY3QpIHtcbiAgICAgICAgdmFyIGksIG1vbSwgcmVnZXg7XG5cbiAgICAgICAgaWYgKHRoaXMuX21vbnRoc1BhcnNlRXhhY3QpIHtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVTdHJpY3RQYXJzZS5jYWxsKHRoaXMsIG1vbnRoTmFtZSwgZm9ybWF0LCBzdHJpY3QpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLl9tb250aHNQYXJzZSkge1xuICAgICAgICAgICAgdGhpcy5fbW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX2xvbmdNb250aHNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fc2hvcnRNb250aHNQYXJzZSA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVE9ETzogYWRkIHNvcnRpbmdcbiAgICAgICAgLy8gU29ydGluZyBtYWtlcyBzdXJlIGlmIG9uZSBtb250aCAob3IgYWJicikgaXMgYSBwcmVmaXggb2YgYW5vdGhlclxuICAgICAgICAvLyBzZWUgc29ydGluZyBpbiBjb21wdXRlTW9udGhzUGFyc2VcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDEyOyBpKyspIHtcbiAgICAgICAgICAgIC8vIG1ha2UgdGhlIHJlZ2V4IGlmIHdlIGRvbid0IGhhdmUgaXQgYWxyZWFkeVxuICAgICAgICAgICAgbW9tID0gY3JlYXRlVVRDKFsyMDAwLCBpXSk7XG4gICAgICAgICAgICBpZiAoc3RyaWN0ICYmICF0aGlzLl9sb25nTW9udGhzUGFyc2VbaV0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sb25nTW9udGhzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKFxuICAgICAgICAgICAgICAgICAgICAnXicgKyB0aGlzLm1vbnRocyhtb20sICcnKS5yZXBsYWNlKCcuJywgJycpICsgJyQnLFxuICAgICAgICAgICAgICAgICAgICAnaSdcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Nob3J0TW9udGhzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKFxuICAgICAgICAgICAgICAgICAgICAnXicgKyB0aGlzLm1vbnRoc1Nob3J0KG1vbSwgJycpLnJlcGxhY2UoJy4nLCAnJykgKyAnJCcsXG4gICAgICAgICAgICAgICAgICAgICdpJ1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXN0cmljdCAmJiAhdGhpcy5fbW9udGhzUGFyc2VbaV0pIHtcbiAgICAgICAgICAgICAgICByZWdleCA9XG4gICAgICAgICAgICAgICAgICAgICdeJyArIHRoaXMubW9udGhzKG1vbSwgJycpICsgJ3xeJyArIHRoaXMubW9udGhzU2hvcnQobW9tLCAnJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbW9udGhzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKHJlZ2V4LnJlcGxhY2UoJy4nLCAnJyksICdpJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0ZXN0IHRoZSByZWdleFxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIHN0cmljdCAmJlxuICAgICAgICAgICAgICAgIGZvcm1hdCA9PT0gJ01NTU0nICYmXG4gICAgICAgICAgICAgICAgdGhpcy5fbG9uZ01vbnRoc1BhcnNlW2ldLnRlc3QobW9udGhOYW1lKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICAgIHN0cmljdCAmJlxuICAgICAgICAgICAgICAgIGZvcm1hdCA9PT0gJ01NTScgJiZcbiAgICAgICAgICAgICAgICB0aGlzLl9zaG9ydE1vbnRoc1BhcnNlW2ldLnRlc3QobW9udGhOYW1lKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFzdHJpY3QgJiYgdGhpcy5fbW9udGhzUGFyc2VbaV0udGVzdChtb250aE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBzZXRNb250aChtb20sIHZhbHVlKSB7XG4gICAgICAgIHZhciBkYXlPZk1vbnRoO1xuXG4gICAgICAgIGlmICghbW9tLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgLy8gTm8gb3BcbiAgICAgICAgICAgIHJldHVybiBtb207XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaWYgKC9eXFxkKyQvLnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB0b0ludCh2YWx1ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gbW9tLmxvY2FsZURhdGEoKS5tb250aHNQYXJzZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogQW5vdGhlciBzaWxlbnQgZmFpbHVyZT9cbiAgICAgICAgICAgICAgICBpZiAoIWlzTnVtYmVyKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbW9tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGRheU9mTW9udGggPSBNYXRoLm1pbihtb20uZGF0ZSgpLCBkYXlzSW5Nb250aChtb20ueWVhcigpLCB2YWx1ZSkpO1xuICAgICAgICBtb20uX2RbJ3NldCcgKyAobW9tLl9pc1VUQyA/ICdVVEMnIDogJycpICsgJ01vbnRoJ10odmFsdWUsIGRheU9mTW9udGgpO1xuICAgICAgICByZXR1cm4gbW9tO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNldE1vbnRoKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBzZXRNb250aCh0aGlzLCB2YWx1ZSk7XG4gICAgICAgICAgICBob29rcy51cGRhdGVPZmZzZXQodGhpcywgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBnZXQodGhpcywgJ01vbnRoJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXREYXlzSW5Nb250aCgpIHtcbiAgICAgICAgcmV0dXJuIGRheXNJbk1vbnRoKHRoaXMueWVhcigpLCB0aGlzLm1vbnRoKCkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vbnRoc1Nob3J0UmVnZXgoaXNTdHJpY3QpIHtcbiAgICAgICAgaWYgKHRoaXMuX21vbnRoc1BhcnNlRXhhY3QpIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX21vbnRoc1JlZ2V4JykpIHtcbiAgICAgICAgICAgICAgICBjb21wdXRlTW9udGhzUGFyc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1N0cmljdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9tb250aHNTaG9ydFN0cmljdFJlZ2V4O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzU2hvcnRSZWdleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX21vbnRoc1Nob3J0UmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX21vbnRoc1Nob3J0UmVnZXggPSBkZWZhdWx0TW9udGhzU2hvcnRSZWdleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9tb250aHNTaG9ydFN0cmljdFJlZ2V4ICYmIGlzU3RyaWN0XG4gICAgICAgICAgICAgICAgPyB0aGlzLl9tb250aHNTaG9ydFN0cmljdFJlZ2V4XG4gICAgICAgICAgICAgICAgOiB0aGlzLl9tb250aHNTaG9ydFJlZ2V4O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW9udGhzUmVnZXgoaXNTdHJpY3QpIHtcbiAgICAgICAgaWYgKHRoaXMuX21vbnRoc1BhcnNlRXhhY3QpIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX21vbnRoc1JlZ2V4JykpIHtcbiAgICAgICAgICAgICAgICBjb21wdXRlTW9udGhzUGFyc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1N0cmljdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9tb250aHNTdHJpY3RSZWdleDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1JlZ2V4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfbW9udGhzUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX21vbnRoc1JlZ2V4ID0gZGVmYXVsdE1vbnRoc1JlZ2V4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1N0cmljdFJlZ2V4ICYmIGlzU3RyaWN0XG4gICAgICAgICAgICAgICAgPyB0aGlzLl9tb250aHNTdHJpY3RSZWdleFxuICAgICAgICAgICAgICAgIDogdGhpcy5fbW9udGhzUmVnZXg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb21wdXRlTW9udGhzUGFyc2UoKSB7XG4gICAgICAgIGZ1bmN0aW9uIGNtcExlblJldihhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYi5sZW5ndGggLSBhLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzaG9ydFBpZWNlcyA9IFtdLFxuICAgICAgICAgICAgbG9uZ1BpZWNlcyA9IFtdLFxuICAgICAgICAgICAgbWl4ZWRQaWVjZXMgPSBbXSxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBtb207XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCAxMjsgaSsrKSB7XG4gICAgICAgICAgICAvLyBtYWtlIHRoZSByZWdleCBpZiB3ZSBkb24ndCBoYXZlIGl0IGFscmVhZHlcbiAgICAgICAgICAgIG1vbSA9IGNyZWF0ZVVUQyhbMjAwMCwgaV0pO1xuICAgICAgICAgICAgc2hvcnRQaWVjZXMucHVzaCh0aGlzLm1vbnRoc1Nob3J0KG1vbSwgJycpKTtcbiAgICAgICAgICAgIGxvbmdQaWVjZXMucHVzaCh0aGlzLm1vbnRocyhtb20sICcnKSk7XG4gICAgICAgICAgICBtaXhlZFBpZWNlcy5wdXNoKHRoaXMubW9udGhzKG1vbSwgJycpKTtcbiAgICAgICAgICAgIG1peGVkUGllY2VzLnB1c2godGhpcy5tb250aHNTaG9ydChtb20sICcnKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU29ydGluZyBtYWtlcyBzdXJlIGlmIG9uZSBtb250aCAob3IgYWJicikgaXMgYSBwcmVmaXggb2YgYW5vdGhlciBpdFxuICAgICAgICAvLyB3aWxsIG1hdGNoIHRoZSBsb25nZXIgcGllY2UuXG4gICAgICAgIHNob3J0UGllY2VzLnNvcnQoY21wTGVuUmV2KTtcbiAgICAgICAgbG9uZ1BpZWNlcy5zb3J0KGNtcExlblJldik7XG4gICAgICAgIG1peGVkUGllY2VzLnNvcnQoY21wTGVuUmV2KTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDEyOyBpKyspIHtcbiAgICAgICAgICAgIHNob3J0UGllY2VzW2ldID0gcmVnZXhFc2NhcGUoc2hvcnRQaWVjZXNbaV0pO1xuICAgICAgICAgICAgbG9uZ1BpZWNlc1tpXSA9IHJlZ2V4RXNjYXBlKGxvbmdQaWVjZXNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCAyNDsgaSsrKSB7XG4gICAgICAgICAgICBtaXhlZFBpZWNlc1tpXSA9IHJlZ2V4RXNjYXBlKG1peGVkUGllY2VzW2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX21vbnRoc1JlZ2V4ID0gbmV3IFJlZ0V4cCgnXignICsgbWl4ZWRQaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xuICAgICAgICB0aGlzLl9tb250aHNTaG9ydFJlZ2V4ID0gdGhpcy5fbW9udGhzUmVnZXg7XG4gICAgICAgIHRoaXMuX21vbnRoc1N0cmljdFJlZ2V4ID0gbmV3IFJlZ0V4cChcbiAgICAgICAgICAgICdeKCcgKyBsb25nUGllY2VzLmpvaW4oJ3wnKSArICcpJyxcbiAgICAgICAgICAgICdpJ1xuICAgICAgICApO1xuICAgICAgICB0aGlzLl9tb250aHNTaG9ydFN0cmljdFJlZ2V4ID0gbmV3IFJlZ0V4cChcbiAgICAgICAgICAgICdeKCcgKyBzaG9ydFBpZWNlcy5qb2luKCd8JykgKyAnKScsXG4gICAgICAgICAgICAnaSdcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignWScsIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHkgPSB0aGlzLnllYXIoKTtcbiAgICAgICAgcmV0dXJuIHkgPD0gOTk5OSA/IHplcm9GaWxsKHksIDQpIDogJysnICsgeTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnWVknLCAyXSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy55ZWFyKCkgJSAxMDA7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1lZWVknLCA0XSwgMCwgJ3llYXInKTtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1lZWVlZJywgNV0sIDAsICd5ZWFyJyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydZWVlZWVknLCA2LCB0cnVlXSwgMCwgJ3llYXInKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygneWVhcicsICd5Jyk7XG5cbiAgICAvLyBQUklPUklUSUVTXG5cbiAgICBhZGRVbml0UHJpb3JpdHkoJ3llYXInLCAxKTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ1knLCBtYXRjaFNpZ25lZCk7XG4gICAgYWRkUmVnZXhUb2tlbignWVknLCBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbignWVlZWScsIG1hdGNoMXRvNCwgbWF0Y2g0KTtcbiAgICBhZGRSZWdleFRva2VuKCdZWVlZWScsIG1hdGNoMXRvNiwgbWF0Y2g2KTtcbiAgICBhZGRSZWdleFRva2VuKCdZWVlZWVknLCBtYXRjaDF0bzYsIG1hdGNoNik7XG5cbiAgICBhZGRQYXJzZVRva2VuKFsnWVlZWVknLCAnWVlZWVlZJ10sIFlFQVIpO1xuICAgIGFkZFBhcnNlVG9rZW4oJ1lZWVknLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgIGFycmF5W1lFQVJdID1cbiAgICAgICAgICAgIGlucHV0Lmxlbmd0aCA9PT0gMiA/IGhvb2tzLnBhcnNlVHdvRGlnaXRZZWFyKGlucHV0KSA6IHRvSW50KGlucHV0KTtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKCdZWScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgYXJyYXlbWUVBUl0gPSBob29rcy5wYXJzZVR3b0RpZ2l0WWVhcihpbnB1dCk7XG4gICAgfSk7XG4gICAgYWRkUGFyc2VUb2tlbignWScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgYXJyYXlbWUVBUl0gPSBwYXJzZUludChpbnB1dCwgMTApO1xuICAgIH0pO1xuXG4gICAgLy8gSEVMUEVSU1xuXG4gICAgZnVuY3Rpb24gZGF5c0luWWVhcih5ZWFyKSB7XG4gICAgICAgIHJldHVybiBpc0xlYXBZZWFyKHllYXIpID8gMzY2IDogMzY1O1xuICAgIH1cblxuICAgIC8vIEhPT0tTXG5cbiAgICBob29rcy5wYXJzZVR3b0RpZ2l0WWVhciA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICByZXR1cm4gdG9JbnQoaW5wdXQpICsgKHRvSW50KGlucHV0KSA+IDY4ID8gMTkwMCA6IDIwMDApO1xuICAgIH07XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICB2YXIgZ2V0U2V0WWVhciA9IG1ha2VHZXRTZXQoJ0Z1bGxZZWFyJywgdHJ1ZSk7XG5cbiAgICBmdW5jdGlvbiBnZXRJc0xlYXBZZWFyKCkge1xuICAgICAgICByZXR1cm4gaXNMZWFwWWVhcih0aGlzLnllYXIoKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlRGF0ZSh5LCBtLCBkLCBoLCBNLCBzLCBtcykge1xuICAgICAgICAvLyBjYW4ndCBqdXN0IGFwcGx5KCkgdG8gY3JlYXRlIGEgZGF0ZTpcbiAgICAgICAgLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xLzE4MTM0OFxuICAgICAgICB2YXIgZGF0ZTtcbiAgICAgICAgLy8gdGhlIGRhdGUgY29uc3RydWN0b3IgcmVtYXBzIHllYXJzIDAtOTkgdG8gMTkwMC0xOTk5XG4gICAgICAgIGlmICh5IDwgMTAwICYmIHkgPj0gMCkge1xuICAgICAgICAgICAgLy8gcHJlc2VydmUgbGVhcCB5ZWFycyB1c2luZyBhIGZ1bGwgNDAwIHllYXIgY3ljbGUsIHRoZW4gcmVzZXRcbiAgICAgICAgICAgIGRhdGUgPSBuZXcgRGF0ZSh5ICsgNDAwLCBtLCBkLCBoLCBNLCBzLCBtcyk7XG4gICAgICAgICAgICBpZiAoaXNGaW5pdGUoZGF0ZS5nZXRGdWxsWWVhcigpKSkge1xuICAgICAgICAgICAgICAgIGRhdGUuc2V0RnVsbFllYXIoeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkYXRlID0gbmV3IERhdGUoeSwgbSwgZCwgaCwgTSwgcywgbXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRhdGU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlVVRDRGF0ZSh5KSB7XG4gICAgICAgIHZhciBkYXRlLCBhcmdzO1xuICAgICAgICAvLyB0aGUgRGF0ZS5VVEMgZnVuY3Rpb24gcmVtYXBzIHllYXJzIDAtOTkgdG8gMTkwMC0xOTk5XG4gICAgICAgIGlmICh5IDwgMTAwICYmIHkgPj0gMCkge1xuICAgICAgICAgICAgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAvLyBwcmVzZXJ2ZSBsZWFwIHllYXJzIHVzaW5nIGEgZnVsbCA0MDAgeWVhciBjeWNsZSwgdGhlbiByZXNldFxuICAgICAgICAgICAgYXJnc1swXSA9IHkgKyA0MDA7XG4gICAgICAgICAgICBkYXRlID0gbmV3IERhdGUoRGF0ZS5VVEMuYXBwbHkobnVsbCwgYXJncykpO1xuICAgICAgICAgICAgaWYgKGlzRmluaXRlKGRhdGUuZ2V0VVRDRnVsbFllYXIoKSkpIHtcbiAgICAgICAgICAgICAgICBkYXRlLnNldFVUQ0Z1bGxZZWFyKHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGF0ZSA9IG5ldyBEYXRlKERhdGUuVVRDLmFwcGx5KG51bGwsIGFyZ3VtZW50cykpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRhdGU7XG4gICAgfVxuXG4gICAgLy8gc3RhcnQtb2YtZmlyc3Qtd2VlayAtIHN0YXJ0LW9mLXllYXJcbiAgICBmdW5jdGlvbiBmaXJzdFdlZWtPZmZzZXQoeWVhciwgZG93LCBkb3kpIHtcbiAgICAgICAgdmFyIC8vIGZpcnN0LXdlZWsgZGF5IC0tIHdoaWNoIGphbnVhcnkgaXMgYWx3YXlzIGluIHRoZSBmaXJzdCB3ZWVrICg0IGZvciBpc28sIDEgZm9yIG90aGVyKVxuICAgICAgICAgICAgZndkID0gNyArIGRvdyAtIGRveSxcbiAgICAgICAgICAgIC8vIGZpcnN0LXdlZWsgZGF5IGxvY2FsIHdlZWtkYXkgLS0gd2hpY2ggbG9jYWwgd2Vla2RheSBpcyBmd2RcbiAgICAgICAgICAgIGZ3ZGx3ID0gKDcgKyBjcmVhdGVVVENEYXRlKHllYXIsIDAsIGZ3ZCkuZ2V0VVRDRGF5KCkgLSBkb3cpICUgNztcblxuICAgICAgICByZXR1cm4gLWZ3ZGx3ICsgZndkIC0gMTtcbiAgICB9XG5cbiAgICAvLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JU09fd2Vla19kYXRlI0NhbGN1bGF0aW5nX2FfZGF0ZV9naXZlbl90aGVfeWVhci4yQ193ZWVrX251bWJlcl9hbmRfd2Vla2RheVxuICAgIGZ1bmN0aW9uIGRheU9mWWVhckZyb21XZWVrcyh5ZWFyLCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSkge1xuICAgICAgICB2YXIgbG9jYWxXZWVrZGF5ID0gKDcgKyB3ZWVrZGF5IC0gZG93KSAlIDcsXG4gICAgICAgICAgICB3ZWVrT2Zmc2V0ID0gZmlyc3RXZWVrT2Zmc2V0KHllYXIsIGRvdywgZG95KSxcbiAgICAgICAgICAgIGRheU9mWWVhciA9IDEgKyA3ICogKHdlZWsgLSAxKSArIGxvY2FsV2Vla2RheSArIHdlZWtPZmZzZXQsXG4gICAgICAgICAgICByZXNZZWFyLFxuICAgICAgICAgICAgcmVzRGF5T2ZZZWFyO1xuXG4gICAgICAgIGlmIChkYXlPZlllYXIgPD0gMCkge1xuICAgICAgICAgICAgcmVzWWVhciA9IHllYXIgLSAxO1xuICAgICAgICAgICAgcmVzRGF5T2ZZZWFyID0gZGF5c0luWWVhcihyZXNZZWFyKSArIGRheU9mWWVhcjtcbiAgICAgICAgfSBlbHNlIGlmIChkYXlPZlllYXIgPiBkYXlzSW5ZZWFyKHllYXIpKSB7XG4gICAgICAgICAgICByZXNZZWFyID0geWVhciArIDE7XG4gICAgICAgICAgICByZXNEYXlPZlllYXIgPSBkYXlPZlllYXIgLSBkYXlzSW5ZZWFyKHllYXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzWWVhciA9IHllYXI7XG4gICAgICAgICAgICByZXNEYXlPZlllYXIgPSBkYXlPZlllYXI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeWVhcjogcmVzWWVhcixcbiAgICAgICAgICAgIGRheU9mWWVhcjogcmVzRGF5T2ZZZWFyLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdlZWtPZlllYXIobW9tLCBkb3csIGRveSkge1xuICAgICAgICB2YXIgd2Vla09mZnNldCA9IGZpcnN0V2Vla09mZnNldChtb20ueWVhcigpLCBkb3csIGRveSksXG4gICAgICAgICAgICB3ZWVrID0gTWF0aC5mbG9vcigobW9tLmRheU9mWWVhcigpIC0gd2Vla09mZnNldCAtIDEpIC8gNykgKyAxLFxuICAgICAgICAgICAgcmVzV2VlayxcbiAgICAgICAgICAgIHJlc1llYXI7XG5cbiAgICAgICAgaWYgKHdlZWsgPCAxKSB7XG4gICAgICAgICAgICByZXNZZWFyID0gbW9tLnllYXIoKSAtIDE7XG4gICAgICAgICAgICByZXNXZWVrID0gd2VlayArIHdlZWtzSW5ZZWFyKHJlc1llYXIsIGRvdywgZG95KTtcbiAgICAgICAgfSBlbHNlIGlmICh3ZWVrID4gd2Vla3NJblllYXIobW9tLnllYXIoKSwgZG93LCBkb3kpKSB7XG4gICAgICAgICAgICByZXNXZWVrID0gd2VlayAtIHdlZWtzSW5ZZWFyKG1vbS55ZWFyKCksIGRvdywgZG95KTtcbiAgICAgICAgICAgIHJlc1llYXIgPSBtb20ueWVhcigpICsgMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc1llYXIgPSBtb20ueWVhcigpO1xuICAgICAgICAgICAgcmVzV2VlayA9IHdlZWs7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgd2VlazogcmVzV2VlayxcbiAgICAgICAgICAgIHllYXI6IHJlc1llYXIsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gd2Vla3NJblllYXIoeWVhciwgZG93LCBkb3kpIHtcbiAgICAgICAgdmFyIHdlZWtPZmZzZXQgPSBmaXJzdFdlZWtPZmZzZXQoeWVhciwgZG93LCBkb3kpLFxuICAgICAgICAgICAgd2Vla09mZnNldE5leHQgPSBmaXJzdFdlZWtPZmZzZXQoeWVhciArIDEsIGRvdywgZG95KTtcbiAgICAgICAgcmV0dXJuIChkYXlzSW5ZZWFyKHllYXIpIC0gd2Vla09mZnNldCArIHdlZWtPZmZzZXROZXh0KSAvIDc7XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ3cnLCBbJ3d3JywgMl0sICd3bycsICd3ZWVrJyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oJ1cnLCBbJ1dXJywgMl0sICdXbycsICdpc29XZWVrJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ3dlZWsnLCAndycpO1xuICAgIGFkZFVuaXRBbGlhcygnaXNvV2VlaycsICdXJyk7XG5cbiAgICAvLyBQUklPUklUSUVTXG5cbiAgICBhZGRVbml0UHJpb3JpdHkoJ3dlZWsnLCA1KTtcbiAgICBhZGRVbml0UHJpb3JpdHkoJ2lzb1dlZWsnLCA1KTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ3cnLCBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ3d3JywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1cnLCBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1dXJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuXG4gICAgYWRkV2Vla1BhcnNlVG9rZW4oXG4gICAgICAgIFsndycsICd3dycsICdXJywgJ1dXJ10sXG4gICAgICAgIGZ1bmN0aW9uIChpbnB1dCwgd2VlaywgY29uZmlnLCB0b2tlbikge1xuICAgICAgICAgICAgd2Vla1t0b2tlbi5zdWJzdHIoMCwgMSldID0gdG9JbnQoaW5wdXQpO1xuICAgICAgICB9XG4gICAgKTtcblxuICAgIC8vIEhFTFBFUlNcblxuICAgIC8vIExPQ0FMRVNcblxuICAgIGZ1bmN0aW9uIGxvY2FsZVdlZWsobW9tKSB7XG4gICAgICAgIHJldHVybiB3ZWVrT2ZZZWFyKG1vbSwgdGhpcy5fd2Vlay5kb3csIHRoaXMuX3dlZWsuZG95KS53ZWVrO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0TG9jYWxlV2VlayA9IHtcbiAgICAgICAgZG93OiAwLCAvLyBTdW5kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICAgICAgZG95OiA2LCAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiA2dGggaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGxvY2FsZUZpcnN0RGF5T2ZXZWVrKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd2Vlay5kb3c7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9jYWxlRmlyc3REYXlPZlllYXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93ZWVrLmRveTtcbiAgICB9XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBnZXRTZXRXZWVrKGlucHV0KSB7XG4gICAgICAgIHZhciB3ZWVrID0gdGhpcy5sb2NhbGVEYXRhKCkud2Vlayh0aGlzKTtcbiAgICAgICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyB3ZWVrIDogdGhpcy5hZGQoKGlucHV0IC0gd2VlaykgKiA3LCAnZCcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNldElTT1dlZWsoaW5wdXQpIHtcbiAgICAgICAgdmFyIHdlZWsgPSB3ZWVrT2ZZZWFyKHRoaXMsIDEsIDQpLndlZWs7XG4gICAgICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gd2VlayA6IHRoaXMuYWRkKChpbnB1dCAtIHdlZWspICogNywgJ2QnKTtcbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignZCcsIDAsICdkbycsICdkYXknKTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdkZCcsIDAsIDAsIGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLndlZWtkYXlzTWluKHRoaXMsIGZvcm1hdCk7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignZGRkJywgMCwgMCwgZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkud2Vla2RheXNTaG9ydCh0aGlzLCBmb3JtYXQpO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ2RkZGQnLCAwLCAwLCBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS53ZWVrZGF5cyh0aGlzLCBmb3JtYXQpO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ2UnLCAwLCAwLCAnd2Vla2RheScpO1xuICAgIGFkZEZvcm1hdFRva2VuKCdFJywgMCwgMCwgJ2lzb1dlZWtkYXknKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnZGF5JywgJ2QnKTtcbiAgICBhZGRVbml0QWxpYXMoJ3dlZWtkYXknLCAnZScpO1xuICAgIGFkZFVuaXRBbGlhcygnaXNvV2Vla2RheScsICdFJyk7XG5cbiAgICAvLyBQUklPUklUWVxuICAgIGFkZFVuaXRQcmlvcml0eSgnZGF5JywgMTEpO1xuICAgIGFkZFVuaXRQcmlvcml0eSgnd2Vla2RheScsIDExKTtcbiAgICBhZGRVbml0UHJpb3JpdHkoJ2lzb1dlZWtkYXknLCAxMSk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdkJywgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdlJywgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdFJywgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdkZCcsIGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUud2Vla2RheXNNaW5SZWdleChpc1N0cmljdCk7XG4gICAgfSk7XG4gICAgYWRkUmVnZXhUb2tlbignZGRkJywgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS53ZWVrZGF5c1Nob3J0UmVnZXgoaXNTdHJpY3QpO1xuICAgIH0pO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2RkZGQnLCBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gbG9jYWxlLndlZWtkYXlzUmVnZXgoaXNTdHJpY3QpO1xuICAgIH0pO1xuXG4gICAgYWRkV2Vla1BhcnNlVG9rZW4oWydkZCcsICdkZGQnLCAnZGRkZCddLCBmdW5jdGlvbiAoaW5wdXQsIHdlZWssIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgdmFyIHdlZWtkYXkgPSBjb25maWcuX2xvY2FsZS53ZWVrZGF5c1BhcnNlKGlucHV0LCB0b2tlbiwgY29uZmlnLl9zdHJpY3QpO1xuICAgICAgICAvLyBpZiB3ZSBkaWRuJ3QgZ2V0IGEgd2Vla2RheSBuYW1lLCBtYXJrIHRoZSBkYXRlIGFzIGludmFsaWRcbiAgICAgICAgaWYgKHdlZWtkYXkgIT0gbnVsbCkge1xuICAgICAgICAgICAgd2Vlay5kID0gd2Vla2RheTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmludmFsaWRXZWVrZGF5ID0gaW5wdXQ7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGFkZFdlZWtQYXJzZVRva2VuKFsnZCcsICdlJywgJ0UnXSwgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgIHdlZWtbdG9rZW5dID0gdG9JbnQoaW5wdXQpO1xuICAgIH0pO1xuXG4gICAgLy8gSEVMUEVSU1xuXG4gICAgZnVuY3Rpb24gcGFyc2VXZWVrZGF5KGlucHV0LCBsb2NhbGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNOYU4oaW5wdXQpKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQoaW5wdXQsIDEwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlucHV0ID0gbG9jYWxlLndlZWtkYXlzUGFyc2UoaW5wdXQpO1xuICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VJc29XZWVrZGF5KGlucHV0LCBsb2NhbGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbGUud2Vla2RheXNQYXJzZShpbnB1dCkgJSA3IHx8IDc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzTmFOKGlucHV0KSA/IG51bGwgOiBpbnB1dDtcbiAgICB9XG5cbiAgICAvLyBMT0NBTEVTXG4gICAgZnVuY3Rpb24gc2hpZnRXZWVrZGF5cyh3cywgbikge1xuICAgICAgICByZXR1cm4gd3Muc2xpY2UobiwgNykuY29uY2F0KHdzLnNsaWNlKDAsIG4pKTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdExvY2FsZVdlZWtkYXlzID1cbiAgICAgICAgICAgICdTdW5kYXlfTW9uZGF5X1R1ZXNkYXlfV2VkbmVzZGF5X1RodXJzZGF5X0ZyaWRheV9TYXR1cmRheScuc3BsaXQoJ18nKSxcbiAgICAgICAgZGVmYXVsdExvY2FsZVdlZWtkYXlzU2hvcnQgPSAnU3VuX01vbl9UdWVfV2VkX1RodV9GcmlfU2F0Jy5zcGxpdCgnXycpLFxuICAgICAgICBkZWZhdWx0TG9jYWxlV2Vla2RheXNNaW4gPSAnU3VfTW9fVHVfV2VfVGhfRnJfU2EnLnNwbGl0KCdfJyksXG4gICAgICAgIGRlZmF1bHRXZWVrZGF5c1JlZ2V4ID0gbWF0Y2hXb3JkLFxuICAgICAgICBkZWZhdWx0V2Vla2RheXNTaG9ydFJlZ2V4ID0gbWF0Y2hXb3JkLFxuICAgICAgICBkZWZhdWx0V2Vla2RheXNNaW5SZWdleCA9IG1hdGNoV29yZDtcblxuICAgIGZ1bmN0aW9uIGxvY2FsZVdlZWtkYXlzKG0sIGZvcm1hdCkge1xuICAgICAgICB2YXIgd2Vla2RheXMgPSBpc0FycmF5KHRoaXMuX3dlZWtkYXlzKVxuICAgICAgICAgICAgPyB0aGlzLl93ZWVrZGF5c1xuICAgICAgICAgICAgOiB0aGlzLl93ZWVrZGF5c1tcbiAgICAgICAgICAgICAgICAgIG0gJiYgbSAhPT0gdHJ1ZSAmJiB0aGlzLl93ZWVrZGF5cy5pc0Zvcm1hdC50ZXN0KGZvcm1hdClcbiAgICAgICAgICAgICAgICAgICAgICA/ICdmb3JtYXQnXG4gICAgICAgICAgICAgICAgICAgICAgOiAnc3RhbmRhbG9uZSdcbiAgICAgICAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIG0gPT09IHRydWVcbiAgICAgICAgICAgID8gc2hpZnRXZWVrZGF5cyh3ZWVrZGF5cywgdGhpcy5fd2Vlay5kb3cpXG4gICAgICAgICAgICA6IG1cbiAgICAgICAgICAgID8gd2Vla2RheXNbbS5kYXkoKV1cbiAgICAgICAgICAgIDogd2Vla2RheXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9jYWxlV2Vla2RheXNTaG9ydChtKSB7XG4gICAgICAgIHJldHVybiBtID09PSB0cnVlXG4gICAgICAgICAgICA/IHNoaWZ0V2Vla2RheXModGhpcy5fd2Vla2RheXNTaG9ydCwgdGhpcy5fd2Vlay5kb3cpXG4gICAgICAgICAgICA6IG1cbiAgICAgICAgICAgID8gdGhpcy5fd2Vla2RheXNTaG9ydFttLmRheSgpXVxuICAgICAgICAgICAgOiB0aGlzLl93ZWVrZGF5c1Nob3J0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvY2FsZVdlZWtkYXlzTWluKG0pIHtcbiAgICAgICAgcmV0dXJuIG0gPT09IHRydWVcbiAgICAgICAgICAgID8gc2hpZnRXZWVrZGF5cyh0aGlzLl93ZWVrZGF5c01pbiwgdGhpcy5fd2Vlay5kb3cpXG4gICAgICAgICAgICA6IG1cbiAgICAgICAgICAgID8gdGhpcy5fd2Vla2RheXNNaW5bbS5kYXkoKV1cbiAgICAgICAgICAgIDogdGhpcy5fd2Vla2RheXNNaW47XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFuZGxlU3RyaWN0UGFyc2UkMSh3ZWVrZGF5TmFtZSwgZm9ybWF0LCBzdHJpY3QpIHtcbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgICBpaSxcbiAgICAgICAgICAgIG1vbSxcbiAgICAgICAgICAgIGxsYyA9IHdlZWtkYXlOYW1lLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmICghdGhpcy5fd2Vla2RheXNQYXJzZSkge1xuICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlID0gW107XG4gICAgICAgICAgICB0aGlzLl9taW5XZWVrZGF5c1BhcnNlID0gW107XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCA3OyArK2kpIHtcbiAgICAgICAgICAgICAgICBtb20gPSBjcmVhdGVVVEMoWzIwMDAsIDFdKS5kYXkoaSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbWluV2Vla2RheXNQYXJzZVtpXSA9IHRoaXMud2Vla2RheXNNaW4oXG4gICAgICAgICAgICAgICAgICAgIG1vbSxcbiAgICAgICAgICAgICAgICAgICAgJydcbiAgICAgICAgICAgICAgICApLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlW2ldID0gdGhpcy53ZWVrZGF5c1Nob3J0KFxuICAgICAgICAgICAgICAgICAgICBtb20sXG4gICAgICAgICAgICAgICAgICAgICcnXG4gICAgICAgICAgICAgICAgKS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzUGFyc2VbaV0gPSB0aGlzLndlZWtkYXlzKG1vbSwgJycpLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RyaWN0KSB7XG4gICAgICAgICAgICBpZiAoZm9ybWF0ID09PSAnZGRkZCcpIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl93ZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGZvcm1hdCA9PT0gJ2RkZCcpIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbWluV2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGZvcm1hdCA9PT0gJ2RkZGQnKSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fd2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9taW5XZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGZvcm1hdCA9PT0gJ2RkZCcpIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3dlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX21pbldlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbWluV2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fd2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVXZWVrZGF5c1BhcnNlKHdlZWtkYXlOYW1lLCBmb3JtYXQsIHN0cmljdCkge1xuICAgICAgICB2YXIgaSwgbW9tLCByZWdleDtcblxuICAgICAgICBpZiAodGhpcy5fd2Vla2RheXNQYXJzZUV4YWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlU3RyaWN0UGFyc2UkMS5jYWxsKHRoaXMsIHdlZWtkYXlOYW1lLCBmb3JtYXQsIHN0cmljdCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuX3dlZWtkYXlzUGFyc2UpIHtcbiAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX21pbldlZWtkYXlzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fZnVsbFdlZWtkYXlzUGFyc2UgPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCA3OyBpKyspIHtcbiAgICAgICAgICAgIC8vIG1ha2UgdGhlIHJlZ2V4IGlmIHdlIGRvbid0IGhhdmUgaXQgYWxyZWFkeVxuXG4gICAgICAgICAgICBtb20gPSBjcmVhdGVVVEMoWzIwMDAsIDFdKS5kYXkoaSk7XG4gICAgICAgICAgICBpZiAoc3RyaWN0ICYmICF0aGlzLl9mdWxsV2Vla2RheXNQYXJzZVtpXSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2Z1bGxXZWVrZGF5c1BhcnNlW2ldID0gbmV3IFJlZ0V4cChcbiAgICAgICAgICAgICAgICAgICAgJ14nICsgdGhpcy53ZWVrZGF5cyhtb20sICcnKS5yZXBsYWNlKCcuJywgJ1xcXFwuPycpICsgJyQnLFxuICAgICAgICAgICAgICAgICAgICAnaSdcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZVtpXSA9IG5ldyBSZWdFeHAoXG4gICAgICAgICAgICAgICAgICAgICdeJyArIHRoaXMud2Vla2RheXNTaG9ydChtb20sICcnKS5yZXBsYWNlKCcuJywgJ1xcXFwuPycpICsgJyQnLFxuICAgICAgICAgICAgICAgICAgICAnaSdcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHRoaXMuX21pbldlZWtkYXlzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKFxuICAgICAgICAgICAgICAgICAgICAnXicgKyB0aGlzLndlZWtkYXlzTWluKG1vbSwgJycpLnJlcGxhY2UoJy4nLCAnXFxcXC4/JykgKyAnJCcsXG4gICAgICAgICAgICAgICAgICAgICdpJ1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3dlZWtkYXlzUGFyc2VbaV0pIHtcbiAgICAgICAgICAgICAgICByZWdleCA9XG4gICAgICAgICAgICAgICAgICAgICdeJyArXG4gICAgICAgICAgICAgICAgICAgIHRoaXMud2Vla2RheXMobW9tLCAnJykgK1xuICAgICAgICAgICAgICAgICAgICAnfF4nICtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy53ZWVrZGF5c1Nob3J0KG1vbSwgJycpICtcbiAgICAgICAgICAgICAgICAgICAgJ3xeJyArXG4gICAgICAgICAgICAgICAgICAgIHRoaXMud2Vla2RheXNNaW4obW9tLCAnJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNQYXJzZVtpXSA9IG5ldyBSZWdFeHAocmVnZXgucmVwbGFjZSgnLicsICcnKSwgJ2knKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRlc3QgdGhlIHJlZ2V4XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgc3RyaWN0ICYmXG4gICAgICAgICAgICAgICAgZm9ybWF0ID09PSAnZGRkZCcgJiZcbiAgICAgICAgICAgICAgICB0aGlzLl9mdWxsV2Vla2RheXNQYXJzZVtpXS50ZXN0KHdlZWtkYXlOYW1lKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICAgIHN0cmljdCAmJlxuICAgICAgICAgICAgICAgIGZvcm1hdCA9PT0gJ2RkZCcgJiZcbiAgICAgICAgICAgICAgICB0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2VbaV0udGVzdCh3ZWVrZGF5TmFtZSlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICAgICBzdHJpY3QgJiZcbiAgICAgICAgICAgICAgICBmb3JtYXQgPT09ICdkZCcgJiZcbiAgICAgICAgICAgICAgICB0aGlzLl9taW5XZWVrZGF5c1BhcnNlW2ldLnRlc3Qod2Vla2RheU5hbWUpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIXN0cmljdCAmJiB0aGlzLl93ZWVrZGF5c1BhcnNlW2ldLnRlc3Qod2Vla2RheU5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBnZXRTZXREYXlPZldlZWsoaW5wdXQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0ICE9IG51bGwgPyB0aGlzIDogTmFOO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkYXkgPSB0aGlzLl9pc1VUQyA/IHRoaXMuX2QuZ2V0VVRDRGF5KCkgOiB0aGlzLl9kLmdldERheSgpO1xuICAgICAgICBpZiAoaW5wdXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgaW5wdXQgPSBwYXJzZVdlZWtkYXkoaW5wdXQsIHRoaXMubG9jYWxlRGF0YSgpKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZChpbnB1dCAtIGRheSwgJ2QnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBkYXk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTZXRMb2NhbGVEYXlPZldlZWsoaW5wdXQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0ICE9IG51bGwgPyB0aGlzIDogTmFOO1xuICAgICAgICB9XG4gICAgICAgIHZhciB3ZWVrZGF5ID0gKHRoaXMuZGF5KCkgKyA3IC0gdGhpcy5sb2NhbGVEYXRhKCkuX3dlZWsuZG93KSAlIDc7XG4gICAgICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gd2Vla2RheSA6IHRoaXMuYWRkKGlucHV0IC0gd2Vla2RheSwgJ2QnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTZXRJU09EYXlPZldlZWsoaW5wdXQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0ICE9IG51bGwgPyB0aGlzIDogTmFOO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYmVoYXZlcyB0aGUgc2FtZSBhcyBtb21lbnQjZGF5IGV4Y2VwdFxuICAgICAgICAvLyBhcyBhIGdldHRlciwgcmV0dXJucyA3IGluc3RlYWQgb2YgMCAoMS03IHJhbmdlIGluc3RlYWQgb2YgMC02KVxuICAgICAgICAvLyBhcyBhIHNldHRlciwgc3VuZGF5IHNob3VsZCBiZWxvbmcgdG8gdGhlIHByZXZpb3VzIHdlZWsuXG5cbiAgICAgICAgaWYgKGlucHV0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHZhciB3ZWVrZGF5ID0gcGFyc2VJc29XZWVrZGF5KGlucHV0LCB0aGlzLmxvY2FsZURhdGEoKSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXkodGhpcy5kYXkoKSAlIDcgPyB3ZWVrZGF5IDogd2Vla2RheSAtIDcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF5KCkgfHwgNztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdlZWtkYXlzUmVnZXgoaXNTdHJpY3QpIHtcbiAgICAgICAgaWYgKHRoaXMuX3dlZWtkYXlzUGFyc2VFeGFjdCkge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfd2Vla2RheXNSZWdleCcpKSB7XG4gICAgICAgICAgICAgICAgY29tcHV0ZVdlZWtkYXlzUGFyc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1N0cmljdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1N0cmljdFJlZ2V4O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNSZWdleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX3dlZWtkYXlzUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzUmVnZXggPSBkZWZhdWx0V2Vla2RheXNSZWdleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1N0cmljdFJlZ2V4ICYmIGlzU3RyaWN0XG4gICAgICAgICAgICAgICAgPyB0aGlzLl93ZWVrZGF5c1N0cmljdFJlZ2V4XG4gICAgICAgICAgICAgICAgOiB0aGlzLl93ZWVrZGF5c1JlZ2V4O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gd2Vla2RheXNTaG9ydFJlZ2V4KGlzU3RyaWN0KSB7XG4gICAgICAgIGlmICh0aGlzLl93ZWVrZGF5c1BhcnNlRXhhY3QpIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX3dlZWtkYXlzUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIGNvbXB1dGVXZWVrZGF5c1BhcnNlLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNTdHJpY3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNTaG9ydFN0cmljdFJlZ2V4O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNTaG9ydFJlZ2V4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfd2Vla2RheXNTaG9ydFJlZ2V4JykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1Nob3J0UmVnZXggPSBkZWZhdWx0V2Vla2RheXNTaG9ydFJlZ2V4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzU2hvcnRTdHJpY3RSZWdleCAmJiBpc1N0cmljdFxuICAgICAgICAgICAgICAgID8gdGhpcy5fd2Vla2RheXNTaG9ydFN0cmljdFJlZ2V4XG4gICAgICAgICAgICAgICAgOiB0aGlzLl93ZWVrZGF5c1Nob3J0UmVnZXg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB3ZWVrZGF5c01pblJlZ2V4KGlzU3RyaWN0KSB7XG4gICAgICAgIGlmICh0aGlzLl93ZWVrZGF5c1BhcnNlRXhhY3QpIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX3dlZWtkYXlzUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIGNvbXB1dGVXZWVrZGF5c1BhcnNlLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNTdHJpY3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNNaW5TdHJpY3RSZWdleDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzTWluUmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ193ZWVrZGF5c01pblJlZ2V4JykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl93ZWVrZGF5c01pblJlZ2V4ID0gZGVmYXVsdFdlZWtkYXlzTWluUmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNNaW5TdHJpY3RSZWdleCAmJiBpc1N0cmljdFxuICAgICAgICAgICAgICAgID8gdGhpcy5fd2Vla2RheXNNaW5TdHJpY3RSZWdleFxuICAgICAgICAgICAgICAgIDogdGhpcy5fd2Vla2RheXNNaW5SZWdleDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbXB1dGVXZWVrZGF5c1BhcnNlKCkge1xuICAgICAgICBmdW5jdGlvbiBjbXBMZW5SZXYoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGIubGVuZ3RoIC0gYS5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbWluUGllY2VzID0gW10sXG4gICAgICAgICAgICBzaG9ydFBpZWNlcyA9IFtdLFxuICAgICAgICAgICAgbG9uZ1BpZWNlcyA9IFtdLFxuICAgICAgICAgICAgbWl4ZWRQaWVjZXMgPSBbXSxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBtb20sXG4gICAgICAgICAgICBtaW5wLFxuICAgICAgICAgICAgc2hvcnRwLFxuICAgICAgICAgICAgbG9uZ3A7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCA3OyBpKyspIHtcbiAgICAgICAgICAgIC8vIG1ha2UgdGhlIHJlZ2V4IGlmIHdlIGRvbid0IGhhdmUgaXQgYWxyZWFkeVxuICAgICAgICAgICAgbW9tID0gY3JlYXRlVVRDKFsyMDAwLCAxXSkuZGF5KGkpO1xuICAgICAgICAgICAgbWlucCA9IHJlZ2V4RXNjYXBlKHRoaXMud2Vla2RheXNNaW4obW9tLCAnJykpO1xuICAgICAgICAgICAgc2hvcnRwID0gcmVnZXhFc2NhcGUodGhpcy53ZWVrZGF5c1Nob3J0KG1vbSwgJycpKTtcbiAgICAgICAgICAgIGxvbmdwID0gcmVnZXhFc2NhcGUodGhpcy53ZWVrZGF5cyhtb20sICcnKSk7XG4gICAgICAgICAgICBtaW5QaWVjZXMucHVzaChtaW5wKTtcbiAgICAgICAgICAgIHNob3J0UGllY2VzLnB1c2goc2hvcnRwKTtcbiAgICAgICAgICAgIGxvbmdQaWVjZXMucHVzaChsb25ncCk7XG4gICAgICAgICAgICBtaXhlZFBpZWNlcy5wdXNoKG1pbnApO1xuICAgICAgICAgICAgbWl4ZWRQaWVjZXMucHVzaChzaG9ydHApO1xuICAgICAgICAgICAgbWl4ZWRQaWVjZXMucHVzaChsb25ncCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU29ydGluZyBtYWtlcyBzdXJlIGlmIG9uZSB3ZWVrZGF5IChvciBhYmJyKSBpcyBhIHByZWZpeCBvZiBhbm90aGVyIGl0XG4gICAgICAgIC8vIHdpbGwgbWF0Y2ggdGhlIGxvbmdlciBwaWVjZS5cbiAgICAgICAgbWluUGllY2VzLnNvcnQoY21wTGVuUmV2KTtcbiAgICAgICAgc2hvcnRQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgICAgICBsb25nUGllY2VzLnNvcnQoY21wTGVuUmV2KTtcbiAgICAgICAgbWl4ZWRQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuXG4gICAgICAgIHRoaXMuX3dlZWtkYXlzUmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBtaXhlZFBpZWNlcy5qb2luKCd8JykgKyAnKScsICdpJyk7XG4gICAgICAgIHRoaXMuX3dlZWtkYXlzU2hvcnRSZWdleCA9IHRoaXMuX3dlZWtkYXlzUmVnZXg7XG4gICAgICAgIHRoaXMuX3dlZWtkYXlzTWluUmVnZXggPSB0aGlzLl93ZWVrZGF5c1JlZ2V4O1xuXG4gICAgICAgIHRoaXMuX3dlZWtkYXlzU3RyaWN0UmVnZXggPSBuZXcgUmVnRXhwKFxuICAgICAgICAgICAgJ14oJyArIGxvbmdQaWVjZXMuam9pbignfCcpICsgJyknLFxuICAgICAgICAgICAgJ2knXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuX3dlZWtkYXlzU2hvcnRTdHJpY3RSZWdleCA9IG5ldyBSZWdFeHAoXG4gICAgICAgICAgICAnXignICsgc2hvcnRQaWVjZXMuam9pbignfCcpICsgJyknLFxuICAgICAgICAgICAgJ2knXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuX3dlZWtkYXlzTWluU3RyaWN0UmVnZXggPSBuZXcgUmVnRXhwKFxuICAgICAgICAgICAgJ14oJyArIG1pblBpZWNlcy5qb2luKCd8JykgKyAnKScsXG4gICAgICAgICAgICAnaSdcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBmdW5jdGlvbiBoRm9ybWF0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ob3VycygpICUgMTIgfHwgMTI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24ga0Zvcm1hdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaG91cnMoKSB8fCAyNDtcbiAgICB9XG5cbiAgICBhZGRGb3JtYXRUb2tlbignSCcsIFsnSEgnLCAyXSwgMCwgJ2hvdXInKTtcbiAgICBhZGRGb3JtYXRUb2tlbignaCcsIFsnaGgnLCAyXSwgMCwgaEZvcm1hdCk7XG4gICAgYWRkRm9ybWF0VG9rZW4oJ2snLCBbJ2trJywgMl0sIDAsIGtGb3JtYXQpO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ2htbScsIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICcnICsgaEZvcm1hdC5hcHBseSh0aGlzKSArIHplcm9GaWxsKHRoaXMubWludXRlcygpLCAyKTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdobW1zcycsIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICcnICtcbiAgICAgICAgICAgIGhGb3JtYXQuYXBwbHkodGhpcykgK1xuICAgICAgICAgICAgemVyb0ZpbGwodGhpcy5taW51dGVzKCksIDIpICtcbiAgICAgICAgICAgIHplcm9GaWxsKHRoaXMuc2Vjb25kcygpLCAyKVxuICAgICAgICApO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ0htbScsIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICcnICsgdGhpcy5ob3VycygpICsgemVyb0ZpbGwodGhpcy5taW51dGVzKCksIDIpO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ0htbXNzJywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgJycgK1xuICAgICAgICAgICAgdGhpcy5ob3VycygpICtcbiAgICAgICAgICAgIHplcm9GaWxsKHRoaXMubWludXRlcygpLCAyKSArXG4gICAgICAgICAgICB6ZXJvRmlsbCh0aGlzLnNlY29uZHMoKSwgMilcbiAgICAgICAgKTtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIG1lcmlkaWVtKHRva2VuLCBsb3dlcmNhc2UpIHtcbiAgICAgICAgYWRkRm9ybWF0VG9rZW4odG9rZW4sIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5tZXJpZGllbShcbiAgICAgICAgICAgICAgICB0aGlzLmhvdXJzKCksXG4gICAgICAgICAgICAgICAgdGhpcy5taW51dGVzKCksXG4gICAgICAgICAgICAgICAgbG93ZXJjYXNlXG4gICAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBtZXJpZGllbSgnYScsIHRydWUpO1xuICAgIG1lcmlkaWVtKCdBJywgZmFsc2UpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdob3VyJywgJ2gnKTtcblxuICAgIC8vIFBSSU9SSVRZXG4gICAgYWRkVW5pdFByaW9yaXR5KCdob3VyJywgMTMpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgZnVuY3Rpb24gbWF0Y2hNZXJpZGllbShpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUuX21lcmlkaWVtUGFyc2U7XG4gICAgfVxuXG4gICAgYWRkUmVnZXhUb2tlbignYScsIG1hdGNoTWVyaWRpZW0pO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0EnLCBtYXRjaE1lcmlkaWVtKTtcbiAgICBhZGRSZWdleFRva2VuKCdIJywgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdoJywgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdrJywgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdISCcsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdoaCcsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdraycsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ2htbScsIG1hdGNoM3RvNCk7XG4gICAgYWRkUmVnZXhUb2tlbignaG1tc3MnLCBtYXRjaDV0bzYpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0htbScsIG1hdGNoM3RvNCk7XG4gICAgYWRkUmVnZXhUb2tlbignSG1tc3MnLCBtYXRjaDV0bzYpO1xuXG4gICAgYWRkUGFyc2VUb2tlbihbJ0gnLCAnSEgnXSwgSE9VUik7XG4gICAgYWRkUGFyc2VUb2tlbihbJ2snLCAna2snXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIHZhciBrSW5wdXQgPSB0b0ludChpbnB1dCk7XG4gICAgICAgIGFycmF5W0hPVVJdID0ga0lucHV0ID09PSAyNCA/IDAgOiBrSW5wdXQ7XG4gICAgfSk7XG4gICAgYWRkUGFyc2VUb2tlbihbJ2EnLCAnQSddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgY29uZmlnLl9pc1BtID0gY29uZmlnLl9sb2NhbGUuaXNQTShpbnB1dCk7XG4gICAgICAgIGNvbmZpZy5fbWVyaWRpZW0gPSBpbnB1dDtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKFsnaCcsICdoaCddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgYXJyYXlbSE9VUl0gPSB0b0ludChpbnB1dCk7XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmJpZ0hvdXIgPSB0cnVlO1xuICAgIH0pO1xuICAgIGFkZFBhcnNlVG9rZW4oJ2htbScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICB2YXIgcG9zID0gaW5wdXQubGVuZ3RoIC0gMjtcbiAgICAgICAgYXJyYXlbSE9VUl0gPSB0b0ludChpbnB1dC5zdWJzdHIoMCwgcG9zKSk7XG4gICAgICAgIGFycmF5W01JTlVURV0gPSB0b0ludChpbnB1dC5zdWJzdHIocG9zKSk7XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmJpZ0hvdXIgPSB0cnVlO1xuICAgIH0pO1xuICAgIGFkZFBhcnNlVG9rZW4oJ2htbXNzJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIHZhciBwb3MxID0gaW5wdXQubGVuZ3RoIC0gNCxcbiAgICAgICAgICAgIHBvczIgPSBpbnB1dC5sZW5ndGggLSAyO1xuICAgICAgICBhcnJheVtIT1VSXSA9IHRvSW50KGlucHV0LnN1YnN0cigwLCBwb3MxKSk7XG4gICAgICAgIGFycmF5W01JTlVURV0gPSB0b0ludChpbnB1dC5zdWJzdHIocG9zMSwgMikpO1xuICAgICAgICBhcnJheVtTRUNPTkRdID0gdG9JbnQoaW5wdXQuc3Vic3RyKHBvczIpKTtcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuYmlnSG91ciA9IHRydWU7XG4gICAgfSk7XG4gICAgYWRkUGFyc2VUb2tlbignSG1tJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIHZhciBwb3MgPSBpbnB1dC5sZW5ndGggLSAyO1xuICAgICAgICBhcnJheVtIT1VSXSA9IHRvSW50KGlucHV0LnN1YnN0cigwLCBwb3MpKTtcbiAgICAgICAgYXJyYXlbTUlOVVRFXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MpKTtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKCdIbW1zcycsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICB2YXIgcG9zMSA9IGlucHV0Lmxlbmd0aCAtIDQsXG4gICAgICAgICAgICBwb3MyID0gaW5wdXQubGVuZ3RoIC0gMjtcbiAgICAgICAgYXJyYXlbSE9VUl0gPSB0b0ludChpbnB1dC5zdWJzdHIoMCwgcG9zMSkpO1xuICAgICAgICBhcnJheVtNSU5VVEVdID0gdG9JbnQoaW5wdXQuc3Vic3RyKHBvczEsIDIpKTtcbiAgICAgICAgYXJyYXlbU0VDT05EXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MyKSk7XG4gICAgfSk7XG5cbiAgICAvLyBMT0NBTEVTXG5cbiAgICBmdW5jdGlvbiBsb2NhbGVJc1BNKGlucHV0KSB7XG4gICAgICAgIC8vIElFOCBRdWlya3MgTW9kZSAmIElFNyBTdGFuZGFyZHMgTW9kZSBkbyBub3QgYWxsb3cgYWNjZXNzaW5nIHN0cmluZ3MgbGlrZSBhcnJheXNcbiAgICAgICAgLy8gVXNpbmcgY2hhckF0IHNob3VsZCBiZSBtb3JlIGNvbXBhdGlibGUuXG4gICAgICAgIHJldHVybiAoaW5wdXQgKyAnJykudG9Mb3dlckNhc2UoKS5jaGFyQXQoMCkgPT09ICdwJztcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdExvY2FsZU1lcmlkaWVtUGFyc2UgPSAvW2FwXVxcLj9tP1xcLj8vaSxcbiAgICAgICAgLy8gU2V0dGluZyB0aGUgaG91ciBzaG91bGQga2VlcCB0aGUgdGltZSwgYmVjYXVzZSB0aGUgdXNlciBleHBsaWNpdGx5XG4gICAgICAgIC8vIHNwZWNpZmllZCB3aGljaCBob3VyIHRoZXkgd2FudC4gU28gdHJ5aW5nIHRvIG1haW50YWluIHRoZSBzYW1lIGhvdXIgKGluXG4gICAgICAgIC8vIGEgbmV3IHRpbWV6b25lKSBtYWtlcyBzZW5zZS4gQWRkaW5nL3N1YnRyYWN0aW5nIGhvdXJzIGRvZXMgbm90IGZvbGxvd1xuICAgICAgICAvLyB0aGlzIHJ1bGUuXG4gICAgICAgIGdldFNldEhvdXIgPSBtYWtlR2V0U2V0KCdIb3VycycsIHRydWUpO1xuXG4gICAgZnVuY3Rpb24gbG9jYWxlTWVyaWRpZW0oaG91cnMsIG1pbnV0ZXMsIGlzTG93ZXIpIHtcbiAgICAgICAgaWYgKGhvdXJzID4gMTEpIHtcbiAgICAgICAgICAgIHJldHVybiBpc0xvd2VyID8gJ3BtJyA6ICdQTSc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gaXNMb3dlciA/ICdhbScgOiAnQU0nO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGJhc2VDb25maWcgPSB7XG4gICAgICAgIGNhbGVuZGFyOiBkZWZhdWx0Q2FsZW5kYXIsXG4gICAgICAgIGxvbmdEYXRlRm9ybWF0OiBkZWZhdWx0TG9uZ0RhdGVGb3JtYXQsXG4gICAgICAgIGludmFsaWREYXRlOiBkZWZhdWx0SW52YWxpZERhdGUsXG4gICAgICAgIG9yZGluYWw6IGRlZmF1bHRPcmRpbmFsLFxuICAgICAgICBkYXlPZk1vbnRoT3JkaW5hbFBhcnNlOiBkZWZhdWx0RGF5T2ZNb250aE9yZGluYWxQYXJzZSxcbiAgICAgICAgcmVsYXRpdmVUaW1lOiBkZWZhdWx0UmVsYXRpdmVUaW1lLFxuXG4gICAgICAgIG1vbnRoczogZGVmYXVsdExvY2FsZU1vbnRocyxcbiAgICAgICAgbW9udGhzU2hvcnQ6IGRlZmF1bHRMb2NhbGVNb250aHNTaG9ydCxcblxuICAgICAgICB3ZWVrOiBkZWZhdWx0TG9jYWxlV2VlayxcblxuICAgICAgICB3ZWVrZGF5czogZGVmYXVsdExvY2FsZVdlZWtkYXlzLFxuICAgICAgICB3ZWVrZGF5c01pbjogZGVmYXVsdExvY2FsZVdlZWtkYXlzTWluLFxuICAgICAgICB3ZWVrZGF5c1Nob3J0OiBkZWZhdWx0TG9jYWxlV2Vla2RheXNTaG9ydCxcblxuICAgICAgICBtZXJpZGllbVBhcnNlOiBkZWZhdWx0TG9jYWxlTWVyaWRpZW1QYXJzZSxcbiAgICB9O1xuXG4gICAgLy8gaW50ZXJuYWwgc3RvcmFnZSBmb3IgbG9jYWxlIGNvbmZpZyBmaWxlc1xuICAgIHZhciBsb2NhbGVzID0ge30sXG4gICAgICAgIGxvY2FsZUZhbWlsaWVzID0ge30sXG4gICAgICAgIGdsb2JhbExvY2FsZTtcblxuICAgIGZ1bmN0aW9uIGNvbW1vblByZWZpeChhcnIxLCBhcnIyKSB7XG4gICAgICAgIHZhciBpLFxuICAgICAgICAgICAgbWlubCA9IE1hdGgubWluKGFycjEubGVuZ3RoLCBhcnIyLmxlbmd0aCk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBtaW5sOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGlmIChhcnIxW2ldICE9PSBhcnIyW2ldKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1pbmw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbm9ybWFsaXplTG9jYWxlKGtleSkge1xuICAgICAgICByZXR1cm4ga2V5ID8ga2V5LnRvTG93ZXJDYXNlKCkucmVwbGFjZSgnXycsICctJykgOiBrZXk7XG4gICAgfVxuXG4gICAgLy8gcGljayB0aGUgbG9jYWxlIGZyb20gdGhlIGFycmF5XG4gICAgLy8gdHJ5IFsnZW4tYXUnLCAnZW4tZ2InXSBhcyAnZW4tYXUnLCAnZW4tZ2InLCAnZW4nLCBhcyBpbiBtb3ZlIHRocm91Z2ggdGhlIGxpc3QgdHJ5aW5nIGVhY2hcbiAgICAvLyBzdWJzdHJpbmcgZnJvbSBtb3N0IHNwZWNpZmljIHRvIGxlYXN0LCBidXQgbW92ZSB0byB0aGUgbmV4dCBhcnJheSBpdGVtIGlmIGl0J3MgYSBtb3JlIHNwZWNpZmljIHZhcmlhbnQgdGhhbiB0aGUgY3VycmVudCByb290XG4gICAgZnVuY3Rpb24gY2hvb3NlTG9jYWxlKG5hbWVzKSB7XG4gICAgICAgIHZhciBpID0gMCxcbiAgICAgICAgICAgIGosXG4gICAgICAgICAgICBuZXh0LFxuICAgICAgICAgICAgbG9jYWxlLFxuICAgICAgICAgICAgc3BsaXQ7XG5cbiAgICAgICAgd2hpbGUgKGkgPCBuYW1lcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHNwbGl0ID0gbm9ybWFsaXplTG9jYWxlKG5hbWVzW2ldKS5zcGxpdCgnLScpO1xuICAgICAgICAgICAgaiA9IHNwbGl0Lmxlbmd0aDtcbiAgICAgICAgICAgIG5leHQgPSBub3JtYWxpemVMb2NhbGUobmFtZXNbaSArIDFdKTtcbiAgICAgICAgICAgIG5leHQgPSBuZXh0ID8gbmV4dC5zcGxpdCgnLScpIDogbnVsbDtcbiAgICAgICAgICAgIHdoaWxlIChqID4gMCkge1xuICAgICAgICAgICAgICAgIGxvY2FsZSA9IGxvYWRMb2NhbGUoc3BsaXQuc2xpY2UoMCwgaikuam9pbignLScpKTtcbiAgICAgICAgICAgICAgICBpZiAobG9jYWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsb2NhbGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgbmV4dCAmJlxuICAgICAgICAgICAgICAgICAgICBuZXh0Lmxlbmd0aCA+PSBqICYmXG4gICAgICAgICAgICAgICAgICAgIGNvbW1vblByZWZpeChzcGxpdCwgbmV4dCkgPj0gaiAtIDFcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgLy90aGUgbmV4dCBhcnJheSBpdGVtIGlzIGJldHRlciB0aGFuIGEgc2hhbGxvd2VyIHN1YnN0cmluZyBvZiB0aGlzIG9uZVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgai0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnbG9iYWxMb2NhbGU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNMb2NhbGVOYW1lU2FuZShuYW1lKSB7XG4gICAgICAgIC8vIFByZXZlbnQgbmFtZXMgdGhhdCBsb29rIGxpa2UgZmlsZXN5c3RlbSBwYXRocywgaS5lIGNvbnRhaW4gJy8nIG9yICdcXCdcbiAgICAgICAgcmV0dXJuIG5hbWUubWF0Y2goJ15bXi9cXFxcXFxcXF0qJCcpICE9IG51bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9hZExvY2FsZShuYW1lKSB7XG4gICAgICAgIHZhciBvbGRMb2NhbGUgPSBudWxsLFxuICAgICAgICAgICAgYWxpYXNlZFJlcXVpcmU7XG4gICAgICAgIC8vIFRPRE86IEZpbmQgYSBiZXR0ZXIgd2F5IHRvIHJlZ2lzdGVyIGFuZCBsb2FkIGFsbCB0aGUgbG9jYWxlcyBpbiBOb2RlXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIGxvY2FsZXNbbmFtZV0gPT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgIG1vZHVsZSAmJlxuICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgJiZcbiAgICAgICAgICAgIGlzTG9jYWxlTmFtZVNhbmUobmFtZSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIG9sZExvY2FsZSA9IGdsb2JhbExvY2FsZS5fYWJicjtcbiAgICAgICAgICAgICAgICBhbGlhc2VkUmVxdWlyZSA9IHJlcXVpcmU7XG4gICAgICAgICAgICAgICAgYWxpYXNlZFJlcXVpcmUoJy4vbG9jYWxlLycgKyBuYW1lKTtcbiAgICAgICAgICAgICAgICBnZXRTZXRHbG9iYWxMb2NhbGUob2xkTG9jYWxlKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAvLyBtYXJrIGFzIG5vdCBmb3VuZCB0byBhdm9pZCByZXBlYXRpbmcgZXhwZW5zaXZlIGZpbGUgcmVxdWlyZSBjYWxsIGNhdXNpbmcgaGlnaCBDUFVcbiAgICAgICAgICAgICAgICAvLyB3aGVuIHRyeWluZyB0byBmaW5kIGVuLVVTLCBlbl9VUywgZW4tdXMgZm9yIGV2ZXJ5IGZvcm1hdCBjYWxsXG4gICAgICAgICAgICAgICAgbG9jYWxlc1tuYW1lXSA9IG51bGw7IC8vIG51bGwgbWVhbnMgbm90IGZvdW5kXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvY2FsZXNbbmFtZV07XG4gICAgfVxuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiB3aWxsIGxvYWQgbG9jYWxlIGFuZCB0aGVuIHNldCB0aGUgZ2xvYmFsIGxvY2FsZS4gIElmXG4gICAgLy8gbm8gYXJndW1lbnRzIGFyZSBwYXNzZWQgaW4sIGl0IHdpbGwgc2ltcGx5IHJldHVybiB0aGUgY3VycmVudCBnbG9iYWxcbiAgICAvLyBsb2NhbGUga2V5LlxuICAgIGZ1bmN0aW9uIGdldFNldEdsb2JhbExvY2FsZShrZXksIHZhbHVlcykge1xuICAgICAgICB2YXIgZGF0YTtcbiAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgICAgaWYgKGlzVW5kZWZpbmVkKHZhbHVlcykpIHtcbiAgICAgICAgICAgICAgICBkYXRhID0gZ2V0TG9jYWxlKGtleSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBkZWZpbmVMb2NhbGUoa2V5LCB2YWx1ZXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgICAgICAgIC8vIG1vbWVudC5kdXJhdGlvbi5fbG9jYWxlID0gbW9tZW50Ll9sb2NhbGUgPSBkYXRhO1xuICAgICAgICAgICAgICAgIGdsb2JhbExvY2FsZSA9IGRhdGE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiYgY29uc29sZS53YXJuKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vd2FybiB1c2VyIGlmIGFyZ3VtZW50cyBhcmUgcGFzc2VkIGJ1dCB0aGUgbG9jYWxlIGNvdWxkIG5vdCBiZSBzZXRcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0xvY2FsZSAnICsga2V5ICsgJyBub3QgZm91bmQuIERpZCB5b3UgZm9yZ2V0IHRvIGxvYWQgaXQ/J1xuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBnbG9iYWxMb2NhbGUuX2FiYnI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVmaW5lTG9jYWxlKG5hbWUsIGNvbmZpZykge1xuICAgICAgICBpZiAoY29uZmlnICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgbG9jYWxlLFxuICAgICAgICAgICAgICAgIHBhcmVudENvbmZpZyA9IGJhc2VDb25maWc7XG4gICAgICAgICAgICBjb25maWcuYWJiciA9IG5hbWU7XG4gICAgICAgICAgICBpZiAobG9jYWxlc1tuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZGVwcmVjYXRlU2ltcGxlKFxuICAgICAgICAgICAgICAgICAgICAnZGVmaW5lTG9jYWxlT3ZlcnJpZGUnLFxuICAgICAgICAgICAgICAgICAgICAndXNlIG1vbWVudC51cGRhdGVMb2NhbGUobG9jYWxlTmFtZSwgY29uZmlnKSB0byBjaGFuZ2UgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnYW4gZXhpc3RpbmcgbG9jYWxlLiBtb21lbnQuZGVmaW5lTG9jYWxlKGxvY2FsZU5hbWUsICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2NvbmZpZykgc2hvdWxkIG9ubHkgYmUgdXNlZCBmb3IgY3JlYXRpbmcgYSBuZXcgbG9jYWxlICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ1NlZSBodHRwOi8vbW9tZW50anMuY29tL2d1aWRlcy8jL3dhcm5pbmdzL2RlZmluZS1sb2NhbGUvIGZvciBtb3JlIGluZm8uJ1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgcGFyZW50Q29uZmlnID0gbG9jYWxlc1tuYW1lXS5fY29uZmlnO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjb25maWcucGFyZW50TG9jYWxlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAobG9jYWxlc1tjb25maWcucGFyZW50TG9jYWxlXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudENvbmZpZyA9IGxvY2FsZXNbY29uZmlnLnBhcmVudExvY2FsZV0uX2NvbmZpZztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsb2NhbGUgPSBsb2FkTG9jYWxlKGNvbmZpZy5wYXJlbnRMb2NhbGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobG9jYWxlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudENvbmZpZyA9IGxvY2FsZS5fY29uZmlnO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFsb2NhbGVGYW1pbGllc1tjb25maWcucGFyZW50TG9jYWxlXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsZUZhbWlsaWVzW2NvbmZpZy5wYXJlbnRMb2NhbGVdID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbGVGYW1pbGllc1tjb25maWcucGFyZW50TG9jYWxlXS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZzogY29uZmlnLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvY2FsZXNbbmFtZV0gPSBuZXcgTG9jYWxlKG1lcmdlQ29uZmlncyhwYXJlbnRDb25maWcsIGNvbmZpZykpO1xuXG4gICAgICAgICAgICBpZiAobG9jYWxlRmFtaWxpZXNbbmFtZV0pIHtcbiAgICAgICAgICAgICAgICBsb2NhbGVGYW1pbGllc1tuYW1lXS5mb3JFYWNoKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICAgICAgICAgIGRlZmluZUxvY2FsZSh4Lm5hbWUsIHguY29uZmlnKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gYmFja3dhcmRzIGNvbXBhdCBmb3Igbm93OiBhbHNvIHNldCB0aGUgbG9jYWxlXG4gICAgICAgICAgICAvLyBtYWtlIHN1cmUgd2Ugc2V0IHRoZSBsb2NhbGUgQUZURVIgYWxsIGNoaWxkIGxvY2FsZXMgaGF2ZSBiZWVuXG4gICAgICAgICAgICAvLyBjcmVhdGVkLCBzbyB3ZSB3b24ndCBlbmQgdXAgd2l0aCB0aGUgY2hpbGQgbG9jYWxlIHNldC5cbiAgICAgICAgICAgIGdldFNldEdsb2JhbExvY2FsZShuYW1lKTtcblxuICAgICAgICAgICAgcmV0dXJuIGxvY2FsZXNbbmFtZV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyB1c2VmdWwgZm9yIHRlc3RpbmdcbiAgICAgICAgICAgIGRlbGV0ZSBsb2NhbGVzW25hbWVdO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1cGRhdGVMb2NhbGUobmFtZSwgY29uZmlnKSB7XG4gICAgICAgIGlmIChjb25maWcgIT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIGxvY2FsZSxcbiAgICAgICAgICAgICAgICB0bXBMb2NhbGUsXG4gICAgICAgICAgICAgICAgcGFyZW50Q29uZmlnID0gYmFzZUNvbmZpZztcblxuICAgICAgICAgICAgaWYgKGxvY2FsZXNbbmFtZV0gIT0gbnVsbCAmJiBsb2NhbGVzW25hbWVdLnBhcmVudExvY2FsZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIGV4aXN0aW5nIGNoaWxkIGxvY2FsZSBpbi1wbGFjZSB0byBhdm9pZCBtZW1vcnktbGVha3NcbiAgICAgICAgICAgICAgICBsb2NhbGVzW25hbWVdLnNldChtZXJnZUNvbmZpZ3MobG9jYWxlc1tuYW1lXS5fY29uZmlnLCBjb25maWcpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gTUVSR0VcbiAgICAgICAgICAgICAgICB0bXBMb2NhbGUgPSBsb2FkTG9jYWxlKG5hbWUpO1xuICAgICAgICAgICAgICAgIGlmICh0bXBMb2NhbGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnRDb25maWcgPSB0bXBMb2NhbGUuX2NvbmZpZztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uZmlnID0gbWVyZ2VDb25maWdzKHBhcmVudENvbmZpZywgY29uZmlnKTtcbiAgICAgICAgICAgICAgICBpZiAodG1wTG9jYWxlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdXBkYXRlTG9jYWxlIGlzIGNhbGxlZCBmb3IgY3JlYXRpbmcgYSBuZXcgbG9jYWxlXG4gICAgICAgICAgICAgICAgICAgIC8vIFNldCBhYmJyIHNvIGl0IHdpbGwgaGF2ZSBhIG5hbWUgKGdldHRlcnMgcmV0dXJuXG4gICAgICAgICAgICAgICAgICAgIC8vIHVuZGVmaW5lZCBvdGhlcndpc2UpLlxuICAgICAgICAgICAgICAgICAgICBjb25maWcuYWJiciA9IG5hbWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxvY2FsZSA9IG5ldyBMb2NhbGUoY29uZmlnKTtcbiAgICAgICAgICAgICAgICBsb2NhbGUucGFyZW50TG9jYWxlID0gbG9jYWxlc1tuYW1lXTtcbiAgICAgICAgICAgICAgICBsb2NhbGVzW25hbWVdID0gbG9jYWxlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBiYWNrd2FyZHMgY29tcGF0IGZvciBub3c6IGFsc28gc2V0IHRoZSBsb2NhbGVcbiAgICAgICAgICAgIGdldFNldEdsb2JhbExvY2FsZShuYW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHBhc3MgbnVsbCBmb3IgY29uZmlnIHRvIHVudXBkYXRlLCB1c2VmdWwgZm9yIHRlc3RzXG4gICAgICAgICAgICBpZiAobG9jYWxlc1tuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxvY2FsZXNbbmFtZV0ucGFyZW50TG9jYWxlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxlc1tuYW1lXSA9IGxvY2FsZXNbbmFtZV0ucGFyZW50TG9jYWxlO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmFtZSA9PT0gZ2V0U2V0R2xvYmFsTG9jYWxlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldFNldEdsb2JhbExvY2FsZShuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobG9jYWxlc1tuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBsb2NhbGVzW25hbWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbG9jYWxlc1tuYW1lXTtcbiAgICB9XG5cbiAgICAvLyByZXR1cm5zIGxvY2FsZSBkYXRhXG4gICAgZnVuY3Rpb24gZ2V0TG9jYWxlKGtleSkge1xuICAgICAgICB2YXIgbG9jYWxlO1xuXG4gICAgICAgIGlmIChrZXkgJiYga2V5Ll9sb2NhbGUgJiYga2V5Ll9sb2NhbGUuX2FiYnIpIHtcbiAgICAgICAgICAgIGtleSA9IGtleS5fbG9jYWxlLl9hYmJyO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBnbG9iYWxMb2NhbGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzQXJyYXkoa2V5KSkge1xuICAgICAgICAgICAgLy9zaG9ydC1jaXJjdWl0IGV2ZXJ5dGhpbmcgZWxzZVxuICAgICAgICAgICAgbG9jYWxlID0gbG9hZExvY2FsZShrZXkpO1xuICAgICAgICAgICAgaWYgKGxvY2FsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBsb2NhbGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBrZXkgPSBba2V5XTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjaG9vc2VMb2NhbGUoa2V5KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaXN0TG9jYWxlcygpIHtcbiAgICAgICAgcmV0dXJuIGtleXMobG9jYWxlcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2hlY2tPdmVyZmxvdyhtKSB7XG4gICAgICAgIHZhciBvdmVyZmxvdyxcbiAgICAgICAgICAgIGEgPSBtLl9hO1xuXG4gICAgICAgIGlmIChhICYmIGdldFBhcnNpbmdGbGFncyhtKS5vdmVyZmxvdyA9PT0gLTIpIHtcbiAgICAgICAgICAgIG92ZXJmbG93ID1cbiAgICAgICAgICAgICAgICBhW01PTlRIXSA8IDAgfHwgYVtNT05USF0gPiAxMVxuICAgICAgICAgICAgICAgICAgICA/IE1PTlRIXG4gICAgICAgICAgICAgICAgICAgIDogYVtEQVRFXSA8IDEgfHwgYVtEQVRFXSA+IGRheXNJbk1vbnRoKGFbWUVBUl0sIGFbTU9OVEhdKVxuICAgICAgICAgICAgICAgICAgICA/IERBVEVcbiAgICAgICAgICAgICAgICAgICAgOiBhW0hPVVJdIDwgMCB8fFxuICAgICAgICAgICAgICAgICAgICAgIGFbSE9VUl0gPiAyNCB8fFxuICAgICAgICAgICAgICAgICAgICAgIChhW0hPVVJdID09PSAyNCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAoYVtNSU5VVEVdICE9PSAwIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhW1NFQ09ORF0gIT09IDAgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFbTUlMTElTRUNPTkRdICE9PSAwKSlcbiAgICAgICAgICAgICAgICAgICAgPyBIT1VSXG4gICAgICAgICAgICAgICAgICAgIDogYVtNSU5VVEVdIDwgMCB8fCBhW01JTlVURV0gPiA1OVxuICAgICAgICAgICAgICAgICAgICA/IE1JTlVURVxuICAgICAgICAgICAgICAgICAgICA6IGFbU0VDT05EXSA8IDAgfHwgYVtTRUNPTkRdID4gNTlcbiAgICAgICAgICAgICAgICAgICAgPyBTRUNPTkRcbiAgICAgICAgICAgICAgICAgICAgOiBhW01JTExJU0VDT05EXSA8IDAgfHwgYVtNSUxMSVNFQ09ORF0gPiA5OTlcbiAgICAgICAgICAgICAgICAgICAgPyBNSUxMSVNFQ09ORFxuICAgICAgICAgICAgICAgICAgICA6IC0xO1xuXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKG0pLl9vdmVyZmxvd0RheU9mWWVhciAmJlxuICAgICAgICAgICAgICAgIChvdmVyZmxvdyA8IFlFQVIgfHwgb3ZlcmZsb3cgPiBEQVRFKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgb3ZlcmZsb3cgPSBEQVRFO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdldFBhcnNpbmdGbGFncyhtKS5fb3ZlcmZsb3dXZWVrcyAmJiBvdmVyZmxvdyA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBvdmVyZmxvdyA9IFdFRUs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ2V0UGFyc2luZ0ZsYWdzKG0pLl9vdmVyZmxvd1dlZWtkYXkgJiYgb3ZlcmZsb3cgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgb3ZlcmZsb3cgPSBXRUVLREFZO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MobSkub3ZlcmZsb3cgPSBvdmVyZmxvdztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtO1xuICAgIH1cblxuICAgIC8vIGlzbyA4NjAxIHJlZ2V4XG4gICAgLy8gMDAwMC0wMC0wMCAwMDAwLVcwMCBvciAwMDAwLVcwMC0wICsgVCArIDAwIG9yIDAwOjAwIG9yIDAwOjAwOjAwIG9yIDAwOjAwOjAwLjAwMCArICswMDowMCBvciArMDAwMCBvciArMDApXG4gICAgdmFyIGV4dGVuZGVkSXNvUmVnZXggPVxuICAgICAgICAgICAgL15cXHMqKCg/OlsrLV1cXGR7Nn18XFxkezR9KS0oPzpcXGRcXGQtXFxkXFxkfFdcXGRcXGQtXFxkfFdcXGRcXGR8XFxkXFxkXFxkfFxcZFxcZCkpKD86KFR8ICkoXFxkXFxkKD86OlxcZFxcZCg/OjpcXGRcXGQoPzpbLixdXFxkKyk/KT8pPykoWystXVxcZFxcZCg/Ojo/XFxkXFxkKT98XFxzKlopPyk/JC8sXG4gICAgICAgIGJhc2ljSXNvUmVnZXggPVxuICAgICAgICAgICAgL15cXHMqKCg/OlsrLV1cXGR7Nn18XFxkezR9KSg/OlxcZFxcZFxcZFxcZHxXXFxkXFxkXFxkfFdcXGRcXGR8XFxkXFxkXFxkfFxcZFxcZHwpKSg/OihUfCApKFxcZFxcZCg/OlxcZFxcZCg/OlxcZFxcZCg/OlsuLF1cXGQrKT8pPyk/KShbKy1dXFxkXFxkKD86Oj9cXGRcXGQpP3xcXHMqWik/KT8kLyxcbiAgICAgICAgdHpSZWdleCA9IC9afFsrLV1cXGRcXGQoPzo6P1xcZFxcZCk/LyxcbiAgICAgICAgaXNvRGF0ZXMgPSBbXG4gICAgICAgICAgICBbJ1lZWVlZWS1NTS1ERCcsIC9bKy1dXFxkezZ9LVxcZFxcZC1cXGRcXGQvXSxcbiAgICAgICAgICAgIFsnWVlZWS1NTS1ERCcsIC9cXGR7NH0tXFxkXFxkLVxcZFxcZC9dLFxuICAgICAgICAgICAgWydHR0dHLVtXXVdXLUUnLCAvXFxkezR9LVdcXGRcXGQtXFxkL10sXG4gICAgICAgICAgICBbJ0dHR0ctW1ddV1cnLCAvXFxkezR9LVdcXGRcXGQvLCBmYWxzZV0sXG4gICAgICAgICAgICBbJ1lZWVktREREJywgL1xcZHs0fS1cXGR7M30vXSxcbiAgICAgICAgICAgIFsnWVlZWS1NTScsIC9cXGR7NH0tXFxkXFxkLywgZmFsc2VdLFxuICAgICAgICAgICAgWydZWVlZWVlNTUREJywgL1srLV1cXGR7MTB9L10sXG4gICAgICAgICAgICBbJ1lZWVlNTUREJywgL1xcZHs4fS9dLFxuICAgICAgICAgICAgWydHR0dHW1ddV1dFJywgL1xcZHs0fVdcXGR7M30vXSxcbiAgICAgICAgICAgIFsnR0dHR1tXXVdXJywgL1xcZHs0fVdcXGR7Mn0vLCBmYWxzZV0sXG4gICAgICAgICAgICBbJ1lZWVlEREQnLCAvXFxkezd9L10sXG4gICAgICAgICAgICBbJ1lZWVlNTScsIC9cXGR7Nn0vLCBmYWxzZV0sXG4gICAgICAgICAgICBbJ1lZWVknLCAvXFxkezR9LywgZmFsc2VdLFxuICAgICAgICBdLFxuICAgICAgICAvLyBpc28gdGltZSBmb3JtYXRzIGFuZCByZWdleGVzXG4gICAgICAgIGlzb1RpbWVzID0gW1xuICAgICAgICAgICAgWydISDptbTpzcy5TU1NTJywgL1xcZFxcZDpcXGRcXGQ6XFxkXFxkXFwuXFxkKy9dLFxuICAgICAgICAgICAgWydISDptbTpzcyxTU1NTJywgL1xcZFxcZDpcXGRcXGQ6XFxkXFxkLFxcZCsvXSxcbiAgICAgICAgICAgIFsnSEg6bW06c3MnLCAvXFxkXFxkOlxcZFxcZDpcXGRcXGQvXSxcbiAgICAgICAgICAgIFsnSEg6bW0nLCAvXFxkXFxkOlxcZFxcZC9dLFxuICAgICAgICAgICAgWydISG1tc3MuU1NTUycsIC9cXGRcXGRcXGRcXGRcXGRcXGRcXC5cXGQrL10sXG4gICAgICAgICAgICBbJ0hIbW1zcyxTU1NTJywgL1xcZFxcZFxcZFxcZFxcZFxcZCxcXGQrL10sXG4gICAgICAgICAgICBbJ0hIbW1zcycsIC9cXGRcXGRcXGRcXGRcXGRcXGQvXSxcbiAgICAgICAgICAgIFsnSEhtbScsIC9cXGRcXGRcXGRcXGQvXSxcbiAgICAgICAgICAgIFsnSEgnLCAvXFxkXFxkL10sXG4gICAgICAgIF0sXG4gICAgICAgIGFzcE5ldEpzb25SZWdleCA9IC9eXFwvP0RhdGVcXCgoLT9cXGQrKS9pLFxuICAgICAgICAvLyBSRkMgMjgyMiByZWdleDogRm9yIGRldGFpbHMgc2VlIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMyODIyI3NlY3Rpb24tMy4zXG4gICAgICAgIHJmYzI4MjIgPVxuICAgICAgICAgICAgL14oPzooTW9ufFR1ZXxXZWR8VGh1fEZyaXxTYXR8U3VuKSw/XFxzKT8oXFxkezEsMn0pXFxzKEphbnxGZWJ8TWFyfEFwcnxNYXl8SnVufEp1bHxBdWd8U2VwfE9jdHxOb3Z8RGVjKVxccyhcXGR7Miw0fSlcXHMoXFxkXFxkKTooXFxkXFxkKSg/OjooXFxkXFxkKSk/XFxzKD86KFVUfEdNVHxbRUNNUF1bU0RdVCl8KFtael0pfChbKy1dXFxkezR9KSkkLyxcbiAgICAgICAgb2JzT2Zmc2V0cyA9IHtcbiAgICAgICAgICAgIFVUOiAwLFxuICAgICAgICAgICAgR01UOiAwLFxuICAgICAgICAgICAgRURUOiAtNCAqIDYwLFxuICAgICAgICAgICAgRVNUOiAtNSAqIDYwLFxuICAgICAgICAgICAgQ0RUOiAtNSAqIDYwLFxuICAgICAgICAgICAgQ1NUOiAtNiAqIDYwLFxuICAgICAgICAgICAgTURUOiAtNiAqIDYwLFxuICAgICAgICAgICAgTVNUOiAtNyAqIDYwLFxuICAgICAgICAgICAgUERUOiAtNyAqIDYwLFxuICAgICAgICAgICAgUFNUOiAtOCAqIDYwLFxuICAgICAgICB9O1xuXG4gICAgLy8gZGF0ZSBmcm9tIGlzbyBmb3JtYXRcbiAgICBmdW5jdGlvbiBjb25maWdGcm9tSVNPKGNvbmZpZykge1xuICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgIGwsXG4gICAgICAgICAgICBzdHJpbmcgPSBjb25maWcuX2ksXG4gICAgICAgICAgICBtYXRjaCA9IGV4dGVuZGVkSXNvUmVnZXguZXhlYyhzdHJpbmcpIHx8IGJhc2ljSXNvUmVnZXguZXhlYyhzdHJpbmcpLFxuICAgICAgICAgICAgYWxsb3dUaW1lLFxuICAgICAgICAgICAgZGF0ZUZvcm1hdCxcbiAgICAgICAgICAgIHRpbWVGb3JtYXQsXG4gICAgICAgICAgICB0ekZvcm1hdCxcbiAgICAgICAgICAgIGlzb0RhdGVzTGVuID0gaXNvRGF0ZXMubGVuZ3RoLFxuICAgICAgICAgICAgaXNvVGltZXNMZW4gPSBpc29UaW1lcy5sZW5ndGg7XG5cbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5pc28gPSB0cnVlO1xuICAgICAgICAgICAgZm9yIChpID0gMCwgbCA9IGlzb0RhdGVzTGVuOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzb0RhdGVzW2ldWzFdLmV4ZWMobWF0Y2hbMV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGVGb3JtYXQgPSBpc29EYXRlc1tpXVswXTtcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dUaW1lID0gaXNvRGF0ZXNbaV1bMl0gIT09IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0ZUZvcm1hdCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1hdGNoWzNdKSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMCwgbCA9IGlzb1RpbWVzTGVuOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc29UaW1lc1tpXVsxXS5leGVjKG1hdGNoWzNdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWF0Y2hbMl0gc2hvdWxkIGJlICdUJyBvciBzcGFjZVxuICAgICAgICAgICAgICAgICAgICAgICAgdGltZUZvcm1hdCA9IChtYXRjaFsyXSB8fCAnICcpICsgaXNvVGltZXNbaV1bMF07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGltZUZvcm1hdCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFhbGxvd1RpbWUgJiYgdGltZUZvcm1hdCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1hdGNoWzRdKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR6UmVnZXguZXhlYyhtYXRjaFs0XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdHpGb3JtYXQgPSAnWic7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25maWcuX2YgPSBkYXRlRm9ybWF0ICsgKHRpbWVGb3JtYXQgfHwgJycpICsgKHR6Rm9ybWF0IHx8ICcnKTtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21TdHJpbmdBbmRGb3JtYXQoY29uZmlnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXh0cmFjdEZyb21SRkMyODIyU3RyaW5ncyhcbiAgICAgICAgeWVhclN0cixcbiAgICAgICAgbW9udGhTdHIsXG4gICAgICAgIGRheVN0cixcbiAgICAgICAgaG91clN0cixcbiAgICAgICAgbWludXRlU3RyLFxuICAgICAgICBzZWNvbmRTdHJcbiAgICApIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtcbiAgICAgICAgICAgIHVudHJ1bmNhdGVZZWFyKHllYXJTdHIpLFxuICAgICAgICAgICAgZGVmYXVsdExvY2FsZU1vbnRoc1Nob3J0LmluZGV4T2YobW9udGhTdHIpLFxuICAgICAgICAgICAgcGFyc2VJbnQoZGF5U3RyLCAxMCksXG4gICAgICAgICAgICBwYXJzZUludChob3VyU3RyLCAxMCksXG4gICAgICAgICAgICBwYXJzZUludChtaW51dGVTdHIsIDEwKSxcbiAgICAgICAgXTtcblxuICAgICAgICBpZiAoc2Vjb25kU3RyKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChwYXJzZUludChzZWNvbmRTdHIsIDEwKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVudHJ1bmNhdGVZZWFyKHllYXJTdHIpIHtcbiAgICAgICAgdmFyIHllYXIgPSBwYXJzZUludCh5ZWFyU3RyLCAxMCk7XG4gICAgICAgIGlmICh5ZWFyIDw9IDQ5KSB7XG4gICAgICAgICAgICByZXR1cm4gMjAwMCArIHllYXI7XG4gICAgICAgIH0gZWxzZSBpZiAoeWVhciA8PSA5OTkpIHtcbiAgICAgICAgICAgIHJldHVybiAxOTAwICsgeWVhcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geWVhcjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcmVwcm9jZXNzUkZDMjgyMihzKSB7XG4gICAgICAgIC8vIFJlbW92ZSBjb21tZW50cyBhbmQgZm9sZGluZyB3aGl0ZXNwYWNlIGFuZCByZXBsYWNlIG11bHRpcGxlLXNwYWNlcyB3aXRoIGEgc2luZ2xlIHNwYWNlXG4gICAgICAgIHJldHVybiBzXG4gICAgICAgICAgICAucmVwbGFjZSgvXFwoW14oKV0qXFwpfFtcXG5cXHRdL2csICcgJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC8oXFxzXFxzKykvZywgJyAnKVxuICAgICAgICAgICAgLnJlcGxhY2UoL15cXHNcXHMqLywgJycpXG4gICAgICAgICAgICAucmVwbGFjZSgvXFxzXFxzKiQvLCAnJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2hlY2tXZWVrZGF5KHdlZWtkYXlTdHIsIHBhcnNlZElucHV0LCBjb25maWcpIHtcbiAgICAgICAgaWYgKHdlZWtkYXlTdHIpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IFJlcGxhY2UgdGhlIHZhbmlsbGEgSlMgRGF0ZSBvYmplY3Qgd2l0aCBhbiBpbmRlcGVuZGVudCBkYXktb2Ytd2VlayBjaGVjay5cbiAgICAgICAgICAgIHZhciB3ZWVrZGF5UHJvdmlkZWQgPSBkZWZhdWx0TG9jYWxlV2Vla2RheXNTaG9ydC5pbmRleE9mKHdlZWtkYXlTdHIpLFxuICAgICAgICAgICAgICAgIHdlZWtkYXlBY3R1YWwgPSBuZXcgRGF0ZShcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkSW5wdXRbMF0sXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZElucHV0WzFdLFxuICAgICAgICAgICAgICAgICAgICBwYXJzZWRJbnB1dFsyXVxuICAgICAgICAgICAgICAgICkuZ2V0RGF5KCk7XG4gICAgICAgICAgICBpZiAod2Vla2RheVByb3ZpZGVkICE9PSB3ZWVrZGF5QWN0dWFsKSB7XG4gICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykud2Vla2RheU1pc21hdGNoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2FsY3VsYXRlT2Zmc2V0KG9ic09mZnNldCwgbWlsaXRhcnlPZmZzZXQsIG51bU9mZnNldCkge1xuICAgICAgICBpZiAob2JzT2Zmc2V0KSB7XG4gICAgICAgICAgICByZXR1cm4gb2JzT2Zmc2V0c1tvYnNPZmZzZXRdO1xuICAgICAgICB9IGVsc2UgaWYgKG1pbGl0YXJ5T2Zmc2V0KSB7XG4gICAgICAgICAgICAvLyB0aGUgb25seSBhbGxvd2VkIG1pbGl0YXJ5IHR6IGlzIFpcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGhtID0gcGFyc2VJbnQobnVtT2Zmc2V0LCAxMCksXG4gICAgICAgICAgICAgICAgbSA9IGhtICUgMTAwLFxuICAgICAgICAgICAgICAgIGggPSAoaG0gLSBtKSAvIDEwMDtcbiAgICAgICAgICAgIHJldHVybiBoICogNjAgKyBtO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gZGF0ZSBhbmQgdGltZSBmcm9tIHJlZiAyODIyIGZvcm1hdFxuICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21SRkMyODIyKGNvbmZpZykge1xuICAgICAgICB2YXIgbWF0Y2ggPSByZmMyODIyLmV4ZWMocHJlcHJvY2Vzc1JGQzI4MjIoY29uZmlnLl9pKSksXG4gICAgICAgICAgICBwYXJzZWRBcnJheTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICBwYXJzZWRBcnJheSA9IGV4dHJhY3RGcm9tUkZDMjgyMlN0cmluZ3MoXG4gICAgICAgICAgICAgICAgbWF0Y2hbNF0sXG4gICAgICAgICAgICAgICAgbWF0Y2hbM10sXG4gICAgICAgICAgICAgICAgbWF0Y2hbMl0sXG4gICAgICAgICAgICAgICAgbWF0Y2hbNV0sXG4gICAgICAgICAgICAgICAgbWF0Y2hbNl0sXG4gICAgICAgICAgICAgICAgbWF0Y2hbN11cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAoIWNoZWNrV2Vla2RheShtYXRjaFsxXSwgcGFyc2VkQXJyYXksIGNvbmZpZykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbmZpZy5fYSA9IHBhcnNlZEFycmF5O1xuICAgICAgICAgICAgY29uZmlnLl90em0gPSBjYWxjdWxhdGVPZmZzZXQobWF0Y2hbOF0sIG1hdGNoWzldLCBtYXRjaFsxMF0pO1xuXG4gICAgICAgICAgICBjb25maWcuX2QgPSBjcmVhdGVVVENEYXRlLmFwcGx5KG51bGwsIGNvbmZpZy5fYSk7XG4gICAgICAgICAgICBjb25maWcuX2Quc2V0VVRDTWludXRlcyhjb25maWcuX2QuZ2V0VVRDTWludXRlcygpIC0gY29uZmlnLl90em0pO1xuXG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5yZmMyODIyID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gZGF0ZSBmcm9tIDEpIEFTUC5ORVQsIDIpIElTTywgMykgUkZDIDI4MjIgZm9ybWF0cywgb3IgNCkgb3B0aW9uYWwgZmFsbGJhY2sgaWYgcGFyc2luZyBpc24ndCBzdHJpY3RcbiAgICBmdW5jdGlvbiBjb25maWdGcm9tU3RyaW5nKGNvbmZpZykge1xuICAgICAgICB2YXIgbWF0Y2hlZCA9IGFzcE5ldEpzb25SZWdleC5leGVjKGNvbmZpZy5faSk7XG4gICAgICAgIGlmIChtYXRjaGVkICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZSgrbWF0Y2hlZFsxXSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25maWdGcm9tSVNPKGNvbmZpZyk7XG4gICAgICAgIGlmIChjb25maWcuX2lzVmFsaWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBkZWxldGUgY29uZmlnLl9pc1ZhbGlkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uZmlnRnJvbVJGQzI4MjIoY29uZmlnKTtcbiAgICAgICAgaWYgKGNvbmZpZy5faXNWYWxpZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBjb25maWcuX2lzVmFsaWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29uZmlnLl9zdHJpY3QpIHtcbiAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gRmluYWwgYXR0ZW1wdCwgdXNlIElucHV0IEZhbGxiYWNrXG4gICAgICAgICAgICBob29rcy5jcmVhdGVGcm9tSW5wdXRGYWxsYmFjayhjb25maWcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaG9va3MuY3JlYXRlRnJvbUlucHV0RmFsbGJhY2sgPSBkZXByZWNhdGUoXG4gICAgICAgICd2YWx1ZSBwcm92aWRlZCBpcyBub3QgaW4gYSByZWNvZ25pemVkIFJGQzI4MjIgb3IgSVNPIGZvcm1hdC4gbW9tZW50IGNvbnN0cnVjdGlvbiBmYWxscyBiYWNrIHRvIGpzIERhdGUoKSwgJyArXG4gICAgICAgICAgICAnd2hpY2ggaXMgbm90IHJlbGlhYmxlIGFjcm9zcyBhbGwgYnJvd3NlcnMgYW5kIHZlcnNpb25zLiBOb24gUkZDMjgyMi9JU08gZGF0ZSBmb3JtYXRzIGFyZSAnICtcbiAgICAgICAgICAgICdkaXNjb3VyYWdlZC4gUGxlYXNlIHJlZmVyIHRvIGh0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3MvanMtZGF0ZS8gZm9yIG1vcmUgaW5mby4nLFxuICAgICAgICBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShjb25maWcuX2kgKyAoY29uZmlnLl91c2VVVEMgPyAnIFVUQycgOiAnJykpO1xuICAgICAgICB9XG4gICAgKTtcblxuICAgIC8vIFBpY2sgdGhlIGZpcnN0IGRlZmluZWQgb2YgdHdvIG9yIHRocmVlIGFyZ3VtZW50cy5cbiAgICBmdW5jdGlvbiBkZWZhdWx0cyhhLCBiLCBjKSB7XG4gICAgICAgIGlmIChhICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICB9XG4gICAgICAgIGlmIChiICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGN1cnJlbnREYXRlQXJyYXkoY29uZmlnKSB7XG4gICAgICAgIC8vIGhvb2tzIGlzIGFjdHVhbGx5IHRoZSBleHBvcnRlZCBtb21lbnQgb2JqZWN0XG4gICAgICAgIHZhciBub3dWYWx1ZSA9IG5ldyBEYXRlKGhvb2tzLm5vdygpKTtcbiAgICAgICAgaWYgKGNvbmZpZy5fdXNlVVRDKSB7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIG5vd1ZhbHVlLmdldFVUQ0Z1bGxZZWFyKCksXG4gICAgICAgICAgICAgICAgbm93VmFsdWUuZ2V0VVRDTW9udGgoKSxcbiAgICAgICAgICAgICAgICBub3dWYWx1ZS5nZXRVVENEYXRlKCksXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbbm93VmFsdWUuZ2V0RnVsbFllYXIoKSwgbm93VmFsdWUuZ2V0TW9udGgoKSwgbm93VmFsdWUuZ2V0RGF0ZSgpXTtcbiAgICB9XG5cbiAgICAvLyBjb252ZXJ0IGFuIGFycmF5IHRvIGEgZGF0ZS5cbiAgICAvLyB0aGUgYXJyYXkgc2hvdWxkIG1pcnJvciB0aGUgcGFyYW1ldGVycyBiZWxvd1xuICAgIC8vIG5vdGU6IGFsbCB2YWx1ZXMgcGFzdCB0aGUgeWVhciBhcmUgb3B0aW9uYWwgYW5kIHdpbGwgZGVmYXVsdCB0byB0aGUgbG93ZXN0IHBvc3NpYmxlIHZhbHVlLlxuICAgIC8vIFt5ZWFyLCBtb250aCwgZGF5ICwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kXVxuICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21BcnJheShjb25maWcpIHtcbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgICBkYXRlLFxuICAgICAgICAgICAgaW5wdXQgPSBbXSxcbiAgICAgICAgICAgIGN1cnJlbnREYXRlLFxuICAgICAgICAgICAgZXhwZWN0ZWRXZWVrZGF5LFxuICAgICAgICAgICAgeWVhclRvVXNlO1xuXG4gICAgICAgIGlmIChjb25maWcuX2QpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGN1cnJlbnREYXRlID0gY3VycmVudERhdGVBcnJheShjb25maWcpO1xuXG4gICAgICAgIC8vY29tcHV0ZSBkYXkgb2YgdGhlIHllYXIgZnJvbSB3ZWVrcyBhbmQgd2Vla2RheXNcbiAgICAgICAgaWYgKGNvbmZpZy5fdyAmJiBjb25maWcuX2FbREFURV0gPT0gbnVsbCAmJiBjb25maWcuX2FbTU9OVEhdID09IG51bGwpIHtcbiAgICAgICAgICAgIGRheU9mWWVhckZyb21XZWVrSW5mbyhjb25maWcpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9pZiB0aGUgZGF5IG9mIHRoZSB5ZWFyIGlzIHNldCwgZmlndXJlIG91dCB3aGF0IGl0IGlzXG4gICAgICAgIGlmIChjb25maWcuX2RheU9mWWVhciAhPSBudWxsKSB7XG4gICAgICAgICAgICB5ZWFyVG9Vc2UgPSBkZWZhdWx0cyhjb25maWcuX2FbWUVBUl0sIGN1cnJlbnREYXRlW1lFQVJdKTtcblxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIGNvbmZpZy5fZGF5T2ZZZWFyID4gZGF5c0luWWVhcih5ZWFyVG9Vc2UpIHx8XG4gICAgICAgICAgICAgICAgY29uZmlnLl9kYXlPZlllYXIgPT09IDBcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLl9vdmVyZmxvd0RheU9mWWVhciA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRhdGUgPSBjcmVhdGVVVENEYXRlKHllYXJUb1VzZSwgMCwgY29uZmlnLl9kYXlPZlllYXIpO1xuICAgICAgICAgICAgY29uZmlnLl9hW01PTlRIXSA9IGRhdGUuZ2V0VVRDTW9udGgoKTtcbiAgICAgICAgICAgIGNvbmZpZy5fYVtEQVRFXSA9IGRhdGUuZ2V0VVRDRGF0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGVmYXVsdCB0byBjdXJyZW50IGRhdGUuXG4gICAgICAgIC8vICogaWYgbm8geWVhciwgbW9udGgsIGRheSBvZiBtb250aCBhcmUgZ2l2ZW4sIGRlZmF1bHQgdG8gdG9kYXlcbiAgICAgICAgLy8gKiBpZiBkYXkgb2YgbW9udGggaXMgZ2l2ZW4sIGRlZmF1bHQgbW9udGggYW5kIHllYXJcbiAgICAgICAgLy8gKiBpZiBtb250aCBpcyBnaXZlbiwgZGVmYXVsdCBvbmx5IHllYXJcbiAgICAgICAgLy8gKiBpZiB5ZWFyIGlzIGdpdmVuLCBkb24ndCBkZWZhdWx0IGFueXRoaW5nXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCAzICYmIGNvbmZpZy5fYVtpXSA9PSBudWxsOyArK2kpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fYVtpXSA9IGlucHV0W2ldID0gY3VycmVudERhdGVbaV07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBaZXJvIG91dCB3aGF0ZXZlciB3YXMgbm90IGRlZmF1bHRlZCwgaW5jbHVkaW5nIHRpbWVcbiAgICAgICAgZm9yICg7IGkgPCA3OyBpKyspIHtcbiAgICAgICAgICAgIGNvbmZpZy5fYVtpXSA9IGlucHV0W2ldID1cbiAgICAgICAgICAgICAgICBjb25maWcuX2FbaV0gPT0gbnVsbCA/IChpID09PSAyID8gMSA6IDApIDogY29uZmlnLl9hW2ldO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2sgZm9yIDI0OjAwOjAwLjAwMFxuICAgICAgICBpZiAoXG4gICAgICAgICAgICBjb25maWcuX2FbSE9VUl0gPT09IDI0ICYmXG4gICAgICAgICAgICBjb25maWcuX2FbTUlOVVRFXSA9PT0gMCAmJlxuICAgICAgICAgICAgY29uZmlnLl9hW1NFQ09ORF0gPT09IDAgJiZcbiAgICAgICAgICAgIGNvbmZpZy5fYVtNSUxMSVNFQ09ORF0gPT09IDBcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBjb25maWcuX25leHREYXkgPSB0cnVlO1xuICAgICAgICAgICAgY29uZmlnLl9hW0hPVVJdID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbmZpZy5fZCA9IChjb25maWcuX3VzZVVUQyA/IGNyZWF0ZVVUQ0RhdGUgOiBjcmVhdGVEYXRlKS5hcHBseShcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICBpbnB1dFxuICAgICAgICApO1xuICAgICAgICBleHBlY3RlZFdlZWtkYXkgPSBjb25maWcuX3VzZVVUQ1xuICAgICAgICAgICAgPyBjb25maWcuX2QuZ2V0VVRDRGF5KClcbiAgICAgICAgICAgIDogY29uZmlnLl9kLmdldERheSgpO1xuXG4gICAgICAgIC8vIEFwcGx5IHRpbWV6b25lIG9mZnNldCBmcm9tIGlucHV0LiBUaGUgYWN0dWFsIHV0Y09mZnNldCBjYW4gYmUgY2hhbmdlZFxuICAgICAgICAvLyB3aXRoIHBhcnNlWm9uZS5cbiAgICAgICAgaWYgKGNvbmZpZy5fdHptICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fZC5zZXRVVENNaW51dGVzKGNvbmZpZy5fZC5nZXRVVENNaW51dGVzKCkgLSBjb25maWcuX3R6bSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29uZmlnLl9uZXh0RGF5KSB7XG4gICAgICAgICAgICBjb25maWcuX2FbSE9VUl0gPSAyNDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNoZWNrIGZvciBtaXNtYXRjaGluZyBkYXkgb2Ygd2Vla1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICBjb25maWcuX3cgJiZcbiAgICAgICAgICAgIHR5cGVvZiBjb25maWcuX3cuZCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgIGNvbmZpZy5fdy5kICE9PSBleHBlY3RlZFdlZWtkYXlcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS53ZWVrZGF5TWlzbWF0Y2ggPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGF5T2ZZZWFyRnJvbVdlZWtJbmZvKGNvbmZpZykge1xuICAgICAgICB2YXIgdywgd2Vla1llYXIsIHdlZWssIHdlZWtkYXksIGRvdywgZG95LCB0ZW1wLCB3ZWVrZGF5T3ZlcmZsb3csIGN1cldlZWs7XG5cbiAgICAgICAgdyA9IGNvbmZpZy5fdztcbiAgICAgICAgaWYgKHcuR0cgIT0gbnVsbCB8fCB3LlcgIT0gbnVsbCB8fCB3LkUgIT0gbnVsbCkge1xuICAgICAgICAgICAgZG93ID0gMTtcbiAgICAgICAgICAgIGRveSA9IDQ7XG5cbiAgICAgICAgICAgIC8vIFRPRE86IFdlIG5lZWQgdG8gdGFrZSB0aGUgY3VycmVudCBpc29XZWVrWWVhciwgYnV0IHRoYXQgZGVwZW5kcyBvblxuICAgICAgICAgICAgLy8gaG93IHdlIGludGVycHJldCBub3cgKGxvY2FsLCB1dGMsIGZpeGVkIG9mZnNldCkuIFNvIGNyZWF0ZVxuICAgICAgICAgICAgLy8gYSBub3cgdmVyc2lvbiBvZiBjdXJyZW50IGNvbmZpZyAodGFrZSBsb2NhbC91dGMvb2Zmc2V0IGZsYWdzLCBhbmRcbiAgICAgICAgICAgIC8vIGNyZWF0ZSBub3cpLlxuICAgICAgICAgICAgd2Vla1llYXIgPSBkZWZhdWx0cyhcbiAgICAgICAgICAgICAgICB3LkdHLFxuICAgICAgICAgICAgICAgIGNvbmZpZy5fYVtZRUFSXSxcbiAgICAgICAgICAgICAgICB3ZWVrT2ZZZWFyKGNyZWF0ZUxvY2FsKCksIDEsIDQpLnllYXJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB3ZWVrID0gZGVmYXVsdHMody5XLCAxKTtcbiAgICAgICAgICAgIHdlZWtkYXkgPSBkZWZhdWx0cyh3LkUsIDEpO1xuICAgICAgICAgICAgaWYgKHdlZWtkYXkgPCAxIHx8IHdlZWtkYXkgPiA3KSB7XG4gICAgICAgICAgICAgICAgd2Vla2RheU92ZXJmbG93ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRvdyA9IGNvbmZpZy5fbG9jYWxlLl93ZWVrLmRvdztcbiAgICAgICAgICAgIGRveSA9IGNvbmZpZy5fbG9jYWxlLl93ZWVrLmRveTtcblxuICAgICAgICAgICAgY3VyV2VlayA9IHdlZWtPZlllYXIoY3JlYXRlTG9jYWwoKSwgZG93LCBkb3kpO1xuXG4gICAgICAgICAgICB3ZWVrWWVhciA9IGRlZmF1bHRzKHcuZ2csIGNvbmZpZy5fYVtZRUFSXSwgY3VyV2Vlay55ZWFyKTtcblxuICAgICAgICAgICAgLy8gRGVmYXVsdCB0byBjdXJyZW50IHdlZWsuXG4gICAgICAgICAgICB3ZWVrID0gZGVmYXVsdHMody53LCBjdXJXZWVrLndlZWspO1xuXG4gICAgICAgICAgICBpZiAody5kICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyB3ZWVrZGF5IC0tIGxvdyBkYXkgbnVtYmVycyBhcmUgY29uc2lkZXJlZCBuZXh0IHdlZWtcbiAgICAgICAgICAgICAgICB3ZWVrZGF5ID0gdy5kO1xuICAgICAgICAgICAgICAgIGlmICh3ZWVrZGF5IDwgMCB8fCB3ZWVrZGF5ID4gNikge1xuICAgICAgICAgICAgICAgICAgICB3ZWVrZGF5T3ZlcmZsb3cgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAody5lICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBsb2NhbCB3ZWVrZGF5IC0tIGNvdW50aW5nIHN0YXJ0cyBmcm9tIGJlZ2lubmluZyBvZiB3ZWVrXG4gICAgICAgICAgICAgICAgd2Vla2RheSA9IHcuZSArIGRvdztcbiAgICAgICAgICAgICAgICBpZiAody5lIDwgMCB8fCB3LmUgPiA2KSB7XG4gICAgICAgICAgICAgICAgICAgIHdlZWtkYXlPdmVyZmxvdyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBkZWZhdWx0IHRvIGJlZ2lubmluZyBvZiB3ZWVrXG4gICAgICAgICAgICAgICAgd2Vla2RheSA9IGRvdztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAod2VlayA8IDEgfHwgd2VlayA+IHdlZWtzSW5ZZWFyKHdlZWtZZWFyLCBkb3csIGRveSkpIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLl9vdmVyZmxvd1dlZWtzID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmICh3ZWVrZGF5T3ZlcmZsb3cgIT0gbnVsbCkge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuX292ZXJmbG93V2Vla2RheSA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0ZW1wID0gZGF5T2ZZZWFyRnJvbVdlZWtzKHdlZWtZZWFyLCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSk7XG4gICAgICAgICAgICBjb25maWcuX2FbWUVBUl0gPSB0ZW1wLnllYXI7XG4gICAgICAgICAgICBjb25maWcuX2RheU9mWWVhciA9IHRlbXAuZGF5T2ZZZWFyO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gY29uc3RhbnQgdGhhdCByZWZlcnMgdG8gdGhlIElTTyBzdGFuZGFyZFxuICAgIGhvb2tzLklTT184NjAxID0gZnVuY3Rpb24gKCkge307XG5cbiAgICAvLyBjb25zdGFudCB0aGF0IHJlZmVycyB0byB0aGUgUkZDIDI4MjIgZm9ybVxuICAgIGhvb2tzLlJGQ18yODIyID0gZnVuY3Rpb24gKCkge307XG5cbiAgICAvLyBkYXRlIGZyb20gc3RyaW5nIGFuZCBmb3JtYXQgc3RyaW5nXG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbVN0cmluZ0FuZEZvcm1hdChjb25maWcpIHtcbiAgICAgICAgLy8gVE9ETzogTW92ZSB0aGlzIHRvIGFub3RoZXIgcGFydCBvZiB0aGUgY3JlYXRpb24gZmxvdyB0byBwcmV2ZW50IGNpcmN1bGFyIGRlcHNcbiAgICAgICAgaWYgKGNvbmZpZy5fZiA9PT0gaG9va3MuSVNPXzg2MDEpIHtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21JU08oY29uZmlnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uZmlnLl9mID09PSBob29rcy5SRkNfMjgyMikge1xuICAgICAgICAgICAgY29uZmlnRnJvbVJGQzI4MjIoY29uZmlnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25maWcuX2EgPSBbXTtcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuZW1wdHkgPSB0cnVlO1xuXG4gICAgICAgIC8vIFRoaXMgYXJyYXkgaXMgdXNlZCB0byBtYWtlIGEgRGF0ZSwgZWl0aGVyIHdpdGggYG5ldyBEYXRlYCBvciBgRGF0ZS5VVENgXG4gICAgICAgIHZhciBzdHJpbmcgPSAnJyArIGNvbmZpZy5faSxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBwYXJzZWRJbnB1dCxcbiAgICAgICAgICAgIHRva2VucyxcbiAgICAgICAgICAgIHRva2VuLFxuICAgICAgICAgICAgc2tpcHBlZCxcbiAgICAgICAgICAgIHN0cmluZ0xlbmd0aCA9IHN0cmluZy5sZW5ndGgsXG4gICAgICAgICAgICB0b3RhbFBhcnNlZElucHV0TGVuZ3RoID0gMCxcbiAgICAgICAgICAgIGVyYSxcbiAgICAgICAgICAgIHRva2VuTGVuO1xuXG4gICAgICAgIHRva2VucyA9XG4gICAgICAgICAgICBleHBhbmRGb3JtYXQoY29uZmlnLl9mLCBjb25maWcuX2xvY2FsZSkubWF0Y2goZm9ybWF0dGluZ1Rva2VucykgfHwgW107XG4gICAgICAgIHRva2VuTGVuID0gdG9rZW5zLmxlbmd0aDtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRva2VuTGVuOyBpKyspIHtcbiAgICAgICAgICAgIHRva2VuID0gdG9rZW5zW2ldO1xuICAgICAgICAgICAgcGFyc2VkSW5wdXQgPSAoc3RyaW5nLm1hdGNoKGdldFBhcnNlUmVnZXhGb3JUb2tlbih0b2tlbiwgY29uZmlnKSkgfHxcbiAgICAgICAgICAgICAgICBbXSlbMF07XG4gICAgICAgICAgICBpZiAocGFyc2VkSW5wdXQpIHtcbiAgICAgICAgICAgICAgICBza2lwcGVkID0gc3RyaW5nLnN1YnN0cigwLCBzdHJpbmcuaW5kZXhPZihwYXJzZWRJbnB1dCkpO1xuICAgICAgICAgICAgICAgIGlmIChza2lwcGVkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykudW51c2VkSW5wdXQucHVzaChza2lwcGVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RyaW5nID0gc3RyaW5nLnNsaWNlKFxuICAgICAgICAgICAgICAgICAgICBzdHJpbmcuaW5kZXhPZihwYXJzZWRJbnB1dCkgKyBwYXJzZWRJbnB1dC5sZW5ndGhcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHRvdGFsUGFyc2VkSW5wdXRMZW5ndGggKz0gcGFyc2VkSW5wdXQubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZG9uJ3QgcGFyc2UgaWYgaXQncyBub3QgYSBrbm93biB0b2tlblxuICAgICAgICAgICAgaWYgKGZvcm1hdFRva2VuRnVuY3Rpb25zW3Rva2VuXSkge1xuICAgICAgICAgICAgICAgIGlmIChwYXJzZWRJbnB1dCkge1xuICAgICAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5lbXB0eSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLnVudXNlZFRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYWRkVGltZVRvQXJyYXlGcm9tVG9rZW4odG9rZW4sIHBhcnNlZElucHV0LCBjb25maWcpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjb25maWcuX3N0cmljdCAmJiAhcGFyc2VkSW5wdXQpIHtcbiAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS51bnVzZWRUb2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhZGQgcmVtYWluaW5nIHVucGFyc2VkIGlucHV0IGxlbmd0aCB0byB0aGUgc3RyaW5nXG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmNoYXJzTGVmdE92ZXIgPVxuICAgICAgICAgICAgc3RyaW5nTGVuZ3RoIC0gdG90YWxQYXJzZWRJbnB1dExlbmd0aDtcbiAgICAgICAgaWYgKHN0cmluZy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS51bnVzZWRJbnB1dC5wdXNoKHN0cmluZyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjbGVhciBfMTJoIGZsYWcgaWYgaG91ciBpcyA8PSAxMlxuICAgICAgICBpZiAoXG4gICAgICAgICAgICBjb25maWcuX2FbSE9VUl0gPD0gMTIgJiZcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmJpZ0hvdXIgPT09IHRydWUgJiZcbiAgICAgICAgICAgIGNvbmZpZy5fYVtIT1VSXSA+IDBcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5iaWdIb3VyID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykucGFyc2VkRGF0ZVBhcnRzID0gY29uZmlnLl9hLnNsaWNlKDApO1xuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5tZXJpZGllbSA9IGNvbmZpZy5fbWVyaWRpZW07XG4gICAgICAgIC8vIGhhbmRsZSBtZXJpZGllbVxuICAgICAgICBjb25maWcuX2FbSE9VUl0gPSBtZXJpZGllbUZpeFdyYXAoXG4gICAgICAgICAgICBjb25maWcuX2xvY2FsZSxcbiAgICAgICAgICAgIGNvbmZpZy5fYVtIT1VSXSxcbiAgICAgICAgICAgIGNvbmZpZy5fbWVyaWRpZW1cbiAgICAgICAgKTtcblxuICAgICAgICAvLyBoYW5kbGUgZXJhXG4gICAgICAgIGVyYSA9IGdldFBhcnNpbmdGbGFncyhjb25maWcpLmVyYTtcbiAgICAgICAgaWYgKGVyYSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uZmlnLl9hW1lFQVJdID0gY29uZmlnLl9sb2NhbGUuZXJhc0NvbnZlcnRZZWFyKGVyYSwgY29uZmlnLl9hW1lFQVJdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbmZpZ0Zyb21BcnJheShjb25maWcpO1xuICAgICAgICBjaGVja092ZXJmbG93KGNvbmZpZyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWVyaWRpZW1GaXhXcmFwKGxvY2FsZSwgaG91ciwgbWVyaWRpZW0pIHtcbiAgICAgICAgdmFyIGlzUG07XG5cbiAgICAgICAgaWYgKG1lcmlkaWVtID09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIG5vdGhpbmcgdG8gZG9cbiAgICAgICAgICAgIHJldHVybiBob3VyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsb2NhbGUubWVyaWRpZW1Ib3VyICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbGUubWVyaWRpZW1Ib3VyKGhvdXIsIG1lcmlkaWVtKTtcbiAgICAgICAgfSBlbHNlIGlmIChsb2NhbGUuaXNQTSAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyBGYWxsYmFja1xuICAgICAgICAgICAgaXNQbSA9IGxvY2FsZS5pc1BNKG1lcmlkaWVtKTtcbiAgICAgICAgICAgIGlmIChpc1BtICYmIGhvdXIgPCAxMikge1xuICAgICAgICAgICAgICAgIGhvdXIgKz0gMTI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzUG0gJiYgaG91ciA9PT0gMTIpIHtcbiAgICAgICAgICAgICAgICBob3VyID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBob3VyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gdGhpcyBpcyBub3Qgc3VwcG9zZWQgdG8gaGFwcGVuXG4gICAgICAgICAgICByZXR1cm4gaG91cjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGRhdGUgZnJvbSBzdHJpbmcgYW5kIGFycmF5IG9mIGZvcm1hdCBzdHJpbmdzXG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbVN0cmluZ0FuZEFycmF5KGNvbmZpZykge1xuICAgICAgICB2YXIgdGVtcENvbmZpZyxcbiAgICAgICAgICAgIGJlc3RNb21lbnQsXG4gICAgICAgICAgICBzY29yZVRvQmVhdCxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBjdXJyZW50U2NvcmUsXG4gICAgICAgICAgICB2YWxpZEZvcm1hdEZvdW5kLFxuICAgICAgICAgICAgYmVzdEZvcm1hdElzVmFsaWQgPSBmYWxzZSxcbiAgICAgICAgICAgIGNvbmZpZ2ZMZW4gPSBjb25maWcuX2YubGVuZ3RoO1xuXG4gICAgICAgIGlmIChjb25maWdmTGVuID09PSAwKSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5pbnZhbGlkRm9ybWF0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKE5hTik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY29uZmlnZkxlbjsgaSsrKSB7XG4gICAgICAgICAgICBjdXJyZW50U2NvcmUgPSAwO1xuICAgICAgICAgICAgdmFsaWRGb3JtYXRGb3VuZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGVtcENvbmZpZyA9IGNvcHlDb25maWcoe30sIGNvbmZpZyk7XG4gICAgICAgICAgICBpZiAoY29uZmlnLl91c2VVVEMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRlbXBDb25maWcuX3VzZVVUQyA9IGNvbmZpZy5fdXNlVVRDO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGVtcENvbmZpZy5fZiA9IGNvbmZpZy5fZltpXTtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21TdHJpbmdBbmRGb3JtYXQodGVtcENvbmZpZyk7XG5cbiAgICAgICAgICAgIGlmIChpc1ZhbGlkKHRlbXBDb25maWcpKSB7XG4gICAgICAgICAgICAgICAgdmFsaWRGb3JtYXRGb3VuZCA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIGFueSBpbnB1dCB0aGF0IHdhcyBub3QgcGFyc2VkIGFkZCBhIHBlbmFsdHkgZm9yIHRoYXQgZm9ybWF0XG4gICAgICAgICAgICBjdXJyZW50U2NvcmUgKz0gZ2V0UGFyc2luZ0ZsYWdzKHRlbXBDb25maWcpLmNoYXJzTGVmdE92ZXI7XG5cbiAgICAgICAgICAgIC8vb3IgdG9rZW5zXG4gICAgICAgICAgICBjdXJyZW50U2NvcmUgKz0gZ2V0UGFyc2luZ0ZsYWdzKHRlbXBDb25maWcpLnVudXNlZFRva2Vucy5sZW5ndGggKiAxMDtcblxuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKHRlbXBDb25maWcpLnNjb3JlID0gY3VycmVudFNjb3JlO1xuXG4gICAgICAgICAgICBpZiAoIWJlc3RGb3JtYXRJc1ZhbGlkKSB7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICBzY29yZVRvQmVhdCA9PSBudWxsIHx8XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTY29yZSA8IHNjb3JlVG9CZWF0IHx8XG4gICAgICAgICAgICAgICAgICAgIHZhbGlkRm9ybWF0Rm91bmRcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgc2NvcmVUb0JlYXQgPSBjdXJyZW50U2NvcmU7XG4gICAgICAgICAgICAgICAgICAgIGJlc3RNb21lbnQgPSB0ZW1wQ29uZmlnO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsaWRGb3JtYXRGb3VuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmVzdEZvcm1hdElzVmFsaWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudFNjb3JlIDwgc2NvcmVUb0JlYXQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2NvcmVUb0JlYXQgPSBjdXJyZW50U2NvcmU7XG4gICAgICAgICAgICAgICAgICAgIGJlc3RNb21lbnQgPSB0ZW1wQ29uZmlnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGV4dGVuZChjb25maWcsIGJlc3RNb21lbnQgfHwgdGVtcENvbmZpZyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbU9iamVjdChjb25maWcpIHtcbiAgICAgICAgaWYgKGNvbmZpZy5fZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGkgPSBub3JtYWxpemVPYmplY3RVbml0cyhjb25maWcuX2kpLFxuICAgICAgICAgICAgZGF5T3JEYXRlID0gaS5kYXkgPT09IHVuZGVmaW5lZCA/IGkuZGF0ZSA6IGkuZGF5O1xuICAgICAgICBjb25maWcuX2EgPSBtYXAoXG4gICAgICAgICAgICBbaS55ZWFyLCBpLm1vbnRoLCBkYXlPckRhdGUsIGkuaG91ciwgaS5taW51dGUsIGkuc2Vjb25kLCBpLm1pbGxpc2Vjb25kXSxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqICYmIHBhcnNlSW50KG9iaiwgMTApO1xuICAgICAgICAgICAgfVxuICAgICAgICApO1xuXG4gICAgICAgIGNvbmZpZ0Zyb21BcnJheShjb25maWcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUZyb21Db25maWcoY29uZmlnKSB7XG4gICAgICAgIHZhciByZXMgPSBuZXcgTW9tZW50KGNoZWNrT3ZlcmZsb3cocHJlcGFyZUNvbmZpZyhjb25maWcpKSk7XG4gICAgICAgIGlmIChyZXMuX25leHREYXkpIHtcbiAgICAgICAgICAgIC8vIEFkZGluZyBpcyBzbWFydCBlbm91Z2ggYXJvdW5kIERTVFxuICAgICAgICAgICAgcmVzLmFkZCgxLCAnZCcpO1xuICAgICAgICAgICAgcmVzLl9uZXh0RGF5ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcmVwYXJlQ29uZmlnKGNvbmZpZykge1xuICAgICAgICB2YXIgaW5wdXQgPSBjb25maWcuX2ksXG4gICAgICAgICAgICBmb3JtYXQgPSBjb25maWcuX2Y7XG5cbiAgICAgICAgY29uZmlnLl9sb2NhbGUgPSBjb25maWcuX2xvY2FsZSB8fCBnZXRMb2NhbGUoY29uZmlnLl9sKTtcblxuICAgICAgICBpZiAoaW5wdXQgPT09IG51bGwgfHwgKGZvcm1hdCA9PT0gdW5kZWZpbmVkICYmIGlucHV0ID09PSAnJykpIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVJbnZhbGlkKHsgbnVsbElucHV0OiB0cnVlIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNvbmZpZy5faSA9IGlucHV0ID0gY29uZmlnLl9sb2NhbGUucHJlcGFyc2UoaW5wdXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzTW9tZW50KGlucHV0KSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBNb21lbnQoY2hlY2tPdmVyZmxvdyhpbnB1dCkpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzRGF0ZShpbnB1dCkpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IGlucHV0O1xuICAgICAgICB9IGVsc2UgaWYgKGlzQXJyYXkoZm9ybWF0KSkge1xuICAgICAgICAgICAgY29uZmlnRnJvbVN0cmluZ0FuZEFycmF5KGNvbmZpZyk7XG4gICAgICAgIH0gZWxzZSBpZiAoZm9ybWF0KSB7XG4gICAgICAgICAgICBjb25maWdGcm9tU3RyaW5nQW5kRm9ybWF0KGNvbmZpZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25maWdGcm9tSW5wdXQoY29uZmlnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNWYWxpZChjb25maWcpKSB7XG4gICAgICAgICAgICBjb25maWcuX2QgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbmZpZztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb25maWdGcm9tSW5wdXQoY29uZmlnKSB7XG4gICAgICAgIHZhciBpbnB1dCA9IGNvbmZpZy5faTtcbiAgICAgICAgaWYgKGlzVW5kZWZpbmVkKGlucHV0KSkge1xuICAgICAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoaG9va3Mubm93KCkpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzRGF0ZShpbnB1dCkpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKGlucHV0LnZhbHVlT2YoKSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY29uZmlnRnJvbVN0cmluZyhjb25maWcpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICAgICAgICBjb25maWcuX2EgPSBtYXAoaW5wdXQuc2xpY2UoMCksIGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQob2JqLCAxMCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21BcnJheShjb25maWcpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KGlucHV0KSkge1xuICAgICAgICAgICAgY29uZmlnRnJvbU9iamVjdChjb25maWcpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzTnVtYmVyKGlucHV0KSkge1xuICAgICAgICAgICAgLy8gZnJvbSBtaWxsaXNlY29uZHNcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKGlucHV0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGhvb2tzLmNyZWF0ZUZyb21JbnB1dEZhbGxiYWNrKGNvbmZpZyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVMb2NhbE9yVVRDKGlucHV0LCBmb3JtYXQsIGxvY2FsZSwgc3RyaWN0LCBpc1VUQykge1xuICAgICAgICB2YXIgYyA9IHt9O1xuXG4gICAgICAgIGlmIChmb3JtYXQgPT09IHRydWUgfHwgZm9ybWF0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgc3RyaWN0ID0gZm9ybWF0O1xuICAgICAgICAgICAgZm9ybWF0ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxvY2FsZSA9PT0gdHJ1ZSB8fCBsb2NhbGUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBzdHJpY3QgPSBsb2NhbGU7XG4gICAgICAgICAgICBsb2NhbGUgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoXG4gICAgICAgICAgICAoaXNPYmplY3QoaW5wdXQpICYmIGlzT2JqZWN0RW1wdHkoaW5wdXQpKSB8fFxuICAgICAgICAgICAgKGlzQXJyYXkoaW5wdXQpICYmIGlucHV0Lmxlbmd0aCA9PT0gMClcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBpbnB1dCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBvYmplY3QgY29uc3RydWN0aW9uIG11c3QgYmUgZG9uZSB0aGlzIHdheS5cbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21vbWVudC9tb21lbnQvaXNzdWVzLzE0MjNcbiAgICAgICAgYy5faXNBTW9tZW50T2JqZWN0ID0gdHJ1ZTtcbiAgICAgICAgYy5fdXNlVVRDID0gYy5faXNVVEMgPSBpc1VUQztcbiAgICAgICAgYy5fbCA9IGxvY2FsZTtcbiAgICAgICAgYy5faSA9IGlucHV0O1xuICAgICAgICBjLl9mID0gZm9ybWF0O1xuICAgICAgICBjLl9zdHJpY3QgPSBzdHJpY3Q7XG5cbiAgICAgICAgcmV0dXJuIGNyZWF0ZUZyb21Db25maWcoYyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlTG9jYWwoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUxvY2FsT3JVVEMoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QsIGZhbHNlKTtcbiAgICB9XG5cbiAgICB2YXIgcHJvdG90eXBlTWluID0gZGVwcmVjYXRlKFxuICAgICAgICAgICAgJ21vbWVudCgpLm1pbiBpcyBkZXByZWNhdGVkLCB1c2UgbW9tZW50Lm1heCBpbnN0ZWFkLiBodHRwOi8vbW9tZW50anMuY29tL2d1aWRlcy8jL3dhcm5pbmdzL21pbi1tYXgvJyxcbiAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgb3RoZXIgPSBjcmVhdGVMb2NhbC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzVmFsaWQoKSAmJiBvdGhlci5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG90aGVyIDwgdGhpcyA/IHRoaXMgOiBvdGhlcjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlSW52YWxpZCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgKSxcbiAgICAgICAgcHJvdG90eXBlTWF4ID0gZGVwcmVjYXRlKFxuICAgICAgICAgICAgJ21vbWVudCgpLm1heCBpcyBkZXByZWNhdGVkLCB1c2UgbW9tZW50Lm1pbiBpbnN0ZWFkLiBodHRwOi8vbW9tZW50anMuY29tL2d1aWRlcy8jL3dhcm5pbmdzL21pbi1tYXgvJyxcbiAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgb3RoZXIgPSBjcmVhdGVMb2NhbC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzVmFsaWQoKSAmJiBvdGhlci5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG90aGVyID4gdGhpcyA/IHRoaXMgOiBvdGhlcjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlSW52YWxpZCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgKTtcblxuICAgIC8vIFBpY2sgYSBtb21lbnQgbSBmcm9tIG1vbWVudHMgc28gdGhhdCBtW2ZuXShvdGhlcikgaXMgdHJ1ZSBmb3IgYWxsXG4gICAgLy8gb3RoZXIuIFRoaXMgcmVsaWVzIG9uIHRoZSBmdW5jdGlvbiBmbiB0byBiZSB0cmFuc2l0aXZlLlxuICAgIC8vXG4gICAgLy8gbW9tZW50cyBzaG91bGQgZWl0aGVyIGJlIGFuIGFycmF5IG9mIG1vbWVudCBvYmplY3RzIG9yIGFuIGFycmF5LCB3aG9zZVxuICAgIC8vIGZpcnN0IGVsZW1lbnQgaXMgYW4gYXJyYXkgb2YgbW9tZW50IG9iamVjdHMuXG4gICAgZnVuY3Rpb24gcGlja0J5KGZuLCBtb21lbnRzKSB7XG4gICAgICAgIHZhciByZXMsIGk7XG4gICAgICAgIGlmIChtb21lbnRzLmxlbmd0aCA9PT0gMSAmJiBpc0FycmF5KG1vbWVudHNbMF0pKSB7XG4gICAgICAgICAgICBtb21lbnRzID0gbW9tZW50c1swXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW1vbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlTG9jYWwoKTtcbiAgICAgICAgfVxuICAgICAgICByZXMgPSBtb21lbnRzWzBdO1xuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgbW9tZW50cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKCFtb21lbnRzW2ldLmlzVmFsaWQoKSB8fCBtb21lbnRzW2ldW2ZuXShyZXMpKSB7XG4gICAgICAgICAgICAgICAgcmVzID0gbW9tZW50c1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIC8vIFRPRE86IFVzZSBbXS5zb3J0IGluc3RlYWQ/XG4gICAgZnVuY3Rpb24gbWluKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcblxuICAgICAgICByZXR1cm4gcGlja0J5KCdpc0JlZm9yZScsIGFyZ3MpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1heCgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG5cbiAgICAgICAgcmV0dXJuIHBpY2tCeSgnaXNBZnRlcicsIGFyZ3MpO1xuICAgIH1cblxuICAgIHZhciBub3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBEYXRlLm5vdyA/IERhdGUubm93KCkgOiArbmV3IERhdGUoKTtcbiAgICB9O1xuXG4gICAgdmFyIG9yZGVyaW5nID0gW1xuICAgICAgICAneWVhcicsXG4gICAgICAgICdxdWFydGVyJyxcbiAgICAgICAgJ21vbnRoJyxcbiAgICAgICAgJ3dlZWsnLFxuICAgICAgICAnZGF5JyxcbiAgICAgICAgJ2hvdXInLFxuICAgICAgICAnbWludXRlJyxcbiAgICAgICAgJ3NlY29uZCcsXG4gICAgICAgICdtaWxsaXNlY29uZCcsXG4gICAgXTtcblxuICAgIGZ1bmN0aW9uIGlzRHVyYXRpb25WYWxpZChtKSB7XG4gICAgICAgIHZhciBrZXksXG4gICAgICAgICAgICB1bml0SGFzRGVjaW1hbCA9IGZhbHNlLFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIG9yZGVyTGVuID0gb3JkZXJpbmcubGVuZ3RoO1xuICAgICAgICBmb3IgKGtleSBpbiBtKSB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgaGFzT3duUHJvcChtLCBrZXkpICYmXG4gICAgICAgICAgICAgICAgIShcbiAgICAgICAgICAgICAgICAgICAgaW5kZXhPZi5jYWxsKG9yZGVyaW5nLCBrZXkpICE9PSAtMSAmJlxuICAgICAgICAgICAgICAgICAgICAobVtrZXldID09IG51bGwgfHwgIWlzTmFOKG1ba2V5XSkpXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG9yZGVyTGVuOyArK2kpIHtcbiAgICAgICAgICAgIGlmIChtW29yZGVyaW5nW2ldXSkge1xuICAgICAgICAgICAgICAgIGlmICh1bml0SGFzRGVjaW1hbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIG9ubHkgYWxsb3cgbm9uLWludGVnZXJzIGZvciBzbWFsbGVzdCB1bml0XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwYXJzZUZsb2F0KG1bb3JkZXJpbmdbaV1dKSAhPT0gdG9JbnQobVtvcmRlcmluZ1tpXV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHVuaXRIYXNEZWNpbWFsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1ZhbGlkJDEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc1ZhbGlkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUludmFsaWQkMSgpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUR1cmF0aW9uKE5hTik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gRHVyYXRpb24oZHVyYXRpb24pIHtcbiAgICAgICAgdmFyIG5vcm1hbGl6ZWRJbnB1dCA9IG5vcm1hbGl6ZU9iamVjdFVuaXRzKGR1cmF0aW9uKSxcbiAgICAgICAgICAgIHllYXJzID0gbm9ybWFsaXplZElucHV0LnllYXIgfHwgMCxcbiAgICAgICAgICAgIHF1YXJ0ZXJzID0gbm9ybWFsaXplZElucHV0LnF1YXJ0ZXIgfHwgMCxcbiAgICAgICAgICAgIG1vbnRocyA9IG5vcm1hbGl6ZWRJbnB1dC5tb250aCB8fCAwLFxuICAgICAgICAgICAgd2Vla3MgPSBub3JtYWxpemVkSW5wdXQud2VlayB8fCBub3JtYWxpemVkSW5wdXQuaXNvV2VlayB8fCAwLFxuICAgICAgICAgICAgZGF5cyA9IG5vcm1hbGl6ZWRJbnB1dC5kYXkgfHwgMCxcbiAgICAgICAgICAgIGhvdXJzID0gbm9ybWFsaXplZElucHV0LmhvdXIgfHwgMCxcbiAgICAgICAgICAgIG1pbnV0ZXMgPSBub3JtYWxpemVkSW5wdXQubWludXRlIHx8IDAsXG4gICAgICAgICAgICBzZWNvbmRzID0gbm9ybWFsaXplZElucHV0LnNlY29uZCB8fCAwLFxuICAgICAgICAgICAgbWlsbGlzZWNvbmRzID0gbm9ybWFsaXplZElucHV0Lm1pbGxpc2Vjb25kIHx8IDA7XG5cbiAgICAgICAgdGhpcy5faXNWYWxpZCA9IGlzRHVyYXRpb25WYWxpZChub3JtYWxpemVkSW5wdXQpO1xuXG4gICAgICAgIC8vIHJlcHJlc2VudGF0aW9uIGZvciBkYXRlQWRkUmVtb3ZlXG4gICAgICAgIHRoaXMuX21pbGxpc2Vjb25kcyA9XG4gICAgICAgICAgICArbWlsbGlzZWNvbmRzICtcbiAgICAgICAgICAgIHNlY29uZHMgKiAxZTMgKyAvLyAxMDAwXG4gICAgICAgICAgICBtaW51dGVzICogNmU0ICsgLy8gMTAwMCAqIDYwXG4gICAgICAgICAgICBob3VycyAqIDEwMDAgKiA2MCAqIDYwOyAvL3VzaW5nIDEwMDAgKiA2MCAqIDYwIGluc3RlYWQgb2YgMzZlNSB0byBhdm9pZCBmbG9hdGluZyBwb2ludCByb3VuZGluZyBlcnJvcnMgaHR0cHM6Ly9naXRodWIuY29tL21vbWVudC9tb21lbnQvaXNzdWVzLzI5NzhcbiAgICAgICAgLy8gQmVjYXVzZSBvZiBkYXRlQWRkUmVtb3ZlIHRyZWF0cyAyNCBob3VycyBhcyBkaWZmZXJlbnQgZnJvbSBhXG4gICAgICAgIC8vIGRheSB3aGVuIHdvcmtpbmcgYXJvdW5kIERTVCwgd2UgbmVlZCB0byBzdG9yZSB0aGVtIHNlcGFyYXRlbHlcbiAgICAgICAgdGhpcy5fZGF5cyA9ICtkYXlzICsgd2Vla3MgKiA3O1xuICAgICAgICAvLyBJdCBpcyBpbXBvc3NpYmxlIHRvIHRyYW5zbGF0ZSBtb250aHMgaW50byBkYXlzIHdpdGhvdXQga25vd2luZ1xuICAgICAgICAvLyB3aGljaCBtb250aHMgeW91IGFyZSBhcmUgdGFsa2luZyBhYm91dCwgc28gd2UgaGF2ZSB0byBzdG9yZVxuICAgICAgICAvLyBpdCBzZXBhcmF0ZWx5LlxuICAgICAgICB0aGlzLl9tb250aHMgPSArbW9udGhzICsgcXVhcnRlcnMgKiAzICsgeWVhcnMgKiAxMjtcblxuICAgICAgICB0aGlzLl9kYXRhID0ge307XG5cbiAgICAgICAgdGhpcy5fbG9jYWxlID0gZ2V0TG9jYWxlKCk7XG5cbiAgICAgICAgdGhpcy5fYnViYmxlKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNEdXJhdGlvbihvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIER1cmF0aW9uO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFic1JvdW5kKG51bWJlcikge1xuICAgICAgICBpZiAobnVtYmVyIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgucm91bmQoLTEgKiBudW1iZXIpICogLTE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5yb3VuZChudW1iZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gY29tcGFyZSB0d28gYXJyYXlzLCByZXR1cm4gdGhlIG51bWJlciBvZiBkaWZmZXJlbmNlc1xuICAgIGZ1bmN0aW9uIGNvbXBhcmVBcnJheXMoYXJyYXkxLCBhcnJheTIsIGRvbnRDb252ZXJ0KSB7XG4gICAgICAgIHZhciBsZW4gPSBNYXRoLm1pbihhcnJheTEubGVuZ3RoLCBhcnJheTIubGVuZ3RoKSxcbiAgICAgICAgICAgIGxlbmd0aERpZmYgPSBNYXRoLmFicyhhcnJheTEubGVuZ3RoIC0gYXJyYXkyLmxlbmd0aCksXG4gICAgICAgICAgICBkaWZmcyA9IDAsXG4gICAgICAgICAgICBpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAoZG9udENvbnZlcnQgJiYgYXJyYXkxW2ldICE9PSBhcnJheTJbaV0pIHx8XG4gICAgICAgICAgICAgICAgKCFkb250Q29udmVydCAmJiB0b0ludChhcnJheTFbaV0pICE9PSB0b0ludChhcnJheTJbaV0pKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgZGlmZnMrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGlmZnMgKyBsZW5ndGhEaWZmO1xuICAgIH1cblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGZ1bmN0aW9uIG9mZnNldCh0b2tlbiwgc2VwYXJhdG9yKSB7XG4gICAgICAgIGFkZEZvcm1hdFRva2VuKHRva2VuLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy51dGNPZmZzZXQoKSxcbiAgICAgICAgICAgICAgICBzaWduID0gJysnO1xuICAgICAgICAgICAgaWYgKG9mZnNldCA8IDApIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSAtb2Zmc2V0O1xuICAgICAgICAgICAgICAgIHNpZ24gPSAnLSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIHNpZ24gK1xuICAgICAgICAgICAgICAgIHplcm9GaWxsKH5+KG9mZnNldCAvIDYwKSwgMikgK1xuICAgICAgICAgICAgICAgIHNlcGFyYXRvciArXG4gICAgICAgICAgICAgICAgemVyb0ZpbGwofn5vZmZzZXQgJSA2MCwgMilcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIG9mZnNldCgnWicsICc6Jyk7XG4gICAgb2Zmc2V0KCdaWicsICcnKTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ1onLCBtYXRjaFNob3J0T2Zmc2V0KTtcbiAgICBhZGRSZWdleFRva2VuKCdaWicsIG1hdGNoU2hvcnRPZmZzZXQpO1xuICAgIGFkZFBhcnNlVG9rZW4oWydaJywgJ1paJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICBjb25maWcuX3VzZVVUQyA9IHRydWU7XG4gICAgICAgIGNvbmZpZy5fdHptID0gb2Zmc2V0RnJvbVN0cmluZyhtYXRjaFNob3J0T2Zmc2V0LCBpbnB1dCk7XG4gICAgfSk7XG5cbiAgICAvLyBIRUxQRVJTXG5cbiAgICAvLyB0aW1lem9uZSBjaHVua2VyXG4gICAgLy8gJysxMDowMCcgPiBbJzEwJywgICcwMCddXG4gICAgLy8gJy0xNTMwJyAgPiBbJy0xNScsICczMCddXG4gICAgdmFyIGNodW5rT2Zmc2V0ID0gLyhbXFwrXFwtXXxcXGRcXGQpL2dpO1xuXG4gICAgZnVuY3Rpb24gb2Zmc2V0RnJvbVN0cmluZyhtYXRjaGVyLCBzdHJpbmcpIHtcbiAgICAgICAgdmFyIG1hdGNoZXMgPSAoc3RyaW5nIHx8ICcnKS5tYXRjaChtYXRjaGVyKSxcbiAgICAgICAgICAgIGNodW5rLFxuICAgICAgICAgICAgcGFydHMsXG4gICAgICAgICAgICBtaW51dGVzO1xuXG4gICAgICAgIGlmIChtYXRjaGVzID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNodW5rID0gbWF0Y2hlc1ttYXRjaGVzLmxlbmd0aCAtIDFdIHx8IFtdO1xuICAgICAgICBwYXJ0cyA9IChjaHVuayArICcnKS5tYXRjaChjaHVua09mZnNldCkgfHwgWyctJywgMCwgMF07XG4gICAgICAgIG1pbnV0ZXMgPSArKHBhcnRzWzFdICogNjApICsgdG9JbnQocGFydHNbMl0pO1xuXG4gICAgICAgIHJldHVybiBtaW51dGVzID09PSAwID8gMCA6IHBhcnRzWzBdID09PSAnKycgPyBtaW51dGVzIDogLW1pbnV0ZXM7XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIGEgbW9tZW50IGZyb20gaW5wdXQsIHRoYXQgaXMgbG9jYWwvdXRjL3pvbmUgZXF1aXZhbGVudCB0byBtb2RlbC5cbiAgICBmdW5jdGlvbiBjbG9uZVdpdGhPZmZzZXQoaW5wdXQsIG1vZGVsKSB7XG4gICAgICAgIHZhciByZXMsIGRpZmY7XG4gICAgICAgIGlmIChtb2RlbC5faXNVVEMpIHtcbiAgICAgICAgICAgIHJlcyA9IG1vZGVsLmNsb25lKCk7XG4gICAgICAgICAgICBkaWZmID1cbiAgICAgICAgICAgICAgICAoaXNNb21lbnQoaW5wdXQpIHx8IGlzRGF0ZShpbnB1dClcbiAgICAgICAgICAgICAgICAgICAgPyBpbnB1dC52YWx1ZU9mKClcbiAgICAgICAgICAgICAgICAgICAgOiBjcmVhdGVMb2NhbChpbnB1dCkudmFsdWVPZigpKSAtIHJlcy52YWx1ZU9mKCk7XG4gICAgICAgICAgICAvLyBVc2UgbG93LWxldmVsIGFwaSwgYmVjYXVzZSB0aGlzIGZuIGlzIGxvdy1sZXZlbCBhcGkuXG4gICAgICAgICAgICByZXMuX2Quc2V0VGltZShyZXMuX2QudmFsdWVPZigpICsgZGlmZik7XG4gICAgICAgICAgICBob29rcy51cGRhdGVPZmZzZXQocmVzLCBmYWxzZSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUxvY2FsKGlucHV0KS5sb2NhbCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0RGF0ZU9mZnNldChtKSB7XG4gICAgICAgIC8vIE9uIEZpcmVmb3guMjQgRGF0ZSNnZXRUaW1lem9uZU9mZnNldCByZXR1cm5zIGEgZmxvYXRpbmcgcG9pbnQuXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tb21lbnQvbW9tZW50L3B1bGwvMTg3MVxuICAgICAgICByZXR1cm4gLU1hdGgucm91bmQobS5fZC5nZXRUaW1lem9uZU9mZnNldCgpKTtcbiAgICB9XG5cbiAgICAvLyBIT09LU1xuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCB3aGVuZXZlciBhIG1vbWVudCBpcyBtdXRhdGVkLlxuICAgIC8vIEl0IGlzIGludGVuZGVkIHRvIGtlZXAgdGhlIG9mZnNldCBpbiBzeW5jIHdpdGggdGhlIHRpbWV6b25lLlxuICAgIGhvb2tzLnVwZGF0ZU9mZnNldCA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgLy8ga2VlcExvY2FsVGltZSA9IHRydWUgbWVhbnMgb25seSBjaGFuZ2UgdGhlIHRpbWV6b25lLCB3aXRob3V0XG4gICAgLy8gYWZmZWN0aW5nIHRoZSBsb2NhbCBob3VyLiBTbyA1OjMxOjI2ICswMzAwIC0tW3V0Y09mZnNldCgyLCB0cnVlKV0tLT5cbiAgICAvLyA1OjMxOjI2ICswMjAwIEl0IGlzIHBvc3NpYmxlIHRoYXQgNTozMToyNiBkb2Vzbid0IGV4aXN0IHdpdGggb2Zmc2V0XG4gICAgLy8gKzAyMDAsIHNvIHdlIGFkanVzdCB0aGUgdGltZSBhcyBuZWVkZWQsIHRvIGJlIHZhbGlkLlxuICAgIC8vXG4gICAgLy8gS2VlcGluZyB0aGUgdGltZSBhY3R1YWxseSBhZGRzL3N1YnRyYWN0cyAob25lIGhvdXIpXG4gICAgLy8gZnJvbSB0aGUgYWN0dWFsIHJlcHJlc2VudGVkIHRpbWUuIFRoYXQgaXMgd2h5IHdlIGNhbGwgdXBkYXRlT2Zmc2V0XG4gICAgLy8gYSBzZWNvbmQgdGltZS4gSW4gY2FzZSBpdCB3YW50cyB1cyB0byBjaGFuZ2UgdGhlIG9mZnNldCBhZ2FpblxuICAgIC8vIF9jaGFuZ2VJblByb2dyZXNzID09IHRydWUgY2FzZSwgdGhlbiB3ZSBoYXZlIHRvIGFkanVzdCwgYmVjYXVzZVxuICAgIC8vIHRoZXJlIGlzIG5vIHN1Y2ggdGltZSBpbiB0aGUgZ2l2ZW4gdGltZXpvbmUuXG4gICAgZnVuY3Rpb24gZ2V0U2V0T2Zmc2V0KGlucHV0LCBrZWVwTG9jYWxUaW1lLCBrZWVwTWludXRlcykge1xuICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5fb2Zmc2V0IHx8IDAsXG4gICAgICAgICAgICBsb2NhbEFkanVzdDtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0ICE9IG51bGwgPyB0aGlzIDogTmFOO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbnB1dCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGlucHV0ID0gb2Zmc2V0RnJvbVN0cmluZyhtYXRjaFNob3J0T2Zmc2V0LCBpbnB1dCk7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoTWF0aC5hYnMoaW5wdXQpIDwgMTYgJiYgIWtlZXBNaW51dGVzKSB7XG4gICAgICAgICAgICAgICAgaW5wdXQgPSBpbnB1dCAqIDYwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLl9pc1VUQyAmJiBrZWVwTG9jYWxUaW1lKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxBZGp1c3QgPSBnZXREYXRlT2Zmc2V0KHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fb2Zmc2V0ID0gaW5wdXQ7XG4gICAgICAgICAgICB0aGlzLl9pc1VUQyA9IHRydWU7XG4gICAgICAgICAgICBpZiAobG9jYWxBZGp1c3QgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkKGxvY2FsQWRqdXN0LCAnbScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9mZnNldCAhPT0gaW5wdXQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWtlZXBMb2NhbFRpbWUgfHwgdGhpcy5fY2hhbmdlSW5Qcm9ncmVzcykge1xuICAgICAgICAgICAgICAgICAgICBhZGRTdWJ0cmFjdChcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBjcmVhdGVEdXJhdGlvbihpbnB1dCAtIG9mZnNldCwgJ20nKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIDEsXG4gICAgICAgICAgICAgICAgICAgICAgICBmYWxzZVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIXRoaXMuX2NoYW5nZUluUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2hhbmdlSW5Qcm9ncmVzcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGhvb2tzLnVwZGF0ZU9mZnNldCh0aGlzLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2hhbmdlSW5Qcm9ncmVzcyA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faXNVVEMgPyBvZmZzZXQgOiBnZXREYXRlT2Zmc2V0KHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2V0Wm9uZShpbnB1dCwga2VlcExvY2FsVGltZSkge1xuICAgICAgICBpZiAoaW5wdXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBpbnB1dCA9IC1pbnB1dDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy51dGNPZmZzZXQoaW5wdXQsIGtlZXBMb2NhbFRpbWUpO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAtdGhpcy51dGNPZmZzZXQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldE9mZnNldFRvVVRDKGtlZXBMb2NhbFRpbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudXRjT2Zmc2V0KDAsIGtlZXBMb2NhbFRpbWUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldE9mZnNldFRvTG9jYWwoa2VlcExvY2FsVGltZSkge1xuICAgICAgICBpZiAodGhpcy5faXNVVEMpIHtcbiAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KDAsIGtlZXBMb2NhbFRpbWUpO1xuICAgICAgICAgICAgdGhpcy5faXNVVEMgPSBmYWxzZTtcblxuICAgICAgICAgICAgaWYgKGtlZXBMb2NhbFRpbWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN1YnRyYWN0KGdldERhdGVPZmZzZXQodGhpcyksICdtJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0T2Zmc2V0VG9QYXJzZWRPZmZzZXQoKSB7XG4gICAgICAgIGlmICh0aGlzLl90em0gIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy51dGNPZmZzZXQodGhpcy5fdHptLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHRoaXMuX2kgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB2YXIgdFpvbmUgPSBvZmZzZXRGcm9tU3RyaW5nKG1hdGNoT2Zmc2V0LCB0aGlzLl9pKTtcbiAgICAgICAgICAgIGlmICh0Wm9uZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51dGNPZmZzZXQodFpvbmUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnV0Y09mZnNldCgwLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYXNBbGlnbmVkSG91ck9mZnNldChpbnB1dCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaW5wdXQgPSBpbnB1dCA/IGNyZWF0ZUxvY2FsKGlucHV0KS51dGNPZmZzZXQoKSA6IDA7XG5cbiAgICAgICAgcmV0dXJuICh0aGlzLnV0Y09mZnNldCgpIC0gaW5wdXQpICUgNjAgPT09IDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNEYXlsaWdodFNhdmluZ1RpbWUoKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB0aGlzLnV0Y09mZnNldCgpID4gdGhpcy5jbG9uZSgpLm1vbnRoKDApLnV0Y09mZnNldCgpIHx8XG4gICAgICAgICAgICB0aGlzLnV0Y09mZnNldCgpID4gdGhpcy5jbG9uZSgpLm1vbnRoKDUpLnV0Y09mZnNldCgpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNEYXlsaWdodFNhdmluZ1RpbWVTaGlmdGVkKCkge1xuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKHRoaXMuX2lzRFNUU2hpZnRlZCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pc0RTVFNoaWZ0ZWQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYyA9IHt9LFxuICAgICAgICAgICAgb3RoZXI7XG5cbiAgICAgICAgY29weUNvbmZpZyhjLCB0aGlzKTtcbiAgICAgICAgYyA9IHByZXBhcmVDb25maWcoYyk7XG5cbiAgICAgICAgaWYgKGMuX2EpIHtcbiAgICAgICAgICAgIG90aGVyID0gYy5faXNVVEMgPyBjcmVhdGVVVEMoYy5fYSkgOiBjcmVhdGVMb2NhbChjLl9hKTtcbiAgICAgICAgICAgIHRoaXMuX2lzRFNUU2hpZnRlZCA9XG4gICAgICAgICAgICAgICAgdGhpcy5pc1ZhbGlkKCkgJiYgY29tcGFyZUFycmF5cyhjLl9hLCBvdGhlci50b0FycmF5KCkpID4gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2lzRFNUU2hpZnRlZCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzRFNUU2hpZnRlZDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0xvY2FsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1ZhbGlkKCkgPyAhdGhpcy5faXNVVEMgOiBmYWxzZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1V0Y09mZnNldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNWYWxpZCgpID8gdGhpcy5faXNVVEMgOiBmYWxzZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1V0YygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNWYWxpZCgpID8gdGhpcy5faXNVVEMgJiYgdGhpcy5fb2Zmc2V0ID09PSAwIDogZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gQVNQLk5FVCBqc29uIGRhdGUgZm9ybWF0IHJlZ2V4XG4gICAgdmFyIGFzcE5ldFJlZ2V4ID0gL14oLXxcXCspPyg/OihcXGQqKVsuIF0pPyhcXGQrKTooXFxkKykoPzo6KFxcZCspKFxcLlxcZCopPyk/JC8sXG4gICAgICAgIC8vIGZyb20gaHR0cDovL2RvY3MuY2xvc3VyZS1saWJyYXJ5Lmdvb2dsZWNvZGUuY29tL2dpdC9jbG9zdXJlX2dvb2dfZGF0ZV9kYXRlLmpzLnNvdXJjZS5odG1sXG4gICAgICAgIC8vIHNvbWV3aGF0IG1vcmUgaW4gbGluZSB3aXRoIDQuNC4zLjIgMjAwNCBzcGVjLCBidXQgYWxsb3dzIGRlY2ltYWwgYW55d2hlcmVcbiAgICAgICAgLy8gYW5kIGZ1cnRoZXIgbW9kaWZpZWQgdG8gYWxsb3cgZm9yIHN0cmluZ3MgY29udGFpbmluZyBib3RoIHdlZWsgYW5kIGRheVxuICAgICAgICBpc29SZWdleCA9XG4gICAgICAgICAgICAvXigtfFxcKyk/UCg/OihbLStdP1swLTksLl0qKVkpPyg/OihbLStdP1swLTksLl0qKU0pPyg/OihbLStdP1swLTksLl0qKVcpPyg/OihbLStdP1swLTksLl0qKUQpPyg/OlQoPzooWy0rXT9bMC05LC5dKilIKT8oPzooWy0rXT9bMC05LC5dKilNKT8oPzooWy0rXT9bMC05LC5dKilTKT8pPyQvO1xuXG4gICAgZnVuY3Rpb24gY3JlYXRlRHVyYXRpb24oaW5wdXQsIGtleSkge1xuICAgICAgICB2YXIgZHVyYXRpb24gPSBpbnB1dCxcbiAgICAgICAgICAgIC8vIG1hdGNoaW5nIGFnYWluc3QgcmVnZXhwIGlzIGV4cGVuc2l2ZSwgZG8gaXQgb24gZGVtYW5kXG4gICAgICAgICAgICBtYXRjaCA9IG51bGwsXG4gICAgICAgICAgICBzaWduLFxuICAgICAgICAgICAgcmV0LFxuICAgICAgICAgICAgZGlmZlJlcztcblxuICAgICAgICBpZiAoaXNEdXJhdGlvbihpbnB1dCkpIHtcbiAgICAgICAgICAgIGR1cmF0aW9uID0ge1xuICAgICAgICAgICAgICAgIG1zOiBpbnB1dC5fbWlsbGlzZWNvbmRzLFxuICAgICAgICAgICAgICAgIGQ6IGlucHV0Ll9kYXlzLFxuICAgICAgICAgICAgICAgIE06IGlucHV0Ll9tb250aHMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKGlzTnVtYmVyKGlucHV0KSB8fCAhaXNOYU4oK2lucHV0KSkge1xuICAgICAgICAgICAgZHVyYXRpb24gPSB7fTtcbiAgICAgICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICAgICAgICBkdXJhdGlvbltrZXldID0gK2lucHV0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkdXJhdGlvbi5taWxsaXNlY29uZHMgPSAraW5wdXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoKG1hdGNoID0gYXNwTmV0UmVnZXguZXhlYyhpbnB1dCkpKSB7XG4gICAgICAgICAgICBzaWduID0gbWF0Y2hbMV0gPT09ICctJyA/IC0xIDogMTtcbiAgICAgICAgICAgIGR1cmF0aW9uID0ge1xuICAgICAgICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgICAgICAgZDogdG9JbnQobWF0Y2hbREFURV0pICogc2lnbixcbiAgICAgICAgICAgICAgICBoOiB0b0ludChtYXRjaFtIT1VSXSkgKiBzaWduLFxuICAgICAgICAgICAgICAgIG06IHRvSW50KG1hdGNoW01JTlVURV0pICogc2lnbixcbiAgICAgICAgICAgICAgICBzOiB0b0ludChtYXRjaFtTRUNPTkRdKSAqIHNpZ24sXG4gICAgICAgICAgICAgICAgbXM6IHRvSW50KGFic1JvdW5kKG1hdGNoW01JTExJU0VDT05EXSAqIDEwMDApKSAqIHNpZ24sIC8vIHRoZSBtaWxsaXNlY29uZCBkZWNpbWFsIHBvaW50IGlzIGluY2x1ZGVkIGluIHRoZSBtYXRjaFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmICgobWF0Y2ggPSBpc29SZWdleC5leGVjKGlucHV0KSkpIHtcbiAgICAgICAgICAgIHNpZ24gPSBtYXRjaFsxXSA9PT0gJy0nID8gLTEgOiAxO1xuICAgICAgICAgICAgZHVyYXRpb24gPSB7XG4gICAgICAgICAgICAgICAgeTogcGFyc2VJc28obWF0Y2hbMl0sIHNpZ24pLFxuICAgICAgICAgICAgICAgIE06IHBhcnNlSXNvKG1hdGNoWzNdLCBzaWduKSxcbiAgICAgICAgICAgICAgICB3OiBwYXJzZUlzbyhtYXRjaFs0XSwgc2lnbiksXG4gICAgICAgICAgICAgICAgZDogcGFyc2VJc28obWF0Y2hbNV0sIHNpZ24pLFxuICAgICAgICAgICAgICAgIGg6IHBhcnNlSXNvKG1hdGNoWzZdLCBzaWduKSxcbiAgICAgICAgICAgICAgICBtOiBwYXJzZUlzbyhtYXRjaFs3XSwgc2lnbiksXG4gICAgICAgICAgICAgICAgczogcGFyc2VJc28obWF0Y2hbOF0sIHNpZ24pLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChkdXJhdGlvbiA9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBjaGVja3MgZm9yIG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICBkdXJhdGlvbiA9IHt9O1xuICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgdHlwZW9mIGR1cmF0aW9uID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgKCdmcm9tJyBpbiBkdXJhdGlvbiB8fCAndG8nIGluIGR1cmF0aW9uKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIGRpZmZSZXMgPSBtb21lbnRzRGlmZmVyZW5jZShcbiAgICAgICAgICAgICAgICBjcmVhdGVMb2NhbChkdXJhdGlvbi5mcm9tKSxcbiAgICAgICAgICAgICAgICBjcmVhdGVMb2NhbChkdXJhdGlvbi50bylcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGR1cmF0aW9uID0ge307XG4gICAgICAgICAgICBkdXJhdGlvbi5tcyA9IGRpZmZSZXMubWlsbGlzZWNvbmRzO1xuICAgICAgICAgICAgZHVyYXRpb24uTSA9IGRpZmZSZXMubW9udGhzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0ID0gbmV3IER1cmF0aW9uKGR1cmF0aW9uKTtcblxuICAgICAgICBpZiAoaXNEdXJhdGlvbihpbnB1dCkgJiYgaGFzT3duUHJvcChpbnB1dCwgJ19sb2NhbGUnKSkge1xuICAgICAgICAgICAgcmV0Ll9sb2NhbGUgPSBpbnB1dC5fbG9jYWxlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzRHVyYXRpb24oaW5wdXQpICYmIGhhc093blByb3AoaW5wdXQsICdfaXNWYWxpZCcpKSB7XG4gICAgICAgICAgICByZXQuX2lzVmFsaWQgPSBpbnB1dC5faXNWYWxpZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG4gICAgY3JlYXRlRHVyYXRpb24uZm4gPSBEdXJhdGlvbi5wcm90b3R5cGU7XG4gICAgY3JlYXRlRHVyYXRpb24uaW52YWxpZCA9IGNyZWF0ZUludmFsaWQkMTtcblxuICAgIGZ1bmN0aW9uIHBhcnNlSXNvKGlucCwgc2lnbikge1xuICAgICAgICAvLyBXZSdkIG5vcm1hbGx5IHVzZSB+fmlucCBmb3IgdGhpcywgYnV0IHVuZm9ydHVuYXRlbHkgaXQgYWxzb1xuICAgICAgICAvLyBjb252ZXJ0cyBmbG9hdHMgdG8gaW50cy5cbiAgICAgICAgLy8gaW5wIG1heSBiZSB1bmRlZmluZWQsIHNvIGNhcmVmdWwgY2FsbGluZyByZXBsYWNlIG9uIGl0LlxuICAgICAgICB2YXIgcmVzID0gaW5wICYmIHBhcnNlRmxvYXQoaW5wLnJlcGxhY2UoJywnLCAnLicpKTtcbiAgICAgICAgLy8gYXBwbHkgc2lnbiB3aGlsZSB3ZSdyZSBhdCBpdFxuICAgICAgICByZXR1cm4gKGlzTmFOKHJlcykgPyAwIDogcmVzKSAqIHNpZ247XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcG9zaXRpdmVNb21lbnRzRGlmZmVyZW5jZShiYXNlLCBvdGhlcikge1xuICAgICAgICB2YXIgcmVzID0ge307XG5cbiAgICAgICAgcmVzLm1vbnRocyA9XG4gICAgICAgICAgICBvdGhlci5tb250aCgpIC0gYmFzZS5tb250aCgpICsgKG90aGVyLnllYXIoKSAtIGJhc2UueWVhcigpKSAqIDEyO1xuICAgICAgICBpZiAoYmFzZS5jbG9uZSgpLmFkZChyZXMubW9udGhzLCAnTScpLmlzQWZ0ZXIob3RoZXIpKSB7XG4gICAgICAgICAgICAtLXJlcy5tb250aHM7XG4gICAgICAgIH1cblxuICAgICAgICByZXMubWlsbGlzZWNvbmRzID0gK290aGVyIC0gK2Jhc2UuY2xvbmUoKS5hZGQocmVzLm1vbnRocywgJ00nKTtcblxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vbWVudHNEaWZmZXJlbmNlKGJhc2UsIG90aGVyKSB7XG4gICAgICAgIHZhciByZXM7XG4gICAgICAgIGlmICghKGJhc2UuaXNWYWxpZCgpICYmIG90aGVyLmlzVmFsaWQoKSkpIHtcbiAgICAgICAgICAgIHJldHVybiB7IG1pbGxpc2Vjb25kczogMCwgbW9udGhzOiAwIH07XG4gICAgICAgIH1cblxuICAgICAgICBvdGhlciA9IGNsb25lV2l0aE9mZnNldChvdGhlciwgYmFzZSk7XG4gICAgICAgIGlmIChiYXNlLmlzQmVmb3JlKG90aGVyKSkge1xuICAgICAgICAgICAgcmVzID0gcG9zaXRpdmVNb21lbnRzRGlmZmVyZW5jZShiYXNlLCBvdGhlcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXMgPSBwb3NpdGl2ZU1vbWVudHNEaWZmZXJlbmNlKG90aGVyLCBiYXNlKTtcbiAgICAgICAgICAgIHJlcy5taWxsaXNlY29uZHMgPSAtcmVzLm1pbGxpc2Vjb25kcztcbiAgICAgICAgICAgIHJlcy5tb250aHMgPSAtcmVzLm1vbnRocztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgLy8gVE9ETzogcmVtb3ZlICduYW1lJyBhcmcgYWZ0ZXIgZGVwcmVjYXRpb24gaXMgcmVtb3ZlZFxuICAgIGZ1bmN0aW9uIGNyZWF0ZUFkZGVyKGRpcmVjdGlvbiwgbmFtZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHZhbCwgcGVyaW9kKSB7XG4gICAgICAgICAgICB2YXIgZHVyLCB0bXA7XG4gICAgICAgICAgICAvL2ludmVydCB0aGUgYXJndW1lbnRzLCBidXQgY29tcGxhaW4gYWJvdXQgaXRcbiAgICAgICAgICAgIGlmIChwZXJpb2QgIT09IG51bGwgJiYgIWlzTmFOKCtwZXJpb2QpKSB7XG4gICAgICAgICAgICAgICAgZGVwcmVjYXRlU2ltcGxlKFxuICAgICAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgICAgICAnbW9tZW50KCkuJyArXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lICtcbiAgICAgICAgICAgICAgICAgICAgICAgICcocGVyaW9kLCBudW1iZXIpIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgbW9tZW50KCkuJyArXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lICtcbiAgICAgICAgICAgICAgICAgICAgICAgICcobnVtYmVyLCBwZXJpb2QpLiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdTZWUgaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy9hZGQtaW52ZXJ0ZWQtcGFyYW0vIGZvciBtb3JlIGluZm8uJ1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgdG1wID0gdmFsO1xuICAgICAgICAgICAgICAgIHZhbCA9IHBlcmlvZDtcbiAgICAgICAgICAgICAgICBwZXJpb2QgPSB0bXA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGR1ciA9IGNyZWF0ZUR1cmF0aW9uKHZhbCwgcGVyaW9kKTtcbiAgICAgICAgICAgIGFkZFN1YnRyYWN0KHRoaXMsIGR1ciwgZGlyZWN0aW9uKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZFN1YnRyYWN0KG1vbSwgZHVyYXRpb24sIGlzQWRkaW5nLCB1cGRhdGVPZmZzZXQpIHtcbiAgICAgICAgdmFyIG1pbGxpc2Vjb25kcyA9IGR1cmF0aW9uLl9taWxsaXNlY29uZHMsXG4gICAgICAgICAgICBkYXlzID0gYWJzUm91bmQoZHVyYXRpb24uX2RheXMpLFxuICAgICAgICAgICAgbW9udGhzID0gYWJzUm91bmQoZHVyYXRpb24uX21vbnRocyk7XG5cbiAgICAgICAgaWYgKCFtb20uaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICAvLyBObyBvcFxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdXBkYXRlT2Zmc2V0ID0gdXBkYXRlT2Zmc2V0ID09IG51bGwgPyB0cnVlIDogdXBkYXRlT2Zmc2V0O1xuXG4gICAgICAgIGlmIChtb250aHMpIHtcbiAgICAgICAgICAgIHNldE1vbnRoKG1vbSwgZ2V0KG1vbSwgJ01vbnRoJykgKyBtb250aHMgKiBpc0FkZGluZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRheXMpIHtcbiAgICAgICAgICAgIHNldCQxKG1vbSwgJ0RhdGUnLCBnZXQobW9tLCAnRGF0ZScpICsgZGF5cyAqIGlzQWRkaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWlsbGlzZWNvbmRzKSB7XG4gICAgICAgICAgICBtb20uX2Quc2V0VGltZShtb20uX2QudmFsdWVPZigpICsgbWlsbGlzZWNvbmRzICogaXNBZGRpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1cGRhdGVPZmZzZXQpIHtcbiAgICAgICAgICAgIGhvb2tzLnVwZGF0ZU9mZnNldChtb20sIGRheXMgfHwgbW9udGhzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBhZGQgPSBjcmVhdGVBZGRlcigxLCAnYWRkJyksXG4gICAgICAgIHN1YnRyYWN0ID0gY3JlYXRlQWRkZXIoLTEsICdzdWJ0cmFjdCcpO1xuXG4gICAgZnVuY3Rpb24gaXNTdHJpbmcoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycgfHwgaW5wdXQgaW5zdGFuY2VvZiBTdHJpbmc7XG4gICAgfVxuXG4gICAgLy8gdHlwZSBNb21lbnRJbnB1dCA9IE1vbWVudCB8IERhdGUgfCBzdHJpbmcgfCBudW1iZXIgfCAobnVtYmVyIHwgc3RyaW5nKVtdIHwgTW9tZW50SW5wdXRPYmplY3QgfCB2b2lkOyAvLyBudWxsIHwgdW5kZWZpbmVkXG4gICAgZnVuY3Rpb24gaXNNb21lbnRJbnB1dChpbnB1dCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgaXNNb21lbnQoaW5wdXQpIHx8XG4gICAgICAgICAgICBpc0RhdGUoaW5wdXQpIHx8XG4gICAgICAgICAgICBpc1N0cmluZyhpbnB1dCkgfHxcbiAgICAgICAgICAgIGlzTnVtYmVyKGlucHV0KSB8fFxuICAgICAgICAgICAgaXNOdW1iZXJPclN0cmluZ0FycmF5KGlucHV0KSB8fFxuICAgICAgICAgICAgaXNNb21lbnRJbnB1dE9iamVjdChpbnB1dCkgfHxcbiAgICAgICAgICAgIGlucHV0ID09PSBudWxsIHx8XG4gICAgICAgICAgICBpbnB1dCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNNb21lbnRJbnB1dE9iamVjdChpbnB1dCkge1xuICAgICAgICB2YXIgb2JqZWN0VGVzdCA9IGlzT2JqZWN0KGlucHV0KSAmJiAhaXNPYmplY3RFbXB0eShpbnB1dCksXG4gICAgICAgICAgICBwcm9wZXJ0eVRlc3QgPSBmYWxzZSxcbiAgICAgICAgICAgIHByb3BlcnRpZXMgPSBbXG4gICAgICAgICAgICAgICAgJ3llYXJzJyxcbiAgICAgICAgICAgICAgICAneWVhcicsXG4gICAgICAgICAgICAgICAgJ3knLFxuICAgICAgICAgICAgICAgICdtb250aHMnLFxuICAgICAgICAgICAgICAgICdtb250aCcsXG4gICAgICAgICAgICAgICAgJ00nLFxuICAgICAgICAgICAgICAgICdkYXlzJyxcbiAgICAgICAgICAgICAgICAnZGF5JyxcbiAgICAgICAgICAgICAgICAnZCcsXG4gICAgICAgICAgICAgICAgJ2RhdGVzJyxcbiAgICAgICAgICAgICAgICAnZGF0ZScsXG4gICAgICAgICAgICAgICAgJ0QnLFxuICAgICAgICAgICAgICAgICdob3VycycsXG4gICAgICAgICAgICAgICAgJ2hvdXInLFxuICAgICAgICAgICAgICAgICdoJyxcbiAgICAgICAgICAgICAgICAnbWludXRlcycsXG4gICAgICAgICAgICAgICAgJ21pbnV0ZScsXG4gICAgICAgICAgICAgICAgJ20nLFxuICAgICAgICAgICAgICAgICdzZWNvbmRzJyxcbiAgICAgICAgICAgICAgICAnc2Vjb25kJyxcbiAgICAgICAgICAgICAgICAncycsXG4gICAgICAgICAgICAgICAgJ21pbGxpc2Vjb25kcycsXG4gICAgICAgICAgICAgICAgJ21pbGxpc2Vjb25kJyxcbiAgICAgICAgICAgICAgICAnbXMnLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBwcm9wZXJ0eSxcbiAgICAgICAgICAgIHByb3BlcnR5TGVuID0gcHJvcGVydGllcy5sZW5ndGg7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHByb3BlcnR5TGVuOyBpICs9IDEpIHtcbiAgICAgICAgICAgIHByb3BlcnR5ID0gcHJvcGVydGllc1tpXTtcbiAgICAgICAgICAgIHByb3BlcnR5VGVzdCA9IHByb3BlcnR5VGVzdCB8fCBoYXNPd25Qcm9wKGlucHV0LCBwcm9wZXJ0eSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb2JqZWN0VGVzdCAmJiBwcm9wZXJ0eVRlc3Q7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNOdW1iZXJPclN0cmluZ0FycmF5KGlucHV0KSB7XG4gICAgICAgIHZhciBhcnJheVRlc3QgPSBpc0FycmF5KGlucHV0KSxcbiAgICAgICAgICAgIGRhdGFUeXBlVGVzdCA9IGZhbHNlO1xuICAgICAgICBpZiAoYXJyYXlUZXN0KSB7XG4gICAgICAgICAgICBkYXRhVHlwZVRlc3QgPVxuICAgICAgICAgICAgICAgIGlucHV0LmZpbHRlcihmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gIWlzTnVtYmVyKGl0ZW0pICYmIGlzU3RyaW5nKGlucHV0KTtcbiAgICAgICAgICAgICAgICB9KS5sZW5ndGggPT09IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFycmF5VGVzdCAmJiBkYXRhVHlwZVRlc3Q7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNDYWxlbmRhclNwZWMoaW5wdXQpIHtcbiAgICAgICAgdmFyIG9iamVjdFRlc3QgPSBpc09iamVjdChpbnB1dCkgJiYgIWlzT2JqZWN0RW1wdHkoaW5wdXQpLFxuICAgICAgICAgICAgcHJvcGVydHlUZXN0ID0gZmFsc2UsXG4gICAgICAgICAgICBwcm9wZXJ0aWVzID0gW1xuICAgICAgICAgICAgICAgICdzYW1lRGF5JyxcbiAgICAgICAgICAgICAgICAnbmV4dERheScsXG4gICAgICAgICAgICAgICAgJ2xhc3REYXknLFxuICAgICAgICAgICAgICAgICduZXh0V2VlaycsXG4gICAgICAgICAgICAgICAgJ2xhc3RXZWVrJyxcbiAgICAgICAgICAgICAgICAnc2FtZUVsc2UnLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBwcm9wZXJ0eTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcHJvcGVydGllcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgcHJvcGVydHkgPSBwcm9wZXJ0aWVzW2ldO1xuICAgICAgICAgICAgcHJvcGVydHlUZXN0ID0gcHJvcGVydHlUZXN0IHx8IGhhc093blByb3AoaW5wdXQsIHByb3BlcnR5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvYmplY3RUZXN0ICYmIHByb3BlcnR5VGVzdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRDYWxlbmRhckZvcm1hdChteU1vbWVudCwgbm93KSB7XG4gICAgICAgIHZhciBkaWZmID0gbXlNb21lbnQuZGlmZihub3csICdkYXlzJywgdHJ1ZSk7XG4gICAgICAgIHJldHVybiBkaWZmIDwgLTZcbiAgICAgICAgICAgID8gJ3NhbWVFbHNlJ1xuICAgICAgICAgICAgOiBkaWZmIDwgLTFcbiAgICAgICAgICAgID8gJ2xhc3RXZWVrJ1xuICAgICAgICAgICAgOiBkaWZmIDwgMFxuICAgICAgICAgICAgPyAnbGFzdERheSdcbiAgICAgICAgICAgIDogZGlmZiA8IDFcbiAgICAgICAgICAgID8gJ3NhbWVEYXknXG4gICAgICAgICAgICA6IGRpZmYgPCAyXG4gICAgICAgICAgICA/ICduZXh0RGF5J1xuICAgICAgICAgICAgOiBkaWZmIDwgN1xuICAgICAgICAgICAgPyAnbmV4dFdlZWsnXG4gICAgICAgICAgICA6ICdzYW1lRWxzZSc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2FsZW5kYXIkMSh0aW1lLCBmb3JtYXRzKSB7XG4gICAgICAgIC8vIFN1cHBvcnQgZm9yIHNpbmdsZSBwYXJhbWV0ZXIsIGZvcm1hdHMgb25seSBvdmVybG9hZCB0byB0aGUgY2FsZW5kYXIgZnVuY3Rpb25cbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIGlmICghYXJndW1lbnRzWzBdKSB7XG4gICAgICAgICAgICAgICAgdGltZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBmb3JtYXRzID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpc01vbWVudElucHV0KGFyZ3VtZW50c1swXSkpIHtcbiAgICAgICAgICAgICAgICB0aW1lID0gYXJndW1lbnRzWzBdO1xuICAgICAgICAgICAgICAgIGZvcm1hdHMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzQ2FsZW5kYXJTcGVjKGFyZ3VtZW50c1swXSkpIHtcbiAgICAgICAgICAgICAgICBmb3JtYXRzID0gYXJndW1lbnRzWzBdO1xuICAgICAgICAgICAgICAgIHRpbWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2Ugd2FudCB0byBjb21wYXJlIHRoZSBzdGFydCBvZiB0b2RheSwgdnMgdGhpcy5cbiAgICAgICAgLy8gR2V0dGluZyBzdGFydC1vZi10b2RheSBkZXBlbmRzIG9uIHdoZXRoZXIgd2UncmUgbG9jYWwvdXRjL29mZnNldCBvciBub3QuXG4gICAgICAgIHZhciBub3cgPSB0aW1lIHx8IGNyZWF0ZUxvY2FsKCksXG4gICAgICAgICAgICBzb2QgPSBjbG9uZVdpdGhPZmZzZXQobm93LCB0aGlzKS5zdGFydE9mKCdkYXknKSxcbiAgICAgICAgICAgIGZvcm1hdCA9IGhvb2tzLmNhbGVuZGFyRm9ybWF0KHRoaXMsIHNvZCkgfHwgJ3NhbWVFbHNlJyxcbiAgICAgICAgICAgIG91dHB1dCA9XG4gICAgICAgICAgICAgICAgZm9ybWF0cyAmJlxuICAgICAgICAgICAgICAgIChpc0Z1bmN0aW9uKGZvcm1hdHNbZm9ybWF0XSlcbiAgICAgICAgICAgICAgICAgICAgPyBmb3JtYXRzW2Zvcm1hdF0uY2FsbCh0aGlzLCBub3cpXG4gICAgICAgICAgICAgICAgICAgIDogZm9ybWF0c1tmb3JtYXRdKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXQoXG4gICAgICAgICAgICBvdXRwdXQgfHwgdGhpcy5sb2NhbGVEYXRhKCkuY2FsZW5kYXIoZm9ybWF0LCB0aGlzLCBjcmVhdGVMb2NhbChub3cpKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gbmV3IE1vbWVudCh0aGlzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0FmdGVyKGlucHV0LCB1bml0cykge1xuICAgICAgICB2YXIgbG9jYWxJbnB1dCA9IGlzTW9tZW50KGlucHV0KSA/IGlucHV0IDogY3JlYXRlTG9jYWwoaW5wdXQpO1xuICAgICAgICBpZiAoISh0aGlzLmlzVmFsaWQoKSAmJiBsb2NhbElucHV0LmlzVmFsaWQoKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKSB8fCAnbWlsbGlzZWNvbmQnO1xuICAgICAgICBpZiAodW5pdHMgPT09ICdtaWxsaXNlY29uZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlT2YoKSA+IGxvY2FsSW5wdXQudmFsdWVPZigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsSW5wdXQudmFsdWVPZigpIDwgdGhpcy5jbG9uZSgpLnN0YXJ0T2YodW5pdHMpLnZhbHVlT2YoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzQmVmb3JlKGlucHV0LCB1bml0cykge1xuICAgICAgICB2YXIgbG9jYWxJbnB1dCA9IGlzTW9tZW50KGlucHV0KSA/IGlucHV0IDogY3JlYXRlTG9jYWwoaW5wdXQpO1xuICAgICAgICBpZiAoISh0aGlzLmlzVmFsaWQoKSAmJiBsb2NhbElucHV0LmlzVmFsaWQoKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKSB8fCAnbWlsbGlzZWNvbmQnO1xuICAgICAgICBpZiAodW5pdHMgPT09ICdtaWxsaXNlY29uZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlT2YoKSA8IGxvY2FsSW5wdXQudmFsdWVPZigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5lbmRPZih1bml0cykudmFsdWVPZigpIDwgbG9jYWxJbnB1dC52YWx1ZU9mKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0JldHdlZW4oZnJvbSwgdG8sIHVuaXRzLCBpbmNsdXNpdml0eSkge1xuICAgICAgICB2YXIgbG9jYWxGcm9tID0gaXNNb21lbnQoZnJvbSkgPyBmcm9tIDogY3JlYXRlTG9jYWwoZnJvbSksXG4gICAgICAgICAgICBsb2NhbFRvID0gaXNNb21lbnQodG8pID8gdG8gOiBjcmVhdGVMb2NhbCh0byk7XG4gICAgICAgIGlmICghKHRoaXMuaXNWYWxpZCgpICYmIGxvY2FsRnJvbS5pc1ZhbGlkKCkgJiYgbG9jYWxUby5pc1ZhbGlkKCkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaW5jbHVzaXZpdHkgPSBpbmNsdXNpdml0eSB8fCAnKCknO1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKGluY2x1c2l2aXR5WzBdID09PSAnKCdcbiAgICAgICAgICAgICAgICA/IHRoaXMuaXNBZnRlcihsb2NhbEZyb20sIHVuaXRzKVxuICAgICAgICAgICAgICAgIDogIXRoaXMuaXNCZWZvcmUobG9jYWxGcm9tLCB1bml0cykpICYmXG4gICAgICAgICAgICAoaW5jbHVzaXZpdHlbMV0gPT09ICcpJ1xuICAgICAgICAgICAgICAgID8gdGhpcy5pc0JlZm9yZShsb2NhbFRvLCB1bml0cylcbiAgICAgICAgICAgICAgICA6ICF0aGlzLmlzQWZ0ZXIobG9jYWxUbywgdW5pdHMpKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzU2FtZShpbnB1dCwgdW5pdHMpIHtcbiAgICAgICAgdmFyIGxvY2FsSW5wdXQgPSBpc01vbWVudChpbnB1dCkgPyBpbnB1dCA6IGNyZWF0ZUxvY2FsKGlucHV0KSxcbiAgICAgICAgICAgIGlucHV0TXM7XG4gICAgICAgIGlmICghKHRoaXMuaXNWYWxpZCgpICYmIGxvY2FsSW5wdXQuaXNWYWxpZCgpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpIHx8ICdtaWxsaXNlY29uZCc7XG4gICAgICAgIGlmICh1bml0cyA9PT0gJ21pbGxpc2Vjb25kJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVPZigpID09PSBsb2NhbElucHV0LnZhbHVlT2YoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlucHV0TXMgPSBsb2NhbElucHV0LnZhbHVlT2YoKTtcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgdGhpcy5jbG9uZSgpLnN0YXJ0T2YodW5pdHMpLnZhbHVlT2YoKSA8PSBpbnB1dE1zICYmXG4gICAgICAgICAgICAgICAgaW5wdXRNcyA8PSB0aGlzLmNsb25lKCkuZW5kT2YodW5pdHMpLnZhbHVlT2YoKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzU2FtZU9yQWZ0ZXIoaW5wdXQsIHVuaXRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzU2FtZShpbnB1dCwgdW5pdHMpIHx8IHRoaXMuaXNBZnRlcihpbnB1dCwgdW5pdHMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzU2FtZU9yQmVmb3JlKGlucHV0LCB1bml0cykge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1NhbWUoaW5wdXQsIHVuaXRzKSB8fCB0aGlzLmlzQmVmb3JlKGlucHV0LCB1bml0cyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGlmZihpbnB1dCwgdW5pdHMsIGFzRmxvYXQpIHtcbiAgICAgICAgdmFyIHRoYXQsIHpvbmVEZWx0YSwgb3V0cHV0O1xuXG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgIH1cblxuICAgICAgICB0aGF0ID0gY2xvbmVXaXRoT2Zmc2V0KGlucHV0LCB0aGlzKTtcblxuICAgICAgICBpZiAoIXRoYXQuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICB9XG5cbiAgICAgICAgem9uZURlbHRhID0gKHRoYXQudXRjT2Zmc2V0KCkgLSB0aGlzLnV0Y09mZnNldCgpKSAqIDZlNDtcblxuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcblxuICAgICAgICBzd2l0Y2ggKHVuaXRzKSB7XG4gICAgICAgICAgICBjYXNlICd5ZWFyJzpcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSBtb250aERpZmYodGhpcywgdGhhdCkgLyAxMjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ21vbnRoJzpcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSBtb250aERpZmYodGhpcywgdGhhdCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdxdWFydGVyJzpcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSBtb250aERpZmYodGhpcywgdGhhdCkgLyAzO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnc2Vjb25kJzpcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSAodGhpcyAtIHRoYXQpIC8gMWUzO1xuICAgICAgICAgICAgICAgIGJyZWFrOyAvLyAxMDAwXG4gICAgICAgICAgICBjYXNlICdtaW51dGUnOlxuICAgICAgICAgICAgICAgIG91dHB1dCA9ICh0aGlzIC0gdGhhdCkgLyA2ZTQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7IC8vIDEwMDAgKiA2MFxuICAgICAgICAgICAgY2FzZSAnaG91cic6XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gKHRoaXMgLSB0aGF0KSAvIDM2ZTU7XG4gICAgICAgICAgICAgICAgYnJlYWs7IC8vIDEwMDAgKiA2MCAqIDYwXG4gICAgICAgICAgICBjYXNlICdkYXknOlxuICAgICAgICAgICAgICAgIG91dHB1dCA9ICh0aGlzIC0gdGhhdCAtIHpvbmVEZWx0YSkgLyA4NjRlNTtcbiAgICAgICAgICAgICAgICBicmVhazsgLy8gMTAwMCAqIDYwICogNjAgKiAyNCwgbmVnYXRlIGRzdFxuICAgICAgICAgICAgY2FzZSAnd2Vlayc6XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gKHRoaXMgLSB0aGF0IC0gem9uZURlbHRhKSAvIDYwNDhlNTtcbiAgICAgICAgICAgICAgICBicmVhazsgLy8gMTAwMCAqIDYwICogNjAgKiAyNCAqIDcsIG5lZ2F0ZSBkc3RcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gdGhpcyAtIHRoYXQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXNGbG9hdCA/IG91dHB1dCA6IGFic0Zsb29yKG91dHB1dCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW9udGhEaWZmKGEsIGIpIHtcbiAgICAgICAgaWYgKGEuZGF0ZSgpIDwgYi5kYXRlKCkpIHtcbiAgICAgICAgICAgIC8vIGVuZC1vZi1tb250aCBjYWxjdWxhdGlvbnMgd29yayBjb3JyZWN0IHdoZW4gdGhlIHN0YXJ0IG1vbnRoIGhhcyBtb3JlXG4gICAgICAgICAgICAvLyBkYXlzIHRoYW4gdGhlIGVuZCBtb250aC5cbiAgICAgICAgICAgIHJldHVybiAtbW9udGhEaWZmKGIsIGEpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGRpZmZlcmVuY2UgaW4gbW9udGhzXG4gICAgICAgIHZhciB3aG9sZU1vbnRoRGlmZiA9IChiLnllYXIoKSAtIGEueWVhcigpKSAqIDEyICsgKGIubW9udGgoKSAtIGEubW9udGgoKSksXG4gICAgICAgICAgICAvLyBiIGlzIGluIChhbmNob3IgLSAxIG1vbnRoLCBhbmNob3IgKyAxIG1vbnRoKVxuICAgICAgICAgICAgYW5jaG9yID0gYS5jbG9uZSgpLmFkZCh3aG9sZU1vbnRoRGlmZiwgJ21vbnRocycpLFxuICAgICAgICAgICAgYW5jaG9yMixcbiAgICAgICAgICAgIGFkanVzdDtcblxuICAgICAgICBpZiAoYiAtIGFuY2hvciA8IDApIHtcbiAgICAgICAgICAgIGFuY2hvcjIgPSBhLmNsb25lKCkuYWRkKHdob2xlTW9udGhEaWZmIC0gMSwgJ21vbnRocycpO1xuICAgICAgICAgICAgLy8gbGluZWFyIGFjcm9zcyB0aGUgbW9udGhcbiAgICAgICAgICAgIGFkanVzdCA9IChiIC0gYW5jaG9yKSAvIChhbmNob3IgLSBhbmNob3IyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFuY2hvcjIgPSBhLmNsb25lKCkuYWRkKHdob2xlTW9udGhEaWZmICsgMSwgJ21vbnRocycpO1xuICAgICAgICAgICAgLy8gbGluZWFyIGFjcm9zcyB0aGUgbW9udGhcbiAgICAgICAgICAgIGFkanVzdCA9IChiIC0gYW5jaG9yKSAvIChhbmNob3IyIC0gYW5jaG9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vY2hlY2sgZm9yIG5lZ2F0aXZlIHplcm8sIHJldHVybiB6ZXJvIGlmIG5lZ2F0aXZlIHplcm9cbiAgICAgICAgcmV0dXJuIC0od2hvbGVNb250aERpZmYgKyBhZGp1c3QpIHx8IDA7XG4gICAgfVxuXG4gICAgaG9va3MuZGVmYXVsdEZvcm1hdCA9ICdZWVlZLU1NLUREVEhIOm1tOnNzWic7XG4gICAgaG9va3MuZGVmYXVsdEZvcm1hdFV0YyA9ICdZWVlZLU1NLUREVEhIOm1tOnNzW1pdJztcblxuICAgIGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmxvY2FsZSgnZW4nKS5mb3JtYXQoJ2RkZCBNTU0gREQgWVlZWSBISDptbTpzcyBbR01UXVpaJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9JU09TdHJpbmcoa2VlcE9mZnNldCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdXRjID0ga2VlcE9mZnNldCAhPT0gdHJ1ZSxcbiAgICAgICAgICAgIG0gPSB1dGMgPyB0aGlzLmNsb25lKCkudXRjKCkgOiB0aGlzO1xuICAgICAgICBpZiAobS55ZWFyKCkgPCAwIHx8IG0ueWVhcigpID4gOTk5OSkge1xuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdE1vbWVudChcbiAgICAgICAgICAgICAgICBtLFxuICAgICAgICAgICAgICAgIHV0Y1xuICAgICAgICAgICAgICAgICAgICA/ICdZWVlZWVktTU0tRERbVF1ISDptbTpzcy5TU1NbWl0nXG4gICAgICAgICAgICAgICAgICAgIDogJ1lZWVlZWS1NTS1ERFtUXUhIOm1tOnNzLlNTU1onXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKERhdGUucHJvdG90eXBlLnRvSVNPU3RyaW5nKSkge1xuICAgICAgICAgICAgLy8gbmF0aXZlIGltcGxlbWVudGF0aW9uIGlzIH41MHggZmFzdGVyLCB1c2UgaXQgd2hlbiB3ZSBjYW5cbiAgICAgICAgICAgIGlmICh1dGMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50b0RhdGUoKS50b0lTT1N0cmluZygpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IERhdGUodGhpcy52YWx1ZU9mKCkgKyB0aGlzLnV0Y09mZnNldCgpICogNjAgKiAxMDAwKVxuICAgICAgICAgICAgICAgICAgICAudG9JU09TdHJpbmcoKVxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgnWicsIGZvcm1hdE1vbWVudChtLCAnWicpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm9ybWF0TW9tZW50KFxuICAgICAgICAgICAgbSxcbiAgICAgICAgICAgIHV0YyA/ICdZWVlZLU1NLUREW1RdSEg6bW06c3MuU1NTW1pdJyA6ICdZWVlZLU1NLUREW1RdSEg6bW06c3MuU1NTWidcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBodW1hbiByZWFkYWJsZSByZXByZXNlbnRhdGlvbiBvZiBhIG1vbWVudCB0aGF0IGNhblxuICAgICAqIGFsc28gYmUgZXZhbHVhdGVkIHRvIGdldCBhIG5ldyBtb21lbnQgd2hpY2ggaXMgdGhlIHNhbWVcbiAgICAgKlxuICAgICAqIEBsaW5rIGh0dHBzOi8vbm9kZWpzLm9yZy9kaXN0L2xhdGVzdC9kb2NzL2FwaS91dGlsLmh0bWwjdXRpbF9jdXN0b21faW5zcGVjdF9mdW5jdGlvbl9vbl9vYmplY3RzXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5zcGVjdCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuICdtb21lbnQuaW52YWxpZCgvKiAnICsgdGhpcy5faSArICcgKi8pJztcbiAgICAgICAgfVxuICAgICAgICB2YXIgZnVuYyA9ICdtb21lbnQnLFxuICAgICAgICAgICAgem9uZSA9ICcnLFxuICAgICAgICAgICAgcHJlZml4LFxuICAgICAgICAgICAgeWVhcixcbiAgICAgICAgICAgIGRhdGV0aW1lLFxuICAgICAgICAgICAgc3VmZml4O1xuICAgICAgICBpZiAoIXRoaXMuaXNMb2NhbCgpKSB7XG4gICAgICAgICAgICBmdW5jID0gdGhpcy51dGNPZmZzZXQoKSA9PT0gMCA/ICdtb21lbnQudXRjJyA6ICdtb21lbnQucGFyc2Vab25lJztcbiAgICAgICAgICAgIHpvbmUgPSAnWic7XG4gICAgICAgIH1cbiAgICAgICAgcHJlZml4ID0gJ1snICsgZnVuYyArICcoXCJdJztcbiAgICAgICAgeWVhciA9IDAgPD0gdGhpcy55ZWFyKCkgJiYgdGhpcy55ZWFyKCkgPD0gOTk5OSA/ICdZWVlZJyA6ICdZWVlZWVknO1xuICAgICAgICBkYXRldGltZSA9ICctTU0tRERbVF1ISDptbTpzcy5TU1MnO1xuICAgICAgICBzdWZmaXggPSB6b25lICsgJ1tcIildJztcblxuICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXQocHJlZml4ICsgeWVhciArIGRhdGV0aW1lICsgc3VmZml4KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmb3JtYXQoaW5wdXRTdHJpbmcpIHtcbiAgICAgICAgaWYgKCFpbnB1dFN0cmluZykge1xuICAgICAgICAgICAgaW5wdXRTdHJpbmcgPSB0aGlzLmlzVXRjKClcbiAgICAgICAgICAgICAgICA/IGhvb2tzLmRlZmF1bHRGb3JtYXRVdGNcbiAgICAgICAgICAgICAgICA6IGhvb2tzLmRlZmF1bHRGb3JtYXQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG91dHB1dCA9IGZvcm1hdE1vbWVudCh0aGlzLCBpbnB1dFN0cmluZyk7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5wb3N0Zm9ybWF0KG91dHB1dCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZnJvbSh0aW1lLCB3aXRob3V0U3VmZml4KSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIHRoaXMuaXNWYWxpZCgpICYmXG4gICAgICAgICAgICAoKGlzTW9tZW50KHRpbWUpICYmIHRpbWUuaXNWYWxpZCgpKSB8fCBjcmVhdGVMb2NhbCh0aW1lKS5pc1ZhbGlkKCkpXG4gICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUR1cmF0aW9uKHsgdG86IHRoaXMsIGZyb206IHRpbWUgfSlcbiAgICAgICAgICAgICAgICAubG9jYWxlKHRoaXMubG9jYWxlKCkpXG4gICAgICAgICAgICAgICAgLmh1bWFuaXplKCF3aXRob3V0U3VmZml4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5pbnZhbGlkRGF0ZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZnJvbU5vdyh3aXRob3V0U3VmZml4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZyb20oY3JlYXRlTG9jYWwoKSwgd2l0aG91dFN1ZmZpeCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG8odGltZSwgd2l0aG91dFN1ZmZpeCkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICB0aGlzLmlzVmFsaWQoKSAmJlxuICAgICAgICAgICAgKChpc01vbWVudCh0aW1lKSAmJiB0aW1lLmlzVmFsaWQoKSkgfHwgY3JlYXRlTG9jYWwodGltZSkuaXNWYWxpZCgpKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVEdXJhdGlvbih7IGZyb206IHRoaXMsIHRvOiB0aW1lIH0pXG4gICAgICAgICAgICAgICAgLmxvY2FsZSh0aGlzLmxvY2FsZSgpKVxuICAgICAgICAgICAgICAgIC5odW1hbml6ZSghd2l0aG91dFN1ZmZpeCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkuaW52YWxpZERhdGUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvTm93KHdpdGhvdXRTdWZmaXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG8oY3JlYXRlTG9jYWwoKSwgd2l0aG91dFN1ZmZpeCk7XG4gICAgfVxuXG4gICAgLy8gSWYgcGFzc2VkIGEgbG9jYWxlIGtleSwgaXQgd2lsbCBzZXQgdGhlIGxvY2FsZSBmb3IgdGhpc1xuICAgIC8vIGluc3RhbmNlLiAgT3RoZXJ3aXNlLCBpdCB3aWxsIHJldHVybiB0aGUgbG9jYWxlIGNvbmZpZ3VyYXRpb25cbiAgICAvLyB2YXJpYWJsZXMgZm9yIHRoaXMgaW5zdGFuY2UuXG4gICAgZnVuY3Rpb24gbG9jYWxlKGtleSkge1xuICAgICAgICB2YXIgbmV3TG9jYWxlRGF0YTtcblxuICAgICAgICBpZiAoa2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9sb2NhbGUuX2FiYnI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXdMb2NhbGVEYXRhID0gZ2V0TG9jYWxlKGtleSk7XG4gICAgICAgICAgICBpZiAobmV3TG9jYWxlRGF0YSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbG9jYWxlID0gbmV3TG9jYWxlRGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGxhbmcgPSBkZXByZWNhdGUoXG4gICAgICAgICdtb21lbnQoKS5sYW5nKCkgaXMgZGVwcmVjYXRlZC4gSW5zdGVhZCwgdXNlIG1vbWVudCgpLmxvY2FsZURhdGEoKSB0byBnZXQgdGhlIGxhbmd1YWdlIGNvbmZpZ3VyYXRpb24uIFVzZSBtb21lbnQoKS5sb2NhbGUoKSB0byBjaGFuZ2UgbGFuZ3VhZ2VzLicsXG4gICAgICAgIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIGlmIChrZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICApO1xuXG4gICAgZnVuY3Rpb24gbG9jYWxlRGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvY2FsZTtcbiAgICB9XG5cbiAgICB2YXIgTVNfUEVSX1NFQ09ORCA9IDEwMDAsXG4gICAgICAgIE1TX1BFUl9NSU5VVEUgPSA2MCAqIE1TX1BFUl9TRUNPTkQsXG4gICAgICAgIE1TX1BFUl9IT1VSID0gNjAgKiBNU19QRVJfTUlOVVRFLFxuICAgICAgICBNU19QRVJfNDAwX1lFQVJTID0gKDM2NSAqIDQwMCArIDk3KSAqIDI0ICogTVNfUEVSX0hPVVI7XG5cbiAgICAvLyBhY3R1YWwgbW9kdWxvIC0gaGFuZGxlcyBuZWdhdGl2ZSBudW1iZXJzIChmb3IgZGF0ZXMgYmVmb3JlIDE5NzApOlxuICAgIGZ1bmN0aW9uIG1vZCQxKGRpdmlkZW5kLCBkaXZpc29yKSB7XG4gICAgICAgIHJldHVybiAoKGRpdmlkZW5kICUgZGl2aXNvcikgKyBkaXZpc29yKSAlIGRpdmlzb3I7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9jYWxTdGFydE9mRGF0ZSh5LCBtLCBkKSB7XG4gICAgICAgIC8vIHRoZSBkYXRlIGNvbnN0cnVjdG9yIHJlbWFwcyB5ZWFycyAwLTk5IHRvIDE5MDAtMTk5OVxuICAgICAgICBpZiAoeSA8IDEwMCAmJiB5ID49IDApIHtcbiAgICAgICAgICAgIC8vIHByZXNlcnZlIGxlYXAgeWVhcnMgdXNpbmcgYSBmdWxsIDQwMCB5ZWFyIGN5Y2xlLCB0aGVuIHJlc2V0XG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGUoeSArIDQwMCwgbSwgZCkgLSBNU19QRVJfNDAwX1lFQVJTO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHksIG0sIGQpLnZhbHVlT2YoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHV0Y1N0YXJ0T2ZEYXRlKHksIG0sIGQpIHtcbiAgICAgICAgLy8gRGF0ZS5VVEMgcmVtYXBzIHllYXJzIDAtOTkgdG8gMTkwMC0xOTk5XG4gICAgICAgIGlmICh5IDwgMTAwICYmIHkgPj0gMCkge1xuICAgICAgICAgICAgLy8gcHJlc2VydmUgbGVhcCB5ZWFycyB1c2luZyBhIGZ1bGwgNDAwIHllYXIgY3ljbGUsIHRoZW4gcmVzZXRcbiAgICAgICAgICAgIHJldHVybiBEYXRlLlVUQyh5ICsgNDAwLCBtLCBkKSAtIE1TX1BFUl80MDBfWUVBUlM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gRGF0ZS5VVEMoeSwgbSwgZCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzdGFydE9mKHVuaXRzKSB7XG4gICAgICAgIHZhciB0aW1lLCBzdGFydE9mRGF0ZTtcbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG4gICAgICAgIGlmICh1bml0cyA9PT0gdW5kZWZpbmVkIHx8IHVuaXRzID09PSAnbWlsbGlzZWNvbmQnIHx8ICF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBzdGFydE9mRGF0ZSA9IHRoaXMuX2lzVVRDID8gdXRjU3RhcnRPZkRhdGUgOiBsb2NhbFN0YXJ0T2ZEYXRlO1xuXG4gICAgICAgIHN3aXRjaCAodW5pdHMpIHtcbiAgICAgICAgICAgIGNhc2UgJ3llYXInOlxuICAgICAgICAgICAgICAgIHRpbWUgPSBzdGFydE9mRGF0ZSh0aGlzLnllYXIoKSwgMCwgMSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdxdWFydGVyJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gc3RhcnRPZkRhdGUoXG4gICAgICAgICAgICAgICAgICAgIHRoaXMueWVhcigpLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1vbnRoKCkgLSAodGhpcy5tb250aCgpICUgMyksXG4gICAgICAgICAgICAgICAgICAgIDFcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbW9udGgnOlxuICAgICAgICAgICAgICAgIHRpbWUgPSBzdGFydE9mRGF0ZSh0aGlzLnllYXIoKSwgdGhpcy5tb250aCgpLCAxKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3dlZWsnOlxuICAgICAgICAgICAgICAgIHRpbWUgPSBzdGFydE9mRGF0ZShcbiAgICAgICAgICAgICAgICAgICAgdGhpcy55ZWFyKCksXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubW9udGgoKSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kYXRlKCkgLSB0aGlzLndlZWtkYXkoKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdpc29XZWVrJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gc3RhcnRPZkRhdGUoXG4gICAgICAgICAgICAgICAgICAgIHRoaXMueWVhcigpLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1vbnRoKCksXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGF0ZSgpIC0gKHRoaXMuaXNvV2Vla2RheSgpIC0gMSlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZGF5JzpcbiAgICAgICAgICAgIGNhc2UgJ2RhdGUnOlxuICAgICAgICAgICAgICAgIHRpbWUgPSBzdGFydE9mRGF0ZSh0aGlzLnllYXIoKSwgdGhpcy5tb250aCgpLCB0aGlzLmRhdGUoKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdob3VyJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gdGhpcy5fZC52YWx1ZU9mKCk7XG4gICAgICAgICAgICAgICAgdGltZSAtPSBtb2QkMShcbiAgICAgICAgICAgICAgICAgICAgdGltZSArICh0aGlzLl9pc1VUQyA/IDAgOiB0aGlzLnV0Y09mZnNldCgpICogTVNfUEVSX01JTlVURSksXG4gICAgICAgICAgICAgICAgICAgIE1TX1BFUl9IT1VSXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgICAgICAgICAgICAgdGltZSA9IHRoaXMuX2QudmFsdWVPZigpO1xuICAgICAgICAgICAgICAgIHRpbWUgLT0gbW9kJDEodGltZSwgTVNfUEVSX01JTlVURSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdzZWNvbmQnOlxuICAgICAgICAgICAgICAgIHRpbWUgPSB0aGlzLl9kLnZhbHVlT2YoKTtcbiAgICAgICAgICAgICAgICB0aW1lIC09IG1vZCQxKHRpbWUsIE1TX1BFUl9TRUNPTkQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fZC5zZXRUaW1lKHRpbWUpO1xuICAgICAgICBob29rcy51cGRhdGVPZmZzZXQodGhpcywgdHJ1ZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVuZE9mKHVuaXRzKSB7XG4gICAgICAgIHZhciB0aW1lLCBzdGFydE9mRGF0ZTtcbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG4gICAgICAgIGlmICh1bml0cyA9PT0gdW5kZWZpbmVkIHx8IHVuaXRzID09PSAnbWlsbGlzZWNvbmQnIHx8ICF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBzdGFydE9mRGF0ZSA9IHRoaXMuX2lzVVRDID8gdXRjU3RhcnRPZkRhdGUgOiBsb2NhbFN0YXJ0T2ZEYXRlO1xuXG4gICAgICAgIHN3aXRjaCAodW5pdHMpIHtcbiAgICAgICAgICAgIGNhc2UgJ3llYXInOlxuICAgICAgICAgICAgICAgIHRpbWUgPSBzdGFydE9mRGF0ZSh0aGlzLnllYXIoKSArIDEsIDAsIDEpIC0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3F1YXJ0ZXInOlxuICAgICAgICAgICAgICAgIHRpbWUgPVxuICAgICAgICAgICAgICAgICAgICBzdGFydE9mRGF0ZShcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMueWVhcigpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tb250aCgpIC0gKHRoaXMubW9udGgoKSAlIDMpICsgMyxcbiAgICAgICAgICAgICAgICAgICAgICAgIDFcbiAgICAgICAgICAgICAgICAgICAgKSAtIDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdtb250aCc6XG4gICAgICAgICAgICAgICAgdGltZSA9IHN0YXJ0T2ZEYXRlKHRoaXMueWVhcigpLCB0aGlzLm1vbnRoKCkgKyAxLCAxKSAtIDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd3ZWVrJzpcbiAgICAgICAgICAgICAgICB0aW1lID1cbiAgICAgICAgICAgICAgICAgICAgc3RhcnRPZkRhdGUoXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnllYXIoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubW9udGgoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGF0ZSgpIC0gdGhpcy53ZWVrZGF5KCkgKyA3XG4gICAgICAgICAgICAgICAgICAgICkgLSAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaXNvV2Vlayc6XG4gICAgICAgICAgICAgICAgdGltZSA9XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0T2ZEYXRlKFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy55ZWFyKCksXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1vbnRoKCksXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRhdGUoKSAtICh0aGlzLmlzb1dlZWtkYXkoKSAtIDEpICsgN1xuICAgICAgICAgICAgICAgICAgICApIC0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2RheSc6XG4gICAgICAgICAgICBjYXNlICdkYXRlJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gc3RhcnRPZkRhdGUodGhpcy55ZWFyKCksIHRoaXMubW9udGgoKSwgdGhpcy5kYXRlKCkgKyAxKSAtIDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdob3VyJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gdGhpcy5fZC52YWx1ZU9mKCk7XG4gICAgICAgICAgICAgICAgdGltZSArPVxuICAgICAgICAgICAgICAgICAgICBNU19QRVJfSE9VUiAtXG4gICAgICAgICAgICAgICAgICAgIG1vZCQxKFxuICAgICAgICAgICAgICAgICAgICAgICAgdGltZSArICh0aGlzLl9pc1VUQyA/IDAgOiB0aGlzLnV0Y09mZnNldCgpICogTVNfUEVSX01JTlVURSksXG4gICAgICAgICAgICAgICAgICAgICAgICBNU19QRVJfSE9VUlxuICAgICAgICAgICAgICAgICAgICApIC1cbiAgICAgICAgICAgICAgICAgICAgMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgICAgICAgICAgICAgdGltZSA9IHRoaXMuX2QudmFsdWVPZigpO1xuICAgICAgICAgICAgICAgIHRpbWUgKz0gTVNfUEVSX01JTlVURSAtIG1vZCQxKHRpbWUsIE1TX1BFUl9NSU5VVEUpIC0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgICAgICAgICAgICAgdGltZSA9IHRoaXMuX2QudmFsdWVPZigpO1xuICAgICAgICAgICAgICAgIHRpbWUgKz0gTVNfUEVSX1NFQ09ORCAtIG1vZCQxKHRpbWUsIE1TX1BFUl9TRUNPTkQpIC0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2Quc2V0VGltZSh0aW1lKTtcbiAgICAgICAgaG9va3MudXBkYXRlT2Zmc2V0KHRoaXMsIHRydWUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWx1ZU9mKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZC52YWx1ZU9mKCkgLSAodGhpcy5fb2Zmc2V0IHx8IDApICogNjAwMDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdW5peCgpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IodGhpcy52YWx1ZU9mKCkgLyAxMDAwKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b0RhdGUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZSh0aGlzLnZhbHVlT2YoKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9BcnJheSgpIHtcbiAgICAgICAgdmFyIG0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgbS55ZWFyKCksXG4gICAgICAgICAgICBtLm1vbnRoKCksXG4gICAgICAgICAgICBtLmRhdGUoKSxcbiAgICAgICAgICAgIG0uaG91cigpLFxuICAgICAgICAgICAgbS5taW51dGUoKSxcbiAgICAgICAgICAgIG0uc2Vjb25kKCksXG4gICAgICAgICAgICBtLm1pbGxpc2Vjb25kKCksXG4gICAgICAgIF07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9PYmplY3QoKSB7XG4gICAgICAgIHZhciBtID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHllYXJzOiBtLnllYXIoKSxcbiAgICAgICAgICAgIG1vbnRoczogbS5tb250aCgpLFxuICAgICAgICAgICAgZGF0ZTogbS5kYXRlKCksXG4gICAgICAgICAgICBob3VyczogbS5ob3VycygpLFxuICAgICAgICAgICAgbWludXRlczogbS5taW51dGVzKCksXG4gICAgICAgICAgICBzZWNvbmRzOiBtLnNlY29uZHMoKSxcbiAgICAgICAgICAgIG1pbGxpc2Vjb25kczogbS5taWxsaXNlY29uZHMoKSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICAgIC8vIG5ldyBEYXRlKE5hTikudG9KU09OKCkgPT09IG51bGxcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNWYWxpZCgpID8gdGhpcy50b0lTT1N0cmluZygpIDogbnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1ZhbGlkJDIoKSB7XG4gICAgICAgIHJldHVybiBpc1ZhbGlkKHRoaXMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNpbmdGbGFncygpIHtcbiAgICAgICAgcmV0dXJuIGV4dGVuZCh7fSwgZ2V0UGFyc2luZ0ZsYWdzKHRoaXMpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnZhbGlkQXQoKSB7XG4gICAgICAgIHJldHVybiBnZXRQYXJzaW5nRmxhZ3ModGhpcykub3ZlcmZsb3c7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRpb25EYXRhKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaW5wdXQ6IHRoaXMuX2ksXG4gICAgICAgICAgICBmb3JtYXQ6IHRoaXMuX2YsXG4gICAgICAgICAgICBsb2NhbGU6IHRoaXMuX2xvY2FsZSxcbiAgICAgICAgICAgIGlzVVRDOiB0aGlzLl9pc1VUQyxcbiAgICAgICAgICAgIHN0cmljdDogdGhpcy5fc3RyaWN0LFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFkZEZvcm1hdFRva2VuKCdOJywgMCwgMCwgJ2VyYUFiYnInKTtcbiAgICBhZGRGb3JtYXRUb2tlbignTk4nLCAwLCAwLCAnZXJhQWJicicpO1xuICAgIGFkZEZvcm1hdFRva2VuKCdOTk4nLCAwLCAwLCAnZXJhQWJicicpO1xuICAgIGFkZEZvcm1hdFRva2VuKCdOTk5OJywgMCwgMCwgJ2VyYU5hbWUnKTtcbiAgICBhZGRGb3JtYXRUb2tlbignTk5OTk4nLCAwLCAwLCAnZXJhTmFycm93Jyk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbigneScsIFsneScsIDFdLCAneW8nLCAnZXJhWWVhcicpO1xuICAgIGFkZEZvcm1hdFRva2VuKCd5JywgWyd5eScsIDJdLCAwLCAnZXJhWWVhcicpO1xuICAgIGFkZEZvcm1hdFRva2VuKCd5JywgWyd5eXknLCAzXSwgMCwgJ2VyYVllYXInKTtcbiAgICBhZGRGb3JtYXRUb2tlbigneScsIFsneXl5eScsIDRdLCAwLCAnZXJhWWVhcicpO1xuXG4gICAgYWRkUmVnZXhUb2tlbignTicsIG1hdGNoRXJhQWJicik7XG4gICAgYWRkUmVnZXhUb2tlbignTk4nLCBtYXRjaEVyYUFiYnIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ05OTicsIG1hdGNoRXJhQWJicik7XG4gICAgYWRkUmVnZXhUb2tlbignTk5OTicsIG1hdGNoRXJhTmFtZSk7XG4gICAgYWRkUmVnZXhUb2tlbignTk5OTk4nLCBtYXRjaEVyYU5hcnJvdyk7XG5cbiAgICBhZGRQYXJzZVRva2VuKFxuICAgICAgICBbJ04nLCAnTk4nLCAnTk5OJywgJ05OTk4nLCAnTk5OTk4nXSxcbiAgICAgICAgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnLCB0b2tlbikge1xuICAgICAgICAgICAgdmFyIGVyYSA9IGNvbmZpZy5fbG9jYWxlLmVyYXNQYXJzZShpbnB1dCwgdG9rZW4sIGNvbmZpZy5fc3RyaWN0KTtcbiAgICAgICAgICAgIGlmIChlcmEpIHtcbiAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5lcmEgPSBlcmE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmludmFsaWRFcmEgPSBpbnB1dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICk7XG5cbiAgICBhZGRSZWdleFRva2VuKCd5JywgbWF0Y2hVbnNpZ25lZCk7XG4gICAgYWRkUmVnZXhUb2tlbigneXknLCBtYXRjaFVuc2lnbmVkKTtcbiAgICBhZGRSZWdleFRva2VuKCd5eXknLCBtYXRjaFVuc2lnbmVkKTtcbiAgICBhZGRSZWdleFRva2VuKCd5eXl5JywgbWF0Y2hVbnNpZ25lZCk7XG4gICAgYWRkUmVnZXhUb2tlbigneW8nLCBtYXRjaEVyYVllYXJPcmRpbmFsKTtcblxuICAgIGFkZFBhcnNlVG9rZW4oWyd5JywgJ3l5JywgJ3l5eScsICd5eXl5J10sIFlFQVIpO1xuICAgIGFkZFBhcnNlVG9rZW4oWyd5byddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgIHZhciBtYXRjaDtcbiAgICAgICAgaWYgKGNvbmZpZy5fbG9jYWxlLl9lcmFZZWFyT3JkaW5hbFJlZ2V4KSB7XG4gICAgICAgICAgICBtYXRjaCA9IGlucHV0Lm1hdGNoKGNvbmZpZy5fbG9jYWxlLl9lcmFZZWFyT3JkaW5hbFJlZ2V4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb25maWcuX2xvY2FsZS5lcmFZZWFyT3JkaW5hbFBhcnNlKSB7XG4gICAgICAgICAgICBhcnJheVtZRUFSXSA9IGNvbmZpZy5fbG9jYWxlLmVyYVllYXJPcmRpbmFsUGFyc2UoaW5wdXQsIG1hdGNoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFycmF5W1lFQVJdID0gcGFyc2VJbnQoaW5wdXQsIDEwKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gbG9jYWxlRXJhcyhtLCBmb3JtYXQpIHtcbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgICBsLFxuICAgICAgICAgICAgZGF0ZSxcbiAgICAgICAgICAgIGVyYXMgPSB0aGlzLl9lcmFzIHx8IGdldExvY2FsZSgnZW4nKS5fZXJhcztcbiAgICAgICAgZm9yIChpID0gMCwgbCA9IGVyYXMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBlcmFzW2ldLnNpbmNlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICAgICAgLy8gdHJ1bmNhdGUgdGltZVxuICAgICAgICAgICAgICAgICAgICBkYXRlID0gaG9va3MoZXJhc1tpXS5zaW5jZSkuc3RhcnRPZignZGF5Jyk7XG4gICAgICAgICAgICAgICAgICAgIGVyYXNbaV0uc2luY2UgPSBkYXRlLnZhbHVlT2YoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGVyYXNbaV0udW50aWwpIHtcbiAgICAgICAgICAgICAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgICAgICAgICAgICAgICBlcmFzW2ldLnVudGlsID0gK0luZmluaXR5O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgICAgICAvLyB0cnVuY2F0ZSB0aW1lXG4gICAgICAgICAgICAgICAgICAgIGRhdGUgPSBob29rcyhlcmFzW2ldLnVudGlsKS5zdGFydE9mKCdkYXknKS52YWx1ZU9mKCk7XG4gICAgICAgICAgICAgICAgICAgIGVyYXNbaV0udW50aWwgPSBkYXRlLnZhbHVlT2YoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVyYXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9jYWxlRXJhc1BhcnNlKGVyYU5hbWUsIGZvcm1hdCwgc3RyaWN0KSB7XG4gICAgICAgIHZhciBpLFxuICAgICAgICAgICAgbCxcbiAgICAgICAgICAgIGVyYXMgPSB0aGlzLmVyYXMoKSxcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICBhYmJyLFxuICAgICAgICAgICAgbmFycm93O1xuICAgICAgICBlcmFOYW1lID0gZXJhTmFtZS50b1VwcGVyQ2FzZSgpO1xuXG4gICAgICAgIGZvciAoaSA9IDAsIGwgPSBlcmFzLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgICAgICAgbmFtZSA9IGVyYXNbaV0ubmFtZS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgYWJiciA9IGVyYXNbaV0uYWJici50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgbmFycm93ID0gZXJhc1tpXS5uYXJyb3cudG9VcHBlckNhc2UoKTtcblxuICAgICAgICAgICAgaWYgKHN0cmljdCkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoZm9ybWF0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ04nOlxuICAgICAgICAgICAgICAgICAgICBjYXNlICdOTic6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ05OTic6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWJiciA9PT0gZXJhTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlcmFzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnTk5OTic6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmFtZSA9PT0gZXJhTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlcmFzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnTk5OTk4nOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5hcnJvdyA9PT0gZXJhTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlcmFzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChbbmFtZSwgYWJiciwgbmFycm93XS5pbmRleE9mKGVyYU5hbWUpID49IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXJhc1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvY2FsZUVyYXNDb252ZXJ0WWVhcihlcmEsIHllYXIpIHtcbiAgICAgICAgdmFyIGRpciA9IGVyYS5zaW5jZSA8PSBlcmEudW50aWwgPyArMSA6IC0xO1xuICAgICAgICBpZiAoeWVhciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gaG9va3MoZXJhLnNpbmNlKS55ZWFyKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gaG9va3MoZXJhLnNpbmNlKS55ZWFyKCkgKyAoeWVhciAtIGVyYS5vZmZzZXQpICogZGlyO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0RXJhTmFtZSgpIHtcbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgICBsLFxuICAgICAgICAgICAgdmFsLFxuICAgICAgICAgICAgZXJhcyA9IHRoaXMubG9jYWxlRGF0YSgpLmVyYXMoKTtcbiAgICAgICAgZm9yIChpID0gMCwgbCA9IGVyYXMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgICAvLyB0cnVuY2F0ZSB0aW1lXG4gICAgICAgICAgICB2YWwgPSB0aGlzLmNsb25lKCkuc3RhcnRPZignZGF5JykudmFsdWVPZigpO1xuXG4gICAgICAgICAgICBpZiAoZXJhc1tpXS5zaW5jZSA8PSB2YWwgJiYgdmFsIDw9IGVyYXNbaV0udW50aWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXJhc1tpXS5uYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVyYXNbaV0udW50aWwgPD0gdmFsICYmIHZhbCA8PSBlcmFzW2ldLnNpbmNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVyYXNbaV0ubmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRFcmFOYXJyb3coKSB7XG4gICAgICAgIHZhciBpLFxuICAgICAgICAgICAgbCxcbiAgICAgICAgICAgIHZhbCxcbiAgICAgICAgICAgIGVyYXMgPSB0aGlzLmxvY2FsZURhdGEoKS5lcmFzKCk7XG4gICAgICAgIGZvciAoaSA9IDAsIGwgPSBlcmFzLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgICAgICAgLy8gdHJ1bmNhdGUgdGltZVxuICAgICAgICAgICAgdmFsID0gdGhpcy5jbG9uZSgpLnN0YXJ0T2YoJ2RheScpLnZhbHVlT2YoKTtcblxuICAgICAgICAgICAgaWYgKGVyYXNbaV0uc2luY2UgPD0gdmFsICYmIHZhbCA8PSBlcmFzW2ldLnVudGlsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVyYXNbaV0ubmFycm93O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVyYXNbaV0udW50aWwgPD0gdmFsICYmIHZhbCA8PSBlcmFzW2ldLnNpbmNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVyYXNbaV0ubmFycm93O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEVyYUFiYnIoKSB7XG4gICAgICAgIHZhciBpLFxuICAgICAgICAgICAgbCxcbiAgICAgICAgICAgIHZhbCxcbiAgICAgICAgICAgIGVyYXMgPSB0aGlzLmxvY2FsZURhdGEoKS5lcmFzKCk7XG4gICAgICAgIGZvciAoaSA9IDAsIGwgPSBlcmFzLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgICAgICAgLy8gdHJ1bmNhdGUgdGltZVxuICAgICAgICAgICAgdmFsID0gdGhpcy5jbG9uZSgpLnN0YXJ0T2YoJ2RheScpLnZhbHVlT2YoKTtcblxuICAgICAgICAgICAgaWYgKGVyYXNbaV0uc2luY2UgPD0gdmFsICYmIHZhbCA8PSBlcmFzW2ldLnVudGlsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVyYXNbaV0uYWJicjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlcmFzW2ldLnVudGlsIDw9IHZhbCAmJiB2YWwgPD0gZXJhc1tpXS5zaW5jZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlcmFzW2ldLmFiYnI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0RXJhWWVhcigpIHtcbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgICBsLFxuICAgICAgICAgICAgZGlyLFxuICAgICAgICAgICAgdmFsLFxuICAgICAgICAgICAgZXJhcyA9IHRoaXMubG9jYWxlRGF0YSgpLmVyYXMoKTtcbiAgICAgICAgZm9yIChpID0gMCwgbCA9IGVyYXMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgICBkaXIgPSBlcmFzW2ldLnNpbmNlIDw9IGVyYXNbaV0udW50aWwgPyArMSA6IC0xO1xuXG4gICAgICAgICAgICAvLyB0cnVuY2F0ZSB0aW1lXG4gICAgICAgICAgICB2YWwgPSB0aGlzLmNsb25lKCkuc3RhcnRPZignZGF5JykudmFsdWVPZigpO1xuXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgKGVyYXNbaV0uc2luY2UgPD0gdmFsICYmIHZhbCA8PSBlcmFzW2ldLnVudGlsKSB8fFxuICAgICAgICAgICAgICAgIChlcmFzW2ldLnVudGlsIDw9IHZhbCAmJiB2YWwgPD0gZXJhc1tpXS5zaW5jZSlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgICAgICh0aGlzLnllYXIoKSAtIGhvb2tzKGVyYXNbaV0uc2luY2UpLnllYXIoKSkgKiBkaXIgK1xuICAgICAgICAgICAgICAgICAgICBlcmFzW2ldLm9mZnNldFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy55ZWFyKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXJhc05hbWVSZWdleChpc1N0cmljdCkge1xuICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ19lcmFzTmFtZVJlZ2V4JykpIHtcbiAgICAgICAgICAgIGNvbXB1dGVFcmFzUGFyc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXNTdHJpY3QgPyB0aGlzLl9lcmFzTmFtZVJlZ2V4IDogdGhpcy5fZXJhc1JlZ2V4O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVyYXNBYmJyUmVnZXgoaXNTdHJpY3QpIHtcbiAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfZXJhc0FiYnJSZWdleCcpKSB7XG4gICAgICAgICAgICBjb21wdXRlRXJhc1BhcnNlLmNhbGwodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzU3RyaWN0ID8gdGhpcy5fZXJhc0FiYnJSZWdleCA6IHRoaXMuX2VyYXNSZWdleDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlcmFzTmFycm93UmVnZXgoaXNTdHJpY3QpIHtcbiAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfZXJhc05hcnJvd1JlZ2V4JykpIHtcbiAgICAgICAgICAgIGNvbXB1dGVFcmFzUGFyc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXNTdHJpY3QgPyB0aGlzLl9lcmFzTmFycm93UmVnZXggOiB0aGlzLl9lcmFzUmVnZXg7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWF0Y2hFcmFBYmJyKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS5lcmFzQWJiclJlZ2V4KGlzU3RyaWN0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYXRjaEVyYU5hbWUoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gbG9jYWxlLmVyYXNOYW1lUmVnZXgoaXNTdHJpY3QpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1hdGNoRXJhTmFycm93KGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS5lcmFzTmFycm93UmVnZXgoaXNTdHJpY3QpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1hdGNoRXJhWWVhck9yZGluYWwoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gbG9jYWxlLl9lcmFZZWFyT3JkaW5hbFJlZ2V4IHx8IG1hdGNoVW5zaWduZWQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29tcHV0ZUVyYXNQYXJzZSgpIHtcbiAgICAgICAgdmFyIGFiYnJQaWVjZXMgPSBbXSxcbiAgICAgICAgICAgIG5hbWVQaWVjZXMgPSBbXSxcbiAgICAgICAgICAgIG5hcnJvd1BpZWNlcyA9IFtdLFxuICAgICAgICAgICAgbWl4ZWRQaWVjZXMgPSBbXSxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBsLFxuICAgICAgICAgICAgZXJhcyA9IHRoaXMuZXJhcygpO1xuXG4gICAgICAgIGZvciAoaSA9IDAsIGwgPSBlcmFzLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgICAgICAgbmFtZVBpZWNlcy5wdXNoKHJlZ2V4RXNjYXBlKGVyYXNbaV0ubmFtZSkpO1xuICAgICAgICAgICAgYWJiclBpZWNlcy5wdXNoKHJlZ2V4RXNjYXBlKGVyYXNbaV0uYWJicikpO1xuICAgICAgICAgICAgbmFycm93UGllY2VzLnB1c2gocmVnZXhFc2NhcGUoZXJhc1tpXS5uYXJyb3cpKTtcblxuICAgICAgICAgICAgbWl4ZWRQaWVjZXMucHVzaChyZWdleEVzY2FwZShlcmFzW2ldLm5hbWUpKTtcbiAgICAgICAgICAgIG1peGVkUGllY2VzLnB1c2gocmVnZXhFc2NhcGUoZXJhc1tpXS5hYmJyKSk7XG4gICAgICAgICAgICBtaXhlZFBpZWNlcy5wdXNoKHJlZ2V4RXNjYXBlKGVyYXNbaV0ubmFycm93KSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9lcmFzUmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBtaXhlZFBpZWNlcy5qb2luKCd8JykgKyAnKScsICdpJyk7XG4gICAgICAgIHRoaXMuX2VyYXNOYW1lUmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBuYW1lUGllY2VzLmpvaW4oJ3wnKSArICcpJywgJ2knKTtcbiAgICAgICAgdGhpcy5fZXJhc0FiYnJSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIGFiYnJQaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xuICAgICAgICB0aGlzLl9lcmFzTmFycm93UmVnZXggPSBuZXcgUmVnRXhwKFxuICAgICAgICAgICAgJ14oJyArIG5hcnJvd1BpZWNlcy5qb2luKCd8JykgKyAnKScsXG4gICAgICAgICAgICAnaSdcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ2dnJywgMl0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2Vla1llYXIoKSAlIDEwMDtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnR0cnLCAyXSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc29XZWVrWWVhcigpICUgMTAwO1xuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gYWRkV2Vla1llYXJGb3JtYXRUb2tlbih0b2tlbiwgZ2V0dGVyKSB7XG4gICAgICAgIGFkZEZvcm1hdFRva2VuKDAsIFt0b2tlbiwgdG9rZW4ubGVuZ3RoXSwgMCwgZ2V0dGVyKTtcbiAgICB9XG5cbiAgICBhZGRXZWVrWWVhckZvcm1hdFRva2VuKCdnZ2dnJywgJ3dlZWtZZWFyJyk7XG4gICAgYWRkV2Vla1llYXJGb3JtYXRUb2tlbignZ2dnZ2cnLCAnd2Vla1llYXInKTtcbiAgICBhZGRXZWVrWWVhckZvcm1hdFRva2VuKCdHR0dHJywgJ2lzb1dlZWtZZWFyJyk7XG4gICAgYWRkV2Vla1llYXJGb3JtYXRUb2tlbignR0dHR0cnLCAnaXNvV2Vla1llYXInKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnd2Vla1llYXInLCAnZ2cnKTtcbiAgICBhZGRVbml0QWxpYXMoJ2lzb1dlZWtZZWFyJywgJ0dHJyk7XG5cbiAgICAvLyBQUklPUklUWVxuXG4gICAgYWRkVW5pdFByaW9yaXR5KCd3ZWVrWWVhcicsIDEpO1xuICAgIGFkZFVuaXRQcmlvcml0eSgnaXNvV2Vla1llYXInLCAxKTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ0cnLCBtYXRjaFNpZ25lZCk7XG4gICAgYWRkUmVnZXhUb2tlbignZycsIG1hdGNoU2lnbmVkKTtcbiAgICBhZGRSZWdleFRva2VuKCdHRycsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdnZycsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdHR0dHJywgbWF0Y2gxdG80LCBtYXRjaDQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2dnZ2cnLCBtYXRjaDF0bzQsIG1hdGNoNCk7XG4gICAgYWRkUmVnZXhUb2tlbignR0dHR0cnLCBtYXRjaDF0bzYsIG1hdGNoNik7XG4gICAgYWRkUmVnZXhUb2tlbignZ2dnZ2cnLCBtYXRjaDF0bzYsIG1hdGNoNik7XG5cbiAgICBhZGRXZWVrUGFyc2VUb2tlbihcbiAgICAgICAgWydnZ2dnJywgJ2dnZ2dnJywgJ0dHR0cnLCAnR0dHR0cnXSxcbiAgICAgICAgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgICAgICB3ZWVrW3Rva2VuLnN1YnN0cigwLCAyKV0gPSB0b0ludChpbnB1dCk7XG4gICAgICAgIH1cbiAgICApO1xuXG4gICAgYWRkV2Vla1BhcnNlVG9rZW4oWydnZycsICdHRyddLCBmdW5jdGlvbiAoaW5wdXQsIHdlZWssIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgd2Vla1t0b2tlbl0gPSBob29rcy5wYXJzZVR3b0RpZ2l0WWVhcihpbnB1dCk7XG4gICAgfSk7XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBnZXRTZXRXZWVrWWVhcihpbnB1dCkge1xuICAgICAgICByZXR1cm4gZ2V0U2V0V2Vla1llYXJIZWxwZXIuY2FsbChcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgIHRoaXMud2VlaygpLFxuICAgICAgICAgICAgdGhpcy53ZWVrZGF5KCksXG4gICAgICAgICAgICB0aGlzLmxvY2FsZURhdGEoKS5fd2Vlay5kb3csXG4gICAgICAgICAgICB0aGlzLmxvY2FsZURhdGEoKS5fd2Vlay5kb3lcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTZXRJU09XZWVrWWVhcihpbnB1dCkge1xuICAgICAgICByZXR1cm4gZ2V0U2V0V2Vla1llYXJIZWxwZXIuY2FsbChcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgIHRoaXMuaXNvV2VlaygpLFxuICAgICAgICAgICAgdGhpcy5pc29XZWVrZGF5KCksXG4gICAgICAgICAgICAxLFxuICAgICAgICAgICAgNFxuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldElTT1dlZWtzSW5ZZWFyKCkge1xuICAgICAgICByZXR1cm4gd2Vla3NJblllYXIodGhpcy55ZWFyKCksIDEsIDQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldElTT1dlZWtzSW5JU09XZWVrWWVhcigpIHtcbiAgICAgICAgcmV0dXJuIHdlZWtzSW5ZZWFyKHRoaXMuaXNvV2Vla1llYXIoKSwgMSwgNCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0V2Vla3NJblllYXIoKSB7XG4gICAgICAgIHZhciB3ZWVrSW5mbyA9IHRoaXMubG9jYWxlRGF0YSgpLl93ZWVrO1xuICAgICAgICByZXR1cm4gd2Vla3NJblllYXIodGhpcy55ZWFyKCksIHdlZWtJbmZvLmRvdywgd2Vla0luZm8uZG95KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRXZWVrc0luV2Vla1llYXIoKSB7XG4gICAgICAgIHZhciB3ZWVrSW5mbyA9IHRoaXMubG9jYWxlRGF0YSgpLl93ZWVrO1xuICAgICAgICByZXR1cm4gd2Vla3NJblllYXIodGhpcy53ZWVrWWVhcigpLCB3ZWVrSW5mby5kb3csIHdlZWtJbmZvLmRveSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2V0V2Vla1llYXJIZWxwZXIoaW5wdXQsIHdlZWssIHdlZWtkYXksIGRvdywgZG95KSB7XG4gICAgICAgIHZhciB3ZWVrc1RhcmdldDtcbiAgICAgICAgaWYgKGlucHV0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB3ZWVrT2ZZZWFyKHRoaXMsIGRvdywgZG95KS55ZWFyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd2Vla3NUYXJnZXQgPSB3ZWVrc0luWWVhcihpbnB1dCwgZG93LCBkb3kpO1xuICAgICAgICAgICAgaWYgKHdlZWsgPiB3ZWVrc1RhcmdldCkge1xuICAgICAgICAgICAgICAgIHdlZWsgPSB3ZWVrc1RhcmdldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzZXRXZWVrQWxsLmNhbGwodGhpcywgaW5wdXQsIHdlZWssIHdlZWtkYXksIGRvdywgZG95KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldFdlZWtBbGwod2Vla1llYXIsIHdlZWssIHdlZWtkYXksIGRvdywgZG95KSB7XG4gICAgICAgIHZhciBkYXlPZlllYXJEYXRhID0gZGF5T2ZZZWFyRnJvbVdlZWtzKHdlZWtZZWFyLCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSksXG4gICAgICAgICAgICBkYXRlID0gY3JlYXRlVVRDRGF0ZShkYXlPZlllYXJEYXRhLnllYXIsIDAsIGRheU9mWWVhckRhdGEuZGF5T2ZZZWFyKTtcblxuICAgICAgICB0aGlzLnllYXIoZGF0ZS5nZXRVVENGdWxsWWVhcigpKTtcbiAgICAgICAgdGhpcy5tb250aChkYXRlLmdldFVUQ01vbnRoKCkpO1xuICAgICAgICB0aGlzLmRhdGUoZGF0ZS5nZXRVVENEYXRlKCkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignUScsIDAsICdRbycsICdxdWFydGVyJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ3F1YXJ0ZXInLCAnUScpO1xuXG4gICAgLy8gUFJJT1JJVFlcblxuICAgIGFkZFVuaXRQcmlvcml0eSgncXVhcnRlcicsIDcpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignUScsIG1hdGNoMSk7XG4gICAgYWRkUGFyc2VUb2tlbignUScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgYXJyYXlbTU9OVEhdID0gKHRvSW50KGlucHV0KSAtIDEpICogMztcbiAgICB9KTtcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIGZ1bmN0aW9uIGdldFNldFF1YXJ0ZXIoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0ID09IG51bGxcbiAgICAgICAgICAgID8gTWF0aC5jZWlsKCh0aGlzLm1vbnRoKCkgKyAxKSAvIDMpXG4gICAgICAgICAgICA6IHRoaXMubW9udGgoKGlucHV0IC0gMSkgKiAzICsgKHRoaXMubW9udGgoKSAlIDMpKTtcbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignRCcsIFsnREQnLCAyXSwgJ0RvJywgJ2RhdGUnKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnZGF0ZScsICdEJyk7XG5cbiAgICAvLyBQUklPUklUWVxuICAgIGFkZFVuaXRQcmlvcml0eSgnZGF0ZScsIDkpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignRCcsIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignREQnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbignRG8nLCBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgICAgICAvLyBUT0RPOiBSZW1vdmUgXCJvcmRpbmFsUGFyc2VcIiBmYWxsYmFjayBpbiBuZXh0IG1ham9yIHJlbGVhc2UuXG4gICAgICAgIHJldHVybiBpc1N0cmljdFxuICAgICAgICAgICAgPyBsb2NhbGUuX2RheU9mTW9udGhPcmRpbmFsUGFyc2UgfHwgbG9jYWxlLl9vcmRpbmFsUGFyc2VcbiAgICAgICAgICAgIDogbG9jYWxlLl9kYXlPZk1vbnRoT3JkaW5hbFBhcnNlTGVuaWVudDtcbiAgICB9KTtcblxuICAgIGFkZFBhcnNlVG9rZW4oWydEJywgJ0REJ10sIERBVEUpO1xuICAgIGFkZFBhcnNlVG9rZW4oJ0RvJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgICAgICBhcnJheVtEQVRFXSA9IHRvSW50KGlucHV0Lm1hdGNoKG1hdGNoMXRvMilbMF0pO1xuICAgIH0pO1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgdmFyIGdldFNldERheU9mTW9udGggPSBtYWtlR2V0U2V0KCdEYXRlJywgdHJ1ZSk7XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignREREJywgWydEREREJywgM10sICdERERvJywgJ2RheU9mWWVhcicpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdkYXlPZlllYXInLCAnREREJyk7XG5cbiAgICAvLyBQUklPUklUWVxuICAgIGFkZFVuaXRQcmlvcml0eSgnZGF5T2ZZZWFyJywgNCk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdEREQnLCBtYXRjaDF0bzMpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0REREQnLCBtYXRjaDMpO1xuICAgIGFkZFBhcnNlVG9rZW4oWydEREQnLCAnRERERCddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgY29uZmlnLl9kYXlPZlllYXIgPSB0b0ludChpbnB1dCk7XG4gICAgfSk7XG5cbiAgICAvLyBIRUxQRVJTXG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBnZXRTZXREYXlPZlllYXIoaW5wdXQpIHtcbiAgICAgICAgdmFyIGRheU9mWWVhciA9XG4gICAgICAgICAgICBNYXRoLnJvdW5kKFxuICAgICAgICAgICAgICAgICh0aGlzLmNsb25lKCkuc3RhcnRPZignZGF5JykgLSB0aGlzLmNsb25lKCkuc3RhcnRPZigneWVhcicpKSAvIDg2NGU1XG4gICAgICAgICAgICApICsgMTtcbiAgICAgICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyBkYXlPZlllYXIgOiB0aGlzLmFkZChpbnB1dCAtIGRheU9mWWVhciwgJ2QnKTtcbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignbScsIFsnbW0nLCAyXSwgMCwgJ21pbnV0ZScpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdtaW51dGUnLCAnbScpO1xuXG4gICAgLy8gUFJJT1JJVFlcblxuICAgIGFkZFVuaXRQcmlvcml0eSgnbWludXRlJywgMTQpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignbScsIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignbW0nLCBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUGFyc2VUb2tlbihbJ20nLCAnbW0nXSwgTUlOVVRFKTtcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIHZhciBnZXRTZXRNaW51dGUgPSBtYWtlR2V0U2V0KCdNaW51dGVzJywgZmFsc2UpO1xuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ3MnLCBbJ3NzJywgMl0sIDAsICdzZWNvbmQnKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnc2Vjb25kJywgJ3MnKTtcblxuICAgIC8vIFBSSU9SSVRZXG5cbiAgICBhZGRVbml0UHJpb3JpdHkoJ3NlY29uZCcsIDE1KTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ3MnLCBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ3NzJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFBhcnNlVG9rZW4oWydzJywgJ3NzJ10sIFNFQ09ORCk7XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICB2YXIgZ2V0U2V0U2Vjb25kID0gbWFrZUdldFNldCgnU2Vjb25kcycsIGZhbHNlKTtcblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdTJywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gfn4odGhpcy5taWxsaXNlY29uZCgpIC8gMTAwKTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1MnLCAyXSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gfn4odGhpcy5taWxsaXNlY29uZCgpIC8gMTApO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1MnLCAzXSwgMCwgJ21pbGxpc2Vjb25kJyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTJywgNF0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwO1xuICAgIH0pO1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1NTU1MnLCA1XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTAwO1xuICAgIH0pO1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1NTU1NTJywgNl0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwMDA7XG4gICAgfSk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTU1NTJywgN10sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwMDAwO1xuICAgIH0pO1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1NTU1NTU1MnLCA4XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTAwMDAwO1xuICAgIH0pO1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1NTU1NTU1NTJywgOV0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwMDAwMDA7XG4gICAgfSk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ21pbGxpc2Vjb25kJywgJ21zJyk7XG5cbiAgICAvLyBQUklPUklUWVxuXG4gICAgYWRkVW5pdFByaW9yaXR5KCdtaWxsaXNlY29uZCcsIDE2KTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ1MnLCBtYXRjaDF0bzMsIG1hdGNoMSk7XG4gICAgYWRkUmVnZXhUb2tlbignU1MnLCBtYXRjaDF0bzMsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbignU1NTJywgbWF0Y2gxdG8zLCBtYXRjaDMpO1xuXG4gICAgdmFyIHRva2VuLCBnZXRTZXRNaWxsaXNlY29uZDtcbiAgICBmb3IgKHRva2VuID0gJ1NTU1MnOyB0b2tlbi5sZW5ndGggPD0gOTsgdG9rZW4gKz0gJ1MnKSB7XG4gICAgICAgIGFkZFJlZ2V4VG9rZW4odG9rZW4sIG1hdGNoVW5zaWduZWQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlTXMoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgIGFycmF5W01JTExJU0VDT05EXSA9IHRvSW50KCgnMC4nICsgaW5wdXQpICogMTAwMCk7XG4gICAgfVxuXG4gICAgZm9yICh0b2tlbiA9ICdTJzsgdG9rZW4ubGVuZ3RoIDw9IDk7IHRva2VuICs9ICdTJykge1xuICAgICAgICBhZGRQYXJzZVRva2VuKHRva2VuLCBwYXJzZU1zKTtcbiAgICB9XG5cbiAgICBnZXRTZXRNaWxsaXNlY29uZCA9IG1ha2VHZXRTZXQoJ01pbGxpc2Vjb25kcycsIGZhbHNlKTtcblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCd6JywgMCwgMCwgJ3pvbmVBYmJyJyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oJ3p6JywgMCwgMCwgJ3pvbmVOYW1lJyk7XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBnZXRab25lQWJicigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzVVRDID8gJ1VUQycgOiAnJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRab25lTmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzVVRDID8gJ0Nvb3JkaW5hdGVkIFVuaXZlcnNhbCBUaW1lJyA6ICcnO1xuICAgIH1cblxuICAgIHZhciBwcm90byA9IE1vbWVudC5wcm90b3R5cGU7XG5cbiAgICBwcm90by5hZGQgPSBhZGQ7XG4gICAgcHJvdG8uY2FsZW5kYXIgPSBjYWxlbmRhciQxO1xuICAgIHByb3RvLmNsb25lID0gY2xvbmU7XG4gICAgcHJvdG8uZGlmZiA9IGRpZmY7XG4gICAgcHJvdG8uZW5kT2YgPSBlbmRPZjtcbiAgICBwcm90by5mb3JtYXQgPSBmb3JtYXQ7XG4gICAgcHJvdG8uZnJvbSA9IGZyb207XG4gICAgcHJvdG8uZnJvbU5vdyA9IGZyb21Ob3c7XG4gICAgcHJvdG8udG8gPSB0bztcbiAgICBwcm90by50b05vdyA9IHRvTm93O1xuICAgIHByb3RvLmdldCA9IHN0cmluZ0dldDtcbiAgICBwcm90by5pbnZhbGlkQXQgPSBpbnZhbGlkQXQ7XG4gICAgcHJvdG8uaXNBZnRlciA9IGlzQWZ0ZXI7XG4gICAgcHJvdG8uaXNCZWZvcmUgPSBpc0JlZm9yZTtcbiAgICBwcm90by5pc0JldHdlZW4gPSBpc0JldHdlZW47XG4gICAgcHJvdG8uaXNTYW1lID0gaXNTYW1lO1xuICAgIHByb3RvLmlzU2FtZU9yQWZ0ZXIgPSBpc1NhbWVPckFmdGVyO1xuICAgIHByb3RvLmlzU2FtZU9yQmVmb3JlID0gaXNTYW1lT3JCZWZvcmU7XG4gICAgcHJvdG8uaXNWYWxpZCA9IGlzVmFsaWQkMjtcbiAgICBwcm90by5sYW5nID0gbGFuZztcbiAgICBwcm90by5sb2NhbGUgPSBsb2NhbGU7XG4gICAgcHJvdG8ubG9jYWxlRGF0YSA9IGxvY2FsZURhdGE7XG4gICAgcHJvdG8ubWF4ID0gcHJvdG90eXBlTWF4O1xuICAgIHByb3RvLm1pbiA9IHByb3RvdHlwZU1pbjtcbiAgICBwcm90by5wYXJzaW5nRmxhZ3MgPSBwYXJzaW5nRmxhZ3M7XG4gICAgcHJvdG8uc2V0ID0gc3RyaW5nU2V0O1xuICAgIHByb3RvLnN0YXJ0T2YgPSBzdGFydE9mO1xuICAgIHByb3RvLnN1YnRyYWN0ID0gc3VidHJhY3Q7XG4gICAgcHJvdG8udG9BcnJheSA9IHRvQXJyYXk7XG4gICAgcHJvdG8udG9PYmplY3QgPSB0b09iamVjdDtcbiAgICBwcm90by50b0RhdGUgPSB0b0RhdGU7XG4gICAgcHJvdG8udG9JU09TdHJpbmcgPSB0b0lTT1N0cmluZztcbiAgICBwcm90by5pbnNwZWN0ID0gaW5zcGVjdDtcbiAgICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLmZvciAhPSBudWxsKSB7XG4gICAgICAgIHByb3RvW1N5bWJvbC5mb3IoJ25vZGVqcy51dGlsLmluc3BlY3QuY3VzdG9tJyldID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICdNb21lbnQ8JyArIHRoaXMuZm9ybWF0KCkgKyAnPic7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHByb3RvLnRvSlNPTiA9IHRvSlNPTjtcbiAgICBwcm90by50b1N0cmluZyA9IHRvU3RyaW5nO1xuICAgIHByb3RvLnVuaXggPSB1bml4O1xuICAgIHByb3RvLnZhbHVlT2YgPSB2YWx1ZU9mO1xuICAgIHByb3RvLmNyZWF0aW9uRGF0YSA9IGNyZWF0aW9uRGF0YTtcbiAgICBwcm90by5lcmFOYW1lID0gZ2V0RXJhTmFtZTtcbiAgICBwcm90by5lcmFOYXJyb3cgPSBnZXRFcmFOYXJyb3c7XG4gICAgcHJvdG8uZXJhQWJiciA9IGdldEVyYUFiYnI7XG4gICAgcHJvdG8uZXJhWWVhciA9IGdldEVyYVllYXI7XG4gICAgcHJvdG8ueWVhciA9IGdldFNldFllYXI7XG4gICAgcHJvdG8uaXNMZWFwWWVhciA9IGdldElzTGVhcFllYXI7XG4gICAgcHJvdG8ud2Vla1llYXIgPSBnZXRTZXRXZWVrWWVhcjtcbiAgICBwcm90by5pc29XZWVrWWVhciA9IGdldFNldElTT1dlZWtZZWFyO1xuICAgIHByb3RvLnF1YXJ0ZXIgPSBwcm90by5xdWFydGVycyA9IGdldFNldFF1YXJ0ZXI7XG4gICAgcHJvdG8ubW9udGggPSBnZXRTZXRNb250aDtcbiAgICBwcm90by5kYXlzSW5Nb250aCA9IGdldERheXNJbk1vbnRoO1xuICAgIHByb3RvLndlZWsgPSBwcm90by53ZWVrcyA9IGdldFNldFdlZWs7XG4gICAgcHJvdG8uaXNvV2VlayA9IHByb3RvLmlzb1dlZWtzID0gZ2V0U2V0SVNPV2VlaztcbiAgICBwcm90by53ZWVrc0luWWVhciA9IGdldFdlZWtzSW5ZZWFyO1xuICAgIHByb3RvLndlZWtzSW5XZWVrWWVhciA9IGdldFdlZWtzSW5XZWVrWWVhcjtcbiAgICBwcm90by5pc29XZWVrc0luWWVhciA9IGdldElTT1dlZWtzSW5ZZWFyO1xuICAgIHByb3RvLmlzb1dlZWtzSW5JU09XZWVrWWVhciA9IGdldElTT1dlZWtzSW5JU09XZWVrWWVhcjtcbiAgICBwcm90by5kYXRlID0gZ2V0U2V0RGF5T2ZNb250aDtcbiAgICBwcm90by5kYXkgPSBwcm90by5kYXlzID0gZ2V0U2V0RGF5T2ZXZWVrO1xuICAgIHByb3RvLndlZWtkYXkgPSBnZXRTZXRMb2NhbGVEYXlPZldlZWs7XG4gICAgcHJvdG8uaXNvV2Vla2RheSA9IGdldFNldElTT0RheU9mV2VlaztcbiAgICBwcm90by5kYXlPZlllYXIgPSBnZXRTZXREYXlPZlllYXI7XG4gICAgcHJvdG8uaG91ciA9IHByb3RvLmhvdXJzID0gZ2V0U2V0SG91cjtcbiAgICBwcm90by5taW51dGUgPSBwcm90by5taW51dGVzID0gZ2V0U2V0TWludXRlO1xuICAgIHByb3RvLnNlY29uZCA9IHByb3RvLnNlY29uZHMgPSBnZXRTZXRTZWNvbmQ7XG4gICAgcHJvdG8ubWlsbGlzZWNvbmQgPSBwcm90by5taWxsaXNlY29uZHMgPSBnZXRTZXRNaWxsaXNlY29uZDtcbiAgICBwcm90by51dGNPZmZzZXQgPSBnZXRTZXRPZmZzZXQ7XG4gICAgcHJvdG8udXRjID0gc2V0T2Zmc2V0VG9VVEM7XG4gICAgcHJvdG8ubG9jYWwgPSBzZXRPZmZzZXRUb0xvY2FsO1xuICAgIHByb3RvLnBhcnNlWm9uZSA9IHNldE9mZnNldFRvUGFyc2VkT2Zmc2V0O1xuICAgIHByb3RvLmhhc0FsaWduZWRIb3VyT2Zmc2V0ID0gaGFzQWxpZ25lZEhvdXJPZmZzZXQ7XG4gICAgcHJvdG8uaXNEU1QgPSBpc0RheWxpZ2h0U2F2aW5nVGltZTtcbiAgICBwcm90by5pc0xvY2FsID0gaXNMb2NhbDtcbiAgICBwcm90by5pc1V0Y09mZnNldCA9IGlzVXRjT2Zmc2V0O1xuICAgIHByb3RvLmlzVXRjID0gaXNVdGM7XG4gICAgcHJvdG8uaXNVVEMgPSBpc1V0YztcbiAgICBwcm90by56b25lQWJiciA9IGdldFpvbmVBYmJyO1xuICAgIHByb3RvLnpvbmVOYW1lID0gZ2V0Wm9uZU5hbWU7XG4gICAgcHJvdG8uZGF0ZXMgPSBkZXByZWNhdGUoXG4gICAgICAgICdkYXRlcyBhY2Nlc3NvciBpcyBkZXByZWNhdGVkLiBVc2UgZGF0ZSBpbnN0ZWFkLicsXG4gICAgICAgIGdldFNldERheU9mTW9udGhcbiAgICApO1xuICAgIHByb3RvLm1vbnRocyA9IGRlcHJlY2F0ZShcbiAgICAgICAgJ21vbnRocyBhY2Nlc3NvciBpcyBkZXByZWNhdGVkLiBVc2UgbW9udGggaW5zdGVhZCcsXG4gICAgICAgIGdldFNldE1vbnRoXG4gICAgKTtcbiAgICBwcm90by55ZWFycyA9IGRlcHJlY2F0ZShcbiAgICAgICAgJ3llYXJzIGFjY2Vzc29yIGlzIGRlcHJlY2F0ZWQuIFVzZSB5ZWFyIGluc3RlYWQnLFxuICAgICAgICBnZXRTZXRZZWFyXG4gICAgKTtcbiAgICBwcm90by56b25lID0gZGVwcmVjYXRlKFxuICAgICAgICAnbW9tZW50KCkuem9uZSBpcyBkZXByZWNhdGVkLCB1c2UgbW9tZW50KCkudXRjT2Zmc2V0IGluc3RlYWQuIGh0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3Mvem9uZS8nLFxuICAgICAgICBnZXRTZXRab25lXG4gICAgKTtcbiAgICBwcm90by5pc0RTVFNoaWZ0ZWQgPSBkZXByZWNhdGUoXG4gICAgICAgICdpc0RTVFNoaWZ0ZWQgaXMgZGVwcmVjYXRlZC4gU2VlIGh0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3MvZHN0LXNoaWZ0ZWQvIGZvciBtb3JlIGluZm9ybWF0aW9uJyxcbiAgICAgICAgaXNEYXlsaWdodFNhdmluZ1RpbWVTaGlmdGVkXG4gICAgKTtcblxuICAgIGZ1bmN0aW9uIGNyZWF0ZVVuaXgoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUxvY2FsKGlucHV0ICogMTAwMCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlSW5ab25lKCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlTG9jYWwuYXBwbHkobnVsbCwgYXJndW1lbnRzKS5wYXJzZVpvbmUoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcmVQYXJzZVBvc3RGb3JtYXQoc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgfVxuXG4gICAgdmFyIHByb3RvJDEgPSBMb2NhbGUucHJvdG90eXBlO1xuXG4gICAgcHJvdG8kMS5jYWxlbmRhciA9IGNhbGVuZGFyO1xuICAgIHByb3RvJDEubG9uZ0RhdGVGb3JtYXQgPSBsb25nRGF0ZUZvcm1hdDtcbiAgICBwcm90byQxLmludmFsaWREYXRlID0gaW52YWxpZERhdGU7XG4gICAgcHJvdG8kMS5vcmRpbmFsID0gb3JkaW5hbDtcbiAgICBwcm90byQxLnByZXBhcnNlID0gcHJlUGFyc2VQb3N0Rm9ybWF0O1xuICAgIHByb3RvJDEucG9zdGZvcm1hdCA9IHByZVBhcnNlUG9zdEZvcm1hdDtcbiAgICBwcm90byQxLnJlbGF0aXZlVGltZSA9IHJlbGF0aXZlVGltZTtcbiAgICBwcm90byQxLnBhc3RGdXR1cmUgPSBwYXN0RnV0dXJlO1xuICAgIHByb3RvJDEuc2V0ID0gc2V0O1xuICAgIHByb3RvJDEuZXJhcyA9IGxvY2FsZUVyYXM7XG4gICAgcHJvdG8kMS5lcmFzUGFyc2UgPSBsb2NhbGVFcmFzUGFyc2U7XG4gICAgcHJvdG8kMS5lcmFzQ29udmVydFllYXIgPSBsb2NhbGVFcmFzQ29udmVydFllYXI7XG4gICAgcHJvdG8kMS5lcmFzQWJiclJlZ2V4ID0gZXJhc0FiYnJSZWdleDtcbiAgICBwcm90byQxLmVyYXNOYW1lUmVnZXggPSBlcmFzTmFtZVJlZ2V4O1xuICAgIHByb3RvJDEuZXJhc05hcnJvd1JlZ2V4ID0gZXJhc05hcnJvd1JlZ2V4O1xuXG4gICAgcHJvdG8kMS5tb250aHMgPSBsb2NhbGVNb250aHM7XG4gICAgcHJvdG8kMS5tb250aHNTaG9ydCA9IGxvY2FsZU1vbnRoc1Nob3J0O1xuICAgIHByb3RvJDEubW9udGhzUGFyc2UgPSBsb2NhbGVNb250aHNQYXJzZTtcbiAgICBwcm90byQxLm1vbnRoc1JlZ2V4ID0gbW9udGhzUmVnZXg7XG4gICAgcHJvdG8kMS5tb250aHNTaG9ydFJlZ2V4ID0gbW9udGhzU2hvcnRSZWdleDtcbiAgICBwcm90byQxLndlZWsgPSBsb2NhbGVXZWVrO1xuICAgIHByb3RvJDEuZmlyc3REYXlPZlllYXIgPSBsb2NhbGVGaXJzdERheU9mWWVhcjtcbiAgICBwcm90byQxLmZpcnN0RGF5T2ZXZWVrID0gbG9jYWxlRmlyc3REYXlPZldlZWs7XG5cbiAgICBwcm90byQxLndlZWtkYXlzID0gbG9jYWxlV2Vla2RheXM7XG4gICAgcHJvdG8kMS53ZWVrZGF5c01pbiA9IGxvY2FsZVdlZWtkYXlzTWluO1xuICAgIHByb3RvJDEud2Vla2RheXNTaG9ydCA9IGxvY2FsZVdlZWtkYXlzU2hvcnQ7XG4gICAgcHJvdG8kMS53ZWVrZGF5c1BhcnNlID0gbG9jYWxlV2Vla2RheXNQYXJzZTtcblxuICAgIHByb3RvJDEud2Vla2RheXNSZWdleCA9IHdlZWtkYXlzUmVnZXg7XG4gICAgcHJvdG8kMS53ZWVrZGF5c1Nob3J0UmVnZXggPSB3ZWVrZGF5c1Nob3J0UmVnZXg7XG4gICAgcHJvdG8kMS53ZWVrZGF5c01pblJlZ2V4ID0gd2Vla2RheXNNaW5SZWdleDtcblxuICAgIHByb3RvJDEuaXNQTSA9IGxvY2FsZUlzUE07XG4gICAgcHJvdG8kMS5tZXJpZGllbSA9IGxvY2FsZU1lcmlkaWVtO1xuXG4gICAgZnVuY3Rpb24gZ2V0JDEoZm9ybWF0LCBpbmRleCwgZmllbGQsIHNldHRlcikge1xuICAgICAgICB2YXIgbG9jYWxlID0gZ2V0TG9jYWxlKCksXG4gICAgICAgICAgICB1dGMgPSBjcmVhdGVVVEMoKS5zZXQoc2V0dGVyLCBpbmRleCk7XG4gICAgICAgIHJldHVybiBsb2NhbGVbZmllbGRdKHV0YywgZm9ybWF0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaXN0TW9udGhzSW1wbChmb3JtYXQsIGluZGV4LCBmaWVsZCkge1xuICAgICAgICBpZiAoaXNOdW1iZXIoZm9ybWF0KSkge1xuICAgICAgICAgICAgaW5kZXggPSBmb3JtYXQ7XG4gICAgICAgICAgICBmb3JtYXQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBmb3JtYXQgPSBmb3JtYXQgfHwgJyc7XG5cbiAgICAgICAgaWYgKGluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXQkMShmb3JtYXQsIGluZGV4LCBmaWVsZCwgJ21vbnRoJyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgIG91dCA9IFtdO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTI7IGkrKykge1xuICAgICAgICAgICAgb3V0W2ldID0gZ2V0JDEoZm9ybWF0LCBpLCBmaWVsZCwgJ21vbnRoJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG5cbiAgICAvLyAoKVxuICAgIC8vICg1KVxuICAgIC8vIChmbXQsIDUpXG4gICAgLy8gKGZtdClcbiAgICAvLyAodHJ1ZSlcbiAgICAvLyAodHJ1ZSwgNSlcbiAgICAvLyAodHJ1ZSwgZm10LCA1KVxuICAgIC8vICh0cnVlLCBmbXQpXG4gICAgZnVuY3Rpb24gbGlzdFdlZWtkYXlzSW1wbChsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgsIGZpZWxkKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbG9jYWxlU29ydGVkID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIGlmIChpc051bWJlcihmb3JtYXQpKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBmb3JtYXQ7XG4gICAgICAgICAgICAgICAgZm9ybWF0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3JtYXQgPSBmb3JtYXQgfHwgJyc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3JtYXQgPSBsb2NhbGVTb3J0ZWQ7XG4gICAgICAgICAgICBpbmRleCA9IGZvcm1hdDtcbiAgICAgICAgICAgIGxvY2FsZVNvcnRlZCA9IGZhbHNlO1xuXG4gICAgICAgICAgICBpZiAoaXNOdW1iZXIoZm9ybWF0KSkge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gZm9ybWF0O1xuICAgICAgICAgICAgICAgIGZvcm1hdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9ybWF0ID0gZm9ybWF0IHx8ICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxvY2FsZSA9IGdldExvY2FsZSgpLFxuICAgICAgICAgICAgc2hpZnQgPSBsb2NhbGVTb3J0ZWQgPyBsb2NhbGUuX3dlZWsuZG93IDogMCxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBvdXQgPSBbXTtcblxuICAgICAgICBpZiAoaW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGdldCQxKGZvcm1hdCwgKGluZGV4ICsgc2hpZnQpICUgNywgZmllbGQsICdkYXknKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCA3OyBpKyspIHtcbiAgICAgICAgICAgIG91dFtpXSA9IGdldCQxKGZvcm1hdCwgKGkgKyBzaGlmdCkgJSA3LCBmaWVsZCwgJ2RheScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGlzdE1vbnRocyhmb3JtYXQsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBsaXN0TW9udGhzSW1wbChmb3JtYXQsIGluZGV4LCAnbW9udGhzJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGlzdE1vbnRoc1Nob3J0KGZvcm1hdCwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGxpc3RNb250aHNJbXBsKGZvcm1hdCwgaW5kZXgsICdtb250aHNTaG9ydCcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpc3RXZWVrZGF5cyhsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGxpc3RXZWVrZGF5c0ltcGwobG9jYWxlU29ydGVkLCBmb3JtYXQsIGluZGV4LCAnd2Vla2RheXMnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaXN0V2Vla2RheXNTaG9ydChsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGxpc3RXZWVrZGF5c0ltcGwobG9jYWxlU29ydGVkLCBmb3JtYXQsIGluZGV4LCAnd2Vla2RheXNTaG9ydCcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpc3RXZWVrZGF5c01pbihsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGxpc3RXZWVrZGF5c0ltcGwobG9jYWxlU29ydGVkLCBmb3JtYXQsIGluZGV4LCAnd2Vla2RheXNNaW4nKTtcbiAgICB9XG5cbiAgICBnZXRTZXRHbG9iYWxMb2NhbGUoJ2VuJywge1xuICAgICAgICBlcmFzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc2luY2U6ICcwMDAxLTAxLTAxJyxcbiAgICAgICAgICAgICAgICB1bnRpbDogK0luZmluaXR5LFxuICAgICAgICAgICAgICAgIG9mZnNldDogMSxcbiAgICAgICAgICAgICAgICBuYW1lOiAnQW5ubyBEb21pbmknLFxuICAgICAgICAgICAgICAgIG5hcnJvdzogJ0FEJyxcbiAgICAgICAgICAgICAgICBhYmJyOiAnQUQnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzaW5jZTogJzAwMDAtMTItMzEnLFxuICAgICAgICAgICAgICAgIHVudGlsOiAtSW5maW5pdHksXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiAxLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdCZWZvcmUgQ2hyaXN0JyxcbiAgICAgICAgICAgICAgICBuYXJyb3c6ICdCQycsXG4gICAgICAgICAgICAgICAgYWJicjogJ0JDJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgICAgIGRheU9mTW9udGhPcmRpbmFsUGFyc2U6IC9cXGR7MSwyfSh0aHxzdHxuZHxyZCkvLFxuICAgICAgICBvcmRpbmFsOiBmdW5jdGlvbiAobnVtYmVyKSB7XG4gICAgICAgICAgICB2YXIgYiA9IG51bWJlciAlIDEwLFxuICAgICAgICAgICAgICAgIG91dHB1dCA9XG4gICAgICAgICAgICAgICAgICAgIHRvSW50KChudW1iZXIgJSAxMDApIC8gMTApID09PSAxXG4gICAgICAgICAgICAgICAgICAgICAgICA/ICd0aCdcbiAgICAgICAgICAgICAgICAgICAgICAgIDogYiA9PT0gMVxuICAgICAgICAgICAgICAgICAgICAgICAgPyAnc3QnXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGIgPT09IDJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gJ25kJ1xuICAgICAgICAgICAgICAgICAgICAgICAgOiBiID09PSAzXG4gICAgICAgICAgICAgICAgICAgICAgICA/ICdyZCdcbiAgICAgICAgICAgICAgICAgICAgICAgIDogJ3RoJztcbiAgICAgICAgICAgIHJldHVybiBudW1iZXIgKyBvdXRwdXQ7XG4gICAgICAgIH0sXG4gICAgfSk7XG5cbiAgICAvLyBTaWRlIGVmZmVjdCBpbXBvcnRzXG5cbiAgICBob29rcy5sYW5nID0gZGVwcmVjYXRlKFxuICAgICAgICAnbW9tZW50LmxhbmcgaXMgZGVwcmVjYXRlZC4gVXNlIG1vbWVudC5sb2NhbGUgaW5zdGVhZC4nLFxuICAgICAgICBnZXRTZXRHbG9iYWxMb2NhbGVcbiAgICApO1xuICAgIGhvb2tzLmxhbmdEYXRhID0gZGVwcmVjYXRlKFxuICAgICAgICAnbW9tZW50LmxhbmdEYXRhIGlzIGRlcHJlY2F0ZWQuIFVzZSBtb21lbnQubG9jYWxlRGF0YSBpbnN0ZWFkLicsXG4gICAgICAgIGdldExvY2FsZVxuICAgICk7XG5cbiAgICB2YXIgbWF0aEFicyA9IE1hdGguYWJzO1xuXG4gICAgZnVuY3Rpb24gYWJzKCkge1xuICAgICAgICB2YXIgZGF0YSA9IHRoaXMuX2RhdGE7XG5cbiAgICAgICAgdGhpcy5fbWlsbGlzZWNvbmRzID0gbWF0aEFicyh0aGlzLl9taWxsaXNlY29uZHMpO1xuICAgICAgICB0aGlzLl9kYXlzID0gbWF0aEFicyh0aGlzLl9kYXlzKTtcbiAgICAgICAgdGhpcy5fbW9udGhzID0gbWF0aEFicyh0aGlzLl9tb250aHMpO1xuXG4gICAgICAgIGRhdGEubWlsbGlzZWNvbmRzID0gbWF0aEFicyhkYXRhLm1pbGxpc2Vjb25kcyk7XG4gICAgICAgIGRhdGEuc2Vjb25kcyA9IG1hdGhBYnMoZGF0YS5zZWNvbmRzKTtcbiAgICAgICAgZGF0YS5taW51dGVzID0gbWF0aEFicyhkYXRhLm1pbnV0ZXMpO1xuICAgICAgICBkYXRhLmhvdXJzID0gbWF0aEFicyhkYXRhLmhvdXJzKTtcbiAgICAgICAgZGF0YS5tb250aHMgPSBtYXRoQWJzKGRhdGEubW9udGhzKTtcbiAgICAgICAgZGF0YS55ZWFycyA9IG1hdGhBYnMoZGF0YS55ZWFycyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkU3VidHJhY3QkMShkdXJhdGlvbiwgaW5wdXQsIHZhbHVlLCBkaXJlY3Rpb24pIHtcbiAgICAgICAgdmFyIG90aGVyID0gY3JlYXRlRHVyYXRpb24oaW5wdXQsIHZhbHVlKTtcblxuICAgICAgICBkdXJhdGlvbi5fbWlsbGlzZWNvbmRzICs9IGRpcmVjdGlvbiAqIG90aGVyLl9taWxsaXNlY29uZHM7XG4gICAgICAgIGR1cmF0aW9uLl9kYXlzICs9IGRpcmVjdGlvbiAqIG90aGVyLl9kYXlzO1xuICAgICAgICBkdXJhdGlvbi5fbW9udGhzICs9IGRpcmVjdGlvbiAqIG90aGVyLl9tb250aHM7XG5cbiAgICAgICAgcmV0dXJuIGR1cmF0aW9uLl9idWJibGUoKTtcbiAgICB9XG5cbiAgICAvLyBzdXBwb3J0cyBvbmx5IDIuMC1zdHlsZSBhZGQoMSwgJ3MnKSBvciBhZGQoZHVyYXRpb24pXG4gICAgZnVuY3Rpb24gYWRkJDEoaW5wdXQsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBhZGRTdWJ0cmFjdCQxKHRoaXMsIGlucHV0LCB2YWx1ZSwgMSk7XG4gICAgfVxuXG4gICAgLy8gc3VwcG9ydHMgb25seSAyLjAtc3R5bGUgc3VidHJhY3QoMSwgJ3MnKSBvciBzdWJ0cmFjdChkdXJhdGlvbilcbiAgICBmdW5jdGlvbiBzdWJ0cmFjdCQxKGlucHV0LCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gYWRkU3VidHJhY3QkMSh0aGlzLCBpbnB1dCwgdmFsdWUsIC0xKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhYnNDZWlsKG51bWJlcikge1xuICAgICAgICBpZiAobnVtYmVyIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IobnVtYmVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmNlaWwobnVtYmVyKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJ1YmJsZSgpIHtcbiAgICAgICAgdmFyIG1pbGxpc2Vjb25kcyA9IHRoaXMuX21pbGxpc2Vjb25kcyxcbiAgICAgICAgICAgIGRheXMgPSB0aGlzLl9kYXlzLFxuICAgICAgICAgICAgbW9udGhzID0gdGhpcy5fbW9udGhzLFxuICAgICAgICAgICAgZGF0YSA9IHRoaXMuX2RhdGEsXG4gICAgICAgICAgICBzZWNvbmRzLFxuICAgICAgICAgICAgbWludXRlcyxcbiAgICAgICAgICAgIGhvdXJzLFxuICAgICAgICAgICAgeWVhcnMsXG4gICAgICAgICAgICBtb250aHNGcm9tRGF5cztcblxuICAgICAgICAvLyBpZiB3ZSBoYXZlIGEgbWl4IG9mIHBvc2l0aXZlIGFuZCBuZWdhdGl2ZSB2YWx1ZXMsIGJ1YmJsZSBkb3duIGZpcnN0XG4gICAgICAgIC8vIGNoZWNrOiBodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC9pc3N1ZXMvMjE2NlxuICAgICAgICBpZiAoXG4gICAgICAgICAgICAhKFxuICAgICAgICAgICAgICAgIChtaWxsaXNlY29uZHMgPj0gMCAmJiBkYXlzID49IDAgJiYgbW9udGhzID49IDApIHx8XG4gICAgICAgICAgICAgICAgKG1pbGxpc2Vjb25kcyA8PSAwICYmIGRheXMgPD0gMCAmJiBtb250aHMgPD0gMClcbiAgICAgICAgICAgIClcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBtaWxsaXNlY29uZHMgKz0gYWJzQ2VpbChtb250aHNUb0RheXMobW9udGhzKSArIGRheXMpICogODY0ZTU7XG4gICAgICAgICAgICBkYXlzID0gMDtcbiAgICAgICAgICAgIG1vbnRocyA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGUgZm9sbG93aW5nIGNvZGUgYnViYmxlcyB1cCB2YWx1ZXMsIHNlZSB0aGUgdGVzdHMgZm9yXG4gICAgICAgIC8vIGV4YW1wbGVzIG9mIHdoYXQgdGhhdCBtZWFucy5cbiAgICAgICAgZGF0YS5taWxsaXNlY29uZHMgPSBtaWxsaXNlY29uZHMgJSAxMDAwO1xuXG4gICAgICAgIHNlY29uZHMgPSBhYnNGbG9vcihtaWxsaXNlY29uZHMgLyAxMDAwKTtcbiAgICAgICAgZGF0YS5zZWNvbmRzID0gc2Vjb25kcyAlIDYwO1xuXG4gICAgICAgIG1pbnV0ZXMgPSBhYnNGbG9vcihzZWNvbmRzIC8gNjApO1xuICAgICAgICBkYXRhLm1pbnV0ZXMgPSBtaW51dGVzICUgNjA7XG5cbiAgICAgICAgaG91cnMgPSBhYnNGbG9vcihtaW51dGVzIC8gNjApO1xuICAgICAgICBkYXRhLmhvdXJzID0gaG91cnMgJSAyNDtcblxuICAgICAgICBkYXlzICs9IGFic0Zsb29yKGhvdXJzIC8gMjQpO1xuXG4gICAgICAgIC8vIGNvbnZlcnQgZGF5cyB0byBtb250aHNcbiAgICAgICAgbW9udGhzRnJvbURheXMgPSBhYnNGbG9vcihkYXlzVG9Nb250aHMoZGF5cykpO1xuICAgICAgICBtb250aHMgKz0gbW9udGhzRnJvbURheXM7XG4gICAgICAgIGRheXMgLT0gYWJzQ2VpbChtb250aHNUb0RheXMobW9udGhzRnJvbURheXMpKTtcblxuICAgICAgICAvLyAxMiBtb250aHMgLT4gMSB5ZWFyXG4gICAgICAgIHllYXJzID0gYWJzRmxvb3IobW9udGhzIC8gMTIpO1xuICAgICAgICBtb250aHMgJT0gMTI7XG5cbiAgICAgICAgZGF0YS5kYXlzID0gZGF5cztcbiAgICAgICAgZGF0YS5tb250aHMgPSBtb250aHM7XG4gICAgICAgIGRhdGEueWVhcnMgPSB5ZWFycztcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkYXlzVG9Nb250aHMoZGF5cykge1xuICAgICAgICAvLyA0MDAgeWVhcnMgaGF2ZSAxNDYwOTcgZGF5cyAodGFraW5nIGludG8gYWNjb3VudCBsZWFwIHllYXIgcnVsZXMpXG4gICAgICAgIC8vIDQwMCB5ZWFycyBoYXZlIDEyIG1vbnRocyA9PT0gNDgwMFxuICAgICAgICByZXR1cm4gKGRheXMgKiA0ODAwKSAvIDE0NjA5NztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb250aHNUb0RheXMobW9udGhzKSB7XG4gICAgICAgIC8vIHRoZSByZXZlcnNlIG9mIGRheXNUb01vbnRoc1xuICAgICAgICByZXR1cm4gKG1vbnRocyAqIDE0NjA5NykgLyA0ODAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFzKHVuaXRzKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRheXMsXG4gICAgICAgICAgICBtb250aHMsXG4gICAgICAgICAgICBtaWxsaXNlY29uZHMgPSB0aGlzLl9taWxsaXNlY29uZHM7XG5cbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG5cbiAgICAgICAgaWYgKHVuaXRzID09PSAnbW9udGgnIHx8IHVuaXRzID09PSAncXVhcnRlcicgfHwgdW5pdHMgPT09ICd5ZWFyJykge1xuICAgICAgICAgICAgZGF5cyA9IHRoaXMuX2RheXMgKyBtaWxsaXNlY29uZHMgLyA4NjRlNTtcbiAgICAgICAgICAgIG1vbnRocyA9IHRoaXMuX21vbnRocyArIGRheXNUb01vbnRocyhkYXlzKTtcbiAgICAgICAgICAgIHN3aXRjaCAodW5pdHMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdtb250aCc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtb250aHM7XG4gICAgICAgICAgICAgICAgY2FzZSAncXVhcnRlcic6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtb250aHMgLyAzO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3llYXInOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbW9udGhzIC8gMTI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBoYW5kbGUgbWlsbGlzZWNvbmRzIHNlcGFyYXRlbHkgYmVjYXVzZSBvZiBmbG9hdGluZyBwb2ludCBtYXRoIGVycm9ycyAoaXNzdWUgIzE4NjcpXG4gICAgICAgICAgICBkYXlzID0gdGhpcy5fZGF5cyArIE1hdGgucm91bmQobW9udGhzVG9EYXlzKHRoaXMuX21vbnRocykpO1xuICAgICAgICAgICAgc3dpdGNoICh1bml0cykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3dlZWsnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF5cyAvIDcgKyBtaWxsaXNlY29uZHMgLyA2MDQ4ZTU7XG4gICAgICAgICAgICAgICAgY2FzZSAnZGF5JzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRheXMgKyBtaWxsaXNlY29uZHMgLyA4NjRlNTtcbiAgICAgICAgICAgICAgICBjYXNlICdob3VyJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRheXMgKiAyNCArIG1pbGxpc2Vjb25kcyAvIDM2ZTU7XG4gICAgICAgICAgICAgICAgY2FzZSAnbWludXRlJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRheXMgKiAxNDQwICsgbWlsbGlzZWNvbmRzIC8gNmU0O1xuICAgICAgICAgICAgICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXlzICogODY0MDAgKyBtaWxsaXNlY29uZHMgLyAxMDAwO1xuICAgICAgICAgICAgICAgIC8vIE1hdGguZmxvb3IgcHJldmVudHMgZmxvYXRpbmcgcG9pbnQgbWF0aCBlcnJvcnMgaGVyZVxuICAgICAgICAgICAgICAgIGNhc2UgJ21pbGxpc2Vjb25kJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoZGF5cyAqIDg2NGU1KSArIG1pbGxpc2Vjb25kcztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gdW5pdCAnICsgdW5pdHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gVE9ETzogVXNlIHRoaXMuYXMoJ21zJyk/XG4gICAgZnVuY3Rpb24gdmFsdWVPZiQxKCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB0aGlzLl9taWxsaXNlY29uZHMgK1xuICAgICAgICAgICAgdGhpcy5fZGF5cyAqIDg2NGU1ICtcbiAgICAgICAgICAgICh0aGlzLl9tb250aHMgJSAxMikgKiAyNTkyZTYgK1xuICAgICAgICAgICAgdG9JbnQodGhpcy5fbW9udGhzIC8gMTIpICogMzE1MzZlNlxuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1ha2VBcyhhbGlhcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXMoYWxpYXMpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHZhciBhc01pbGxpc2Vjb25kcyA9IG1ha2VBcygnbXMnKSxcbiAgICAgICAgYXNTZWNvbmRzID0gbWFrZUFzKCdzJyksXG4gICAgICAgIGFzTWludXRlcyA9IG1ha2VBcygnbScpLFxuICAgICAgICBhc0hvdXJzID0gbWFrZUFzKCdoJyksXG4gICAgICAgIGFzRGF5cyA9IG1ha2VBcygnZCcpLFxuICAgICAgICBhc1dlZWtzID0gbWFrZUFzKCd3JyksXG4gICAgICAgIGFzTW9udGhzID0gbWFrZUFzKCdNJyksXG4gICAgICAgIGFzUXVhcnRlcnMgPSBtYWtlQXMoJ1EnKSxcbiAgICAgICAgYXNZZWFycyA9IG1ha2VBcygneScpO1xuXG4gICAgZnVuY3Rpb24gY2xvbmUkMSgpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUR1cmF0aW9uKHRoaXMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldCQyKHVuaXRzKSB7XG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuICAgICAgICByZXR1cm4gdGhpcy5pc1ZhbGlkKCkgPyB0aGlzW3VuaXRzICsgJ3MnXSgpIDogTmFOO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1ha2VHZXR0ZXIobmFtZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXNWYWxpZCgpID8gdGhpcy5fZGF0YVtuYW1lXSA6IE5hTjtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgbWlsbGlzZWNvbmRzID0gbWFrZUdldHRlcignbWlsbGlzZWNvbmRzJyksXG4gICAgICAgIHNlY29uZHMgPSBtYWtlR2V0dGVyKCdzZWNvbmRzJyksXG4gICAgICAgIG1pbnV0ZXMgPSBtYWtlR2V0dGVyKCdtaW51dGVzJyksXG4gICAgICAgIGhvdXJzID0gbWFrZUdldHRlcignaG91cnMnKSxcbiAgICAgICAgZGF5cyA9IG1ha2VHZXR0ZXIoJ2RheXMnKSxcbiAgICAgICAgbW9udGhzID0gbWFrZUdldHRlcignbW9udGhzJyksXG4gICAgICAgIHllYXJzID0gbWFrZUdldHRlcigneWVhcnMnKTtcblxuICAgIGZ1bmN0aW9uIHdlZWtzKCkge1xuICAgICAgICByZXR1cm4gYWJzRmxvb3IodGhpcy5kYXlzKCkgLyA3KTtcbiAgICB9XG5cbiAgICB2YXIgcm91bmQgPSBNYXRoLnJvdW5kLFxuICAgICAgICB0aHJlc2hvbGRzID0ge1xuICAgICAgICAgICAgc3M6IDQ0LCAvLyBhIGZldyBzZWNvbmRzIHRvIHNlY29uZHNcbiAgICAgICAgICAgIHM6IDQ1LCAvLyBzZWNvbmRzIHRvIG1pbnV0ZVxuICAgICAgICAgICAgbTogNDUsIC8vIG1pbnV0ZXMgdG8gaG91clxuICAgICAgICAgICAgaDogMjIsIC8vIGhvdXJzIHRvIGRheVxuICAgICAgICAgICAgZDogMjYsIC8vIGRheXMgdG8gbW9udGgvd2Vla1xuICAgICAgICAgICAgdzogbnVsbCwgLy8gd2Vla3MgdG8gbW9udGhcbiAgICAgICAgICAgIE06IDExLCAvLyBtb250aHMgdG8geWVhclxuICAgICAgICB9O1xuXG4gICAgLy8gaGVscGVyIGZ1bmN0aW9uIGZvciBtb21lbnQuZm4uZnJvbSwgbW9tZW50LmZuLmZyb21Ob3csIGFuZCBtb21lbnQuZHVyYXRpb24uZm4uaHVtYW5pemVcbiAgICBmdW5jdGlvbiBzdWJzdGl0dXRlVGltZUFnbyhzdHJpbmcsIG51bWJlciwgd2l0aG91dFN1ZmZpeCwgaXNGdXR1cmUsIGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gbG9jYWxlLnJlbGF0aXZlVGltZShudW1iZXIgfHwgMSwgISF3aXRob3V0U3VmZml4LCBzdHJpbmcsIGlzRnV0dXJlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWxhdGl2ZVRpbWUkMShwb3NOZWdEdXJhdGlvbiwgd2l0aG91dFN1ZmZpeCwgdGhyZXNob2xkcywgbG9jYWxlKSB7XG4gICAgICAgIHZhciBkdXJhdGlvbiA9IGNyZWF0ZUR1cmF0aW9uKHBvc05lZ0R1cmF0aW9uKS5hYnMoKSxcbiAgICAgICAgICAgIHNlY29uZHMgPSByb3VuZChkdXJhdGlvbi5hcygncycpKSxcbiAgICAgICAgICAgIG1pbnV0ZXMgPSByb3VuZChkdXJhdGlvbi5hcygnbScpKSxcbiAgICAgICAgICAgIGhvdXJzID0gcm91bmQoZHVyYXRpb24uYXMoJ2gnKSksXG4gICAgICAgICAgICBkYXlzID0gcm91bmQoZHVyYXRpb24uYXMoJ2QnKSksXG4gICAgICAgICAgICBtb250aHMgPSByb3VuZChkdXJhdGlvbi5hcygnTScpKSxcbiAgICAgICAgICAgIHdlZWtzID0gcm91bmQoZHVyYXRpb24uYXMoJ3cnKSksXG4gICAgICAgICAgICB5ZWFycyA9IHJvdW5kKGR1cmF0aW9uLmFzKCd5JykpLFxuICAgICAgICAgICAgYSA9XG4gICAgICAgICAgICAgICAgKHNlY29uZHMgPD0gdGhyZXNob2xkcy5zcyAmJiBbJ3MnLCBzZWNvbmRzXSkgfHxcbiAgICAgICAgICAgICAgICAoc2Vjb25kcyA8IHRocmVzaG9sZHMucyAmJiBbJ3NzJywgc2Vjb25kc10pIHx8XG4gICAgICAgICAgICAgICAgKG1pbnV0ZXMgPD0gMSAmJiBbJ20nXSkgfHxcbiAgICAgICAgICAgICAgICAobWludXRlcyA8IHRocmVzaG9sZHMubSAmJiBbJ21tJywgbWludXRlc10pIHx8XG4gICAgICAgICAgICAgICAgKGhvdXJzIDw9IDEgJiYgWydoJ10pIHx8XG4gICAgICAgICAgICAgICAgKGhvdXJzIDwgdGhyZXNob2xkcy5oICYmIFsnaGgnLCBob3Vyc10pIHx8XG4gICAgICAgICAgICAgICAgKGRheXMgPD0gMSAmJiBbJ2QnXSkgfHxcbiAgICAgICAgICAgICAgICAoZGF5cyA8IHRocmVzaG9sZHMuZCAmJiBbJ2RkJywgZGF5c10pO1xuXG4gICAgICAgIGlmICh0aHJlc2hvbGRzLncgIT0gbnVsbCkge1xuICAgICAgICAgICAgYSA9XG4gICAgICAgICAgICAgICAgYSB8fFxuICAgICAgICAgICAgICAgICh3ZWVrcyA8PSAxICYmIFsndyddKSB8fFxuICAgICAgICAgICAgICAgICh3ZWVrcyA8IHRocmVzaG9sZHMudyAmJiBbJ3d3Jywgd2Vla3NdKTtcbiAgICAgICAgfVxuICAgICAgICBhID0gYSB8fFxuICAgICAgICAgICAgKG1vbnRocyA8PSAxICYmIFsnTSddKSB8fFxuICAgICAgICAgICAgKG1vbnRocyA8IHRocmVzaG9sZHMuTSAmJiBbJ01NJywgbW9udGhzXSkgfHxcbiAgICAgICAgICAgICh5ZWFycyA8PSAxICYmIFsneSddKSB8fCBbJ3l5JywgeWVhcnNdO1xuXG4gICAgICAgIGFbMl0gPSB3aXRob3V0U3VmZml4O1xuICAgICAgICBhWzNdID0gK3Bvc05lZ0R1cmF0aW9uID4gMDtcbiAgICAgICAgYVs0XSA9IGxvY2FsZTtcbiAgICAgICAgcmV0dXJuIHN1YnN0aXR1dGVUaW1lQWdvLmFwcGx5KG51bGwsIGEpO1xuICAgIH1cblxuICAgIC8vIFRoaXMgZnVuY3Rpb24gYWxsb3dzIHlvdSB0byBzZXQgdGhlIHJvdW5kaW5nIGZ1bmN0aW9uIGZvciByZWxhdGl2ZSB0aW1lIHN0cmluZ3NcbiAgICBmdW5jdGlvbiBnZXRTZXRSZWxhdGl2ZVRpbWVSb3VuZGluZyhyb3VuZGluZ0Z1bmN0aW9uKSB7XG4gICAgICAgIGlmIChyb3VuZGluZ0Z1bmN0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiByb3VuZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHJvdW5kaW5nRnVuY3Rpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJvdW5kID0gcm91bmRpbmdGdW5jdGlvbjtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBUaGlzIGZ1bmN0aW9uIGFsbG93cyB5b3UgdG8gc2V0IGEgdGhyZXNob2xkIGZvciByZWxhdGl2ZSB0aW1lIHN0cmluZ3NcbiAgICBmdW5jdGlvbiBnZXRTZXRSZWxhdGl2ZVRpbWVUaHJlc2hvbGQodGhyZXNob2xkLCBsaW1pdCkge1xuICAgICAgICBpZiAodGhyZXNob2xkc1t0aHJlc2hvbGRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGltaXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRocmVzaG9sZHNbdGhyZXNob2xkXTtcbiAgICAgICAgfVxuICAgICAgICB0aHJlc2hvbGRzW3RocmVzaG9sZF0gPSBsaW1pdDtcbiAgICAgICAgaWYgKHRocmVzaG9sZCA9PT0gJ3MnKSB7XG4gICAgICAgICAgICB0aHJlc2hvbGRzLnNzID0gbGltaXQgLSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGh1bWFuaXplKGFyZ1dpdGhTdWZmaXgsIGFyZ1RocmVzaG9sZHMpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLmludmFsaWREYXRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgd2l0aFN1ZmZpeCA9IGZhbHNlLFxuICAgICAgICAgICAgdGggPSB0aHJlc2hvbGRzLFxuICAgICAgICAgICAgbG9jYWxlLFxuICAgICAgICAgICAgb3V0cHV0O1xuXG4gICAgICAgIGlmICh0eXBlb2YgYXJnV2l0aFN1ZmZpeCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGFyZ1RocmVzaG9sZHMgPSBhcmdXaXRoU3VmZml4O1xuICAgICAgICAgICAgYXJnV2l0aFN1ZmZpeCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgYXJnV2l0aFN1ZmZpeCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICB3aXRoU3VmZml4ID0gYXJnV2l0aFN1ZmZpeDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGFyZ1RocmVzaG9sZHMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICB0aCA9IE9iamVjdC5hc3NpZ24oe30sIHRocmVzaG9sZHMsIGFyZ1RocmVzaG9sZHMpO1xuICAgICAgICAgICAgaWYgKGFyZ1RocmVzaG9sZHMucyAhPSBudWxsICYmIGFyZ1RocmVzaG9sZHMuc3MgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoLnNzID0gYXJnVGhyZXNob2xkcy5zIC0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxvY2FsZSA9IHRoaXMubG9jYWxlRGF0YSgpO1xuICAgICAgICBvdXRwdXQgPSByZWxhdGl2ZVRpbWUkMSh0aGlzLCAhd2l0aFN1ZmZpeCwgdGgsIGxvY2FsZSk7XG5cbiAgICAgICAgaWYgKHdpdGhTdWZmaXgpIHtcbiAgICAgICAgICAgIG91dHB1dCA9IGxvY2FsZS5wYXN0RnV0dXJlKCt0aGlzLCBvdXRwdXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGxvY2FsZS5wb3N0Zm9ybWF0KG91dHB1dCk7XG4gICAgfVxuXG4gICAgdmFyIGFicyQxID0gTWF0aC5hYnM7XG5cbiAgICBmdW5jdGlvbiBzaWduKHgpIHtcbiAgICAgICAgcmV0dXJuICh4ID4gMCkgLSAoeCA8IDApIHx8ICt4O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvSVNPU3RyaW5nJDEoKSB7XG4gICAgICAgIC8vIGZvciBJU08gc3RyaW5ncyB3ZSBkbyBub3QgdXNlIHRoZSBub3JtYWwgYnViYmxpbmcgcnVsZXM6XG4gICAgICAgIC8vICAqIG1pbGxpc2Vjb25kcyBidWJibGUgdXAgdW50aWwgdGhleSBiZWNvbWUgaG91cnNcbiAgICAgICAgLy8gICogZGF5cyBkbyBub3QgYnViYmxlIGF0IGFsbFxuICAgICAgICAvLyAgKiBtb250aHMgYnViYmxlIHVwIHVudGlsIHRoZXkgYmVjb21lIHllYXJzXG4gICAgICAgIC8vIFRoaXMgaXMgYmVjYXVzZSB0aGVyZSBpcyBubyBjb250ZXh0LWZyZWUgY29udmVyc2lvbiBiZXR3ZWVuIGhvdXJzIGFuZCBkYXlzXG4gICAgICAgIC8vICh0aGluayBvZiBjbG9jayBjaGFuZ2VzKVxuICAgICAgICAvLyBhbmQgYWxzbyBub3QgYmV0d2VlbiBkYXlzIGFuZCBtb250aHMgKDI4LTMxIGRheXMgcGVyIG1vbnRoKVxuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkuaW52YWxpZERhdGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzZWNvbmRzID0gYWJzJDEodGhpcy5fbWlsbGlzZWNvbmRzKSAvIDEwMDAsXG4gICAgICAgICAgICBkYXlzID0gYWJzJDEodGhpcy5fZGF5cyksXG4gICAgICAgICAgICBtb250aHMgPSBhYnMkMSh0aGlzLl9tb250aHMpLFxuICAgICAgICAgICAgbWludXRlcyxcbiAgICAgICAgICAgIGhvdXJzLFxuICAgICAgICAgICAgeWVhcnMsXG4gICAgICAgICAgICBzLFxuICAgICAgICAgICAgdG90YWwgPSB0aGlzLmFzU2Vjb25kcygpLFxuICAgICAgICAgICAgdG90YWxTaWduLFxuICAgICAgICAgICAgeW1TaWduLFxuICAgICAgICAgICAgZGF5c1NpZ24sXG4gICAgICAgICAgICBobXNTaWduO1xuXG4gICAgICAgIGlmICghdG90YWwpIHtcbiAgICAgICAgICAgIC8vIHRoaXMgaXMgdGhlIHNhbWUgYXMgQyMncyAoTm9kYSkgYW5kIHB5dGhvbiAoaXNvZGF0ZSkuLi5cbiAgICAgICAgICAgIC8vIGJ1dCBub3Qgb3RoZXIgSlMgKGdvb2cuZGF0ZSlcbiAgICAgICAgICAgIHJldHVybiAnUDBEJztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIDM2MDAgc2Vjb25kcyAtPiA2MCBtaW51dGVzIC0+IDEgaG91clxuICAgICAgICBtaW51dGVzID0gYWJzRmxvb3Ioc2Vjb25kcyAvIDYwKTtcbiAgICAgICAgaG91cnMgPSBhYnNGbG9vcihtaW51dGVzIC8gNjApO1xuICAgICAgICBzZWNvbmRzICU9IDYwO1xuICAgICAgICBtaW51dGVzICU9IDYwO1xuXG4gICAgICAgIC8vIDEyIG1vbnRocyAtPiAxIHllYXJcbiAgICAgICAgeWVhcnMgPSBhYnNGbG9vcihtb250aHMgLyAxMik7XG4gICAgICAgIG1vbnRocyAlPSAxMjtcblxuICAgICAgICAvLyBpbnNwaXJlZCBieSBodHRwczovL2dpdGh1Yi5jb20vZG9yZGlsbGUvbW9tZW50LWlzb2R1cmF0aW9uL2Jsb2IvbWFzdGVyL21vbWVudC5pc29kdXJhdGlvbi5qc1xuICAgICAgICBzID0gc2Vjb25kcyA/IHNlY29uZHMudG9GaXhlZCgzKS5yZXBsYWNlKC9cXC4/MCskLywgJycpIDogJyc7XG5cbiAgICAgICAgdG90YWxTaWduID0gdG90YWwgPCAwID8gJy0nIDogJyc7XG4gICAgICAgIHltU2lnbiA9IHNpZ24odGhpcy5fbW9udGhzKSAhPT0gc2lnbih0b3RhbCkgPyAnLScgOiAnJztcbiAgICAgICAgZGF5c1NpZ24gPSBzaWduKHRoaXMuX2RheXMpICE9PSBzaWduKHRvdGFsKSA/ICctJyA6ICcnO1xuICAgICAgICBobXNTaWduID0gc2lnbih0aGlzLl9taWxsaXNlY29uZHMpICE9PSBzaWduKHRvdGFsKSA/ICctJyA6ICcnO1xuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB0b3RhbFNpZ24gK1xuICAgICAgICAgICAgJ1AnICtcbiAgICAgICAgICAgICh5ZWFycyA/IHltU2lnbiArIHllYXJzICsgJ1knIDogJycpICtcbiAgICAgICAgICAgIChtb250aHMgPyB5bVNpZ24gKyBtb250aHMgKyAnTScgOiAnJykgK1xuICAgICAgICAgICAgKGRheXMgPyBkYXlzU2lnbiArIGRheXMgKyAnRCcgOiAnJykgK1xuICAgICAgICAgICAgKGhvdXJzIHx8IG1pbnV0ZXMgfHwgc2Vjb25kcyA/ICdUJyA6ICcnKSArXG4gICAgICAgICAgICAoaG91cnMgPyBobXNTaWduICsgaG91cnMgKyAnSCcgOiAnJykgK1xuICAgICAgICAgICAgKG1pbnV0ZXMgPyBobXNTaWduICsgbWludXRlcyArICdNJyA6ICcnKSArXG4gICAgICAgICAgICAoc2Vjb25kcyA/IGhtc1NpZ24gKyBzICsgJ1MnIDogJycpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgdmFyIHByb3RvJDIgPSBEdXJhdGlvbi5wcm90b3R5cGU7XG5cbiAgICBwcm90byQyLmlzVmFsaWQgPSBpc1ZhbGlkJDE7XG4gICAgcHJvdG8kMi5hYnMgPSBhYnM7XG4gICAgcHJvdG8kMi5hZGQgPSBhZGQkMTtcbiAgICBwcm90byQyLnN1YnRyYWN0ID0gc3VidHJhY3QkMTtcbiAgICBwcm90byQyLmFzID0gYXM7XG4gICAgcHJvdG8kMi5hc01pbGxpc2Vjb25kcyA9IGFzTWlsbGlzZWNvbmRzO1xuICAgIHByb3RvJDIuYXNTZWNvbmRzID0gYXNTZWNvbmRzO1xuICAgIHByb3RvJDIuYXNNaW51dGVzID0gYXNNaW51dGVzO1xuICAgIHByb3RvJDIuYXNIb3VycyA9IGFzSG91cnM7XG4gICAgcHJvdG8kMi5hc0RheXMgPSBhc0RheXM7XG4gICAgcHJvdG8kMi5hc1dlZWtzID0gYXNXZWVrcztcbiAgICBwcm90byQyLmFzTW9udGhzID0gYXNNb250aHM7XG4gICAgcHJvdG8kMi5hc1F1YXJ0ZXJzID0gYXNRdWFydGVycztcbiAgICBwcm90byQyLmFzWWVhcnMgPSBhc1llYXJzO1xuICAgIHByb3RvJDIudmFsdWVPZiA9IHZhbHVlT2YkMTtcbiAgICBwcm90byQyLl9idWJibGUgPSBidWJibGU7XG4gICAgcHJvdG8kMi5jbG9uZSA9IGNsb25lJDE7XG4gICAgcHJvdG8kMi5nZXQgPSBnZXQkMjtcbiAgICBwcm90byQyLm1pbGxpc2Vjb25kcyA9IG1pbGxpc2Vjb25kcztcbiAgICBwcm90byQyLnNlY29uZHMgPSBzZWNvbmRzO1xuICAgIHByb3RvJDIubWludXRlcyA9IG1pbnV0ZXM7XG4gICAgcHJvdG8kMi5ob3VycyA9IGhvdXJzO1xuICAgIHByb3RvJDIuZGF5cyA9IGRheXM7XG4gICAgcHJvdG8kMi53ZWVrcyA9IHdlZWtzO1xuICAgIHByb3RvJDIubW9udGhzID0gbW9udGhzO1xuICAgIHByb3RvJDIueWVhcnMgPSB5ZWFycztcbiAgICBwcm90byQyLmh1bWFuaXplID0gaHVtYW5pemU7XG4gICAgcHJvdG8kMi50b0lTT1N0cmluZyA9IHRvSVNPU3RyaW5nJDE7XG4gICAgcHJvdG8kMi50b1N0cmluZyA9IHRvSVNPU3RyaW5nJDE7XG4gICAgcHJvdG8kMi50b0pTT04gPSB0b0lTT1N0cmluZyQxO1xuICAgIHByb3RvJDIubG9jYWxlID0gbG9jYWxlO1xuICAgIHByb3RvJDIubG9jYWxlRGF0YSA9IGxvY2FsZURhdGE7XG5cbiAgICBwcm90byQyLnRvSXNvU3RyaW5nID0gZGVwcmVjYXRlKFxuICAgICAgICAndG9Jc29TdHJpbmcoKSBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIHRvSVNPU3RyaW5nKCkgaW5zdGVhZCAobm90aWNlIHRoZSBjYXBpdGFscyknLFxuICAgICAgICB0b0lTT1N0cmluZyQxXG4gICAgKTtcbiAgICBwcm90byQyLmxhbmcgPSBsYW5nO1xuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ1gnLCAwLCAwLCAndW5peCcpO1xuICAgIGFkZEZvcm1hdFRva2VuKCd4JywgMCwgMCwgJ3ZhbHVlT2YnKTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ3gnLCBtYXRjaFNpZ25lZCk7XG4gICAgYWRkUmVnZXhUb2tlbignWCcsIG1hdGNoVGltZXN0YW1wKTtcbiAgICBhZGRQYXJzZVRva2VuKCdYJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKHBhcnNlRmxvYXQoaW5wdXQpICogMTAwMCk7XG4gICAgfSk7XG4gICAgYWRkUGFyc2VUb2tlbigneCcsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZSh0b0ludChpbnB1dCkpO1xuICAgIH0pO1xuXG4gICAgLy8hIG1vbWVudC5qc1xuXG4gICAgaG9va3MudmVyc2lvbiA9ICcyLjI5LjQnO1xuXG4gICAgc2V0SG9va0NhbGxiYWNrKGNyZWF0ZUxvY2FsKTtcblxuICAgIGhvb2tzLmZuID0gcHJvdG87XG4gICAgaG9va3MubWluID0gbWluO1xuICAgIGhvb2tzLm1heCA9IG1heDtcbiAgICBob29rcy5ub3cgPSBub3c7XG4gICAgaG9va3MudXRjID0gY3JlYXRlVVRDO1xuICAgIGhvb2tzLnVuaXggPSBjcmVhdGVVbml4O1xuICAgIGhvb2tzLm1vbnRocyA9IGxpc3RNb250aHM7XG4gICAgaG9va3MuaXNEYXRlID0gaXNEYXRlO1xuICAgIGhvb2tzLmxvY2FsZSA9IGdldFNldEdsb2JhbExvY2FsZTtcbiAgICBob29rcy5pbnZhbGlkID0gY3JlYXRlSW52YWxpZDtcbiAgICBob29rcy5kdXJhdGlvbiA9IGNyZWF0ZUR1cmF0aW9uO1xuICAgIGhvb2tzLmlzTW9tZW50ID0gaXNNb21lbnQ7XG4gICAgaG9va3Mud2Vla2RheXMgPSBsaXN0V2Vla2RheXM7XG4gICAgaG9va3MucGFyc2Vab25lID0gY3JlYXRlSW5ab25lO1xuICAgIGhvb2tzLmxvY2FsZURhdGEgPSBnZXRMb2NhbGU7XG4gICAgaG9va3MuaXNEdXJhdGlvbiA9IGlzRHVyYXRpb247XG4gICAgaG9va3MubW9udGhzU2hvcnQgPSBsaXN0TW9udGhzU2hvcnQ7XG4gICAgaG9va3Mud2Vla2RheXNNaW4gPSBsaXN0V2Vla2RheXNNaW47XG4gICAgaG9va3MuZGVmaW5lTG9jYWxlID0gZGVmaW5lTG9jYWxlO1xuICAgIGhvb2tzLnVwZGF0ZUxvY2FsZSA9IHVwZGF0ZUxvY2FsZTtcbiAgICBob29rcy5sb2NhbGVzID0gbGlzdExvY2FsZXM7XG4gICAgaG9va3Mud2Vla2RheXNTaG9ydCA9IGxpc3RXZWVrZGF5c1Nob3J0O1xuICAgIGhvb2tzLm5vcm1hbGl6ZVVuaXRzID0gbm9ybWFsaXplVW5pdHM7XG4gICAgaG9va3MucmVsYXRpdmVUaW1lUm91bmRpbmcgPSBnZXRTZXRSZWxhdGl2ZVRpbWVSb3VuZGluZztcbiAgICBob29rcy5yZWxhdGl2ZVRpbWVUaHJlc2hvbGQgPSBnZXRTZXRSZWxhdGl2ZVRpbWVUaHJlc2hvbGQ7XG4gICAgaG9va3MuY2FsZW5kYXJGb3JtYXQgPSBnZXRDYWxlbmRhckZvcm1hdDtcbiAgICBob29rcy5wcm90b3R5cGUgPSBwcm90bztcblxuICAgIC8vIGN1cnJlbnRseSBIVE1MNSBpbnB1dCB0eXBlIG9ubHkgc3VwcG9ydHMgMjQtaG91ciBmb3JtYXRzXG4gICAgaG9va3MuSFRNTDVfRk1UID0ge1xuICAgICAgICBEQVRFVElNRV9MT0NBTDogJ1lZWVktTU0tRERUSEg6bW0nLCAvLyA8aW5wdXQgdHlwZT1cImRhdGV0aW1lLWxvY2FsXCIgLz5cbiAgICAgICAgREFURVRJTUVfTE9DQUxfU0VDT05EUzogJ1lZWVktTU0tRERUSEg6bW06c3MnLCAvLyA8aW5wdXQgdHlwZT1cImRhdGV0aW1lLWxvY2FsXCIgc3RlcD1cIjFcIiAvPlxuICAgICAgICBEQVRFVElNRV9MT0NBTF9NUzogJ1lZWVktTU0tRERUSEg6bW06c3MuU1NTJywgLy8gPGlucHV0IHR5cGU9XCJkYXRldGltZS1sb2NhbFwiIHN0ZXA9XCIwLjAwMVwiIC8+XG4gICAgICAgIERBVEU6ICdZWVlZLU1NLUREJywgLy8gPGlucHV0IHR5cGU9XCJkYXRlXCIgLz5cbiAgICAgICAgVElNRTogJ0hIOm1tJywgLy8gPGlucHV0IHR5cGU9XCJ0aW1lXCIgLz5cbiAgICAgICAgVElNRV9TRUNPTkRTOiAnSEg6bW06c3MnLCAvLyA8aW5wdXQgdHlwZT1cInRpbWVcIiBzdGVwPVwiMVwiIC8+XG4gICAgICAgIFRJTUVfTVM6ICdISDptbTpzcy5TU1MnLCAvLyA8aW5wdXQgdHlwZT1cInRpbWVcIiBzdGVwPVwiMC4wMDFcIiAvPlxuICAgICAgICBXRUVLOiAnR0dHRy1bV11XVycsIC8vIDxpbnB1dCB0eXBlPVwid2Vla1wiIC8+XG4gICAgICAgIE1PTlRIOiAnWVlZWS1NTScsIC8vIDxpbnB1dCB0eXBlPVwibW9udGhcIiAvPlxuICAgIH07XG5cbiAgICByZXR1cm4gaG9va3M7XG5cbn0pKSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/moment/moment.js\n");

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[2]!./src/components/Loading/loading.module.css":
/*!*******************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[2]!./src/components/Loading/loading.module.css ***!
  \*******************************************************************************************************************************************************************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("// Imports\nvar ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../../../node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js\");\nvar ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(true);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \".loading_profile_main_loader__07_qZ {\\n /* left: 50% !important;\\n margin-left: -100px;\\n position: fixed !important;\\n top: 50% !important;\\n margin-top: -100px;\\n width: 45px;*/\\n z-index: 9000 !important;\\n}\\n\\n.loading_profile_main_loader__07_qZ .loading_loader__ZuvLg {\\n position: relative;\\n margin: 0px auto;\\n width: auto;\\n height: auto;\\n}\\n.loading_profile_main_loader__07_qZ .loading_loader__ZuvLg:before {\\n content: \\\"\\\";\\n display: block;\\n padding-top: 100%;\\n}\\n\\n.loading_circular_loader__61Vvx {\\n -webkit-animation: loading_rotate__ij5oE 2s linear infinite;\\n animation: loading_rotate__ij5oE 2s linear infinite;\\n height: 100%;\\n transform-origin: center center;\\n width: 100%;\\n position: absolute;\\n top: 0;\\n left: 0;\\n margin: auto;\\n}\\n\\n.loading_loader_path___n6of {\\n stroke-dasharray: 150, 200;\\n stroke-dashoffset: -10;\\n -webkit-animation: loading_dash__HzS6p 1.5s ease-in-out infinite, loading_color__ETQqn 6s ease-in-out infinite;\\n animation: loading_dash__HzS6p 1.5s ease-in-out infinite, loading_color__ETQqn 6s ease-in-out infinite;\\n stroke-linecap: round;\\n}\\n\\n@-webkit-keyframes loading_rotate__ij5oE {\\n 100% {\\n  transform: rotate(360deg);\\n }\\n}\\n\\n@keyframes loading_rotate__ij5oE {\\n 100% {\\n  transform: rotate(360deg);\\n }\\n}\\n@-webkit-keyframes loading_dash__HzS6p {\\n 0% {\\n  stroke-dasharray: 1, 200;\\n  stroke-dashoffset: 0;\\n }\\n 50% {\\n  stroke-dasharray: 89, 200;\\n  stroke-dashoffset: -35;\\n }\\n 100% {\\n  stroke-dasharray: 89, 200;\\n  stroke-dashoffset: -124;\\n }\\n}\\n@keyframes loading_dash__HzS6p {\\n 0% {\\n  stroke-dasharray: 1, 200;\\n  stroke-dashoffset: 0;\\n }\\n 50% {\\n  stroke-dasharray: 89, 200;\\n  stroke-dashoffset: -35;\\n }\\n 100% {\\n  stroke-dasharray: 89, 200;\\n  stroke-dashoffset: -124;\\n }\\n}\\n@-webkit-keyframes loading_color__ETQqn {\\n 0% {\\n  stroke: var(--white-color);\\n }\\n 40% {\\n  stroke: var(--white-color);\\n }\\n 66% {\\n  stroke: var(--white-color);\\n }\\n 80%,\\n 90% {\\n  stroke: var(--white-color);\\n }\\n}\\n@keyframes loading_color__ETQqn {\\n 0% {\\n  stroke: var(--white-color);\\n }\\n 40% {\\n  stroke: var(--white-color);\\n }\\n 66% {\\n  stroke: var(--white-color);\\n }\\n 80%,\\n 90% {\\n  stroke: var(--white-color);\\n }\\n}\\n\", \"\",{\"version\":3,\"sources\":[\"webpack://src/components/Loading/loading.module.css\"],\"names\":[],\"mappings\":\"AAAA;CACC;;;;;cAKa;CACb,wBAAwB;AACzB;;AAEA;CACC,kBAAkB;CAClB,gBAAgB;CAChB,WAAW;CACX,YAAY;AACb;AACA;CACC,WAAW;CACX,cAAc;CACd,iBAAiB;AAClB;;AAEA;CACC,2DAA4C;CAC5C,mDAAoC;CACpC,YAAY;CAGZ,+BAA+B;CAC/B,WAAW;CACX,kBAAkB;CAClB,MAAM;CACN,OAAO;CACP,YAAY;AACb;;AAEA;CACC,0BAA0B;CAC1B,sBAAsB;CACtB,8GAAgF;CAChF,sGAAwE;CACxE,qBAAqB;AACtB;;AAEA;CACC;EAEC,yBAAyB;CAC1B;AACD;;AAEA;CACC;EAEC,yBAAyB;CAC1B;AACD;AACA;CACC;EACC,wBAAwB;EACxB,oBAAoB;CACrB;CACA;EACC,yBAAyB;EACzB,sBAAsB;CACvB;CACA;EACC,yBAAyB;EACzB,uBAAuB;CACxB;AACD;AACA;CACC;EACC,wBAAwB;EACxB,oBAAoB;CACrB;CACA;EACC,yBAAyB;EACzB,sBAAsB;CACvB;CACA;EACC,yBAAyB;EACzB,uBAAuB;CACxB;AACD;AACA;CACC;EACC,0BAA0B;CAC3B;CACA;EACC,0BAA0B;CAC3B;CACA;EACC,0BAA0B;CAC3B;CACA;;EAEC,0BAA0B;CAC3B;AACD;AACA;CACC;EACC,0BAA0B;CAC3B;CACA;EACC,0BAA0B;CAC3B;CACA;EACC,0BAA0B;CAC3B;CACA;;EAEC,0BAA0B;CAC3B;AACD\",\"sourcesContent\":[\".profile_main_loader {\\n /* left: 50% !important;\\n margin-left: -100px;\\n position: fixed !important;\\n top: 50% !important;\\n margin-top: -100px;\\n width: 45px;*/\\n z-index: 9000 !important;\\n}\\n\\n.profile_main_loader .loader {\\n position: relative;\\n margin: 0px auto;\\n width: auto;\\n height: auto;\\n}\\n.profile_main_loader .loader:before {\\n content: \\\"\\\";\\n display: block;\\n padding-top: 100%;\\n}\\n\\n.circular_loader {\\n -webkit-animation: rotate 2s linear infinite;\\n animation: rotate 2s linear infinite;\\n height: 100%;\\n -webkit-transform-origin: center center;\\n -ms-transform-origin: center center;\\n transform-origin: center center;\\n width: 100%;\\n position: absolute;\\n top: 0;\\n left: 0;\\n margin: auto;\\n}\\n\\n.loader_path {\\n stroke-dasharray: 150, 200;\\n stroke-dashoffset: -10;\\n -webkit-animation: dash 1.5s ease-in-out infinite, color 6s ease-in-out infinite;\\n animation: dash 1.5s ease-in-out infinite, color 6s ease-in-out infinite;\\n stroke-linecap: round;\\n}\\n\\n@-webkit-keyframes rotate {\\n 100% {\\n  -webkit-transform: rotate(360deg);\\n  transform: rotate(360deg);\\n }\\n}\\n\\n@keyframes rotate {\\n 100% {\\n  -webkit-transform: rotate(360deg);\\n  transform: rotate(360deg);\\n }\\n}\\n@-webkit-keyframes dash {\\n 0% {\\n  stroke-dasharray: 1, 200;\\n  stroke-dashoffset: 0;\\n }\\n 50% {\\n  stroke-dasharray: 89, 200;\\n  stroke-dashoffset: -35;\\n }\\n 100% {\\n  stroke-dasharray: 89, 200;\\n  stroke-dashoffset: -124;\\n }\\n}\\n@keyframes dash {\\n 0% {\\n  stroke-dasharray: 1, 200;\\n  stroke-dashoffset: 0;\\n }\\n 50% {\\n  stroke-dasharray: 89, 200;\\n  stroke-dashoffset: -35;\\n }\\n 100% {\\n  stroke-dasharray: 89, 200;\\n  stroke-dashoffset: -124;\\n }\\n}\\n@-webkit-keyframes color {\\n 0% {\\n  stroke: var(--white-color);\\n }\\n 40% {\\n  stroke: var(--white-color);\\n }\\n 66% {\\n  stroke: var(--white-color);\\n }\\n 80%,\\n 90% {\\n  stroke: var(--white-color);\\n }\\n}\\n@keyframes color {\\n 0% {\\n  stroke: var(--white-color);\\n }\\n 40% {\\n  stroke: var(--white-color);\\n }\\n 66% {\\n  stroke: var(--white-color);\\n }\\n 80%,\\n 90% {\\n  stroke: var(--white-color);\\n }\\n}\\n\"],\"sourceRoot\":\"\"}]);\n// Exports\n___CSS_LOADER_EXPORT___.locals = {\n\t\"profile_main_loader\": \"loading_profile_main_loader__07_qZ\",\n\t\"loader\": \"loading_loader__ZuvLg\",\n\t\"circular_loader\": \"loading_circular_loader__61Vvx\",\n\t\"rotate\": \"loading_rotate__ij5oE\",\n\t\"loader_path\": \"loading_loader_path___n6of\",\n\t\"dash\": \"loading_dash__HzS6p\",\n\t\"color\": \"loading_color__ETQqn\"\n};\nmodule.exports = ___CSS_LOADER_EXPORT___;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1szXS5vbmVPZls0XS51c2VbMV0hLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbM10ub25lT2ZbNF0udXNlWzJdIS4vc3JjL2NvbXBvbmVudHMvTG9hZGluZy9sb2FkaW5nLm1vZHVsZS5jc3MuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxrQ0FBa0MsbUJBQU8sQ0FBQyx5S0FBcUY7QUFDL0g7QUFDQTtBQUNBLCtFQUErRSwyQkFBMkIsdUJBQXVCLDhCQUE4Qix1QkFBdUIsc0JBQXNCLGVBQWUsOEJBQThCLEdBQUcsZ0VBQWdFLHNCQUFzQixvQkFBb0IsZUFBZSxnQkFBZ0IsR0FBRyxxRUFBcUUsaUJBQWlCLGtCQUFrQixxQkFBcUIsR0FBRyxxQ0FBcUMsK0RBQStELHVEQUF1RCxnQkFBZ0IsbUNBQW1DLGVBQWUsc0JBQXNCLFVBQVUsV0FBVyxnQkFBZ0IsR0FBRyxpQ0FBaUMsOEJBQThCLDBCQUEwQixrSEFBa0gsMEdBQTBHLHlCQUF5QixHQUFHLDhDQUE4QyxTQUFTLDhCQUE4QixJQUFJLEdBQUcsc0NBQXNDLFNBQVMsOEJBQThCLElBQUksR0FBRywwQ0FBMEMsT0FBTyw2QkFBNkIseUJBQXlCLElBQUksUUFBUSw4QkFBOEIsMkJBQTJCLElBQUksU0FBUyw4QkFBOEIsNEJBQTRCLElBQUksR0FBRyxrQ0FBa0MsT0FBTyw2QkFBNkIseUJBQXlCLElBQUksUUFBUSw4QkFBOEIsMkJBQTJCLElBQUksU0FBUyw4QkFBOEIsNEJBQTRCLElBQUksR0FBRywyQ0FBMkMsT0FBTywrQkFBK0IsSUFBSSxRQUFRLCtCQUErQixJQUFJLFFBQVEsK0JBQStCLElBQUksZUFBZSwrQkFBK0IsSUFBSSxHQUFHLG1DQUFtQyxPQUFPLCtCQUErQixJQUFJLFFBQVEsK0JBQStCLElBQUksUUFBUSwrQkFBK0IsSUFBSSxlQUFlLCtCQUErQixJQUFJLEdBQUcsU0FBUywwR0FBMEcsU0FBUyxLQUFLLFlBQVksT0FBTyxLQUFLLFlBQVksYUFBYSxXQUFXLFVBQVUsS0FBSyxLQUFLLFVBQVUsVUFBVSxZQUFZLE9BQU8sS0FBSyxZQUFZLGFBQWEsV0FBVyxZQUFZLFdBQVcsWUFBWSxXQUFXLFVBQVUsVUFBVSxNQUFNLEtBQUssWUFBWSxhQUFhLGFBQWEsYUFBYSxhQUFhLE9BQU8sS0FBSyxLQUFLLFlBQVksTUFBTSxNQUFNLEtBQUssS0FBSyxZQUFZLE1BQU0sS0FBSyxLQUFLLEtBQUssWUFBWSxhQUFhLE1BQU0sS0FBSyxZQUFZLGFBQWEsTUFBTSxLQUFLLFlBQVksYUFBYSxNQUFNLEtBQUssS0FBSyxLQUFLLFlBQVksYUFBYSxNQUFNLEtBQUssWUFBWSxhQUFhLE1BQU0sS0FBSyxZQUFZLGFBQWEsTUFBTSxLQUFLLEtBQUssS0FBSyxZQUFZLE1BQU0sS0FBSyxZQUFZLE1BQU0sS0FBSyxZQUFZLE1BQU0sTUFBTSxZQUFZLE1BQU0sS0FBSyxLQUFLLEtBQUssWUFBWSxNQUFNLEtBQUssWUFBWSxNQUFNLEtBQUssWUFBWSxNQUFNLE1BQU0sWUFBWSxNQUFNLCtDQUErQywyQkFBMkIsdUJBQXVCLDhCQUE4Qix1QkFBdUIsc0JBQXNCLGVBQWUsOEJBQThCLEdBQUcsa0NBQWtDLHNCQUFzQixvQkFBb0IsZUFBZSxnQkFBZ0IsR0FBRyx1Q0FBdUMsaUJBQWlCLGtCQUFrQixxQkFBcUIsR0FBRyxzQkFBc0IsZ0RBQWdELHdDQUF3QyxnQkFBZ0IsMkNBQTJDLHVDQUF1QyxtQ0FBbUMsZUFBZSxzQkFBc0IsVUFBVSxXQUFXLGdCQUFnQixHQUFHLGtCQUFrQiw4QkFBOEIsMEJBQTBCLG9GQUFvRiw0RUFBNEUseUJBQXlCLEdBQUcsK0JBQStCLFNBQVMsc0NBQXNDLDhCQUE4QixJQUFJLEdBQUcsdUJBQXVCLFNBQVMsc0NBQXNDLDhCQUE4QixJQUFJLEdBQUcsMkJBQTJCLE9BQU8sNkJBQTZCLHlCQUF5QixJQUFJLFFBQVEsOEJBQThCLDJCQUEyQixJQUFJLFNBQVMsOEJBQThCLDRCQUE0QixJQUFJLEdBQUcsbUJBQW1CLE9BQU8sNkJBQTZCLHlCQUF5QixJQUFJLFFBQVEsOEJBQThCLDJCQUEyQixJQUFJLFNBQVMsOEJBQThCLDRCQUE0QixJQUFJLEdBQUcsNEJBQTRCLE9BQU8sK0JBQStCLElBQUksUUFBUSwrQkFBK0IsSUFBSSxRQUFRLCtCQUErQixJQUFJLGVBQWUsK0JBQStCLElBQUksR0FBRyxvQkFBb0IsT0FBTywrQkFBK0IsSUFBSSxRQUFRLCtCQUErQixJQUFJLFFBQVEsK0JBQStCLElBQUksZUFBZSwrQkFBK0IsSUFBSSxHQUFHLHFCQUFxQjtBQUNsc0s7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvY29tcG9uZW50cy9Mb2FkaW5nL2xvYWRpbmcubW9kdWxlLmNzcz84NDIxIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEltcG9ydHNcbnZhciBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gPSByZXF1aXJlKFwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvY3NzLWxvYWRlci9zcmMvcnVudGltZS9hcGkuanNcIik7XG52YXIgX19fQ1NTX0xPQURFUl9FWFBPUlRfX18gPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18odHJ1ZSk7XG4vLyBNb2R1bGVcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLnB1c2goW21vZHVsZS5pZCwgXCIubG9hZGluZ19wcm9maWxlX21haW5fbG9hZGVyX18wN19xWiB7XFxuIC8qIGxlZnQ6IDUwJSAhaW1wb3J0YW50O1xcbiBtYXJnaW4tbGVmdDogLTEwMHB4O1xcbiBwb3NpdGlvbjogZml4ZWQgIWltcG9ydGFudDtcXG4gdG9wOiA1MCUgIWltcG9ydGFudDtcXG4gbWFyZ2luLXRvcDogLTEwMHB4O1xcbiB3aWR0aDogNDVweDsqL1xcbiB6LWluZGV4OiA5MDAwICFpbXBvcnRhbnQ7XFxufVxcblxcbi5sb2FkaW5nX3Byb2ZpbGVfbWFpbl9sb2FkZXJfXzA3X3FaIC5sb2FkaW5nX2xvYWRlcl9fWnV2TGcge1xcbiBwb3NpdGlvbjogcmVsYXRpdmU7XFxuIG1hcmdpbjogMHB4IGF1dG87XFxuIHdpZHRoOiBhdXRvO1xcbiBoZWlnaHQ6IGF1dG87XFxufVxcbi5sb2FkaW5nX3Byb2ZpbGVfbWFpbl9sb2FkZXJfXzA3X3FaIC5sb2FkaW5nX2xvYWRlcl9fWnV2TGc6YmVmb3JlIHtcXG4gY29udGVudDogXFxcIlxcXCI7XFxuIGRpc3BsYXk6IGJsb2NrO1xcbiBwYWRkaW5nLXRvcDogMTAwJTtcXG59XFxuXFxuLmxvYWRpbmdfY2lyY3VsYXJfbG9hZGVyX182MVZ2eCB7XFxuIC13ZWJraXQtYW5pbWF0aW9uOiBsb2FkaW5nX3JvdGF0ZV9faWo1b0UgMnMgbGluZWFyIGluZmluaXRlO1xcbiBhbmltYXRpb246IGxvYWRpbmdfcm90YXRlX19pajVvRSAycyBsaW5lYXIgaW5maW5pdGU7XFxuIGhlaWdodDogMTAwJTtcXG4gdHJhbnNmb3JtLW9yaWdpbjogY2VudGVyIGNlbnRlcjtcXG4gd2lkdGg6IDEwMCU7XFxuIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gdG9wOiAwO1xcbiBsZWZ0OiAwO1xcbiBtYXJnaW46IGF1dG87XFxufVxcblxcbi5sb2FkaW5nX2xvYWRlcl9wYXRoX19fbjZvZiB7XFxuIHN0cm9rZS1kYXNoYXJyYXk6IDE1MCwgMjAwO1xcbiBzdHJva2UtZGFzaG9mZnNldDogLTEwO1xcbiAtd2Via2l0LWFuaW1hdGlvbjogbG9hZGluZ19kYXNoX19IelM2cCAxLjVzIGVhc2UtaW4tb3V0IGluZmluaXRlLCBsb2FkaW5nX2NvbG9yX19FVFFxbiA2cyBlYXNlLWluLW91dCBpbmZpbml0ZTtcXG4gYW5pbWF0aW9uOiBsb2FkaW5nX2Rhc2hfX0h6UzZwIDEuNXMgZWFzZS1pbi1vdXQgaW5maW5pdGUsIGxvYWRpbmdfY29sb3JfX0VUUXFuIDZzIGVhc2UtaW4tb3V0IGluZmluaXRlO1xcbiBzdHJva2UtbGluZWNhcDogcm91bmQ7XFxufVxcblxcbkAtd2Via2l0LWtleWZyYW1lcyBsb2FkaW5nX3JvdGF0ZV9faWo1b0Uge1xcbiAxMDAlIHtcXG4gIHRyYW5zZm9ybTogcm90YXRlKDM2MGRlZyk7XFxuIH1cXG59XFxuXFxuQGtleWZyYW1lcyBsb2FkaW5nX3JvdGF0ZV9faWo1b0Uge1xcbiAxMDAlIHtcXG4gIHRyYW5zZm9ybTogcm90YXRlKDM2MGRlZyk7XFxuIH1cXG59XFxuQC13ZWJraXQta2V5ZnJhbWVzIGxvYWRpbmdfZGFzaF9fSHpTNnAge1xcbiAwJSB7XFxuICBzdHJva2UtZGFzaGFycmF5OiAxLCAyMDA7XFxuICBzdHJva2UtZGFzaG9mZnNldDogMDtcXG4gfVxcbiA1MCUge1xcbiAgc3Ryb2tlLWRhc2hhcnJheTogODksIDIwMDtcXG4gIHN0cm9rZS1kYXNob2Zmc2V0OiAtMzU7XFxuIH1cXG4gMTAwJSB7XFxuICBzdHJva2UtZGFzaGFycmF5OiA4OSwgMjAwO1xcbiAgc3Ryb2tlLWRhc2hvZmZzZXQ6IC0xMjQ7XFxuIH1cXG59XFxuQGtleWZyYW1lcyBsb2FkaW5nX2Rhc2hfX0h6UzZwIHtcXG4gMCUge1xcbiAgc3Ryb2tlLWRhc2hhcnJheTogMSwgMjAwO1xcbiAgc3Ryb2tlLWRhc2hvZmZzZXQ6IDA7XFxuIH1cXG4gNTAlIHtcXG4gIHN0cm9rZS1kYXNoYXJyYXk6IDg5LCAyMDA7XFxuICBzdHJva2UtZGFzaG9mZnNldDogLTM1O1xcbiB9XFxuIDEwMCUge1xcbiAgc3Ryb2tlLWRhc2hhcnJheTogODksIDIwMDtcXG4gIHN0cm9rZS1kYXNob2Zmc2V0OiAtMTI0O1xcbiB9XFxufVxcbkAtd2Via2l0LWtleWZyYW1lcyBsb2FkaW5nX2NvbG9yX19FVFFxbiB7XFxuIDAlIHtcXG4gIHN0cm9rZTogdmFyKC0td2hpdGUtY29sb3IpO1xcbiB9XFxuIDQwJSB7XFxuICBzdHJva2U6IHZhcigtLXdoaXRlLWNvbG9yKTtcXG4gfVxcbiA2NiUge1xcbiAgc3Ryb2tlOiB2YXIoLS13aGl0ZS1jb2xvcik7XFxuIH1cXG4gODAlLFxcbiA5MCUge1xcbiAgc3Ryb2tlOiB2YXIoLS13aGl0ZS1jb2xvcik7XFxuIH1cXG59XFxuQGtleWZyYW1lcyBsb2FkaW5nX2NvbG9yX19FVFFxbiB7XFxuIDAlIHtcXG4gIHN0cm9rZTogdmFyKC0td2hpdGUtY29sb3IpO1xcbiB9XFxuIDQwJSB7XFxuICBzdHJva2U6IHZhcigtLXdoaXRlLWNvbG9yKTtcXG4gfVxcbiA2NiUge1xcbiAgc3Ryb2tlOiB2YXIoLS13aGl0ZS1jb2xvcik7XFxuIH1cXG4gODAlLFxcbiA5MCUge1xcbiAgc3Ryb2tlOiB2YXIoLS13aGl0ZS1jb2xvcik7XFxuIH1cXG59XFxuXCIsIFwiXCIse1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wid2VicGFjazovL3NyYy9jb21wb25lbnRzL0xvYWRpbmcvbG9hZGluZy5tb2R1bGUuY3NzXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCJBQUFBO0NBQ0M7Ozs7O2NBS2E7Q0FDYix3QkFBd0I7QUFDekI7O0FBRUE7Q0FDQyxrQkFBa0I7Q0FDbEIsZ0JBQWdCO0NBQ2hCLFdBQVc7Q0FDWCxZQUFZO0FBQ2I7QUFDQTtDQUNDLFdBQVc7Q0FDWCxjQUFjO0NBQ2QsaUJBQWlCO0FBQ2xCOztBQUVBO0NBQ0MsMkRBQTRDO0NBQzVDLG1EQUFvQztDQUNwQyxZQUFZO0NBR1osK0JBQStCO0NBQy9CLFdBQVc7Q0FDWCxrQkFBa0I7Q0FDbEIsTUFBTTtDQUNOLE9BQU87Q0FDUCxZQUFZO0FBQ2I7O0FBRUE7Q0FDQywwQkFBMEI7Q0FDMUIsc0JBQXNCO0NBQ3RCLDhHQUFnRjtDQUNoRixzR0FBd0U7Q0FDeEUscUJBQXFCO0FBQ3RCOztBQUVBO0NBQ0M7RUFFQyx5QkFBeUI7Q0FDMUI7QUFDRDs7QUFFQTtDQUNDO0VBRUMseUJBQXlCO0NBQzFCO0FBQ0Q7QUFDQTtDQUNDO0VBQ0Msd0JBQXdCO0VBQ3hCLG9CQUFvQjtDQUNyQjtDQUNBO0VBQ0MseUJBQXlCO0VBQ3pCLHNCQUFzQjtDQUN2QjtDQUNBO0VBQ0MseUJBQXlCO0VBQ3pCLHVCQUF1QjtDQUN4QjtBQUNEO0FBQ0E7Q0FDQztFQUNDLHdCQUF3QjtFQUN4QixvQkFBb0I7Q0FDckI7Q0FDQTtFQUNDLHlCQUF5QjtFQUN6QixzQkFBc0I7Q0FDdkI7Q0FDQTtFQUNDLHlCQUF5QjtFQUN6Qix1QkFBdUI7Q0FDeEI7QUFDRDtBQUNBO0NBQ0M7RUFDQywwQkFBMEI7Q0FDM0I7Q0FDQTtFQUNDLDBCQUEwQjtDQUMzQjtDQUNBO0VBQ0MsMEJBQTBCO0NBQzNCO0NBQ0E7O0VBRUMsMEJBQTBCO0NBQzNCO0FBQ0Q7QUFDQTtDQUNDO0VBQ0MsMEJBQTBCO0NBQzNCO0NBQ0E7RUFDQywwQkFBMEI7Q0FDM0I7Q0FDQTtFQUNDLDBCQUEwQjtDQUMzQjtDQUNBOztFQUVDLDBCQUEwQjtDQUMzQjtBQUNEXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIi5wcm9maWxlX21haW5fbG9hZGVyIHtcXG4gLyogbGVmdDogNTAlICFpbXBvcnRhbnQ7XFxuIG1hcmdpbi1sZWZ0OiAtMTAwcHg7XFxuIHBvc2l0aW9uOiBmaXhlZCAhaW1wb3J0YW50O1xcbiB0b3A6IDUwJSAhaW1wb3J0YW50O1xcbiBtYXJnaW4tdG9wOiAtMTAwcHg7XFxuIHdpZHRoOiA0NXB4OyovXFxuIHotaW5kZXg6IDkwMDAgIWltcG9ydGFudDtcXG59XFxuXFxuLnByb2ZpbGVfbWFpbl9sb2FkZXIgLmxvYWRlciB7XFxuIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gbWFyZ2luOiAwcHggYXV0bztcXG4gd2lkdGg6IGF1dG87XFxuIGhlaWdodDogYXV0bztcXG59XFxuLnByb2ZpbGVfbWFpbl9sb2FkZXIgLmxvYWRlcjpiZWZvcmUge1xcbiBjb250ZW50OiBcXFwiXFxcIjtcXG4gZGlzcGxheTogYmxvY2s7XFxuIHBhZGRpbmctdG9wOiAxMDAlO1xcbn1cXG5cXG4uY2lyY3VsYXJfbG9hZGVyIHtcXG4gLXdlYmtpdC1hbmltYXRpb246IHJvdGF0ZSAycyBsaW5lYXIgaW5maW5pdGU7XFxuIGFuaW1hdGlvbjogcm90YXRlIDJzIGxpbmVhciBpbmZpbml0ZTtcXG4gaGVpZ2h0OiAxMDAlO1xcbiAtd2Via2l0LXRyYW5zZm9ybS1vcmlnaW46IGNlbnRlciBjZW50ZXI7XFxuIC1tcy10cmFuc2Zvcm0tb3JpZ2luOiBjZW50ZXIgY2VudGVyO1xcbiB0cmFuc2Zvcm0tb3JpZ2luOiBjZW50ZXIgY2VudGVyO1xcbiB3aWR0aDogMTAwJTtcXG4gcG9zaXRpb246IGFic29sdXRlO1xcbiB0b3A6IDA7XFxuIGxlZnQ6IDA7XFxuIG1hcmdpbjogYXV0bztcXG59XFxuXFxuLmxvYWRlcl9wYXRoIHtcXG4gc3Ryb2tlLWRhc2hhcnJheTogMTUwLCAyMDA7XFxuIHN0cm9rZS1kYXNob2Zmc2V0OiAtMTA7XFxuIC13ZWJraXQtYW5pbWF0aW9uOiBkYXNoIDEuNXMgZWFzZS1pbi1vdXQgaW5maW5pdGUsIGNvbG9yIDZzIGVhc2UtaW4tb3V0IGluZmluaXRlO1xcbiBhbmltYXRpb246IGRhc2ggMS41cyBlYXNlLWluLW91dCBpbmZpbml0ZSwgY29sb3IgNnMgZWFzZS1pbi1vdXQgaW5maW5pdGU7XFxuIHN0cm9rZS1saW5lY2FwOiByb3VuZDtcXG59XFxuXFxuQC13ZWJraXQta2V5ZnJhbWVzIHJvdGF0ZSB7XFxuIDEwMCUge1xcbiAgLXdlYmtpdC10cmFuc2Zvcm06IHJvdGF0ZSgzNjBkZWcpO1xcbiAgdHJhbnNmb3JtOiByb3RhdGUoMzYwZGVnKTtcXG4gfVxcbn1cXG5cXG5Aa2V5ZnJhbWVzIHJvdGF0ZSB7XFxuIDEwMCUge1xcbiAgLXdlYmtpdC10cmFuc2Zvcm06IHJvdGF0ZSgzNjBkZWcpO1xcbiAgdHJhbnNmb3JtOiByb3RhdGUoMzYwZGVnKTtcXG4gfVxcbn1cXG5ALXdlYmtpdC1rZXlmcmFtZXMgZGFzaCB7XFxuIDAlIHtcXG4gIHN0cm9rZS1kYXNoYXJyYXk6IDEsIDIwMDtcXG4gIHN0cm9rZS1kYXNob2Zmc2V0OiAwO1xcbiB9XFxuIDUwJSB7XFxuICBzdHJva2UtZGFzaGFycmF5OiA4OSwgMjAwO1xcbiAgc3Ryb2tlLWRhc2hvZmZzZXQ6IC0zNTtcXG4gfVxcbiAxMDAlIHtcXG4gIHN0cm9rZS1kYXNoYXJyYXk6IDg5LCAyMDA7XFxuICBzdHJva2UtZGFzaG9mZnNldDogLTEyNDtcXG4gfVxcbn1cXG5Aa2V5ZnJhbWVzIGRhc2gge1xcbiAwJSB7XFxuICBzdHJva2UtZGFzaGFycmF5OiAxLCAyMDA7XFxuICBzdHJva2UtZGFzaG9mZnNldDogMDtcXG4gfVxcbiA1MCUge1xcbiAgc3Ryb2tlLWRhc2hhcnJheTogODksIDIwMDtcXG4gIHN0cm9rZS1kYXNob2Zmc2V0OiAtMzU7XFxuIH1cXG4gMTAwJSB7XFxuICBzdHJva2UtZGFzaGFycmF5OiA4OSwgMjAwO1xcbiAgc3Ryb2tlLWRhc2hvZmZzZXQ6IC0xMjQ7XFxuIH1cXG59XFxuQC13ZWJraXQta2V5ZnJhbWVzIGNvbG9yIHtcXG4gMCUge1xcbiAgc3Ryb2tlOiB2YXIoLS13aGl0ZS1jb2xvcik7XFxuIH1cXG4gNDAlIHtcXG4gIHN0cm9rZTogdmFyKC0td2hpdGUtY29sb3IpO1xcbiB9XFxuIDY2JSB7XFxuICBzdHJva2U6IHZhcigtLXdoaXRlLWNvbG9yKTtcXG4gfVxcbiA4MCUsXFxuIDkwJSB7XFxuICBzdHJva2U6IHZhcigtLXdoaXRlLWNvbG9yKTtcXG4gfVxcbn1cXG5Aa2V5ZnJhbWVzIGNvbG9yIHtcXG4gMCUge1xcbiAgc3Ryb2tlOiB2YXIoLS13aGl0ZS1jb2xvcik7XFxuIH1cXG4gNDAlIHtcXG4gIHN0cm9rZTogdmFyKC0td2hpdGUtY29sb3IpO1xcbiB9XFxuIDY2JSB7XFxuICBzdHJva2U6IHZhcigtLXdoaXRlLWNvbG9yKTtcXG4gfVxcbiA4MCUsXFxuIDkwJSB7XFxuICBzdHJva2U6IHZhcigtLXdoaXRlLWNvbG9yKTtcXG4gfVxcbn1cXG5cIl0sXCJzb3VyY2VSb290XCI6XCJcIn1dKTtcbi8vIEV4cG9ydHNcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLmxvY2FscyA9IHtcblx0XCJwcm9maWxlX21haW5fbG9hZGVyXCI6IFwibG9hZGluZ19wcm9maWxlX21haW5fbG9hZGVyX18wN19xWlwiLFxuXHRcImxvYWRlclwiOiBcImxvYWRpbmdfbG9hZGVyX19adXZMZ1wiLFxuXHRcImNpcmN1bGFyX2xvYWRlclwiOiBcImxvYWRpbmdfY2lyY3VsYXJfbG9hZGVyX182MVZ2eFwiLFxuXHRcInJvdGF0ZVwiOiBcImxvYWRpbmdfcm90YXRlX19pajVvRVwiLFxuXHRcImxvYWRlcl9wYXRoXCI6IFwibG9hZGluZ19sb2FkZXJfcGF0aF9fX242b2ZcIixcblx0XCJkYXNoXCI6IFwibG9hZGluZ19kYXNoX19IelM2cFwiLFxuXHRcImNvbG9yXCI6IFwibG9hZGluZ19jb2xvcl9fRVRRcW5cIlxufTtcbm1vZHVsZS5leHBvcnRzID0gX19fQ1NTX0xPQURFUl9FWFBPUlRfX187XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[2]!./src/components/Loading/loading.module.css\n");

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[2]!./src/components/Modal/Modal.module.css":
/*!***************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[2]!./src/components/Modal/Modal.module.css ***!
  \***************************************************************************************************************************************************************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("// Imports\nvar ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../../../node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js\");\nvar ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(true);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \".Modal_modal__rQoc6 {\\n    position: fixed;\\n    bottom: 0;\\n    left: 0;\\n    right: 0;\\n    height: 100%;\\n    width: 100%;\\n    z-index: 100;\\n    background-color: rgba(0, 0, 0, 0.5);\\n    display: flex;\\n    justify-content: center;\\n    align-items: center;\\n\\n}\\n\\n.Modal_modal_container__T9ySA {\\n    position: fixed;\\n    bottom: -1000px;\\n    background-color: var(--divider-color);\\n    border-radius: 10px;\\n    width: 95%;\\n    height: auto;\\n    z-index: 101;\\n    box-shadow: 0px 0px 10px rgba(0, 0, 0, 0.5);\\n    text-align: center;\\n    transition: all .5s;\\n    padding: 10px;\\n}\\n\\n.Modal_show_modal__mgVd0 {\\n    bottom: 10px;\\n}\\n\\n.Modal_modal_content__NFxCB::-webkit-scrollbar {\\n    display: none;\\n}\\n\\n.Modal_modal_content__NFxCB {\\n    overflow: scroll;\\n    /* margin-bottom: 40%; */\\n    padding-bottom: 40%;\\n    width: 100%;\\n    height: 100%;\\n    text-align: center;\\n    display: flex;\\n    flex-direction: column;\\n    justify-content: center;\\n    align-items: center;\\n}\\n\\n.Modal_modal_title__3GpJO {\\n    /* text-decoration: underline; */\\n    padding: 10px;\\n    /* height: 50px; */\\n    margin: 0;\\n    top: 0;\\n    position: -webkit-sticky;\\n    position: sticky;\\n    width: 100%;\\n    background-color: var(--divider-color);\\n    font-size: 28px;\\n    font-family: var(--light-primary-font);\\n}\\n\\n.Modal_message_wrapper__UgzcR {\\n    font-family: var(--light-primary-font);\\n    text-align: left;\\n}\\n\\n.Modal_modal_message__Am3PK {\\n    font-size: 18px;\\n    padding: 0px 30px 0px 30px;\\n}\\n\\n.Modal_modal_buttons__nI7Vt {\\n    position: absolute;\\n    width: 80%;\\n    padding-bottom: 20px;\\n    bottom: 0;\\n}\\n\\n.Modal_center_loading__dl2_r {\\n    display: flex;\\n    align-items: center;\\n    justify-content: center;\\n}\\n\\n\\n@media screen and (min-width: 768px) {\\n    .Modal_modal_container__T9ySA {\\n        width: 50%;\\n    }\\n\\n    .Modal_modal_message__Am3PK {\\n        font-size: 20px;\\n    }\\n\\n}\", \"\",{\"version\":3,\"sources\":[\"webpack://src/components/Modal/Modal.module.css\"],\"names\":[],\"mappings\":\"AAAA;IACI,eAAe;IACf,SAAS;IACT,OAAO;IACP,QAAQ;IACR,YAAY;IACZ,WAAW;IACX,YAAY;IACZ,oCAAoC;IACpC,aAAa;IACb,uBAAuB;IACvB,mBAAmB;;AAEvB;;AAEA;IACI,eAAe;IACf,eAAe;IACf,sCAAsC;IACtC,mBAAmB;IACnB,UAAU;IACV,YAAY;IACZ,YAAY;IACZ,2CAA2C;IAC3C,kBAAkB;IAClB,mBAAmB;IACnB,aAAa;AACjB;;AAEA;IACI,YAAY;AAChB;;AAEA;IACI,aAAa;AACjB;;AAEA;IACI,gBAAgB;IAChB,wBAAwB;IACxB,mBAAmB;IACnB,WAAW;IACX,YAAY;IACZ,kBAAkB;IAClB,aAAa;IACb,sBAAsB;IACtB,uBAAuB;IACvB,mBAAmB;AACvB;;AAEA;IACI,gCAAgC;IAChC,aAAa;IACb,kBAAkB;IAClB,SAAS;IACT,MAAM;IACN,wBAAgB;IAAhB,gBAAgB;IAChB,WAAW;IACX,sCAAsC;IACtC,eAAe;IACf,sCAAsC;AAC1C;;AAEA;IACI,sCAAsC;IACtC,gBAAgB;AACpB;;AAEA;IACI,eAAe;IACf,0BAA0B;AAC9B;;AAEA;IACI,kBAAkB;IAClB,UAAU;IACV,oBAAoB;IACpB,SAAS;AACb;;AAEA;IACI,aAAa;IACb,mBAAmB;IACnB,uBAAuB;AAC3B;;;AAGA;IACI;QACI,UAAU;IACd;;IAEA;QACI,eAAe;IACnB;;AAEJ\",\"sourcesContent\":[\".modal {\\n    position: fixed;\\n    bottom: 0;\\n    left: 0;\\n    right: 0;\\n    height: 100%;\\n    width: 100%;\\n    z-index: 100;\\n    background-color: rgba(0, 0, 0, 0.5);\\n    display: flex;\\n    justify-content: center;\\n    align-items: center;\\n\\n}\\n\\n.modal_container {\\n    position: fixed;\\n    bottom: -1000px;\\n    background-color: var(--divider-color);\\n    border-radius: 10px;\\n    width: 95%;\\n    height: auto;\\n    z-index: 101;\\n    box-shadow: 0px 0px 10px rgba(0, 0, 0, 0.5);\\n    text-align: center;\\n    transition: all .5s;\\n    padding: 10px;\\n}\\n\\n.show_modal {\\n    bottom: 10px;\\n}\\n\\n.modal_content::-webkit-scrollbar {\\n    display: none;\\n}\\n\\n.modal_content {\\n    overflow: scroll;\\n    /* margin-bottom: 40%; */\\n    padding-bottom: 40%;\\n    width: 100%;\\n    height: 100%;\\n    text-align: center;\\n    display: flex;\\n    flex-direction: column;\\n    justify-content: center;\\n    align-items: center;\\n}\\n\\n.modal_title {\\n    /* text-decoration: underline; */\\n    padding: 10px;\\n    /* height: 50px; */\\n    margin: 0;\\n    top: 0;\\n    position: sticky;\\n    width: 100%;\\n    background-color: var(--divider-color);\\n    font-size: 28px;\\n    font-family: var(--light-primary-font);\\n}\\n\\n.message_wrapper {\\n    font-family: var(--light-primary-font);\\n    text-align: left;\\n}\\n\\n.modal_message {\\n    font-size: 18px;\\n    padding: 0px 30px 0px 30px;\\n}\\n\\n.modal_buttons {\\n    position: absolute;\\n    width: 80%;\\n    padding-bottom: 20px;\\n    bottom: 0;\\n}\\n\\n.center_loading {\\n    display: flex;\\n    align-items: center;\\n    justify-content: center;\\n}\\n\\n\\n@media screen and (min-width: 768px) {\\n    .modal_container {\\n        width: 50%;\\n    }\\n\\n    .modal_message {\\n        font-size: 20px;\\n    }\\n\\n}\"],\"sourceRoot\":\"\"}]);\n// Exports\n___CSS_LOADER_EXPORT___.locals = {\n\t\"modal\": \"Modal_modal__rQoc6\",\n\t\"modal_container\": \"Modal_modal_container__T9ySA\",\n\t\"show_modal\": \"Modal_show_modal__mgVd0\",\n\t\"modal_content\": \"Modal_modal_content__NFxCB\",\n\t\"modal_title\": \"Modal_modal_title__3GpJO\",\n\t\"message_wrapper\": \"Modal_message_wrapper__UgzcR\",\n\t\"modal_message\": \"Modal_modal_message__Am3PK\",\n\t\"modal_buttons\": \"Modal_modal_buttons__nI7Vt\",\n\t\"center_loading\": \"Modal_center_loading__dl2_r\"\n};\nmodule.exports = ___CSS_LOADER_EXPORT___;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1szXS5vbmVPZls0XS51c2VbMV0hLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbM10ub25lT2ZbNF0udXNlWzJdIS4vc3JjL2NvbXBvbmVudHMvTW9kYWwvTW9kYWwubW9kdWxlLmNzcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGtDQUFrQyxtQkFBTyxDQUFDLHlLQUFxRjtBQUMvSDtBQUNBO0FBQ0EsK0RBQStELHNCQUFzQixnQkFBZ0IsY0FBYyxlQUFlLG1CQUFtQixrQkFBa0IsbUJBQW1CLDJDQUEyQyxvQkFBb0IsOEJBQThCLDBCQUEwQixLQUFLLG1DQUFtQyxzQkFBc0Isc0JBQXNCLDZDQUE2QywwQkFBMEIsaUJBQWlCLG1CQUFtQixtQkFBbUIsa0RBQWtELHlCQUF5QiwwQkFBMEIsb0JBQW9CLEdBQUcsOEJBQThCLG1CQUFtQixHQUFHLG9EQUFvRCxvQkFBb0IsR0FBRyxpQ0FBaUMsdUJBQXVCLDZCQUE2Qiw0QkFBNEIsa0JBQWtCLG1CQUFtQix5QkFBeUIsb0JBQW9CLDZCQUE2Qiw4QkFBOEIsMEJBQTBCLEdBQUcsK0JBQStCLHFDQUFxQyxzQkFBc0IsdUJBQXVCLGtCQUFrQixhQUFhLCtCQUErQix1QkFBdUIsa0JBQWtCLDZDQUE2QyxzQkFBc0IsNkNBQTZDLEdBQUcsbUNBQW1DLDZDQUE2Qyx1QkFBdUIsR0FBRyxpQ0FBaUMsc0JBQXNCLGlDQUFpQyxHQUFHLGlDQUFpQyx5QkFBeUIsaUJBQWlCLDJCQUEyQixnQkFBZ0IsR0FBRyxrQ0FBa0Msb0JBQW9CLDBCQUEwQiw4QkFBOEIsR0FBRyw0Q0FBNEMscUNBQXFDLHFCQUFxQixPQUFPLHFDQUFxQywwQkFBMEIsT0FBTyxLQUFLLE9BQU8sc0dBQXNHLFVBQVUsVUFBVSxVQUFVLFVBQVUsVUFBVSxVQUFVLFVBQVUsWUFBWSxXQUFXLFlBQVksY0FBYyxPQUFPLEtBQUssVUFBVSxVQUFVLFlBQVksYUFBYSxXQUFXLFVBQVUsVUFBVSxZQUFZLGFBQWEsYUFBYSxXQUFXLE9BQU8sS0FBSyxVQUFVLE9BQU8sS0FBSyxVQUFVLE9BQU8sS0FBSyxZQUFZLGFBQWEsYUFBYSxXQUFXLFVBQVUsWUFBWSxXQUFXLFlBQVksYUFBYSxhQUFhLE9BQU8sS0FBSyxZQUFZLFdBQVcsWUFBWSxXQUFXLFVBQVUsWUFBWSxhQUFhLFdBQVcsWUFBWSxXQUFXLFlBQVksT0FBTyxLQUFLLFlBQVksYUFBYSxPQUFPLEtBQUssVUFBVSxZQUFZLE9BQU8sS0FBSyxZQUFZLFdBQVcsWUFBWSxXQUFXLE1BQU0sS0FBSyxVQUFVLFlBQVksYUFBYSxRQUFRLEtBQUssS0FBSyxVQUFVLE1BQU0sS0FBSyxVQUFVLE9BQU8saUNBQWlDLHNCQUFzQixnQkFBZ0IsY0FBYyxlQUFlLG1CQUFtQixrQkFBa0IsbUJBQW1CLDJDQUEyQyxvQkFBb0IsOEJBQThCLDBCQUEwQixLQUFLLHNCQUFzQixzQkFBc0Isc0JBQXNCLDZDQUE2QywwQkFBMEIsaUJBQWlCLG1CQUFtQixtQkFBbUIsa0RBQWtELHlCQUF5QiwwQkFBMEIsb0JBQW9CLEdBQUcsaUJBQWlCLG1CQUFtQixHQUFHLHVDQUF1QyxvQkFBb0IsR0FBRyxvQkFBb0IsdUJBQXVCLDZCQUE2Qiw0QkFBNEIsa0JBQWtCLG1CQUFtQix5QkFBeUIsb0JBQW9CLDZCQUE2Qiw4QkFBOEIsMEJBQTBCLEdBQUcsa0JBQWtCLHFDQUFxQyxzQkFBc0IsdUJBQXVCLGtCQUFrQixhQUFhLHVCQUF1QixrQkFBa0IsNkNBQTZDLHNCQUFzQiw2Q0FBNkMsR0FBRyxzQkFBc0IsNkNBQTZDLHVCQUF1QixHQUFHLG9CQUFvQixzQkFBc0IsaUNBQWlDLEdBQUcsb0JBQW9CLHlCQUF5QixpQkFBaUIsMkJBQTJCLGdCQUFnQixHQUFHLHFCQUFxQixvQkFBb0IsMEJBQTBCLDhCQUE4QixHQUFHLDRDQUE0Qyx3QkFBd0IscUJBQXFCLE9BQU8sd0JBQXdCLDBCQUEwQixPQUFPLEtBQUssbUJBQW1CO0FBQzVtSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvY29tcG9uZW50cy9Nb2RhbC9Nb2RhbC5tb2R1bGUuY3NzPzFhZmYiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gSW1wb3J0c1xudmFyIF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyA9IHJlcXVpcmUoXCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9ydW50aW1lL2FwaS5qc1wiKTtcbnZhciBfX19DU1NfTE9BREVSX0VYUE9SVF9fXyA9IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyh0cnVlKTtcbi8vIE1vZHVsZVxuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ucHVzaChbbW9kdWxlLmlkLCBcIi5Nb2RhbF9tb2RhbF9fclFvYzYge1xcbiAgICBwb3NpdGlvbjogZml4ZWQ7XFxuICAgIGJvdHRvbTogMDtcXG4gICAgbGVmdDogMDtcXG4gICAgcmlnaHQ6IDA7XFxuICAgIGhlaWdodDogMTAwJTtcXG4gICAgd2lkdGg6IDEwMCU7XFxuICAgIHotaW5kZXg6IDEwMDtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgwLCAwLCAwLCAwLjUpO1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG5cXG59XFxuXFxuLk1vZGFsX21vZGFsX2NvbnRhaW5lcl9fVDl5U0Ege1xcbiAgICBwb3NpdGlvbjogZml4ZWQ7XFxuICAgIGJvdHRvbTogLTEwMDBweDtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tZGl2aWRlci1jb2xvcik7XFxuICAgIGJvcmRlci1yYWRpdXM6IDEwcHg7XFxuICAgIHdpZHRoOiA5NSU7XFxuICAgIGhlaWdodDogYXV0bztcXG4gICAgei1pbmRleDogMTAxO1xcbiAgICBib3gtc2hhZG93OiAwcHggMHB4IDEwcHggcmdiYSgwLCAwLCAwLCAwLjUpO1xcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICAgIHRyYW5zaXRpb246IGFsbCAuNXM7XFxuICAgIHBhZGRpbmc6IDEwcHg7XFxufVxcblxcbi5Nb2RhbF9zaG93X21vZGFsX19tZ1ZkMCB7XFxuICAgIGJvdHRvbTogMTBweDtcXG59XFxuXFxuLk1vZGFsX21vZGFsX2NvbnRlbnRfX05GeENCOjotd2Via2l0LXNjcm9sbGJhciB7XFxuICAgIGRpc3BsYXk6IG5vbmU7XFxufVxcblxcbi5Nb2RhbF9tb2RhbF9jb250ZW50X19ORnhDQiB7XFxuICAgIG92ZXJmbG93OiBzY3JvbGw7XFxuICAgIC8qIG1hcmdpbi1ib3R0b206IDQwJTsgKi9cXG4gICAgcGFkZGluZy1ib3R0b206IDQwJTtcXG4gICAgd2lkdGg6IDEwMCU7XFxuICAgIGhlaWdodDogMTAwJTtcXG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG59XFxuXFxuLk1vZGFsX21vZGFsX3RpdGxlX18zR3BKTyB7XFxuICAgIC8qIHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lOyAqL1xcbiAgICBwYWRkaW5nOiAxMHB4O1xcbiAgICAvKiBoZWlnaHQ6IDUwcHg7ICovXFxuICAgIG1hcmdpbjogMDtcXG4gICAgdG9wOiAwO1xcbiAgICBwb3NpdGlvbjogLXdlYmtpdC1zdGlja3k7XFxuICAgIHBvc2l0aW9uOiBzdGlja3k7XFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1kaXZpZGVyLWNvbG9yKTtcXG4gICAgZm9udC1zaXplOiAyOHB4O1xcbiAgICBmb250LWZhbWlseTogdmFyKC0tbGlnaHQtcHJpbWFyeS1mb250KTtcXG59XFxuXFxuLk1vZGFsX21lc3NhZ2Vfd3JhcHBlcl9fVWd6Y1Ige1xcbiAgICBmb250LWZhbWlseTogdmFyKC0tbGlnaHQtcHJpbWFyeS1mb250KTtcXG4gICAgdGV4dC1hbGlnbjogbGVmdDtcXG59XFxuXFxuLk1vZGFsX21vZGFsX21lc3NhZ2VfX0FtM1BLIHtcXG4gICAgZm9udC1zaXplOiAxOHB4O1xcbiAgICBwYWRkaW5nOiAwcHggMzBweCAwcHggMzBweDtcXG59XFxuXFxuLk1vZGFsX21vZGFsX2J1dHRvbnNfX25JN1Z0IHtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICB3aWR0aDogODAlO1xcbiAgICBwYWRkaW5nLWJvdHRvbTogMjBweDtcXG4gICAgYm90dG9tOiAwO1xcbn1cXG5cXG4uTW9kYWxfY2VudGVyX2xvYWRpbmdfX2RsMl9yIHtcXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxufVxcblxcblxcbkBtZWRpYSBzY3JlZW4gYW5kIChtaW4td2lkdGg6IDc2OHB4KSB7XFxuICAgIC5Nb2RhbF9tb2RhbF9jb250YWluZXJfX1Q5eVNBIHtcXG4gICAgICAgIHdpZHRoOiA1MCU7XFxuICAgIH1cXG5cXG4gICAgLk1vZGFsX21vZGFsX21lc3NhZ2VfX0FtM1BLIHtcXG4gICAgICAgIGZvbnQtc2l6ZTogMjBweDtcXG4gICAgfVxcblxcbn1cIiwgXCJcIix7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCJ3ZWJwYWNrOi8vc3JjL2NvbXBvbmVudHMvTW9kYWwvTW9kYWwubW9kdWxlLmNzc1wiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiQUFBQTtJQUNJLGVBQWU7SUFDZixTQUFTO0lBQ1QsT0FBTztJQUNQLFFBQVE7SUFDUixZQUFZO0lBQ1osV0FBVztJQUNYLFlBQVk7SUFDWixvQ0FBb0M7SUFDcEMsYUFBYTtJQUNiLHVCQUF1QjtJQUN2QixtQkFBbUI7O0FBRXZCOztBQUVBO0lBQ0ksZUFBZTtJQUNmLGVBQWU7SUFDZixzQ0FBc0M7SUFDdEMsbUJBQW1CO0lBQ25CLFVBQVU7SUFDVixZQUFZO0lBQ1osWUFBWTtJQUNaLDJDQUEyQztJQUMzQyxrQkFBa0I7SUFDbEIsbUJBQW1CO0lBQ25CLGFBQWE7QUFDakI7O0FBRUE7SUFDSSxZQUFZO0FBQ2hCOztBQUVBO0lBQ0ksYUFBYTtBQUNqQjs7QUFFQTtJQUNJLGdCQUFnQjtJQUNoQix3QkFBd0I7SUFDeEIsbUJBQW1CO0lBQ25CLFdBQVc7SUFDWCxZQUFZO0lBQ1osa0JBQWtCO0lBQ2xCLGFBQWE7SUFDYixzQkFBc0I7SUFDdEIsdUJBQXVCO0lBQ3ZCLG1CQUFtQjtBQUN2Qjs7QUFFQTtJQUNJLGdDQUFnQztJQUNoQyxhQUFhO0lBQ2Isa0JBQWtCO0lBQ2xCLFNBQVM7SUFDVCxNQUFNO0lBQ04sd0JBQWdCO0lBQWhCLGdCQUFnQjtJQUNoQixXQUFXO0lBQ1gsc0NBQXNDO0lBQ3RDLGVBQWU7SUFDZixzQ0FBc0M7QUFDMUM7O0FBRUE7SUFDSSxzQ0FBc0M7SUFDdEMsZ0JBQWdCO0FBQ3BCOztBQUVBO0lBQ0ksZUFBZTtJQUNmLDBCQUEwQjtBQUM5Qjs7QUFFQTtJQUNJLGtCQUFrQjtJQUNsQixVQUFVO0lBQ1Ysb0JBQW9CO0lBQ3BCLFNBQVM7QUFDYjs7QUFFQTtJQUNJLGFBQWE7SUFDYixtQkFBbUI7SUFDbkIsdUJBQXVCO0FBQzNCOzs7QUFHQTtJQUNJO1FBQ0ksVUFBVTtJQUNkOztJQUVBO1FBQ0ksZUFBZTtJQUNuQjs7QUFFSlwiLFwic291cmNlc0NvbnRlbnRcIjpbXCIubW9kYWwge1xcbiAgICBwb3NpdGlvbjogZml4ZWQ7XFxuICAgIGJvdHRvbTogMDtcXG4gICAgbGVmdDogMDtcXG4gICAgcmlnaHQ6IDA7XFxuICAgIGhlaWdodDogMTAwJTtcXG4gICAgd2lkdGg6IDEwMCU7XFxuICAgIHotaW5kZXg6IDEwMDtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgwLCAwLCAwLCAwLjUpO1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG5cXG59XFxuXFxuLm1vZGFsX2NvbnRhaW5lciB7XFxuICAgIHBvc2l0aW9uOiBmaXhlZDtcXG4gICAgYm90dG9tOiAtMTAwMHB4O1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1kaXZpZGVyLWNvbG9yKTtcXG4gICAgYm9yZGVyLXJhZGl1czogMTBweDtcXG4gICAgd2lkdGg6IDk1JTtcXG4gICAgaGVpZ2h0OiBhdXRvO1xcbiAgICB6LWluZGV4OiAxMDE7XFxuICAgIGJveC1zaGFkb3c6IDBweCAwcHggMTBweCByZ2JhKDAsIDAsIDAsIDAuNSk7XFxuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gICAgdHJhbnNpdGlvbjogYWxsIC41cztcXG4gICAgcGFkZGluZzogMTBweDtcXG59XFxuXFxuLnNob3dfbW9kYWwge1xcbiAgICBib3R0b206IDEwcHg7XFxufVxcblxcbi5tb2RhbF9jb250ZW50Ojotd2Via2l0LXNjcm9sbGJhciB7XFxuICAgIGRpc3BsYXk6IG5vbmU7XFxufVxcblxcbi5tb2RhbF9jb250ZW50IHtcXG4gICAgb3ZlcmZsb3c6IHNjcm9sbDtcXG4gICAgLyogbWFyZ2luLWJvdHRvbTogNDAlOyAqL1xcbiAgICBwYWRkaW5nLWJvdHRvbTogNDAlO1xcbiAgICB3aWR0aDogMTAwJTtcXG4gICAgaGVpZ2h0OiAxMDAlO1xcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbn1cXG5cXG4ubW9kYWxfdGl0bGUge1xcbiAgICAvKiB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTsgKi9cXG4gICAgcGFkZGluZzogMTBweDtcXG4gICAgLyogaGVpZ2h0OiA1MHB4OyAqL1xcbiAgICBtYXJnaW46IDA7XFxuICAgIHRvcDogMDtcXG4gICAgcG9zaXRpb246IHN0aWNreTtcXG4gICAgd2lkdGg6IDEwMCU7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWRpdmlkZXItY29sb3IpO1xcbiAgICBmb250LXNpemU6IDI4cHg7XFxuICAgIGZvbnQtZmFtaWx5OiB2YXIoLS1saWdodC1wcmltYXJ5LWZvbnQpO1xcbn1cXG5cXG4ubWVzc2FnZV93cmFwcGVyIHtcXG4gICAgZm9udC1mYW1pbHk6IHZhcigtLWxpZ2h0LXByaW1hcnktZm9udCk7XFxuICAgIHRleHQtYWxpZ246IGxlZnQ7XFxufVxcblxcbi5tb2RhbF9tZXNzYWdlIHtcXG4gICAgZm9udC1zaXplOiAxOHB4O1xcbiAgICBwYWRkaW5nOiAwcHggMzBweCAwcHggMzBweDtcXG59XFxuXFxuLm1vZGFsX2J1dHRvbnMge1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIHdpZHRoOiA4MCU7XFxuICAgIHBhZGRpbmctYm90dG9tOiAyMHB4O1xcbiAgICBib3R0b206IDA7XFxufVxcblxcbi5jZW50ZXJfbG9hZGluZyB7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcbn1cXG5cXG5cXG5AbWVkaWEgc2NyZWVuIGFuZCAobWluLXdpZHRoOiA3NjhweCkge1xcbiAgICAubW9kYWxfY29udGFpbmVyIHtcXG4gICAgICAgIHdpZHRoOiA1MCU7XFxuICAgIH1cXG5cXG4gICAgLm1vZGFsX21lc3NhZ2Uge1xcbiAgICAgICAgZm9udC1zaXplOiAyMHB4O1xcbiAgICB9XFxuXFxufVwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuLy8gRXhwb3J0c1xuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ubG9jYWxzID0ge1xuXHRcIm1vZGFsXCI6IFwiTW9kYWxfbW9kYWxfX3JRb2M2XCIsXG5cdFwibW9kYWxfY29udGFpbmVyXCI6IFwiTW9kYWxfbW9kYWxfY29udGFpbmVyX19UOXlTQVwiLFxuXHRcInNob3dfbW9kYWxcIjogXCJNb2RhbF9zaG93X21vZGFsX19tZ1ZkMFwiLFxuXHRcIm1vZGFsX2NvbnRlbnRcIjogXCJNb2RhbF9tb2RhbF9jb250ZW50X19ORnhDQlwiLFxuXHRcIm1vZGFsX3RpdGxlXCI6IFwiTW9kYWxfbW9kYWxfdGl0bGVfXzNHcEpPXCIsXG5cdFwibWVzc2FnZV93cmFwcGVyXCI6IFwiTW9kYWxfbWVzc2FnZV93cmFwcGVyX19VZ3pjUlwiLFxuXHRcIm1vZGFsX21lc3NhZ2VcIjogXCJNb2RhbF9tb2RhbF9tZXNzYWdlX19BbTNQS1wiLFxuXHRcIm1vZGFsX2J1dHRvbnNcIjogXCJNb2RhbF9tb2RhbF9idXR0b25zX19uSTdWdFwiLFxuXHRcImNlbnRlcl9sb2FkaW5nXCI6IFwiTW9kYWxfY2VudGVyX2xvYWRpbmdfX2RsMl9yXCJcbn07XG5tb2R1bGUuZXhwb3J0cyA9IF9fX0NTU19MT0FERVJfRVhQT1JUX19fO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[2]!./src/components/Modal/Modal.module.css\n");

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[2]!./src/components/VideoPlayer/VideoPlayerDesktop.module.css":
/*!**********************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[2]!./src/components/VideoPlayer/VideoPlayerDesktop.module.css ***!
  \**********************************************************************************************************************************************************************************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("// Imports\nvar ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../../../node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js\");\nvar ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(true);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \".VideoPlayerDesktop_video_wrapper__x73Jz {\\n    overflow: hidden;\\n    border-radius: 20px;\\n    width: 100%;\\n    max-width: 1000px;\\n    position: relative;\\n    display: flex;\\n    justify-content: center;\\n    /* margin-inline: auto; */\\n    z-index: 1;\\n}\\n\\n.VideoPlayerDesktop_theater_mode__e4vIY {\\n    overflow: hidden;\\n    position: relative;\\n    display: flex;\\n    border-radius: 20px;\\n    justify-content: center;\\n    top: 0;\\n    left: 0;\\n    width: 100%;\\n    height: auto;\\n    background-color: rgba(0, 0, 0, 0.5);\\n    z-index: 1;\\n}\\n\\n.VideoPlayerDesktop_video__6UoEx {\\n\\n    height: 100%;\\n    width: 100%;\\n}\\n\\n.VideoPlayerDesktop_controls_wrapper__tzBsg {\\n    position: absolute;\\n    bottom: 0;\\n    width: 100%;\\n    padding: 10px;\\n    border-radius: 20px 20px 0 0;\\n    z-index: 100;\\n    opacity: 0;\\n    transition: opacity 150ms ease-in-out;\\n}\\n\\n.VideoPlayerDesktop_controls_wrapper__tzBsg::before {\\n    content: \\\"\\\";\\n    position: absolute;\\n    top: 0;\\n    left: 0;\\n    width: 100%;\\n    height: 100%;\\n    background: linear-gradient(to top, rgba(0, 0, 0, .75), transparent);\\n    border-radius: 20px 20px 0 0;\\n    pointer-events: none;\\n    z-index: -1;\\n}\\n\\n\\n.VideoPlayerDesktop_controls__p_HqL {\\n    display: flex;\\n    flex-direction: column;\\n}\\n\\n\\n.VideoPlayerDesktop_video_wrapper__x73Jz:hover .VideoPlayerDesktop_controls_wrapper__tzBsg,\\n.VideoPlayerDesktop_video_wrapper__x73Jz:focus-within .VideoPlayerDesktop_controls_wrapper__tzBsg,\\n.VideoPlayerDesktop_theater_mode__e4vIY:hover .VideoPlayerDesktop_controls_wrapper__tzBsg {\\n    opacity: 1;\\n}\\n\\n.VideoPlayerDesktop_show_controls__Va_CI {\\n    opacity: 1;\\n}\\n\\n.VideoPlayerDesktop_hide_controls__w7zvg {\\n    opacity: 0 !important;\\n}\\n\\n.VideoPlayerDesktop_playing_ad_wrapper__laEbh {\\n    position: absolute;\\n    top: 10px;\\n    left: 10px;\\n    width: 50px;\\n    height: 25px;\\n    text-align: center;\\n    background-color: #fbc02d;\\n    display: flex;\\n    justify-content: center;\\n    align-items: center;\\n    border-radius: 8px;\\n}\\n\\n\\n\\n.VideoPlayerDesktop_bottom_controls__R1ITu {\\n    display: flex;\\n    flex-direction: row;\\n    justify-content: space-between;\\n    align-items: center;\\n    padding: 10px;\\n    border-radius: 0 0 20px 20px;\\n}\\n\\n.VideoPlayerDesktop_controls_left__7tZhZ {\\n    display: flex;\\n    flex-direction: row;\\n    gap: 20px;\\n    align-items: center;\\n}\\n\\n.VideoPlayerDesktop_controls_right__aIGPg {\\n    display: flex;\\n    flex-direction: row;\\n    gap: 20px;\\n    align-items: center;\\n}\\n\\n\\n/* Volume Wrapper */\\n\\n.VideoPlayerDesktop_volume_wrap__I1kGr {\\n    padding: 0 10px 0 0;\\n    display: inline-block;\\n}\\n\\n.VideoPlayerDesktop_volume_btn__JVtiY {\\n    float: left;\\n}\\n\\n.VideoPlayerDesktop_volume_wrap__I1kGr {\\n    justify-content: center;\\n    align-items: center;\\n    display: flex;\\n}\\n\\n.VideoPlayerDesktop_volume_wrap__I1kGr #VideoPlayerDesktop_volume__kj5Uy {\\n    float: left;\\n}\\n\\n.VideoPlayerDesktop_volume_wrap__I1kGr.VideoPlayerDesktop_volume_show__Zpk0J button {\\n    color: white;\\n}\\n\\n.VideoPlayerDesktop_volume_wrap__I1kGr.VideoPlayerDesktop_volume_show__Zpk0J .VideoPlayerDesktop_volume_panel___2X_8 {\\n    width: 73px;\\n}\\n\\n.VideoPlayerDesktop_volume_wrap__I1kGr .VideoPlayerDesktop_volume_panel___2X_8 {\\n    float: left;\\n    height: 40px;\\n    width: 0;\\n    overflow: hidden;\\n    transition: width 0.2s;\\n    cursor: pointer;\\n}\\n\\n.VideoPlayerDesktop_volume_wrap__I1kGr .VideoPlayerDesktop_volume_panel___2X_8 .VideoPlayerDesktop_volume_slider___O1V2 {\\n    position: relative;\\n    height: 100%;\\n}\\n\\n.VideoPlayerDesktop_volume_wrap__I1kGr .VideoPlayerDesktop_volume_panel___2X_8 .VideoPlayerDesktop_volume_slider_track__lsoBd {\\n    height: 3px;\\n    width: 70px;\\n    position: absolute;\\n    top: 50%;\\n    right: 0;\\n    margin-top: -1px;\\n    background: gray;\\n}\\n\\n.VideoPlayerDesktop_volume_wrap__I1kGr .VideoPlayerDesktop_volume_panel___2X_8 .VideoPlayerDesktop_volume_slider_progress__bPy2i {\\n    height: 100%;\\n    width: 50%;\\n    background: red;\\n    position: relative;\\n}\\n\\n.VideoPlayerDesktop_volume_wrap__I1kGr .VideoPlayerDesktop_volume_panel___2X_8 .VideoPlayerDesktop_volume_slider_handle__lsjnY {\\n    height: 12px;\\n    width: 3px;\\n    position: absolute;\\n    top: -5px;\\n    right: 0;\\n    background: white;\\n}\\n\\n\\n.VideoPlayerDesktop_current_quality__QQ5Oq {\\n    background-color: var(--primary-color);\\n    padding-left: 5px;\\n    padding-right: 5px;\\n    border-radius: 5px;\\n    opacity: 1;\\n    transition: opacity 150ms ease-in-out;\\n\\n}\\n\\n\\n/* Duration Wrapper */\\n.VideoPlayerDesktop_duration__4WGZt {\\n    display: flex;\\n    flex-direction: row;\\n    justify-content: center;\\n    align-items: center;\\n    gap: 3px;\\n}\\n\\n/* Buttons */\\n\\n.VideoPlayerDesktop_btn__9i09n {\\n    width: 24px;\\n    height: 24px;\\n    cursor: pointer;\\n}\\n\\n.VideoPlayerDesktop_pause_play_btn__4uSsh {\\n    cursor: pointer;\\n}\\n\\n.VideoPlayerDesktop_settings_btn__gtZVU {\\n    transition: all 0.2s ease-in-out;\\n}\\n\\n/* Timeline */\\n\\n.VideoPlayerDesktop_timeline_wrap__dNTLs {\\n    width: 100%;\\n}\\n\\n.VideoPlayerDesktop_timeline_wrap__dNTLs {\\n    justify-content: center;\\n    align-items: center;\\n    display: flex;\\n}\\n\\n.VideoPlayerDesktop_timeline_wrap__dNTLs.VideoPlayerDesktop_timeline_show__jjjNr button {\\n    color: white;\\n}\\n\\n.VideoPlayerDesktop_timeline_wrap__dNTLs.VideoPlayerDesktop_timeline_show__jjjNr .VideoPlayerDesktop_timeline_panel__16yFK {\\n    width: 100%;\\n}\\n\\n.VideoPlayerDesktop_timeline_wrap__dNTLs .VideoPlayerDesktop_timeline_panel__16yFK {\\n    height: 20px;\\n    width: 100%;\\n    overflow: hidden;\\n    transition: width 0.2s;\\n    cursor: pointer;\\n}\\n\\n.VideoPlayerDesktop_timeline_wrap__dNTLs .VideoPlayerDesktop_timeline_panel__16yFK .VideoPlayerDesktop_timeline_slider__O_FF5 {\\n    position: relative;\\n    height: 100%;\\n}\\n\\n.VideoPlayerDesktop_timeline_wrap__dNTLs .VideoPlayerDesktop_timeline_panel__16yFK .VideoPlayerDesktop_timeline_slider_track__SgKLd {\\n    height: 3px;\\n    width: 100%;\\n    position: absolute;\\n    top: 50%;\\n    right: 0;\\n    margin-top: -1px;\\n    background: #fff;\\n}\\n\\n.VideoPlayerDesktop_timeline_wrap__dNTLs .VideoPlayerDesktop_timeline_panel__16yFK .VideoPlayerDesktop_timeline_slider_progress__D7sAF {\\n    height: 100%;\\n    width: 50%;\\n    background: red;\\n    position: relative;\\n}\\n\\n.VideoPlayerDesktop_timeline_wrap__dNTLs:hover .VideoPlayerDesktop_timeline_panel__16yFK .VideoPlayerDesktop_timeline_slider_handle__ljYiK {\\n    height: 12px;\\n    width: 12px;\\n    border-radius: 100px;\\n    position: absolute;\\n    top: -5px;\\n    right: 0;\\n    background: white;\\n}\\n\\n\\n/* settings popup */\\n.VideoPlayerDesktop_settings_popup__fHLT3 {\\n    z-index: 101;\\n    right: 20px;\\n    bottom: 100px;\\n    padding: 10px 20px 10px 20px;\\n    width: 300px;\\n    height: 100px;\\n    position: absolute;\\n    overflow: hidden;\\n    justify-content: space-between;\\n    border-radius: 10px;\\n    background: rgba(28, 28, 28, .9);\\n    text-shadow: 0 0 2px rgb(0 0 0 / 50%);\\n    display: none;\\n    -webkit-animation: VideoPlayerDesktop_show_settings__7KkJG .5s ease-in-out;\\n            animation: VideoPlayerDesktop_show_settings__7KkJG .5s ease-in-out;\\n    transition: height 0.5s;\\n}\\n\\n.VideoPlayerDesktop_settings_popup_show__NErsU {\\n    height: 250px;\\n}\\n\\n@-webkit-keyframes VideoPlayerDesktop_show_settings__7KkJG {\\n\\n    0% {\\n        border-radius: 0%;\\n        transform: scale(0);\\n        opacity: 0;\\n    }\\n\\n    100% {\\n        border-radius: 10px;\\n        transform: scale(1);\\n        opacity: 1;\\n    }\\n}\\n\\n@keyframes VideoPlayerDesktop_show_settings__7KkJG {\\n\\n    0% {\\n        border-radius: 0%;\\n        transform: scale(0);\\n        opacity: 0;\\n    }\\n\\n    100% {\\n        border-radius: 10px;\\n        transform: scale(1);\\n        opacity: 1;\\n    }\\n}\\n\\n.VideoPlayerDesktop_settings_item__HI29i {\\n    height: -webkit-fit-content;\\n    height: -moz-fit-content;\\n    height: fit-content;\\n    padding: 5px;\\n    align-items: center;\\n    gap: 5px;\\n    display: flex;\\n    background-repeat: no-repeat;\\n    background-position: right center;\\n    background-size: 32px 32px;\\n    -moz-background-size: 32px 32px;\\n    -webkit-background-size: 32px 32px;\\n    background-image: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMDAlIiBoZWlnaHQ9IjEwMCUiIHZpZXdCb3g9IjAgMCAzMiAzMiIgdmVyc2lvbj0iMS4xIj48cGF0aCBkPSJtIDEyLjU5LDIwLjM0IDQuNTgsLTQuNTkgLTQuNTgsLTQuNTkgMS40MSwtMS40MSA2LDYgLTYsNiB6IiBmaWxsPSIjZmZmIiAvPjwvc3ZnPg==);\\n}\\n\\n.VideoPlayerDesktop_center_on_screen__lvaAB {\\n    position: absolute;\\n    top: 50%;\\n    left: 50%;\\n    transform: translate(-50%, -50%);\\n}\", \"\",{\"version\":3,\"sources\":[\"webpack://src/components/VideoPlayer/VideoPlayerDesktop.module.css\"],\"names\":[],\"mappings\":\"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\",\"sourcesContent\":[\".video_wrapper {\\n    overflow: hidden;\\n    border-radius: 20px;\\n    width: 100%;\\n    max-width: 1000px;\\n    position: relative;\\n    display: flex;\\n    justify-content: center;\\n    /* margin-inline: auto; */\\n    z-index: 1;\\n}\\n\\n.theater_mode {\\n    overflow: hidden;\\n    position: relative;\\n    display: flex;\\n    border-radius: 20px;\\n    justify-content: center;\\n    top: 0;\\n    left: 0;\\n    width: 100%;\\n    height: auto;\\n    background-color: rgba(0, 0, 0, 0.5);\\n    z-index: 1;\\n}\\n\\n.video {\\n\\n    height: 100%;\\n    width: 100%;\\n}\\n\\n.controls_wrapper {\\n    position: absolute;\\n    bottom: 0;\\n    width: 100%;\\n    padding: 10px;\\n    border-radius: 20px 20px 0 0;\\n    z-index: 100;\\n    opacity: 0;\\n    transition: opacity 150ms ease-in-out;\\n}\\n\\n.controls_wrapper::before {\\n    content: \\\"\\\";\\n    position: absolute;\\n    top: 0;\\n    left: 0;\\n    width: 100%;\\n    height: 100%;\\n    background: linear-gradient(to top, rgba(0, 0, 0, .75), transparent);\\n    border-radius: 20px 20px 0 0;\\n    pointer-events: none;\\n    z-index: -1;\\n}\\n\\n\\n.controls {\\n    display: flex;\\n    flex-direction: column;\\n}\\n\\n\\n.video_wrapper:hover .controls_wrapper,\\n.video_wrapper:focus-within .controls_wrapper,\\n.theater_mode:hover .controls_wrapper {\\n    opacity: 1;\\n}\\n\\n.show_controls {\\n    opacity: 1;\\n}\\n\\n.hide_controls {\\n    opacity: 0 !important;\\n}\\n\\n.playing_ad_wrapper {\\n    position: absolute;\\n    top: 10px;\\n    left: 10px;\\n    width: 50px;\\n    height: 25px;\\n    text-align: center;\\n    background-color: #fbc02d;\\n    display: flex;\\n    justify-content: center;\\n    align-items: center;\\n    border-radius: 8px;\\n}\\n\\n\\n\\n.bottom_controls {\\n    display: flex;\\n    flex-direction: row;\\n    justify-content: space-between;\\n    align-items: center;\\n    padding: 10px;\\n    border-radius: 0 0 20px 20px;\\n}\\n\\n.controls_left {\\n    display: flex;\\n    flex-direction: row;\\n    gap: 20px;\\n    align-items: center;\\n}\\n\\n.controls_right {\\n    display: flex;\\n    flex-direction: row;\\n    gap: 20px;\\n    align-items: center;\\n}\\n\\n\\n/* Volume Wrapper */\\n\\n.volume_wrap {\\n    padding: 0 10px 0 0;\\n    display: inline-block;\\n}\\n\\n.volume_btn {\\n    float: left;\\n}\\n\\n.volume_wrap {\\n    justify-content: center;\\n    align-items: center;\\n    display: flex;\\n}\\n\\n.volume_wrap #volume {\\n    float: left;\\n}\\n\\n.volume_wrap.volume_show button {\\n    color: white;\\n}\\n\\n.volume_wrap.volume_show .volume_panel {\\n    width: 73px;\\n}\\n\\n.volume_wrap .volume_panel {\\n    float: left;\\n    height: 40px;\\n    width: 0;\\n    overflow: hidden;\\n    transition: width 0.2s;\\n    cursor: pointer;\\n}\\n\\n.volume_wrap .volume_panel .volume_slider {\\n    position: relative;\\n    height: 100%;\\n}\\n\\n.volume_wrap .volume_panel .volume_slider_track {\\n    height: 3px;\\n    width: 70px;\\n    position: absolute;\\n    top: 50%;\\n    right: 0;\\n    margin-top: -1px;\\n    background: gray;\\n}\\n\\n.volume_wrap .volume_panel .volume_slider_progress {\\n    height: 100%;\\n    width: 50%;\\n    background: red;\\n    position: relative;\\n}\\n\\n.volume_wrap .volume_panel .volume_slider_handle {\\n    height: 12px;\\n    width: 3px;\\n    position: absolute;\\n    top: -5px;\\n    right: 0;\\n    background: white;\\n}\\n\\n\\n.current_quality {\\n    background-color: var(--primary-color);\\n    padding-left: 5px;\\n    padding-right: 5px;\\n    border-radius: 5px;\\n    opacity: 1;\\n    transition: opacity 150ms ease-in-out;\\n\\n}\\n\\n\\n/* Duration Wrapper */\\n.duration {\\n    display: flex;\\n    flex-direction: row;\\n    justify-content: center;\\n    align-items: center;\\n    gap: 3px;\\n}\\n\\n/* Buttons */\\n\\n.btn {\\n    width: 24px;\\n    height: 24px;\\n    cursor: pointer;\\n}\\n\\n.pause_play_btn {\\n    cursor: pointer;\\n}\\n\\n.settings_btn {\\n    transition: all 0.2s ease-in-out;\\n}\\n\\n/* Timeline */\\n\\n.timeline_wrap {\\n    width: 100%;\\n}\\n\\n.timeline_wrap {\\n    justify-content: center;\\n    align-items: center;\\n    display: flex;\\n}\\n\\n.timeline_wrap.timeline_show button {\\n    color: white;\\n}\\n\\n.timeline_wrap.timeline_show .timeline_panel {\\n    width: 100%;\\n}\\n\\n.timeline_wrap .timeline_panel {\\n    height: 20px;\\n    width: 100%;\\n    overflow: hidden;\\n    transition: width 0.2s;\\n    cursor: pointer;\\n}\\n\\n.timeline_wrap .timeline_panel .timeline_slider {\\n    position: relative;\\n    height: 100%;\\n}\\n\\n.timeline_wrap .timeline_panel .timeline_slider_track {\\n    height: 3px;\\n    width: 100%;\\n    position: absolute;\\n    top: 50%;\\n    right: 0;\\n    margin-top: -1px;\\n    background: #fff;\\n}\\n\\n.timeline_wrap .timeline_panel .timeline_slider_progress {\\n    height: 100%;\\n    width: 50%;\\n    background: red;\\n    position: relative;\\n}\\n\\n.timeline_wrap:hover .timeline_panel .timeline_slider_handle {\\n    height: 12px;\\n    width: 12px;\\n    border-radius: 100px;\\n    position: absolute;\\n    top: -5px;\\n    right: 0;\\n    background: white;\\n}\\n\\n\\n/* settings popup */\\n.settings_popup {\\n    z-index: 101;\\n    right: 20px;\\n    bottom: 100px;\\n    padding: 10px 20px 10px 20px;\\n    width: 300px;\\n    height: 100px;\\n    position: absolute;\\n    overflow: hidden;\\n    justify-content: space-between;\\n    border-radius: 10px;\\n    background: rgba(28, 28, 28, .9);\\n    text-shadow: 0 0 2px rgb(0 0 0 / 50%);\\n    display: none;\\n    animation: show_settings .5s ease-in-out;\\n    transition: height 0.5s;\\n}\\n\\n.settings_popup_show {\\n    height: 250px;\\n}\\n\\n@keyframes show_settings {\\n\\n    0% {\\n        border-radius: 0%;\\n        transform: scale(0);\\n        opacity: 0;\\n    }\\n\\n    100% {\\n        border-radius: 10px;\\n        transform: scale(1);\\n        opacity: 1;\\n    }\\n}\\n\\n.settings_item {\\n    height: fit-content;\\n    padding: 5px;\\n    align-items: center;\\n    gap: 5px;\\n    display: flex;\\n    background-repeat: no-repeat;\\n    background-position: right center;\\n    background-size: 32px 32px;\\n    -moz-background-size: 32px 32px;\\n    -webkit-background-size: 32px 32px;\\n    background-image: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMDAlIiBoZWlnaHQ9IjEwMCUiIHZpZXdCb3g9IjAgMCAzMiAzMiIgdmVyc2lvbj0iMS4xIj48cGF0aCBkPSJtIDEyLjU5LDIwLjM0IDQuNTgsLTQuNTkgLTQuNTgsLTQuNTkgMS40MSwtMS40MSA2LDYgLTYsNiB6IiBmaWxsPSIjZmZmIiAvPjwvc3ZnPg==);\\n}\\n\\n.center_on_screen {\\n    position: absolute;\\n    top: 50%;\\n    left: 50%;\\n    transform: translate(-50%, -50%);\\n}\"],\"sourceRoot\":\"\"}]);\n// Exports\n___CSS_LOADER_EXPORT___.locals = {\n\t\"video_wrapper\": \"VideoPlayerDesktop_video_wrapper__x73Jz\",\n\t\"theater_mode\": \"VideoPlayerDesktop_theater_mode__e4vIY\",\n\t\"video\": \"VideoPlayerDesktop_video__6UoEx\",\n\t\"controls_wrapper\": \"VideoPlayerDesktop_controls_wrapper__tzBsg\",\n\t\"controls\": \"VideoPlayerDesktop_controls__p_HqL\",\n\t\"show_controls\": \"VideoPlayerDesktop_show_controls__Va_CI\",\n\t\"hide_controls\": \"VideoPlayerDesktop_hide_controls__w7zvg\",\n\t\"playing_ad_wrapper\": \"VideoPlayerDesktop_playing_ad_wrapper__laEbh\",\n\t\"bottom_controls\": \"VideoPlayerDesktop_bottom_controls__R1ITu\",\n\t\"controls_left\": \"VideoPlayerDesktop_controls_left__7tZhZ\",\n\t\"controls_right\": \"VideoPlayerDesktop_controls_right__aIGPg\",\n\t\"volume_wrap\": \"VideoPlayerDesktop_volume_wrap__I1kGr\",\n\t\"volume_btn\": \"VideoPlayerDesktop_volume_btn__JVtiY\",\n\t\"volume\": \"VideoPlayerDesktop_volume__kj5Uy\",\n\t\"volume_show\": \"VideoPlayerDesktop_volume_show__Zpk0J\",\n\t\"volume_panel\": \"VideoPlayerDesktop_volume_panel___2X_8\",\n\t\"volume_slider\": \"VideoPlayerDesktop_volume_slider___O1V2\",\n\t\"volume_slider_track\": \"VideoPlayerDesktop_volume_slider_track__lsoBd\",\n\t\"volume_slider_progress\": \"VideoPlayerDesktop_volume_slider_progress__bPy2i\",\n\t\"volume_slider_handle\": \"VideoPlayerDesktop_volume_slider_handle__lsjnY\",\n\t\"current_quality\": \"VideoPlayerDesktop_current_quality__QQ5Oq\",\n\t\"duration\": \"VideoPlayerDesktop_duration__4WGZt\",\n\t\"btn\": \"VideoPlayerDesktop_btn__9i09n\",\n\t\"pause_play_btn\": \"VideoPlayerDesktop_pause_play_btn__4uSsh\",\n\t\"settings_btn\": \"VideoPlayerDesktop_settings_btn__gtZVU\",\n\t\"timeline_wrap\": \"VideoPlayerDesktop_timeline_wrap__dNTLs\",\n\t\"timeline_show\": \"VideoPlayerDesktop_timeline_show__jjjNr\",\n\t\"timeline_panel\": \"VideoPlayerDesktop_timeline_panel__16yFK\",\n\t\"timeline_slider\": \"VideoPlayerDesktop_timeline_slider__O_FF5\",\n\t\"timeline_slider_track\": \"VideoPlayerDesktop_timeline_slider_track__SgKLd\",\n\t\"timeline_slider_progress\": \"VideoPlayerDesktop_timeline_slider_progress__D7sAF\",\n\t\"timeline_slider_handle\": \"VideoPlayerDesktop_timeline_slider_handle__ljYiK\",\n\t\"settings_popup\": \"VideoPlayerDesktop_settings_popup__fHLT3\",\n\t\"show_settings\": \"VideoPlayerDesktop_show_settings__7KkJG\",\n\t\"settings_popup_show\": \"VideoPlayerDesktop_settings_popup_show__NErsU\",\n\t\"settings_item\": \"VideoPlayerDesktop_settings_item__HI29i\",\n\t\"center_on_screen\": \"VideoPlayerDesktop_center_on_screen__lvaAB\"\n};\nmodule.exports = ___CSS_LOADER_EXPORT___;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1szXS5vbmVPZls0XS51c2VbMV0hLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbM10ub25lT2ZbNF0udXNlWzJdIS4vc3JjL2NvbXBvbmVudHMvVmlkZW9QbGF5ZXIvVmlkZW9QbGF5ZXJEZXNrdG9wLm1vZHVsZS5jc3MuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxrQ0FBa0MsbUJBQU8sQ0FBQyx5S0FBcUY7QUFDL0g7QUFDQTtBQUNBLG9GQUFvRix1QkFBdUIsMEJBQTBCLGtCQUFrQix3QkFBd0IseUJBQXlCLG9CQUFvQiw4QkFBOEIsOEJBQThCLG1CQUFtQixHQUFHLDZDQUE2Qyx1QkFBdUIseUJBQXlCLG9CQUFvQiwwQkFBMEIsOEJBQThCLGFBQWEsY0FBYyxrQkFBa0IsbUJBQW1CLDJDQUEyQyxpQkFBaUIsR0FBRyxzQ0FBc0MscUJBQXFCLGtCQUFrQixHQUFHLGlEQUFpRCx5QkFBeUIsZ0JBQWdCLGtCQUFrQixvQkFBb0IsbUNBQW1DLG1CQUFtQixpQkFBaUIsNENBQTRDLEdBQUcseURBQXlELG9CQUFvQix5QkFBeUIsYUFBYSxjQUFjLGtCQUFrQixtQkFBbUIsMkVBQTJFLG1DQUFtQywyQkFBMkIsa0JBQWtCLEdBQUcsMkNBQTJDLG9CQUFvQiw2QkFBNkIsR0FBRyxrU0FBa1MsaUJBQWlCLEdBQUcsOENBQThDLGlCQUFpQixHQUFHLDhDQUE4Qyw0QkFBNEIsR0FBRyxtREFBbUQseUJBQXlCLGdCQUFnQixpQkFBaUIsa0JBQWtCLG1CQUFtQix5QkFBeUIsZ0NBQWdDLG9CQUFvQiw4QkFBOEIsMEJBQTBCLHlCQUF5QixHQUFHLG9EQUFvRCxvQkFBb0IsMEJBQTBCLHFDQUFxQyww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YUFBYSxXQUFXLFlBQVksT0FBTyxLQUFLLFVBQVUsWUFBWSxXQUFXLFlBQVksT0FBTyxLQUFLLFVBQVUsWUFBWSxXQUFXLFlBQVksUUFBUSxhQUFhLE1BQU0sWUFBWSxhQUFhLE9BQU8sS0FBSyxVQUFVLE1BQU0sS0FBSyxZQUFZLGFBQWEsV0FBVyxPQUFPLEtBQUssVUFBVSxNQUFNLEtBQUssVUFBVSxPQUFPLEtBQUssVUFBVSxNQUFNLEtBQUssVUFBVSxVQUFVLFVBQVUsWUFBWSxhQUFhLFdBQVcsT0FBTyxLQUFLLFlBQVksV0FBVyxPQUFPLEtBQUssVUFBVSxVQUFVLFlBQVksV0FBVyxVQUFVLFlBQVksYUFBYSxPQUFPLEtBQUssVUFBVSxVQUFVLFVBQVUsWUFBWSxPQUFPLEtBQUssVUFBVSxVQUFVLFlBQVksV0FBVyxVQUFVLFlBQVksUUFBUSxLQUFLLFlBQVksYUFBYSxhQUFhLGFBQWEsV0FBVyxhQUFhLFFBQVEsWUFBWSxNQUFNLFVBQVUsWUFBWSxhQUFhLGFBQWEsV0FBVyxNQUFNLFdBQVcsS0FBSyxVQUFVLFVBQVUsVUFBVSxPQUFPLEtBQUssVUFBVSxPQUFPLEtBQUssWUFBWSxPQUFPLFdBQVcsS0FBSyxVQUFVLE1BQU0sS0FBSyxZQUFZLGFBQWEsV0FBVyxPQUFPLEtBQUssVUFBVSxPQUFPLEtBQUssVUFBVSxNQUFNLEtBQUssVUFBVSxVQUFVLFlBQVksYUFBYSxXQUFXLE9BQU8sS0FBSyxZQUFZLFdBQVcsT0FBTyxLQUFLLFVBQVUsVUFBVSxZQUFZLFdBQVcsVUFBVSxZQUFZLGFBQWEsT0FBTyxLQUFLLFVBQVUsVUFBVSxVQUFVLFlBQVksT0FBTyxLQUFLLFVBQVUsVUFBVSxZQUFZLGFBQWEsV0FBVyxVQUFVLFlBQVksUUFBUSxZQUFZLE1BQU0sVUFBVSxVQUFVLFVBQVUsWUFBWSxXQUFXLFVBQVUsWUFBWSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsV0FBVyxZQUFZLGFBQWEsYUFBYSxPQUFPLEtBQUssVUFBVSxPQUFPLE1BQU0sS0FBSyxZQUFZLGFBQWEsV0FBVyxNQUFNLEtBQUss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b0IsR0FBRyw4QkFBOEIsWUFBWSw0QkFBNEIsOEJBQThCLHFCQUFxQixPQUFPLGNBQWMsOEJBQThCLDhCQUE4QixxQkFBcUIsT0FBTyxHQUFHLG9CQUFvQiwwQkFBMEIsbUJBQW1CLDBCQUEwQixlQUFlLG9CQUFvQixtQ0FBbUMsd0NBQXdDLGlDQUFpQyxzQ0FBc0MseUNBQXlDLCtDQUErQyx5UUFBeVEsR0FBRyx1QkFBdUIseUJBQXlCLGVBQWUsZ0JBQWdCLHVDQUF1QyxHQUFHLG1CQUFtQjtBQUNyMmpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbXBvbmVudHMvVmlkZW9QbGF5ZXIvVmlkZW9QbGF5ZXJEZXNrdG9wLm1vZHVsZS5jc3M/Mzg5MCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBJbXBvcnRzXG52YXIgX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fID0gcmVxdWlyZShcIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL2Nzcy1sb2FkZXIvc3JjL3J1bnRpbWUvYXBpLmpzXCIpO1xudmFyIF9fX0NTU19MT0FERVJfRVhQT1JUX19fID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKHRydWUpO1xuLy8gTW9kdWxlXG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5wdXNoKFttb2R1bGUuaWQsIFwiLlZpZGVvUGxheWVyRGVza3RvcF92aWRlb193cmFwcGVyX194NzNKeiB7XFxuICAgIG92ZXJmbG93OiBoaWRkZW47XFxuICAgIGJvcmRlci1yYWRpdXM6IDIwcHg7XFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgICBtYXgtd2lkdGg6IDEwMDBweDtcXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG4gICAgLyogbWFyZ2luLWlubGluZTogYXV0bzsgKi9cXG4gICAgei1pbmRleDogMTtcXG59XFxuXFxuLlZpZGVvUGxheWVyRGVza3RvcF90aGVhdGVyX21vZGVfX2U0dklZIHtcXG4gICAgb3ZlcmZsb3c6IGhpZGRlbjtcXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICBib3JkZXItcmFkaXVzOiAyMHB4O1xcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG4gICAgdG9wOiAwO1xcbiAgICBsZWZ0OiAwO1xcbiAgICB3aWR0aDogMTAwJTtcXG4gICAgaGVpZ2h0OiBhdXRvO1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuNSk7XFxuICAgIHotaW5kZXg6IDE7XFxufVxcblxcbi5WaWRlb1BsYXllckRlc2t0b3BfdmlkZW9fXzZVb0V4IHtcXG5cXG4gICAgaGVpZ2h0OiAxMDAlO1xcbiAgICB3aWR0aDogMTAwJTtcXG59XFxuXFxuLlZpZGVvUGxheWVyRGVza3RvcF9jb250cm9sc193cmFwcGVyX190ekJzZyB7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgYm90dG9tOiAwO1xcbiAgICB3aWR0aDogMTAwJTtcXG4gICAgcGFkZGluZzogMTBweDtcXG4gICAgYm9yZGVyLXJhZGl1czogMjBweCAyMHB4IDAgMDtcXG4gICAgei1pbmRleDogMTAwO1xcbiAgICBvcGFjaXR5OiAwO1xcbiAgICB0cmFuc2l0aW9uOiBvcGFjaXR5IDE1MG1zIGVhc2UtaW4tb3V0O1xcbn1cXG5cXG4uVmlkZW9QbGF5ZXJEZXNrdG9wX2NvbnRyb2xzX3dyYXBwZXJfX3R6QnNnOjpiZWZvcmUge1xcbiAgICBjb250ZW50OiBcXFwiXFxcIjtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICB0b3A6IDA7XFxuICAgIGxlZnQ6IDA7XFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgICBoZWlnaHQ6IDEwMCU7XFxuICAgIGJhY2tncm91bmQ6IGxpbmVhci1ncmFkaWVudCh0byB0b3AsIHJnYmEoMCwgMCwgMCwgLjc1KSwgdHJhbnNwYXJlbnQpO1xcbiAgICBib3JkZXItcmFkaXVzOiAyMHB4IDIwcHggMCAwO1xcbiAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcXG4gICAgei1pbmRleDogLTE7XFxufVxcblxcblxcbi5WaWRlb1BsYXllckRlc2t0b3BfY29udHJvbHNfX3BfSHFMIHtcXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG59XFxuXFxuXFxuLlZpZGVvUGxheWVyRGVza3RvcF92aWRlb193cmFwcGVyX194NzNKejpob3ZlciAuVmlkZW9QbGF5ZXJEZXNrdG9wX2NvbnRyb2xzX3dyYXBwZXJfX3R6QnNnLFxcbi5WaWRlb1BsYXllckRlc2t0b3BfdmlkZW9fd3JhcHBlcl9feDczSno6Zm9jdXMtd2l0aGluIC5WaWRlb1BsYXllckRlc2t0b3BfY29udHJvbHNfd3JhcHBlcl9fdHpCc2csXFxuLlZpZGVvUGxheWVyRGVza3RvcF90aGVhdGVyX21vZGVfX2U0dklZOmhvdmVyIC5WaWRlb1BsYXllckRlc2t0b3BfY29udHJvbHNfd3JhcHBlcl9fdHpCc2cge1xcbiAgICBvcGFjaXR5OiAxO1xcbn1cXG5cXG4uVmlkZW9QbGF5ZXJEZXNrdG9wX3Nob3dfY29udHJvbHNfX1ZhX0NJIHtcXG4gICAgb3BhY2l0eTogMTtcXG59XFxuXFxuLlZpZGVvUGxheWVyRGVza3RvcF9oaWRlX2NvbnRyb2xzX193N3p2ZyB7XFxuICAgIG9wYWNpdHk6IDAgIWltcG9ydGFudDtcXG59XFxuXFxuLlZpZGVvUGxheWVyRGVza3RvcF9wbGF5aW5nX2FkX3dyYXBwZXJfX2xhRWJoIHtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICB0b3A6IDEwcHg7XFxuICAgIGxlZnQ6IDEwcHg7XFxuICAgIHdpZHRoOiA1MHB4O1xcbiAgICBoZWlnaHQ6IDI1cHg7XFxuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI2ZiYzAyZDtcXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICAgIGJvcmRlci1yYWRpdXM6IDhweDtcXG59XFxuXFxuXFxuXFxuLlZpZGVvUGxheWVyRGVza3RvcF9ib3R0b21fY29udHJvbHNfX1IxSVR1IHtcXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAgZmxleC1kaXJlY3Rpb246IHJvdztcXG4gICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgICBwYWRkaW5nOiAxMHB4O1xcbiAgICBib3JkZXItcmFkaXVzOiAwIDAgMjBweCAyMHB4O1xcbn1cXG5cXG4uVmlkZW9QbGF5ZXJEZXNrdG9wX2NvbnRyb2xzX2xlZnRfXzd0WmhaIHtcXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAgZmxleC1kaXJlY3Rpb246IHJvdztcXG4gICAgZ2FwOiAyMHB4O1xcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbn1cXG5cXG4uVmlkZW9QbGF5ZXJEZXNrdG9wX2NvbnRyb2xzX3JpZ2h0X19hSUdQZyB7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGZsZXgtZGlyZWN0aW9uOiByb3c7XFxuICAgIGdhcDogMjBweDtcXG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG59XFxuXFxuXFxuLyogVm9sdW1lIFdyYXBwZXIgKi9cXG5cXG4uVmlkZW9QbGF5ZXJEZXNrdG9wX3ZvbHVtZV93cmFwX19JMWtHciB7XFxuICAgIHBhZGRpbmc6IDAgMTBweCAwIDA7XFxuICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG59XFxuXFxuLlZpZGVvUGxheWVyRGVza3RvcF92b2x1bWVfYnRuX19KVnRpWSB7XFxuICAgIGZsb2F0OiBsZWZ0O1xcbn1cXG5cXG4uVmlkZW9QbGF5ZXJEZXNrdG9wX3ZvbHVtZV93cmFwX19JMWtHciB7XFxuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbn1cXG5cXG4uVmlkZW9QbGF5ZXJEZXNrdG9wX3ZvbHVtZV93cmFwX19JMWtHciAjVmlkZW9QbGF5ZXJEZXNrdG9wX3ZvbHVtZV9fa2o1VXkge1xcbiAgICBmbG9hdDogbGVmdDtcXG59XFxuXFxuLlZpZGVvUGxheWVyRGVza3RvcF92b2x1bWVfd3JhcF9fSTFrR3IuVmlkZW9QbGF5ZXJEZXNrdG9wX3ZvbHVtZV9zaG93X19acGswSiBidXR0b24ge1xcbiAgICBjb2xvcjogd2hpdGU7XFxufVxcblxcbi5WaWRlb1BsYXllckRlc2t0b3Bfdm9sdW1lX3dyYXBfX0kxa0dyLlZpZGVvUGxheWVyRGVza3RvcF92b2x1bWVfc2hvd19fWnBrMEogLlZpZGVvUGxheWVyRGVza3RvcF92b2x1bWVfcGFuZWxfX18yWF84IHtcXG4gICAgd2lkdGg6IDczcHg7XFxufVxcblxcbi5WaWRlb1BsYXllckRlc2t0b3Bfdm9sdW1lX3dyYXBfX0kxa0dyIC5WaWRlb1BsYXllckRlc2t0b3Bfdm9sdW1lX3BhbmVsX19fMlhfOCB7XFxuICAgIGZsb2F0OiBsZWZ0O1xcbiAgICBoZWlnaHQ6IDQwcHg7XFxuICAgIHdpZHRoOiAwO1xcbiAgICBvdmVyZmxvdzogaGlkZGVuO1xcbiAgICB0cmFuc2l0aW9uOiB3aWR0aCAwLjJzO1xcbiAgICBjdXJzb3I6IHBvaW50ZXI7XFxufVxcblxcbi5WaWRlb1BsYXllckRlc2t0b3Bfdm9sdW1lX3dyYXBfX0kxa0dyIC5WaWRlb1BsYXllckRlc2t0b3Bfdm9sdW1lX3BhbmVsX19fMlhfOCAuVmlkZW9QbGF5ZXJEZXNrdG9wX3ZvbHVtZV9zbGlkZXJfX19PMVYyIHtcXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgICBoZWlnaHQ6IDEwMCU7XFxufVxcblxcbi5WaWRlb1BsYXllckRlc2t0b3Bfdm9sdW1lX3dyYXBfX0kxa0dyIC5WaWRlb1BsYXllckRlc2t0b3Bfdm9sdW1lX3BhbmVsX19fMlhfOCAuVmlkZW9QbGF5ZXJEZXNrdG9wX3ZvbHVtZV9zbGlkZXJfdHJhY2tfX2xzb0JkIHtcXG4gICAgaGVpZ2h0OiAzcHg7XFxuICAgIHdpZHRoOiA3MHB4O1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIHRvcDogNTAlO1xcbiAgICByaWdodDogMDtcXG4gICAgbWFyZ2luLXRvcDogLTFweDtcXG4gICAgYmFja2dyb3VuZDogZ3JheTtcXG59XFxuXFxuLlZpZGVvUGxheWVyRGVza3RvcF92b2x1bWVfd3JhcF9fSTFrR3IgLlZpZGVvUGxheWVyRGVza3RvcF92b2x1bWVfcGFuZWxfX18yWF84IC5WaWRlb1BsYXllckRlc2t0b3Bfdm9sdW1lX3NsaWRlcl9wcm9ncmVzc19fYlB5Mmkge1xcbiAgICBoZWlnaHQ6IDEwMCU7XFxuICAgIHdpZHRoOiA1MCU7XFxuICAgIGJhY2tncm91bmQ6IHJlZDtcXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbn1cXG5cXG4uVmlkZW9QbGF5ZXJEZXNrdG9wX3ZvbHVtZV93cmFwX19JMWtHciAuVmlkZW9QbGF5ZXJEZXNrdG9wX3ZvbHVtZV9wYW5lbF9fXzJYXzggLlZpZGVvUGxheWVyRGVza3RvcF92b2x1bWVfc2xpZGVyX2hhbmRsZV9fbHNqblkge1xcbiAgICBoZWlnaHQ6IDEycHg7XFxuICAgIHdpZHRoOiAzcHg7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgdG9wOiAtNXB4O1xcbiAgICByaWdodDogMDtcXG4gICAgYmFja2dyb3VuZDogd2hpdGU7XFxufVxcblxcblxcbi5WaWRlb1BsYXllckRlc2t0b3BfY3VycmVudF9xdWFsaXR5X19RUTVPcSB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLXByaW1hcnktY29sb3IpO1xcbiAgICBwYWRkaW5nLWxlZnQ6IDVweDtcXG4gICAgcGFkZGluZy1yaWdodDogNXB4O1xcbiAgICBib3JkZXItcmFkaXVzOiA1cHg7XFxuICAgIG9wYWNpdHk6IDE7XFxuICAgIHRyYW5zaXRpb246IG9wYWNpdHkgMTUwbXMgZWFzZS1pbi1vdXQ7XFxuXFxufVxcblxcblxcbi8qIER1cmF0aW9uIFdyYXBwZXIgKi9cXG4uVmlkZW9QbGF5ZXJEZXNrdG9wX2R1cmF0aW9uX180V0dadCB7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGZsZXgtZGlyZWN0aW9uOiByb3c7XFxuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgICBnYXA6IDNweDtcXG59XFxuXFxuLyogQnV0dG9ucyAqL1xcblxcbi5WaWRlb1BsYXllckRlc2t0b3BfYnRuX185aTA5biB7XFxuICAgIHdpZHRoOiAyNHB4O1xcbiAgICBoZWlnaHQ6IDI0cHg7XFxuICAgIGN1cnNvcjogcG9pbnRlcjtcXG59XFxuXFxuLlZpZGVvUGxheWVyRGVza3RvcF9wYXVzZV9wbGF5X2J0bl9fNHVTc2gge1xcbiAgICBjdXJzb3I6IHBvaW50ZXI7XFxufVxcblxcbi5WaWRlb1BsYXllckRlc2t0b3Bfc2V0dGluZ3NfYnRuX19ndFpWVSB7XFxuICAgIHRyYW5zaXRpb246IGFsbCAwLjJzIGVhc2UtaW4tb3V0O1xcbn1cXG5cXG4vKiBUaW1lbGluZSAqL1xcblxcbi5WaWRlb1BsYXllckRlc2t0b3BfdGltZWxpbmVfd3JhcF9fZE5UTHMge1xcbiAgICB3aWR0aDogMTAwJTtcXG59XFxuXFxuLlZpZGVvUGxheWVyRGVza3RvcF90aW1lbGluZV93cmFwX19kTlRMcyB7XFxuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbn1cXG5cXG4uVmlkZW9QbGF5ZXJEZXNrdG9wX3RpbWVsaW5lX3dyYXBfX2ROVExzLlZpZGVvUGxheWVyRGVza3RvcF90aW1lbGluZV9zaG93X19qampOciBidXR0b24ge1xcbiAgICBjb2xvcjogd2hpdGU7XFxufVxcblxcbi5WaWRlb1BsYXllckRlc2t0b3BfdGltZWxpbmVfd3JhcF9fZE5UTHMuVmlkZW9QbGF5ZXJEZXNrdG9wX3RpbWVsaW5lX3Nob3dfX2pqak5yIC5WaWRlb1BsYXllckRlc2t0b3BfdGltZWxpbmVfcGFuZWxfXzE2eUZLIHtcXG4gICAgd2lkdGg6IDEwMCU7XFxufVxcblxcbi5WaWRlb1BsYXllckRlc2t0b3BfdGltZWxpbmVfd3JhcF9fZE5UTHMgLlZpZGVvUGxheWVyRGVza3RvcF90aW1lbGluZV9wYW5lbF9fMTZ5Rksge1xcbiAgICBoZWlnaHQ6IDIwcHg7XFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgICBvdmVyZmxvdzogaGlkZGVuO1xcbiAgICB0cmFuc2l0aW9uOiB3aWR0aCAwLjJzO1xcbiAgICBjdXJzb3I6IHBvaW50ZXI7XFxufVxcblxcbi5WaWRlb1BsYXllckRlc2t0b3BfdGltZWxpbmVfd3JhcF9fZE5UTHMgLlZpZGVvUGxheWVyRGVza3RvcF90aW1lbGluZV9wYW5lbF9fMTZ5RksgLlZpZGVvUGxheWVyRGVza3RvcF90aW1lbGluZV9zbGlkZXJfX09fRkY1IHtcXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgICBoZWlnaHQ6IDEwMCU7XFxufVxcblxcbi5WaWRlb1BsYXllckRlc2t0b3BfdGltZWxpbmVfd3JhcF9fZE5UTHMgLlZpZGVvUGxheWVyRGVza3RvcF90aW1lbGluZV9wYW5lbF9fMTZ5RksgLlZpZGVvUGxheWVyRGVza3RvcF90aW1lbGluZV9zbGlkZXJfdHJhY2tfX1NnS0xkIHtcXG4gICAgaGVpZ2h0OiAzcHg7XFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIHRvcDogNTAlO1xcbiAgICByaWdodDogMDtcXG4gICAgbWFyZ2luLXRvcDogLTFweDtcXG4gICAgYmFja2dyb3VuZDogI2ZmZjtcXG59XFxuXFxuLlZpZGVvUGxheWVyRGVza3RvcF90aW1lbGluZV93cmFwX19kTlRMcyAuVmlkZW9QbGF5ZXJEZXNrdG9wX3RpbWVsaW5lX3BhbmVsX18xNnlGSyAuVmlkZW9QbGF5ZXJEZXNrdG9wX3RpbWVsaW5lX3NsaWRlcl9wcm9ncmVzc19fRDdzQUYge1xcbiAgICBoZWlnaHQ6IDEwMCU7XFxuICAgIHdpZHRoOiA1MCU7XFxuICAgIGJhY2tncm91bmQ6IHJlZDtcXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbn1cXG5cXG4uVmlkZW9QbGF5ZXJEZXNrdG9wX3RpbWVsaW5lX3dyYXBfX2ROVExzOmhvdmVyIC5WaWRlb1BsYXllckRlc2t0b3BfdGltZWxpbmVfcGFuZWxfXzE2eUZLIC5WaWRlb1BsYXllckRlc2t0b3BfdGltZWxpbmVfc2xpZGVyX2hhbmRsZV9fbGpZaUsge1xcbiAgICBoZWlnaHQ6IDEycHg7XFxuICAgIHdpZHRoOiAxMnB4O1xcbiAgICBib3JkZXItcmFkaXVzOiAxMDBweDtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICB0b3A6IC01cHg7XFxuICAgIHJpZ2h0OiAwO1xcbiAgICBiYWNrZ3JvdW5kOiB3aGl0ZTtcXG59XFxuXFxuXFxuLyogc2V0dGluZ3MgcG9wdXAgKi9cXG4uVmlkZW9QbGF5ZXJEZXNrdG9wX3NldHRpbmdzX3BvcHVwX19mSExUMyB7XFxuICAgIHotaW5kZXg6IDEwMTtcXG4gICAgcmlnaHQ6IDIwcHg7XFxuICAgIGJvdHRvbTogMTAwcHg7XFxuICAgIHBhZGRpbmc6IDEwcHggMjBweCAxMHB4IDIwcHg7XFxuICAgIHdpZHRoOiAzMDBweDtcXG4gICAgaGVpZ2h0OiAxMDBweDtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICBvdmVyZmxvdzogaGlkZGVuO1xcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XFxuICAgIGJvcmRlci1yYWRpdXM6IDEwcHg7XFxuICAgIGJhY2tncm91bmQ6IHJnYmEoMjgsIDI4LCAyOCwgLjkpO1xcbiAgICB0ZXh0LXNoYWRvdzogMCAwIDJweCByZ2IoMCAwIDAgLyA1MCUpO1xcbiAgICBkaXNwbGF5OiBub25lO1xcbiAgICAtd2Via2l0LWFuaW1hdGlvbjogVmlkZW9QbGF5ZXJEZXNrdG9wX3Nob3dfc2V0dGluZ3NfXzdLa0pHIC41cyBlYXNlLWluLW91dDtcXG4gICAgICAgICAgICBhbmltYXRpb246IFZpZGVvUGxheWVyRGVza3RvcF9zaG93X3NldHRpbmdzX183S2tKRyAuNXMgZWFzZS1pbi1vdXQ7XFxuICAgIHRyYW5zaXRpb246IGhlaWdodCAwLjVzO1xcbn1cXG5cXG4uVmlkZW9QbGF5ZXJEZXNrdG9wX3NldHRpbmdzX3BvcHVwX3Nob3dfX05FcnNVIHtcXG4gICAgaGVpZ2h0OiAyNTBweDtcXG59XFxuXFxuQC13ZWJraXQta2V5ZnJhbWVzIFZpZGVvUGxheWVyRGVza3RvcF9zaG93X3NldHRpbmdzX183S2tKRyB7XFxuXFxuICAgIDAlIHtcXG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDAlO1xcbiAgICAgICAgdHJhbnNmb3JtOiBzY2FsZSgwKTtcXG4gICAgICAgIG9wYWNpdHk6IDA7XFxuICAgIH1cXG5cXG4gICAgMTAwJSB7XFxuICAgICAgICBib3JkZXItcmFkaXVzOiAxMHB4O1xcbiAgICAgICAgdHJhbnNmb3JtOiBzY2FsZSgxKTtcXG4gICAgICAgIG9wYWNpdHk6IDE7XFxuICAgIH1cXG59XFxuXFxuQGtleWZyYW1lcyBWaWRlb1BsYXllckRlc2t0b3Bfc2hvd19zZXR0aW5nc19fN0trSkcge1xcblxcbiAgICAwJSB7XFxuICAgICAgICBib3JkZXItcmFkaXVzOiAwJTtcXG4gICAgICAgIHRyYW5zZm9ybTogc2NhbGUoMCk7XFxuICAgICAgICBvcGFjaXR5OiAwO1xcbiAgICB9XFxuXFxuICAgIDEwMCUge1xcbiAgICAgICAgYm9yZGVyLXJhZGl1czogMTBweDtcXG4gICAgICAgIHRyYW5zZm9ybTogc2NhbGUoMSk7XFxuICAgICAgICBvcGFjaXR5OiAxO1xcbiAgICB9XFxufVxcblxcbi5WaWRlb1BsYXllckRlc2t0b3Bfc2V0dGluZ3NfaXRlbV9fSEkyOWkge1xcbiAgICBoZWlnaHQ6IC13ZWJraXQtZml0LWNvbnRlbnQ7XFxuICAgIGhlaWdodDogLW1vei1maXQtY29udGVudDtcXG4gICAgaGVpZ2h0OiBmaXQtY29udGVudDtcXG4gICAgcGFkZGluZzogNXB4O1xcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgICBnYXA6IDVweDtcXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAgYmFja2dyb3VuZC1yZXBlYXQ6IG5vLXJlcGVhdDtcXG4gICAgYmFja2dyb3VuZC1wb3NpdGlvbjogcmlnaHQgY2VudGVyO1xcbiAgICBiYWNrZ3JvdW5kLXNpemU6IDMycHggMzJweDtcXG4gICAgLW1vei1iYWNrZ3JvdW5kLXNpemU6IDMycHggMzJweDtcXG4gICAgLXdlYmtpdC1iYWNrZ3JvdW5kLXNpemU6IDMycHggMzJweDtcXG4gICAgYmFja2dyb3VuZC1pbWFnZTogdXJsKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlIZHBaSFJvUFNJeE1EQWxJaUJvWldsbmFIUTlJakV3TUNVaUlIWnBaWGRDYjNnOUlqQWdNQ0F6TWlBek1pSWdkbVZ5YzJsdmJqMGlNUzR4SWo0OGNHRjBhQ0JrUFNKdElERXlMalU1TERJd0xqTTBJRFF1TlRnc0xUUXVOVGtnTFRRdU5UZ3NMVFF1TlRrZ01TNDBNU3d0TVM0ME1TQTJMRFlnTFRZc05pQjZJaUJtYVd4c1BTSWpabVptSWlBdlBqd3ZjM1puUGc9PSk7XFxufVxcblxcbi5WaWRlb1BsYXllckRlc2t0b3BfY2VudGVyX29uX3NjcmVlbl9fbHZhQUIge1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIHRvcDogNTAlO1xcbiAgICBsZWZ0OiA1MCU7XFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlKC01MCUsIC01MCUpO1xcbn1cIiwgXCJcIix7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCJ3ZWJwYWNrOi8vc3JjL2NvbXBvbmVudHMvVmlkZW9QbGF5ZXIvVmlkZW9QbGF5ZXJEZXNrdG9wLm1vZHVsZS5jc3NcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIkFBQUE7SUFDSSxnQkFBZ0I7SUFDaEIsbUJBQW1CO0lBQ25CLFdBQVc7SUFDWCxpQkFBaUI7SUFDakIsa0JBQWtCO0lBQ2xCLGFBQWE7SUFDYix1QkFBdUI7SUFDdkIseUJBQXlCO0lBQ3pCLFVBQVU7QUFDZDs7QUFFQTtJQUNJLGdCQUFnQjtJQUNoQixrQkFBa0I7SUFDbEIsYUFBYTtJQUNiLG1CQUFtQjtJQUNuQix1QkFBdUI7SUFDdkIsTUFBTTtJQUNOLE9BQU87SUFDUCxXQUFXO0lBQ1gsWUFBWTtJQUNaLG9DQUFvQztJQUNwQyxVQUFVO0FBQ2Q7O0FBRUE7O0lBRUksWUFBWTtJQUNaLFdBQVc7QUFDZjs7QUFFQTtJQUNJLGtCQUFrQjtJQUNsQixTQUFTO0lBQ1QsV0FBVztJQUNYLGFBQWE7SUFDYiw0QkFBNEI7SUFDNUIsWUFBWTtJQUNaLFVBQVU7SUFDVixxQ0FBcUM7QUFDekM7O0FBRUE7SUFDSSxXQUFXO0lBQ1gsa0JBQWtCO0lBQ2xCLE1BQU07SUFDTixPQUFPO0lBQ1AsV0FBVztJQUNYLFlBQVk7SUFDWixvRUFBb0U7SUFDcEUsNEJBQTRCO0lBQzVCLG9CQUFvQjtJQUNwQixXQUFXO0FBQ2Y7OztBQUdBO0lBQ0ksYUFBYTtJQUNiLHNCQUFzQjtBQUMxQjs7O0FBR0E7OztJQUdJLFVBQVU7QUFDZDs7QUFFQTtJQUNJLFVBQVU7QUFDZDs7QUFFQTtJQUNJLHFCQUFxQjtBQUN6Qjs7QUFFQTtJQUNJLGtCQUFrQjtJQUNsQixTQUFTO0lBQ1QsVUFBVTtJQUNWLFdBQVc7SUFDWCxZQUFZO0lBQ1osa0JBQWtCO0lBQ2xCLHlCQUF5QjtJQUN6QixhQUFhO0lBQ2IsdUJBQXVCO0lB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UUFDbkIsVUFBVTtJQUNkO0FBQ0o7O0FBYkE7O0lBRUk7UUFDSSxpQkFBaUI7UUFDakIsbUJBQW1CO1FBQ25CLFVBQVU7SUFDZDs7SUFFQTtRQUNJLG1CQUFtQjtRQUNuQixtQkFBbUI7UUFDbkIsVUFBVTtJQUNkO0FBQ0o7O0FBRUE7SUFDSSwyQkFBbUI7SUFBbkIsd0JBQW1CO0lBQW5CLG1CQUFtQjtJQUNuQixZQUFZO0lBQ1osbUJBQW1CO0lBQ25CLFFBQVE7SUFDUixhQUFhO0lBQ2IsNEJBQTRCO0lBQzVCLGlDQUFpQztJQUNqQywwQkFBMEI7SUFDMUIsK0JBQStCO0lBQy9CLGtDQUFrQztJQUNsQyxpVEFBaVQ7QUFDclQ7O0FBRUE7SUFDSSxrQkFBa0I7SUFDbEIsUUFBUTtJQUNSLFNBQVM7SUFDVCxnQ0FBZ0M7QUFDcENcIixcInNvdXJjZXNDb250ZW50XCI6W1wiLnZpZGVvX3dyYXBwZXIge1xcbiAgICBvdmVyZmxvdzogaGlkZGVuO1xcbiAgICBib3JkZXItcmFkaXVzOiAyMHB4O1xcbiAgICB3aWR0aDogMTAwJTtcXG4gICAgbWF4LXdpZHRoOiAxMDAwcHg7XFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxuICAgIC8qIG1hcmdpbi1pbmxpbmU6IGF1dG87ICovXFxuICAgIHotaW5kZXg6IDE7XFxufVxcblxcbi50aGVhdGVyX21vZGUge1xcbiAgICBvdmVyZmxvdzogaGlkZGVuO1xcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGJvcmRlci1yYWRpdXM6IDIwcHg7XFxuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcbiAgICB0b3A6IDA7XFxuICAgIGxlZnQ6IDA7XFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgICBoZWlnaHQ6IGF1dG87XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMCwgMCwgMCwgMC41KTtcXG4gICAgei1pbmRleDogMTtcXG59XFxuXFxuLnZpZGVvIHtcXG5cXG4gICAgaGVpZ2h0OiAxMDAlO1xcbiAgICB3aWR0aDogMTAwJTtcXG59XFxuXFxuLmNvbnRyb2xzX3dyYXBwZXIge1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIGJvdHRvbTogMDtcXG4gICAgd2lkdGg6IDEwMCU7XFxuICAgIHBhZGRpbmc6IDEwcHg7XFxuICAgIGJvcmRlci1yYWRpdXM6IDIwcHggMjBweCAwIDA7XFxuICAgIHotaW5kZXg6IDEwMDtcXG4gICAgb3BhY2l0eTogMDtcXG4gICAgdHJhbnNpdGlvbjogb3BhY2l0eSAxNTBtcyBlYXNlLWluLW91dDtcXG59XFxuXFxuLmNvbnRyb2xzX3dyYXBwZXI6OmJlZm9yZSB7XFxuICAgIGNvbnRlbnQ6IFxcXCJcXFwiO1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIHRvcDogMDtcXG4gICAgbGVmdDogMDtcXG4gICAgd2lkdGg6IDEwMCU7XFxuICAgIGhlaWdodDogMTAwJTtcXG4gICAgYmFja2dyb3VuZDogbGluZWFyLWdyYWRpZW50KHRvIHRvcCwgcmdiYSgwLCAwLCAwLCAuNzUpLCB0cmFuc3BhcmVudCk7XFxuICAgIGJvcmRlci1yYWRpdXM6IDIwcHggMjBweCAwIDA7XFxuICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xcbiAgICB6LWluZGV4OiAtMTtcXG59XFxuXFxuXFxuLmNvbnRyb2xzIHtcXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG59XFxuXFxuXFxuLnZpZGVvX3dyYXBwZXI6aG92ZXIgLmNvbnRyb2xzX3dyYXBwZXIsXFxuLnZpZGVvX3dyYXBwZXI6Zm9jdXMtd2l0aGluIC5jb250cm9sc193cmFwcGVyLFxcbi50aGVhdGVyX21vZGU6aG92ZXIgLmNvbnRyb2xzX3dyYXBwZXIge1xcbiAgICBvcGFjaXR5OiAxO1xcbn1cXG5cXG4uc2hvd19jb250cm9scyB7XFxuICAgIG9wYWNpdHk6IDE7XFxufVxcblxcbi5oaWRlX2NvbnRyb2xzIHtcXG4gICAgb3BhY2l0eTogMCAhaW1wb3J0YW50O1xcbn1cXG5cXG4ucGxheWluZ19hZF93cmFwcGVyIHtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICB0b3A6IDEwcHg7XFxuICAgIGxlZnQ6IDEwcHg7XFxuICAgIHdpZHRoOiA1MHB4O1xcbiAgICBoZWlnaHQ6IDI1cHg7XFxuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI2ZiYzAyZDtcXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICAgIGJvcmRlci1yYWRpdXM6IDhweDtcXG59XFxuXFxuXFxuXFxuLmJvdHRvbV9jb250cm9scyB7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGZsZXgtZGlyZWN0aW9uOiByb3c7XFxuICAgIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcXG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gICAgcGFkZGluZzogMTBweDtcXG4gICAgYm9yZGVyLXJhZGl1czogMCAwIDIwcHggMjBweDtcXG59XFxuXFxuLmNvbnRyb2xzX2xlZnQge1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICBmbGV4LWRpcmVjdGlvbjogcm93O1xcbiAgICBnYXA6IDIwcHg7XFxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxufVxcblxcbi5jb250cm9sc19yaWdodCB7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGZsZXgtZGlyZWN0aW9uOiByb3c7XFxuICAgIGdhcDogMjBweDtcXG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG59XFxuXFxuXFxuLyogVm9sdW1lIFdyYXBwZXIgKi9cXG5cXG4udm9sdW1lX3dyYXAge1xcbiAgICBwYWRkaW5nOiAwIDEwcHggMCAwO1xcbiAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxufVxcblxcbi52b2x1bWVfYnRuIHtcXG4gICAgZmxvYXQ6IGxlZnQ7XFxufVxcblxcbi52b2x1bWVfd3JhcCB7XFxuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbn1cXG5cXG4udm9sdW1lX3dyYXAgI3ZvbHVtZSB7XFxuICAgIGZsb2F0OiBsZWZ0O1xcbn1cXG5cXG4udm9sdW1lX3dyYXAudm9sdW1lX3Nob3cgYnV0dG9uIHtcXG4gICAgY29sb3I6IHdoaXRlO1xcbn1cXG5cXG4udm9sdW1lX3dyYXAudm9sdW1lX3Nob3cgLnZvbHVtZV9wYW5lbCB7XFxuICAgIHdpZHRoOiA3M3B4O1xcbn1cXG5cXG4udm9sdW1lX3dyYXAgLnZvbHVtZV9wYW5lbCB7XFxuICAgIGZsb2F0OiBsZWZ0O1xcbiAgICBoZWlnaHQ6IDQwcHg7XFxuICAgIHdpZHRoOiAwO1xcbiAgICBvdmVyZmxvdzogaGlkZGVuO1xcbiAgICB0cmFuc2l0aW9uOiB3aWR0aCAwLjJzO1xcbiAgICBjdXJzb3I6IHBvaW50ZXI7XFxufVxcblxcbi52b2x1bWVfd3JhcCAudm9sdW1lX3BhbmVsIC52b2x1bWVfc2xpZGVyIHtcXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgICBoZWlnaHQ6IDEwMCU7XFxufVxcblxcbi52b2x1bWVfd3JhcCAudm9sdW1lX3BhbmVsIC52b2x1bWVfc2xpZGVyX3RyYWNrIHtcXG4gICAgaGVpZ2h0OiAzcHg7XFxuICAgIHdpZHRoOiA3MHB4O1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIHRvcDogNTAlO1xcbiAgICByaWdodDogMDtcXG4gICAgbWFyZ2luLXRvcDogLTFweDtcXG4gICAgYmFja2dyb3VuZDogZ3JheTtcXG59XFxuXFxuLnZvbHVtZV93cmFwIC52b2x1bWVfcGFuZWwgLnZvbHVtZV9zbGlkZXJfcHJvZ3Jlc3Mge1xcbiAgICBoZWlnaHQ6IDEwMCU7XFxuICAgIHdpZHRoOiA1MCU7XFxuICAgIGJhY2tncm91bmQ6IHJlZDtcXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbn1cXG5cXG4udm9sdW1lX3dyYXAgLnZvbHVtZV9wYW5lbCAudm9sdW1lX3NsaWRlcl9oYW5kbGUge1xcbiAgICBoZWlnaHQ6IDEycHg7XFxuICAgIHdpZHRoOiAzcHg7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgdG9wOiAtNXB4O1xcbiAgICByaWdodDogMDtcXG4gICAgYmFja2dyb3VuZDogd2hpdGU7XFxufVxcblxcblxcbi5jdXJyZW50X3F1YWxpdHkge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1wcmltYXJ5LWNvbG9yKTtcXG4gICAgcGFkZGluZy1sZWZ0OiA1cHg7XFxuICAgIHBhZGRpbmctcmlnaHQ6IDVweDtcXG4gICAgYm9yZGVyLXJhZGl1czogNXB4O1xcbiAgICBvcGFjaXR5OiAxO1xcbiAgICB0cmFuc2l0aW9uOiBvcGFjaXR5IDE1MG1zIGVhc2UtaW4tb3V0O1xcblxcbn1cXG5cXG5cXG4vKiBEdXJhdGlvbiBXcmFwcGVyICovXFxuLmR1cmF0aW9uIHtcXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAgZmxleC1kaXJlY3Rpb246IHJvdztcXG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICAgIGdhcDogM3B4O1xcbn1cXG5cXG4vKiBCdXR0b25zICovXFxuXFxuLmJ0biB7XFxuICAgIHdpZHRoOiAyNHB4O1xcbiAgICBoZWlnaHQ6IDI0cHg7XFxuICAgIGN1cnNvcjogcG9pbnRlcjtcXG59XFxuXFxuLnBhdXNlX3BsYXlfYnRuIHtcXG4gICAgY3Vyc29yOiBwb2ludGVyO1xcbn1cXG5cXG4uc2V0dGluZ3NfYnRuIHtcXG4gICAgdHJhbnNpdGlvbjogYWxsIDAuMnMgZWFzZS1pbi1vdXQ7XFxufVxcblxcbi8qIFRpbWVsaW5lICovXFxuXFxuLnRpbWVsaW5lX3dyYXAge1xcbiAgICB3aWR0aDogMTAwJTtcXG59XFxuXFxuLnRpbWVsaW5lX3dyYXAge1xcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gICAgZGlzcGxheTogZmxleDtcXG59XFxuXFxuLnRpbWVsaW5lX3dyYXAudGltZWxpbmVfc2hvdyBidXR0b24ge1xcbiAgICBjb2xvcjogd2hpdGU7XFxufVxcblxcbi50aW1lbGluZV93cmFwLnRpbWVsaW5lX3Nob3cgLnRpbWVsaW5lX3BhbmVsIHtcXG4gICAgd2lkdGg6IDEwMCU7XFxufVxcblxcbi50aW1lbGluZV93cmFwIC50aW1lbGluZV9wYW5lbCB7XFxuICAgIGhlaWdodDogMjBweDtcXG4gICAgd2lkdGg6IDEwMCU7XFxuICAgIG92ZXJmbG93OiBoaWRkZW47XFxuICAgIHRyYW5zaXRpb246IHdpZHRoIDAuMnM7XFxuICAgIGN1cnNvcjogcG9pbnRlcjtcXG59XFxuXFxuLnRpbWVsaW5lX3dyYXAgLnRpbWVsaW5lX3BhbmVsIC50aW1lbGluZV9zbGlkZXIge1xcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICAgIGhlaWdodDogMTAwJTtcXG59XFxuXFxuLnRpbWVsaW5lX3dyYXAgLnRpbWVsaW5lX3BhbmVsIC50aW1lbGluZV9zbGlkZXJfdHJhY2sge1xcbiAgICBoZWlnaHQ6IDNweDtcXG4gICAgd2lkdGg6IDEwMCU7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgdG9wOiA1MCU7XFxuICAgIHJpZ2h0OiAwO1xcbiAgICBtYXJnaW4tdG9wOiAtMXB4O1xcbiAgICBiYWNrZ3JvdW5kOiAjZmZmO1xcbn1cXG5cXG4udGltZWxpbmVfd3JhcCAudGltZWxpbmVfcGFuZWwgLnRpbWVsaW5lX3NsaWRlcl9wcm9ncmVzcyB7XFxuICAgIGhlaWdodDogMTAwJTtcXG4gICAgd2lkdGg6IDUwJTtcXG4gICAgYmFja2dyb3VuZDogcmVkO1xcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XFxufVxcblxcbi50aW1lbGluZV93cmFwOmhvdmVyIC50aW1lbGluZV9wYW5lbCAudGltZWxpbmVfc2xpZGVyX2hhbmRsZSB7XFxuICAgIGhlaWdodDogMTJweDtcXG4gICAgd2lkdGg6IDEycHg7XFxuICAgIGJvcmRlci1yYWRpdXM6IDEwMHB4O1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIHRvcDogLTVweDtcXG4gICAgcmlnaHQ6IDA7XFxuICAgIGJhY2tncm91bmQ6IHdoaXRlO1xcbn1cXG5cXG5cXG4vKiBzZXR0aW5ncyBwb3B1cCAqL1xcbi5zZXR0aW5nc19wb3B1cCB7XFxuICAgIHotaW5kZXg6IDEwMTtcXG4gICAgcmlnaHQ6IDIwcHg7XFxuICAgIGJvdHRvbTogMTAwcHg7XFxuICAgIHBhZGRpbmc6IDEwcHggMjBweCAxMHB4IDIwcHg7XFxuICAgIHdpZHRoOiAzMDBweDtcXG4gICAgaGVpZ2h0OiAxMDBweDtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICBvdmVyZmxvdzogaGlkZGVuO1xcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XFxuICAgIGJvcmRlci1yYWRpdXM6IDEwcHg7XFxuICAgIGJhY2tncm91bmQ6IHJnYmEoMjgsIDI4LCAyOCwgLjkpO1xcbiAgICB0ZXh0LXNoYWRvdzogMCAwIDJweCByZ2IoMCAwIDAgLyA1MCUpO1xcbiAgICBkaXNwbGF5OiBub25lO1xcbiAgICBhbmltYXRpb246IHNob3dfc2V0dGluZ3MgLjVzIGVhc2UtaW4tb3V0O1xcbiAgICB0cmFuc2l0aW9uOiBoZWlnaHQgMC41cztcXG59XFxuXFxuLnNldHRpbmdzX3BvcHVwX3Nob3cge1xcbiAgICBoZWlnaHQ6IDI1MHB4O1xcbn1cXG5cXG5Aa2V5ZnJhbWVzIHNob3dfc2V0dGluZ3Mge1xcblxcbiAgICAwJSB7XFxuICAgICAgICBib3JkZXItcmFkaXVzOiAwJTtcXG4gICAgICAgIHRyYW5zZm9ybTogc2NhbGUoMCk7XFxuICAgICAgICBvcGFjaXR5OiAwO1xcbiAgICB9XFxuXFxuICAgIDEwMCUge1xcbiAgICAgICAgYm9yZGVyLXJhZGl1czogMTBweDtcXG4gICAgICAgIHRyYW5zZm9ybTogc2NhbGUoMSk7XFxuICAgICAgICBvcGFjaXR5OiAxO1xcbiAgICB9XFxufVxcblxcbi5zZXR0aW5nc19pdGVtIHtcXG4gICAgaGVpZ2h0OiBmaXQtY29udGVudDtcXG4gICAgcGFkZGluZzogNXB4O1xcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgICBnYXA6IDVweDtcXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAgYmFja2dyb3VuZC1yZXBlYXQ6IG5vLXJlcGVhdDtcXG4gICAgYmFja2dyb3VuZC1wb3NpdGlvbjogcmlnaHQgY2VudGVyO1xcbiAgICBiYWNrZ3JvdW5kLXNpemU6IDMycHggMzJweDtcXG4gICAgLW1vei1iYWNrZ3JvdW5kLXNpemU6IDMycHggMzJweDtcXG4gICAgLXdlYmtpdC1iYWNrZ3JvdW5kLXNpemU6IDMycHggMzJweDtcXG4gICAgYmFja2dyb3VuZC1pbWFnZTogdXJsKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlIZHBaSFJvUFNJeE1EQWxJaUJvWldsbmFIUTlJakV3TUNVaUlIWnBaWGRDYjNnOUlqQWdNQ0F6TWlBek1pSWdkbVZ5YzJsdmJqMGlNUzR4SWo0OGNHRjBhQ0JrUFNKdElERXlMalU1TERJd0xqTTBJRFF1TlRnc0xUUXVOVGtnTFRRdU5UZ3NMVFF1TlRrZ01TNDBNU3d0TVM0ME1TQTJMRFlnTFRZc05pQjZJaUJtYVd4c1BTSWpabVptSWlBdlBqd3ZjM1puUGc9PSk7XFxufVxcblxcbi5jZW50ZXJfb25fc2NyZWVuIHtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICB0b3A6IDUwJTtcXG4gICAgbGVmdDogNTAlO1xcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgtNTAlLCAtNTAlKTtcXG59XCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG4vLyBFeHBvcnRzXG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5sb2NhbHMgPSB7XG5cdFwidmlkZW9fd3JhcHBlclwiOiBcIlZpZGVvUGxheWVyRGVza3RvcF92aWRlb193cmFwcGVyX194NzNKelwiLFxuXHRcInRoZWF0ZXJfbW9kZVwiOiBcIlZpZGVvUGxheWVyRGVza3RvcF90aGVhdGVyX21vZGVfX2U0dklZXCIsXG5cdFwidmlkZW9cIjogXCJWaWRlb1BsYXllckRlc2t0b3BfdmlkZW9fXzZVb0V4XCIsXG5cdFwiY29udHJvbHNfd3JhcHBlclwiOiBcIlZpZGVvUGxheWVyRGVza3RvcF9jb250cm9sc193cmFwcGVyX190ekJzZ1wiLFxuXHRcImNvbnRyb2xzXCI6IFwiVmlkZW9QbGF5ZXJEZXNrdG9wX2NvbnRyb2xzX19wX0hxTFwiLFxuXHRcInNob3dfY29udHJvbHNcIjogXCJWaWRlb1BsYXllckRlc2t0b3Bfc2hvd19jb250cm9sc19fVmFfQ0lcIixcblx0XCJoaWRlX2NvbnRyb2xzXCI6IFwiVmlkZW9QbGF5ZXJEZXNrdG9wX2hpZGVfY29udHJvbHNfX3c3enZnXCIsXG5cdFwicGxheWluZ19hZF93cmFwcGVyXCI6IFwiVmlkZW9QbGF5ZXJEZXNrdG9wX3BsYXlpbmdfYWRfd3JhcHBlcl9fbGFFYmhcIixcblx0XCJib3R0b21fY29udHJvbHNcIjogXCJWaWRlb1BsYXllckRlc2t0b3BfYm90dG9tX2NvbnRyb2xzX19SMUlUdVwiLFxuXHRcImNvbnRyb2xzX2xlZnRcIjogXCJWaWRlb1BsYXllckRlc2t0b3BfY29udHJvbHNfbGVmdF9fN3RaaFpcIixcblx0XCJjb250cm9sc19yaWdodFwiOiBcIlZpZGVvUGxheWVyRGVza3RvcF9jb250cm9sc19yaWdodF9fYUlHUGdcIixcblx0XCJ2b2x1bWVfd3JhcFwiOiBcIlZpZGVvUGxheWVyRGVza3RvcF92b2x1bWVfd3JhcF9fSTFrR3JcIixcblx0XCJ2b2x1bWVfYnRuXCI6IFwiVmlkZW9QbGF5ZXJEZXNrdG9wX3ZvbHVtZV9idG5fX0pWdGlZXCIsXG5cdFwidm9sdW1lXCI6IFwiVmlkZW9QbGF5ZXJEZXNrdG9wX3ZvbHVtZV9fa2o1VXlcIixcblx0XCJ2b2x1bWVfc2hvd1wiOiBcIlZpZGVvUGxheWVyRGVza3RvcF92b2x1bWVfc2hvd19fWnBrMEpcIixcblx0XCJ2b2x1bWVfcGFuZWxcIjogXCJWaWRlb1BsYXllckRlc2t0b3Bfdm9sdW1lX3BhbmVsX19fMlhfOFwiLFxuXHRcInZvbHVtZV9zbGlkZXJcIjogXCJWaWRlb1BsYXllckRlc2t0b3Bfdm9sdW1lX3NsaWRlcl9fX08xVjJcIixcblx0XCJ2b2x1bWVfc2xpZGVyX3RyYWNrXCI6IFwiVmlkZW9QbGF5ZXJEZXNrdG9wX3ZvbHVtZV9zbGlkZXJfdHJhY2tfX2xzb0JkXCIsXG5cdFwidm9sdW1lX3NsaWRlcl9wcm9ncmVzc1wiOiBcIlZpZGVvUGxheWVyRGVza3RvcF92b2x1bWVfc2xpZGVyX3Byb2dyZXNzX19iUHkyaVwiLFxuXHRcInZvbHVtZV9zbGlkZXJfaGFuZGxlXCI6IFwiVmlkZW9QbGF5ZXJEZXNrdG9wX3ZvbHVtZV9zbGlkZXJfaGFuZGxlX19sc2puWVwiLFxuXHRcImN1cnJlbnRfcXVhbGl0eVwiOiBcIlZpZGVvUGxheWVyRGVza3RvcF9jdXJyZW50X3F1YWxpdHlfX1FRNU9xXCIsXG5cdFwiZHVyYXRpb25cIjogXCJWaWRlb1BsYXllckRlc2t0b3BfZHVyYXRpb25fXzRXR1p0XCIsXG5cdFwiYnRuXCI6IFwiVmlkZW9QbGF5ZXJEZXNrdG9wX2J0bl9fOWkwOW5cIixcblx0XCJwYXVzZV9wbGF5X2J0blwiOiBcIlZpZGVvUGxheWVyRGVza3RvcF9wYXVzZV9wbGF5X2J0bl9fNHVTc2hcIixcblx0XCJzZXR0aW5nc19idG5cIjogXCJWaWRlb1BsYXllckRlc2t0b3Bfc2V0dGluZ3NfYnRuX19ndFpWVVwiLFxuXHRcInRpbWVsaW5lX3dyYXBcIjogXCJWaWRlb1BsYXllckRlc2t0b3BfdGltZWxpbmVfd3JhcF9fZE5UTHNcIixcblx0XCJ0aW1lbGluZV9zaG93XCI6IFwiVmlkZW9QbGF5ZXJEZXNrdG9wX3RpbWVsaW5lX3Nob3dfX2pqak5yXCIsXG5cdFwidGltZWxpbmVfcGFuZWxcIjogXCJWaWRlb1BsYXllckRlc2t0b3BfdGltZWxpbmVfcGFuZWxfXzE2eUZLXCIsXG5cdFwidGltZWxpbmVfc2xpZGVyXCI6IFwiVmlkZW9QbGF5ZXJEZXNrdG9wX3RpbWVsaW5lX3NsaWRlcl9fT19GRjVcIixcblx0XCJ0aW1lbGluZV9zbGlkZXJfdHJhY2tcIjogXCJWaWRlb1BsYXllckRlc2t0b3BfdGltZWxpbmVfc2xpZGVyX3RyYWNrX19TZ0tMZFwiLFxuXHRcInRpbWVsaW5lX3NsaWRlcl9wcm9ncmVzc1wiOiBcIlZpZGVvUGxheWVyRGVza3RvcF90aW1lbGluZV9zbGlkZXJfcHJvZ3Jlc3NfX0Q3c0FGXCIsXG5cdFwidGltZWxpbmVfc2xpZGVyX2hhbmRsZVwiOiBcIlZpZGVvUGxheWVyRGVza3RvcF90aW1lbGluZV9zbGlkZXJfaGFuZGxlX19sallpS1wiLFxuXHRcInNldHRpbmdzX3BvcHVwXCI6IFwiVmlkZW9QbGF5ZXJEZXNrdG9wX3NldHRpbmdzX3BvcHVwX19mSExUM1wiLFxuXHRcInNob3dfc2V0dGluZ3NcIjogXCJWaWRlb1BsYXllckRlc2t0b3Bfc2hvd19zZXR0aW5nc19fN0trSkdcIixcblx0XCJzZXR0aW5nc19wb3B1cF9zaG93XCI6IFwiVmlkZW9QbGF5ZXJEZXNrdG9wX3NldHRpbmdzX3BvcHVwX3Nob3dfX05FcnNVXCIsXG5cdFwic2V0dGluZ3NfaXRlbVwiOiBcIlZpZGVvUGxheWVyRGVza3RvcF9zZXR0aW5nc19pdGVtX19ISTI5aVwiLFxuXHRcImNlbnRlcl9vbl9zY3JlZW5cIjogXCJWaWRlb1BsYXllckRlc2t0b3BfY2VudGVyX29uX3NjcmVlbl9fbHZhQUJcIlxufTtcbm1vZHVsZS5leHBvcnRzID0gX19fQ1NTX0xPQURFUl9FWFBPUlRfX187XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[2]!./src/components/VideoPlayer/VideoPlayerDesktop.module.css\n");

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[2]!./src/components/VideoPlayer/VideoPlayerMobile.module.css":
/*!*********************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[2]!./src/components/VideoPlayer/VideoPlayerMobile.module.css ***!
  \*********************************************************************************************************************************************************************************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("// Imports\nvar ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../../../node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js\");\nvar ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(true);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \".VideoPlayerMobile_video_wrapper__s5DJt {\\n    justify-content: center;\\n    /* border-radius: 10px; */\\n    overflow: hidden;\\n    display: flex;\\n    position: fixed;\\n    width: 100%;\\n    /* height: 100%; */\\n    height: auto;\\n    top: 84px;\\n    left: 0;\\n    right: 0;\\n    background-color: black;\\n    z-index: 100;\\n}\\n\\n.VideoPlayerMobile_touch_resister__szFdR {\\n    position: absolute;\\n    top: 0;\\n    left: 0;\\n    width: 100%;\\n    height: 100%;\\n    background-color: transparent;\\n}\\n\\n.VideoPlayerMobile_video__Rj28T {\\n    width: 100%;\\n    height: 100%;\\n}\\n\\n.VideoPlayerMobile_controls_wrapper__3XWMH {\\n    width: 100%;\\n    height: 100%;\\n}\\n\\n.VideoPlayerMobile_controls__8aega {\\n    opacity: 0;\\n    width: 100%;\\n    height: 100%;\\n    position: absolute;\\n    display: flex;\\n    flex-direction: column;\\n    align-items: center;\\n    padding: 10px;\\n    transition: opacity 150ms ease-in-out;\\n    background-color: rgba(0, 0, 0, 0.5);\\n    /* border-radius: 0 0 20px 20px; */\\n}\\n\\n.VideoPlayerMobile_show_controls__AA43u {\\n    opacity: 1;\\n}\\n\\n/* TOP CONTROLS */\\n.VideoPlayerMobile_top_controls__BbX_2 {\\n    height: 100%;\\n    width: 100%;\\n}\\n\\n.VideoPlayerMobile_settings__yIzLE {\\n    margin-top: 10px;\\n    margin-right: 10px;\\n    float: right;\\n}\\n\\n/* MIDDLE CONTROLS */\\n.VideoPlayerMobile_middle_controls__uWRZJ {\\n    height: 100%;\\n    display: flex;\\n    align-items: center;\\n    justify-content: center;\\n    gap: 30px;\\n\\n}\\n\\n.VideoPlayerMobile_play_pause_btn__abYVi {\\n    font-size: 50px;\\n}\\n\\n.VideoPlayerMobile_skip_previous_btn__3kp_b,\\n.VideoPlayerMobile_skip_next_btn__7G5I0 {\\n    width: 100% !important;\\n    font-size: 40px;\\n}\\n\\n/* BOTTOM CONTROLS */\\n.VideoPlayerMobile_bottom_controls__h0xck {\\n    display: flex;\\n    flex-direction: column;\\n    align-items: flex-end;\\n    width: 100%;\\n    height: 100%;\\n}\\n\\n.VideoPlayerMobile_fullscreen_btn__ox6y0 {\\n    align-self: flex-end;\\n    font-size: 30px;\\n}\\n\\n/* Duration */\\n.VideoPlayerMobile_duration__r7nb5 {\\n    font-size: 15px;\\n    align-self: flex-end;\\n}\\n\\n.VideoPlayerMobile_duration_wrapper__xGw_a {\\n    display: flex;\\n    /* flex-direction: row; */\\n    align-items: center;\\n    justify-content: space-between;\\n    width: 100%;\\n    height: 100%;\\n}\\n\\n.VideoPlayerMobile_duration__r7nb5 {\\n    display: flex;\\n    flex-direction: row;\\n    align-items: flex-end;\\n    gap: 3px;\\n\\n}\\n\\n/* Timeline */\\n\\n.VideoPlayerMobile_timeline_wrap__xFJEw {\\n    width: 100%;\\n}\\n\\n.VideoPlayerMobile_timeline_wrap__xFJEw {\\n    justify-content: center;\\n    align-items: center;\\n    display: flex;\\n}\\n\\n.VideoPlayerMobile_timeline_wrap__xFJEw.VideoPlayerMobile_timeline_show__QCaDn button {\\n    color: white;\\n}\\n\\n.VideoPlayerMobile_timeline_wrap__xFJEw.VideoPlayerMobile_timeline_show__QCaDn .VideoPlayerMobile_timeline_panel__F7Zn0 {\\n    width: 100%;\\n}\\n\\n.VideoPlayerMobile_timeline_wrap__xFJEw .VideoPlayerMobile_timeline_panel__F7Zn0 {\\n    height: 20px;\\n    width: 100%;\\n    overflow: hidden;\\n    transition: width 0.2s;\\n    cursor: pointer;\\n}\\n\\n.VideoPlayerMobile_timeline_wrap__xFJEw .VideoPlayerMobile_timeline_panel__F7Zn0 .VideoPlayerMobile_timeline_slider___E22u {\\n    position: relative;\\n    height: 100%;\\n}\\n\\n.VideoPlayerMobile_timeline_wrap__xFJEw .VideoPlayerMobile_timeline_panel__F7Zn0 .VideoPlayerMobile_timeline_slider_track__Y8jCi {\\n    height: 3px;\\n    width: 100%;\\n    position: absolute;\\n    top: 50%;\\n    right: 0;\\n    margin-top: -1px;\\n    background: #fff;\\n}\\n\\n.VideoPlayerMobile_timeline_wrap__xFJEw .VideoPlayerMobile_timeline_panel__F7Zn0 .VideoPlayerMobile_timeline_slider_progress__PppFO {\\n    height: 100%;\\n    width: 50%;\\n    background: red;\\n    position: relative;\\n}\\n\\n.VideoPlayerMobile_timeline_wrap__xFJEw:hover .VideoPlayerMobile_timeline_panel__F7Zn0 .VideoPlayerMobile_timeline_slider_handle__V2eBT {\\n    height: 12px;\\n    width: 12px;\\n    border-radius: 100px;\\n    position: absolute;\\n    top: -5px;\\n    right: 0;\\n    background: white;\\n}\\n\\n.VideoPlayerMobile_bottom_settings_popup_wrapper__l3KJc {\\n    position: fixed;\\n    bottom: 0;\\n    left: 0;\\n    right: 0;\\n    height: 100%;\\n    width: 100%;\\n    z-index: 100;\\n    background-color: rgba(0, 0, 0, 0.5);\\n}\\n\\n.VideoPlayerMobile_bottom_settings_popup__uhNOD {\\n    position: fixed;\\n    bottom: -1000px;\\n    background-color: var(--divider-color);\\n    border-radius: 10px;\\n    width: 95%;\\n    height: auto;\\n    z-index: 101;\\n    box-shadow: 0px 0px 10px rgba(0, 0, 0, 0.5);\\n    text-align: center;\\n    transition: all .5s;\\n    padding: 10px;\\n}\\n\\n.VideoPlayerMobile_show_setting__TzzlU {\\n    bottom: 10px;\\n}\\n\\n.VideoPlayerMobile_hide_controls__ey37U {\\n    opacity: 0 !important;\\n}\\n\\n.VideoPlayerMobile_unmute_button__39b5t {\\n    padding: 5px;\\n    position: absolute;\\n    top: 10px;\\n    left: 10px;\\n    width: auto;\\n    height: 25px;\\n    text-align: center;\\n    background-color: #fff;\\n    display: flex;\\n    justify-content: center;\\n    align-items: center;\\n    border-radius: 8px;\\n    color: #000;\\n    z-index: 100;\\n}\\n\\n.VideoPlayerMobile_playing_ad_wrapper__tn_B7 {\\n    position: absolute;\\n    top: 10px;\\n    left: 10px;\\n    width: 50px;\\n    height: 25px;\\n    text-align: center;\\n    background-color: #fbc02d;\\n    display: flex;\\n    justify-content: center;\\n    align-items: center;\\n    border-radius: 8px;\\n}\\n\\n.VideoPlayerMobile_current_quality__eRFDY {\\n    justify-content: center;\\n    align-items: center;\\n    display: flex;\\n    margin-left: 5px;\\n    background-color: var(--primary-color);\\n    padding-left: 5px;\\n    padding-right: 5px;\\n    border-radius: 5px;\\n    opacity: 1;\\n    font-size: 15px;\\n    transition: opacity 150ms ease-in-out;\\n}\\n\\n.VideoPlayerMobile_settings_popup_header__P6_jK {\\n    padding: 10px;\\n    justify-content: center;\\n}\\n\\n.VideoPlayerMobile_settings_popup_title__j3Wea {\\n    font-size: 20px;\\n    font-weight: bold;\\n}\\n\\n.VideoPlayerMobile_settings_popup_body_item__PPS2F {\\n    padding: 10px;\\n    display: flex;\\n    width: inherit;\\n    margin: 0px 20px 10px 20px;\\n    background-repeat: no-repeat;\\n    background-position: right center;\\n    background-size: 32px 32px;\\n    -moz-background-size: 32px 32px;\\n    -webkit-background-size: 32px 32px;\\n    background-image: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMDAlIiBoZWlnaHQ9IjEwMCUiIHZpZXdCb3g9IjAgMCAzMiAzMiIgdmVyc2lvbj0iMS4xIj48cGF0aCBkPSJtIDEyLjU5LDIwLjM0IDQuNTgsLTQuNTkgLTQuNTgsLTQuNTkgMS40MSwtMS40MSA2LDYgLTYsNiB6IiBmaWxsPSIjZmZmIiAvPjwvc3ZnPg==);\\n\\n}\\n\\n.VideoPlayerMobile_settings_popup_body_item_text__4Z6fU {\\n    display: flex;\\n    font-size: 20px;\\n}\\n\\n.VideoPlayerMobile_settings_popup_body_item_icon__OELHx {\\n    font-size: 25px;\\n    margin-right: 10px;\\n}\\n\\n.VideoPlayerMobile_developer_text__1T5Yb {\\n    position: absolute;\\n    bottom: 0;\\n    left: 0;\\n    right: 0;\\n    padding: 20px;\\n}\", \"\",{\"version\":3,\"sources\":[\"webpack://src/components/VideoPlayer/VideoPlayerMobile.module.css\"],\"names\":[],\"mappings\":\"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\",\"sourcesContent\":[\".video_wrapper {\\n    justify-content: center;\\n    /* border-radius: 10px; */\\n    overflow: hidden;\\n    display: flex;\\n    position: fixed;\\n    width: 100%;\\n    /* height: 100%; */\\n    height: auto;\\n    top: 84px;\\n    left: 0;\\n    right: 0;\\n    background-color: black;\\n    z-index: 100;\\n}\\n\\n.touch_resister {\\n    position: absolute;\\n    top: 0;\\n    left: 0;\\n    width: 100%;\\n    height: 100%;\\n    background-color: transparent;\\n}\\n\\n.video {\\n    width: 100%;\\n    height: 100%;\\n}\\n\\n.controls_wrapper {\\n    width: 100%;\\n    height: 100%;\\n}\\n\\n.controls {\\n    opacity: 0;\\n    width: 100%;\\n    height: 100%;\\n    position: absolute;\\n    display: flex;\\n    flex-direction: column;\\n    align-items: center;\\n    padding: 10px;\\n    transition: opacity 150ms ease-in-out;\\n    background-color: rgba(0, 0, 0, 0.5);\\n    /* border-radius: 0 0 20px 20px; */\\n}\\n\\n.show_controls {\\n    opacity: 1;\\n}\\n\\n/* TOP CONTROLS */\\n.top_controls {\\n    height: 100%;\\n    width: 100%;\\n}\\n\\n.settings {\\n    margin-top: 10px;\\n    margin-right: 10px;\\n    float: right;\\n}\\n\\n/* MIDDLE CONTROLS */\\n.middle_controls {\\n    height: 100%;\\n    display: flex;\\n    align-items: center;\\n    justify-content: center;\\n    gap: 30px;\\n\\n}\\n\\n.play_pause_btn {\\n    font-size: 50px;\\n}\\n\\n.skip_previous_btn,\\n.skip_next_btn {\\n    width: 100% !important;\\n    font-size: 40px;\\n}\\n\\n/* BOTTOM CONTROLS */\\n.bottom_controls {\\n    display: flex;\\n    flex-direction: column;\\n    align-items: flex-end;\\n    width: 100%;\\n    height: 100%;\\n}\\n\\n.fullscreen_btn {\\n    align-self: flex-end;\\n    font-size: 30px;\\n}\\n\\n/* Duration */\\n.duration {\\n    font-size: 15px;\\n    align-self: flex-end;\\n}\\n\\n.duration_wrapper {\\n    display: flex;\\n    /* flex-direction: row; */\\n    align-items: center;\\n    justify-content: space-between;\\n    width: 100%;\\n    height: 100%;\\n}\\n\\n.duration {\\n    display: flex;\\n    flex-direction: row;\\n    align-items: flex-end;\\n    gap: 3px;\\n\\n}\\n\\n/* Timeline */\\n\\n.timeline_wrap {\\n    width: 100%;\\n}\\n\\n.timeline_wrap {\\n    justify-content: center;\\n    align-items: center;\\n    display: flex;\\n}\\n\\n.timeline_wrap.timeline_show button {\\n    color: white;\\n}\\n\\n.timeline_wrap.timeline_show .timeline_panel {\\n    width: 100%;\\n}\\n\\n.timeline_wrap .timeline_panel {\\n    height: 20px;\\n    width: 100%;\\n    overflow: hidden;\\n    transition: width 0.2s;\\n    cursor: pointer;\\n}\\n\\n.timeline_wrap .timeline_panel .timeline_slider {\\n    position: relative;\\n    height: 100%;\\n}\\n\\n.timeline_wrap .timeline_panel .timeline_slider_track {\\n    height: 3px;\\n    width: 100%;\\n    position: absolute;\\n    top: 50%;\\n    right: 0;\\n    margin-top: -1px;\\n    background: #fff;\\n}\\n\\n.timeline_wrap .timeline_panel .timeline_slider_progress {\\n    height: 100%;\\n    width: 50%;\\n    background: red;\\n    position: relative;\\n}\\n\\n.timeline_wrap:hover .timeline_panel .timeline_slider_handle {\\n    height: 12px;\\n    width: 12px;\\n    border-radius: 100px;\\n    position: absolute;\\n    top: -5px;\\n    right: 0;\\n    background: white;\\n}\\n\\n.bottom_settings_popup_wrapper {\\n    position: fixed;\\n    bottom: 0;\\n    left: 0;\\n    right: 0;\\n    height: 100%;\\n    width: 100%;\\n    z-index: 100;\\n    background-color: rgba(0, 0, 0, 0.5);\\n}\\n\\n.bottom_settings_popup {\\n    position: fixed;\\n    bottom: -1000px;\\n    background-color: var(--divider-color);\\n    border-radius: 10px;\\n    width: 95%;\\n    height: auto;\\n    z-index: 101;\\n    box-shadow: 0px 0px 10px rgba(0, 0, 0, 0.5);\\n    text-align: center;\\n    transition: all .5s;\\n    padding: 10px;\\n}\\n\\n.show_setting {\\n    bottom: 10px;\\n}\\n\\n.hide_controls {\\n    opacity: 0 !important;\\n}\\n\\n.unmute_button {\\n    padding: 5px;\\n    position: absolute;\\n    top: 10px;\\n    left: 10px;\\n    width: auto;\\n    height: 25px;\\n    text-align: center;\\n    background-color: #fff;\\n    display: flex;\\n    justify-content: center;\\n    align-items: center;\\n    border-radius: 8px;\\n    color: #000;\\n    z-index: 100;\\n}\\n\\n.playing_ad_wrapper {\\n    position: absolute;\\n    top: 10px;\\n    left: 10px;\\n    width: 50px;\\n    height: 25px;\\n    text-align: center;\\n    background-color: #fbc02d;\\n    display: flex;\\n    justify-content: center;\\n    align-items: center;\\n    border-radius: 8px;\\n}\\n\\n.current_quality {\\n    justify-content: center;\\n    align-items: center;\\n    display: flex;\\n    margin-left: 5px;\\n    background-color: var(--primary-color);\\n    padding-left: 5px;\\n    padding-right: 5px;\\n    border-radius: 5px;\\n    opacity: 1;\\n    font-size: 15px;\\n    transition: opacity 150ms ease-in-out;\\n}\\n\\n.settings_popup_header {\\n    padding: 10px;\\n    justify-content: center;\\n}\\n\\n.settings_popup_title {\\n    font-size: 20px;\\n    font-weight: bold;\\n}\\n\\n.settings_popup_body_item {\\n    padding: 10px;\\n    display: flex;\\n    width: inherit;\\n    margin: 0px 20px 10px 20px;\\n    background-repeat: no-repeat;\\n    background-position: right center;\\n    background-size: 32px 32px;\\n    -moz-background-size: 32px 32px;\\n    -webkit-background-size: 32px 32px;\\n    background-image: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMDAlIiBoZWlnaHQ9IjEwMCUiIHZpZXdCb3g9IjAgMCAzMiAzMiIgdmVyc2lvbj0iMS4xIj48cGF0aCBkPSJtIDEyLjU5LDIwLjM0IDQuNTgsLTQuNTkgLTQuNTgsLTQuNTkgMS40MSwtMS40MSA2LDYgLTYsNiB6IiBmaWxsPSIjZmZmIiAvPjwvc3ZnPg==);\\n\\n}\\n\\n.settings_popup_body_item_text {\\n    display: flex;\\n    font-size: 20px;\\n}\\n\\n.settings_popup_body_item_icon {\\n    font-size: 25px;\\n    margin-right: 10px;\\n}\\n\\n.developer_text {\\n    position: absolute;\\n    bottom: 0;\\n    left: 0;\\n    right: 0;\\n    padding: 20px;\\n}\"],\"sourceRoot\":\"\"}]);\n// Exports\n___CSS_LOADER_EXPORT___.locals = {\n\t\"video_wrapper\": \"VideoPlayerMobile_video_wrapper__s5DJt\",\n\t\"touch_resister\": \"VideoPlayerMobile_touch_resister__szFdR\",\n\t\"video\": \"VideoPlayerMobile_video__Rj28T\",\n\t\"controls_wrapper\": \"VideoPlayerMobile_controls_wrapper__3XWMH\",\n\t\"controls\": \"VideoPlayerMobile_controls__8aega\",\n\t\"show_controls\": \"VideoPlayerMobile_show_controls__AA43u\",\n\t\"top_controls\": \"VideoPlayerMobile_top_controls__BbX_2\",\n\t\"settings\": \"VideoPlayerMobile_settings__yIzLE\",\n\t\"middle_controls\": \"VideoPlayerMobile_middle_controls__uWRZJ\",\n\t\"play_pause_btn\": \"VideoPlayerMobile_play_pause_btn__abYVi\",\n\t\"skip_previous_btn\": \"VideoPlayerMobile_skip_previous_btn__3kp_b\",\n\t\"skip_next_btn\": \"VideoPlayerMobile_skip_next_btn__7G5I0\",\n\t\"bottom_controls\": \"VideoPlayerMobile_bottom_controls__h0xck\",\n\t\"fullscreen_btn\": \"VideoPlayerMobile_fullscreen_btn__ox6y0\",\n\t\"duration\": \"VideoPlayerMobile_duration__r7nb5\",\n\t\"duration_wrapper\": \"VideoPlayerMobile_duration_wrapper__xGw_a\",\n\t\"timeline_wrap\": \"VideoPlayerMobile_timeline_wrap__xFJEw\",\n\t\"timeline_show\": \"VideoPlayerMobile_timeline_show__QCaDn\",\n\t\"timeline_panel\": \"VideoPlayerMobile_timeline_panel__F7Zn0\",\n\t\"timeline_slider\": \"VideoPlayerMobile_timeline_slider___E22u\",\n\t\"timeline_slider_track\": \"VideoPlayerMobile_timeline_slider_track__Y8jCi\",\n\t\"timeline_slider_progress\": \"VideoPlayerMobile_timeline_slider_progress__PppFO\",\n\t\"timeline_slider_handle\": \"VideoPlayerMobile_timeline_slider_handle__V2eBT\",\n\t\"bottom_settings_popup_wrapper\": \"VideoPlayerMobile_bottom_settings_popup_wrapper__l3KJc\",\n\t\"bottom_settings_popup\": \"VideoPlayerMobile_bottom_settings_popup__uhNOD\",\n\t\"show_setting\": \"VideoPlayerMobile_show_setting__TzzlU\",\n\t\"hide_controls\": \"VideoPlayerMobile_hide_controls__ey37U\",\n\t\"unmute_button\": \"VideoPlayerMobile_unmute_button__39b5t\",\n\t\"playing_ad_wrapper\": \"VideoPlayerMobile_playing_ad_wrapper__tn_B7\",\n\t\"current_quality\": \"VideoPlayerMobile_current_quality__eRFDY\",\n\t\"settings_popup_header\": \"VideoPlayerMobile_settings_popup_header__P6_jK\",\n\t\"settings_popup_title\": \"VideoPlayerMobile_settings_popup_title__j3Wea\",\n\t\"settings_popup_body_item\": \"VideoPlayerMobile_settings_popup_body_item__PPS2F\",\n\t\"settings_popup_body_item_text\": \"VideoPlayerMobile_settings_popup_body_item_text__4Z6fU\",\n\t\"settings_popup_body_item_icon\": \"VideoPlayerMobile_settings_popup_body_item_icon__OELHx\",\n\t\"developer_text\": \"VideoPlayerMobile_developer_text__1T5Yb\"\n};\nmodule.exports = ___CSS_LOADER_EXPORT___;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1szXS5vbmVPZls0XS51c2VbMV0hLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbM10ub25lT2ZbNF0udXNlWzJdIS4vc3JjL2NvbXBvbmVudHMvVmlkZW9QbGF5ZXIvVmlkZW9QbGF5ZXJNb2JpbGUubW9kdWxlLmNzcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGtDQUFrQyxtQkFBTyxDQUFDLHlLQUFxRjtBQUMvSDtBQUNBO0FBQ0EsbUZBQW1GLDhCQUE4Qiw4QkFBOEIseUJBQXlCLG9CQUFvQixzQkFBc0Isa0JBQWtCLHVCQUF1QixxQkFBcUIsZ0JBQWdCLGNBQWMsZUFBZSw4QkFBOEIsbUJBQW1CLEdBQUcsOENBQThDLHlCQUF5QixhQUFhLGNBQWMsa0JBQWtCLG1CQUFtQixvQ0FBb0MsR0FBRyxxQ0FBcUMsa0JBQWtCLG1CQUFtQixHQUFHLGdEQUFnRCxrQkFBa0IsbUJBQW1CLEdBQUcsd0NBQXdDLGlCQUFpQixrQkFBa0IsbUJBQW1CLHlCQUF5QixvQkFBb0IsNkJBQTZCLDBCQUEwQixvQkFBb0IsNENBQTRDLDJDQUEyQyx1Q0FBdUMsS0FBSyw2Q0FBNkMsaUJBQWlCLEdBQUcsZ0VBQWdFLG1CQUFtQixrQkFBa0IsR0FBRyx3Q0FBd0MsdUJBQXVCLHlCQUF5QixtQkFBbUIsR0FBRyxzRUFBc0UsbUJBQW1CLG9CQUFvQiwwQkFBMEIsOEJBQThCLGdCQUFnQixLQUFLLDhDQUE4QyxzQkFBc0IsR0FBRywyRkFBMkYsNkJBQTZCLHNCQUFzQixHQUFHLHNFQUFzRSxvQkFBb0IsNkJBQTZCLDRCQUE0QixrQkFBa0IsbUJBQW1CLEdBQUcsOENBQThDLDJCQUEyQixzQkFBc0IsR0FBRyx3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LG9CQUFvQixtQkFBbUIseUJBQXlCLGdCQUFnQixpQkFBaUIsa0JBQWtCLG1CQUFtQix5QkFBeUIsNkJBQTZCLG9CQUFvQiw4QkFBOEIsMEJBQTBCLHlCQUF5QixrQkFBa0IsbUJBQW1CLEdBQUcseUJBQXlCLHlCQUF5QixnQkFBZ0IsaUJBQWlCLGtCQUFrQixtQkFBbUIseUJBQXlCLGdDQUFnQyxvQkFBb0IsOEJBQThCLDBCQUEwQix5QkFBeUIsR0FBRyxzQkFBc0IsOEJBQThCLDBCQUEwQixvQkFBb0IsdUJBQXVCLDZDQUE2Qyx3QkFBd0IseUJBQXlCLHlCQUF5QixpQkFBaUIsc0JBQXNCLDRDQUE0QyxHQUFHLDRCQUE0QixvQkFBb0IsOEJBQThCLEdBQUcsMkJBQTJCLHNCQUFzQix3QkFBd0IsR0FBRywrQkFBK0Isb0JBQW9CLG9CQUFvQixxQkFBcUIsaUNBQWlDLG1DQUFtQyx3Q0FBd0MsaUNBQWlDLHNDQUFzQyx5Q0FBeUMsK0NBQStDLHlRQUF5USxLQUFLLG9DQUFvQyxvQkFBb0Isc0JBQXNCLEdBQUcsb0NBQW9DLHNCQUFzQix5QkFBeUIsR0FBRyxxQkFBcUIseUJBQXlCLGdCQUFnQixjQUFjLGVBQWUsb0JBQW9CLEdBQUcsbUJBQW1CO0FBQ3RrZTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvY29tcG9uZW50cy9WaWRlb1BsYXllci9WaWRlb1BsYXllck1vYmlsZS5tb2R1bGUuY3NzPzE3YmYiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gSW1wb3J0c1xudmFyIF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyA9IHJlcXVpcmUoXCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9ydW50aW1lL2FwaS5qc1wiKTtcbnZhciBfX19DU1NfTE9BREVSX0VYUE9SVF9fXyA9IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyh0cnVlKTtcbi8vIE1vZHVsZVxuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ucHVzaChbbW9kdWxlLmlkLCBcIi5WaWRlb1BsYXllck1vYmlsZV92aWRlb193cmFwcGVyX19zNURKdCB7XFxuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcbiAgICAvKiBib3JkZXItcmFkaXVzOiAxMHB4OyAqL1xcbiAgICBvdmVyZmxvdzogaGlkZGVuO1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICBwb3NpdGlvbjogZml4ZWQ7XFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgICAvKiBoZWlnaHQ6IDEwMCU7ICovXFxuICAgIGhlaWdodDogYXV0bztcXG4gICAgdG9wOiA4NHB4O1xcbiAgICBsZWZ0OiAwO1xcbiAgICByaWdodDogMDtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogYmxhY2s7XFxuICAgIHotaW5kZXg6IDEwMDtcXG59XFxuXFxuLlZpZGVvUGxheWVyTW9iaWxlX3RvdWNoX3Jlc2lzdGVyX19zekZkUiB7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgdG9wOiAwO1xcbiAgICBsZWZ0OiAwO1xcbiAgICB3aWR0aDogMTAwJTtcXG4gICAgaGVpZ2h0OiAxMDAlO1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcXG59XFxuXFxuLlZpZGVvUGxheWVyTW9iaWxlX3ZpZGVvX19SajI4VCB7XFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgICBoZWlnaHQ6IDEwMCU7XFxufVxcblxcbi5WaWRlb1BsYXllck1vYmlsZV9jb250cm9sc193cmFwcGVyX18zWFdNSCB7XFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgICBoZWlnaHQ6IDEwMCU7XFxufVxcblxcbi5WaWRlb1BsYXllck1vYmlsZV9jb250cm9sc19fOGFlZ2Ege1xcbiAgICBvcGFjaXR5OiAwO1xcbiAgICB3aWR0aDogMTAwJTtcXG4gICAgaGVpZ2h0OiAxMDAlO1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICAgIHBhZGRpbmc6IDEwcHg7XFxuICAgIHRyYW5zaXRpb246IG9wYWNpdHkgMTUwbXMgZWFzZS1pbi1vdXQ7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMCwgMCwgMCwgMC41KTtcXG4gICAgLyogYm9yZGVyLXJhZGl1czogMCAwIDIwcHggMjBweDsgKi9cXG59XFxuXFxuLlZpZGVvUGxheWVyTW9iaWxlX3Nob3dfY29udHJvbHNfX0FBNDN1IHtcXG4gICAgb3BhY2l0eTogMTtcXG59XFxuXFxuLyogVE9QIENPTlRST0xTICovXFxuLlZpZGVvUGxheWVyTW9iaWxlX3RvcF9jb250cm9sc19fQmJYXzIge1xcbiAgICBoZWlnaHQ6IDEwMCU7XFxuICAgIHdpZHRoOiAxMDAlO1xcbn1cXG5cXG4uVmlkZW9QbGF5ZXJNb2JpbGVfc2V0dGluZ3NfX3lJekxFIHtcXG4gICAgbWFyZ2luLXRvcDogMTBweDtcXG4gICAgbWFyZ2luLXJpZ2h0OiAxMHB4O1xcbiAgICBmbG9hdDogcmlnaHQ7XFxufVxcblxcbi8qIE1JRERMRSBDT05UUk9MUyAqL1xcbi5WaWRlb1BsYXllck1vYmlsZV9taWRkbGVfY29udHJvbHNfX3VXUlpKIHtcXG4gICAgaGVpZ2h0OiAxMDAlO1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG4gICAgZ2FwOiAzMHB4O1xcblxcbn1cXG5cXG4uVmlkZW9QbGF5ZXJNb2JpbGVfcGxheV9wYXVzZV9idG5fX2FiWVZpIHtcXG4gICAgZm9udC1zaXplOiA1MHB4O1xcbn1cXG5cXG4uVmlkZW9QbGF5ZXJNb2JpbGVfc2tpcF9wcmV2aW91c19idG5fXzNrcF9iLFxcbi5WaWRlb1BsYXllck1vYmlsZV9za2lwX25leHRfYnRuX183RzVJMCB7XFxuICAgIHdpZHRoOiAxMDAlICFpbXBvcnRhbnQ7XFxuICAgIGZvbnQtc2l6ZTogNDBweDtcXG59XFxuXFxuLyogQk9UVE9NIENPTlRST0xTICovXFxuLlZpZGVvUGxheWVyTW9iaWxlX2JvdHRvbV9jb250cm9sc19faDB4Y2sge1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcbiAgICBhbGlnbi1pdGVtczogZmxleC1lbmQ7XFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgICBoZWlnaHQ6IDEwMCU7XFxufVxcblxcbi5WaWRlb1BsYXllck1vYmlsZV9mdWxsc2NyZWVuX2J0bl9fb3g2eTAge1xcbiAgICBhbGlnbi1zZWxmOiBmbGV4LWVuZDtcXG4gICAgZm9udC1zaXplOiAzMHB4O1xcbn1cXG5cXG4vKiBEdXJhdGlvbiAqL1xcbi5WaWRlb1BsYXllck1vYmlsZV9kdXJhdGlvbl9fcjduYjUge1xcbiAgICBmb250LXNpemU6IDE1cHg7XFxuICAgIGFsaWduLXNlbGY6IGZsZXgtZW5kO1xcbn1cXG5cXG4uVmlkZW9QbGF5ZXJNb2JpbGVfZHVyYXRpb25fd3JhcHBlcl9feEd3X2Ege1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICAvKiBmbGV4LWRpcmVjdGlvbjogcm93OyAqL1xcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgICBoZWlnaHQ6IDEwMCU7XFxufVxcblxcbi5WaWRlb1BsYXllck1vYmlsZV9kdXJhdGlvbl9fcjduYjUge1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICBmbGV4LWRpcmVjdGlvbjogcm93O1xcbiAgICBhbGlnbi1pdGVtczogZmxleC1lbmQ7XFxuICAgIGdhcDogM3B4O1xcblxcbn1cXG5cXG4vKiBUaW1lbGluZSAqL1xcblxcbi5WaWRlb1BsYXllck1vYmlsZV90aW1lbGluZV93cmFwX194RkpFdyB7XFxuICAgIHdpZHRoOiAxMDAlO1xcbn1cXG5cXG4uVmlkZW9QbGF5ZXJNb2JpbGVfdGltZWxpbmVfd3JhcF9feEZKRXcge1xcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gICAgZGlzcGxheTogZmxleDtcXG59XFxuXFxuLlZpZGVvUGxheWVyTW9iaWxlX3RpbWVsaW5lX3dyYXBfX3hGSkV3LlZpZGVvUGxheWVyTW9iaWxlX3RpbWVsaW5lX3Nob3dfX1FDYURuIGJ1dHRvbiB7XFxuICAgIGNvbG9yOiB3aGl0ZTtcXG59XFxuXFxuLlZpZGVvUGxheWVyTW9iaWxlX3RpbWVsaW5lX3dyYXBfX3hGSkV3LlZpZGVvUGxheWVyTW9iaWxlX3RpbWVsaW5lX3Nob3dfX1FDYURuIC5WaWRlb1BsYXllck1vYmlsZV90aW1lbGluZV9wYW5lbF9fRjdabjAge1xcbiAgICB3aWR0aDogMTAwJTtcXG59XFxuXFxuLlZpZGVvUGxheWVyTW9iaWxlX3RpbWVsaW5lX3dyYXBfX3hGSkV3IC5WaWRlb1BsYXllck1vYmlsZV90aW1lbGluZV9wYW5lbF9fRjdabjAge1xcbiAgICBoZWlnaHQ6IDIwcHg7XFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgICBvdmVyZmxvdzogaGlkZGVuO1xcbiAgICB0cmFuc2l0aW9uOiB3aWR0aCAwLjJzO1xcbiAgICBjdXJzb3I6IHBvaW50ZXI7XFxufVxcblxcbi5WaWRlb1BsYXllck1vYmlsZV90aW1lbGluZV93cmFwX194RkpFdyAuVmlkZW9QbGF5ZXJNb2JpbGVfdGltZWxpbmVfcGFuZWxfX0Y3Wm4wIC5WaWRlb1BsYXllck1vYmlsZV90aW1lbGluZV9zbGlkZXJfX19FMjJ1IHtcXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgICBoZWlnaHQ6IDEwMCU7XFxufVxcblxcbi5WaWRlb1BsYXllck1vYmlsZV90aW1lbGluZV93cmFwX194RkpFdyAuVmlkZW9QbGF5ZXJNb2JpbGVfdGltZWxpbmVfcGFuZWxfX0Y3Wm4wIC5WaWRlb1BsYXllck1vYmlsZV90aW1lbGluZV9zbGlkZXJfdHJhY2tfX1k4akNpIHtcXG4gICAgaGVpZ2h0OiAzcHg7XFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIHRvcDogNTAlO1xcbiAgICByaWdodDogMDtcXG4gICAgbWFyZ2luLXRvcDogLTFweDtcXG4gICAgYmFja2dyb3VuZDogI2ZmZjtcXG59XFxuXFxuLlZpZGVvUGxheWVyTW9iaWxlX3RpbWVsaW5lX3dyYXBfX3hGSkV3IC5WaWRlb1BsYXllck1vYmlsZV90aW1lbGluZV9wYW5lbF9fRjdabjAgLlZpZGVvUGxheWVyTW9iaWxlX3RpbWVsaW5lX3NsaWRlcl9wcm9ncmVzc19fUHBwRk8ge1xcbiAgICBoZWlnaHQ6IDEwMCU7XFxuICAgIHdpZHRoOiA1MCU7XFxuICAgIGJhY2tncm91bmQ6IHJlZDtcXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbn1cXG5cXG4uVmlkZW9QbGF5ZXJNb2JpbGVfdGltZWxpbmVfd3JhcF9feEZKRXc6aG92ZXIgLlZpZGVvUGxheWVyTW9iaWxlX3RpbWVsaW5lX3BhbmVsX19GN1puMCAuVmlkZW9QbGF5ZXJNb2JpbGVfdGltZWxpbmVfc2xpZGVyX2hhbmRsZV9fVjJlQlQge1xcbiAgICBoZWlnaHQ6IDEycHg7XFxuICAgIHdpZHRoOiAxMnB4O1xcbiAgICBib3JkZXItcmFkaXVzOiAxMDBweDtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICB0b3A6IC01cHg7XFxuICAgIHJpZ2h0OiAwO1xcbiAgICBiYWNrZ3JvdW5kOiB3aGl0ZTtcXG59XFxuXFxuLlZpZGVvUGxheWVyTW9iaWxlX2JvdHRvbV9zZXR0aW5nc19wb3B1cF93cmFwcGVyX19sM0tKYyB7XFxuICAgIHBvc2l0aW9uOiBmaXhlZDtcXG4gICAgYm90dG9tOiAwO1xcbiAgICBsZWZ0OiAwO1xcbiAgICByaWdodDogMDtcXG4gICAgaGVpZ2h0OiAxMDAlO1xcbiAgICB3aWR0aDogMTAwJTtcXG4gICAgei1pbmRleDogMTAwO1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuNSk7XFxufVxcblxcbi5WaWRlb1BsYXllck1vYmlsZV9ib3R0b21fc2V0dGluZ3NfcG9wdXBfX3VoTk9EIHtcXG4gICAgcG9zaXRpb246IGZpeGVkO1xcbiAgICBib3R0b206IC0xMDAwcHg7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWRpdmlkZXItY29sb3IpO1xcbiAgICBib3JkZXItcmFkaXVzOiAxMHB4O1xcbiAgICB3aWR0aDogOTUlO1xcbiAgICBoZWlnaHQ6IGF1dG87XFxuICAgIHotaW5kZXg6IDEwMTtcXG4gICAgYm94LXNoYWRvdzogMHB4IDBweCAxMHB4IHJnYmEoMCwgMCwgMCwgMC41KTtcXG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xcbiAgICB0cmFuc2l0aW9uOiBhbGwgLjVzO1xcbiAgICBwYWRkaW5nOiAxMHB4O1xcbn1cXG5cXG4uVmlkZW9QbGF5ZXJNb2JpbGVfc2hvd19zZXR0aW5nX19UenpsVSB7XFxuICAgIGJvdHRvbTogMTBweDtcXG59XFxuXFxuLlZpZGVvUGxheWVyTW9iaWxlX2hpZGVfY29udHJvbHNfX2V5MzdVIHtcXG4gICAgb3BhY2l0eTogMCAhaW1wb3J0YW50O1xcbn1cXG5cXG4uVmlkZW9QbGF5ZXJNb2JpbGVfdW5tdXRlX2J1dHRvbl9fMzliNXQge1xcbiAgICBwYWRkaW5nOiA1cHg7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgdG9wOiAxMHB4O1xcbiAgICBsZWZ0OiAxMHB4O1xcbiAgICB3aWR0aDogYXV0bztcXG4gICAgaGVpZ2h0OiAyNXB4O1xcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICNmZmY7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgICBib3JkZXItcmFkaXVzOiA4cHg7XFxuICAgIGNvbG9yOiAjMDAwO1xcbiAgICB6LWluZGV4OiAxMDA7XFxufVxcblxcbi5WaWRlb1BsYXllck1vYmlsZV9wbGF5aW5nX2FkX3dyYXBwZXJfX3RuX0I3IHtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICB0b3A6IDEwcHg7XFxuICAgIGxlZnQ6IDEwcHg7XFxuICAgIHdpZHRoOiA1MHB4O1xcbiAgICBoZWlnaHQ6IDI1cHg7XFxuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI2ZiYzAyZDtcXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICAgIGJvcmRlci1yYWRpdXM6IDhweDtcXG59XFxuXFxuLlZpZGVvUGxheWVyTW9iaWxlX2N1cnJlbnRfcXVhbGl0eV9fZVJGRFkge1xcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAgbWFyZ2luLWxlZnQ6IDVweDtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tcHJpbWFyeS1jb2xvcik7XFxuICAgIHBhZGRpbmctbGVmdDogNXB4O1xcbiAgICBwYWRkaW5nLXJpZ2h0OiA1cHg7XFxuICAgIGJvcmRlci1yYWRpdXM6IDVweDtcXG4gICAgb3BhY2l0eTogMTtcXG4gICAgZm9udC1zaXplOiAxNXB4O1xcbiAgICB0cmFuc2l0aW9uOiBvcGFjaXR5IDE1MG1zIGVhc2UtaW4tb3V0O1xcbn1cXG5cXG4uVmlkZW9QbGF5ZXJNb2JpbGVfc2V0dGluZ3NfcG9wdXBfaGVhZGVyX19QNl9qSyB7XFxuICAgIHBhZGRpbmc6IDEwcHg7XFxuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcbn1cXG5cXG4uVmlkZW9QbGF5ZXJNb2JpbGVfc2V0dGluZ3NfcG9wdXBfdGl0bGVfX2ozV2VhIHtcXG4gICAgZm9udC1zaXplOiAyMHB4O1xcbiAgICBmb250LXdlaWdodDogYm9sZDtcXG59XFxuXFxuLlZpZGVvUGxheWVyTW9iaWxlX3NldHRpbmdzX3BvcHVwX2JvZHlfaXRlbV9fUFBTMkYge1xcbiAgICBwYWRkaW5nOiAxMHB4O1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICB3aWR0aDogaW5oZXJpdDtcXG4gICAgbWFyZ2luOiAwcHggMjBweCAxMHB4IDIwcHg7XFxuICAgIGJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7XFxuICAgIGJhY2tncm91bmQtcG9zaXRpb246IHJpZ2h0IGNlbnRlcjtcXG4gICAgYmFja2dyb3VuZC1zaXplOiAzMnB4IDMycHg7XFxuICAgIC1tb3otYmFja2dyb3VuZC1zaXplOiAzMnB4IDMycHg7XFxuICAgIC13ZWJraXQtYmFja2dyb3VuZC1zaXplOiAzMnB4IDMycHg7XFxuICAgIGJhY2tncm91bmQtaW1hZ2U6IHVybChkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUI0Yld4dWN6MGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY2lJSGRwWkhSb1BTSXhNREFsSWlCb1pXbG5hSFE5SWpFd01DVWlJSFpwWlhkQ2IzZzlJakFnTUNBek1pQXpNaUlnZG1WeWMybHZiajBpTVM0eElqNDhjR0YwYUNCa1BTSnRJREV5TGpVNUxESXdMak0wSURRdU5UZ3NMVFF1TlRrZ0xUUXVOVGdzTFRRdU5Ua2dNUzQwTVN3dE1TNDBNU0EyTERZZ0xUWXNOaUI2SWlCbWFXeHNQU0lqWm1abUlpQXZQand2YzNablBnPT0pO1xcblxcbn1cXG5cXG4uVmlkZW9QbGF5ZXJNb2JpbGVfc2V0dGluZ3NfcG9wdXBfYm9keV9pdGVtX3RleHRfXzRaNmZVIHtcXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAgZm9udC1zaXplOiAyMHB4O1xcbn1cXG5cXG4uVmlkZW9QbGF5ZXJNb2JpbGVfc2V0dGluZ3NfcG9wdXBfYm9keV9pdGVtX2ljb25fX09FTEh4IHtcXG4gICAgZm9udC1zaXplOiAyNXB4O1xcbiAgICBtYXJnaW4tcmlnaHQ6IDEwcHg7XFxufVxcblxcbi5WaWRlb1BsYXllck1vYmlsZV9kZXZlbG9wZXJfdGV4dF9fMVQ1WWIge1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIGJvdHRvbTogMDtcXG4gICAgbGVmdDogMDtcXG4gICAgcmlnaHQ6IDA7XFxuICAgIHBhZGRpbmc6IDIwcHg7XFxufVwiLCBcIlwiLHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIndlYnBhY2s6Ly9zcmMvY29tcG9uZW50cy9WaWRlb1BsYXllci9WaWRlb1BsYXllck1vYmlsZS5tb2R1bGUuY3NzXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCJBQUFBO0lBQ0ksdUJBQXVCO0lBQ3ZCLHlCQUF5QjtJQUN6QixnQkFBZ0I7SUFDaEIsYUFBYTtJQUNiLGVBQWU7SUFDZixXQUFXO0lBQ1gsa0JBQWtCO0lBQ2xCLFlBQVk7SUFDWixTQUFTO0lBQ1QsT0FBTztJQUNQLFFBQVE7SUFDUix1QkFBdUI7SUFDdkIsWUFBWTtBQUNoQjs7QUFFQTtJQUNJLGtCQUFrQjtJQUNsQixNQUFNO0lBQ04sT0FBTztJQUNQLFdBQVc7SUFDWCxZQUFZO0lBQ1osNkJBQTZCO0FBQ2pDOztBQUVBO0lBQ0ksV0FBVztJQUNYLFlBQVk7QUFDaEI7O0FBRUE7SUFDSSxXQUFXO0lBQ1gsWUFBWTtBQUNoQjs7QUFFQTtJQUNJLFVBQVU7SUFDVixXQUFXO0lBQ1gsWUFBWTtJQUNaLGtCQUFrQjtJQUNsQixhQUFhO0lBQ2Isc0JBQXNCO0lBQ3RCLG1CQUFtQjtJQUNuQixhQUFhO0lBQ2IscUNBQXFDO0lBQ3JDLG9DQUFvQztJQUNwQyxrQ0FBa0M7QUFDdEM7O0FBRUE7SUFDSSxVQUFVO0FBQ2Q7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YUFBYTtJQUNiLGFBQWE7SUFDYixjQUFjO0lBQ2QsMEJBQTBCO0lBQzFCLDRCQUE0QjtJQUM1QixpQ0FBaUM7SUFDakMsMEJBQTBCO0lBQzFCLCtCQUErQjtJQUMvQixrQ0FBa0M7SUFDbEMsaVRBQWlUOztBQUVyVDs7QUFFQTtJQUNJLGFBQWE7SUFDYixlQUFlO0FBQ25COztBQUVBO0lBQ0ksZUFBZTtJQUNmLGtCQUFrQjtBQUN0Qjs7QUFFQTtJQUNJLGtCQUFrQjtJQUNsQixTQUFTO0lBQ1QsT0FBTztJQUNQLFFBQVE7SUFDUixhQUFhO0FBQ2pCXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIi52aWRlb193cmFwcGVyIHtcXG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxuICAgIC8qIGJvcmRlci1yYWRpdXM6IDEwcHg7ICovXFxuICAgIG92ZXJmbG93OiBoaWRkZW47XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIHBvc2l0aW9uOiBmaXhlZDtcXG4gICAgd2lkdGg6IDEwMCU7XFxuICAgIC8qIGhlaWdodDogMTAwJTsgKi9cXG4gICAgaGVpZ2h0OiBhdXRvO1xcbiAgICB0b3A6IDg0cHg7XFxuICAgIGxlZnQ6IDA7XFxuICAgIHJpZ2h0OiAwO1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiBibGFjaztcXG4gICAgei1pbmRleDogMTAwO1xcbn1cXG5cXG4udG91Y2hfcmVzaXN0ZXIge1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIHRvcDogMDtcXG4gICAgbGVmdDogMDtcXG4gICAgd2lkdGg6IDEwMCU7XFxuICAgIGhlaWdodDogMTAwJTtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XFxufVxcblxcbi52aWRlbyB7XFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgICBoZWlnaHQ6IDEwMCU7XFxufVxcblxcbi5jb250cm9sc193cmFwcGVyIHtcXG4gICAgd2lkdGg6IDEwMCU7XFxuICAgIGhlaWdodDogMTAwJTtcXG59XFxuXFxuLmNvbnRyb2xzIHtcXG4gICAgb3BhY2l0eTogMDtcXG4gICAgd2lkdGg6IDEwMCU7XFxuICAgIGhlaWdodDogMTAwJTtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgICBwYWRkaW5nOiAxMHB4O1xcbiAgICB0cmFuc2l0aW9uOiBvcGFjaXR5IDE1MG1zIGVhc2UtaW4tb3V0O1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuNSk7XFxuICAgIC8qIGJvcmRlci1yYWRpdXM6IDAgMCAyMHB4IDIwcHg7ICovXFxufVxcblxcbi5zaG93X2NvbnRyb2xzIHtcXG4gICAgb3BhY2l0eTogMTtcXG59XFxuXFxuLyogVE9QIENPTlRST0xTICovXFxuLnRvcF9jb250cm9scyB7XFxuICAgIGhlaWdodDogMTAwJTtcXG4gICAgd2lkdGg6IDEwMCU7XFxufVxcblxcbi5zZXR0aW5ncyB7XFxuICAgIG1hcmdpbi10b3A6IDEwcHg7XFxuICAgIG1hcmdpbi1yaWdodDogMTBweDtcXG4gICAgZmxvYXQ6IHJpZ2h0O1xcbn1cXG5cXG4vKiBNSURETEUgQ09OVFJPTFMgKi9cXG4ubWlkZGxlX2NvbnRyb2xzIHtcXG4gICAgaGVpZ2h0OiAxMDAlO1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG4gICAgZ2FwOiAzMHB4O1xcblxcbn1cXG5cXG4ucGxheV9wYXVzZV9idG4ge1xcbiAgICBmb250LXNpemU6IDUwcHg7XFxufVxcblxcbi5za2lwX3ByZXZpb3VzX2J0bixcXG4uc2tpcF9uZXh0X2J0biB7XFxuICAgIHdpZHRoOiAxMDAlICFpbXBvcnRhbnQ7XFxuICAgIGZvbnQtc2l6ZTogNDBweDtcXG59XFxuXFxuLyogQk9UVE9NIENPTlRST0xTICovXFxuLmJvdHRvbV9jb250cm9scyB7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxuICAgIGFsaWduLWl0ZW1zOiBmbGV4LWVuZDtcXG4gICAgd2lkdGg6IDEwMCU7XFxuICAgIGhlaWdodDogMTAwJTtcXG59XFxuXFxuLmZ1bGxzY3JlZW5fYnRuIHtcXG4gICAgYWxpZ24tc2VsZjogZmxleC1lbmQ7XFxuICAgIGZvbnQtc2l6ZTogMzBweDtcXG59XFxuXFxuLyogRHVyYXRpb24gKi9cXG4uZHVyYXRpb24ge1xcbiAgICBmb250LXNpemU6IDE1cHg7XFxuICAgIGFsaWduLXNlbGY6IGZsZXgtZW5kO1xcbn1cXG5cXG4uZHVyYXRpb25fd3JhcHBlciB7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIC8qIGZsZXgtZGlyZWN0aW9uOiByb3c7ICovXFxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICAgIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcXG4gICAgd2lkdGg6IDEwMCU7XFxuICAgIGhlaWdodDogMTAwJTtcXG59XFxuXFxuLmR1cmF0aW9uIHtcXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAgZmxleC1kaXJlY3Rpb246IHJvdztcXG4gICAgYWxpZ24taXRlbXM6IGZsZXgtZW5kO1xcbiAgICBnYXA6IDNweDtcXG5cXG59XFxuXFxuLyogVGltZWxpbmUgKi9cXG5cXG4udGltZWxpbmVfd3JhcCB7XFxuICAgIHdpZHRoOiAxMDAlO1xcbn1cXG5cXG4udGltZWxpbmVfd3JhcCB7XFxuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbn1cXG5cXG4udGltZWxpbmVfd3JhcC50aW1lbGluZV9zaG93IGJ1dHRvbiB7XFxuICAgIGNvbG9yOiB3aGl0ZTtcXG59XFxuXFxuLnRpbWVsaW5lX3dyYXAudGltZWxpbmVfc2hvdyAudGltZWxpbmVfcGFuZWwge1xcbiAgICB3aWR0aDogMTAwJTtcXG59XFxuXFxuLnRpbWVsaW5lX3dyYXAgLnRpbWVsaW5lX3BhbmVsIHtcXG4gICAgaGVpZ2h0OiAyMHB4O1xcbiAgICB3aWR0aDogMTAwJTtcXG4gICAgb3ZlcmZsb3c6IGhpZGRlbjtcXG4gICAgdHJhbnNpdGlvbjogd2lkdGggMC4ycztcXG4gICAgY3Vyc29yOiBwb2ludGVyO1xcbn1cXG5cXG4udGltZWxpbmVfd3JhcCAudGltZWxpbmVfcGFuZWwgLnRpbWVsaW5lX3NsaWRlciB7XFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gICAgaGVpZ2h0OiAxMDAlO1xcbn1cXG5cXG4udGltZWxpbmVfd3JhcCAudGltZWxpbmVfcGFuZWwgLnRpbWVsaW5lX3NsaWRlcl90cmFjayB7XFxuICAgIGhlaWdodDogM3B4O1xcbiAgICB3aWR0aDogMTAwJTtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICB0b3A6IDUwJTtcXG4gICAgcmlnaHQ6IDA7XFxuICAgIG1hcmdpbi10b3A6IC0xcHg7XFxuICAgIGJhY2tncm91bmQ6ICNmZmY7XFxufVxcblxcbi50aW1lbGluZV93cmFwIC50aW1lbGluZV9wYW5lbCAudGltZWxpbmVfc2xpZGVyX3Byb2dyZXNzIHtcXG4gICAgaGVpZ2h0OiAxMDAlO1xcbiAgICB3aWR0aDogNTAlO1xcbiAgICBiYWNrZ3JvdW5kOiByZWQ7XFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG59XFxuXFxuLnRpbWVsaW5lX3dyYXA6aG92ZXIgLnRpbWVsaW5lX3BhbmVsIC50aW1lbGluZV9zbGlkZXJfaGFuZGxlIHtcXG4gICAgaGVpZ2h0OiAxMnB4O1xcbiAgICB3aWR0aDogMTJweDtcXG4gICAgYm9yZGVyLXJhZGl1czogMTAwcHg7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgdG9wOiAtNXB4O1xcbiAgICByaWdodDogMDtcXG4gICAgYmFja2dyb3VuZDogd2hpdGU7XFxufVxcblxcbi5ib3R0b21fc2V0dGluZ3NfcG9wdXBfd3JhcHBlciB7XFxuICAgIHBvc2l0aW9uOiBmaXhlZDtcXG4gICAgYm90dG9tOiAwO1xcbiAgICBsZWZ0OiAwO1xcbiAgICByaWdodDogMDtcXG4gICAgaGVpZ2h0OiAxMDAlO1xcbiAgICB3aWR0aDogMTAwJTtcXG4gICAgei1pbmRleDogMTAwO1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuNSk7XFxufVxcblxcbi5ib3R0b21fc2V0dGluZ3NfcG9wdXAge1xcbiAgICBwb3NpdGlvbjogZml4ZWQ7XFxuICAgIGJvdHRvbTogLTEwMDBweDtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tZGl2aWRlci1jb2xvcik7XFxuICAgIGJvcmRlci1yYWRpdXM6IDEwcHg7XFxuICAgIHdpZHRoOiA5NSU7XFxuICAgIGhlaWdodDogYXV0bztcXG4gICAgei1pbmRleDogMTAxO1xcbiAgICBib3gtc2hhZG93OiAwcHggMHB4IDEwcHggcmdiYSgwLCAwLCAwLCAwLjUpO1xcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICAgIHRyYW5zaXRpb246IGFsbCAuNXM7XFxuICAgIHBhZGRpbmc6IDEwcHg7XFxufVxcblxcbi5zaG93X3NldHRpbmcge1xcbiAgICBib3R0b206IDEwcHg7XFxufVxcblxcbi5oaWRlX2NvbnRyb2xzIHtcXG4gICAgb3BhY2l0eTogMCAhaW1wb3J0YW50O1xcbn1cXG5cXG4udW5tdXRlX2J1dHRvbiB7XFxuICAgIHBhZGRpbmc6IDVweDtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICB0b3A6IDEwcHg7XFxuICAgIGxlZnQ6IDEwcHg7XFxuICAgIHdpZHRoOiBhdXRvO1xcbiAgICBoZWlnaHQ6IDI1cHg7XFxuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI2ZmZjtcXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICAgIGJvcmRlci1yYWRpdXM6IDhweDtcXG4gICAgY29sb3I6ICMwMDA7XFxuICAgIHotaW5kZXg6IDEwMDtcXG59XFxuXFxuLnBsYXlpbmdfYWRfd3JhcHBlciB7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgdG9wOiAxMHB4O1xcbiAgICBsZWZ0OiAxMHB4O1xcbiAgICB3aWR0aDogNTBweDtcXG4gICAgaGVpZ2h0OiAyNXB4O1xcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICNmYmMwMmQ7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgICBib3JkZXItcmFkaXVzOiA4cHg7XFxufVxcblxcbi5jdXJyZW50X3F1YWxpdHkge1xcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAgbWFyZ2luLWxlZnQ6IDVweDtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tcHJpbWFyeS1jb2xvcik7XFxuICAgIHBhZGRpbmctbGVmdDogNXB4O1xcbiAgICBwYWRkaW5nLXJpZ2h0OiA1cHg7XFxuICAgIGJvcmRlci1yYWRpdXM6IDVweDtcXG4gICAgb3BhY2l0eTogMTtcXG4gICAgZm9udC1zaXplOiAxNXB4O1xcbiAgICB0cmFuc2l0aW9uOiBvcGFjaXR5IDE1MG1zIGVhc2UtaW4tb3V0O1xcbn1cXG5cXG4uc2V0dGluZ3NfcG9wdXBfaGVhZGVyIHtcXG4gICAgcGFkZGluZzogMTBweDtcXG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxufVxcblxcbi5zZXR0aW5nc19wb3B1cF90aXRsZSB7XFxuICAgIGZvbnQtc2l6ZTogMjBweDtcXG4gICAgZm9udC13ZWlnaHQ6IGJvbGQ7XFxufVxcblxcbi5zZXR0aW5nc19wb3B1cF9ib2R5X2l0ZW0ge1xcbiAgICBwYWRkaW5nOiAxMHB4O1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICB3aWR0aDogaW5oZXJpdDtcXG4gICAgbWFyZ2luOiAwcHggMjBweCAxMHB4IDIwcHg7XFxuICAgIGJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7XFxuICAgIGJhY2tncm91bmQtcG9zaXRpb246IHJpZ2h0IGNlbnRlcjtcXG4gICAgYmFja2dyb3VuZC1zaXplOiAzMnB4IDMycHg7XFxuICAgIC1tb3otYmFja2dyb3VuZC1zaXplOiAzMnB4IDMycHg7XFxuICAgIC13ZWJraXQtYmFja2dyb3VuZC1zaXplOiAzMnB4IDMycHg7XFxuICAgIGJhY2tncm91bmQtaW1hZ2U6IHVybChkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUI0Yld4dWN6MGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY2lJSGRwWkhSb1BTSXhNREFsSWlCb1pXbG5hSFE5SWpFd01DVWlJSFpwWlhkQ2IzZzlJakFnTUNBek1pQXpNaUlnZG1WeWMybHZiajBpTVM0eElqNDhjR0YwYUNCa1BTSnRJREV5TGpVNUxESXdMak0wSURRdU5UZ3NMVFF1TlRrZ0xUUXVOVGdzTFRRdU5Ua2dNUzQwTVN3dE1TNDBNU0EyTERZZ0xUWXNOaUI2SWlCbWFXeHNQU0lqWm1abUlpQXZQand2YzNablBnPT0pO1xcblxcbn1cXG5cXG4uc2V0dGluZ3NfcG9wdXBfYm9keV9pdGVtX3RleHQge1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICBmb250LXNpemU6IDIwcHg7XFxufVxcblxcbi5zZXR0aW5nc19wb3B1cF9ib2R5X2l0ZW1faWNvbiB7XFxuICAgIGZvbnQtc2l6ZTogMjVweDtcXG4gICAgbWFyZ2luLXJpZ2h0OiAxMHB4O1xcbn1cXG5cXG4uZGV2ZWxvcGVyX3RleHQge1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIGJvdHRvbTogMDtcXG4gICAgbGVmdDogMDtcXG4gICAgcmlnaHQ6IDA7XFxuICAgIHBhZGRpbmc6IDIwcHg7XFxufVwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuLy8gRXhwb3J0c1xuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ubG9jYWxzID0ge1xuXHRcInZpZGVvX3dyYXBwZXJcIjogXCJWaWRlb1BsYXllck1vYmlsZV92aWRlb193cmFwcGVyX19zNURKdFwiLFxuXHRcInRvdWNoX3Jlc2lzdGVyXCI6IFwiVmlkZW9QbGF5ZXJNb2JpbGVfdG91Y2hfcmVzaXN0ZXJfX3N6RmRSXCIsXG5cdFwidmlkZW9cIjogXCJWaWRlb1BsYXllck1vYmlsZV92aWRlb19fUmoyOFRcIixcblx0XCJjb250cm9sc193cmFwcGVyXCI6IFwiVmlkZW9QbGF5ZXJNb2JpbGVfY29udHJvbHNfd3JhcHBlcl9fM1hXTUhcIixcblx0XCJjb250cm9sc1wiOiBcIlZpZGVvUGxheWVyTW9iaWxlX2NvbnRyb2xzX184YWVnYVwiLFxuXHRcInNob3dfY29udHJvbHNcIjogXCJWaWRlb1BsYXllck1vYmlsZV9zaG93X2NvbnRyb2xzX19BQTQzdVwiLFxuXHRcInRvcF9jb250cm9sc1wiOiBcIlZpZGVvUGxheWVyTW9iaWxlX3RvcF9jb250cm9sc19fQmJYXzJcIixcblx0XCJzZXR0aW5nc1wiOiBcIlZpZGVvUGxheWVyTW9iaWxlX3NldHRpbmdzX195SXpMRVwiLFxuXHRcIm1pZGRsZV9jb250cm9sc1wiOiBcIlZpZGVvUGxheWVyTW9iaWxlX21pZGRsZV9jb250cm9sc19fdVdSWkpcIixcblx0XCJwbGF5X3BhdXNlX2J0blwiOiBcIlZpZGVvUGxheWVyTW9iaWxlX3BsYXlfcGF1c2VfYnRuX19hYllWaVwiLFxuXHRcInNraXBfcHJldmlvdXNfYnRuXCI6IFwiVmlkZW9QbGF5ZXJNb2JpbGVfc2tpcF9wcmV2aW91c19idG5fXzNrcF9iXCIsXG5cdFwic2tpcF9uZXh0X2J0blwiOiBcIlZpZGVvUGxheWVyTW9iaWxlX3NraXBfbmV4dF9idG5fXzdHNUkwXCIsXG5cdFwiYm90dG9tX2NvbnRyb2xzXCI6IFwiVmlkZW9QbGF5ZXJNb2JpbGVfYm90dG9tX2NvbnRyb2xzX19oMHhja1wiLFxuXHRcImZ1bGxzY3JlZW5fYnRuXCI6IFwiVmlkZW9QbGF5ZXJNb2JpbGVfZnVsbHNjcmVlbl9idG5fX294NnkwXCIsXG5cdFwiZHVyYXRpb25cIjogXCJWaWRlb1BsYXllck1vYmlsZV9kdXJhdGlvbl9fcjduYjVcIixcblx0XCJkdXJhdGlvbl93cmFwcGVyXCI6IFwiVmlkZW9QbGF5ZXJNb2JpbGVfZHVyYXRpb25fd3JhcHBlcl9feEd3X2FcIixcblx0XCJ0aW1lbGluZV93cmFwXCI6IFwiVmlkZW9QbGF5ZXJNb2JpbGVfdGltZWxpbmVfd3JhcF9feEZKRXdcIixcblx0XCJ0aW1lbGluZV9zaG93XCI6IFwiVmlkZW9QbGF5ZXJNb2JpbGVfdGltZWxpbmVfc2hvd19fUUNhRG5cIixcblx0XCJ0aW1lbGluZV9wYW5lbFwiOiBcIlZpZGVvUGxheWVyTW9iaWxlX3RpbWVsaW5lX3BhbmVsX19GN1puMFwiLFxuXHRcInRpbWVsaW5lX3NsaWRlclwiOiBcIlZpZGVvUGxheWVyTW9iaWxlX3RpbWVsaW5lX3NsaWRlcl9fX0UyMnVcIixcblx0XCJ0aW1lbGluZV9zbGlkZXJfdHJhY2tcIjogXCJWaWRlb1BsYXllck1vYmlsZV90aW1lbGluZV9zbGlkZXJfdHJhY2tfX1k4akNpXCIsXG5cdFwidGltZWxpbmVfc2xpZGVyX3Byb2dyZXNzXCI6IFwiVmlkZW9QbGF5ZXJNb2JpbGVfdGltZWxpbmVfc2xpZGVyX3Byb2dyZXNzX19QcHBGT1wiLFxuXHRcInRpbWVsaW5lX3NsaWRlcl9oYW5kbGVcIjogXCJWaWRlb1BsYXllck1vYmlsZV90aW1lbGluZV9zbGlkZXJfaGFuZGxlX19WMmVCVFwiLFxuXHRcImJvdHRvbV9zZXR0aW5nc19wb3B1cF93cmFwcGVyXCI6IFwiVmlkZW9QbGF5ZXJNb2JpbGVfYm90dG9tX3NldHRpbmdzX3BvcHVwX3dyYXBwZXJfX2wzS0pjXCIsXG5cdFwiYm90dG9tX3NldHRpbmdzX3BvcHVwXCI6IFwiVmlkZW9QbGF5ZXJNb2JpbGVfYm90dG9tX3NldHRpbmdzX3BvcHVwX191aE5PRFwiLFxuXHRcInNob3dfc2V0dGluZ1wiOiBcIlZpZGVvUGxheWVyTW9iaWxlX3Nob3dfc2V0dGluZ19fVHp6bFVcIixcblx0XCJoaWRlX2NvbnRyb2xzXCI6IFwiVmlkZW9QbGF5ZXJNb2JpbGVfaGlkZV9jb250cm9sc19fZXkzN1VcIixcblx0XCJ1bm11dGVfYnV0dG9uXCI6IFwiVmlkZW9QbGF5ZXJNb2JpbGVfdW5tdXRlX2J1dHRvbl9fMzliNXRcIixcblx0XCJwbGF5aW5nX2FkX3dyYXBwZXJcIjogXCJWaWRlb1BsYXllck1vYmlsZV9wbGF5aW5nX2FkX3dyYXBwZXJfX3RuX0I3XCIsXG5cdFwiY3VycmVudF9xdWFsaXR5XCI6IFwiVmlkZW9QbGF5ZXJNb2JpbGVfY3VycmVudF9xdWFsaXR5X19lUkZEWVwiLFxuXHRcInNldHRpbmdzX3BvcHVwX2hlYWRlclwiOiBcIlZpZGVvUGxheWVyTW9iaWxlX3NldHRpbmdzX3BvcHVwX2hlYWRlcl9fUDZfaktcIixcblx0XCJzZXR0aW5nc19wb3B1cF90aXRsZVwiOiBcIlZpZGVvUGxheWVyTW9iaWxlX3NldHRpbmdzX3BvcHVwX3RpdGxlX19qM1dlYVwiLFxuXHRcInNldHRpbmdzX3BvcHVwX2JvZHlfaXRlbVwiOiBcIlZpZGVvUGxheWVyTW9iaWxlX3NldHRpbmdzX3BvcHVwX2JvZHlfaXRlbV9fUFBTMkZcIixcblx0XCJzZXR0aW5nc19wb3B1cF9ib2R5X2l0ZW1fdGV4dFwiOiBcIlZpZGVvUGxheWVyTW9iaWxlX3NldHRpbmdzX3BvcHVwX2JvZHlfaXRlbV90ZXh0X180WjZmVVwiLFxuXHRcInNldHRpbmdzX3BvcHVwX2JvZHlfaXRlbV9pY29uXCI6IFwiVmlkZW9QbGF5ZXJNb2JpbGVfc2V0dGluZ3NfcG9wdXBfYm9keV9pdGVtX2ljb25fX09FTEh4XCIsXG5cdFwiZGV2ZWxvcGVyX3RleHRcIjogXCJWaWRlb1BsYXllck1vYmlsZV9kZXZlbG9wZXJfdGV4dF9fMVQ1WWJcIlxufTtcbm1vZHVsZS5leHBvcnRzID0gX19fQ1NTX0xPQURFUl9FWFBPUlRfX187XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[2]!./src/components/VideoPlayer/VideoPlayerMobile.module.css\n");

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[2]!./src/pages/Watch/Watch.module.css":
/*!**********************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[2]!./src/pages/Watch/Watch.module.css ***!
  \**********************************************************************************************************************************************************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("// Imports\nvar ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../../../node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js\");\nvar ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(true);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \".Watch_player_wrapper__qHXAw {\\n    width: 100%;\\n    height: 100%;\\n    justify-content: center;\\n    align-items: center;\\n    display: flex;\\n\\n}\\n\\n/* Mobile */\\n.Watch_mobile_video_details__Szdom {\\n    margin-top: 70%;\\n}\\n\\n.Watch_mobile_video_stats__S2Js9 {\\n    display: flex;\\n    flex-direction: row;\\n    align-items: center;\\n    color: var(--light-grey-color);\\n    /* justify-content: space-between; */\\n    /* align-items: center; */\\n}\\n\\n.Watch_content_about_divider__2xY1z {\\n    width: 17px;\\n    max-height: 5px;\\n    margin-right: 10px;\\n    margin-left: 10px;\\n    width: 5px;\\n    height: 5px;\\n    border-radius: 50%;\\n    background-color: var(--light-grey-color);\\n}\\n\\n.Watch_mobile_video_other_details__E_bwW {\\n    width: 90%;\\n    margin: 0 auto;\\n    align-self: center;\\n    margin-top: 15px;\\n    display: flex;\\n    justify-content: space-between;\\n    flex-direction: row;\\n    align-items: center;\\n    gap: 10px;\\n}\\n\\n.Watch_mobile_video_other_details_icons__9E1zg {\\n    font-size: 30px;\\n}\\n\\n.Watch_mobile_video_other_details_item__X7w_J {\\n    align-items: center;\\n    text-align: center;\\n}\\n\\n.Watch_mobile_video_description__KFQeD {\\n    margin-top: 10px;\\n    margin-bottom: 10px;\\n    font-size: 15px;\\n    line-height: 1.1em;\\n    color: var(--light-grey-color);\\n\\n}\\n\\n/* Desktop  */\\n\\n.Watch_desktop_video_details___vW91 {\\n    /* margin-top: 70%; */\\n    padding: 20px 70px 0px 70px;\\n}\\n\\n.Watch_desktop_video_title__uonPZ {\\n\\n    font-size: 30px;\\n}\\n\\n.Watch_desktop_video_details_wrapper__s8L_k {\\n    display: flex;\\n    flex-direction: row;\\n    align-items: center;\\n    color: var(--light-grey-color);\\n    justify-content: space-between;\\n}\\n\\n.Watch_desktop_video_stats___MDOj {\\n    display: flex;\\n    align-items: center;\\n}\\n\\n.Watch_desktop_details_left__XMPiH {\\n    /* display: flex; */\\n}\\n\\n.Watch_desktop_video_other_details__P8rkz {\\n    display: flex;\\n}\\n\\n.Watch_desktop_video_other_details__P8rkz {\\n    display: flex;\\n    flex-direction: row;\\n    align-items: center;\\n    justify-content: space-between;\\n    flex-direction: row;\\n    align-items: center;\\n    gap: 20px;\\n}\\n\\n.Watch_desktop_video_other_details_item__d1ZvF {\\n    align-items: center;\\n    text-align: center;\\n}\", \"\",{\"version\":3,\"sources\":[\"webpack://src/pages/Watch/Watch.module.css\"],\"names\":[],\"mappings\":\"AAAA;IACI,WAAW;IACX,YAAY;IACZ,uBAAuB;IACvB,mBAAmB;IACnB,aAAa;;AAEjB;;AAEA,WAAW;AACX;IACI,eAAe;AACnB;;AAEA;IACI,aAAa;IACb,mBAAmB;IACnB,mBAAmB;IACnB,8BAA8B;IAC9B,oCAAoC;IACpC,yBAAyB;AAC7B;;AAEA;IACI,WAAW;IACX,eAAe;IACf,kBAAkB;IAClB,iBAAiB;IACjB,UAAU;IACV,WAAW;IACX,kBAAkB;IAClB,yCAAyC;AAC7C;;AAEA;IACI,UAAU;IACV,cAAc;IACd,kBAAkB;IAClB,gBAAgB;IAChB,aAAa;IACb,8BAA8B;IAC9B,mBAAmB;IACnB,mBAAmB;IACnB,SAAS;AACb;;AAEA;IACI,eAAe;AACnB;;AAEA;IACI,mBAAmB;IACnB,kBAAkB;AACtB;;AAEA;IACI,gBAAgB;IAChB,mBAAmB;IACnB,eAAe;IACf,kBAAkB;IAClB,8BAA8B;;AAElC;;AAEA,aAAa;;AAEb;IACI,qBAAqB;IACrB,2BAA2B;AAC/B;;AAEA;;IAEI,eAAe;AACnB;;AAEA;IACI,aAAa;IACb,mBAAmB;IACnB,mBAAmB;IACnB,8BAA8B;IAC9B,8BAA8B;AAClC;;AAEA;IACI,aAAa;IACb,mBAAmB;AACvB;;AAEA;IACI,mBAAmB;AACvB;;AAEA;IACI,aAAa;AACjB;;AAEA;IACI,aAAa;IACb,mBAAmB;IACnB,mBAAmB;IACnB,8BAA8B;IAC9B,mBAAmB;IACnB,mBAAmB;IACnB,SAAS;AACb;;AAEA;IACI,mBAAmB;IACnB,kBAAkB;AACtB\",\"sourcesContent\":[\".player_wrapper {\\n    width: 100%;\\n    height: 100%;\\n    justify-content: center;\\n    align-items: center;\\n    display: flex;\\n\\n}\\n\\n/* Mobile */\\n.mobile_video_details {\\n    margin-top: 70%;\\n}\\n\\n.mobile_video_stats {\\n    display: flex;\\n    flex-direction: row;\\n    align-items: center;\\n    color: var(--light-grey-color);\\n    /* justify-content: space-between; */\\n    /* align-items: center; */\\n}\\n\\n.content_about_divider {\\n    width: 17px;\\n    max-height: 5px;\\n    margin-right: 10px;\\n    margin-left: 10px;\\n    width: 5px;\\n    height: 5px;\\n    border-radius: 50%;\\n    background-color: var(--light-grey-color);\\n}\\n\\n.mobile_video_other_details {\\n    width: 90%;\\n    margin: 0 auto;\\n    align-self: center;\\n    margin-top: 15px;\\n    display: flex;\\n    justify-content: space-between;\\n    flex-direction: row;\\n    align-items: center;\\n    gap: 10px;\\n}\\n\\n.mobile_video_other_details_icons {\\n    font-size: 30px;\\n}\\n\\n.mobile_video_other_details_item {\\n    align-items: center;\\n    text-align: center;\\n}\\n\\n.mobile_video_description {\\n    margin-top: 10px;\\n    margin-bottom: 10px;\\n    font-size: 15px;\\n    line-height: 1.1em;\\n    color: var(--light-grey-color);\\n\\n}\\n\\n/* Desktop  */\\n\\n.desktop_video_details {\\n    /* margin-top: 70%; */\\n    padding: 20px 70px 0px 70px;\\n}\\n\\n.desktop_video_title {\\n\\n    font-size: 30px;\\n}\\n\\n.desktop_video_details_wrapper {\\n    display: flex;\\n    flex-direction: row;\\n    align-items: center;\\n    color: var(--light-grey-color);\\n    justify-content: space-between;\\n}\\n\\n.desktop_video_stats {\\n    display: flex;\\n    align-items: center;\\n}\\n\\n.desktop_details_left {\\n    /* display: flex; */\\n}\\n\\n.desktop_video_other_details {\\n    display: flex;\\n}\\n\\n.desktop_video_other_details {\\n    display: flex;\\n    flex-direction: row;\\n    align-items: center;\\n    justify-content: space-between;\\n    flex-direction: row;\\n    align-items: center;\\n    gap: 20px;\\n}\\n\\n.desktop_video_other_details_item {\\n    align-items: center;\\n    text-align: center;\\n}\"],\"sourceRoot\":\"\"}]);\n// Exports\n___CSS_LOADER_EXPORT___.locals = {\n\t\"player_wrapper\": \"Watch_player_wrapper__qHXAw\",\n\t\"mobile_video_details\": \"Watch_mobile_video_details__Szdom\",\n\t\"mobile_video_stats\": \"Watch_mobile_video_stats__S2Js9\",\n\t\"content_about_divider\": \"Watch_content_about_divider__2xY1z\",\n\t\"mobile_video_other_details\": \"Watch_mobile_video_other_details__E_bwW\",\n\t\"mobile_video_other_details_icons\": \"Watch_mobile_video_other_details_icons__9E1zg\",\n\t\"mobile_video_other_details_item\": \"Watch_mobile_video_other_details_item__X7w_J\",\n\t\"mobile_video_description\": \"Watch_mobile_video_description__KFQeD\",\n\t\"desktop_video_details\": \"Watch_desktop_video_details___vW91\",\n\t\"desktop_video_title\": \"Watch_desktop_video_title__uonPZ\",\n\t\"desktop_video_details_wrapper\": \"Watch_desktop_video_details_wrapper__s8L_k\",\n\t\"desktop_video_stats\": \"Watch_desktop_video_stats___MDOj\",\n\t\"desktop_details_left\": \"Watch_desktop_details_left__XMPiH\",\n\t\"desktop_video_other_details\": \"Watch_desktop_video_other_details__P8rkz\",\n\t\"desktop_video_other_details_item\": \"Watch_desktop_video_other_details_item__d1ZvF\"\n};\nmodule.exports = ___CSS_LOADER_EXPORT___;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1szXS5vbmVPZls0XS51c2VbMV0hLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbM10ub25lT2ZbNF0udXNlWzJdIS4vc3JjL3BhZ2VzL1dhdGNoL1dhdGNoLm1vZHVsZS5jc3MuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxrQ0FBa0MsbUJBQU8sQ0FBQyx5S0FBcUY7QUFDL0g7QUFDQTtBQUNBLHdFQUF3RSxrQkFBa0IsbUJBQW1CLDhCQUE4QiwwQkFBMEIsb0JBQW9CLEtBQUssc0RBQXNELHNCQUFzQixHQUFHLHNDQUFzQyxvQkFBb0IsMEJBQTBCLDBCQUEwQixxQ0FBcUMseUNBQXlDLGdDQUFnQyxLQUFLLHlDQUF5QyxrQkFBa0Isc0JBQXNCLHlCQUF5Qix3QkFBd0IsaUJBQWlCLGtCQUFrQix5QkFBeUIsZ0RBQWdELEdBQUcsOENBQThDLGlCQUFpQixxQkFBcUIseUJBQXlCLHVCQUF1QixvQkFBb0IscUNBQXFDLDBCQUEwQiwwQkFBMEIsZ0JBQWdCLEdBQUcsb0RBQW9ELHNCQUFzQixHQUFHLG1EQUFtRCwwQkFBMEIseUJBQXlCLEdBQUcsNENBQTRDLHVCQUF1QiwwQkFBMEIsc0JBQXNCLHlCQUF5QixxQ0FBcUMsS0FBSywyREFBMkQsMEJBQTBCLG9DQUFvQyxHQUFHLHVDQUF1Qyx3QkFBd0IsR0FBRyxpREFBaUQsb0JBQW9CLDBCQUEwQiwwQkFBMEIscUNBQXFDLHFDQUFxQyxHQUFHLHVDQUF1QyxvQkFBb0IsMEJBQTBCLEdBQUcsd0NBQXdDLHdCQUF3QixLQUFLLCtDQUErQyxvQkFBb0IsR0FBRywrQ0FBK0Msb0JBQW9CLDBCQUEwQiwwQkFBMEIscUNBQXFDLDBCQUEwQiwwQkFBMEIsZ0JBQWdCLEdBQUcsb0RBQW9ELDBCQUEwQix5QkFBeUIsR0FBRyxPQUFPLGlHQUFpRyxVQUFVLFVBQVUsWUFBWSxhQUFhLFlBQVksT0FBTyxVQUFVLEtBQUssVUFBVSxPQUFPLEtBQUssVUFBVSxZQUFZLGFBQWEsYUFBYSxhQUFhLGFBQWEsT0FBTyxLQUFLLFVBQVUsVUFBVSxZQUFZLGFBQWEsV0FBVyxVQUFVLFlBQVksYUFBYSxPQUFPLEtBQUssVUFBVSxVQUFVLFlBQVksYUFBYSxXQUFXLFlBQVksYUFBYSxhQUFhLFdBQVcsTUFBTSxLQUFLLFVBQVUsT0FBTyxLQUFLLFlBQVksYUFBYSxPQUFPLEtBQUssWUFBWSxhQUFhLFdBQVcsWUFBWSxjQUFjLE9BQU8sV0FBVyxLQUFLLFlBQVksYUFBYSxPQUFPLE1BQU0sVUFBVSxPQUFPLEtBQUssVUFBVSxZQUFZLGFBQWEsYUFBYSxhQUFhLE9BQU8sS0FBSyxVQUFVLFlBQVksT0FBTyxLQUFLLFlBQVksT0FBTyxLQUFLLFVBQVUsT0FBTyxLQUFLLFVBQVUsWUFBWSxhQUFhLGFBQWEsYUFBYSxhQUFhLFdBQVcsTUFBTSxLQUFLLFlBQVksYUFBYSwyQ0FBMkMsa0JBQWtCLG1CQUFtQiw4QkFBOEIsMEJBQTBCLG9CQUFvQixLQUFLLHlDQUF5QyxzQkFBc0IsR0FBRyx5QkFBeUIsb0JBQW9CLDBCQUEwQiwwQkFBMEIscUNBQXFDLHlDQUF5QyxnQ0FBZ0MsS0FBSyw0QkFBNEIsa0JBQWtCLHNCQUFzQix5QkFBeUIsd0JBQXdCLGlCQUFpQixrQkFBa0IseUJBQXlCLGdEQUFnRCxHQUFHLGlDQUFpQyxpQkFBaUIscUJBQXFCLHlCQUF5Qix1QkFBdUIsb0JBQW9CLHFDQUFxQywwQkFBMEIsMEJBQTBCLGdCQUFnQixHQUFHLHVDQUF1QyxzQkFBc0IsR0FBRyxzQ0FBc0MsMEJBQTBCLHlCQUF5QixHQUFHLCtCQUErQix1QkFBdUIsMEJBQTBCLHNCQUFzQix5QkFBeUIscUNBQXFDLEtBQUssOENBQThDLDBCQUEwQixvQ0FBb0MsR0FBRywwQkFBMEIsd0JBQXdCLEdBQUcsb0NBQW9DLG9CQUFvQiwwQkFBMEIsMEJBQTBCLHFDQUFxQyxxQ0FBcUMsR0FBRywwQkFBMEIsb0JBQW9CLDBCQUEwQixHQUFHLDJCQUEyQix3QkFBd0IsS0FBSyxrQ0FBa0Msb0JBQW9CLEdBQUcsa0NBQWtDLG9CQUFvQiwwQkFBMEIsMEJBQTBCLHFDQUFxQywwQkFBMEIsMEJBQTBCLGdCQUFnQixHQUFHLHVDQUF1QywwQkFBMEIseUJBQXlCLEdBQUcsbUJBQW1CO0FBQ3J4SztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvcGFnZXMvV2F0Y2gvV2F0Y2gubW9kdWxlLmNzcz83ZGQ5Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIEltcG9ydHNcbnZhciBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gPSByZXF1aXJlKFwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvY3NzLWxvYWRlci9zcmMvcnVudGltZS9hcGkuanNcIik7XG52YXIgX19fQ1NTX0xPQURFUl9FWFBPUlRfX18gPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18odHJ1ZSk7XG4vLyBNb2R1bGVcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLnB1c2goW21vZHVsZS5pZCwgXCIuV2F0Y2hfcGxheWVyX3dyYXBwZXJfX3FIWEF3IHtcXG4gICAgd2lkdGg6IDEwMCU7XFxuICAgIGhlaWdodDogMTAwJTtcXG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuXFxufVxcblxcbi8qIE1vYmlsZSAqL1xcbi5XYXRjaF9tb2JpbGVfdmlkZW9fZGV0YWlsc19fU3pkb20ge1xcbiAgICBtYXJnaW4tdG9wOiA3MCU7XFxufVxcblxcbi5XYXRjaF9tb2JpbGVfdmlkZW9fc3RhdHNfX1MySnM5IHtcXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAgZmxleC1kaXJlY3Rpb246IHJvdztcXG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gICAgY29sb3I6IHZhcigtLWxpZ2h0LWdyZXktY29sb3IpO1xcbiAgICAvKiBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47ICovXFxuICAgIC8qIGFsaWduLWl0ZW1zOiBjZW50ZXI7ICovXFxufVxcblxcbi5XYXRjaF9jb250ZW50X2Fib3V0X2RpdmlkZXJfXzJ4WTF6IHtcXG4gICAgd2lkdGg6IDE3cHg7XFxuICAgIG1heC1oZWlnaHQ6IDVweDtcXG4gICAgbWFyZ2luLXJpZ2h0OiAxMHB4O1xcbiAgICBtYXJnaW4tbGVmdDogMTBweDtcXG4gICAgd2lkdGg6IDVweDtcXG4gICAgaGVpZ2h0OiA1cHg7XFxuICAgIGJvcmRlci1yYWRpdXM6IDUwJTtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tbGlnaHQtZ3JleS1jb2xvcik7XFxufVxcblxcbi5XYXRjaF9tb2JpbGVfdmlkZW9fb3RoZXJfZGV0YWlsc19fRV9id1cge1xcbiAgICB3aWR0aDogOTAlO1xcbiAgICBtYXJnaW46IDAgYXV0bztcXG4gICAgYWxpZ24tc2VsZjogY2VudGVyO1xcbiAgICBtYXJnaW4tdG9wOiAxNXB4O1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XFxuICAgIGZsZXgtZGlyZWN0aW9uOiByb3c7XFxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICAgIGdhcDogMTBweDtcXG59XFxuXFxuLldhdGNoX21vYmlsZV92aWRlb19vdGhlcl9kZXRhaWxzX2ljb25zX185RTF6ZyB7XFxuICAgIGZvbnQtc2l6ZTogMzBweDtcXG59XFxuXFxuLldhdGNoX21vYmlsZV92aWRlb19vdGhlcl9kZXRhaWxzX2l0ZW1fX1g3d19KIHtcXG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xcbn1cXG5cXG4uV2F0Y2hfbW9iaWxlX3ZpZGVvX2Rlc2NyaXB0aW9uX19LRlFlRCB7XFxuICAgIG1hcmdpbi10b3A6IDEwcHg7XFxuICAgIG1hcmdpbi1ib3R0b206IDEwcHg7XFxuICAgIGZvbnQtc2l6ZTogMTVweDtcXG4gICAgbGluZS1oZWlnaHQ6IDEuMWVtO1xcbiAgICBjb2xvcjogdmFyKC0tbGlnaHQtZ3JleS1jb2xvcik7XFxuXFxufVxcblxcbi8qIERlc2t0b3AgICovXFxuXFxuLldhdGNoX2Rlc2t0b3BfdmlkZW9fZGV0YWlsc19fX3ZXOTEge1xcbiAgICAvKiBtYXJnaW4tdG9wOiA3MCU7ICovXFxuICAgIHBhZGRpbmc6IDIwcHggNzBweCAwcHggNzBweDtcXG59XFxuXFxuLldhdGNoX2Rlc2t0b3BfdmlkZW9fdGl0bGVfX3VvblBaIHtcXG5cXG4gICAgZm9udC1zaXplOiAzMHB4O1xcbn1cXG5cXG4uV2F0Y2hfZGVza3RvcF92aWRlb19kZXRhaWxzX3dyYXBwZXJfX3M4TF9rIHtcXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAgZmxleC1kaXJlY3Rpb246IHJvdztcXG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gICAgY29sb3I6IHZhcigtLWxpZ2h0LWdyZXktY29sb3IpO1xcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XFxufVxcblxcbi5XYXRjaF9kZXNrdG9wX3ZpZGVvX3N0YXRzX19fTURPaiB7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxufVxcblxcbi5XYXRjaF9kZXNrdG9wX2RldGFpbHNfbGVmdF9fWE1QaUgge1xcbiAgICAvKiBkaXNwbGF5OiBmbGV4OyAqL1xcbn1cXG5cXG4uV2F0Y2hfZGVza3RvcF92aWRlb19vdGhlcl9kZXRhaWxzX19QOHJreiB7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxufVxcblxcbi5XYXRjaF9kZXNrdG9wX3ZpZGVvX290aGVyX2RldGFpbHNfX1A4cmt6IHtcXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAgZmxleC1kaXJlY3Rpb246IHJvdztcXG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xcbiAgICBmbGV4LWRpcmVjdGlvbjogcm93O1xcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgICBnYXA6IDIwcHg7XFxufVxcblxcbi5XYXRjaF9kZXNrdG9wX3ZpZGVvX290aGVyX2RldGFpbHNfaXRlbV9fZDFadkYge1xcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxufVwiLCBcIlwiLHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIndlYnBhY2s6Ly9zcmMvcGFnZXMvV2F0Y2gvV2F0Y2gubW9kdWxlLmNzc1wiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiQUFBQTtJQUNJLFdBQVc7SUFDWCxZQUFZO0lBQ1osdUJBQXVCO0lBQ3ZCLG1CQUFtQjtJQUNuQixhQUFhOztBQUVqQjs7QUFFQSxXQUFXO0FBQ1g7SUFDSSxlQUFlO0FBQ25COztBQUVBO0lBQ0ksYUFBYTtJQUNiLG1CQUFtQjtJQUNuQixtQkFBbUI7SUFDbkIsOEJBQThCO0lBQzlCLG9DQUFvQztJQUNwQyx5QkFBeUI7QUFDN0I7O0FBRUE7SUFDSSxXQUFXO0lBQ1gsZUFBZTtJQUNmLGtCQUFrQjtJQUNsQixpQkFBaUI7SUFDakIsVUFBVTtJQUNWLFdBQVc7SUFDWCxrQkFBa0I7SUFDbEIseUNBQXlDO0FBQzdDOztBQUVBO0lBQ0ksVUFBVTtJQUNWLGNBQWM7SUFDZCxrQkFBa0I7SUFDbEIsZ0JBQWdCO0lBQ2hCLGFBQWE7SUFDYiw4QkFBOEI7SUFDOUIsbUJBQW1CO0lBQ25CLG1CQUFtQjtJQUNuQixTQUFTO0FBQ2I7O0FBRUE7SUFDSSxlQUFlO0FBQ25COztBQUVBO0lBQ0ksbUJBQW1CO0lBQ25CLGtCQUFrQjtBQUN0Qjs7QUFFQTtJQUNJLGdCQUFnQjtJQUNoQixtQkFBbUI7SUFDbkIsZUFBZTtJQUNmLGtCQUFrQjtJQUNsQiw4QkFBOEI7O0FBRWxDOztBQUVBLGFBQWE7O0FBRWI7SUFDSSxxQkFBcUI7SUFDckIsMkJBQTJCO0FBQy9COztBQUVBOztJQUVJLGVBQWU7QUFDbkI7O0FBRUE7SUFDSSxhQUFhO0lBQ2IsbUJBQW1CO0lBQ25CLG1CQUFtQjtJQUNuQiw4QkFBOEI7SUFDOUIsOEJBQThCO0FBQ2xDOztBQUVBO0lBQ0ksYUFBYTtJQUNiLG1CQUFtQjtBQUN2Qjs7QUFFQTtJQUNJLG1CQUFtQjtBQUN2Qjs7QUFFQTtJQUNJLGFBQWE7QUFDakI7O0FBRUE7SUFDSSxhQUFhO0lBQ2IsbUJBQW1CO0lBQ25CLG1CQUFtQjtJQUNuQiw4QkFBOEI7SUFDOUIsbUJBQW1CO0lBQ25CLG1CQUFtQjtJQUNuQixTQUFTO0FBQ2I7O0FBRUE7SUFDSSxtQkFBbUI7SUFDbkIsa0JBQWtCO0FBQ3RCXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIi5wbGF5ZXJfd3JhcHBlciB7XFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgICBoZWlnaHQ6IDEwMCU7XFxuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcblxcbn1cXG5cXG4vKiBNb2JpbGUgKi9cXG4ubW9iaWxlX3ZpZGVvX2RldGFpbHMge1xcbiAgICBtYXJnaW4tdG9wOiA3MCU7XFxufVxcblxcbi5tb2JpbGVfdmlkZW9fc3RhdHMge1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICBmbGV4LWRpcmVjdGlvbjogcm93O1xcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgICBjb2xvcjogdmFyKC0tbGlnaHQtZ3JleS1jb2xvcik7XFxuICAgIC8qIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjsgKi9cXG4gICAgLyogYWxpZ24taXRlbXM6IGNlbnRlcjsgKi9cXG59XFxuXFxuLmNvbnRlbnRfYWJvdXRfZGl2aWRlciB7XFxuICAgIHdpZHRoOiAxN3B4O1xcbiAgICBtYXgtaGVpZ2h0OiA1cHg7XFxuICAgIG1hcmdpbi1yaWdodDogMTBweDtcXG4gICAgbWFyZ2luLWxlZnQ6IDEwcHg7XFxuICAgIHdpZHRoOiA1cHg7XFxuICAgIGhlaWdodDogNXB4O1xcbiAgICBib3JkZXItcmFkaXVzOiA1MCU7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWxpZ2h0LWdyZXktY29sb3IpO1xcbn1cXG5cXG4ubW9iaWxlX3ZpZGVvX290aGVyX2RldGFpbHMge1xcbiAgICB3aWR0aDogOTAlO1xcbiAgICBtYXJnaW46IDAgYXV0bztcXG4gICAgYWxpZ24tc2VsZjogY2VudGVyO1xcbiAgICBtYXJnaW4tdG9wOiAxNXB4O1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XFxuICAgIGZsZXgtZGlyZWN0aW9uOiByb3c7XFxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICAgIGdhcDogMTBweDtcXG59XFxuXFxuLm1vYmlsZV92aWRlb19vdGhlcl9kZXRhaWxzX2ljb25zIHtcXG4gICAgZm9udC1zaXplOiAzMHB4O1xcbn1cXG5cXG4ubW9iaWxlX3ZpZGVvX290aGVyX2RldGFpbHNfaXRlbSB7XFxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcXG59XFxuXFxuLm1vYmlsZV92aWRlb19kZXNjcmlwdGlvbiB7XFxuICAgIG1hcmdpbi10b3A6IDEwcHg7XFxuICAgIG1hcmdpbi1ib3R0b206IDEwcHg7XFxuICAgIGZvbnQtc2l6ZTogMTVweDtcXG4gICAgbGluZS1oZWlnaHQ6IDEuMWVtO1xcbiAgICBjb2xvcjogdmFyKC0tbGlnaHQtZ3JleS1jb2xvcik7XFxuXFxufVxcblxcbi8qIERlc2t0b3AgICovXFxuXFxuLmRlc2t0b3BfdmlkZW9fZGV0YWlscyB7XFxuICAgIC8qIG1hcmdpbi10b3A6IDcwJTsgKi9cXG4gICAgcGFkZGluZzogMjBweCA3MHB4IDBweCA3MHB4O1xcbn1cXG5cXG4uZGVza3RvcF92aWRlb190aXRsZSB7XFxuXFxuICAgIGZvbnQtc2l6ZTogMzBweDtcXG59XFxuXFxuLmRlc2t0b3BfdmlkZW9fZGV0YWlsc193cmFwcGVyIHtcXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAgZmxleC1kaXJlY3Rpb246IHJvdztcXG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gICAgY29sb3I6IHZhcigtLWxpZ2h0LWdyZXktY29sb3IpO1xcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XFxufVxcblxcbi5kZXNrdG9wX3ZpZGVvX3N0YXRzIHtcXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG59XFxuXFxuLmRlc2t0b3BfZGV0YWlsc19sZWZ0IHtcXG4gICAgLyogZGlzcGxheTogZmxleDsgKi9cXG59XFxuXFxuLmRlc2t0b3BfdmlkZW9fb3RoZXJfZGV0YWlscyB7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxufVxcblxcbi5kZXNrdG9wX3ZpZGVvX290aGVyX2RldGFpbHMge1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICBmbGV4LWRpcmVjdGlvbjogcm93O1xcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XFxuICAgIGZsZXgtZGlyZWN0aW9uOiByb3c7XFxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICAgIGdhcDogMjBweDtcXG59XFxuXFxuLmRlc2t0b3BfdmlkZW9fb3RoZXJfZGV0YWlsc19pdGVtIHtcXG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xcbn1cIl0sXCJzb3VyY2VSb290XCI6XCJcIn1dKTtcbi8vIEV4cG9ydHNcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLmxvY2FscyA9IHtcblx0XCJwbGF5ZXJfd3JhcHBlclwiOiBcIldhdGNoX3BsYXllcl93cmFwcGVyX19xSFhBd1wiLFxuXHRcIm1vYmlsZV92aWRlb19kZXRhaWxzXCI6IFwiV2F0Y2hfbW9iaWxlX3ZpZGVvX2RldGFpbHNfX1N6ZG9tXCIsXG5cdFwibW9iaWxlX3ZpZGVvX3N0YXRzXCI6IFwiV2F0Y2hfbW9iaWxlX3ZpZGVvX3N0YXRzX19TMkpzOVwiLFxuXHRcImNvbnRlbnRfYWJvdXRfZGl2aWRlclwiOiBcIldhdGNoX2NvbnRlbnRfYWJvdXRfZGl2aWRlcl9fMnhZMXpcIixcblx0XCJtb2JpbGVfdmlkZW9fb3RoZXJfZGV0YWlsc1wiOiBcIldhdGNoX21vYmlsZV92aWRlb19vdGhlcl9kZXRhaWxzX19FX2J3V1wiLFxuXHRcIm1vYmlsZV92aWRlb19vdGhlcl9kZXRhaWxzX2ljb25zXCI6IFwiV2F0Y2hfbW9iaWxlX3ZpZGVvX290aGVyX2RldGFpbHNfaWNvbnNfXzlFMXpnXCIsXG5cdFwibW9iaWxlX3ZpZGVvX290aGVyX2RldGFpbHNfaXRlbVwiOiBcIldhdGNoX21vYmlsZV92aWRlb19vdGhlcl9kZXRhaWxzX2l0ZW1fX1g3d19KXCIsXG5cdFwibW9iaWxlX3ZpZGVvX2Rlc2NyaXB0aW9uXCI6IFwiV2F0Y2hfbW9iaWxlX3ZpZGVvX2Rlc2NyaXB0aW9uX19LRlFlRFwiLFxuXHRcImRlc2t0b3BfdmlkZW9fZGV0YWlsc1wiOiBcIldhdGNoX2Rlc2t0b3BfdmlkZW9fZGV0YWlsc19fX3ZXOTFcIixcblx0XCJkZXNrdG9wX3ZpZGVvX3RpdGxlXCI6IFwiV2F0Y2hfZGVza3RvcF92aWRlb190aXRsZV9fdW9uUFpcIixcblx0XCJkZXNrdG9wX3ZpZGVvX2RldGFpbHNfd3JhcHBlclwiOiBcIldhdGNoX2Rlc2t0b3BfdmlkZW9fZGV0YWlsc193cmFwcGVyX19zOExfa1wiLFxuXHRcImRlc2t0b3BfdmlkZW9fc3RhdHNcIjogXCJXYXRjaF9kZXNrdG9wX3ZpZGVvX3N0YXRzX19fTURPalwiLFxuXHRcImRlc2t0b3BfZGV0YWlsc19sZWZ0XCI6IFwiV2F0Y2hfZGVza3RvcF9kZXRhaWxzX2xlZnRfX1hNUGlIXCIsXG5cdFwiZGVza3RvcF92aWRlb19vdGhlcl9kZXRhaWxzXCI6IFwiV2F0Y2hfZGVza3RvcF92aWRlb19vdGhlcl9kZXRhaWxzX19QOHJrelwiLFxuXHRcImRlc2t0b3BfdmlkZW9fb3RoZXJfZGV0YWlsc19pdGVtXCI6IFwiV2F0Y2hfZGVza3RvcF92aWRlb19vdGhlcl9kZXRhaWxzX2l0ZW1fX2QxWnZGXCJcbn07XG5tb2R1bGUuZXhwb3J0cyA9IF9fX0NTU19MT0FERVJfRVhQT1JUX19fO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[2]!./src/pages/Watch/Watch.module.css\n");

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=%2Fhome%2Fisolated%2Frakazone%2Frakazone-frontend%2Fsrc%2Fpages%2FWatch%2F%5BvideoId%5D.js&page=%2FWatch%2F%5BvideoId%5D!":
/*!*****************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=%2Fhome%2Fisolated%2Frakazone%2Frakazone-frontend%2Fsrc%2Fpages%2FWatch%2F%5BvideoId%5D.js&page=%2FWatch%2F%5BvideoId%5D! ***!
  \*****************************************************************************************************************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("\n    (window.__NEXT_P = window.__NEXT_P || []).push([\n      \"/Watch/[videoId]\",\n      function () {\n        return __webpack_require__(/*! ./src/pages/Watch/[videoId].js */ \"./src/pages/Watch/[videoId].js\");\n      }\n    ]);\n    if(true) {\n      module.hot.dispose(function () {\n        window.__NEXT_P.push([\"/Watch/[videoId]\"])\n      });\n    }\n  //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LWNsaWVudC1wYWdlcy1sb2FkZXIuanM/YWJzb2x1dGVQYWdlUGF0aD0lMkZob21lJTJGaXNvbGF0ZWQlMkZyYWthem9uZSUyRnJha2F6b25lLWZyb250ZW5kJTJGc3JjJTJGcGFnZXMlMkZXYXRjaCUyRiU1QnZpZGVvSWQlNUQuanMmcGFnZT0lMkZXYXRjaCUyRiU1QnZpZGVvSWQlNUQhLmpzIiwibWFwcGluZ3MiOiI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1CQUFPLENBQUMsc0VBQWdDO0FBQ3ZEO0FBQ0E7QUFDQSxPQUFPLElBQVU7QUFDakIsTUFBTSxVQUFVO0FBQ2hCO0FBQ0EsT0FBTztBQUNQO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLz8wMDNjIl0sInNvdXJjZXNDb250ZW50IjpbIlxuICAgICh3aW5kb3cuX19ORVhUX1AgPSB3aW5kb3cuX19ORVhUX1AgfHwgW10pLnB1c2goW1xuICAgICAgXCIvV2F0Y2gvW3ZpZGVvSWRdXCIsXG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiByZXF1aXJlKFwiLi9zcmMvcGFnZXMvV2F0Y2gvW3ZpZGVvSWRdLmpzXCIpO1xuICAgICAgfVxuICAgIF0pO1xuICAgIGlmKG1vZHVsZS5ob3QpIHtcbiAgICAgIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHdpbmRvdy5fX05FWFRfUC5wdXNoKFtcIi9XYXRjaC9bdmlkZW9JZF1cIl0pXG4gICAgICB9KTtcbiAgICB9XG4gICJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=%2Fhome%2Fisolated%2Frakazone%2Frakazone-frontend%2Fsrc%2Fpages%2FWatch%2F%5BvideoId%5D.js&page=%2FWatch%2F%5BvideoId%5D!\n");

/***/ }),

/***/ "./src/components/Loading/loading.module.css":
/*!***************************************************!*\
  !*** ./src/components/Loading/loading.module.css ***!
  \***************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("var api = __webpack_require__(/*! !../../../node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js\");\n            var content = __webpack_require__(/*! !!../../../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[1]!../../../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[2]!./loading.module.css */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[2]!./src/components/Loading/loading.module.css\");\n\n            content = content.__esModule ? content.default : content;\n\n            if (typeof content === 'string') {\n              content = [[module.id, content, '']];\n            }\n\nvar options = {};\n\noptions.insert = function(element) {\n                // These elements should always exist. If they do not,\n                // this code should fail.\n                var anchorElement = document.querySelector('#__next_css__DO_NOT_USE__');\n                var parentNode = anchorElement.parentNode// Normally <head>\n                ;\n                // Each style tag should be placed right before our\n                // anchor. By inserting before and not after, we do not\n                // need to track the last inserted element.\n                parentNode.insertBefore(element, anchorElement);\n            };\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\nif (true) {\n  if (!content.locals || module.hot.invalidate) {\n    var isEqualLocals = function isEqualLocals(a, b, isNamedExport) {\n    if (!a && b || a && !b) {\n        return false;\n    }\n    let p;\n    for(p in a){\n        if (isNamedExport && p === 'default') {\n            continue;\n        }\n        if (a[p] !== b[p]) {\n            return false;\n        }\n    }\n    for(p in b){\n        if (isNamedExport && p === 'default') {\n            continue;\n        }\n        if (!a[p]) {\n            return false;\n        }\n    }\n    return true;\n};\n    var oldLocals = content.locals;\n\n    module.hot.accept(\n      /*! !!../../../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[1]!../../../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[2]!./loading.module.css */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[2]!./src/components/Loading/loading.module.css\",\n      function () {\n        content = __webpack_require__(/*! !!../../../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[1]!../../../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[2]!./loading.module.css */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[2]!./src/components/Loading/loading.module.css\");\n\n              content = content.__esModule ? content.default : content;\n\n              if (typeof content === 'string') {\n                content = [[module.id, content, '']];\n              }\n\n              if (!isEqualLocals(oldLocals, content.locals)) {\n                module.hot.invalidate();\n\n                return;\n              }\n\n              oldLocals = content.locals;\n\n              update(content);\n      }\n    )\n  }\n\n  module.hot.dispose(function() {\n    update();\n  });\n}\n\nmodule.exports = content.locals || {};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29tcG9uZW50cy9Mb2FkaW5nL2xvYWRpbmcubW9kdWxlLmNzcy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxVQUFVLG1CQUFPLENBQUMsME5BQThHO0FBQ2hJLDBCQUEwQixtQkFBTyxDQUFDLGloQkFBa1E7O0FBRXBTOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBLElBQUksSUFBVTtBQUNkLHlCQUF5QixVQUFVO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJLGlCQUFpQjtBQUNyQixNQUFNLGloQkFBa1E7QUFDeFE7QUFDQSxrQkFBa0IsbUJBQU8sQ0FBQyxpaEJBQWtROztBQUU1Ujs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsVUFBVTs7QUFFMUI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxFQUFFLFVBQVU7QUFDWjtBQUNBLEdBQUc7QUFDSDs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvY29tcG9uZW50cy9Mb2FkaW5nL2xvYWRpbmcubW9kdWxlLmNzcz80ZDM1Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBhcGkgPSByZXF1aXJlKFwiIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtc3R5bGUtbG9hZGVyL3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzXCIpO1xuICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1szXS5vbmVPZls0XS51c2VbMV0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvcG9zdGNzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzNdLm9uZU9mWzRdLnVzZVsyXSEuL2xvYWRpbmcubW9kdWxlLmNzc1wiKTtcblxuICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQuX19lc01vZHVsZSA/IGNvbnRlbnQuZGVmYXVsdCA6IGNvbnRlbnQ7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuICAgICAgICAgICAgfVxuXG52YXIgb3B0aW9ucyA9IHt9O1xuXG5vcHRpb25zLmluc2VydCA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGVzZSBlbGVtZW50cyBzaG91bGQgYWx3YXlzIGV4aXN0LiBJZiB0aGV5IGRvIG5vdCxcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGNvZGUgc2hvdWxkIGZhaWwuXG4gICAgICAgICAgICAgICAgdmFyIGFuY2hvckVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjX19uZXh0X2Nzc19fRE9fTk9UX1VTRV9fJyk7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudE5vZGUgPSBhbmNob3JFbGVtZW50LnBhcmVudE5vZGUvLyBOb3JtYWxseSA8aGVhZD5cbiAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgLy8gRWFjaCBzdHlsZSB0YWcgc2hvdWxkIGJlIHBsYWNlZCByaWdodCBiZWZvcmUgb3VyXG4gICAgICAgICAgICAgICAgLy8gYW5jaG9yLiBCeSBpbnNlcnRpbmcgYmVmb3JlIGFuZCBub3QgYWZ0ZXIsIHdlIGRvIG5vdFxuICAgICAgICAgICAgICAgIC8vIG5lZWQgdG8gdHJhY2sgdGhlIGxhc3QgaW5zZXJ0ZWQgZWxlbWVudC5cbiAgICAgICAgICAgICAgICBwYXJlbnROb2RlLmluc2VydEJlZm9yZShlbGVtZW50LCBhbmNob3JFbGVtZW50KTtcbiAgICAgICAgICAgIH07XG5vcHRpb25zLnNpbmdsZXRvbiA9IGZhbHNlO1xuXG52YXIgdXBkYXRlID0gYXBpKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG5cbmlmIChtb2R1bGUuaG90KSB7XG4gIGlmICghY29udGVudC5sb2NhbHMgfHwgbW9kdWxlLmhvdC5pbnZhbGlkYXRlKSB7XG4gICAgdmFyIGlzRXF1YWxMb2NhbHMgPSBmdW5jdGlvbiBpc0VxdWFsTG9jYWxzKGEsIGIsIGlzTmFtZWRFeHBvcnQpIHtcbiAgICBpZiAoIWEgJiYgYiB8fCBhICYmICFiKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgbGV0IHA7XG4gICAgZm9yKHAgaW4gYSl7XG4gICAgICAgIGlmIChpc05hbWVkRXhwb3J0ICYmIHAgPT09ICdkZWZhdWx0Jykge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFbcF0gIT09IGJbcF0pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IocCBpbiBiKXtcbiAgICAgICAgaWYgKGlzTmFtZWRFeHBvcnQgJiYgcCA9PT0gJ2RlZmF1bHQnKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWFbcF0pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4gICAgdmFyIG9sZExvY2FscyA9IGNvbnRlbnQubG9jYWxzO1xuXG4gICAgbW9kdWxlLmhvdC5hY2NlcHQoXG4gICAgICBcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvY3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbM10ub25lT2ZbNF0udXNlWzFdIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL3Bvc3Rjc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1szXS5vbmVPZls0XS51c2VbMl0hLi9sb2FkaW5nLm1vZHVsZS5jc3NcIixcbiAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL2Nzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzNdLm9uZU9mWzRdLnVzZVsxXSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbM10ub25lT2ZbNF0udXNlWzJdIS4vbG9hZGluZy5tb2R1bGUuY3NzXCIpO1xuXG4gICAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50Ll9fZXNNb2R1bGUgPyBjb250ZW50LmRlZmF1bHQgOiBjb250ZW50O1xuXG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoIWlzRXF1YWxMb2NhbHMob2xkTG9jYWxzLCBjb250ZW50LmxvY2FscykpIHtcbiAgICAgICAgICAgICAgICBtb2R1bGUuaG90LmludmFsaWRhdGUoKTtcblxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIG9sZExvY2FscyA9IGNvbnRlbnQubG9jYWxzO1xuXG4gICAgICAgICAgICAgIHVwZGF0ZShjb250ZW50KTtcbiAgICAgIH1cbiAgICApXG4gIH1cblxuICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7XG4gICAgdXBkYXRlKCk7XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzIHx8IHt9OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/components/Loading/loading.module.css\n");

/***/ }),

/***/ "./src/components/Modal/Modal.module.css":
/*!***********************************************!*\
  !*** ./src/components/Modal/Modal.module.css ***!
  \***********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("var api = __webpack_require__(/*! !../../../node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js\");\n            var content = __webpack_require__(/*! !!../../../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[1]!../../../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[2]!./Modal.module.css */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[2]!./src/components/Modal/Modal.module.css\");\n\n            content = content.__esModule ? content.default : content;\n\n            if (typeof content === 'string') {\n              content = [[module.id, content, '']];\n            }\n\nvar options = {};\n\noptions.insert = function(element) {\n                // These elements should always exist. If they do not,\n                // this code should fail.\n                var anchorElement = document.querySelector('#__next_css__DO_NOT_USE__');\n                var parentNode = anchorElement.parentNode// Normally <head>\n                ;\n                // Each style tag should be placed right before our\n                // anchor. By inserting before and not after, we do not\n                // need to track the last inserted element.\n                parentNode.insertBefore(element, anchorElement);\n            };\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\nif (true) {\n  if (!content.locals || module.hot.invalidate) {\n    var isEqualLocals = function isEqualLocals(a, b, isNamedExport) {\n    if (!a && b || a && !b) {\n        return false;\n    }\n    let p;\n    for(p in a){\n        if (isNamedExport && p === 'default') {\n            continue;\n        }\n        if (a[p] !== b[p]) {\n            return false;\n        }\n    }\n    for(p in b){\n        if (isNamedExport && p === 'default') {\n            continue;\n        }\n        if (!a[p]) {\n            return false;\n        }\n    }\n    return true;\n};\n    var oldLocals = content.locals;\n\n    module.hot.accept(\n      /*! !!../../../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[1]!../../../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[2]!./Modal.module.css */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[2]!./src/components/Modal/Modal.module.css\",\n      function () {\n        content = __webpack_require__(/*! !!../../../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[1]!../../../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[2]!./Modal.module.css */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[2]!./src/components/Modal/Modal.module.css\");\n\n              content = content.__esModule ? content.default : content;\n\n              if (typeof content === 'string') {\n                content = [[module.id, content, '']];\n              }\n\n              if (!isEqualLocals(oldLocals, content.locals)) {\n                module.hot.invalidate();\n\n                return;\n              }\n\n              oldLocals = content.locals;\n\n              update(content);\n      }\n    )\n  }\n\n  module.hot.dispose(function() {\n    update();\n  });\n}\n\nmodule.exports = content.locals || {};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29tcG9uZW50cy9Nb2RhbC9Nb2RhbC5tb2R1bGUuY3NzLmpzIiwibWFwcGluZ3MiOiJBQUFBLFVBQVUsbUJBQU8sQ0FBQywwTkFBOEc7QUFDaEksMEJBQTBCLG1CQUFPLENBQUMsMmdCQUFnUTs7QUFFbFM7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0EsSUFBSSxJQUFVO0FBQ2QseUJBQXlCLFVBQVU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUksaUJBQWlCO0FBQ3JCLE1BQU0sMmdCQUFnUTtBQUN0UTtBQUNBLGtCQUFrQixtQkFBTyxDQUFDLDJnQkFBZ1E7O0FBRTFSOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixVQUFVOztBQUUxQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEVBQUUsVUFBVTtBQUNaO0FBQ0EsR0FBRztBQUNIOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9jb21wb25lbnRzL01vZGFsL01vZGFsLm1vZHVsZS5jc3M/ZDgxZCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgYXBpID0gcmVxdWlyZShcIiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LXN0eWxlLWxvYWRlci9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qc1wiKTtcbiAgICAgICAgICAgIHZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvY3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbM10ub25lT2ZbNF0udXNlWzFdIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL3Bvc3Rjc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1szXS5vbmVPZls0XS51c2VbMl0hLi9Nb2RhbC5tb2R1bGUuY3NzXCIpO1xuXG4gICAgICAgICAgICBjb250ZW50ID0gY29udGVudC5fX2VzTW9kdWxlID8gY29udGVudC5kZWZhdWx0IDogY29udGVudDtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4gICAgICAgICAgICB9XG5cbnZhciBvcHRpb25zID0ge307XG5cbm9wdGlvbnMuaW5zZXJ0ID0gZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIC8vIFRoZXNlIGVsZW1lbnRzIHNob3VsZCBhbHdheXMgZXhpc3QuIElmIHRoZXkgZG8gbm90LFxuICAgICAgICAgICAgICAgIC8vIHRoaXMgY29kZSBzaG91bGQgZmFpbC5cbiAgICAgICAgICAgICAgICB2YXIgYW5jaG9yRWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNfX25leHRfY3NzX19ET19OT1RfVVNFX18nKTtcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50Tm9kZSA9IGFuY2hvckVsZW1lbnQucGFyZW50Tm9kZS8vIE5vcm1hbGx5IDxoZWFkPlxuICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICAvLyBFYWNoIHN0eWxlIHRhZyBzaG91bGQgYmUgcGxhY2VkIHJpZ2h0IGJlZm9yZSBvdXJcbiAgICAgICAgICAgICAgICAvLyBhbmNob3IuIEJ5IGluc2VydGluZyBiZWZvcmUgYW5kIG5vdCBhZnRlciwgd2UgZG8gbm90XG4gICAgICAgICAgICAgICAgLy8gbmVlZCB0byB0cmFjayB0aGUgbGFzdCBpbnNlcnRlZCBlbGVtZW50LlxuICAgICAgICAgICAgICAgIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGVsZW1lbnQsIGFuY2hvckVsZW1lbnQpO1xuICAgICAgICAgICAgfTtcbm9wdGlvbnMuc2luZ2xldG9uID0gZmFsc2U7XG5cbnZhciB1cGRhdGUgPSBhcGkoY29udGVudCwgb3B0aW9ucyk7XG5cblxuaWYgKG1vZHVsZS5ob3QpIHtcbiAgaWYgKCFjb250ZW50LmxvY2FscyB8fCBtb2R1bGUuaG90LmludmFsaWRhdGUpIHtcbiAgICB2YXIgaXNFcXVhbExvY2FscyA9IGZ1bmN0aW9uIGlzRXF1YWxMb2NhbHMoYSwgYiwgaXNOYW1lZEV4cG9ydCkge1xuICAgIGlmICghYSAmJiBiIHx8IGEgJiYgIWIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBsZXQgcDtcbiAgICBmb3IocCBpbiBhKXtcbiAgICAgICAgaWYgKGlzTmFtZWRFeHBvcnQgJiYgcCA9PT0gJ2RlZmF1bHQnKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYVtwXSAhPT0gYltwXSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvcihwIGluIGIpe1xuICAgICAgICBpZiAoaXNOYW1lZEV4cG9ydCAmJiBwID09PSAnZGVmYXVsdCcpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghYVtwXSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcbiAgICB2YXIgb2xkTG9jYWxzID0gY29udGVudC5sb2NhbHM7XG5cbiAgICBtb2R1bGUuaG90LmFjY2VwdChcbiAgICAgIFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1szXS5vbmVPZls0XS51c2VbMV0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvcG9zdGNzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzNdLm9uZU9mWzRdLnVzZVsyXSEuL01vZGFsLm1vZHVsZS5jc3NcIixcbiAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL2Nzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzNdLm9uZU9mWzRdLnVzZVsxXSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbM10ub25lT2ZbNF0udXNlWzJdIS4vTW9kYWwubW9kdWxlLmNzc1wiKTtcblxuICAgICAgICAgICAgICBjb250ZW50ID0gY29udGVudC5fX2VzTW9kdWxlID8gY29udGVudC5kZWZhdWx0IDogY29udGVudDtcblxuICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKCFpc0VxdWFsTG9jYWxzKG9sZExvY2FscywgY29udGVudC5sb2NhbHMpKSB7XG4gICAgICAgICAgICAgICAgbW9kdWxlLmhvdC5pbnZhbGlkYXRlKCk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBvbGRMb2NhbHMgPSBjb250ZW50LmxvY2FscztcblxuICAgICAgICAgICAgICB1cGRhdGUoY29udGVudCk7XG4gICAgICB9XG4gICAgKVxuICB9XG5cbiAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkge1xuICAgIHVwZGF0ZSgpO1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2FscyB8fCB7fTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/components/Modal/Modal.module.css\n");

/***/ }),

/***/ "./src/components/VideoPlayer/VideoPlayerDesktop.module.css":
/*!******************************************************************!*\
  !*** ./src/components/VideoPlayer/VideoPlayerDesktop.module.css ***!
  \******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("var api = __webpack_require__(/*! !../../../node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js\");\n            var content = __webpack_require__(/*! !!../../../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[1]!../../../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[2]!./VideoPlayerDesktop.module.css */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[2]!./src/components/VideoPlayer/VideoPlayerDesktop.module.css\");\n\n            content = content.__esModule ? content.default : content;\n\n            if (typeof content === 'string') {\n              content = [[module.id, content, '']];\n            }\n\nvar options = {};\n\noptions.insert = function(element) {\n                // These elements should always exist. If they do not,\n                // this code should fail.\n                var anchorElement = document.querySelector('#__next_css__DO_NOT_USE__');\n                var parentNode = anchorElement.parentNode// Normally <head>\n                ;\n                // Each style tag should be placed right before our\n                // anchor. By inserting before and not after, we do not\n                // need to track the last inserted element.\n                parentNode.insertBefore(element, anchorElement);\n            };\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\nif (true) {\n  if (!content.locals || module.hot.invalidate) {\n    var isEqualLocals = function isEqualLocals(a, b, isNamedExport) {\n    if (!a && b || a && !b) {\n        return false;\n    }\n    let p;\n    for(p in a){\n        if (isNamedExport && p === 'default') {\n            continue;\n        }\n        if (a[p] !== b[p]) {\n            return false;\n        }\n    }\n    for(p in b){\n        if (isNamedExport && p === 'default') {\n            continue;\n        }\n        if (!a[p]) {\n            return false;\n        }\n    }\n    return true;\n};\n    var oldLocals = content.locals;\n\n    module.hot.accept(\n      /*! !!../../../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[1]!../../../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[2]!./VideoPlayerDesktop.module.css */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[2]!./src/components/VideoPlayer/VideoPlayerDesktop.module.css\",\n      function () {\n        content = __webpack_require__(/*! !!../../../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[1]!../../../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[2]!./VideoPlayerDesktop.module.css */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[2]!./src/components/VideoPlayer/VideoPlayerDesktop.module.css\");\n\n              content = content.__esModule ? content.default : content;\n\n              if (typeof content === 'string') {\n                content = [[module.id, content, '']];\n              }\n\n              if (!isEqualLocals(oldLocals, content.locals)) {\n                module.hot.invalidate();\n\n                return;\n              }\n\n              oldLocals = content.locals;\n\n              update(content);\n      }\n    )\n  }\n\n  module.hot.dispose(function() {\n    update();\n  });\n}\n\nmodule.exports = content.locals || {};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29tcG9uZW50cy9WaWRlb1BsYXllci9WaWRlb1BsYXllckRlc2t0b3AubW9kdWxlLmNzcy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxVQUFVLG1CQUFPLENBQUMsME5BQThHO0FBQ2hJLDBCQUEwQixtQkFBTyxDQUFDLDJpQkFBNlE7O0FBRS9TOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBLElBQUksSUFBVTtBQUNkLHlCQUF5QixVQUFVO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJLGlCQUFpQjtBQUNyQixNQUFNLDJpQkFBNlE7QUFDblI7QUFDQSxrQkFBa0IsbUJBQU8sQ0FBQywyaUJBQTZROztBQUV2Uzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsVUFBVTs7QUFFMUI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxFQUFFLFVBQVU7QUFDWjtBQUNBLEdBQUc7QUFDSDs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvY29tcG9uZW50cy9WaWRlb1BsYXllci9WaWRlb1BsYXllckRlc2t0b3AubW9kdWxlLmNzcz84ZTg3Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBhcGkgPSByZXF1aXJlKFwiIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtc3R5bGUtbG9hZGVyL3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzXCIpO1xuICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1szXS5vbmVPZls0XS51c2VbMV0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvcG9zdGNzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzNdLm9uZU9mWzRdLnVzZVsyXSEuL1ZpZGVvUGxheWVyRGVza3RvcC5tb2R1bGUuY3NzXCIpO1xuXG4gICAgICAgICAgICBjb250ZW50ID0gY29udGVudC5fX2VzTW9kdWxlID8gY29udGVudC5kZWZhdWx0IDogY29udGVudDtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4gICAgICAgICAgICB9XG5cbnZhciBvcHRpb25zID0ge307XG5cbm9wdGlvbnMuaW5zZXJ0ID0gZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIC8vIFRoZXNlIGVsZW1lbnRzIHNob3VsZCBhbHdheXMgZXhpc3QuIElmIHRoZXkgZG8gbm90LFxuICAgICAgICAgICAgICAgIC8vIHRoaXMgY29kZSBzaG91bGQgZmFpbC5cbiAgICAgICAgICAgICAgICB2YXIgYW5jaG9yRWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNfX25leHRfY3NzX19ET19OT1RfVVNFX18nKTtcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50Tm9kZSA9IGFuY2hvckVsZW1lbnQucGFyZW50Tm9kZS8vIE5vcm1hbGx5IDxoZWFkPlxuICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICAvLyBFYWNoIHN0eWxlIHRhZyBzaG91bGQgYmUgcGxhY2VkIHJpZ2h0IGJlZm9yZSBvdXJcbiAgICAgICAgICAgICAgICAvLyBhbmNob3IuIEJ5IGluc2VydGluZyBiZWZvcmUgYW5kIG5vdCBhZnRlciwgd2UgZG8gbm90XG4gICAgICAgICAgICAgICAgLy8gbmVlZCB0byB0cmFjayB0aGUgbGFzdCBpbnNlcnRlZCBlbGVtZW50LlxuICAgICAgICAgICAgICAgIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGVsZW1lbnQsIGFuY2hvckVsZW1lbnQpO1xuICAgICAgICAgICAgfTtcbm9wdGlvbnMuc2luZ2xldG9uID0gZmFsc2U7XG5cbnZhciB1cGRhdGUgPSBhcGkoY29udGVudCwgb3B0aW9ucyk7XG5cblxuaWYgKG1vZHVsZS5ob3QpIHtcbiAgaWYgKCFjb250ZW50LmxvY2FscyB8fCBtb2R1bGUuaG90LmludmFsaWRhdGUpIHtcbiAgICB2YXIgaXNFcXVhbExvY2FscyA9IGZ1bmN0aW9uIGlzRXF1YWxMb2NhbHMoYSwgYiwgaXNOYW1lZEV4cG9ydCkge1xuICAgIGlmICghYSAmJiBiIHx8IGEgJiYgIWIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBsZXQgcDtcbiAgICBmb3IocCBpbiBhKXtcbiAgICAgICAgaWYgKGlzTmFtZWRFeHBvcnQgJiYgcCA9PT0gJ2RlZmF1bHQnKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYVtwXSAhPT0gYltwXSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvcihwIGluIGIpe1xuICAgICAgICBpZiAoaXNOYW1lZEV4cG9ydCAmJiBwID09PSAnZGVmYXVsdCcpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghYVtwXSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcbiAgICB2YXIgb2xkTG9jYWxzID0gY29udGVudC5sb2NhbHM7XG5cbiAgICBtb2R1bGUuaG90LmFjY2VwdChcbiAgICAgIFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1szXS5vbmVPZls0XS51c2VbMV0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvcG9zdGNzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzNdLm9uZU9mWzRdLnVzZVsyXSEuL1ZpZGVvUGxheWVyRGVza3RvcC5tb2R1bGUuY3NzXCIsXG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1szXS5vbmVPZls0XS51c2VbMV0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvcG9zdGNzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzNdLm9uZU9mWzRdLnVzZVsyXSEuL1ZpZGVvUGxheWVyRGVza3RvcC5tb2R1bGUuY3NzXCIpO1xuXG4gICAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50Ll9fZXNNb2R1bGUgPyBjb250ZW50LmRlZmF1bHQgOiBjb250ZW50O1xuXG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoIWlzRXF1YWxMb2NhbHMob2xkTG9jYWxzLCBjb250ZW50LmxvY2FscykpIHtcbiAgICAgICAgICAgICAgICBtb2R1bGUuaG90LmludmFsaWRhdGUoKTtcblxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIG9sZExvY2FscyA9IGNvbnRlbnQubG9jYWxzO1xuXG4gICAgICAgICAgICAgIHVwZGF0ZShjb250ZW50KTtcbiAgICAgIH1cbiAgICApXG4gIH1cblxuICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7XG4gICAgdXBkYXRlKCk7XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzIHx8IHt9OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/components/VideoPlayer/VideoPlayerDesktop.module.css\n");

/***/ }),

/***/ "./src/components/VideoPlayer/VideoPlayerMobile.module.css":
/*!*****************************************************************!*\
  !*** ./src/components/VideoPlayer/VideoPlayerMobile.module.css ***!
  \*****************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("var api = __webpack_require__(/*! !../../../node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js\");\n            var content = __webpack_require__(/*! !!../../../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[1]!../../../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[2]!./VideoPlayerMobile.module.css */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[2]!./src/components/VideoPlayer/VideoPlayerMobile.module.css\");\n\n            content = content.__esModule ? content.default : content;\n\n            if (typeof content === 'string') {\n              content = [[module.id, content, '']];\n            }\n\nvar options = {};\n\noptions.insert = function(element) {\n                // These elements should always exist. If they do not,\n                // this code should fail.\n                var anchorElement = document.querySelector('#__next_css__DO_NOT_USE__');\n                var parentNode = anchorElement.parentNode// Normally <head>\n                ;\n                // Each style tag should be placed right before our\n                // anchor. By inserting before and not after, we do not\n                // need to track the last inserted element.\n                parentNode.insertBefore(element, anchorElement);\n            };\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\nif (true) {\n  if (!content.locals || module.hot.invalidate) {\n    var isEqualLocals = function isEqualLocals(a, b, isNamedExport) {\n    if (!a && b || a && !b) {\n        return false;\n    }\n    let p;\n    for(p in a){\n        if (isNamedExport && p === 'default') {\n            continue;\n        }\n        if (a[p] !== b[p]) {\n            return false;\n        }\n    }\n    for(p in b){\n        if (isNamedExport && p === 'default') {\n            continue;\n        }\n        if (!a[p]) {\n            return false;\n        }\n    }\n    return true;\n};\n    var oldLocals = content.locals;\n\n    module.hot.accept(\n      /*! !!../../../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[1]!../../../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[2]!./VideoPlayerMobile.module.css */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[2]!./src/components/VideoPlayer/VideoPlayerMobile.module.css\",\n      function () {\n        content = __webpack_require__(/*! !!../../../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[1]!../../../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[2]!./VideoPlayerMobile.module.css */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[2]!./src/components/VideoPlayer/VideoPlayerMobile.module.css\");\n\n              content = content.__esModule ? content.default : content;\n\n              if (typeof content === 'string') {\n                content = [[module.id, content, '']];\n              }\n\n              if (!isEqualLocals(oldLocals, content.locals)) {\n                module.hot.invalidate();\n\n                return;\n              }\n\n              oldLocals = content.locals;\n\n              update(content);\n      }\n    )\n  }\n\n  module.hot.dispose(function() {\n    update();\n  });\n}\n\nmodule.exports = content.locals || {};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29tcG9uZW50cy9WaWRlb1BsYXllci9WaWRlb1BsYXllck1vYmlsZS5tb2R1bGUuY3NzLmpzIiwibWFwcGluZ3MiOiJBQUFBLFVBQVUsbUJBQU8sQ0FBQywwTkFBOEc7QUFDaEksMEJBQTBCLG1CQUFPLENBQUMseWlCQUE0UTs7QUFFOVM7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0EsSUFBSSxJQUFVO0FBQ2QseUJBQXlCLFVBQVU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUksaUJBQWlCO0FBQ3JCLE1BQU0seWlCQUE0UTtBQUNsUjtBQUNBLGtCQUFrQixtQkFBTyxDQUFDLHlpQkFBNFE7O0FBRXRTOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixVQUFVOztBQUUxQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEVBQUUsVUFBVTtBQUNaO0FBQ0EsR0FBRztBQUNIOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9jb21wb25lbnRzL1ZpZGVvUGxheWVyL1ZpZGVvUGxheWVyTW9iaWxlLm1vZHVsZS5jc3M/YzYwYiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgYXBpID0gcmVxdWlyZShcIiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LXN0eWxlLWxvYWRlci9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qc1wiKTtcbiAgICAgICAgICAgIHZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvY3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbM10ub25lT2ZbNF0udXNlWzFdIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL3Bvc3Rjc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1szXS5vbmVPZls0XS51c2VbMl0hLi9WaWRlb1BsYXllck1vYmlsZS5tb2R1bGUuY3NzXCIpO1xuXG4gICAgICAgICAgICBjb250ZW50ID0gY29udGVudC5fX2VzTW9kdWxlID8gY29udGVudC5kZWZhdWx0IDogY29udGVudDtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4gICAgICAgICAgICB9XG5cbnZhciBvcHRpb25zID0ge307XG5cbm9wdGlvbnMuaW5zZXJ0ID0gZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIC8vIFRoZXNlIGVsZW1lbnRzIHNob3VsZCBhbHdheXMgZXhpc3QuIElmIHRoZXkgZG8gbm90LFxuICAgICAgICAgICAgICAgIC8vIHRoaXMgY29kZSBzaG91bGQgZmFpbC5cbiAgICAgICAgICAgICAgICB2YXIgYW5jaG9yRWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNfX25leHRfY3NzX19ET19OT1RfVVNFX18nKTtcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50Tm9kZSA9IGFuY2hvckVsZW1lbnQucGFyZW50Tm9kZS8vIE5vcm1hbGx5IDxoZWFkPlxuICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICAvLyBFYWNoIHN0eWxlIHRhZyBzaG91bGQgYmUgcGxhY2VkIHJpZ2h0IGJlZm9yZSBvdXJcbiAgICAgICAgICAgICAgICAvLyBhbmNob3IuIEJ5IGluc2VydGluZyBiZWZvcmUgYW5kIG5vdCBhZnRlciwgd2UgZG8gbm90XG4gICAgICAgICAgICAgICAgLy8gbmVlZCB0byB0cmFjayB0aGUgbGFzdCBpbnNlcnRlZCBlbGVtZW50LlxuICAgICAgICAgICAgICAgIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGVsZW1lbnQsIGFuY2hvckVsZW1lbnQpO1xuICAgICAgICAgICAgfTtcbm9wdGlvbnMuc2luZ2xldG9uID0gZmFsc2U7XG5cbnZhciB1cGRhdGUgPSBhcGkoY29udGVudCwgb3B0aW9ucyk7XG5cblxuaWYgKG1vZHVsZS5ob3QpIHtcbiAgaWYgKCFjb250ZW50LmxvY2FscyB8fCBtb2R1bGUuaG90LmludmFsaWRhdGUpIHtcbiAgICB2YXIgaXNFcXVhbExvY2FscyA9IGZ1bmN0aW9uIGlzRXF1YWxMb2NhbHMoYSwgYiwgaXNOYW1lZEV4cG9ydCkge1xuICAgIGlmICghYSAmJiBiIHx8IGEgJiYgIWIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBsZXQgcDtcbiAgICBmb3IocCBpbiBhKXtcbiAgICAgICAgaWYgKGlzTmFtZWRFeHBvcnQgJiYgcCA9PT0gJ2RlZmF1bHQnKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYVtwXSAhPT0gYltwXSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvcihwIGluIGIpe1xuICAgICAgICBpZiAoaXNOYW1lZEV4cG9ydCAmJiBwID09PSAnZGVmYXVsdCcpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghYVtwXSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcbiAgICB2YXIgb2xkTG9jYWxzID0gY29udGVudC5sb2NhbHM7XG5cbiAgICBtb2R1bGUuaG90LmFjY2VwdChcbiAgICAgIFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1szXS5vbmVPZls0XS51c2VbMV0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvcG9zdGNzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzNdLm9uZU9mWzRdLnVzZVsyXSEuL1ZpZGVvUGxheWVyTW9iaWxlLm1vZHVsZS5jc3NcIixcbiAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL2Nzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzNdLm9uZU9mWzRdLnVzZVsxXSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbM10ub25lT2ZbNF0udXNlWzJdIS4vVmlkZW9QbGF5ZXJNb2JpbGUubW9kdWxlLmNzc1wiKTtcblxuICAgICAgICAgICAgICBjb250ZW50ID0gY29udGVudC5fX2VzTW9kdWxlID8gY29udGVudC5kZWZhdWx0IDogY29udGVudDtcblxuICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKCFpc0VxdWFsTG9jYWxzKG9sZExvY2FscywgY29udGVudC5sb2NhbHMpKSB7XG4gICAgICAgICAgICAgICAgbW9kdWxlLmhvdC5pbnZhbGlkYXRlKCk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBvbGRMb2NhbHMgPSBjb250ZW50LmxvY2FscztcblxuICAgICAgICAgICAgICB1cGRhdGUoY29udGVudCk7XG4gICAgICB9XG4gICAgKVxuICB9XG5cbiAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkge1xuICAgIHVwZGF0ZSgpO1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2FscyB8fCB7fTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/components/VideoPlayer/VideoPlayerMobile.module.css\n");

/***/ }),

/***/ "./src/pages/Watch/Watch.module.css":
/*!******************************************!*\
  !*** ./src/pages/Watch/Watch.module.css ***!
  \******************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("var api = __webpack_require__(/*! !../../../node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js\");\n            var content = __webpack_require__(/*! !!../../../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[1]!../../../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[2]!./Watch.module.css */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[2]!./src/pages/Watch/Watch.module.css\");\n\n            content = content.__esModule ? content.default : content;\n\n            if (typeof content === 'string') {\n              content = [[module.id, content, '']];\n            }\n\nvar options = {};\n\noptions.insert = function(element) {\n                // These elements should always exist. If they do not,\n                // this code should fail.\n                var anchorElement = document.querySelector('#__next_css__DO_NOT_USE__');\n                var parentNode = anchorElement.parentNode// Normally <head>\n                ;\n                // Each style tag should be placed right before our\n                // anchor. By inserting before and not after, we do not\n                // need to track the last inserted element.\n                parentNode.insertBefore(element, anchorElement);\n            };\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\nif (true) {\n  if (!content.locals || module.hot.invalidate) {\n    var isEqualLocals = function isEqualLocals(a, b, isNamedExport) {\n    if (!a && b || a && !b) {\n        return false;\n    }\n    let p;\n    for(p in a){\n        if (isNamedExport && p === 'default') {\n            continue;\n        }\n        if (a[p] !== b[p]) {\n            return false;\n        }\n    }\n    for(p in b){\n        if (isNamedExport && p === 'default') {\n            continue;\n        }\n        if (!a[p]) {\n            return false;\n        }\n    }\n    return true;\n};\n    var oldLocals = content.locals;\n\n    module.hot.accept(\n      /*! !!../../../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[1]!../../../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[2]!./Watch.module.css */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[2]!./src/pages/Watch/Watch.module.css\",\n      function () {\n        content = __webpack_require__(/*! !!../../../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[1]!../../../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[2]!./Watch.module.css */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[2]!./src/pages/Watch/Watch.module.css\");\n\n              content = content.__esModule ? content.default : content;\n\n              if (typeof content === 'string') {\n                content = [[module.id, content, '']];\n              }\n\n              if (!isEqualLocals(oldLocals, content.locals)) {\n                module.hot.invalidate();\n\n                return;\n              }\n\n              oldLocals = content.locals;\n\n              update(content);\n      }\n    )\n  }\n\n  module.hot.dispose(function() {\n    update();\n  });\n}\n\nmodule.exports = content.locals || {};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvcGFnZXMvV2F0Y2gvV2F0Y2gubW9kdWxlLmNzcy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxVQUFVLG1CQUFPLENBQUMsME5BQThHO0FBQ2hJLDBCQUEwQixtQkFBTyxDQUFDLHNnQkFBZ1E7O0FBRWxTOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBLElBQUksSUFBVTtBQUNkLHlCQUF5QixVQUFVO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJLGlCQUFpQjtBQUNyQixNQUFNLHNnQkFBZ1E7QUFDdFE7QUFDQSxrQkFBa0IsbUJBQU8sQ0FBQyxzZ0JBQWdROztBQUUxUjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsVUFBVTs7QUFFMUI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxFQUFFLFVBQVU7QUFDWjtBQUNBLEdBQUc7QUFDSDs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvcGFnZXMvV2F0Y2gvV2F0Y2gubW9kdWxlLmNzcz84ODc5Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBhcGkgPSByZXF1aXJlKFwiIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtc3R5bGUtbG9hZGVyL3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzXCIpO1xuICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1szXS5vbmVPZls0XS51c2VbMV0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvcG9zdGNzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzNdLm9uZU9mWzRdLnVzZVsyXSEuL1dhdGNoLm1vZHVsZS5jc3NcIik7XG5cbiAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50Ll9fZXNNb2R1bGUgPyBjb250ZW50LmRlZmF1bHQgOiBjb250ZW50O1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbiAgICAgICAgICAgIH1cblxudmFyIG9wdGlvbnMgPSB7fTtcblxub3B0aW9ucy5pbnNlcnQgPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlc2UgZWxlbWVudHMgc2hvdWxkIGFsd2F5cyBleGlzdC4gSWYgdGhleSBkbyBub3QsXG4gICAgICAgICAgICAgICAgLy8gdGhpcyBjb2RlIHNob3VsZCBmYWlsLlxuICAgICAgICAgICAgICAgIHZhciBhbmNob3JFbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI19fbmV4dF9jc3NfX0RPX05PVF9VU0VfXycpO1xuICAgICAgICAgICAgICAgIHZhciBwYXJlbnROb2RlID0gYW5jaG9yRWxlbWVudC5wYXJlbnROb2RlLy8gTm9ybWFsbHkgPGhlYWQ+XG4gICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgIC8vIEVhY2ggc3R5bGUgdGFnIHNob3VsZCBiZSBwbGFjZWQgcmlnaHQgYmVmb3JlIG91clxuICAgICAgICAgICAgICAgIC8vIGFuY2hvci4gQnkgaW5zZXJ0aW5nIGJlZm9yZSBhbmQgbm90IGFmdGVyLCB3ZSBkbyBub3RcbiAgICAgICAgICAgICAgICAvLyBuZWVkIHRvIHRyYWNrIHRoZSBsYXN0IGluc2VydGVkIGVsZW1lbnQuXG4gICAgICAgICAgICAgICAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZWxlbWVudCwgYW5jaG9yRWxlbWVudCk7XG4gICAgICAgICAgICB9O1xub3B0aW9ucy5zaW5nbGV0b24gPSBmYWxzZTtcblxudmFyIHVwZGF0ZSA9IGFwaShjb250ZW50LCBvcHRpb25zKTtcblxuXG5pZiAobW9kdWxlLmhvdCkge1xuICBpZiAoIWNvbnRlbnQubG9jYWxzIHx8IG1vZHVsZS5ob3QuaW52YWxpZGF0ZSkge1xuICAgIHZhciBpc0VxdWFsTG9jYWxzID0gZnVuY3Rpb24gaXNFcXVhbExvY2FscyhhLCBiLCBpc05hbWVkRXhwb3J0KSB7XG4gICAgaWYgKCFhICYmIGIgfHwgYSAmJiAhYikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGxldCBwO1xuICAgIGZvcihwIGluIGEpe1xuICAgICAgICBpZiAoaXNOYW1lZEV4cG9ydCAmJiBwID09PSAnZGVmYXVsdCcpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhW3BdICE9PSBiW3BdKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yKHAgaW4gYil7XG4gICAgICAgIGlmIChpc05hbWVkRXhwb3J0ICYmIHAgPT09ICdkZWZhdWx0Jykge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFhW3BdKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuICAgIHZhciBvbGRMb2NhbHMgPSBjb250ZW50LmxvY2FscztcblxuICAgIG1vZHVsZS5ob3QuYWNjZXB0KFxuICAgICAgXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL2Nzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzNdLm9uZU9mWzRdLnVzZVsxXSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbM10ub25lT2ZbNF0udXNlWzJdIS4vV2F0Y2gubW9kdWxlLmNzc1wiLFxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvY3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbM10ub25lT2ZbNF0udXNlWzFdIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL3Bvc3Rjc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1szXS5vbmVPZls0XS51c2VbMl0hLi9XYXRjaC5tb2R1bGUuY3NzXCIpO1xuXG4gICAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50Ll9fZXNNb2R1bGUgPyBjb250ZW50LmRlZmF1bHQgOiBjb250ZW50O1xuXG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoIWlzRXF1YWxMb2NhbHMob2xkTG9jYWxzLCBjb250ZW50LmxvY2FscykpIHtcbiAgICAgICAgICAgICAgICBtb2R1bGUuaG90LmludmFsaWRhdGUoKTtcblxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIG9sZExvY2FscyA9IGNvbnRlbnQubG9jYWxzO1xuXG4gICAgICAgICAgICAgIHVwZGF0ZShjb250ZW50KTtcbiAgICAgIH1cbiAgICApXG4gIH1cblxuICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7XG4gICAgdXBkYXRlKCk7XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzIHx8IHt9OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/pages/Watch/Watch.module.css\n");

/***/ }),

/***/ "./src/components/Loading/index.js":
/*!*****************************************!*\
  !*** ./src/components/Loading/index.js ***!
  \*****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Loading; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _loading_module_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./loading.module.css */ \"./src/components/Loading/loading.module.css\");\n/* harmony import */ var _loading_module_css__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_loading_module_css__WEBPACK_IMPORTED_MODULE_1__);\n\n\nfunction Loading(param) {\n    var w = param.w, h = param.h, c = param.c;\n    var color = c ? c : \"#ffff\";\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            style: {\n                width: w,\n                height: h\n            },\n            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: (_loading_module_css__WEBPACK_IMPORTED_MODULE_1___default().profile_main_loader),\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: (_loading_module_css__WEBPACK_IMPORTED_MODULE_1___default().loader),\n                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"svg\", {\n                        className: (_loading_module_css__WEBPACK_IMPORTED_MODULE_1___default().circular_loader),\n                        viewBox: \"25 25 50 50\",\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"circle\", {\n                            className: (_loading_module_css__WEBPACK_IMPORTED_MODULE_1___default().loader_path),\n                            cx: \"50\",\n                            cy: \"50\",\n                            r: \"20\",\n                            fill: \"none\",\n                            stroke: color,\n                            strokeWidth: \"4\"\n                        }, void 0, false, {\n                            fileName: \"/home/isolated/rakazone/rakazone-frontend/src/components/Loading/index.js\",\n                            lineNumber: 9,\n                            columnNumber: 25\n                        }, this)\n                    }, void 0, false, {\n                        fileName: \"/home/isolated/rakazone/rakazone-frontend/src/components/Loading/index.js\",\n                        lineNumber: 8,\n                        columnNumber: 21\n                    }, this)\n                }, void 0, false, {\n                    fileName: \"/home/isolated/rakazone/rakazone-frontend/src/components/Loading/index.js\",\n                    lineNumber: 7,\n                    columnNumber: 17\n                }, this)\n            }, void 0, false, {\n                fileName: \"/home/isolated/rakazone/rakazone-frontend/src/components/Loading/index.js\",\n                lineNumber: 6,\n                columnNumber: 13\n            }, this)\n        }, void 0, false, {\n            fileName: \"/home/isolated/rakazone/rakazone-frontend/src/components/Loading/index.js\",\n            lineNumber: 5,\n            columnNumber: 9\n        }, this)\n    }, void 0, false);\n};\n_c = Loading;\nvar _c;\n$RefreshReg$(_c, \"Loading\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29tcG9uZW50cy9Mb2FkaW5nL2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFBc0M7QUFDdkIsU0FBU0MsT0FBTyxDQUFDLEtBQVcsRUFBRTtRQUFYQyxDQUFDLEdBQUgsS0FBVyxDQUFUQSxDQUFDLEVBQUVDLENBQUMsR0FBTixLQUFXLENBQU5BLENBQUMsRUFBRUMsQ0FBQyxHQUFULEtBQVcsQ0FBSEEsQ0FBQztJQUNyQyxJQUFJQyxLQUFLLEdBQUdELENBQUMsR0FBR0EsQ0FBQyxHQUFHLE9BQU87SUFDM0IscUJBQU87a0JBQ0gsNEVBQUNFLEtBQUc7WUFBQ0MsS0FBSyxFQUFFO2dCQUFFQyxLQUFLLEVBQUVOLENBQUM7Z0JBQUVPLE1BQU0sRUFBRU4sQ0FBQzthQUFFO3NCQUMvQiw0RUFBQ0csS0FBRztnQkFBQ0ksU0FBUyxFQUFFVixnRkFBdUI7MEJBQ25DLDRFQUFDTSxLQUFHO29CQUFDSSxTQUFTLEVBQUVWLG1FQUFVOzhCQUN0Qiw0RUFBQ2EsS0FBRzt3QkFBQ0gsU0FBUyxFQUFFViw0RUFBbUI7d0JBQUVlLE9BQU8sRUFBQyxhQUFhO2tDQUN0RCw0RUFBQ0MsUUFBTTs0QkFBQ04sU0FBUyxFQUFFVix3RUFBZTs0QkFBRWtCLEVBQUUsRUFBQyxJQUFJOzRCQUFDQyxFQUFFLEVBQUMsSUFBSTs0QkFBQ0MsQ0FBQyxFQUFDLElBQUk7NEJBQUNDLElBQUksRUFBQyxNQUFNOzRCQUFDQyxNQUFNLEVBQUVqQixLQUFLOzRCQUFFa0IsV0FBVyxFQUFDLEdBQUc7Ozs7O2dDQUFHOzs7Ozs0QkFDdEc7Ozs7O3dCQUNKOzs7OztvQkFDSjs7Ozs7Z0JBQ0o7cUJBQ1A7Q0FDTjtBQWJ1QnRCLEtBQUFBLE9BQU8iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbXBvbmVudHMvTG9hZGluZy9pbmRleC5qcz9kNDM2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBjc3MgZnJvbSBcIi4vbG9hZGluZy5tb2R1bGUuY3NzXCJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIExvYWRpbmcoeyB3LCBoLCBjIH0pIHtcbiAgICBsZXQgY29sb3IgPSBjID8gYyA6IFwiI2ZmZmZcIlxuICAgIHJldHVybiA8PlxuICAgICAgICA8ZGl2IHN0eWxlPXt7IHdpZHRoOiB3LCBoZWlnaHQ6IGggfX0+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17Y3NzLnByb2ZpbGVfbWFpbl9sb2FkZXJ9PlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtjc3MubG9hZGVyfT5cbiAgICAgICAgICAgICAgICAgICAgPHN2ZyBjbGFzc05hbWU9e2Nzcy5jaXJjdWxhcl9sb2FkZXJ9IHZpZXdCb3g9XCIyNSAyNSA1MCA1MFwiID5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxjaXJjbGUgY2xhc3NOYW1lPXtjc3MubG9hZGVyX3BhdGh9IGN4PVwiNTBcIiBjeT1cIjUwXCIgcj1cIjIwXCIgZmlsbD1cIm5vbmVcIiBzdHJva2U9e2NvbG9yfSBzdHJva2VXaWR0aD1cIjRcIiAvPlxuICAgICAgICAgICAgICAgICAgICA8L3N2Zz5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICA8Lz5cbn0iXSwibmFtZXMiOlsiY3NzIiwiTG9hZGluZyIsInciLCJoIiwiYyIsImNvbG9yIiwiZGl2Iiwic3R5bGUiLCJ3aWR0aCIsImhlaWdodCIsImNsYXNzTmFtZSIsInByb2ZpbGVfbWFpbl9sb2FkZXIiLCJsb2FkZXIiLCJzdmciLCJjaXJjdWxhcl9sb2FkZXIiLCJ2aWV3Qm94IiwiY2lyY2xlIiwibG9hZGVyX3BhdGgiLCJjeCIsImN5IiwiciIsImZpbGwiLCJzdHJva2UiLCJzdHJva2VXaWR0aCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/components/Loading/index.js\n");

/***/ }),

/***/ "./src/components/Modal/donate.modal.js":
/*!**********************************************!*\
  !*** ./src/components/Modal/donate.modal.js ***!
  \**********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ DonateModal; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _Modal_module_css__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Modal.module.css */ \"./src/components/Modal/Modal.module.css\");\n/* harmony import */ var _Modal_module_css__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_Modal_module_css__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _Buttons__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Buttons */ \"./src/components/Buttons/index.js\");\nfunction _objectWithoutProperties(source, excluded) {\n    if (source == null) return {};\n    var target = _objectWithoutPropertiesLoose(source, excluded);\n    var key, i;\n    if (Object.getOwnPropertySymbols) {\n        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n        for(i = 0; i < sourceSymbolKeys.length; i++){\n            key = sourceSymbolKeys[i];\n            if (excluded.indexOf(key) >= 0) continue;\n            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    var sourceKeys = Object.keys(source);\n    var key, i;\n    for(i = 0; i < sourceKeys.length; i++){\n        key = sourceKeys[i];\n        if (excluded.indexOf(key) >= 0) continue;\n        target[key] = source[key];\n    }\n    return target;\n}\n\n\n\n\nvar _s = $RefreshSig$();\nfunction DonateModal(_param) {\n    var onClose = _param.onClose, whatToShow = _param.whatToShow, props = _objectWithoutProperties(_param, [\n        \"onClose\",\n        \"whatToShow\"\n    ]);\n    _s();\n    var ref = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(props.show), show = ref[0], setShow = ref[1];\n    var modal = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    var closeHandler = function() {\n        setShow(false);\n        setTimeout(function() {\n            onClose();\n        }, 500);\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function() {\n        if (modal.current) {\n            modal.current.addEventListener(\"click\", function(e) {\n                if (e.target === modal.current) {\n                    closeHandler();\n                }\n            });\n        }\n        setShow(props.show);\n        return function() {};\n    }, [\n        props.show\n    ]);\n    var title = \"Sponser Me\";\n    var message = '\\uD83D\\uDCB2 UPI \\u2022 rakazonegaming@oksbi <br/> \\uD83D\\uDCB2 Sponsor \\u2022 <a href=\"https://raka.zone/join\" target=\"_blank\"> raka.zone/join </a> <br/> \\uD83D\\uDCB2 Donation Via PayPal \\u2022 <a href=\"https://raka.zone/paypal\" target=\"_blank\">raka.zone/paypal </a> <br/>  <br/> <div style=\"text-align:center\"> Every Tip Is Appreciated \\uD83D\\uDE4F </div>';\n    var button = \"Later\";\n    if (props.show === false) return null;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            className: (_Modal_module_css__WEBPACK_IMPORTED_MODULE_3___default().modal),\n            ref: modal,\n            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"\".concat((_Modal_module_css__WEBPACK_IMPORTED_MODULE_3___default().modal_container), \" \").concat(show && (_Modal_module_css__WEBPACK_IMPORTED_MODULE_3___default().show_modal)),\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: (_Modal_module_css__WEBPACK_IMPORTED_MODULE_3___default().modal_content),\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: (_Modal_module_css__WEBPACK_IMPORTED_MODULE_3___default().modal_title),\n                            children: title\n                        }, void 0, false, {\n                            fileName: \"/home/isolated/rakazone/rakazone-frontend/src/components/Modal/donate.modal.js\",\n                            lineNumber: 40,\n                            columnNumber: 25\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: (_Modal_module_css__WEBPACK_IMPORTED_MODULE_3___default().message_wrapper),\n                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: (_Modal_module_css__WEBPACK_IMPORTED_MODULE_3___default().modal_message),\n                                dangerouslySetInnerHTML: {\n                                    __html: message\n                                }\n                            }, void 0, false, {\n                                fileName: \"/home/isolated/rakazone/rakazone-frontend/src/components/Modal/donate.modal.js\",\n                                lineNumber: 42,\n                                columnNumber: 29\n                            }, this)\n                        }, void 0, false, {\n                            fileName: \"/home/isolated/rakazone/rakazone-frontend/src/components/Modal/donate.modal.js\",\n                            lineNumber: 41,\n                            columnNumber: 25\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: (_Modal_module_css__WEBPACK_IMPORTED_MODULE_3___default().modal_buttons),\n                            onClick: function() {\n                                return closeHandler();\n                            },\n                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_Buttons__WEBPACK_IMPORTED_MODULE_2__.Primary, {\n                                text: button\n                            }, void 0, false, {\n                                fileName: \"/home/isolated/rakazone/rakazone-frontend/src/components/Modal/donate.modal.js\",\n                                lineNumber: 45,\n                                columnNumber: 29\n                            }, this)\n                        }, void 0, false, {\n                            fileName: \"/home/isolated/rakazone/rakazone-frontend/src/components/Modal/donate.modal.js\",\n                            lineNumber: 44,\n                            columnNumber: 25\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"/home/isolated/rakazone/rakazone-frontend/src/components/Modal/donate.modal.js\",\n                    lineNumber: 39,\n                    columnNumber: 21\n                }, this)\n            }, void 0, false, {\n                fileName: \"/home/isolated/rakazone/rakazone-frontend/src/components/Modal/donate.modal.js\",\n                lineNumber: 38,\n                columnNumber: 17\n            }, this)\n        }, void 0, false, {\n            fileName: \"/home/isolated/rakazone/rakazone-frontend/src/components/Modal/donate.modal.js\",\n            lineNumber: 37,\n            columnNumber: 13\n        }, this)\n    }, void 0, false);\n};\n_s(DonateModal, \"rCPHGRK8kkxSRkR40i3L/g5DFvI=\");\n_c = DonateModal;\nvar _c;\n$RefreshReg$(_c, \"DonateModal\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29tcG9uZW50cy9Nb2RhbC9kb25hdGUubW9kYWwuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUEwRDtBQUN0QjtBQUNBOztBQUVyQixTQUFTTSxXQUFXLENBQUMsTUFBaUMsRUFBRTtRQUFqQ0MsT0FBTyxHQUFULE1BQWlDLENBQS9CQSxPQUFPLEVBQUVDLFVBQVUsR0FBckIsTUFBaUMsQ0FBdEJBLFVBQVUsRUFBS0MsS0FBSyw0QkFBL0IsTUFBaUM7UUFBL0JGLFNBQU87UUFBRUMsWUFBVTs7O0lBQ3JELElBQXdCUCxHQUFvQixHQUFwQkEsK0NBQVEsQ0FBQ1EsS0FBSyxDQUFDQyxJQUFJLENBQUMsRUFMaEQsSUFLZSxHQUFhVCxHQUFvQixHQUFqQyxFQUxmLE9BS3dCLEdBQUlBLEdBQW9CLEdBQXhCO0lBQ3BCLElBQU1XLEtBQUssR0FBR1QsNkNBQU0sQ0FBQyxJQUFJLENBQUM7SUFDMUIsSUFBTVUsWUFBWSxHQUFHLFdBQU07UUFDdkJGLE9BQU8sQ0FBQyxLQUFLLENBQUM7UUFDZEcsVUFBVSxDQUFDLFdBQU07WUFDYlAsT0FBTyxFQUFFO1NBQ1osRUFBRSxHQUFHLENBQUM7S0FDVjtJQUNETCxnREFBUyxDQUFDLFdBQU07UUFDWixJQUFJVSxLQUFLLENBQUNHLE9BQU8sRUFBRTtZQUNmSCxLQUFLLENBQUNHLE9BQU8sQ0FBQ0MsZ0JBQWdCLENBQUMsT0FBTyxFQUFFLFNBQUNDLENBQUMsRUFBSztnQkFDM0MsSUFBSUEsQ0FBQyxDQUFDQyxNQUFNLEtBQUtOLEtBQUssQ0FBQ0csT0FBTyxFQUFFO29CQUM1QkYsWUFBWSxFQUFFO2lCQUNqQjthQUNKLENBQUM7U0FDTDtRQUVERixPQUFPLENBQUNGLEtBQUssQ0FBQ0MsSUFBSSxDQUFDO1FBQ25CLE9BQU8sV0FBTSxFQUNaO0tBQ0osRUFBRTtRQUFDRCxLQUFLLENBQUNDLElBQUk7S0FBQyxDQUFDO0lBR2hCLElBQU1TLEtBQUssR0FBRyxZQUFZO0lBQzFCLElBQU1DLE9BQU8sR0FBSSx1V0FBMFM7SUFDM1QsSUFBTUMsTUFBTSxHQUFHLE9BQU87SUFFdEIsSUFBSVosS0FBSyxDQUFDQyxJQUFJLEtBQUssS0FBSyxFQUFFLE9BQU8sSUFBSTtJQUVyQyxxQkFDSTtrQkFDSSw0RUFBQ1ksS0FBRztZQUFDQyxTQUFTLEVBQUVuQixnRUFBUztZQUFFb0IsR0FBRyxFQUFFWixLQUFLO3NCQUNqQyw0RUFBQ1UsS0FBRztnQkFBQ0MsU0FBUyxFQUFFLEVBQUMsQ0FBeUJiLE1BQXNCLENBQTdDTiwwRUFBbUIsRUFBQyxHQUFDLENBQXlCLFFBQXZCTSxJQUFJLElBQUlOLHFFQUFjLENBQUU7MEJBQzlELDRFQUFDa0IsS0FBRztvQkFBQ0MsU0FBUyxFQUFFbkIsd0VBQWlCOztzQ0FDN0IsOERBQUNrQixLQUFHOzRCQUFDQyxTQUFTLEVBQUVuQixzRUFBZTtzQ0FBR2UsS0FBSzs7Ozs7Z0NBQU87c0NBQzlDLDhEQUFDRyxLQUFHOzRCQUFDQyxTQUFTLEVBQUVuQiwwRUFBbUI7c0NBQy9CLDRFQUFDa0IsS0FBRztnQ0FBQ0MsU0FBUyxFQUFFbkIsd0VBQWlCO2dDQUFFMkIsdUJBQXVCLEVBQUU7b0NBQUVDLE1BQU0sRUFBRVosT0FBTztpQ0FBRTs7Ozs7b0NBQVE7Ozs7O2dDQUNyRjtzQ0FDTiw4REFBQ0UsS0FBRzs0QkFBQ0MsU0FBUyxFQUFFbkIsd0VBQWlCOzRCQUFFOEIsT0FBTyxFQUFFO3VDQUFNckIsWUFBWSxFQUFFOzZCQUFBO3NDQUM1RCw0RUFBQ1IsNkNBQU87Z0NBQUM4QixJQUFJLEVBQUVkLE1BQU07Ozs7O29DQUFJOzs7OztnQ0FDdkI7Ozs7Ozt3QkFDSjs7Ozs7b0JBQ0o7Ozs7O2dCQUNKO3FCQUNQLENBQ047Q0FDSjtHQS9DdUJmLFdBQVc7QUFBWEEsS0FBQUEsV0FBVyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvY29tcG9uZW50cy9Nb2RhbC9kb25hdGUubW9kYWwuanM/Mjk4MCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgcmVhY3QsIHsgdXNlU3RhdGUsIHVzZUVmZmVjdCwgdXNlUmVmIH0gZnJvbSBcInJlYWN0XCJcbmltcG9ydCBjc3MgZnJvbSBcIi4vTW9kYWwubW9kdWxlLmNzc1wiXG5pbXBvcnQgeyBQcmltYXJ5IH0gZnJvbSBcIi4uL0J1dHRvbnNcIlxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBEb25hdGVNb2RhbCh7IG9uQ2xvc2UsIHdoYXRUb1Nob3csIC4uLnByb3BzIH0pIHtcbiAgICBjb25zdCBbc2hvdywgc2V0U2hvd10gPSB1c2VTdGF0ZShwcm9wcy5zaG93KVxuICAgIGNvbnN0IG1vZGFsID0gdXNlUmVmKG51bGwpXG4gICAgY29uc3QgY2xvc2VIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgICBzZXRTaG93KGZhbHNlKVxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIG9uQ2xvc2UoKVxuICAgICAgICB9LCA1MDApXG4gICAgfVxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChtb2RhbC5jdXJyZW50KSB7XG4gICAgICAgICAgICBtb2RhbC5jdXJyZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAoZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlLnRhcmdldCA9PT0gbW9kYWwuY3VycmVudCkge1xuICAgICAgICAgICAgICAgICAgICBjbG9zZUhhbmRsZXIoKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICBzZXRTaG93KHByb3BzLnNob3cpXG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIH1cbiAgICB9LCBbcHJvcHMuc2hvd10pXG5cblxuICAgIGNvbnN0IHRpdGxlID0gXCJTcG9uc2VyIE1lXCJcbiAgICBjb25zdCBtZXNzYWdlID0gYPCfkrIgVVBJIOKAoiByYWthem9uZWdhbWluZ0Bva3NiaSA8YnIvPiDwn5KyIFNwb25zb3Ig4oCiIDxhIGhyZWY9XCJodHRwczovL3Jha2Euem9uZS9qb2luXCIgdGFyZ2V0PVwiX2JsYW5rXCI+IHJha2Euem9uZS9qb2luIDwvYT4gPGJyLz4g8J+SsiBEb25hdGlvbiBWaWEgUGF5UGFsIOKAoiA8YSBocmVmPVwiaHR0cHM6Ly9yYWthLnpvbmUvcGF5cGFsXCIgdGFyZ2V0PVwiX2JsYW5rXCI+cmFrYS56b25lL3BheXBhbCA8L2E+IDxici8+ICA8YnIvPiA8ZGl2IHN0eWxlPVwidGV4dC1hbGlnbjpjZW50ZXJcIj4gRXZlcnkgVGlwIElzIEFwcHJlY2lhdGVkIPCfmY8gPC9kaXY+YFxuICAgIGNvbnN0IGJ1dHRvbiA9IFwiTGF0ZXJcIlxuXG4gICAgaWYgKHByb3BzLnNob3cgPT09IGZhbHNlKSByZXR1cm4gbnVsbFxuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPD5cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtjc3MubW9kYWx9IHJlZj17bW9kYWx9ID5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17YCR7Y3NzLm1vZGFsX2NvbnRhaW5lcn0gJHtzaG93ICYmIGNzcy5zaG93X21vZGFsfWB9PlxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17Y3NzLm1vZGFsX2NvbnRlbnR9PlxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Nzcy5tb2RhbF90aXRsZX0+e3RpdGxlfTwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Nzcy5tZXNzYWdlX3dyYXBwZXJ9PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtjc3MubW9kYWxfbWVzc2FnZX0gZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw9e3sgX19odG1sOiBtZXNzYWdlIH19PjwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17Y3NzLm1vZGFsX2J1dHRvbnN9IG9uQ2xpY2s9eygpID0+IGNsb3NlSGFuZGxlcigpfT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8UHJpbWFyeSB0ZXh0PXtidXR0b259IC8+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC8+XG4gICAgKVxufSJdLCJuYW1lcyI6WyJyZWFjdCIsInVzZVN0YXRlIiwidXNlRWZmZWN0IiwidXNlUmVmIiwiY3NzIiwiUHJpbWFyeSIsIkRvbmF0ZU1vZGFsIiwib25DbG9zZSIsIndoYXRUb1Nob3ciLCJwcm9wcyIsInNob3ciLCJzZXRTaG93IiwibW9kYWwiLCJjbG9zZUhhbmRsZXIiLCJzZXRUaW1lb3V0IiwiY3VycmVudCIsImFkZEV2ZW50TGlzdGVuZXIiLCJlIiwidGFyZ2V0IiwidGl0bGUiLCJtZXNzYWdlIiwiYnV0dG9uIiwiZGl2IiwiY2xhc3NOYW1lIiwicmVmIiwibW9kYWxfY29udGFpbmVyIiwic2hvd19tb2RhbCIsIm1vZGFsX2NvbnRlbnQiLCJtb2RhbF90aXRsZSIsIm1lc3NhZ2Vfd3JhcHBlciIsIm1vZGFsX21lc3NhZ2UiLCJkYW5nZXJvdXNseVNldElubmVySFRNTCIsIl9faHRtbCIsIm1vZGFsX2J1dHRvbnMiLCJvbkNsaWNrIiwidGV4dCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/components/Modal/donate.modal.js\n");

/***/ }),

/***/ "./src/components/VideoPlayer/Desktop.js":
/*!***********************************************!*\
  !*** ./src/components/VideoPlayer/Desktop.js ***!
  \***********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"VideoPlayerDesktop\": function() { return /* binding */ VideoPlayerDesktop; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _VideoPlayerDesktop_module_css__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./VideoPlayerDesktop.module.css */ \"./src/components/VideoPlayer/VideoPlayerDesktop.module.css\");\n/* harmony import */ var _VideoPlayerDesktop_module_css__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(_VideoPlayerDesktop_module_css__WEBPACK_IMPORTED_MODULE_8__);\n/* harmony import */ var _handler_toast_handler_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../handler/toast.handler.js */ \"./src/handler/toast.handler.js\");\n/* harmony import */ var next_image_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! next/image.js */ \"./node_modules/next/image.js\");\n/* harmony import */ var next_image_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(next_image_js__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _assets_img_png_insta07_png__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../assets/img/png/insta07.png */ \"./src/assets/img/png/insta07.png\");\n/* harmony import */ var _util_functions_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../util/functions.js */ \"./src/util/functions.js\");\n/* harmony import */ var _Loading__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../Loading */ \"./src/components/Loading/index.js\");\n/* harmony import */ var hls_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! hls.js */ \"./node_modules/hls.js/dist/hls.js\");\n/* harmony import */ var hls_js__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(hls_js__WEBPACK_IMPORTED_MODULE_7__);\nfunction _defineProperty(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _objectSpread(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        var ownKeys = Object.keys(source);\n        if (typeof Object.getOwnPropertySymbols === \"function\") {\n            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n            }));\n        }\n        ownKeys.forEach(function(key) {\n            _defineProperty(target, key, source[key]);\n        });\n    }\n    return target;\n}\n\n\n\n\n\n\n\n\n\n\nvar _s = $RefreshSig$();\nfunction VideoPlayerDesktop(props) {\n    var _this = this;\n    _s();\n    var src1 = \"https://keviv.xyz/api/downloads/output/\".concat(props.videoId, \"/HLS/playlist.m3u8\");\n    var adSrc = \"https://keviv.xyz/api/downloads/SampleAd/playlist.m3u8\";\n    var playbackSpeedsList = [\n        0.5,\n        0.75,\n        1,\n        1.25,\n        1.5,\n        1.75,\n        2\n    ];\n    // Controller for the video\n    var videoPlayer = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    var videoController = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    var volumeController = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    var timelineController = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    // States\n    var ref14 = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false), isPlaying = ref14[0], setIsPlaying = ref14[1];\n    var ref1 = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false), showVolume = ref1[0], setShowVolume = ref1[1];\n    var ref2 = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false), fullscreen = ref2[0], setFullscreen = ref2[1];\n    var ref3 = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false), playingAd = ref3[0], setPlayingAd = ref3[1];\n    var ref4 = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false), theaterMode = ref4[0], setTheaterMode = ref4[1];\n    var ref5 = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false), showEndScreen = ref5[0], setShowEndScreen = ref5[1];\n    var ref6 = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false), showSettings = ref6[0], setShowSettings = ref6[1];\n    var ref7 = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false), loading = ref7[0], setLoading = ref7[1];\n    var ref8 = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n        currentDuration: 0,\n        totalDuration: 0,\n        percentage: 0\n    }), duration = ref8[0], setDuration = ref8[1];\n    var ref9 = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n        volumeLevel: 50,\n        volume_icon: \"volume_up\",\n        lastVolume: 0\n    }), volume1 = ref9[0], setVolume = ref9[1];\n    var ref10 = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false), settingsShowQuality = ref10[0], setSettingsShowQuality = ref10[1];\n    var ref11 = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false), settingsShowSpeed = ref11[0], setSettingsShowSpeed = ref11[1];\n    var ref12 = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"auto\"), quality = ref12[0], setQuality = ref12[1];\n    var ref13 = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]), levels = ref13[0], setLevels = ref13[1];\n    // Functions\n    var handleTheaterMode = function() {\n        setTheaterMode(!theaterMode);\n    };\n    var handleSettings = function() {\n        if (showSettings) {\n            setSettingsShowQuality(false);\n            setSettingsShowSpeed(false);\n            setShowSettings(false);\n        } else {\n            setShowSettings(true);\n        }\n    };\n    var handleQualitySelect = function(q) {\n        handleSettings();\n        setQuality(q);\n    };\n    var handleSpeedSelect = function(s) {\n        handleSettings();\n        videoController.current.playbackRate = s;\n    };\n    var calculateVolume = function(click, elm) {\n        var volume_width = elm.offsetWidth;\n        var click_x = click.clientX - elm.getBoundingClientRect().left;\n        var volume = (click_x / volume_width * 100).toFixed(0);\n        return volume;\n    };\n    var handleFullScreen = function() {\n        if (document.fullscreenElement != null) {\n            setFullscreen(false);\n            return document.exitFullscreen();\n        } else {\n            if (videoPlayer.current.requestFullscreen) {\n                videoPlayer.current.requestFullscreen();\n            } else if (videoPlayer.current.webkitRequestFullscreen) {\n                videoPlayer.current.webkitRequestFullscreen();\n            } else if (videoPlayer.current.mozRequestFullScreen) {\n                videoPlayer.current.mozRequestFullScreen();\n            } else if (videoPlayer.current.msRequestFullscreen) {\n                videoPlayer.current.msRequestFullscreen();\n            }\n            setFullscreen(true);\n        }\n    };\n    var handlePictureInPicture = function() {\n        if (document.pictureInPictureElement != null) {\n            document.exitPictureInPicture();\n        } else {\n            videoController.current.requestPictureInPicture();\n        }\n    };\n    var handleMute = function() {\n        if (videoController.current.muted) {\n            videoController.current.muted = false;\n            setVolume({\n                volumeLevel: volume1.lastVolume * 100,\n                volume_icon: \"volume_down\"\n            });\n        } else {\n            videoController.current.muted = true;\n            setVolume({\n                volumeLevel: 0,\n                volume_icon: \"volume_off\",\n                lastVolume: videoController.current.volume\n            });\n        }\n    };\n    var handlePlayPause = function() {\n        if (showSettings) return handleSettings();\n        if (videoController.current.paused) {\n            setIsPlaying(true);\n            videoController.current.play();\n        } else {\n            setIsPlaying(false);\n            videoController.current.pause();\n        }\n    };\n    var handleVolume = function() {\n        document.removeEventListener(\"mousemove\", handleVolumeSlider);\n        document.removeEventListener(\"mouseup\", handleVolume);\n    };\n    var handleTimeline = function() {\n        document.removeEventListener(\"mousemove\", handleTimelineSlider);\n        document.removeEventListener(\"mouseup\", handleTimeline);\n    };\n    var handleVolumeSlider = function(e) {\n        setShowVolume(true);\n        e.preventDefault();\n        var slider = document.getElementsByClassName((_VideoPlayerDesktop_module_css__WEBPACK_IMPORTED_MODULE_8___default().volume_slider))[0];\n        var percent = calculateVolume(e, slider);\n        if (percent < 0) {\n            percent = 0;\n        } else if (percent > 100) {\n            percent = 100;\n        }\n        var volume_icon = percent > 70 ? \"volume_up\" : percent > 40 ? \"volume_down\" : percent == 0 ? \"volume_off\" : \"volume_down\";\n        videoController.current.volume = percent / 100;\n        setVolume({\n            volumeLevel: percent,\n            volume_icon: volume_icon\n        });\n    };\n    var handleTimelineSlider = function(e) {\n        e.preventDefault();\n        var slider = document.getElementsByClassName((_VideoPlayerDesktop_module_css__WEBPACK_IMPORTED_MODULE_8___default().timeline_slider))[0];\n        var percent = calculateVolume(e, slider);\n        if (percent < 0) {\n            percent = 0;\n        } else if (percent > 100) {\n            percent = 100;\n        }\n        videoController.current.currentTime = percent / 100 * videoController.current.duration;\n        setDuration({\n            currentDuration: (0,_util_functions_js__WEBPACK_IMPORTED_MODULE_5__.formatDuration)(videoController.current.currentTime),\n            totalDuration: (0,_util_functions_js__WEBPACK_IMPORTED_MODULE_5__.formatDuration)(videoController.current.duration),\n            percentage: percent\n        });\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function() {\n        // Event Listeners\n        videoController.current.addEventListener(\"play\", function() {\n            setIsPlaying(true);\n        });\n        videoController.current.addEventListener(\"durationchange\", function() {\n            if (playingAd) return;\n            setDuration({\n                currentDuration: (0,_util_functions_js__WEBPACK_IMPORTED_MODULE_5__.formatDuration)(videoController.current.currentTime),\n                totalDuration: (0,_util_functions_js__WEBPACK_IMPORTED_MODULE_5__.formatDuration)(videoController.current.duration),\n                percentage: 0\n            });\n        });\n        videoController.current.addEventListener(\"timeupdate\", function() {\n            if (playingAd) return;\n            setLoading(false);\n            setDuration({\n                currentDuration: (0,_util_functions_js__WEBPACK_IMPORTED_MODULE_5__.formatDuration)(videoController.current.currentTime),\n                totalDuration: (0,_util_functions_js__WEBPACK_IMPORTED_MODULE_5__.formatDuration)(videoController.current.duration),\n                percentage: videoController.current.currentTime / videoController.current.duration * 100\n            });\n        });\n        videoController.current.addEventListener(\"loadeddata\", function() {\n            var ref;\n            setLoading(false);\n            // videoController.current.volume = 50 / 100\n            if (!((ref = videoController.current) === null || ref === void 0 ? void 0 : ref.currentTime)) return;\n            setDuration({\n                currentDuration: (0,_util_functions_js__WEBPACK_IMPORTED_MODULE_5__.formatDuration)(videoController.current.currentTime),\n                totalDuration: (0,_util_functions_js__WEBPACK_IMPORTED_MODULE_5__.formatDuration)(videoController.current.duration),\n                percentage: videoController.current.currentTime / videoController.current.duration * 100\n            });\n        });\n        // Volume Controller\n        volumeController.current.addEventListener(\"mousedown\", function(e) {\n            document.addEventListener(\"mousemove\", handleVolumeSlider);\n            document.addEventListener(\"mouseup\", function(e) {\n                return handleVolume();\n            });\n        });\n        volumeController.current.addEventListener(\"click\", function(e) {\n            handleVolumeSlider(e);\n        });\n        // timeline Controller\n        timelineController.current.addEventListener(\"mousedown\", function(e) {\n            if (playingAd) return;\n            document.addEventListener(\"mousemove\", handleTimelineSlider);\n            document.addEventListener(\"mouseup\", function(e) {\n                return handleTimeline();\n            });\n        });\n        timelineController.current.addEventListener(\"click\", function(e) {\n            if (playingAd) return;\n            handleTimelineSlider(e);\n        });\n        // videoController.current.addEventListener(\"ended\", () => {\n        //     setIsPlaying(false)\n        //     toastService.success(\"Video ended\")\n        // })\n        videoController.current.addEventListener(\"waiting\", function() {\n            setLoading(true);\n        });\n        videoController.current.addEventListener(\"dblclick\", function(e) {\n            if (showSettings) setShowSettings(false);\n            if (e.target.classList.contains((_VideoPlayerDesktop_module_css__WEBPACK_IMPORTED_MODULE_8___default().video))) {\n                handleFullScreen();\n            }\n        });\n        // handle key strokes\n        document.onkeydown = function(e) {\n            if (e.key === \" \") {\n                e.preventDefault();\n                handlePlayPause();\n            } else if (e.key === \"f\") {\n                handleFullScreen();\n            } else if (e.key === \"p\") {\n                handlePictureInPicture();\n            } else if (e.key == 0) {\n                videoController.current.currentTime = 0 / 100 * videoController.current.duration;\n            } else if (e.key == \"m\") {\n                handleMute();\n            }\n        };\n    }, [\n        videoController.current\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function() {\n        // --------------------------------------------------\n        var defaultOptions = {\n            startLevel: -1,\n            licenseXhrSetup: function licenseXhrSetup(xhr, url) {\n                xhr.withCredentials = true // do send cookies\n                ;\n                if (!xhr.readyState) {\n                    // Call open to change the method (default is POST) or modify the url\n                    xhr.open(\"GET\", url, true);\n                    // Append headers after opening\n                    xhr.setRequestHeader(\"Content-Type\", \"application/octet-stream\");\n                }\n            }\n        };\n        var rebuild = function(video, src) {\n            setLoading(true);\n            var hls = new (hls_js__WEBPACK_IMPORTED_MODULE_7___default())(defaultOptions);\n            hls.loadSource(src);\n            hls.attachMedia(video);\n            return hls;\n        };\n        var hls1 = new (hls_js__WEBPACK_IMPORTED_MODULE_7___default())(defaultOptions);\n        var video1 = videoController.current;\n        video1.removeAttribute(\"controls\");\n        video1.autoPlay = true;\n        video1.muted = true;\n        setLoading(true);\n        if (!video1) return;\n        if (video1.canPlayType(\"application/vnd.apple.mpegurl\") && props.isIOS) {\n            video1.removeAttribute(\"controls\");\n            video1.setAttribute(\"webkit-playsinline\", \"\");\n            video1.setAttribute(\"playsinline\", \"\");\n            video1.setAttribute(\"x-webkit-airplay\", \"allow\");\n            video1.setAttribute(\"x5-video-player-type\", \"h5\");\n            video1.setAttribute(\"x5-video-player-fullscreen\", \"false\");\n            video1.setAttribute(\"x5-video-orientation\", \"portraint\");\n            if (adSrc) {\n                setPlayingAd(true);\n                video1.src = adSrc;\n            } else {\n                video1.src = src1;\n            }\n        } else if (hls_js__WEBPACK_IMPORTED_MODULE_7___default().isSupported()) {\n            // This will run in all other modern browsers\n            if (adSrc) {\n                setPlayingAd(true);\n                hls1.loadSource(adSrc);\n            } else {\n                hls1.loadSource(src1);\n            }\n            hls1.attachMedia(video1);\n        } else {\n            console.error(\"This is an old browser that does not support MSE https://developer.mozilla.org/en-US/docs/Web/API/Media_Source_Extensions_API\");\n        }\n        video1.addEventListener(\"ended\", function() {\n            var ref, ref15;\n            if (video1.src === adSrc || ((ref15 = (ref = hls1 === null || hls1 === void 0 ? void 0 : hls1.levels[0]) === null || ref === void 0 ? void 0 : ref.url[0]) === null || ref15 === void 0 ? void 0 : ref15.includes(\"Ad\"))) {\n                setPlayingAd(false);\n                if (video1.canPlayType(\"application/vnd.apple.mpegurl\") && props.isIOS) {\n                    video1.src = src1;\n                } else {\n                    hls1.destroy();\n                    hls1 = rebuild(video1, src1);\n                }\n            }\n        });\n        hls1.once((hls_js__WEBPACK_IMPORTED_MODULE_7___default().Events.LEVEL_LOADED), function(event, data) {\n            setLoading(false);\n            var level_duration = data.details.totalduration;\n            setDuration(_objectSpread({}, duration, {\n                totalDuration: (0,_util_functions_js__WEBPACK_IMPORTED_MODULE_5__.formatDuration)(level_duration),\n                currentDuration: (0,_util_functions_js__WEBPACK_IMPORTED_MODULE_5__.formatDuration)(video1.currentTime)\n            }));\n        });\n        hls1.once((hls_js__WEBPACK_IMPORTED_MODULE_7___default().Events.MANIFEST_PARSED), function(event, data) {\n            setLoading(false);\n            setLevels(data.levels);\n            hls1.currentLevel = quality === \"auto\" ? -1 : quality;\n        });\n        video1.addEventListener(\"waiting\", function() {\n            setIsPlaying(false);\n            setLoading(true);\n        });\n        video1.addEventListener(\"playing\", function() {\n            setIsPlaying(true);\n            setLoading(false);\n        });\n        return function() {\n            hls1.destroy();\n        };\n    }, [\n        quality\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"\".concat(!theaterMode ? (_VideoPlayerDesktop_module_css__WEBPACK_IMPORTED_MODULE_8___default().video_wrapper) : (_VideoPlayerDesktop_module_css__WEBPACK_IMPORTED_MODULE_8___default().theater_mode)),\n        ref: videoPlayer,\n        children: [\n            playingAd && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: (_VideoPlayerDesktop_module_css__WEBPACK_IMPORTED_MODULE_8___default().playing_ad_wrapper),\n                children: \"Ad\"\n            }, void 0, false, {\n                fileName: \"/home/isolated/rakazone/rakazone-frontend/src/components/VideoPlayer/Desktop.js\",\n                lineNumber: 335,\n                columnNumber: 27\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"\".concat((_VideoPlayerDesktop_module_css__WEBPACK_IMPORTED_MODULE_8___default().settings_popup), \" \").concat((settingsShowQuality || settingsShowSpeed) && (_VideoPlayerDesktop_module_css__WEBPACK_IMPORTED_MODULE_8___default().settings_popup_show)),\n                style: showSettings ? {\n                    display: \"block\"\n                } : [],\n                children: [\n                    !settingsShowQuality && !settingsShowSpeed && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"\".concat((_VideoPlayerDesktop_module_css__WEBPACK_IMPORTED_MODULE_8___default().settings_item)),\n                        onClick: function() {\n                            return setSettingsShowQuality(true);\n                        },\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"\".concat((_VideoPlayerDesktop_module_css__WEBPACK_IMPORTED_MODULE_8___default().quality_selector), \" material-icons-round\"),\n                                children: \"tune\"\n                            }, void 0, false, {\n                                fileName: \"/home/isolated/rakazone/rakazone-frontend/src/components/VideoPlayer/Desktop.js\",\n                                lineNumber: 339,\n                                columnNumber: 25\n                            }, this),\n                            \"Quality \",\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: (_VideoPlayerDesktop_module_css__WEBPACK_IMPORTED_MODULE_8___default().current_quality),\n                                children: [\n                                    \" \",\n                                    quality === \"auto\" ? \"Auto\" : quality == 0 ? \"360p\" : quality == 1 ? \"480p\" : quality == 2 ? \"720p\" : \"1080p\"\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/home/isolated/rakazone/rakazone-frontend/src/components/VideoPlayer/Desktop.js\",\n                                lineNumber: 340,\n                                columnNumber: 33\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/home/isolated/rakazone/rakazone-frontend/src/components/VideoPlayer/Desktop.js\",\n                        lineNumber: 338,\n                        columnNumber: 21\n                    }, this),\n                    !settingsShowSpeed && settingsShowQuality && levels.map(function(level, index) {\n                        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"\".concat((_VideoPlayerDesktop_module_css__WEBPACK_IMPORTED_MODULE_8___default().settings_item)),\n                            onClick: function() {\n                                return handleQualitySelect(index);\n                            },\n                            children: [\n                                level.height,\n                                \"p\"\n                            ]\n                        }, index, true, {\n                            fileName: \"/home/isolated/rakazone/rakazone-frontend/src/components/VideoPlayer/Desktop.js\",\n                            lineNumber: 347,\n                            columnNumber: 29\n                        }, _this);\n                    }),\n                    !settingsShowQuality && !settingsShowSpeed && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"\".concat((_VideoPlayerDesktop_module_css__WEBPACK_IMPORTED_MODULE_8___default().settings_item)),\n                        onClick: function() {\n                            return setSettingsShowSpeed(true);\n                        },\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"\".concat((_VideoPlayerDesktop_module_css__WEBPACK_IMPORTED_MODULE_8___default().quality_selector), \" material-icons-round\"),\n                                children: \"slow_motion_video\"\n                            }, void 0, false, {\n                                fileName: \"/home/isolated/rakazone/rakazone-frontend/src/components/VideoPlayer/Desktop.js\",\n                                lineNumber: 355,\n                                columnNumber: 25\n                            }, this),\n                            \"Playback Speed\"\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/home/isolated/rakazone/rakazone-frontend/src/components/VideoPlayer/Desktop.js\",\n                        lineNumber: 354,\n                        columnNumber: 21\n                    }, this),\n                    settingsShowSpeed && !settingsShowQuality && playbackSpeedsList.map(function(speed, index) {\n                        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"\".concat((_VideoPlayerDesktop_module_css__WEBPACK_IMPORTED_MODULE_8___default().settings_item)),\n                            onClick: function() {\n                                return handleSpeedSelect(speed);\n                            },\n                            children: [\n                                speed,\n                                \"x\"\n                            ]\n                        }, index, true, {\n                            fileName: \"/home/isolated/rakazone/rakazone-frontend/src/components/VideoPlayer/Desktop.js\",\n                            lineNumber: 363,\n                            columnNumber: 29\n                        }, _this);\n                    })\n                ]\n            }, void 0, true, {\n                fileName: \"/home/isolated/rakazone/rakazone-frontend/src/components/VideoPlayer/Desktop.js\",\n                lineNumber: 336,\n                columnNumber: 13\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: (_VideoPlayerDesktop_module_css__WEBPACK_IMPORTED_MODULE_8___default().center_on_screen),\n                children: loading && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_Loading__WEBPACK_IMPORTED_MODULE_6__[\"default\"], {\n                    w: \"70px\",\n                    h: \"70px\"\n                }, void 0, false, {\n                    fileName: \"/home/isolated/rakazone/rakazone-frontend/src/components/VideoPlayer/Desktop.js\",\n                    lineNumber: 369,\n                    columnNumber: 73\n                }, this)\n            }, void 0, false, {\n                fileName: \"/home/isolated/rakazone/rakazone-frontend/src/components/VideoPlayer/Desktop.js\",\n                lineNumber: 369,\n                columnNumber: 13\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"\".concat((_VideoPlayerDesktop_module_css__WEBPACK_IMPORTED_MODULE_8___default().controls_wrapper), \" \").concat(playingAd && (_VideoPlayerDesktop_module_css__WEBPACK_IMPORTED_MODULE_8___default().hide_controls), \" \").concat(isPlaying ? [] : (_VideoPlayerDesktop_module_css__WEBPACK_IMPORTED_MODULE_8___default().show_controls)),\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: (_VideoPlayerDesktop_module_css__WEBPACK_IMPORTED_MODULE_8___default().controls),\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"\".concat((_VideoPlayerDesktop_module_css__WEBPACK_IMPORTED_MODULE_8___default().timeline_wrap)),\n                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: (_VideoPlayerDesktop_module_css__WEBPACK_IMPORTED_MODULE_8___default().timeline_panel),\n                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    ref: timelineController,\n                                    className: (_VideoPlayerDesktop_module_css__WEBPACK_IMPORTED_MODULE_8___default().timeline_slider),\n                                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        className: (_VideoPlayerDesktop_module_css__WEBPACK_IMPORTED_MODULE_8___default().timeline_slider_track),\n                                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                            className: (_VideoPlayerDesktop_module_css__WEBPACK_IMPORTED_MODULE_8___default().timeline_slider_progress),\n                                            style: {\n                                                width: duration.percentage + \"%\"\n                                            },\n                                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                className: (_VideoPlayerDesktop_module_css__WEBPACK_IMPORTED_MODULE_8___default().timeline_slider_handle)\n                                            }, void 0, false, {\n                                                fileName: \"/home/isolated/rakazone/rakazone-frontend/src/components/VideoPlayer/Desktop.js\",\n                                                lineNumber: 377,\n                                                columnNumber: 41\n                                            }, this)\n                                        }, void 0, false, {\n                                            fileName: \"/home/isolated/rakazone/rakazone-frontend/src/components/VideoPlayer/Desktop.js\",\n                                            lineNumber: 376,\n                                            columnNumber: 37\n                                        }, this)\n                                    }, void 0, false, {\n                                        fileName: \"/home/isolated/rakazone/rakazone-frontend/src/components/VideoPlayer/Desktop.js\",\n                                        lineNumber: 375,\n                                        columnNumber: 33\n                                    }, this)\n                                }, void 0, false, {\n                                    fileName: \"/home/isolated/rakazone/rakazone-frontend/src/components/VideoPlayer/Desktop.js\",\n                                    lineNumber: 374,\n                                    columnNumber: 29\n                                }, this)\n                            }, void 0, false, {\n                                fileName: \"/home/isolated/rakazone/rakazone-frontend/src/components/VideoPlayer/Desktop.js\",\n                                lineNumber: 373,\n                                columnNumber: 25\n                            }, this)\n                        }, void 0, false, {\n                            fileName: \"/home/isolated/rakazone/rakazone-frontend/src/components/VideoPlayer/Desktop.js\",\n                            lineNumber: 372,\n                            columnNumber: 21\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: (_VideoPlayerDesktop_module_css__WEBPACK_IMPORTED_MODULE_8___default().bottom_controls),\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: \"\".concat((_VideoPlayerDesktop_module_css__WEBPACK_IMPORTED_MODULE_8___default().controls_left)),\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                            className: \"\".concat((_VideoPlayerDesktop_module_css__WEBPACK_IMPORTED_MODULE_8___default().pause_play_btn), \" \").concat((_VideoPlayerDesktop_module_css__WEBPACK_IMPORTED_MODULE_8___default().btn)),\n                                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                className: \"\".concat((_VideoPlayerDesktop_module_css__WEBPACK_IMPORTED_MODULE_8___default().play_pause), \" material-icons-round\"),\n                                                onClick: function() {\n                                                    return handlePlayPause();\n                                                },\n                                                children: isPlaying ? \"pause\" : \"play_arrow\"\n                                            }, void 0, false, {\n                                                fileName: \"/home/isolated/rakazone/rakazone-frontend/src/components/VideoPlayer/Desktop.js\",\n                                                lineNumber: 387,\n                                                columnNumber: 33\n                                            }, this)\n                                        }, void 0, false, {\n                                            fileName: \"/home/isolated/rakazone/rakazone-frontend/src/components/VideoPlayer/Desktop.js\",\n                                            lineNumber: 386,\n                                            columnNumber: 29\n                                        }, this),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                            className: \"\".concat((_VideoPlayerDesktop_module_css__WEBPACK_IMPORTED_MODULE_8___default().volume_wrap), \" \").concat(showVolume ? (_VideoPlayerDesktop_module_css__WEBPACK_IMPORTED_MODULE_8___default().volume_show) : []),\n                                            onMouseEnter: function() {\n                                                return setShowVolume(true);\n                                            },\n                                            onMouseLeave: function() {\n                                                return setShowVolume(false);\n                                            },\n                                            children: [\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                    className: \"\".concat((_VideoPlayerDesktop_module_css__WEBPACK_IMPORTED_MODULE_8___default().volume_btn), \" material-icons-round \").concat((_VideoPlayerDesktop_module_css__WEBPACK_IMPORTED_MODULE_8___default().btn)),\n                                                    onClick: function() {\n                                                        return handleMute();\n                                                    },\n                                                    children: volume1.volume_icon\n                                                }, void 0, false, {\n                                                    fileName: \"/home/isolated/rakazone/rakazone-frontend/src/components/VideoPlayer/Desktop.js\",\n                                                    lineNumber: 392,\n                                                    columnNumber: 33\n                                                }, this),\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                    className: (_VideoPlayerDesktop_module_css__WEBPACK_IMPORTED_MODULE_8___default().volume_panel),\n                                                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                        ref: volumeController,\n                                                        className: (_VideoPlayerDesktop_module_css__WEBPACK_IMPORTED_MODULE_8___default().volume_slider),\n                                                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                            className: (_VideoPlayerDesktop_module_css__WEBPACK_IMPORTED_MODULE_8___default().volume_slider_track),\n                                                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                                className: (_VideoPlayerDesktop_module_css__WEBPACK_IMPORTED_MODULE_8___default().volume_slider_progress),\n                                                                style: {\n                                                                    width: volume1.volumeLevel + \"%\"\n                                                                },\n                                                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                                    className: (_VideoPlayerDesktop_module_css__WEBPACK_IMPORTED_MODULE_8___default().volume_slider_handle)\n                                                                }, void 0, false, {\n                                                                    fileName: \"/home/isolated/rakazone/rakazone-frontend/src/components/VideoPlayer/Desktop.js\",\n                                                                    lineNumber: 399,\n                                                                    columnNumber: 49\n                                                                }, this)\n                                                            }, void 0, false, {\n                                                                fileName: \"/home/isolated/rakazone/rakazone-frontend/src/components/VideoPlayer/Desktop.js\",\n                                                                lineNumber: 398,\n                                                                columnNumber: 45\n                                                            }, this)\n                                                        }, void 0, false, {\n                                                            fileName: \"/home/isolated/rakazone/rakazone-frontend/src/components/VideoPlayer/Desktop.js\",\n                                                            lineNumber: 397,\n                                                            columnNumber: 41\n                                                        }, this)\n                                                    }, void 0, false, {\n                                                        fileName: \"/home/isolated/rakazone/rakazone-frontend/src/components/VideoPlayer/Desktop.js\",\n                                                        lineNumber: 396,\n                                                        columnNumber: 37\n                                                    }, this)\n                                                }, void 0, false, {\n                                                    fileName: \"/home/isolated/rakazone/rakazone-frontend/src/components/VideoPlayer/Desktop.js\",\n                                                    lineNumber: 395,\n                                                    columnNumber: 33\n                                                }, this)\n                                            ]\n                                        }, void 0, true, {\n                                            fileName: \"/home/isolated/rakazone/rakazone-frontend/src/components/VideoPlayer/Desktop.js\",\n                                            lineNumber: 391,\n                                            columnNumber: 29\n                                        }, this),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                            className: (_VideoPlayerDesktop_module_css__WEBPACK_IMPORTED_MODULE_8___default().duration_wrapper),\n                                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                className: (_VideoPlayerDesktop_module_css__WEBPACK_IMPORTED_MODULE_8___default().duration),\n                                                children: [\n                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                        className: (_VideoPlayerDesktop_module_css__WEBPACK_IMPORTED_MODULE_8___default().duration_current),\n                                                        children: duration.currentDuration\n                                                    }, void 0, false, {\n                                                        fileName: \"/home/isolated/rakazone/rakazone-frontend/src/components/VideoPlayer/Desktop.js\",\n                                                        lineNumber: 407,\n                                                        columnNumber: 37\n                                                    }, this),\n                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                        className: (_VideoPlayerDesktop_module_css__WEBPACK_IMPORTED_MODULE_8___default().duration_separator),\n                                                        children: \"/\"\n                                                    }, void 0, false, {\n                                                        fileName: \"/home/isolated/rakazone/rakazone-frontend/src/components/VideoPlayer/Desktop.js\",\n                                                        lineNumber: 408,\n                                                        columnNumber: 37\n                                                    }, this),\n                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                        className: (_VideoPlayerDesktop_module_css__WEBPACK_IMPORTED_MODULE_8___default().duration_total),\n                                                        children: duration.totalDuration\n                                                    }, void 0, false, {\n                                                        fileName: \"/home/isolated/rakazone/rakazone-frontend/src/components/VideoPlayer/Desktop.js\",\n                                                        lineNumber: 409,\n                                                        columnNumber: 37\n                                                    }, this)\n                                                ]\n                                            }, void 0, true, {\n                                                fileName: \"/home/isolated/rakazone/rakazone-frontend/src/components/VideoPlayer/Desktop.js\",\n                                                lineNumber: 406,\n                                                columnNumber: 33\n                                            }, this)\n                                        }, void 0, false, {\n                                            fileName: \"/home/isolated/rakazone/rakazone-frontend/src/components/VideoPlayer/Desktop.js\",\n                                            lineNumber: 405,\n                                            columnNumber: 29\n                                        }, this)\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"/home/isolated/rakazone/rakazone-frontend/src/components/VideoPlayer/Desktop.js\",\n                                    lineNumber: 385,\n                                    columnNumber: 25\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: (_VideoPlayerDesktop_module_css__WEBPACK_IMPORTED_MODULE_8___default().controls_right),\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                            className: \"\".concat((_VideoPlayerDesktop_module_css__WEBPACK_IMPORTED_MODULE_8___default().mini_player_container), \" \").concat((_VideoPlayerDesktop_module_css__WEBPACK_IMPORTED_MODULE_8___default().btn)),\n                                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                className: \"\".concat((_VideoPlayerDesktop_module_css__WEBPACK_IMPORTED_MODULE_8___default().settings_btn), \" material-icons-round\"),\n                                                style: showSettings ? {\n                                                    transform: \"rotateZ(30deg)\"\n                                                } : [],\n                                                onClick: function() {\n                                                    return handleSettings();\n                                                },\n                                                children: \"settings\"\n                                            }, void 0, false, {\n                                                fileName: \"/home/isolated/rakazone/rakazone-frontend/src/components/VideoPlayer/Desktop.js\",\n                                                lineNumber: 415,\n                                                columnNumber: 33\n                                            }, this)\n                                        }, void 0, false, {\n                                            fileName: \"/home/isolated/rakazone/rakazone-frontend/src/components/VideoPlayer/Desktop.js\",\n                                            lineNumber: 414,\n                                            columnNumber: 29\n                                        }, this),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                            className: \"\".concat((_VideoPlayerDesktop_module_css__WEBPACK_IMPORTED_MODULE_8___default().mini_player_container), \" \").concat((_VideoPlayerDesktop_module_css__WEBPACK_IMPORTED_MODULE_8___default().btn)),\n                                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                className: \"\".concat((_VideoPlayerDesktop_module_css__WEBPACK_IMPORTED_MODULE_8___default().mini_player_btn), \" material-icons-round\"),\n                                                onClick: function() {\n                                                    return handlePictureInPicture();\n                                                },\n                                                children: \"branding_watermark\"\n                                            }, void 0, false, {\n                                                fileName: \"/home/isolated/rakazone/rakazone-frontend/src/components/VideoPlayer/Desktop.js\",\n                                                lineNumber: 420,\n                                                columnNumber: 33\n                                            }, this)\n                                        }, void 0, false, {\n                                            fileName: \"/home/isolated/rakazone/rakazone-frontend/src/components/VideoPlayer/Desktop.js\",\n                                            lineNumber: 419,\n                                            columnNumber: 29\n                                        }, this),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                            className: \"\".concat((_VideoPlayerDesktop_module_css__WEBPACK_IMPORTED_MODULE_8___default().theater_container), \" \").concat((_VideoPlayerDesktop_module_css__WEBPACK_IMPORTED_MODULE_8___default().btn)),\n                                            onClick: function() {\n                                                handleTheaterMode();\n                                            },\n                                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                className: \"\".concat((_VideoPlayerDesktop_module_css__WEBPACK_IMPORTED_MODULE_8___default().theater_btn), \" material-icons-round\"),\n                                                children: theaterMode ? \"crop_7_5\" : \"crop_7_5\"\n                                            }, void 0, false, {\n                                                fileName: \"/home/isolated/rakazone/rakazone-frontend/src/components/VideoPlayer/Desktop.js\",\n                                                lineNumber: 430,\n                                                columnNumber: 33\n                                            }, this)\n                                        }, void 0, false, {\n                                            fileName: \"/home/isolated/rakazone/rakazone-frontend/src/components/VideoPlayer/Desktop.js\",\n                                            lineNumber: 424,\n                                            columnNumber: 29\n                                        }, this),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                            className: \"\".concat((_VideoPlayerDesktop_module_css__WEBPACK_IMPORTED_MODULE_8___default().fullscreen_container), \" \").concat((_VideoPlayerDesktop_module_css__WEBPACK_IMPORTED_MODULE_8___default().btn)),\n                                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                className: \"\".concat((_VideoPlayerDesktop_module_css__WEBPACK_IMPORTED_MODULE_8___default().fullscreen_btn), \" material-icons-round\"),\n                                                onClick: function() {\n                                                    return handleFullScreen();\n                                                },\n                                                children: fullscreen ? \"fullscreen_exit\" : \"fullscreen\"\n                                            }, void 0, false, {\n                                                fileName: \"/home/isolated/rakazone/rakazone-frontend/src/components/VideoPlayer/Desktop.js\",\n                                                lineNumber: 433,\n                                                columnNumber: 33\n                                            }, this)\n                                        }, void 0, false, {\n                                            fileName: \"/home/isolated/rakazone/rakazone-frontend/src/components/VideoPlayer/Desktop.js\",\n                                            lineNumber: 432,\n                                            columnNumber: 29\n                                        }, this)\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"/home/isolated/rakazone/rakazone-frontend/src/components/VideoPlayer/Desktop.js\",\n                                    lineNumber: 413,\n                                    columnNumber: 25\n                                }, this)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"/home/isolated/rakazone/rakazone-frontend/src/components/VideoPlayer/Desktop.js\",\n                            lineNumber: 384,\n                            columnNumber: 21\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"/home/isolated/rakazone/rakazone-frontend/src/components/VideoPlayer/Desktop.js\",\n                    lineNumber: 371,\n                    columnNumber: 17\n                }, this)\n            }, void 0, false, {\n                fileName: \"/home/isolated/rakazone/rakazone-frontend/src/components/VideoPlayer/Desktop.js\",\n                lineNumber: 370,\n                columnNumber: 13\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"video\", {\n                autoPlay: true,\n                controls: false,\n                ref: videoController,\n                className: (_VideoPlayerDesktop_module_css__WEBPACK_IMPORTED_MODULE_8___default().video),\n                onClick: function() {\n                    return handlePlayPause();\n                }\n            }, void 0, false, {\n                fileName: \"/home/isolated/rakazone/rakazone-frontend/src/components/VideoPlayer/Desktop.js\",\n                lineNumber: 441,\n                columnNumber: 13\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/home/isolated/rakazone/rakazone-frontend/src/components/VideoPlayer/Desktop.js\",\n        lineNumber: 334,\n        columnNumber: 9\n    }, this);\n}\n_s(VideoPlayerDesktop, \"SHkTU0PuO8fXNM2CJw4nvX65PHQ=\");\n_c = VideoPlayerDesktop;\nvar _c;\n$RefreshReg$(_c, \"VideoPlayerDesktop\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29tcG9uZW50cy9WaWRlb1BsYXllci9EZXNrdG9wLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFtRDtBQUNRO0FBQ0Y7QUFDSTtBQUM1QjtBQUN1QjtBQUNBO0FBQ3hCO0FBQ1I7O0FBRWpCLFNBQVNXLGtCQUFrQixDQUFDQyxLQUFLLEVBQUU7OztJQUN0QyxJQUFNQyxJQUFHLEdBQUcseUNBQXdDLENBQWdCLE1BQWtCLENBQWhDRCxLQUFLLENBQUNFLE9BQU8sRUFBQyxvQkFBa0IsQ0FBQztJQUN2RixJQUFNQyxLQUFLLEdBQUksd0RBQXNEO0lBQ3JFLElBQU1DLGtCQUFrQixHQUFHO0FBQUMsV0FBRztBQUFFLFlBQUk7QUFBRSxTQUFDO0FBQUUsWUFBSTtBQUFFLFdBQUc7QUFBRSxZQUFJO0FBQUUsU0FBQztLQUFDO0lBRTdELDJCQUEyQjtJQUMzQixJQUFNQyxXQUFXLEdBQUdqQiw2Q0FBTSxDQUFDLElBQUksQ0FBQztJQUNoQyxJQUFNa0IsZUFBZSxHQUFHbEIsNkNBQU0sQ0FBQyxJQUFJLENBQUM7SUFDcEMsSUFBTW1CLGdCQUFnQixHQUFHbkIsNkNBQU0sQ0FBQyxJQUFJLENBQUM7SUFDckMsSUFBTW9CLGtCQUFrQixHQUFHcEIsNkNBQU0sQ0FBQyxJQUFJLENBQUM7SUFFdkMsU0FBUztJQUNULElBQWtDQyxLQUFlLEdBQWZBLCtDQUFRLENBQUMsS0FBSyxDQUFDLEVBdEJyRCxTQXNCb0IsR0FBa0JBLEtBQWUsR0FBakMsRUF0QnBCLFlBc0JrQyxHQUFJQSxLQUFlLEdBQW5CO0lBQzlCLElBQW9DQSxJQUFlLEdBQWZBLCtDQUFRLENBQUMsS0FBSyxDQUFDLEVBdkJ2RCxVQXVCcUIsR0FBbUJBLElBQWUsR0FBbEMsRUF2QnJCLGFBdUJvQyxHQUFJQSxJQUFlLEdBQW5CO0lBQ2hDLElBQW9DQSxJQUFlLEdBQWZBLCtDQUFRLENBQUMsS0FBSyxDQUFDLEVBeEJ2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L0M5SSxtRkFBeUIsRUFBQyx1QkFBcUIsQ0FBQzswREFBRzBCLFdBQVcsR0FBRyxVQUFVLEdBQUcsVUFBVTs7Ozs7b0RBQU87Ozs7O2dEQUNoSDtzREFDTiw4REFBQ21ILEtBQUc7NENBQUNDLFNBQVMsRUFBRSxFQUFDLENBQXdDOUksTUFBaUIsQ0FBdkRBLDRGQUFrQyxFQUFDLEdBQUMsQ0FBb0IsUUFBbEJBLDJFQUFpQixDQUFFO3NEQUN4RSw0RUFBQzZJLEtBQUc7Z0RBQUNDLFNBQVMsRUFBRSxFQUFDLENBQStCLE1BQXFCLENBQWxEOUksc0ZBQTRCLEVBQUMsdUJBQXFCLENBQUM7Z0RBQUV3SixPQUFPLEVBQUU7MkRBQU1sRixnQkFBZ0IsRUFBRTtpREFBQTswREFDcEdoRCxVQUFVLEdBQUcsaUJBQWlCLEdBQUcsWUFBWTs7Ozs7b0RBQzVDOzs7OztnREFDSjs7Ozs7O3dDQUNKOzs7Ozs7Z0NBQ0o7Ozs7Ozt3QkFDSjs7Ozs7b0JBQ0o7MEJBQ04sOERBQUNtRixPQUFLO2dCQUFDaUIsUUFBUTtnQkFBQzRDLFFBQVEsRUFBRSxLQUFLO2dCQUFFckIsR0FBRyxFQUFFbEksZUFBZTtnQkFBRStILFNBQVMsRUFBRTlJLDZFQUFtQjtnQkFBRXdKLE9BQU8sRUFBRTsyQkFBTXBFLGVBQWUsRUFBRTtpQkFBQTs7Ozs7b0JBQUk7Ozs7OztZQUV6SCxDQUNUO0NBQ0o7R0FsYmU1RSxrQkFBa0I7QUFBbEJBLEtBQUFBLGtCQUFrQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvY29tcG9uZW50cy9WaWRlb1BsYXllci9EZXNrdG9wLmpzPzVjMTQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlUmVmLCB1c2VTdGF0ZSwgdXNlRWZmZWN0IH0gZnJvbSBcInJlYWN0XCJcbmltcG9ydCBkZXNrdG9wX3N0eWxlIGZyb20gXCIuL1ZpZGVvUGxheWVyRGVza3RvcC5tb2R1bGUuY3NzXCJcbmltcG9ydCBtb2JpbGVfc3R5bGUgZnJvbSBcIi4vVmlkZW9QbGF5ZXJNb2JpbGUubW9kdWxlLmNzc1wiXG5pbXBvcnQgeyB0b2FzdFNlcnZpY2UgfSBmcm9tIFwiLi4vLi4vaGFuZGxlci90b2FzdC5oYW5kbGVyLmpzXCJcbmltcG9ydCBJbWFnZSBmcm9tIFwibmV4dC9pbWFnZS5qc1wiXG5pbXBvcnQgdGVzdEltYWdlIGZyb20gXCIuLi8uLi9hc3NldHMvaW1nL3BuZy9pbnN0YTA3LnBuZ1wiXG5pbXBvcnQgeyBmb3JtYXREdXJhdGlvbiB9IGZyb20gXCIuLi8uLi91dGlsL2Z1bmN0aW9ucy5qc1wiXG5pbXBvcnQgTG9hZGluZyBmcm9tIFwiLi4vTG9hZGluZ1wiXG5pbXBvcnQgSGxzIGZyb20gXCJobHMuanNcIlxuXG5leHBvcnQgZnVuY3Rpb24gVmlkZW9QbGF5ZXJEZXNrdG9wKHByb3BzKSB7XG4gICAgY29uc3Qgc3JjID0gYGh0dHBzOi8va2V2aXYueHl6L2FwaS9kb3dubG9hZHMvb3V0cHV0LyR7cHJvcHMudmlkZW9JZH0vSExTL3BsYXlsaXN0Lm0zdThgXG4gICAgY29uc3QgYWRTcmMgPSBgaHR0cHM6Ly9rZXZpdi54eXovYXBpL2Rvd25sb2Fkcy9TYW1wbGVBZC9wbGF5bGlzdC5tM3U4YFxuICAgIGNvbnN0IHBsYXliYWNrU3BlZWRzTGlzdCA9IFswLjUsIDAuNzUsIDEsIDEuMjUsIDEuNSwgMS43NSwgMl1cblxuICAgIC8vIENvbnRyb2xsZXIgZm9yIHRoZSB2aWRlb1xuICAgIGNvbnN0IHZpZGVvUGxheWVyID0gdXNlUmVmKG51bGwpXG4gICAgY29uc3QgdmlkZW9Db250cm9sbGVyID0gdXNlUmVmKG51bGwpXG4gICAgY29uc3Qgdm9sdW1lQ29udHJvbGxlciA9IHVzZVJlZihudWxsKVxuICAgIGNvbnN0IHRpbWVsaW5lQ29udHJvbGxlciA9IHVzZVJlZihudWxsKVxuXG4gICAgLy8gU3RhdGVzXG4gICAgY29uc3QgW2lzUGxheWluZywgc2V0SXNQbGF5aW5nXSA9IHVzZVN0YXRlKGZhbHNlKVxuICAgIGNvbnN0IFtzaG93Vm9sdW1lLCBzZXRTaG93Vm9sdW1lXSA9IHVzZVN0YXRlKGZhbHNlKVxuICAgIGNvbnN0IFtmdWxsc2NyZWVuLCBzZXRGdWxsc2NyZWVuXSA9IHVzZVN0YXRlKGZhbHNlKVxuICAgIGNvbnN0IFtwbGF5aW5nQWQsIHNldFBsYXlpbmdBZF0gPSB1c2VTdGF0ZShmYWxzZSlcbiAgICBjb25zdCBbdGhlYXRlck1vZGUsIHNldFRoZWF0ZXJNb2RlXSA9IHVzZVN0YXRlKGZhbHNlKVxuICAgIGNvbnN0IFtzaG93RW5kU2NyZWVuLCBzZXRTaG93RW5kU2NyZWVuXSA9IHVzZVN0YXRlKGZhbHNlKVxuICAgIGNvbnN0IFtzaG93U2V0dGluZ3MsIHNldFNob3dTZXR0aW5nc10gPSB1c2VTdGF0ZShmYWxzZSlcbiAgICBjb25zdCBbbG9hZGluZywgc2V0TG9hZGluZ10gPSB1c2VTdGF0ZShmYWxzZSlcbiAgICBjb25zdCBbZHVyYXRpb24sIHNldER1cmF0aW9uXSA9IHVzZVN0YXRlKHsgY3VycmVudER1cmF0aW9uOiAwLCB0b3RhbER1cmF0aW9uOiAwLCBwZXJjZW50YWdlOiAwIH0pXG4gICAgY29uc3QgW3ZvbHVtZSwgc2V0Vm9sdW1lXSA9IHVzZVN0YXRlKHsgdm9sdW1lTGV2ZWw6IDUwLCB2b2x1bWVfaWNvbjogXCJ2b2x1bWVfdXBcIiwgbGFzdFZvbHVtZTogMCB9KVxuICAgIGNvbnN0IFtzZXR0aW5nc1Nob3dRdWFsaXR5LCBzZXRTZXR0aW5nc1Nob3dRdWFsaXR5XSA9IHVzZVN0YXRlKGZhbHNlKVxuICAgIGNvbnN0IFtzZXR0aW5nc1Nob3dTcGVlZCwgc2V0U2V0dGluZ3NTaG93U3BlZWRdID0gdXNlU3RhdGUoZmFsc2UpXG4gICAgY29uc3QgW3F1YWxpdHksIHNldFF1YWxpdHldID0gdXNlU3RhdGUoXCJhdXRvXCIpXG4gICAgY29uc3QgW2xldmVscywgc2V0TGV2ZWxzXSA9IHVzZVN0YXRlKFtdKVxuXG4gICAgLy8gRnVuY3Rpb25zXG4gICAgY29uc3QgaGFuZGxlVGhlYXRlck1vZGUgPSAoKSA9PiB7XG4gICAgICAgIHNldFRoZWF0ZXJNb2RlKCF0aGVhdGVyTW9kZSlcbiAgICB9XG4gICAgY29uc3QgaGFuZGxlU2V0dGluZ3MgPSAoKSA9PiB7XG4gICAgICAgIGlmIChzaG93U2V0dGluZ3MpIHtcbiAgICAgICAgICAgIHNldFNldHRpbmdzU2hvd1F1YWxpdHkoZmFsc2UpXG4gICAgICAgICAgICBzZXRTZXR0aW5nc1Nob3dTcGVlZChmYWxzZSlcbiAgICAgICAgICAgIHNldFNob3dTZXR0aW5ncyhmYWxzZSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNldFNob3dTZXR0aW5ncyh0cnVlKVxuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGhhbmRsZVF1YWxpdHlTZWxlY3QgPSAocSkgPT4ge1xuICAgICAgICBoYW5kbGVTZXR0aW5ncygpXG4gICAgICAgIHNldFF1YWxpdHkocSlcbiAgICB9XG5cbiAgICBjb25zdCBoYW5kbGVTcGVlZFNlbGVjdCA9IChzKSA9PiB7XG4gICAgICAgIGhhbmRsZVNldHRpbmdzKClcbiAgICAgICAgdmlkZW9Db250cm9sbGVyLmN1cnJlbnQucGxheWJhY2tSYXRlID0gc1xuICAgIH1cblxuICAgIGNvbnN0IGNhbGN1bGF0ZVZvbHVtZSA9IChjbGljaywgZWxtKSA9PiB7XG4gICAgICAgIGNvbnN0IHZvbHVtZV93aWR0aCA9IGVsbS5vZmZzZXRXaWR0aFxuICAgICAgICBjb25zdCBjbGlja194ID0gY2xpY2suY2xpZW50WCAtIGVsbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0XG4gICAgICAgIGNvbnN0IHZvbHVtZSA9ICgoY2xpY2tfeCAvIHZvbHVtZV93aWR0aCkgKiAxMDApLnRvRml4ZWQoMClcbiAgICAgICAgcmV0dXJuIHZvbHVtZVxuICAgIH1cblxuICAgIGNvbnN0IGhhbmRsZUZ1bGxTY3JlZW4gPSAoKSA9PiB7XG4gICAgICAgIGlmIChkb2N1bWVudC5mdWxsc2NyZWVuRWxlbWVudCAhPSBudWxsKSB7XG4gICAgICAgICAgICBzZXRGdWxsc2NyZWVuKGZhbHNlKVxuICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50LmV4aXRGdWxsc2NyZWVuKClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh2aWRlb1BsYXllci5jdXJyZW50LnJlcXVlc3RGdWxsc2NyZWVuKSB7XG4gICAgICAgICAgICAgICAgdmlkZW9QbGF5ZXIuY3VycmVudC5yZXF1ZXN0RnVsbHNjcmVlbigpXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHZpZGVvUGxheWVyLmN1cnJlbnQud2Via2l0UmVxdWVzdEZ1bGxzY3JlZW4pIHtcbiAgICAgICAgICAgICAgICB2aWRlb1BsYXllci5jdXJyZW50LndlYmtpdFJlcXVlc3RGdWxsc2NyZWVuKClcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodmlkZW9QbGF5ZXIuY3VycmVudC5tb3pSZXF1ZXN0RnVsbFNjcmVlbikge1xuICAgICAgICAgICAgICAgIHZpZGVvUGxheWVyLmN1cnJlbnQubW96UmVxdWVzdEZ1bGxTY3JlZW4oKVxuICAgICAgICAgICAgfSBlbHNlIGlmICh2aWRlb1BsYXllci5jdXJyZW50Lm1zUmVxdWVzdEZ1bGxzY3JlZW4pIHtcbiAgICAgICAgICAgICAgICB2aWRlb1BsYXllci5jdXJyZW50Lm1zUmVxdWVzdEZ1bGxzY3JlZW4oKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0RnVsbHNjcmVlbih0cnVlKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgaGFuZGxlUGljdHVyZUluUGljdHVyZSA9ICgpID0+IHtcbiAgICAgICAgaWYgKGRvY3VtZW50LnBpY3R1cmVJblBpY3R1cmVFbGVtZW50ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGRvY3VtZW50LmV4aXRQaWN0dXJlSW5QaWN0dXJlKClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZpZGVvQ29udHJvbGxlci5jdXJyZW50LnJlcXVlc3RQaWN0dXJlSW5QaWN0dXJlKClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGhhbmRsZU11dGUgPSAoKSA9PiB7XG4gICAgICAgIGlmICh2aWRlb0NvbnRyb2xsZXIuY3VycmVudC5tdXRlZCkge1xuICAgICAgICAgICAgdmlkZW9Db250cm9sbGVyLmN1cnJlbnQubXV0ZWQgPSBmYWxzZVxuICAgICAgICAgICAgc2V0Vm9sdW1lKHsgdm9sdW1lTGV2ZWw6IHZvbHVtZS5sYXN0Vm9sdW1lICogMTAwLCB2b2x1bWVfaWNvbjogXCJ2b2x1bWVfZG93blwiIH0pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2aWRlb0NvbnRyb2xsZXIuY3VycmVudC5tdXRlZCA9IHRydWVcbiAgICAgICAgICAgIHNldFZvbHVtZSh7IHZvbHVtZUxldmVsOiAwLCB2b2x1bWVfaWNvbjogXCJ2b2x1bWVfb2ZmXCIsIGxhc3RWb2x1bWU6IHZpZGVvQ29udHJvbGxlci5jdXJyZW50LnZvbHVtZSB9KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgaGFuZGxlUGxheVBhdXNlID0gKCkgPT4ge1xuICAgICAgICBpZiAoc2hvd1NldHRpbmdzKSByZXR1cm4gaGFuZGxlU2V0dGluZ3MoKVxuICAgICAgICBpZiAodmlkZW9Db250cm9sbGVyLmN1cnJlbnQucGF1c2VkKSB7XG4gICAgICAgICAgICBzZXRJc1BsYXlpbmcodHJ1ZSlcbiAgICAgICAgICAgIHZpZGVvQ29udHJvbGxlci5jdXJyZW50LnBsYXkoKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2V0SXNQbGF5aW5nKGZhbHNlKVxuICAgICAgICAgICAgdmlkZW9Db250cm9sbGVyLmN1cnJlbnQucGF1c2UoKVxuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGhhbmRsZVZvbHVtZSA9ICgpID0+IHtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCBoYW5kbGVWb2x1bWVTbGlkZXIpXG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIGhhbmRsZVZvbHVtZSlcbiAgICB9XG5cbiAgICBjb25zdCBoYW5kbGVUaW1lbGluZSA9ICgpID0+IHtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCBoYW5kbGVUaW1lbGluZVNsaWRlcilcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgaGFuZGxlVGltZWxpbmUpXG4gICAgfVxuICAgIGNvbnN0IGhhbmRsZVZvbHVtZVNsaWRlciA9IChlKSA9PiB7XG4gICAgICAgIHNldFNob3dWb2x1bWUodHJ1ZSlcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICAgIGNvbnN0IHNsaWRlciA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoZGVza3RvcF9zdHlsZS52b2x1bWVfc2xpZGVyKVswXVxuICAgICAgICBsZXQgcGVyY2VudCA9IGNhbGN1bGF0ZVZvbHVtZShlLCBzbGlkZXIpXG4gICAgICAgIGlmIChwZXJjZW50IDwgMCkge1xuICAgICAgICAgICAgcGVyY2VudCA9IDBcbiAgICAgICAgfSBlbHNlIGlmIChwZXJjZW50ID4gMTAwKSB7XG4gICAgICAgICAgICBwZXJjZW50ID0gMTAwXG4gICAgICAgIH1cbiAgICAgICAgbGV0IHZvbHVtZV9pY29uID0gcGVyY2VudCA+IDcwID8gXCJ2b2x1bWVfdXBcIiA6IHBlcmNlbnQgPiA0MCA/IFwidm9sdW1lX2Rvd25cIiA6IHBlcmNlbnQgPT0gMCA/IFwidm9sdW1lX29mZlwiIDogXCJ2b2x1bWVfZG93blwiXG4gICAgICAgIHZpZGVvQ29udHJvbGxlci5jdXJyZW50LnZvbHVtZSA9IHBlcmNlbnQgLyAxMDBcbiAgICAgICAgc2V0Vm9sdW1lKHsgdm9sdW1lTGV2ZWw6IHBlcmNlbnQsIHZvbHVtZV9pY29uOiB2b2x1bWVfaWNvbiB9KVxuICAgIH1cblxuICAgIGNvbnN0IGhhbmRsZVRpbWVsaW5lU2xpZGVyID0gKGUpID0+IHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICAgIGNvbnN0IHNsaWRlciA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoZGVza3RvcF9zdHlsZS50aW1lbGluZV9zbGlkZXIpWzBdXG4gICAgICAgIGxldCBwZXJjZW50ID0gY2FsY3VsYXRlVm9sdW1lKGUsIHNsaWRlcilcbiAgICAgICAgaWYgKHBlcmNlbnQgPCAwKSB7XG4gICAgICAgICAgICBwZXJjZW50ID0gMFxuICAgICAgICB9IGVsc2UgaWYgKHBlcmNlbnQgPiAxMDApIHtcbiAgICAgICAgICAgIHBlcmNlbnQgPSAxMDBcbiAgICAgICAgfVxuICAgICAgICB2aWRlb0NvbnRyb2xsZXIuY3VycmVudC5jdXJyZW50VGltZSA9IChwZXJjZW50IC8gMTAwKSAqIHZpZGVvQ29udHJvbGxlci5jdXJyZW50LmR1cmF0aW9uXG4gICAgICAgIHNldER1cmF0aW9uKHsgY3VycmVudER1cmF0aW9uOiBmb3JtYXREdXJhdGlvbih2aWRlb0NvbnRyb2xsZXIuY3VycmVudC5jdXJyZW50VGltZSksIHRvdGFsRHVyYXRpb246IGZvcm1hdER1cmF0aW9uKHZpZGVvQ29udHJvbGxlci5jdXJyZW50LmR1cmF0aW9uKSwgcGVyY2VudGFnZTogcGVyY2VudCB9KVxuICAgIH1cblxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIC8vIEV2ZW50IExpc3RlbmVyc1xuICAgICAgICB2aWRlb0NvbnRyb2xsZXIuY3VycmVudC5hZGRFdmVudExpc3RlbmVyKFwicGxheVwiLCAoKSA9PiB7XG4gICAgICAgICAgICBzZXRJc1BsYXlpbmcodHJ1ZSlcbiAgICAgICAgfSlcblxuICAgICAgICB2aWRlb0NvbnRyb2xsZXIuY3VycmVudC5hZGRFdmVudExpc3RlbmVyKFwiZHVyYXRpb25jaGFuZ2VcIiwgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHBsYXlpbmdBZCkgcmV0dXJuXG4gICAgICAgICAgICBzZXREdXJhdGlvbih7IGN1cnJlbnREdXJhdGlvbjogZm9ybWF0RHVyYXRpb24odmlkZW9Db250cm9sbGVyLmN1cnJlbnQuY3VycmVudFRpbWUpLCB0b3RhbER1cmF0aW9uOiBmb3JtYXREdXJhdGlvbih2aWRlb0NvbnRyb2xsZXIuY3VycmVudC5kdXJhdGlvbiksIHBlcmNlbnRhZ2U6IDAgfSlcbiAgICAgICAgfSlcbiAgICAgICAgdmlkZW9Db250cm9sbGVyLmN1cnJlbnQuYWRkRXZlbnRMaXN0ZW5lcihcInRpbWV1cGRhdGVcIiwgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHBsYXlpbmdBZCkgcmV0dXJuXG4gICAgICAgICAgICBzZXRMb2FkaW5nKGZhbHNlKVxuICAgICAgICAgICAgc2V0RHVyYXRpb24oe1xuICAgICAgICAgICAgICAgIGN1cnJlbnREdXJhdGlvbjogZm9ybWF0RHVyYXRpb24odmlkZW9Db250cm9sbGVyLmN1cnJlbnQuY3VycmVudFRpbWUpLFxuICAgICAgICAgICAgICAgIHRvdGFsRHVyYXRpb246IGZvcm1hdER1cmF0aW9uKHZpZGVvQ29udHJvbGxlci5jdXJyZW50LmR1cmF0aW9uKSxcbiAgICAgICAgICAgICAgICBwZXJjZW50YWdlOiAodmlkZW9Db250cm9sbGVyLmN1cnJlbnQuY3VycmVudFRpbWUgLyB2aWRlb0NvbnRyb2xsZXIuY3VycmVudC5kdXJhdGlvbikgKiAxMDAsXG4gICAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgICAgICB2aWRlb0NvbnRyb2xsZXIuY3VycmVudC5hZGRFdmVudExpc3RlbmVyKFwibG9hZGVkZGF0YVwiLCAoKSA9PiB7XG4gICAgICAgICAgICBzZXRMb2FkaW5nKGZhbHNlKVxuICAgICAgICAgICAgLy8gdmlkZW9Db250cm9sbGVyLmN1cnJlbnQudm9sdW1lID0gNTAgLyAxMDBcbiAgICAgICAgICAgIGlmICghdmlkZW9Db250cm9sbGVyLmN1cnJlbnQ/LmN1cnJlbnRUaW1lKSByZXR1cm5cbiAgICAgICAgICAgIHNldER1cmF0aW9uKHtcbiAgICAgICAgICAgICAgICBjdXJyZW50RHVyYXRpb246IGZvcm1hdER1cmF0aW9uKHZpZGVvQ29udHJvbGxlci5jdXJyZW50LmN1cnJlbnRUaW1lKSxcbiAgICAgICAgICAgICAgICB0b3RhbER1cmF0aW9uOiBmb3JtYXREdXJhdGlvbih2aWRlb0NvbnRyb2xsZXIuY3VycmVudC5kdXJhdGlvbiksXG4gICAgICAgICAgICAgICAgcGVyY2VudGFnZTogKHZpZGVvQ29udHJvbGxlci5jdXJyZW50LmN1cnJlbnRUaW1lIC8gdmlkZW9Db250cm9sbGVyLmN1cnJlbnQuZHVyYXRpb24pICogMTAwLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSlcblxuICAgICAgICAvLyBWb2x1bWUgQ29udHJvbGxlclxuICAgICAgICB2b2x1bWVDb250cm9sbGVyLmN1cnJlbnQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCAoZSkgPT4ge1xuICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCBoYW5kbGVWb2x1bWVTbGlkZXIpXG4gICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCAoZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBoYW5kbGVWb2x1bWUoKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSlcbiAgICAgICAgdm9sdW1lQ29udHJvbGxlci5jdXJyZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAoZSkgPT4ge1xuICAgICAgICAgICAgaGFuZGxlVm9sdW1lU2xpZGVyKGUpXG4gICAgICAgIH0pXG4gICAgICAgIC8vIHRpbWVsaW5lIENvbnRyb2xsZXJcbiAgICAgICAgdGltZWxpbmVDb250cm9sbGVyLmN1cnJlbnQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCAoZSkgPT4ge1xuICAgICAgICAgICAgaWYgKHBsYXlpbmdBZCkgcmV0dXJuXG4gICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIGhhbmRsZVRpbWVsaW5lU2xpZGVyKVxuICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgKGUpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlVGltZWxpbmUoKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSlcbiAgICAgICAgdGltZWxpbmVDb250cm9sbGVyLmN1cnJlbnQuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIChlKSA9PiB7XG4gICAgICAgICAgICBpZiAocGxheWluZ0FkKSByZXR1cm5cbiAgICAgICAgICAgIGhhbmRsZVRpbWVsaW5lU2xpZGVyKGUpXG4gICAgICAgIH0pXG5cbiAgICAgICAgLy8gdmlkZW9Db250cm9sbGVyLmN1cnJlbnQuYWRkRXZlbnRMaXN0ZW5lcihcImVuZGVkXCIsICgpID0+IHtcbiAgICAgICAgLy8gICAgIHNldElzUGxheWluZyhmYWxzZSlcbiAgICAgICAgLy8gICAgIHRvYXN0U2VydmljZS5zdWNjZXNzKFwiVmlkZW8gZW5kZWRcIilcbiAgICAgICAgLy8gfSlcblxuICAgICAgICB2aWRlb0NvbnRyb2xsZXIuY3VycmVudC5hZGRFdmVudExpc3RlbmVyKFwid2FpdGluZ1wiLCAoKSA9PiB7XG4gICAgICAgICAgICBzZXRMb2FkaW5nKHRydWUpXG4gICAgICAgIH0pXG5cbiAgICAgICAgdmlkZW9Db250cm9sbGVyLmN1cnJlbnQuYWRkRXZlbnRMaXN0ZW5lcihcImRibGNsaWNrXCIsIChlKSA9PiB7XG4gICAgICAgICAgICBpZiAoc2hvd1NldHRpbmdzKSBzZXRTaG93U2V0dGluZ3MoZmFsc2UpXG4gICAgICAgICAgICBpZiAoZS50YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKGRlc2t0b3Bfc3R5bGUudmlkZW8pKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlRnVsbFNjcmVlbigpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG5cbiAgICAgICAgLy8gaGFuZGxlIGtleSBzdHJva2VzXG4gICAgICAgIGRvY3VtZW50Lm9ua2V5ZG93biA9IChlKSA9PiB7XG4gICAgICAgICAgICBpZiAoZS5rZXkgPT09IFwiIFwiKSB7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICAgICAgICAgICAgaGFuZGxlUGxheVBhdXNlKClcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZS5rZXkgPT09IFwiZlwiKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlRnVsbFNjcmVlbigpXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGUua2V5ID09PSBcInBcIikge1xuICAgICAgICAgICAgICAgIGhhbmRsZVBpY3R1cmVJblBpY3R1cmUoKVxuICAgICAgICAgICAgfSBlbHNlIGlmIChlLmtleSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgdmlkZW9Db250cm9sbGVyLmN1cnJlbnQuY3VycmVudFRpbWUgPSAoMCAvIDEwMCkgKiB2aWRlb0NvbnRyb2xsZXIuY3VycmVudC5kdXJhdGlvblxuICAgICAgICAgICAgfSBlbHNlIGlmIChlLmtleSA9PSBcIm1cIikge1xuICAgICAgICAgICAgICAgIGhhbmRsZU11dGUoKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwgW3ZpZGVvQ29udHJvbGxlci5jdXJyZW50XSlcblxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgICAgICAgICBzdGFydExldmVsOiAtMSxcbiAgICAgICAgICAgIGxpY2Vuc2VYaHJTZXR1cDogZnVuY3Rpb24gKHhociwgdXJsKSB7XG4gICAgICAgICAgICAgICAgeGhyLndpdGhDcmVkZW50aWFscyA9IHRydWUgLy8gZG8gc2VuZCBjb29raWVzXG4gICAgICAgICAgICAgICAgaWYgKCF4aHIucmVhZHlTdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBDYWxsIG9wZW4gdG8gY2hhbmdlIHRoZSBtZXRob2QgKGRlZmF1bHQgaXMgUE9TVCkgb3IgbW9kaWZ5IHRoZSB1cmxcbiAgICAgICAgICAgICAgICAgICAgeGhyLm9wZW4oXCJHRVRcIiwgdXJsLCB0cnVlKVxuICAgICAgICAgICAgICAgICAgICAvLyBBcHBlbmQgaGVhZGVycyBhZnRlciBvcGVuaW5nXG4gICAgICAgICAgICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKFwiQ29udGVudC1UeXBlXCIsIFwiYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtXCIpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJlYnVpbGQgPSAodmlkZW8sIHNyYykgPT4ge1xuICAgICAgICAgICAgc2V0TG9hZGluZyh0cnVlKVxuICAgICAgICAgICAgY29uc3QgaGxzID0gbmV3IEhscyhkZWZhdWx0T3B0aW9ucylcbiAgICAgICAgICAgIGhscy5sb2FkU291cmNlKHNyYylcbiAgICAgICAgICAgIGhscy5hdHRhY2hNZWRpYSh2aWRlbylcbiAgICAgICAgICAgIHJldHVybiBobHNcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBobHMgPSBuZXcgSGxzKGRlZmF1bHRPcHRpb25zKVxuICAgICAgICBjb25zdCB2aWRlbyA9IHZpZGVvQ29udHJvbGxlci5jdXJyZW50XG4gICAgICAgIHZpZGVvLnJlbW92ZUF0dHJpYnV0ZShcImNvbnRyb2xzXCIpXG4gICAgICAgIHZpZGVvLmF1dG9QbGF5ID0gdHJ1ZVxuICAgICAgICB2aWRlby5tdXRlZCA9IHRydWVcbiAgICAgICAgc2V0TG9hZGluZyh0cnVlKVxuICAgICAgICBpZiAoIXZpZGVvKSByZXR1cm5cbiAgICAgICAgaWYgKHZpZGVvLmNhblBsYXlUeXBlKFwiYXBwbGljYXRpb24vdm5kLmFwcGxlLm1wZWd1cmxcIikgJiYgcHJvcHMuaXNJT1MpIHtcbiAgICAgICAgICAgIHZpZGVvLnJlbW92ZUF0dHJpYnV0ZShcImNvbnRyb2xzXCIpXG4gICAgICAgICAgICB2aWRlby5zZXRBdHRyaWJ1dGUoXCJ3ZWJraXQtcGxheXNpbmxpbmVcIiwgXCJcIilcbiAgICAgICAgICAgIHZpZGVvLnNldEF0dHJpYnV0ZShcInBsYXlzaW5saW5lXCIsIFwiXCIpXG4gICAgICAgICAgICB2aWRlby5zZXRBdHRyaWJ1dGUoXCJ4LXdlYmtpdC1haXJwbGF5XCIsIFwiYWxsb3dcIilcbiAgICAgICAgICAgIHZpZGVvLnNldEF0dHJpYnV0ZShcIng1LXZpZGVvLXBsYXllci10eXBlXCIsIFwiaDVcIilcbiAgICAgICAgICAgIHZpZGVvLnNldEF0dHJpYnV0ZShcIng1LXZpZGVvLXBsYXllci1mdWxsc2NyZWVuXCIsIFwiZmFsc2VcIilcbiAgICAgICAgICAgIHZpZGVvLnNldEF0dHJpYnV0ZShcIng1LXZpZGVvLW9yaWVudGF0aW9uXCIsIFwicG9ydHJhaW50XCIpXG5cbiAgICAgICAgICAgIGlmIChhZFNyYykge1xuICAgICAgICAgICAgICAgIHNldFBsYXlpbmdBZCh0cnVlKVxuICAgICAgICAgICAgICAgIHZpZGVvLnNyYyA9IGFkU3JjXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZpZGVvLnNyYyA9IHNyY1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKEhscy5pc1N1cHBvcnRlZCgpKSB7XG4gICAgICAgICAgICAvLyBUaGlzIHdpbGwgcnVuIGluIGFsbCBvdGhlciBtb2Rlcm4gYnJvd3NlcnNcbiAgICAgICAgICAgIGlmIChhZFNyYykge1xuICAgICAgICAgICAgICAgIHNldFBsYXlpbmdBZCh0cnVlKVxuICAgICAgICAgICAgICAgIGhscy5sb2FkU291cmNlKGFkU3JjKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBobHMubG9hZFNvdXJjZShzcmMpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBobHMuYXR0YWNoTWVkaWEodmlkZW8pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiVGhpcyBpcyBhbiBvbGQgYnJvd3NlciB0aGF0IGRvZXMgbm90IHN1cHBvcnQgTVNFIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9NZWRpYV9Tb3VyY2VfRXh0ZW5zaW9uc19BUElcIilcbiAgICAgICAgfVxuXG4gICAgICAgIHZpZGVvLmFkZEV2ZW50TGlzdGVuZXIoXCJlbmRlZFwiLCAoKSA9PiB7XG4gICAgICAgICAgICBpZiAodmlkZW8uc3JjID09PSBhZFNyYyB8fCBobHM/LmxldmVsc1swXT8udXJsWzBdPy5pbmNsdWRlcyhcIkFkXCIpKSB7XG4gICAgICAgICAgICAgICAgc2V0UGxheWluZ0FkKGZhbHNlKVxuICAgICAgICAgICAgICAgIGlmICh2aWRlby5jYW5QbGF5VHlwZShcImFwcGxpY2F0aW9uL3ZuZC5hcHBsZS5tcGVndXJsXCIpICYmIHByb3BzLmlzSU9TKSB7XG4gICAgICAgICAgICAgICAgICAgIHZpZGVvLnNyYyA9IHNyY1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGhscy5kZXN0cm95KClcbiAgICAgICAgICAgICAgICAgICAgaGxzID0gcmVidWlsZCh2aWRlbywgc3JjKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcblxuICAgICAgICBobHMub25jZShIbHMuRXZlbnRzLkxFVkVMX0xPQURFRCwgKGV2ZW50LCBkYXRhKSA9PiB7XG4gICAgICAgICAgICBzZXRMb2FkaW5nKGZhbHNlKVxuICAgICAgICAgICAgdmFyIGxldmVsX2R1cmF0aW9uID0gZGF0YS5kZXRhaWxzLnRvdGFsZHVyYXRpb25cbiAgICAgICAgICAgIHNldER1cmF0aW9uKHsgLi4uZHVyYXRpb24sIHRvdGFsRHVyYXRpb246IGZvcm1hdER1cmF0aW9uKGxldmVsX2R1cmF0aW9uKSwgY3VycmVudER1cmF0aW9uOiBmb3JtYXREdXJhdGlvbih2aWRlby5jdXJyZW50VGltZSkgfSlcbiAgICAgICAgfSlcbiAgICAgICAgaGxzLm9uY2UoSGxzLkV2ZW50cy5NQU5JRkVTVF9QQVJTRUQsIGZ1bmN0aW9uIChldmVudCwgZGF0YSkge1xuICAgICAgICAgICAgc2V0TG9hZGluZyhmYWxzZSlcbiAgICAgICAgICAgIHNldExldmVscyhkYXRhLmxldmVscylcbiAgICAgICAgICAgIGhscy5jdXJyZW50TGV2ZWwgPSBxdWFsaXR5ID09PSBcImF1dG9cIiA/IC0xIDogcXVhbGl0eVxuICAgICAgICB9KVxuXG4gICAgICAgIHZpZGVvLmFkZEV2ZW50TGlzdGVuZXIoXCJ3YWl0aW5nXCIsICgpID0+IHtcbiAgICAgICAgICAgIHNldElzUGxheWluZyhmYWxzZSlcbiAgICAgICAgICAgIHNldExvYWRpbmcodHJ1ZSlcbiAgICAgICAgfSlcbiAgICAgICAgdmlkZW8uYWRkRXZlbnRMaXN0ZW5lcihcInBsYXlpbmdcIiwgKCkgPT4ge1xuICAgICAgICAgICAgc2V0SXNQbGF5aW5nKHRydWUpXG4gICAgICAgICAgICBzZXRMb2FkaW5nKGZhbHNlKVxuICAgICAgICB9KVxuXG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBobHMuZGVzdHJveSgpXG4gICAgICAgIH1cbiAgICB9LCBbcXVhbGl0eV0pXG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT17YCR7IXRoZWF0ZXJNb2RlID8gZGVza3RvcF9zdHlsZS52aWRlb193cmFwcGVyIDogZGVza3RvcF9zdHlsZS50aGVhdGVyX21vZGV9YH0gcmVmPXt2aWRlb1BsYXllcn0+XG4gICAgICAgICAgICB7cGxheWluZ0FkICYmIDxkaXYgY2xhc3NOYW1lPXtkZXNrdG9wX3N0eWxlLnBsYXlpbmdfYWRfd3JhcHBlcn0+QWQ8L2Rpdj59XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17YCR7ZGVza3RvcF9zdHlsZS5zZXR0aW5nc19wb3B1cH0gJHsoc2V0dGluZ3NTaG93UXVhbGl0eSB8fCBzZXR0aW5nc1Nob3dTcGVlZCkgJiYgZGVza3RvcF9zdHlsZS5zZXR0aW5nc19wb3B1cF9zaG93fWB9IHN0eWxlPXtzaG93U2V0dGluZ3MgPyB7IGRpc3BsYXk6IFwiYmxvY2tcIiB9IDogW119PlxuICAgICAgICAgICAgICAgIHshc2V0dGluZ3NTaG93UXVhbGl0eSAmJiAhc2V0dGluZ3NTaG93U3BlZWQgJiYgKFxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17YCR7ZGVza3RvcF9zdHlsZS5zZXR0aW5nc19pdGVtfWB9IG9uQ2xpY2s9eygpID0+IHNldFNldHRpbmdzU2hvd1F1YWxpdHkodHJ1ZSl9PlxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Ake2Rlc2t0b3Bfc3R5bGUucXVhbGl0eV9zZWxlY3Rvcn0gbWF0ZXJpYWwtaWNvbnMtcm91bmRgfT50dW5lPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICBRdWFsaXR5IDxkaXYgY2xhc3NOYW1lPXtkZXNrdG9wX3N0eWxlLmN1cnJlbnRfcXVhbGl0eX0+IHtxdWFsaXR5ID09PSBcImF1dG9cIiA/IFwiQXV0b1wiIDogcXVhbGl0eSA9PSAwID8gXCIzNjBwXCIgOiBxdWFsaXR5ID09IDEgPyBcIjQ4MHBcIiA6IHF1YWxpdHkgPT0gMiA/IFwiNzIwcFwiIDogXCIxMDgwcFwifTwvZGl2PlxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgICAgIHshc2V0dGluZ3NTaG93U3BlZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3NTaG93UXVhbGl0eSAmJlxuICAgICAgICAgICAgICAgICAgICBsZXZlbHMubWFwKChsZXZlbCwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Ake2Rlc2t0b3Bfc3R5bGUuc2V0dGluZ3NfaXRlbX1gfSBrZXk9e2luZGV4fSBvbkNsaWNrPXsoKSA9PiBoYW5kbGVRdWFsaXR5U2VsZWN0KGluZGV4KX0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtsZXZlbC5oZWlnaHR9cFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICB9KX1cblxuICAgICAgICAgICAgICAgIHshc2V0dGluZ3NTaG93UXVhbGl0eSAmJiAhc2V0dGluZ3NTaG93U3BlZWQgJiYgKFxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17YCR7ZGVza3RvcF9zdHlsZS5zZXR0aW5nc19pdGVtfWB9IG9uQ2xpY2s9eygpID0+IHNldFNldHRpbmdzU2hvd1NwZWVkKHRydWUpfT5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtgJHtkZXNrdG9wX3N0eWxlLnF1YWxpdHlfc2VsZWN0b3J9IG1hdGVyaWFsLWljb25zLXJvdW5kYH0+c2xvd19tb3Rpb25fdmlkZW88L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgIFBsYXliYWNrIFNwZWVkXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICl9XG4gICAgICAgICAgICAgICAge3NldHRpbmdzU2hvd1NwZWVkICYmXG4gICAgICAgICAgICAgICAgICAgICFzZXR0aW5nc1Nob3dRdWFsaXR5ICYmXG4gICAgICAgICAgICAgICAgICAgIHBsYXliYWNrU3BlZWRzTGlzdC5tYXAoKHNwZWVkLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17YCR7ZGVza3RvcF9zdHlsZS5zZXR0aW5nc19pdGVtfWB9IGtleT17aW5kZXh9IG9uQ2xpY2s9eygpID0+IGhhbmRsZVNwZWVkU2VsZWN0KHNwZWVkKX0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtzcGVlZH14XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIH0pfVxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17ZGVza3RvcF9zdHlsZS5jZW50ZXJfb25fc2NyZWVufT57bG9hZGluZyAmJiA8TG9hZGluZyB3PXtcIjcwcHhcIn0gaD17XCI3MHB4XCJ9IC8+fTwvZGl2PlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Ake2Rlc2t0b3Bfc3R5bGUuY29udHJvbHNfd3JhcHBlcn0gJHtwbGF5aW5nQWQgJiYgZGVza3RvcF9zdHlsZS5oaWRlX2NvbnRyb2xzfSAke2lzUGxheWluZyA/IFtdIDogZGVza3RvcF9zdHlsZS5zaG93X2NvbnRyb2xzfWB9PlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtkZXNrdG9wX3N0eWxlLmNvbnRyb2xzfT5cbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Ake2Rlc2t0b3Bfc3R5bGUudGltZWxpbmVfd3JhcH1gfT5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtkZXNrdG9wX3N0eWxlLnRpbWVsaW5lX3BhbmVsfT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IHJlZj17dGltZWxpbmVDb250cm9sbGVyfSBjbGFzc05hbWU9e2Rlc2t0b3Bfc3R5bGUudGltZWxpbmVfc2xpZGVyfT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Rlc2t0b3Bfc3R5bGUudGltZWxpbmVfc2xpZGVyX3RyYWNrfT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtkZXNrdG9wX3N0eWxlLnRpbWVsaW5lX3NsaWRlcl9wcm9ncmVzc30gc3R5bGU9e3sgd2lkdGg6IGR1cmF0aW9uLnBlcmNlbnRhZ2UgKyBcIiVcIiB9fT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17ZGVza3RvcF9zdHlsZS50aW1lbGluZV9zbGlkZXJfaGFuZGxlfT48L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17ZGVza3RvcF9zdHlsZS5ib3R0b21fY29udHJvbHN9PlxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Ake2Rlc2t0b3Bfc3R5bGUuY29udHJvbHNfbGVmdH1gfT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17YCR7ZGVza3RvcF9zdHlsZS5wYXVzZV9wbGF5X2J0bn0gJHtkZXNrdG9wX3N0eWxlLmJ0bn1gfT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Ake2Rlc2t0b3Bfc3R5bGUucGxheV9wYXVzZX0gbWF0ZXJpYWwtaWNvbnMtcm91bmRgfSBvbkNsaWNrPXsoKSA9PiBoYW5kbGVQbGF5UGF1c2UoKX0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7aXNQbGF5aW5nID8gXCJwYXVzZVwiIDogXCJwbGF5X2Fycm93XCJ9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtgJHtkZXNrdG9wX3N0eWxlLnZvbHVtZV93cmFwfSAke3Nob3dWb2x1bWUgPyBkZXNrdG9wX3N0eWxlLnZvbHVtZV9zaG93IDogW119YH0gb25Nb3VzZUVudGVyPXsoKSA9PiBzZXRTaG93Vm9sdW1lKHRydWUpfSBvbk1vdXNlTGVhdmU9eygpID0+IHNldFNob3dWb2x1bWUoZmFsc2UpfT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Ake2Rlc2t0b3Bfc3R5bGUudm9sdW1lX2J0bn0gbWF0ZXJpYWwtaWNvbnMtcm91bmQgJHtkZXNrdG9wX3N0eWxlLmJ0bn1gfSBvbkNsaWNrPXsoKSA9PiBoYW5kbGVNdXRlKCl9PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge3ZvbHVtZS52b2x1bWVfaWNvbn1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtkZXNrdG9wX3N0eWxlLnZvbHVtZV9wYW5lbH0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IHJlZj17dm9sdW1lQ29udHJvbGxlcn0gY2xhc3NOYW1lPXtkZXNrdG9wX3N0eWxlLnZvbHVtZV9zbGlkZXJ9PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtkZXNrdG9wX3N0eWxlLnZvbHVtZV9zbGlkZXJfdHJhY2t9PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17ZGVza3RvcF9zdHlsZS52b2x1bWVfc2xpZGVyX3Byb2dyZXNzfSBzdHlsZT17eyB3aWR0aDogdm9sdW1lLnZvbHVtZUxldmVsICsgXCIlXCIgfX0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17ZGVza3RvcF9zdHlsZS52b2x1bWVfc2xpZGVyX2hhbmRsZX0+PC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtkZXNrdG9wX3N0eWxlLmR1cmF0aW9uX3dyYXBwZXJ9PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17ZGVza3RvcF9zdHlsZS5kdXJhdGlvbn0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17ZGVza3RvcF9zdHlsZS5kdXJhdGlvbl9jdXJyZW50fT57ZHVyYXRpb24uY3VycmVudER1cmF0aW9ufTwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Rlc2t0b3Bfc3R5bGUuZHVyYXRpb25fc2VwYXJhdG9yfT4vPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17ZGVza3RvcF9zdHlsZS5kdXJhdGlvbl90b3RhbH0+e2R1cmF0aW9uLnRvdGFsRHVyYXRpb259PC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17ZGVza3RvcF9zdHlsZS5jb250cm9sc19yaWdodH0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Ake2Rlc2t0b3Bfc3R5bGUubWluaV9wbGF5ZXJfY29udGFpbmVyfSAke2Rlc2t0b3Bfc3R5bGUuYnRufWB9PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17YCR7ZGVza3RvcF9zdHlsZS5zZXR0aW5nc19idG59IG1hdGVyaWFsLWljb25zLXJvdW5kYH0gc3R5bGU9e3Nob3dTZXR0aW5ncyA/IHsgdHJhbnNmb3JtOiBcInJvdGF0ZVooMzBkZWcpXCIgfSA6IFtdfSBvbkNsaWNrPXsoKSA9PiBoYW5kbGVTZXR0aW5ncygpfT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtgJHtkZXNrdG9wX3N0eWxlLm1pbmlfcGxheWVyX2NvbnRhaW5lcn0gJHtkZXNrdG9wX3N0eWxlLmJ0bn1gfT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Ake2Rlc2t0b3Bfc3R5bGUubWluaV9wbGF5ZXJfYnRufSBtYXRlcmlhbC1pY29ucy1yb3VuZGB9IG9uQ2xpY2s9eygpID0+IGhhbmRsZVBpY3R1cmVJblBpY3R1cmUoKX0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmFuZGluZ193YXRlcm1hcmtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2Ake2Rlc2t0b3Bfc3R5bGUudGhlYXRlcl9jb250YWluZXJ9ICR7ZGVza3RvcF9zdHlsZS5idG59YH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlVGhlYXRlck1vZGUoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Ake2Rlc2t0b3Bfc3R5bGUudGhlYXRlcl9idG59IG1hdGVyaWFsLWljb25zLXJvdW5kYH0+e3RoZWF0ZXJNb2RlID8gXCJjcm9wXzdfNVwiIDogXCJjcm9wXzdfNVwifTwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtgJHtkZXNrdG9wX3N0eWxlLmZ1bGxzY3JlZW5fY29udGFpbmVyfSAke2Rlc2t0b3Bfc3R5bGUuYnRufWB9PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17YCR7ZGVza3RvcF9zdHlsZS5mdWxsc2NyZWVuX2J0bn0gbWF0ZXJpYWwtaWNvbnMtcm91bmRgfSBvbkNsaWNrPXsoKSA9PiBoYW5kbGVGdWxsU2NyZWVuKCl9PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge2Z1bGxzY3JlZW4gPyBcImZ1bGxzY3JlZW5fZXhpdFwiIDogXCJmdWxsc2NyZWVuXCJ9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8dmlkZW8gYXV0b1BsYXkgY29udHJvbHM9e2ZhbHNlfSByZWY9e3ZpZGVvQ29udHJvbGxlcn0gY2xhc3NOYW1lPXtkZXNrdG9wX3N0eWxlLnZpZGVvfSBvbkNsaWNrPXsoKSA9PiBoYW5kbGVQbGF5UGF1c2UoKX0gLz5cbiAgICAgICAgICAgIHsvKiA8dmlkZW8gb25DbGljaz17KCkgPT4gaGFuZGxlUGxheVBhdXNlKCl9IHJlZj17dmlkZW9Db250cm9sbGVyfSBjbGFzc05hbWU9e2Rlc2t0b3Bfc3R5bGUudmlkZW99IHNyYz17YGh0dHBzOi8vcmFrYS56b25lL2Rldi9hcGkvZG93bmxvYWRzL291dHB1dC8ke3Byb3BzLnZpZGVvSWR9L0hMUy9pbmRleC5tM3U4YH0gLz4gKi99XG4gICAgICAgIDwvZGl2PlxuICAgIClcbn1cbiJdLCJuYW1lcyI6WyJ1c2VSZWYiLCJ1c2VTdGF0ZSIsInVzZUVmZmVjdCIsImRlc2t0b3Bfc3R5bGUiLCJtb2JpbGVfc3R5bGUiLCJ0b2FzdFNlcnZpY2UiLCJJbWFnZSIsInRlc3RJbWFnZSIsImZvcm1hdER1cmF0aW9uIiwiTG9hZGluZyIsIkhscyIsIlZpZGVvUGxheWVyRGVza3RvcCIsInByb3BzIiwic3JjIiwidmlkZW9JZCIsImFkU3JjIiwicGxheWJhY2tTcGVlZHNMaXN0IiwidmlkZW9QbGF5ZXIiLCJ2aWRlb0NvbnRyb2xsZXIiLCJ2b2x1bWVDb250cm9sbGVyIiwidGltZWxpbmVDb250cm9sbGVyIiwiaXNQbGF5aW5nIiwic2V0SXNQbGF5aW5nIiwic2hvd1ZvbHVtZSIsInNldFNob3dWb2x1bWUiLCJmdWxsc2NyZWVuIiwic2V0RnVsbHNjcmVlbiIsInBsYXlpbmdBZCIsInNldFBsYXlpbmdBZCIsInRoZWF0ZXJNb2RlIiwic2V0VGhlYXRlck1vZGUiLCJzaG93RW5kU2NyZWVuIiwic2V0U2hvd0VuZFNjcmVlbiIsInNob3dTZXR0aW5ncyIsInNldFNob3dTZXR0aW5ncyIsImxvYWRpbmciLCJzZXRMb2FkaW5nIiwiY3VycmVudER1cmF0aW9uIiwidG90YWxEdXJhdGlvbiIsInBlcmNlbnRhZ2UiLCJkdXJhdGlvbiIsInNldER1cmF0aW9uIiwidm9sdW1lTGV2ZWwiLCJ2b2x1bWVfaWNvbiIsImxhc3RWb2x1bWUiLCJ2b2x1bWUiLCJzZXRWb2x1bWUiLCJzZXR0aW5nc1Nob3dRdWFsaXR5Iiwic2V0U2V0dGluZ3NTaG93UXVhbGl0eSIsInNldHRpbmdzU2hvd1NwZWVkIiwic2V0U2V0dGluZ3NTaG93U3BlZWQiLCJxdWFsaXR5Iiwic2V0UXVhbGl0eSIsImxldmVscyIsInNldExldmVscyIsImhhbmRsZVRoZWF0ZXJNb2RlIiwiaGFuZGxlU2V0dGluZ3MiLCJoYW5kbGVRdWFsaXR5U2VsZWN0IiwicSIsImhhbmRsZVNwZWVkU2VsZWN0IiwicyIsImN1cnJlbnQiLCJwbGF5YmFja1JhdGUiLCJjYWxjdWxhdGVWb2x1bWUiLCJjbGljayIsImVsbSIsInZvbHVtZV93aWR0aCIsIm9mZnNldFdpZHRoIiwiY2xpY2tfeCIsImNsaWVudFgiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJsZWZ0IiwidG9GaXhlZCIsImhhbmRsZUZ1bGxTY3JlZW4iLCJkb2N1bWVudCIsImZ1bGxzY3JlZW5FbGVtZW50IiwiZXhpdEZ1bGxzY3JlZW4iLCJyZXF1ZXN0RnVsbHNjcmVlbiIsIndlYmtpdFJlcXVlc3RGdWxsc2NyZWVuIiwibW96UmVxdWVzdEZ1bGxTY3JlZW4iLCJtc1JlcXVlc3RGdWxsc2NyZWVuIiwiaGFuZGxlUGljdHVyZUluUGljdHVyZSIsInBpY3R1cmVJblBpY3R1cmVFbGVtZW50IiwiZXhpdFBpY3R1cmVJblBpY3R1cmUiLCJyZXF1ZXN0UGljdHVyZUluUGljdHVyZSIsImhhbmRsZU11dGUiLCJtdXRlZCIsImhhbmRsZVBsYXlQYXVzZSIsInBhdXNlZCIsInBsYXkiLCJwYXVzZSIsImhhbmRsZVZvbHVtZSIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJoYW5kbGVWb2x1bWVTbGlkZXIiLCJoYW5kbGVUaW1lbGluZSIsImhhbmRsZVRpbWVsaW5lU2xpZGVyIiwiZSIsInByZXZlbnREZWZhdWx0Iiwic2xpZGVyIiwiZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSIsInZvbHVtZV9zbGlkZXIiLCJwZXJjZW50IiwidGltZWxpbmVfc2xpZGVyIiwiY3VycmVudFRpbWUiLCJhZGRFdmVudExpc3RlbmVyIiwidGFyZ2V0IiwiY2xhc3NMaXN0IiwiY29udGFpbnMiLCJ2aWRlbyIsIm9ua2V5ZG93biIsImtleSIsImRlZmF1bHRPcHRpb25zIiwic3RhcnRMZXZlbCIsImxpY2Vuc2VYaHJTZXR1cCIsInhociIsInVybCIsIndpdGhDcmVkZW50aWFscyIsInJlYWR5U3RhdGUiLCJvcGVuIiwic2V0UmVxdWVzdEhlYWRlciIsInJlYnVpbGQiLCJobHMiLCJsb2FkU291cmNlIiwiYXR0YWNoTWVkaWEiLCJyZW1vdmVBdHRyaWJ1dGUiLCJhdXRvUGxheSIsImNhblBsYXlUeXBlIiwiaXNJT1MiLCJzZXRBdHRyaWJ1dGUiLCJpc1N1cHBvcnRlZCIsImNvbnNvbGUiLCJlcnJvciIsImluY2x1ZGVzIiwiZGVzdHJveSIsIm9uY2UiLCJFdmVudHMiLCJMRVZFTF9MT0FERUQiLCJldmVudCIsImRhdGEiLCJsZXZlbF9kdXJhdGlvbiIsImRldGFpbHMiLCJ0b3RhbGR1cmF0aW9uIiwiTUFOSUZFU1RfUEFSU0VEIiwiY3VycmVudExldmVsIiwiZGl2IiwiY2xhc3NOYW1lIiwidmlkZW9fd3JhcHBlciIsInRoZWF0ZXJfbW9kZSIsInJlZiIsInBsYXlpbmdfYWRfd3JhcHBlciIsInNldHRpbmdzX3BvcHVwIiwic2V0dGluZ3NfcG9wdXBfc2hvdyIsInN0eWxlIiwiZGlzcGxheSIsInNldHRpbmdzX2l0ZW0iLCJvbkNsaWNrIiwicXVhbGl0eV9zZWxlY3RvciIsImN1cnJlbnRfcXVhbGl0eSIsIm1hcCIsImxldmVsIiwiaW5kZXgiLCJoZWlnaHQiLCJzcGVlZCIsImNlbnRlcl9vbl9zY3JlZW4iLCJ3IiwiaCIsImNvbnRyb2xzX3dyYXBwZXIiLCJoaWRlX2NvbnRyb2xzIiwic2hvd19jb250cm9scyIsImNvbnRyb2xzIiwidGltZWxpbmVfd3JhcCIsInRpbWVsaW5lX3BhbmVsIiwidGltZWxpbmVfc2xpZGVyX3RyYWNrIiwidGltZWxpbmVfc2xpZGVyX3Byb2dyZXNzIiwid2lkdGgiLCJ0aW1lbGluZV9zbGlkZXJfaGFuZGxlIiwiYm90dG9tX2NvbnRyb2xzIiwiY29udHJvbHNfbGVmdCIsInBhdXNlX3BsYXlfYnRuIiwiYnRuIiwicGxheV9wYXVzZSIsInZvbHVtZV93cmFwIiwidm9sdW1lX3Nob3ciLCJvbk1vdXNlRW50ZXIiLCJvbk1vdXNlTGVhdmUiLCJ2b2x1bWVfYnRuIiwidm9sdW1lX3BhbmVsIiwidm9sdW1lX3NsaWRlcl90cmFjayIsInZvbHVtZV9zbGlkZXJfcHJvZ3Jlc3MiLCJ2b2x1bWVfc2xpZGVyX2hhbmRsZSIsImR1cmF0aW9uX3dyYXBwZXIiLCJkdXJhdGlvbl9jdXJyZW50IiwiZHVyYXRpb25fc2VwYXJhdG9yIiwiZHVyYXRpb25fdG90YWwiLCJjb250cm9sc19yaWdodCIsIm1pbmlfcGxheWVyX2NvbnRhaW5lciIsInNldHRpbmdzX2J0biIsInRyYW5zZm9ybSIsIm1pbmlfcGxheWVyX2J0biIsInRoZWF0ZXJfY29udGFpbmVyIiwidGhlYXRlcl9idG4iLCJmdWxsc2NyZWVuX2NvbnRhaW5lciIsImZ1bGxzY3JlZW5fYnRuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/components/VideoPlayer/Desktop.js\n");

/***/ }),

/***/ "./src/components/VideoPlayer/Mobile.js":
/*!**********************************************!*\
  !*** ./src/components/VideoPlayer/Mobile.js ***!
  \**********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"VideoPlayerMobile\": function() { return /* binding */ VideoPlayerMobile; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _VideoPlayerMobile_module_css__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./VideoPlayerMobile.module.css */ \"./src/components/VideoPlayer/VideoPlayerMobile.module.css\");\n/* harmony import */ var _VideoPlayerMobile_module_css__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(_VideoPlayerMobile_module_css__WEBPACK_IMPORTED_MODULE_8__);\n/* harmony import */ var _handler_toast_handler_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../handler/toast.handler.js */ \"./src/handler/toast.handler.js\");\n/* harmony import */ var next_image_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! next/image.js */ \"./node_modules/next/image.js\");\n/* harmony import */ var next_image_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(next_image_js__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _assets_img_png_insta07_png__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../assets/img/png/insta07.png */ \"./src/assets/img/png/insta07.png\");\n/* harmony import */ var _util_functions_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../util/functions.js */ \"./src/util/functions.js\");\n/* harmony import */ var components_Loading__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! components/Loading */ \"./src/components/Loading/index.js\");\n/* harmony import */ var hls_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! hls.js */ \"./node_modules/hls.js/dist/hls.js\");\n/* harmony import */ var hls_js__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(hls_js__WEBPACK_IMPORTED_MODULE_7__);\nfunction _defineProperty(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _objectSpread(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        var ownKeys = Object.keys(source);\n        if (typeof Object.getOwnPropertySymbols === \"function\") {\n            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n            }));\n        }\n        ownKeys.forEach(function(key) {\n            _defineProperty(target, key, source[key]);\n        });\n    }\n    return target;\n}\n\n\n\n\n\n\n\n\n\nvar _s = $RefreshSig$();\nfunction VideoPlayerMobile(props) {\n    var _this = this;\n    _s();\n    var src1 = \"https://keviv.xyz/api/downloads/output/\".concat(props.videoId, \"/HLS/playlist.m3u8\");\n    var adSrc = props.adSrc;\n    var playbackSpeedsList = [\n        0.5,\n        0.75,\n        1,\n        1.25,\n        1.5,\n        1.75,\n        2\n    ];\n    var videoPlayer = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    var videoController = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    var timelineController = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    var ref14 = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false), isPlaying = ref14[0], setIsPlaying = ref14[1];\n    var ref1 = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false), fullscreen = ref1[0], setFullscreen = ref1[1];\n    var ref2 = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false), showEndScreen = ref2[0], setShowEndScreen = ref2[1];\n    // settings\n    var ref3 = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false), showSettings = ref3[0], setShowSettings = ref3[1];\n    var ref4 = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false), settingsShowQuality = ref4[0], setSettingsShowQuality = ref4[1];\n    var ref5 = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false), settingsShowSpeed = ref5[0], setSettingsShowSpeed = ref5[1];\n    var ref6 = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true), muted = ref6[0], setMuted = ref6[1];\n    var ref7 = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true), showControls = ref7[0], setShowControls = ref7[1];\n    var ref8 = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false), playingAd = ref8[0], setPlayingAd = ref8[1];\n    var ref9 = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true), loading = ref9[0], setLoading = ref9[1];\n    var ref10 = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n        currentDuration: 0,\n        totalDuration: 0,\n        percentage: 0\n    }), duration = ref10[0], setDuration = ref10[1];\n    var ref11 = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"auto\"), quality = ref11[0], setQuality = ref11[1];\n    var ref12 = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]), levels = ref12[0], setLevels = ref12[1];\n    // some functions\n    var _closeSettings = function() {\n        setShowSettings(false);\n        setSettingsShowQuality(false);\n        setSettingsShowSpeed(false);\n    };\n    var handleSettings = function() {\n        if (showSettings) {\n            setSettingsShowQuality(false);\n            setSettingsShowSpeed(false);\n            setShowSettings(false);\n        } else {\n            setShowSettings(true);\n        }\n    };\n    var handleQualitySelect = function(q) {\n        handleSettings();\n        setQuality(q);\n    };\n    var handleSpeedSelect = function(s) {\n        handleSettings();\n        videoController.current.playbackRate = s;\n    };\n    var calculateSlider = function(click, elm) {\n        var volume_width = elm.offsetWidth;\n        var click_x = click.clientX - elm.getBoundingClientRect().left;\n        var volume = (click_x / volume_width * 100).toFixed(0);\n        return volume;\n    };\n    var handleFullScreen = function() {\n        if (document.fullscreenElement != null) {\n            setFullscreen(false);\n            return document.exitFullscreen();\n        }\n        if (videoPlayer.current.requestFullscreen) {\n            videoPlayer.current.requestFullscreen();\n        } else if (videoPlayer.current.webkitRequestFullscreen) {\n            videoPlayer.current.webkitRequestFullscreen();\n        } else if (videoPlayer.current.mozRequestFullScreen) {\n            videoPlayer.current.mozRequestFullScreen();\n        } else if (videoPlayer.current.msRequestFullscreen) {\n            videoPlayer.current.msRequestFullscreen();\n        }\n        setFullscreen(true);\n    };\n    var handlePlayPause = function() {\n        if (!showControls) return;\n        if (showSettings) return setShowSettings(false);\n        if (videoController.current.paused) {\n            setIsPlaying(true);\n            videoController.current.play();\n            setTimeout(function() {\n                setShowControls(false);\n            }, 1000);\n        } else {\n            setIsPlaying(false);\n            videoController.current.pause();\n        }\n    };\n    var handleUnmute = function() {\n        setMuted(false);\n        videoController.current.muted = false;\n    };\n    var handleTimeline = function() {\n        document.removeEventListener(\"mousemove\", handleTimelineSlider);\n        document.removeEventListener(\"mouseup\", handleTimeline);\n    };\n    var handleTimelineSlider = function(e) {\n        e.preventDefault();\n        var slider = document.getElementsByClassName((_VideoPlayerMobile_module_css__WEBPACK_IMPORTED_MODULE_8___default().timeline_slider))[0];\n        var percent = calculateSlider(e, slider);\n        if (percent < 0) {\n            percent = 0;\n        } else if (percent > 100) {\n            percent = 100;\n        }\n        videoController.current.currentTime = percent / 100 * videoController.current.duration;\n        setDuration({\n            currentDuration: (0,_util_functions_js__WEBPACK_IMPORTED_MODULE_5__.formatDuration)(videoController.current.currentTime),\n            totalDuration: (0,_util_functions_js__WEBPACK_IMPORTED_MODULE_5__.formatDuration)(videoController.current.duration),\n            percentage: percent\n        });\n    };\n    var onPressForwardOrBackward = function(number) {\n        setTimeout(function() {\n            setShowControls(false);\n        }, 1000);\n        videoController.current.currentTime = videoController.current.currentTime + number;\n    };\n    var _handleClick = function(event) {\n        if (!showControls && !event) return setShowControls(true);\n        if (event === \"settings\") {\n            return setShowSettings(true);\n        } else if (event === \"forward\") {\n            return onPressForwardOrBackward(10);\n        } else if (event === \"backward\") {\n            return onPressForwardOrBackward(-10);\n        } else if (event === \"PlayPause\") {\n            return handlePlayPause();\n        } else if (event === \"fullscreen\") {\n            return handleFullScreen();\n        } else {\n            if (showControls) return setShowControls(false);\n        }\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function() {\n        // Event Listeners\n        videoController.current.addEventListener(\"timeupdate\", function() {\n            if (playingAd) return;\n            setLoading(false);\n            setDuration({\n                currentDuration: (0,_util_functions_js__WEBPACK_IMPORTED_MODULE_5__.formatDuration)(videoController.current.currentTime),\n                totalDuration: (0,_util_functions_js__WEBPACK_IMPORTED_MODULE_5__.formatDuration)(videoController.current.duration),\n                percentage: videoController.current.currentTime / videoController.current.duration * 100\n            });\n        });\n        videoController.current.addEventListener(\"loadeddata\", function() {\n            // videoController.current.volume = 50 / 100\n            setLoading(false);\n            setDuration({\n                currentDuration: (0,_util_functions_js__WEBPACK_IMPORTED_MODULE_5__.formatDuration)(videoController.current.currentTime),\n                totalDuration: (0,_util_functions_js__WEBPACK_IMPORTED_MODULE_5__.formatDuration)(videoController.current.duration),\n                percentage: videoController.current.currentTime / videoController.current.duration * 100\n            });\n        });\n        timelineController.current.addEventListener(\"mousedown\", function(e) {\n            if (playingAd) return;\n            document.addEventListener(\"mousemove\", handleTimelineSlider);\n            document.addEventListener(\"mouseup\", function(e) {\n                return handleTimeline();\n            });\n        });\n        timelineController.current.addEventListener(\"click\", function(e) {\n            if (playingAd) return;\n            handleTimelineSlider(e);\n        });\n        return function() {};\n    }, [\n        playingAd\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function() {\n        // --------------------------------------------------\n        var defaultOptions = {\n            startLevel: -1,\n            licenseXhrSetup: function licenseXhrSetup(xhr, url) {\n                xhr.withCredentials = true // do send cookies\n                ;\n                if (!xhr.readyState) {\n                    // Call open to change the method (default is POST) or modify the url\n                    xhr.open(\"GET\", url, true);\n                    // Append headers after opening\n                    xhr.setRequestHeader(\"Content-Type\", \"application/octet-stream\");\n                }\n            }\n        };\n        var rebuild = function(video, src) {\n            setLoading(true);\n            var hls = new (hls_js__WEBPACK_IMPORTED_MODULE_7___default())(defaultOptions);\n            hls.loadSource(src);\n            hls.attachMedia(video);\n            return hls;\n        };\n        var hls1 = new (hls_js__WEBPACK_IMPORTED_MODULE_7___default())(defaultOptions);\n        var video1 = videoController.current;\n        video1.removeAttribute(\"controls\");\n        video1.autoPlay = true;\n        video1.muted = true;\n        setLoading(true);\n        if (!video1) return;\n        if (video1.canPlayType(\"application/vnd.apple.mpegurl\") && props.isIOS) {\n            video1.removeAttribute(\"controls\");\n            video1.setAttribute(\"webkit-playsinline\", \"\");\n            video1.setAttribute(\"playsinline\", \"\");\n            video1.setAttribute(\"x-webkit-airplay\", \"allow\");\n            video1.setAttribute(\"x5-video-player-type\", \"h5\");\n            video1.setAttribute(\"x5-video-player-fullscreen\", \"false\");\n            video1.setAttribute(\"x5-video-orientation\", \"portraint\");\n            if (adSrc) {\n                setPlayingAd(true);\n                video1.src = adSrc;\n            } else {\n                video1.src = src1;\n            }\n        } else if (hls_js__WEBPACK_IMPORTED_MODULE_7___default().isSupported()) {\n            // This will run in all other modern browsers\n            if (adSrc) {\n                setPlayingAd(true);\n                hls1.loadSource(adSrc);\n            } else {\n                hls1.loadSource(src1);\n            }\n            hls1.attachMedia(video1);\n        } else {\n            console.error(\"This is an old browser that does not support MSE https://developer.mozilla.org/en-US/docs/Web/API/Media_Source_Extensions_API\");\n        }\n        video1.addEventListener(\"ended\", function() {\n            var ref, ref13;\n            if (video1.src === adSrc || ((ref13 = (ref = hls1 === null || hls1 === void 0 ? void 0 : hls1.levels[0]) === null || ref === void 0 ? void 0 : ref.url[0]) === null || ref13 === void 0 ? void 0 : ref13.includes(\"Ad\"))) {\n                setPlayingAd(false);\n                if (video1.canPlayType(\"application/vnd.apple.mpegurl\") && props.isIOS) {\n                    video1.src = src1;\n                } else {\n                    hls1.destroy();\n                    hls1 = rebuild(video1, src1);\n                }\n            }\n        });\n        hls1.once((hls_js__WEBPACK_IMPORTED_MODULE_7___default().Events.LEVEL_LOADED), function(event, data) {\n            setLoading(false);\n            var level_duration = data.details.totalduration;\n            setDuration(_objectSpread({}, duration, {\n                totalDuration: (0,_util_functions_js__WEBPACK_IMPORTED_MODULE_5__.formatDuration)(level_duration),\n                currentDuration: (0,_util_functions_js__WEBPACK_IMPORTED_MODULE_5__.formatDuration)(video1.currentTime)\n            }));\n        });\n        hls1.once((hls_js__WEBPACK_IMPORTED_MODULE_7___default().Events.MANIFEST_PARSED), function(event, data) {\n            setLoading(false);\n            setLevels(data.levels);\n            hls1.currentLevel = quality === \"auto\" ? -1 : quality;\n        });\n        video1.addEventListener(\"waiting\", function() {\n            setIsPlaying(false);\n            setLoading(true);\n        });\n        video1.addEventListener(\"playing\", function() {\n            setIsPlaying(true);\n            setLoading(false);\n        });\n        return function() {\n            hls1.destroy();\n        };\n    }, [\n        quality\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: (_VideoPlayerMobile_module_css__WEBPACK_IMPORTED_MODULE_8___default().video_wrapper),\n        ref: videoPlayer,\n        onClick: function() {\n            return _handleClick();\n        },\n        children: [\n            playingAd && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: (_VideoPlayerMobile_module_css__WEBPACK_IMPORTED_MODULE_8___default().playing_ad_wrapper),\n                children: \"Ad\"\n            }, void 0, false, {\n                fileName: \"/home/isolated/rakazone/rakazone-frontend/src/components/VideoPlayer/Mobile.js\",\n                lineNumber: 286,\n                columnNumber: 17\n            }, this),\n            muted && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: (_VideoPlayerMobile_module_css__WEBPACK_IMPORTED_MODULE_8___default().unmute_button),\n                onClick: function() {\n                    return handleUnmute();\n                },\n                children: \"Unmute\"\n            }, void 0, false, {\n                fileName: \"/home/isolated/rakazone/rakazone-frontend/src/components/VideoPlayer/Mobile.js\",\n                lineNumber: 291,\n                columnNumber: 17\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"\".concat((_VideoPlayerMobile_module_css__WEBPACK_IMPORTED_MODULE_8___default().controls), \" \").concat(playingAd && (_VideoPlayerMobile_module_css__WEBPACK_IMPORTED_MODULE_8___default().hide_controls), \"  \").concat(showControls && (_VideoPlayerMobile_module_css__WEBPACK_IMPORTED_MODULE_8___default().show_controls)),\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: (_VideoPlayerMobile_module_css__WEBPACK_IMPORTED_MODULE_8___default().top_controls),\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            onClick: function() {\n                                return _handleClick(\"settings\");\n                            },\n                            className: \"\".concat((_VideoPlayerMobile_module_css__WEBPACK_IMPORTED_MODULE_8___default().settings), \" material-icons-round\"),\n                            children: \"settings\"\n                        }, void 0, false, {\n                            fileName: \"/home/isolated/rakazone/rakazone-frontend/src/components/VideoPlayer/Mobile.js\",\n                            lineNumber: 295,\n                            columnNumber: 21\n                        }, this)\n                    }, void 0, false, {\n                        fileName: \"/home/isolated/rakazone/rakazone-frontend/src/components/VideoPlayer/Mobile.js\",\n                        lineNumber: 294,\n                        columnNumber: 17\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: (_VideoPlayerMobile_module_css__WEBPACK_IMPORTED_MODULE_8___default().middle_controls),\n                        children: loading ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(components_Loading__WEBPACK_IMPORTED_MODULE_6__[\"default\"], {\n                            w: \"40px\",\n                            h: \"40px\"\n                        }, void 0, false, {\n                            fileName: \"/home/isolated/rakazone/rakazone-frontend/src/components/VideoPlayer/Mobile.js\",\n                            lineNumber: 301,\n                            columnNumber: 25\n                        }, this) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: \"\".concat((_VideoPlayerMobile_module_css__WEBPACK_IMPORTED_MODULE_8___default().skip_previous_btn), \" material-icons-round\"),\n                                    onClick: function() {\n                                        return _handleClick(\"backward\");\n                                    },\n                                    children: \"replay_10\"\n                                }, void 0, false, {\n                                    fileName: \"/home/isolated/rakazone/rakazone-frontend/src/components/VideoPlayer/Mobile.js\",\n                                    lineNumber: 304,\n                                    columnNumber: 29\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: \"\".concat((_VideoPlayerMobile_module_css__WEBPACK_IMPORTED_MODULE_8___default().play_pause_btn), \" material-icons-round\"),\n                                    onClick: function() {\n                                        return _handleClick(\"PlayPause\");\n                                    },\n                                    children: isPlaying ? \"pause\" : \"play_arrow\"\n                                }, void 0, false, {\n                                    fileName: \"/home/isolated/rakazone/rakazone-frontend/src/components/VideoPlayer/Mobile.js\",\n                                    lineNumber: 307,\n                                    columnNumber: 29\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: \"\".concat((_VideoPlayerMobile_module_css__WEBPACK_IMPORTED_MODULE_8___default().skip_next_btn), \" material-icons-round\"),\n                                    onClick: function() {\n                                        return _handleClick(\"forward\");\n                                    },\n                                    children: \"forward_10\"\n                                }, void 0, false, {\n                                    fileName: \"/home/isolated/rakazone/rakazone-frontend/src/components/VideoPlayer/Mobile.js\",\n                                    lineNumber: 310,\n                                    columnNumber: 29\n                                }, this)\n                            ]\n                        }, void 0, true)\n                    }, void 0, false, {\n                        fileName: \"/home/isolated/rakazone/rakazone-frontend/src/components/VideoPlayer/Mobile.js\",\n                        lineNumber: 299,\n                        columnNumber: 17\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: (_VideoPlayerMobile_module_css__WEBPACK_IMPORTED_MODULE_8___default().bottom_controls),\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: (_VideoPlayerMobile_module_css__WEBPACK_IMPORTED_MODULE_8___default().duration_wrapper),\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        className: (_VideoPlayerMobile_module_css__WEBPACK_IMPORTED_MODULE_8___default().duration),\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                className: (_VideoPlayerMobile_module_css__WEBPACK_IMPORTED_MODULE_8___default().duration_current),\n                                                children: duration.currentDuration\n                                            }, void 0, false, {\n                                                fileName: \"/home/isolated/rakazone/rakazone-frontend/src/components/VideoPlayer/Mobile.js\",\n                                                lineNumber: 319,\n                                                columnNumber: 29\n                                            }, this),\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                className: (_VideoPlayerMobile_module_css__WEBPACK_IMPORTED_MODULE_8___default().duration_separator),\n                                                children: \"/\"\n                                            }, void 0, false, {\n                                                fileName: \"/home/isolated/rakazone/rakazone-frontend/src/components/VideoPlayer/Mobile.js\",\n                                                lineNumber: 320,\n                                                columnNumber: 29\n                                            }, this),\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                className: (_VideoPlayerMobile_module_css__WEBPACK_IMPORTED_MODULE_8___default().duration_total),\n                                                children: duration.totalDuration\n                                            }, void 0, false, {\n                                                fileName: \"/home/isolated/rakazone/rakazone-frontend/src/components/VideoPlayer/Mobile.js\",\n                                                lineNumber: 321,\n                                                columnNumber: 29\n                                            }, this)\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"/home/isolated/rakazone/rakazone-frontend/src/components/VideoPlayer/Mobile.js\",\n                                        lineNumber: 318,\n                                        columnNumber: 25\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        className: \"\".concat((_VideoPlayerMobile_module_css__WEBPACK_IMPORTED_MODULE_8___default().fullscreen_btn), \" material-icons-round\"),\n                                        onClick: function() {\n                                            return _handleClick(\"fullscreen\");\n                                        },\n                                        children: fullscreen ? \"fullscreen_exit\" : \"fullscreen\"\n                                    }, void 0, false, {\n                                        fileName: \"/home/isolated/rakazone/rakazone-frontend/src/components/VideoPlayer/Mobile.js\",\n                                        lineNumber: 323,\n                                        columnNumber: 25\n                                    }, this)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/home/isolated/rakazone/rakazone-frontend/src/components/VideoPlayer/Mobile.js\",\n                                lineNumber: 317,\n                                columnNumber: 21\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                ref: timelineController,\n                                className: \"\".concat((_VideoPlayerMobile_module_css__WEBPACK_IMPORTED_MODULE_8___default().timeline_wrap)),\n                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: (_VideoPlayerMobile_module_css__WEBPACK_IMPORTED_MODULE_8___default().timeline_panel),\n                                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        className: (_VideoPlayerMobile_module_css__WEBPACK_IMPORTED_MODULE_8___default().timeline_slider),\n                                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                            className: (_VideoPlayerMobile_module_css__WEBPACK_IMPORTED_MODULE_8___default().timeline_slider_track),\n                                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                className: (_VideoPlayerMobile_module_css__WEBPACK_IMPORTED_MODULE_8___default().timeline_slider_progress),\n                                                style: {\n                                                    width: duration.percentage + \"%\"\n                                                },\n                                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                    className: (_VideoPlayerMobile_module_css__WEBPACK_IMPORTED_MODULE_8___default().timeline_slider_handle)\n                                                }, void 0, false, {\n                                                    fileName: \"/home/isolated/rakazone/rakazone-frontend/src/components/VideoPlayer/Mobile.js\",\n                                                    lineNumber: 332,\n                                                    columnNumber: 41\n                                                }, this)\n                                            }, void 0, false, {\n                                                fileName: \"/home/isolated/rakazone/rakazone-frontend/src/components/VideoPlayer/Mobile.js\",\n                                                lineNumber: 331,\n                                                columnNumber: 37\n                                            }, this)\n                                        }, void 0, false, {\n                                            fileName: \"/home/isolated/rakazone/rakazone-frontend/src/components/VideoPlayer/Mobile.js\",\n                                            lineNumber: 330,\n                                            columnNumber: 33\n                                        }, this)\n                                    }, void 0, false, {\n                                        fileName: \"/home/isolated/rakazone/rakazone-frontend/src/components/VideoPlayer/Mobile.js\",\n                                        lineNumber: 329,\n                                        columnNumber: 29\n                                    }, this)\n                                }, void 0, false, {\n                                    fileName: \"/home/isolated/rakazone/rakazone-frontend/src/components/VideoPlayer/Mobile.js\",\n                                    lineNumber: 328,\n                                    columnNumber: 25\n                                }, this)\n                            }, void 0, false, {\n                                fileName: \"/home/isolated/rakazone/rakazone-frontend/src/components/VideoPlayer/Mobile.js\",\n                                lineNumber: 327,\n                                columnNumber: 21\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/home/isolated/rakazone/rakazone-frontend/src/components/VideoPlayer/Mobile.js\",\n                        lineNumber: 316,\n                        columnNumber: 17\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/home/isolated/rakazone/rakazone-frontend/src/components/VideoPlayer/Mobile.js\",\n                lineNumber: 293,\n                columnNumber: 13\n            }, this),\n            showSettings && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"\".concat((_VideoPlayerMobile_module_css__WEBPACK_IMPORTED_MODULE_8___default().bottom_settings_popup_wrapper)),\n                onClick: function() {\n                    return _closeSettings();\n                }\n            }, void 0, false, {\n                fileName: \"/home/isolated/rakazone/rakazone-frontend/src/components/VideoPlayer/Mobile.js\",\n                lineNumber: 340,\n                columnNumber: 30\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"\".concat((_VideoPlayerMobile_module_css__WEBPACK_IMPORTED_MODULE_8___default().bottom_settings_popup), \" \").concat(showSettings && (_VideoPlayerMobile_module_css__WEBPACK_IMPORTED_MODULE_8___default().show_setting)),\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: (_VideoPlayerMobile_module_css__WEBPACK_IMPORTED_MODULE_8___default().settings_popup_header),\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"a\", {\n                            className: (_VideoPlayerMobile_module_css__WEBPACK_IMPORTED_MODULE_8___default().settings_popup_title),\n                            children: \"Settings\"\n                        }, void 0, false, {\n                            fileName: \"/home/isolated/rakazone/rakazone-frontend/src/components/VideoPlayer/Mobile.js\",\n                            lineNumber: 343,\n                            columnNumber: 21\n                        }, this)\n                    }, void 0, false, {\n                        fileName: \"/home/isolated/rakazone/rakazone-frontend/src/components/VideoPlayer/Mobile.js\",\n                        lineNumber: 342,\n                        columnNumber: 17\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: (_VideoPlayerMobile_module_css__WEBPACK_IMPORTED_MODULE_8___default().settings_popup_body),\n                        children: [\n                            !settingsShowQuality && !settingsShowSpeed && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: (_VideoPlayerMobile_module_css__WEBPACK_IMPORTED_MODULE_8___default().settings_popup_body_item),\n                                onClick: function() {\n                                    return setSettingsShowQuality(true);\n                                },\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        className: \"\".concat((_VideoPlayerMobile_module_css__WEBPACK_IMPORTED_MODULE_8___default().settings_popup_body_item_icon), \" material-icons-round\"),\n                                        onClick: function() {\n                                            return handlePlayPause();\n                                        },\n                                        children: \"tune\"\n                                    }, void 0, false, {\n                                        fileName: \"/home/isolated/rakazone/rakazone-frontend/src/components/VideoPlayer/Mobile.js\",\n                                        lineNumber: 348,\n                                        columnNumber: 29\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        className: (_VideoPlayerMobile_module_css__WEBPACK_IMPORTED_MODULE_8___default().settings_popup_body_item_text),\n                                        children: [\n                                            \"Quality\",\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                className: (_VideoPlayerMobile_module_css__WEBPACK_IMPORTED_MODULE_8___default().current_quality),\n                                                children: [\n                                                    \" \",\n                                                    quality === \"auto\" ? \"Auto\" : quality == 0 ? \"360p\" : quality == 1 ? \"480p\" : quality == 2 ? \"720p\" : \"1080p\"\n                                                ]\n                                            }, void 0, true, {\n                                                fileName: \"/home/isolated/rakazone/rakazone-frontend/src/components/VideoPlayer/Mobile.js\",\n                                                lineNumber: 353,\n                                                columnNumber: 33\n                                            }, this)\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"/home/isolated/rakazone/rakazone-frontend/src/components/VideoPlayer/Mobile.js\",\n                                        lineNumber: 351,\n                                        columnNumber: 29\n                                    }, this)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/home/isolated/rakazone/rakazone-frontend/src/components/VideoPlayer/Mobile.js\",\n                                lineNumber: 347,\n                                columnNumber: 25\n                            }, this),\n                            settingsShowQuality && levels.map(function(level, index) {\n                                return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: (_VideoPlayerMobile_module_css__WEBPACK_IMPORTED_MODULE_8___default().settings_popup_body_item),\n                                    onClick: function() {\n                                        return handleQualitySelect(index);\n                                    },\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                            className: \"\".concat((_VideoPlayerMobile_module_css__WEBPACK_IMPORTED_MODULE_8___default().settings_popup_body_item_icon), \" material-icons-round\")\n                                        }, void 0, false, {\n                                            fileName: \"/home/isolated/rakazone/rakazone-frontend/src/components/VideoPlayer/Mobile.js\",\n                                            lineNumber: 361,\n                                            columnNumber: 37\n                                        }, _this),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"a\", {\n                                            className: (_VideoPlayerMobile_module_css__WEBPACK_IMPORTED_MODULE_8___default().settings_popup_body_item_text),\n                                            children: [\n                                                level.height,\n                                                \"p\"\n                                            ]\n                                        }, void 0, true, {\n                                            fileName: \"/home/isolated/rakazone/rakazone-frontend/src/components/VideoPlayer/Mobile.js\",\n                                            lineNumber: 362,\n                                            columnNumber: 37\n                                        }, _this)\n                                    ]\n                                }, index, true, {\n                                    fileName: \"/home/isolated/rakazone/rakazone-frontend/src/components/VideoPlayer/Mobile.js\",\n                                    lineNumber: 360,\n                                    columnNumber: 33\n                                }, _this);\n                            }),\n                            !settingsShowQuality && !settingsShowSpeed && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: (_VideoPlayerMobile_module_css__WEBPACK_IMPORTED_MODULE_8___default().settings_popup_body_item),\n                                onClick: function() {\n                                    return setSettingsShowSpeed(true);\n                                },\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        className: \"\".concat((_VideoPlayerMobile_module_css__WEBPACK_IMPORTED_MODULE_8___default().settings_popup_body_item_icon), \" material-icons-round\"),\n                                        onClick: function() {\n                                            return handlePlayPause();\n                                        },\n                                        children: \"slow_motion_video\"\n                                    }, void 0, false, {\n                                        fileName: \"/home/isolated/rakazone/rakazone-frontend/src/components/VideoPlayer/Mobile.js\",\n                                        lineNumber: 368,\n                                        columnNumber: 29\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"a\", {\n                                        className: (_VideoPlayerMobile_module_css__WEBPACK_IMPORTED_MODULE_8___default().settings_popup_body_item_text),\n                                        children: \"Playback Speed\"\n                                    }, void 0, false, {\n                                        fileName: \"/home/isolated/rakazone/rakazone-frontend/src/components/VideoPlayer/Mobile.js\",\n                                        lineNumber: 371,\n                                        columnNumber: 29\n                                    }, this)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/home/isolated/rakazone/rakazone-frontend/src/components/VideoPlayer/Mobile.js\",\n                                lineNumber: 367,\n                                columnNumber: 25\n                            }, this),\n                            settingsShowSpeed && playbackSpeedsList.map(function(speed, index) {\n                                return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: (_VideoPlayerMobile_module_css__WEBPACK_IMPORTED_MODULE_8___default().settings_popup_body_item),\n                                    onClick: function() {\n                                        return handleSpeedSelect(speed);\n                                    },\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                            className: \"\".concat((_VideoPlayerMobile_module_css__WEBPACK_IMPORTED_MODULE_8___default().settings_popup_body_item_icon), \" material-icons-round\")\n                                        }, void 0, false, {\n                                            fileName: \"/home/isolated/rakazone/rakazone-frontend/src/components/VideoPlayer/Mobile.js\",\n                                            lineNumber: 378,\n                                            columnNumber: 37\n                                        }, _this),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"a\", {\n                                            className: (_VideoPlayerMobile_module_css__WEBPACK_IMPORTED_MODULE_8___default().settings_popup_body_item_text),\n                                            children: [\n                                                speed,\n                                                \"x\"\n                                            ]\n                                        }, void 0, true, {\n                                            fileName: \"/home/isolated/rakazone/rakazone-frontend/src/components/VideoPlayer/Mobile.js\",\n                                            lineNumber: 379,\n                                            columnNumber: 37\n                                        }, _this)\n                                    ]\n                                }, index, true, {\n                                    fileName: \"/home/isolated/rakazone/rakazone-frontend/src/components/VideoPlayer/Mobile.js\",\n                                    lineNumber: 377,\n                                    columnNumber: 33\n                                }, _this);\n                            })\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/home/isolated/rakazone/rakazone-frontend/src/components/VideoPlayer/Mobile.js\",\n                        lineNumber: 345,\n                        columnNumber: 17\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/home/isolated/rakazone/rakazone-frontend/src/components/VideoPlayer/Mobile.js\",\n                lineNumber: 341,\n                columnNumber: 13\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"video\", {\n                autoPlay: true,\n                onClick: function() {\n                    return handlePlayPause();\n                },\n                ref: videoController,\n                className: (_VideoPlayerMobile_module_css__WEBPACK_IMPORTED_MODULE_8___default().video)\n            }, void 0, false, {\n                fileName: \"/home/isolated/rakazone/rakazone-frontend/src/components/VideoPlayer/Mobile.js\",\n                lineNumber: 385,\n                columnNumber: 13\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/home/isolated/rakazone/rakazone-frontend/src/components/VideoPlayer/Mobile.js\",\n        lineNumber: 284,\n        columnNumber: 9\n    }, this);\n}\n_s(VideoPlayerMobile, \"rB6sDboT2jFvmpLrvDjm1auuyq4=\");\n_c = VideoPlayerMobile;\nvar _c;\n$RefreshReg$(_c, \"VideoPlayerMobile\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29tcG9uZW50cy9WaWRlb1BsYXllci9Nb2JpbGUuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQW1EO0FBQ007QUFDSTtBQUM1QjtBQUN1QjtBQUNBO0FBQ2hCO0FBQ2hCOztBQUVqQixTQUFTVSxpQkFBaUIsQ0FBQ0MsS0FBSyxFQUFFOzs7SUFDckMsSUFBSUMsSUFBRyxHQUFHLHlDQUF3QyxDQUFnQixNQUFrQixDQUFoQ0QsS0FBSyxDQUFDRSxPQUFPLEVBQUMsb0JBQWtCLENBQUM7SUFDckYsSUFBTUMsS0FBSyxHQUFHSCxLQUFLLENBQUNHLEtBQUs7SUFDekIsSUFBTUMsa0JBQWtCLEdBQUc7QUFBQyxXQUFHO0FBQUUsWUFBSTtBQUFFLFNBQUM7QUFBRSxZQUFJO0FBQUUsV0FBRztBQUFFLFlBQUk7QUFBRSxTQUFDO0tBQUM7SUFFN0QsSUFBTUMsV0FBVyxHQUFHaEIsNkNBQU0sQ0FBQyxJQUFJLENBQUM7SUFDaEMsSUFBTWlCLGVBQWUsR0FBR2pCLDZDQUFNLENBQUMsSUFBSSxDQUFDO0lBQ3BDLElBQU1rQixrQkFBa0IsR0FBR2xCLDZDQUFNLENBQUMsSUFBSSxDQUFDO0lBQ3ZDLElBQWtDQyxLQUFlLEdBQWZBLCtDQUFRLENBQUMsS0FBSyxDQUFDLEVBakJyRCxTQWlCb0IsR0FBa0JBLEtBQWUsR0FBakMsRUFqQnBCLFlBaUJrQyxHQUFJQSxLQUFlLEdBQW5CO0lBQzlCLElBQW9DQSxJQUFlLEdBQWZBLCtDQUFRLENBQUMsS0FBSyxDQUFDLEVBbEJ2RCxVQWtCcUIsR0FBbUJBLElBQWUsR0FBbEMsRUFsQnJCLGFBa0JvQyxHQUFJQSxJQUFlLEdBQW5CO0lBQ2hDLElBQTBDQSxJQUFlLEdBQWZBLCtDQUFRLENBQUMsS0FBSyxDQUFDLEVBbkI3RCxhQW1Cd0IsR0FBc0JBLElBQWUsR0FBckMsRUFuQnhCLGdCQW1CMEMsR0FBSUEsSUFBZSxHQUFuQjtJQUN0QyxX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QUFrQjs7Ozs7b0JBQUk7Ozs7OztZQUN2RyxDQUNUO0NBQ0o7R0ExWGVPLGlCQUFpQjtBQUFqQkEsS0FBQUEsaUJBQWlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9jb21wb25lbnRzL1ZpZGVvUGxheWVyL01vYmlsZS5qcz83NzAyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZVJlZiwgdXNlU3RhdGUsIHVzZUVmZmVjdCB9IGZyb20gXCJyZWFjdFwiXG5pbXBvcnQgbW9iaWxlX3N0eWxlIGZyb20gXCIuL1ZpZGVvUGxheWVyTW9iaWxlLm1vZHVsZS5jc3NcIlxuaW1wb3J0IHsgdG9hc3RTZXJ2aWNlIH0gZnJvbSBcIi4uLy4uL2hhbmRsZXIvdG9hc3QuaGFuZGxlci5qc1wiXG5pbXBvcnQgSW1hZ2UgZnJvbSBcIm5leHQvaW1hZ2UuanNcIlxuaW1wb3J0IHRlc3RJbWFnZSBmcm9tIFwiLi4vLi4vYXNzZXRzL2ltZy9wbmcvaW5zdGEwNy5wbmdcIlxuaW1wb3J0IHsgZm9ybWF0RHVyYXRpb24gfSBmcm9tIFwiLi4vLi4vdXRpbC9mdW5jdGlvbnMuanNcIlxuaW1wb3J0IExvYWRpbmcgZnJvbSBcImNvbXBvbmVudHMvTG9hZGluZ1wiXG5pbXBvcnQgSGxzIGZyb20gXCJobHMuanNcIlxuXG5leHBvcnQgZnVuY3Rpb24gVmlkZW9QbGF5ZXJNb2JpbGUocHJvcHMpIHtcbiAgICBsZXQgc3JjID0gYGh0dHBzOi8va2V2aXYueHl6L2FwaS9kb3dubG9hZHMvb3V0cHV0LyR7cHJvcHMudmlkZW9JZH0vSExTL3BsYXlsaXN0Lm0zdThgXG4gICAgY29uc3QgYWRTcmMgPSBwcm9wcy5hZFNyY1xuICAgIGNvbnN0IHBsYXliYWNrU3BlZWRzTGlzdCA9IFswLjUsIDAuNzUsIDEsIDEuMjUsIDEuNSwgMS43NSwgMl1cblxuICAgIGNvbnN0IHZpZGVvUGxheWVyID0gdXNlUmVmKG51bGwpXG4gICAgY29uc3QgdmlkZW9Db250cm9sbGVyID0gdXNlUmVmKG51bGwpXG4gICAgY29uc3QgdGltZWxpbmVDb250cm9sbGVyID0gdXNlUmVmKG51bGwpXG4gICAgY29uc3QgW2lzUGxheWluZywgc2V0SXNQbGF5aW5nXSA9IHVzZVN0YXRlKGZhbHNlKVxuICAgIGNvbnN0IFtmdWxsc2NyZWVuLCBzZXRGdWxsc2NyZWVuXSA9IHVzZVN0YXRlKGZhbHNlKVxuICAgIGNvbnN0IFtzaG93RW5kU2NyZWVuLCBzZXRTaG93RW5kU2NyZWVuXSA9IHVzZVN0YXRlKGZhbHNlKVxuICAgIC8vIHNldHRpbmdzXG4gICAgY29uc3QgW3Nob3dTZXR0aW5ncywgc2V0U2hvd1NldHRpbmdzXSA9IHVzZVN0YXRlKGZhbHNlKVxuICAgIGNvbnN0IFtzZXR0aW5nc1Nob3dRdWFsaXR5LCBzZXRTZXR0aW5nc1Nob3dRdWFsaXR5XSA9IHVzZVN0YXRlKGZhbHNlKVxuICAgIGNvbnN0IFtzZXR0aW5nc1Nob3dTcGVlZCwgc2V0U2V0dGluZ3NTaG93U3BlZWRdID0gdXNlU3RhdGUoZmFsc2UpXG4gICAgY29uc3QgW211dGVkLCBzZXRNdXRlZF0gPSB1c2VTdGF0ZSh0cnVlKVxuXG4gICAgY29uc3QgW3Nob3dDb250cm9scywgc2V0U2hvd0NvbnRyb2xzXSA9IHVzZVN0YXRlKHRydWUpXG4gICAgY29uc3QgW3BsYXlpbmdBZCwgc2V0UGxheWluZ0FkXSA9IHVzZVN0YXRlKGZhbHNlKVxuICAgIGNvbnN0IFtsb2FkaW5nLCBzZXRMb2FkaW5nXSA9IHVzZVN0YXRlKHRydWUpXG4gICAgY29uc3QgW2R1cmF0aW9uLCBzZXREdXJhdGlvbl0gPSB1c2VTdGF0ZSh7IGN1cnJlbnREdXJhdGlvbjogMCwgdG90YWxEdXJhdGlvbjogMCwgcGVyY2VudGFnZTogMCB9KVxuICAgIGNvbnN0IFtxdWFsaXR5LCBzZXRRdWFsaXR5XSA9IHVzZVN0YXRlKFwiYXV0b1wiKVxuICAgIGNvbnN0IFtsZXZlbHMsIHNldExldmVsc10gPSB1c2VTdGF0ZShbXSlcblxuICAgIC8vIHNvbWUgZnVuY3Rpb25zXG4gICAgY29uc3QgX2Nsb3NlU2V0dGluZ3MgPSAoKSA9PiB7XG4gICAgICAgIHNldFNob3dTZXR0aW5ncyhmYWxzZSlcbiAgICAgICAgc2V0U2V0dGluZ3NTaG93UXVhbGl0eShmYWxzZSlcbiAgICAgICAgc2V0U2V0dGluZ3NTaG93U3BlZWQoZmFsc2UpXG4gICAgfVxuICAgIGNvbnN0IGhhbmRsZVNldHRpbmdzID0gKCkgPT4ge1xuICAgICAgICBpZiAoc2hvd1NldHRpbmdzKSB7XG4gICAgICAgICAgICBzZXRTZXR0aW5nc1Nob3dRdWFsaXR5KGZhbHNlKVxuICAgICAgICAgICAgc2V0U2V0dGluZ3NTaG93U3BlZWQoZmFsc2UpXG4gICAgICAgICAgICBzZXRTaG93U2V0dGluZ3MoZmFsc2UpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZXRTaG93U2V0dGluZ3ModHJ1ZSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGhhbmRsZVF1YWxpdHlTZWxlY3QgPSAocSkgPT4ge1xuICAgICAgICBoYW5kbGVTZXR0aW5ncygpXG4gICAgICAgIHNldFF1YWxpdHkocSlcbiAgICB9XG4gICAgY29uc3QgaGFuZGxlU3BlZWRTZWxlY3QgPSAocykgPT4ge1xuICAgICAgICBoYW5kbGVTZXR0aW5ncygpXG4gICAgICAgIHZpZGVvQ29udHJvbGxlci5jdXJyZW50LnBsYXliYWNrUmF0ZSA9IHNcbiAgICB9XG4gICAgY29uc3QgY2FsY3VsYXRlU2xpZGVyID0gKGNsaWNrLCBlbG0pID0+IHtcbiAgICAgICAgY29uc3Qgdm9sdW1lX3dpZHRoID0gZWxtLm9mZnNldFdpZHRoXG4gICAgICAgIGNvbnN0IGNsaWNrX3ggPSBjbGljay5jbGllbnRYIC0gZWxtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnRcbiAgICAgICAgY29uc3Qgdm9sdW1lID0gKChjbGlja194IC8gdm9sdW1lX3dpZHRoKSAqIDEwMCkudG9GaXhlZCgwKVxuICAgICAgICByZXR1cm4gdm9sdW1lXG4gICAgfVxuXG4gICAgY29uc3QgaGFuZGxlRnVsbFNjcmVlbiA9ICgpID0+IHtcbiAgICAgICAgaWYgKGRvY3VtZW50LmZ1bGxzY3JlZW5FbGVtZW50ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHNldEZ1bGxzY3JlZW4oZmFsc2UpXG4gICAgICAgICAgICByZXR1cm4gZG9jdW1lbnQuZXhpdEZ1bGxzY3JlZW4oKVxuICAgICAgICB9XG4gICAgICAgIGlmICh2aWRlb1BsYXllci5jdXJyZW50LnJlcXVlc3RGdWxsc2NyZWVuKSB7XG4gICAgICAgICAgICB2aWRlb1BsYXllci5jdXJyZW50LnJlcXVlc3RGdWxsc2NyZWVuKClcbiAgICAgICAgfSBlbHNlIGlmICh2aWRlb1BsYXllci5jdXJyZW50LndlYmtpdFJlcXVlc3RGdWxsc2NyZWVuKSB7XG4gICAgICAgICAgICB2aWRlb1BsYXllci5jdXJyZW50LndlYmtpdFJlcXVlc3RGdWxsc2NyZWVuKClcbiAgICAgICAgfSBlbHNlIGlmICh2aWRlb1BsYXllci5jdXJyZW50Lm1velJlcXVlc3RGdWxsU2NyZWVuKSB7XG4gICAgICAgICAgICB2aWRlb1BsYXllci5jdXJyZW50Lm1velJlcXVlc3RGdWxsU2NyZWVuKClcbiAgICAgICAgfSBlbHNlIGlmICh2aWRlb1BsYXllci5jdXJyZW50Lm1zUmVxdWVzdEZ1bGxzY3JlZW4pIHtcbiAgICAgICAgICAgIHZpZGVvUGxheWVyLmN1cnJlbnQubXNSZXF1ZXN0RnVsbHNjcmVlbigpXG4gICAgICAgIH1cbiAgICAgICAgc2V0RnVsbHNjcmVlbih0cnVlKVxuICAgIH1cblxuICAgIGNvbnN0IGhhbmRsZVBsYXlQYXVzZSA9ICgpID0+IHtcbiAgICAgICAgaWYgKCFzaG93Q29udHJvbHMpIHJldHVyblxuICAgICAgICBpZiAoc2hvd1NldHRpbmdzKSByZXR1cm4gc2V0U2hvd1NldHRpbmdzKGZhbHNlKVxuXG4gICAgICAgIGlmICh2aWRlb0NvbnRyb2xsZXIuY3VycmVudC5wYXVzZWQpIHtcbiAgICAgICAgICAgIHNldElzUGxheWluZyh0cnVlKVxuICAgICAgICAgICAgdmlkZW9Db250cm9sbGVyLmN1cnJlbnQucGxheSgpXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICBzZXRTaG93Q29udHJvbHMoZmFsc2UpXG4gICAgICAgICAgICB9LCAxMDAwKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2V0SXNQbGF5aW5nKGZhbHNlKVxuICAgICAgICAgICAgdmlkZW9Db250cm9sbGVyLmN1cnJlbnQucGF1c2UoKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgaGFuZGxlVW5tdXRlID0gKCkgPT4ge1xuICAgICAgICBzZXRNdXRlZChmYWxzZSlcbiAgICAgICAgdmlkZW9Db250cm9sbGVyLmN1cnJlbnQubXV0ZWQgPSBmYWxzZVxuICAgIH1cblxuXG4gICAgY29uc3QgaGFuZGxlVGltZWxpbmUgPSAoKSA9PiB7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgaGFuZGxlVGltZWxpbmVTbGlkZXIpXG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIGhhbmRsZVRpbWVsaW5lKVxuICAgIH1cblxuICAgIGNvbnN0IGhhbmRsZVRpbWVsaW5lU2xpZGVyID0gKGUpID0+IHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICAgIGNvbnN0IHNsaWRlciA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUobW9iaWxlX3N0eWxlLnRpbWVsaW5lX3NsaWRlcilbMF1cbiAgICAgICAgbGV0IHBlcmNlbnQgPSBjYWxjdWxhdGVTbGlkZXIoZSwgc2xpZGVyKVxuICAgICAgICBpZiAocGVyY2VudCA8IDApIHtcbiAgICAgICAgICAgIHBlcmNlbnQgPSAwXG4gICAgICAgIH0gZWxzZSBpZiAocGVyY2VudCA+IDEwMCkge1xuICAgICAgICAgICAgcGVyY2VudCA9IDEwMFxuICAgICAgICB9XG4gICAgICAgIHZpZGVvQ29udHJvbGxlci5jdXJyZW50LmN1cnJlbnRUaW1lID0gKHBlcmNlbnQgLyAxMDApICogdmlkZW9Db250cm9sbGVyLmN1cnJlbnQuZHVyYXRpb25cbiAgICAgICAgc2V0RHVyYXRpb24oeyBjdXJyZW50RHVyYXRpb246IGZvcm1hdER1cmF0aW9uKHZpZGVvQ29udHJvbGxlci5jdXJyZW50LmN1cnJlbnRUaW1lKSwgdG90YWxEdXJhdGlvbjogZm9ybWF0RHVyYXRpb24odmlkZW9Db250cm9sbGVyLmN1cnJlbnQuZHVyYXRpb24pLCBwZXJjZW50YWdlOiBwZXJjZW50IH0pXG4gICAgfVxuXG4gICAgY29uc3Qgb25QcmVzc0ZvcndhcmRPckJhY2t3YXJkID0gKG51bWJlcikgPT4ge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHNldFNob3dDb250cm9scyhmYWxzZSlcbiAgICAgICAgfSwgMTAwMClcbiAgICAgICAgdmlkZW9Db250cm9sbGVyLmN1cnJlbnQuY3VycmVudFRpbWUgPSB2aWRlb0NvbnRyb2xsZXIuY3VycmVudC5jdXJyZW50VGltZSArIG51bWJlclxuICAgIH1cblxuICAgIGNvbnN0IF9oYW5kbGVDbGljayA9IChldmVudCkgPT4ge1xuICAgICAgICBpZiAoIXNob3dDb250cm9scyAmJiAhZXZlbnQpIHJldHVybiBzZXRTaG93Q29udHJvbHModHJ1ZSlcbiAgICAgICAgaWYgKGV2ZW50ID09PSBcInNldHRpbmdzXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBzZXRTaG93U2V0dGluZ3ModHJ1ZSlcbiAgICAgICAgfSBlbHNlIGlmIChldmVudCA9PT0gXCJmb3J3YXJkXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBvblByZXNzRm9yd2FyZE9yQmFja3dhcmQoMTApXG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnQgPT09IFwiYmFja3dhcmRcIikge1xuICAgICAgICAgICAgcmV0dXJuIG9uUHJlc3NGb3J3YXJkT3JCYWNrd2FyZCgtMTApXG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnQgPT09IFwiUGxheVBhdXNlXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVQbGF5UGF1c2UoKVxuICAgICAgICB9IGVsc2UgaWYgKGV2ZW50ID09PSBcImZ1bGxzY3JlZW5cIikge1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZUZ1bGxTY3JlZW4oKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHNob3dDb250cm9scykgcmV0dXJuIHNldFNob3dDb250cm9scyhmYWxzZSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIC8vIEV2ZW50IExpc3RlbmVyc1xuICAgICAgICB2aWRlb0NvbnRyb2xsZXIuY3VycmVudC5hZGRFdmVudExpc3RlbmVyKFwidGltZXVwZGF0ZVwiLCAoKSA9PiB7XG4gICAgICAgICAgICBpZiAocGxheWluZ0FkKSByZXR1cm5cbiAgICAgICAgICAgIHNldExvYWRpbmcoZmFsc2UpXG4gICAgICAgICAgICBzZXREdXJhdGlvbih7XG4gICAgICAgICAgICAgICAgY3VycmVudER1cmF0aW9uOiBmb3JtYXREdXJhdGlvbih2aWRlb0NvbnRyb2xsZXIuY3VycmVudC5jdXJyZW50VGltZSksXG4gICAgICAgICAgICAgICAgdG90YWxEdXJhdGlvbjogZm9ybWF0RHVyYXRpb24odmlkZW9Db250cm9sbGVyLmN1cnJlbnQuZHVyYXRpb24pLFxuICAgICAgICAgICAgICAgIHBlcmNlbnRhZ2U6ICh2aWRlb0NvbnRyb2xsZXIuY3VycmVudC5jdXJyZW50VGltZSAvIHZpZGVvQ29udHJvbGxlci5jdXJyZW50LmR1cmF0aW9uKSAqIDEwMCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgICAgIHZpZGVvQ29udHJvbGxlci5jdXJyZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkZWRkYXRhXCIsICgpID0+IHtcbiAgICAgICAgICAgIC8vIHZpZGVvQ29udHJvbGxlci5jdXJyZW50LnZvbHVtZSA9IDUwIC8gMTAwXG4gICAgICAgICAgICBzZXRMb2FkaW5nKGZhbHNlKVxuICAgICAgICAgICAgc2V0RHVyYXRpb24oe1xuICAgICAgICAgICAgICAgIGN1cnJlbnREdXJhdGlvbjogZm9ybWF0RHVyYXRpb24odmlkZW9Db250cm9sbGVyLmN1cnJlbnQuY3VycmVudFRpbWUpLFxuICAgICAgICAgICAgICAgIHRvdGFsRHVyYXRpb246IGZvcm1hdER1cmF0aW9uKHZpZGVvQ29udHJvbGxlci5jdXJyZW50LmR1cmF0aW9uKSxcbiAgICAgICAgICAgICAgICBwZXJjZW50YWdlOiAodmlkZW9Db250cm9sbGVyLmN1cnJlbnQuY3VycmVudFRpbWUgLyB2aWRlb0NvbnRyb2xsZXIuY3VycmVudC5kdXJhdGlvbikgKiAxMDAsXG4gICAgICAgICAgICB9KVxuICAgICAgICB9KVxuXG4gICAgICAgIHRpbWVsaW5lQ29udHJvbGxlci5jdXJyZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgKGUpID0+IHtcbiAgICAgICAgICAgIGlmIChwbGF5aW5nQWQpIHJldHVyblxuICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCBoYW5kbGVUaW1lbGluZVNsaWRlcilcbiAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIChlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZVRpbWVsaW5lKClcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0pXG5cbiAgICAgICAgdGltZWxpbmVDb250cm9sbGVyLmN1cnJlbnQuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIChlKSA9PiB7XG4gICAgICAgICAgICBpZiAocGxheWluZ0FkKSByZXR1cm5cbiAgICAgICAgICAgIGhhbmRsZVRpbWVsaW5lU2xpZGVyKGUpXG4gICAgICAgIH0pXG5cbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgfVxuXG4gICAgfSwgW3BsYXlpbmdBZF0pXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICBjb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHN0YXJ0TGV2ZWw6IC0xLFxuICAgICAgICAgICAgbGljZW5zZVhoclNldHVwOiBmdW5jdGlvbiAoeGhyLCB1cmwpIHtcbiAgICAgICAgICAgICAgICB4aHIud2l0aENyZWRlbnRpYWxzID0gdHJ1ZSAvLyBkbyBzZW5kIGNvb2tpZXNcbiAgICAgICAgICAgICAgICBpZiAoIXhoci5yZWFkeVN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENhbGwgb3BlbiB0byBjaGFuZ2UgdGhlIG1ldGhvZCAoZGVmYXVsdCBpcyBQT1NUKSBvciBtb2RpZnkgdGhlIHVybFxuICAgICAgICAgICAgICAgICAgICB4aHIub3BlbihcIkdFVFwiLCB1cmwsIHRydWUpXG4gICAgICAgICAgICAgICAgICAgIC8vIEFwcGVuZCBoZWFkZXJzIGFmdGVyIG9wZW5pbmdcbiAgICAgICAgICAgICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoXCJDb250ZW50LVR5cGVcIiwgXCJhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW1cIilcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmVidWlsZCA9ICh2aWRlbywgc3JjKSA9PiB7XG4gICAgICAgICAgICBzZXRMb2FkaW5nKHRydWUpXG4gICAgICAgICAgICBjb25zdCBobHMgPSBuZXcgSGxzKGRlZmF1bHRPcHRpb25zKVxuICAgICAgICAgICAgaGxzLmxvYWRTb3VyY2Uoc3JjKVxuICAgICAgICAgICAgaGxzLmF0dGFjaE1lZGlhKHZpZGVvKVxuICAgICAgICAgICAgcmV0dXJuIGhsc1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGhscyA9IG5ldyBIbHMoZGVmYXVsdE9wdGlvbnMpXG4gICAgICAgIGNvbnN0IHZpZGVvID0gdmlkZW9Db250cm9sbGVyLmN1cnJlbnRcbiAgICAgICAgdmlkZW8ucmVtb3ZlQXR0cmlidXRlKFwiY29udHJvbHNcIilcbiAgICAgICAgdmlkZW8uYXV0b1BsYXkgPSB0cnVlXG4gICAgICAgIHZpZGVvLm11dGVkID0gdHJ1ZVxuICAgICAgICBzZXRMb2FkaW5nKHRydWUpXG4gICAgICAgIGlmICghdmlkZW8pIHJldHVyblxuICAgICAgICBpZiAodmlkZW8uY2FuUGxheVR5cGUoXCJhcHBsaWNhdGlvbi92bmQuYXBwbGUubXBlZ3VybFwiKSAmJiBwcm9wcy5pc0lPUykge1xuICAgICAgICAgICAgdmlkZW8ucmVtb3ZlQXR0cmlidXRlKFwiY29udHJvbHNcIilcbiAgICAgICAgICAgIHZpZGVvLnNldEF0dHJpYnV0ZShcIndlYmtpdC1wbGF5c2lubGluZVwiLCBcIlwiKVxuICAgICAgICAgICAgdmlkZW8uc2V0QXR0cmlidXRlKFwicGxheXNpbmxpbmVcIiwgXCJcIilcbiAgICAgICAgICAgIHZpZGVvLnNldEF0dHJpYnV0ZShcIngtd2Via2l0LWFpcnBsYXlcIiwgXCJhbGxvd1wiKVxuICAgICAgICAgICAgdmlkZW8uc2V0QXR0cmlidXRlKFwieDUtdmlkZW8tcGxheWVyLXR5cGVcIiwgXCJoNVwiKVxuICAgICAgICAgICAgdmlkZW8uc2V0QXR0cmlidXRlKFwieDUtdmlkZW8tcGxheWVyLWZ1bGxzY3JlZW5cIiwgXCJmYWxzZVwiKVxuICAgICAgICAgICAgdmlkZW8uc2V0QXR0cmlidXRlKFwieDUtdmlkZW8tb3JpZW50YXRpb25cIiwgXCJwb3J0cmFpbnRcIilcblxuICAgICAgICAgICAgaWYgKGFkU3JjKSB7XG4gICAgICAgICAgICAgICAgc2V0UGxheWluZ0FkKHRydWUpXG4gICAgICAgICAgICAgICAgdmlkZW8uc3JjID0gYWRTcmNcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmlkZW8uc3JjID0gc3JjXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoSGxzLmlzU3VwcG9ydGVkKCkpIHtcblxuICAgICAgICAgICAgLy8gVGhpcyB3aWxsIHJ1biBpbiBhbGwgb3RoZXIgbW9kZXJuIGJyb3dzZXJzXG4gICAgICAgICAgICBpZiAoYWRTcmMpIHtcbiAgICAgICAgICAgICAgICBzZXRQbGF5aW5nQWQodHJ1ZSlcbiAgICAgICAgICAgICAgICBobHMubG9hZFNvdXJjZShhZFNyYylcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaGxzLmxvYWRTb3VyY2Uoc3JjKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaGxzLmF0dGFjaE1lZGlhKHZpZGVvKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIlRoaXMgaXMgYW4gb2xkIGJyb3dzZXIgdGhhdCBkb2VzIG5vdCBzdXBwb3J0IE1TRSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTWVkaWFfU291cmNlX0V4dGVuc2lvbnNfQVBJXCIpXG4gICAgICAgIH1cblxuICAgICAgICB2aWRlby5hZGRFdmVudExpc3RlbmVyKFwiZW5kZWRcIiwgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHZpZGVvLnNyYyA9PT0gYWRTcmMgfHwgaGxzPy5sZXZlbHNbMF0/LnVybFswXT8uaW5jbHVkZXMoXCJBZFwiKSkge1xuICAgICAgICAgICAgICAgIHNldFBsYXlpbmdBZChmYWxzZSlcbiAgICAgICAgICAgICAgICBpZiAodmlkZW8uY2FuUGxheVR5cGUoXCJhcHBsaWNhdGlvbi92bmQuYXBwbGUubXBlZ3VybFwiKSAmJiBwcm9wcy5pc0lPUykge1xuICAgICAgICAgICAgICAgICAgICB2aWRlby5zcmMgPSBzcmNcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBobHMuZGVzdHJveSgpXG4gICAgICAgICAgICAgICAgICAgIGhscyA9IHJlYnVpbGQodmlkZW8sIHNyYylcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSlcblxuICAgICAgICBobHMub25jZShIbHMuRXZlbnRzLkxFVkVMX0xPQURFRCwgKGV2ZW50LCBkYXRhKSA9PiB7XG4gICAgICAgICAgICBzZXRMb2FkaW5nKGZhbHNlKVxuICAgICAgICAgICAgdmFyIGxldmVsX2R1cmF0aW9uID0gZGF0YS5kZXRhaWxzLnRvdGFsZHVyYXRpb25cbiAgICAgICAgICAgIHNldER1cmF0aW9uKHsgLi4uZHVyYXRpb24sIHRvdGFsRHVyYXRpb246IGZvcm1hdER1cmF0aW9uKGxldmVsX2R1cmF0aW9uKSwgY3VycmVudER1cmF0aW9uOiBmb3JtYXREdXJhdGlvbih2aWRlby5jdXJyZW50VGltZSkgfSlcbiAgICAgICAgfSlcbiAgICAgICAgaGxzLm9uY2UoSGxzLkV2ZW50cy5NQU5JRkVTVF9QQVJTRUQsIGZ1bmN0aW9uIChldmVudCwgZGF0YSkge1xuICAgICAgICAgICAgc2V0TG9hZGluZyhmYWxzZSlcbiAgICAgICAgICAgIHNldExldmVscyhkYXRhLmxldmVscylcbiAgICAgICAgICAgIGhscy5jdXJyZW50TGV2ZWwgPSBxdWFsaXR5ID09PSBcImF1dG9cIiA/IC0xIDogcXVhbGl0eVxuICAgICAgICB9KVxuXG4gICAgICAgIHZpZGVvLmFkZEV2ZW50TGlzdGVuZXIoXCJ3YWl0aW5nXCIsICgpID0+IHtcbiAgICAgICAgICAgIHNldElzUGxheWluZyhmYWxzZSlcbiAgICAgICAgICAgIHNldExvYWRpbmcodHJ1ZSlcbiAgICAgICAgfSlcbiAgICAgICAgdmlkZW8uYWRkRXZlbnRMaXN0ZW5lcihcInBsYXlpbmdcIiwgKCkgPT4ge1xuICAgICAgICAgICAgc2V0SXNQbGF5aW5nKHRydWUpXG4gICAgICAgICAgICBzZXRMb2FkaW5nKGZhbHNlKVxuICAgICAgICB9XG4gICAgICAgIClcblxuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgaGxzLmRlc3Ryb3koKVxuICAgICAgICB9XG4gICAgfSwgW3F1YWxpdHldKVxuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9e21vYmlsZV9zdHlsZS52aWRlb193cmFwcGVyfSByZWY9e3ZpZGVvUGxheWVyfSBvbkNsaWNrPXsoKSA9PiBfaGFuZGxlQ2xpY2soKX0+XG4gICAgICAgICAgICB7cGxheWluZ0FkICYmIChcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17bW9iaWxlX3N0eWxlLnBsYXlpbmdfYWRfd3JhcHBlcn0+XG4gICAgICAgICAgICAgICAgICAgIEFkXG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICApfVxuICAgICAgICAgICAge211dGVkICYmIChcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17bW9iaWxlX3N0eWxlLnVubXV0ZV9idXR0b259IG9uQ2xpY2s9eygpID0+IGhhbmRsZVVubXV0ZSgpfT5Vbm11dGU8L2Rpdj5cbiAgICAgICAgICAgICl9XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17YCR7bW9iaWxlX3N0eWxlLmNvbnRyb2xzfSAke3BsYXlpbmdBZCAmJiBtb2JpbGVfc3R5bGUuaGlkZV9jb250cm9sc30gICR7c2hvd0NvbnRyb2xzICYmIG1vYmlsZV9zdHlsZS5zaG93X2NvbnRyb2xzfWB9PlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXttb2JpbGVfc3R5bGUudG9wX2NvbnRyb2xzfT5cbiAgICAgICAgICAgICAgICAgICAgPGRpdiBvbkNsaWNrPXsoKSA9PiBfaGFuZGxlQ2xpY2soXCJzZXR0aW5nc1wiKX0gY2xhc3NOYW1lPXtgJHttb2JpbGVfc3R5bGUuc2V0dGluZ3N9IG1hdGVyaWFsLWljb25zLXJvdW5kYH0+XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5nc1xuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17bW9iaWxlX3N0eWxlLm1pZGRsZV9jb250cm9sc30+XG4gICAgICAgICAgICAgICAgICAgIHtsb2FkaW5nID8gKFxuICAgICAgICAgICAgICAgICAgICAgICAgPExvYWRpbmcgdz17XCI0MHB4XCJ9IGg9e1wiNDBweFwifSAvPlxuICAgICAgICAgICAgICAgICAgICApIDogKFxuICAgICAgICAgICAgICAgICAgICAgICAgPD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17YCR7bW9iaWxlX3N0eWxlLnNraXBfcHJldmlvdXNfYnRufSBtYXRlcmlhbC1pY29ucy1yb3VuZGB9IG9uQ2xpY2s9eygpID0+IF9oYW5kbGVDbGljayhcImJhY2t3YXJkXCIpfT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVwbGF5XzEwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Ake21vYmlsZV9zdHlsZS5wbGF5X3BhdXNlX2J0bn0gbWF0ZXJpYWwtaWNvbnMtcm91bmRgfSBvbkNsaWNrPXsoKSA9PiBfaGFuZGxlQ2xpY2soXCJQbGF5UGF1c2VcIil9PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7aXNQbGF5aW5nID8gXCJwYXVzZVwiIDogXCJwbGF5X2Fycm93XCJ9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Ake21vYmlsZV9zdHlsZS5za2lwX25leHRfYnRufSBtYXRlcmlhbC1pY29ucy1yb3VuZGB9IG9uQ2xpY2s9eygpID0+IF9oYW5kbGVDbGljayhcImZvcndhcmRcIil9PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3J3YXJkXzEwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICA8Lz5cbiAgICAgICAgICAgICAgICAgICAgKX1cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17bW9iaWxlX3N0eWxlLmJvdHRvbV9jb250cm9sc30+XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXttb2JpbGVfc3R5bGUuZHVyYXRpb25fd3JhcHBlcn0+XG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17bW9iaWxlX3N0eWxlLmR1cmF0aW9ufT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17bW9iaWxlX3N0eWxlLmR1cmF0aW9uX2N1cnJlbnR9PntkdXJhdGlvbi5jdXJyZW50RHVyYXRpb259PC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e21vYmlsZV9zdHlsZS5kdXJhdGlvbl9zZXBhcmF0b3J9Pi88L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17bW9iaWxlX3N0eWxlLmR1cmF0aW9uX3RvdGFsfT57ZHVyYXRpb24udG90YWxEdXJhdGlvbn08L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Ake21vYmlsZV9zdHlsZS5mdWxsc2NyZWVuX2J0bn0gbWF0ZXJpYWwtaWNvbnMtcm91bmRgfSBvbkNsaWNrPXsoKSA9PiBfaGFuZGxlQ2xpY2soXCJmdWxsc2NyZWVuXCIpfT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7ZnVsbHNjcmVlbiA/IFwiZnVsbHNjcmVlbl9leGl0XCIgOiBcImZ1bGxzY3JlZW5cIn1cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgPGRpdiByZWY9e3RpbWVsaW5lQ29udHJvbGxlcn0gY2xhc3NOYW1lPXtgJHttb2JpbGVfc3R5bGUudGltZWxpbmVfd3JhcH1gfT5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXttb2JpbGVfc3R5bGUudGltZWxpbmVfcGFuZWx9PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXttb2JpbGVfc3R5bGUudGltZWxpbmVfc2xpZGVyfT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e21vYmlsZV9zdHlsZS50aW1lbGluZV9zbGlkZXJfdHJhY2t9PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e21vYmlsZV9zdHlsZS50aW1lbGluZV9zbGlkZXJfcHJvZ3Jlc3N9IHN0eWxlPXt7IHdpZHRoOiBkdXJhdGlvbi5wZXJjZW50YWdlICsgXCIlXCIgfX0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e21vYmlsZV9zdHlsZS50aW1lbGluZV9zbGlkZXJfaGFuZGxlfT48L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAge3Nob3dTZXR0aW5ncyAmJiA8ZGl2IGNsYXNzTmFtZT17YCR7bW9iaWxlX3N0eWxlLmJvdHRvbV9zZXR0aW5nc19wb3B1cF93cmFwcGVyfWB9IG9uQ2xpY2s9eygpID0+IF9jbG9zZVNldHRpbmdzKCl9PjwvZGl2Pn1cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtgJHttb2JpbGVfc3R5bGUuYm90dG9tX3NldHRpbmdzX3BvcHVwfSAke3Nob3dTZXR0aW5ncyAmJiBtb2JpbGVfc3R5bGUuc2hvd19zZXR0aW5nfWB9PlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXttb2JpbGVfc3R5bGUuc2V0dGluZ3NfcG9wdXBfaGVhZGVyfT5cbiAgICAgICAgICAgICAgICAgICAgPGEgY2xhc3NOYW1lPXttb2JpbGVfc3R5bGUuc2V0dGluZ3NfcG9wdXBfdGl0bGV9PlNldHRpbmdzPC9hPlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXttb2JpbGVfc3R5bGUuc2V0dGluZ3NfcG9wdXBfYm9keX0+XG4gICAgICAgICAgICAgICAgICAgIHshc2V0dGluZ3NTaG93UXVhbGl0eSAmJiAhc2V0dGluZ3NTaG93U3BlZWQgJiYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e21vYmlsZV9zdHlsZS5zZXR0aW5nc19wb3B1cF9ib2R5X2l0ZW19IG9uQ2xpY2s9eygpID0+IHNldFNldHRpbmdzU2hvd1F1YWxpdHkodHJ1ZSl9PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtgJHttb2JpbGVfc3R5bGUuc2V0dGluZ3NfcG9wdXBfYm9keV9pdGVtX2ljb259IG1hdGVyaWFsLWljb25zLXJvdW5kYH0gb25DbGljaz17KCkgPT4gaGFuZGxlUGxheVBhdXNlKCl9PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0dW5lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e21vYmlsZV9zdHlsZS5zZXR0aW5nc19wb3B1cF9ib2R5X2l0ZW1fdGV4dH0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFF1YWxpdHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e21vYmlsZV9zdHlsZS5jdXJyZW50X3F1YWxpdHl9PiB7cXVhbGl0eSA9PT0gXCJhdXRvXCIgPyBcIkF1dG9cIiA6IHF1YWxpdHkgPT0gMCA/IFwiMzYwcFwiIDogcXVhbGl0eSA9PSAxID8gXCI0ODBwXCIgOiBxdWFsaXR5ID09IDIgPyBcIjcyMHBcIiA6IFwiMTA4MHBcIn08L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgICAgICAgICB7c2V0dGluZ3NTaG93UXVhbGl0eSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgbGV2ZWxzLm1hcCgobGV2ZWwsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e21vYmlsZV9zdHlsZS5zZXR0aW5nc19wb3B1cF9ib2R5X2l0ZW19IGtleT17aW5kZXh9IG9uQ2xpY2s9eygpID0+IGhhbmRsZVF1YWxpdHlTZWxlY3QoaW5kZXgpfT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtgJHttb2JpbGVfc3R5bGUuc2V0dGluZ3NfcG9wdXBfYm9keV9pdGVtX2ljb259IG1hdGVyaWFsLWljb25zLXJvdW5kYH0+PC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YSBjbGFzc05hbWU9e21vYmlsZV9zdHlsZS5zZXR0aW5nc19wb3B1cF9ib2R5X2l0ZW1fdGV4dH0+e2xldmVsLmhlaWdodH1wPC9hPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICB9KX1cbiAgICAgICAgICAgICAgICAgICAgeyFzZXR0aW5nc1Nob3dRdWFsaXR5ICYmICFzZXR0aW5nc1Nob3dTcGVlZCAmJiAoXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17bW9iaWxlX3N0eWxlLnNldHRpbmdzX3BvcHVwX2JvZHlfaXRlbX0gb25DbGljaz17KCkgPT4gc2V0U2V0dGluZ3NTaG93U3BlZWQodHJ1ZSl9PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtgJHttb2JpbGVfc3R5bGUuc2V0dGluZ3NfcG9wdXBfYm9keV9pdGVtX2ljb259IG1hdGVyaWFsLWljb25zLXJvdW5kYH0gb25DbGljaz17KCkgPT4gaGFuZGxlUGxheVBhdXNlKCl9PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzbG93X21vdGlvbl92aWRlb1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxhIGNsYXNzTmFtZT17bW9iaWxlX3N0eWxlLnNldHRpbmdzX3BvcHVwX2JvZHlfaXRlbV90ZXh0fT5QbGF5YmFjayBTcGVlZDwvYT5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgICAgICAgICB7c2V0dGluZ3NTaG93U3BlZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHBsYXliYWNrU3BlZWRzTGlzdC5tYXAoKHNwZWVkLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXttb2JpbGVfc3R5bGUuc2V0dGluZ3NfcG9wdXBfYm9keV9pdGVtfSBrZXk9e2luZGV4fSBvbkNsaWNrPXsoKSA9PiBoYW5kbGVTcGVlZFNlbGVjdChzcGVlZCl9PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Ake21vYmlsZV9zdHlsZS5zZXR0aW5nc19wb3B1cF9ib2R5X2l0ZW1faWNvbn0gbWF0ZXJpYWwtaWNvbnMtcm91bmRgfT48L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxhIGNsYXNzTmFtZT17bW9iaWxlX3N0eWxlLnNldHRpbmdzX3BvcHVwX2JvZHlfaXRlbV90ZXh0fT57c3BlZWR9eDwvYT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSl9XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDx2aWRlbyBhdXRvUGxheSBvbkNsaWNrPXsoKSA9PiBoYW5kbGVQbGF5UGF1c2UoKX0gcmVmPXt2aWRlb0NvbnRyb2xsZXJ9IGNsYXNzTmFtZT17bW9iaWxlX3N0eWxlLnZpZGVvfSAvPlxuICAgICAgICA8L2Rpdj5cbiAgICApXG59XG4iXSwibmFtZXMiOlsidXNlUmVmIiwidXNlU3RhdGUiLCJ1c2VFZmZlY3QiLCJtb2JpbGVfc3R5bGUiLCJ0b2FzdFNlcnZpY2UiLCJJbWFnZSIsInRlc3RJbWFnZSIsImZvcm1hdER1cmF0aW9uIiwiTG9hZGluZyIsIkhscyIsIlZpZGVvUGxheWVyTW9iaWxlIiwicHJvcHMiLCJzcmMiLCJ2aWRlb0lkIiwiYWRTcmMiLCJwbGF5YmFja1NwZWVkc0xpc3QiLCJ2aWRlb1BsYXllciIsInZpZGVvQ29udHJvbGxlciIsInRpbWVsaW5lQ29udHJvbGxlciIsImlzUGxheWluZyIsInNldElzUGxheWluZyIsImZ1bGxzY3JlZW4iLCJzZXRGdWxsc2NyZWVuIiwic2hvd0VuZFNjcmVlbiIsInNldFNob3dFbmRTY3JlZW4iLCJzaG93U2V0dGluZ3MiLCJzZXRTaG93U2V0dGluZ3MiLCJzZXR0aW5nc1Nob3dRdWFsaXR5Iiwic2V0U2V0dGluZ3NTaG93UXVhbGl0eSIsInNldHRpbmdzU2hvd1NwZWVkIiwic2V0U2V0dGluZ3NTaG93U3BlZWQiLCJtdXRlZCIsInNldE11dGVkIiwic2hvd0NvbnRyb2xzIiwic2V0U2hvd0NvbnRyb2xzIiwicGxheWluZ0FkIiwic2V0UGxheWluZ0FkIiwibG9hZGluZyIsInNldExvYWRpbmciLCJjdXJyZW50RHVyYXRpb24iLCJ0b3RhbER1cmF0aW9uIiwicGVyY2VudGFnZSIsImR1cmF0aW9uIiwic2V0RHVyYXRpb24iLCJxdWFsaXR5Iiwic2V0UXVhbGl0eSIsImxldmVscyIsInNldExldmVscyIsIl9jbG9zZVNldHRpbmdzIiwiaGFuZGxlU2V0dGluZ3MiLCJoYW5kbGVRdWFsaXR5U2VsZWN0IiwicSIsImhhbmRsZVNwZWVkU2VsZWN0IiwicyIsImN1cnJlbnQiLCJwbGF5YmFja1JhdGUiLCJjYWxjdWxhdGVTbGlkZXIiLCJjbGljayIsImVsbSIsInZvbHVtZV93aWR0aCIsIm9mZnNldFdpZHRoIiwiY2xpY2tfeCIsImNsaWVudFgiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJsZWZ0Iiwidm9sdW1lIiwidG9GaXhlZCIsImhhbmRsZUZ1bGxTY3JlZW4iLCJkb2N1bWVudCIsImZ1bGxzY3JlZW5FbGVtZW50IiwiZXhpdEZ1bGxzY3JlZW4iLCJyZXF1ZXN0RnVsbHNjcmVlbiIsIndlYmtpdFJlcXVlc3RGdWxsc2NyZWVuIiwibW96UmVxdWVzdEZ1bGxTY3JlZW4iLCJtc1JlcXVlc3RGdWxsc2NyZWVuIiwiaGFuZGxlUGxheVBhdXNlIiwicGF1c2VkIiwicGxheSIsInNldFRpbWVvdXQiLCJwYXVzZSIsImhhbmRsZVVubXV0ZSIsImhhbmRsZVRpbWVsaW5lIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImhhbmRsZVRpbWVsaW5lU2xpZGVyIiwiZSIsInByZXZlbnREZWZhdWx0Iiwic2xpZGVyIiwiZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSIsInRpbWVsaW5lX3NsaWRlciIsInBlcmNlbnQiLCJjdXJyZW50VGltZSIsIm9uUHJlc3NGb3J3YXJkT3JCYWNrd2FyZCIsIm51bWJlciIsIl9oYW5kbGVDbGljayIsImV2ZW50IiwiYWRkRXZlbnRMaXN0ZW5lciIsImRlZmF1bHRPcHRpb25zIiwic3RhcnRMZXZlbCIsImxpY2Vuc2VYaHJTZXR1cCIsInhociIsInVybCIsIndpdGhDcmVkZW50aWFscyIsInJlYWR5U3RhdGUiLCJvcGVuIiwic2V0UmVxdWVzdEhlYWRlciIsInJlYnVpbGQiLCJ2aWRlbyIsImhscyIsImxvYWRTb3VyY2UiLCJhdHRhY2hNZWRpYSIsInJlbW92ZUF0dHJpYnV0ZSIsImF1dG9QbGF5IiwiY2FuUGxheVR5cGUiLCJpc0lPUyIsInNldEF0dHJpYnV0ZSIsImlzU3VwcG9ydGVkIiwiY29uc29sZSIsImVycm9yIiwiaW5jbHVkZXMiLCJkZXN0cm95Iiwib25jZSIsIkV2ZW50cyIsIkxFVkVMX0xPQURFRCIsImRhdGEiLCJsZXZlbF9kdXJhdGlvbiIsImRldGFpbHMiLCJ0b3RhbGR1cmF0aW9uIiwiTUFOSUZFU1RfUEFSU0VEIiwiY3VycmVudExldmVsIiwiZGl2IiwiY2xhc3NOYW1lIiwidmlkZW9fd3JhcHBlciIsInJlZiIsIm9uQ2xpY2siLCJwbGF5aW5nX2FkX3dyYXBwZXIiLCJ1bm11dGVfYnV0dG9uIiwiY29udHJvbHMiLCJoaWRlX2NvbnRyb2xzIiwic2hvd19jb250cm9scyIsInRvcF9jb250cm9scyIsInNldHRpbmdzIiwibWlkZGxlX2NvbnRyb2xzIiwidyIsImgiLCJza2lwX3ByZXZpb3VzX2J0biIsInBsYXlfcGF1c2VfYnRuIiwic2tpcF9uZXh0X2J0biIsImJvdHRvbV9jb250cm9scyIsImR1cmF0aW9uX3dyYXBwZXIiLCJkdXJhdGlvbl9jdXJyZW50IiwiZHVyYXRpb25fc2VwYXJhdG9yIiwiZHVyYXRpb25fdG90YWwiLCJmdWxsc2NyZWVuX2J0biIsInRpbWVsaW5lX3dyYXAiLCJ0aW1lbGluZV9wYW5lbCIsInRpbWVsaW5lX3NsaWRlcl90cmFjayIsInRpbWVsaW5lX3NsaWRlcl9wcm9ncmVzcyIsInN0eWxlIiwid2lkdGgiLCJ0aW1lbGluZV9zbGlkZXJfaGFuZGxlIiwiYm90dG9tX3NldHRpbmdzX3BvcHVwX3dyYXBwZXIiLCJib3R0b21fc2V0dGluZ3NfcG9wdXAiLCJzaG93X3NldHRpbmciLCJzZXR0aW5nc19wb3B1cF9oZWFkZXIiLCJhIiwic2V0dGluZ3NfcG9wdXBfdGl0bGUiLCJzZXR0aW5nc19wb3B1cF9ib2R5Iiwic2V0dGluZ3NfcG9wdXBfYm9keV9pdGVtIiwic2V0dGluZ3NfcG9wdXBfYm9keV9pdGVtX2ljb24iLCJzZXR0aW5nc19wb3B1cF9ib2R5X2l0ZW1fdGV4dCIsImN1cnJlbnRfcXVhbGl0eSIsIm1hcCIsImxldmVsIiwiaW5kZXgiLCJoZWlnaHQiLCJzcGVlZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/components/VideoPlayer/Mobile.js\n");

/***/ }),

/***/ "./src/components/VideoPlayer/index.js":
/*!*********************************************!*\
  !*** ./src/components/VideoPlayer/index.js ***!
  \*********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"VideoPlayerDesktop\": function() { return /* reexport safe */ _Desktop__WEBPACK_IMPORTED_MODULE_1__.VideoPlayerDesktop; },\n/* harmony export */   \"VideoPlayerMobile\": function() { return /* reexport safe */ _Mobile__WEBPACK_IMPORTED_MODULE_0__.VideoPlayerMobile; }\n/* harmony export */ });\n/* harmony import */ var _Mobile__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Mobile */ \"./src/components/VideoPlayer/Mobile.js\");\n/* harmony import */ var _Desktop__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Desktop */ \"./src/components/VideoPlayer/Desktop.js\");\n\n\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29tcG9uZW50cy9WaWRlb1BsYXllci9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQTRDO0FBQ0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbXBvbmVudHMvVmlkZW9QbGF5ZXIvaW5kZXguanM/NmZlNiJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgeyBWaWRlb1BsYXllck1vYmlsZSB9IGZyb20gXCIuL01vYmlsZVwiXG5leHBvcnQgeyBWaWRlb1BsYXllckRlc2t0b3AgfSBmcm9tIFwiLi9EZXNrdG9wXCIiXSwibmFtZXMiOlsiVmlkZW9QbGF5ZXJNb2JpbGUiLCJWaWRlb1BsYXllckRlc2t0b3AiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/components/VideoPlayer/index.js\n");

/***/ }),

/***/ "./src/pages/Watch/[videoId].js":
/*!**************************************!*\
  !*** ./src/pages/Watch/[videoId].js ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"__N_SSP\": function() { return /* binding */ __N_SSP; },\n/* harmony export */   \"default\": function() { return /* binding */ Watch; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var components_Modal_donate_modal_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! components/Modal/donate.modal.js */ \"./src/components/Modal/donate.modal.js\");\n/* harmony import */ var moment__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! moment */ \"./node_modules/moment/moment.js\");\n/* harmony import */ var moment__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(moment__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var next_head_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! next/head.js */ \"./node_modules/next/head.js\");\n/* harmony import */ var next_head_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(next_head_js__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var util_functions_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! util/functions.js */ \"./src/util/functions.js\");\n/* harmony import */ var _components_VideoPlayer_index_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../components/VideoPlayer/index.js */ \"./src/components/VideoPlayer/index.js\");\n/* harmony import */ var _Watch_module_css__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Watch.module.css */ \"./src/pages/Watch/Watch.module.css\");\n/* harmony import */ var _Watch_module_css__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_Watch_module_css__WEBPACK_IMPORTED_MODULE_7__);\nvar _this = undefined;\n\n\n\n\n\n\n\n//IPHONE : Mozilla/5.0 (iPhone; CPU iPhone OS 15_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.5 Mobile/15E148 Safari/604.1\n// SAFARI APPLE M1 : Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.5 Safari/605.1.15\n\nvar _s = $RefreshSig$();\nvar __N_SSP = true;\nfunction Watch(props) {\n    _s();\n    var videoData = props.videoData.data;\n    var videoId = videoData.videoId;\n    var publishedAt = moment__WEBPACK_IMPORTED_MODULE_2___default().unix(videoData.publishedAt);\n    videoData.title = videoData.title.length > 50 ? videoData.title.substring(0, 50) + \"...\" : videoData.title;\n    videoData.ago = moment__WEBPACK_IMPORTED_MODULE_2___default()(publishedAt).fromNow();\n    videoData.views = (0,util_functions_js__WEBPACK_IMPORTED_MODULE_5__.convertToInternationalCurrencySystem)(videoData.viewCount);\n    videoData.likes = (0,util_functions_js__WEBPACK_IMPORTED_MODULE_5__.convertToInternationalCurrencySystem)(videoData.likeCount);\n    videoData.comments = (0,util_functions_js__WEBPACK_IMPORTED_MODULE_5__.convertToInternationalCurrencySystem)(videoData.commentCount);\n    videoData.description = \"<strong>\\uD83D\\uDDA5\\uFE0F PC Specs</strong> <br/>\\n    \\u2022 i9 9900K , 32 GB DDR4 RAM , ASUS ROG Strix  Z390-F, GPU RTX 3080 <br/>\\n    \\u2022 Camera - Logitech C-922 <br/>\\n    \\u2022 Mic- Samson c03u<br/>\\n    \\u2022 Headset - boAt Immortal IM1300 Gaming<br/>\\n    \\u2022 Keyboard - Logitech G613 Wireless Mechanical Keyboard<br/>\\n    \\u2022 Mouse -  Logitech G304 Wireless Gaming Mouse<br/>\\n    \\u2022 Monitor - LG Ultragear 27Inch<br/>\\n    <br/>\\n    <strong>\\uD83D\\uDCB0 Benefits Of Being A Sponsor \\uD83D\\uDCB0</strong><br/>\\n    <br/>\\n    \\u2022 Get's a custom badge & Emoji's <br/>\\n    \\u2022 Can play with me on non-sub games<br/>\\n    \\u2022 Can join discord voice channel on non-sub games<br/>\\n    \\u2022 Participate in Sponsor's only Giveaway's.<br/>\\n    <br/>\\n    <strong>About RakaZone Gaming \\uD83D\\uDC66\\uD83C\\uDFFB</strong><br/>\\n    <br/>\\n    \\u2022 Rishab Karanwal<br/>\\n    \\u2022 28<br/>\\n    \\u2022 New Delhi, India<br/>\";\n    var AdVideoSrc = \"https://keviv.xyz/api/downloads/SampleAd/playlist.m3u8\";\n    var ref = (0,react__WEBPACK_IMPORTED_MODULE_4__.useState)(false), showDonateModal = ref[0], setShowDonateModal = ref[1];\n    var ref1 = (0,react__WEBPACK_IMPORTED_MODULE_4__.useState)(props.isMobile), isMobile = ref1[0], setIsMobile = ref1[1];\n    var ref2 = (0,react__WEBPACK_IMPORTED_MODULE_4__.useState)(true), loading = ref2[0], setLoading = ref2[1];\n    var component = {\n        desktop: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_VideoPlayer_index_js__WEBPACK_IMPORTED_MODULE_6__.VideoPlayerDesktop, {\n            videoId: videoId,\n            isIOS: props.isIOS,\n            adSrc: AdVideoSrc\n        }, void 0, false, {\n            fileName: \"/home/isolated/rakazone/rakazone-frontend/src/pages/Watch/[videoId].js\",\n            lineNumber: 52,\n            columnNumber: 18\n        }, this),\n        mobile: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_VideoPlayer_index_js__WEBPACK_IMPORTED_MODULE_6__.VideoPlayerMobile, {\n            videoId: videoId,\n            isIOS: props.isIOS,\n            adSrc: AdVideoSrc\n        }, void 0, false, {\n            fileName: \"/home/isolated/rakazone/rakazone-frontend/src/pages/Watch/[videoId].js\",\n            lineNumber: 53,\n            columnNumber: 17\n        }, this)\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((next_head_js__WEBPACK_IMPORTED_MODULE_3___default()), {\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"title\", {\n                    children: videoData.title\n                }, void 0, false, {\n                    fileName: \"/home/isolated/rakazone/rakazone-frontend/src/pages/Watch/[videoId].js\",\n                    lineNumber: 58,\n                    columnNumber: 13\n                }, this)\n            }, void 0, false, {\n                fileName: \"/home/isolated/rakazone/rakazone-frontend/src/pages/Watch/[videoId].js\",\n                lineNumber: 57,\n                columnNumber: 9\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"container-default\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: (_Watch_module_css__WEBPACK_IMPORTED_MODULE_7___default().player_wrapper),\n                        children: isMobile !== null && isMobile ? component.mobile : component.desktop\n                    }, void 0, false, {\n                        fileName: \"/home/isolated/rakazone/rakazone-frontend/src/pages/Watch/[videoId].js\",\n                        lineNumber: 61,\n                        columnNumber: 13\n                    }, this),\n                    isMobile ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(MobileVideoDetails, {\n                        videoData: videoData,\n                        setShowDonateModal: setShowDonateModal\n                    }, void 0, false, {\n                        fileName: \"/home/isolated/rakazone/rakazone-frontend/src/pages/Watch/[videoId].js\",\n                        lineNumber: 62,\n                        columnNumber: 25\n                    }, this) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(DesktopVideoDetails, {\n                        videoData: videoData,\n                        setShowDonateModal: setShowDonateModal\n                    }, void 0, false, {\n                        fileName: \"/home/isolated/rakazone/rakazone-frontend/src/pages/Watch/[videoId].js\",\n                        lineNumber: 62,\n                        columnNumber: 112\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(components_Modal_donate_modal_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"], {\n                        show: showDonateModal,\n                        onClose: function() {\n                            return setShowDonateModal(false);\n                        }\n                    }, void 0, false, {\n                        fileName: \"/home/isolated/rakazone/rakazone-frontend/src/pages/Watch/[videoId].js\",\n                        lineNumber: 63,\n                        columnNumber: 14\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/home/isolated/rakazone/rakazone-frontend/src/pages/Watch/[videoId].js\",\n                lineNumber: 60,\n                columnNumber: 9\n            }, this)\n        ]\n    }, void 0, true);\n};\n_s(Watch, \"ryeQTR3jrym3wFPW49otB+5gv50=\");\n_c = Watch;\nvar MobileVideoDetails = function(param) {\n    var videoData = param.videoData, setShowDonateModal = param.setShowDonateModal;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            className: (_Watch_module_css__WEBPACK_IMPORTED_MODULE_7___default().mobile_video_details),\n            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: (_Watch_module_css__WEBPACK_IMPORTED_MODULE_7___default().mobile_video_details_wrapper),\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: (_Watch_module_css__WEBPACK_IMPORTED_MODULE_7___default().mobile_video_details_wrapper_left),\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: (_Watch_module_css__WEBPACK_IMPORTED_MODULE_7___default().mobile_video_details_wrapper_left_title),\n                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h1\", {\n                                children: videoData.title\n                            }, void 0, false, {\n                                fileName: \"/home/isolated/rakazone/rakazone-frontend/src/pages/Watch/[videoId].js\",\n                                lineNumber: 76,\n                                columnNumber: 25\n                            }, _this)\n                        }, void 0, false, {\n                            fileName: \"/home/isolated/rakazone/rakazone-frontend/src/pages/Watch/[videoId].js\",\n                            lineNumber: 75,\n                            columnNumber: 21\n                        }, _this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: (_Watch_module_css__WEBPACK_IMPORTED_MODULE_7___default().mobile_video_stats),\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: (_Watch_module_css__WEBPACK_IMPORTED_MODULE_7___default().mobile_videoStats_item),\n                                    children: [\n                                        videoData.views,\n                                        \" Views\"\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"/home/isolated/rakazone/rakazone-frontend/src/pages/Watch/[videoId].js\",\n                                    lineNumber: 79,\n                                    columnNumber: 25\n                                }, _this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: (_Watch_module_css__WEBPACK_IMPORTED_MODULE_7___default().content_about_divider)\n                                }, void 0, false, {\n                                    fileName: \"/home/isolated/rakazone/rakazone-frontend/src/pages/Watch/[videoId].js\",\n                                    lineNumber: 80,\n                                    columnNumber: 25\n                                }, _this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: (_Watch_module_css__WEBPACK_IMPORTED_MODULE_7___default().mobile_videoStats_item),\n                                    children: videoData.ago\n                                }, void 0, false, {\n                                    fileName: \"/home/isolated/rakazone/rakazone-frontend/src/pages/Watch/[videoId].js\",\n                                    lineNumber: 81,\n                                    columnNumber: 25\n                                }, _this)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"/home/isolated/rakazone/rakazone-frontend/src/pages/Watch/[videoId].js\",\n                            lineNumber: 78,\n                            columnNumber: 21\n                        }, _this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: (_Watch_module_css__WEBPACK_IMPORTED_MODULE_7___default().mobile_video_other_details),\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: (_Watch_module_css__WEBPACK_IMPORTED_MODULE_7___default().mobile_video_other_details_item),\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                            className: \"material-icons-round \".concat((_Watch_module_css__WEBPACK_IMPORTED_MODULE_7___default().mobile_video_other_details_icons)),\n                                            children: \"thumb_up\"\n                                        }, void 0, false, {\n                                            fileName: \"/home/isolated/rakazone/rakazone-frontend/src/pages/Watch/[videoId].js\",\n                                            lineNumber: 85,\n                                            columnNumber: 29\n                                        }, _this),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                            className: (_Watch_module_css__WEBPACK_IMPORTED_MODULE_7___default().mobile_video_other_details_text),\n                                            children: videoData.likes\n                                        }, void 0, false, {\n                                            fileName: \"/home/isolated/rakazone/rakazone-frontend/src/pages/Watch/[videoId].js\",\n                                            lineNumber: 86,\n                                            columnNumber: 29\n                                        }, _this)\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"/home/isolated/rakazone/rakazone-frontend/src/pages/Watch/[videoId].js\",\n                                    lineNumber: 84,\n                                    columnNumber: 25\n                                }, _this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: (_Watch_module_css__WEBPACK_IMPORTED_MODULE_7___default().mobile_video_other_details_item),\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                            className: \"material-icons-round \".concat((_Watch_module_css__WEBPACK_IMPORTED_MODULE_7___default().mobile_video_other_details_icons)),\n                                            children: \"question_answer\"\n                                        }, void 0, false, {\n                                            fileName: \"/home/isolated/rakazone/rakazone-frontend/src/pages/Watch/[videoId].js\",\n                                            lineNumber: 89,\n                                            columnNumber: 29\n                                        }, _this),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                            className: (_Watch_module_css__WEBPACK_IMPORTED_MODULE_7___default().mobile_video_other_details_text),\n                                            children: videoData.comments\n                                        }, void 0, false, {\n                                            fileName: \"/home/isolated/rakazone/rakazone-frontend/src/pages/Watch/[videoId].js\",\n                                            lineNumber: 90,\n                                            columnNumber: 29\n                                        }, _this)\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"/home/isolated/rakazone/rakazone-frontend/src/pages/Watch/[videoId].js\",\n                                    lineNumber: 88,\n                                    columnNumber: 25\n                                }, _this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: (_Watch_module_css__WEBPACK_IMPORTED_MODULE_7___default().mobile_video_other_details_item),\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                            className: \"material-icons-round \".concat((_Watch_module_css__WEBPACK_IMPORTED_MODULE_7___default().mobile_video_other_details_icons)),\n                                            children: \"share\"\n                                        }, void 0, false, {\n                                            fileName: \"/home/isolated/rakazone/rakazone-frontend/src/pages/Watch/[videoId].js\",\n                                            lineNumber: 93,\n                                            columnNumber: 29\n                                        }, _this),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                            className: (_Watch_module_css__WEBPACK_IMPORTED_MODULE_7___default().mobile_video_other_details_text),\n                                            children: \"Share\"\n                                        }, void 0, false, {\n                                            fileName: \"/home/isolated/rakazone/rakazone-frontend/src/pages/Watch/[videoId].js\",\n                                            lineNumber: 94,\n                                            columnNumber: 29\n                                        }, _this)\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"/home/isolated/rakazone/rakazone-frontend/src/pages/Watch/[videoId].js\",\n                                    lineNumber: 92,\n                                    columnNumber: 25\n                                }, _this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: (_Watch_module_css__WEBPACK_IMPORTED_MODULE_7___default().mobile_video_other_details_item),\n                                    onClick: function() {\n                                        return setShowDonateModal(true);\n                                    },\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                            className: \"material-icons-round \".concat((_Watch_module_css__WEBPACK_IMPORTED_MODULE_7___default().mobile_video_other_details_icons)),\n                                            children: \"attach_money\"\n                                        }, void 0, false, {\n                                            fileName: \"/home/isolated/rakazone/rakazone-frontend/src/pages/Watch/[videoId].js\",\n                                            lineNumber: 97,\n                                            columnNumber: 29\n                                        }, _this),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                            className: (_Watch_module_css__WEBPACK_IMPORTED_MODULE_7___default().mobile_video_other_details_text),\n                                            children: \"Thanks\"\n                                        }, void 0, false, {\n                                            fileName: \"/home/isolated/rakazone/rakazone-frontend/src/pages/Watch/[videoId].js\",\n                                            lineNumber: 98,\n                                            columnNumber: 29\n                                        }, _this)\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"/home/isolated/rakazone/rakazone-frontend/src/pages/Watch/[videoId].js\",\n                                    lineNumber: 96,\n                                    columnNumber: 25\n                                }, _this)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"/home/isolated/rakazone/rakazone-frontend/src/pages/Watch/[videoId].js\",\n                            lineNumber: 83,\n                            columnNumber: 21\n                        }, _this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"divider\"\n                        }, void 0, false, {\n                            fileName: \"/home/isolated/rakazone/rakazone-frontend/src/pages/Watch/[videoId].js\",\n                            lineNumber: 101,\n                            columnNumber: 21\n                        }, _this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: (_Watch_module_css__WEBPACK_IMPORTED_MODULE_7___default().mobile_video_description),\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"a\", {\n                                    children: [\n                                        \"\\uD83D\\uDCB2 UPI \\u2022 rakazonegaming@oksbi \",\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"br\", {}, void 0, false, {\n                                            fileName: \"/home/isolated/rakazone/rakazone-frontend/src/pages/Watch/[videoId].js\",\n                                            lineNumber: 104,\n                                            columnNumber: 58\n                                        }, _this),\n                                        \"\\uD83D\\uDCB2 Sponsor \\u2022 https://raka.zone/sponsor\",\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"br\", {}, void 0, false, {\n                                            fileName: \"/home/isolated/rakazone/rakazone-frontend/src/pages/Watch/[videoId].js\",\n                                            lineNumber: 106,\n                                            columnNumber: 29\n                                        }, _this),\n                                        \"\\uD83D\\uDCB2 Donation Via PayPal \\u2022 https://raka.zone/paypal\",\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"br\", {}, void 0, false, {\n                                            fileName: \"/home/isolated/rakazone/rakazone-frontend/src/pages/Watch/[videoId].js\",\n                                            lineNumber: 108,\n                                            columnNumber: 29\n                                        }, _this),\n                                        \"\\uD83D\\uDE4F Every Tip Is Appreciated\"\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"/home/isolated/rakazone/rakazone-frontend/src/pages/Watch/[videoId].js\",\n                                    lineNumber: 103,\n                                    columnNumber: 25\n                                }, _this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                    dangerouslySetInnerHTML: {\n                                        __html: videoData.description\n                                    }\n                                }, void 0, false, {\n                                    fileName: \"/home/isolated/rakazone/rakazone-frontend/src/pages/Watch/[videoId].js\",\n                                    lineNumber: 111,\n                                    columnNumber: 25\n                                }, _this)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"/home/isolated/rakazone/rakazone-frontend/src/pages/Watch/[videoId].js\",\n                            lineNumber: 102,\n                            columnNumber: 21\n                        }, _this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"/home/isolated/rakazone/rakazone-frontend/src/pages/Watch/[videoId].js\",\n                    lineNumber: 74,\n                    columnNumber: 17\n                }, _this)\n            }, void 0, false, {\n                fileName: \"/home/isolated/rakazone/rakazone-frontend/src/pages/Watch/[videoId].js\",\n                lineNumber: 73,\n                columnNumber: 13\n            }, _this)\n        }, void 0, false, {\n            fileName: \"/home/isolated/rakazone/rakazone-frontend/src/pages/Watch/[videoId].js\",\n            lineNumber: 72,\n            columnNumber: 9\n        }, _this)\n    }, void 0, false);\n};\n_c1 = MobileVideoDetails;\nvar DesktopVideoDetails = function(param) {\n    var videoData = param.videoData, setShowDonateModal = param.setShowDonateModal;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: (_Watch_module_css__WEBPACK_IMPORTED_MODULE_7___default().desktop_video_details),\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            className: (_Watch_module_css__WEBPACK_IMPORTED_MODULE_7___default().desktop_video_details_wrapper_main),\n            children: [\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: (_Watch_module_css__WEBPACK_IMPORTED_MODULE_7___default().desktop_video_details_wrapper),\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: (_Watch_module_css__WEBPACK_IMPORTED_MODULE_7___default().desktop_details_left),\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: (_Watch_module_css__WEBPACK_IMPORTED_MODULE_7___default().desktop_video_details_wrapper_title),\n                                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"a\", {\n                                        className: (_Watch_module_css__WEBPACK_IMPORTED_MODULE_7___default().desktop_video_title),\n                                        children: videoData.title\n                                    }, void 0, false, {\n                                        fileName: \"/home/isolated/rakazone/rakazone-frontend/src/pages/Watch/[videoId].js\",\n                                        lineNumber: 127,\n                                        columnNumber: 29\n                                    }, _this)\n                                }, void 0, false, {\n                                    fileName: \"/home/isolated/rakazone/rakazone-frontend/src/pages/Watch/[videoId].js\",\n                                    lineNumber: 126,\n                                    columnNumber: 25\n                                }, _this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: (_Watch_module_css__WEBPACK_IMPORTED_MODULE_7___default().desktop_video_stats),\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                            className: (_Watch_module_css__WEBPACK_IMPORTED_MODULE_7___default().desktop_videoStats_item),\n                                            children: [\n                                                videoData.views,\n                                                \" Views\"\n                                            ]\n                                        }, void 0, true, {\n                                            fileName: \"/home/isolated/rakazone/rakazone-frontend/src/pages/Watch/[videoId].js\",\n                                            lineNumber: 130,\n                                            columnNumber: 29\n                                        }, _this),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                            className: (_Watch_module_css__WEBPACK_IMPORTED_MODULE_7___default().content_about_divider)\n                                        }, void 0, false, {\n                                            fileName: \"/home/isolated/rakazone/rakazone-frontend/src/pages/Watch/[videoId].js\",\n                                            lineNumber: 131,\n                                            columnNumber: 29\n                                        }, _this),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                            className: (_Watch_module_css__WEBPACK_IMPORTED_MODULE_7___default().desktop_videoStats_item),\n                                            children: videoData.ago\n                                        }, void 0, false, {\n                                            fileName: \"/home/isolated/rakazone/rakazone-frontend/src/pages/Watch/[videoId].js\",\n                                            lineNumber: 132,\n                                            columnNumber: 29\n                                        }, _this)\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"/home/isolated/rakazone/rakazone-frontend/src/pages/Watch/[videoId].js\",\n                                    lineNumber: 129,\n                                    columnNumber: 25\n                                }, _this)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"/home/isolated/rakazone/rakazone-frontend/src/pages/Watch/[videoId].js\",\n                            lineNumber: 125,\n                            columnNumber: 21\n                        }, _this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: (_Watch_module_css__WEBPACK_IMPORTED_MODULE_7___default().desktop_video_other_details),\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: (_Watch_module_css__WEBPACK_IMPORTED_MODULE_7___default().desktop_video_other_details_item),\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                            className: \"material-icons-round \".concat((_Watch_module_css__WEBPACK_IMPORTED_MODULE_7___default().desktop_video_other_details_icons)),\n                                            children: \"thumb_up\"\n                                        }, void 0, false, {\n                                            fileName: \"/home/isolated/rakazone/rakazone-frontend/src/pages/Watch/[videoId].js\",\n                                            lineNumber: 137,\n                                            columnNumber: 29\n                                        }, _this),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                            className: (_Watch_module_css__WEBPACK_IMPORTED_MODULE_7___default().desktop_video_other_details_text),\n                                            children: videoData.likes\n                                        }, void 0, false, {\n                                            fileName: \"/home/isolated/rakazone/rakazone-frontend/src/pages/Watch/[videoId].js\",\n                                            lineNumber: 138,\n                                            columnNumber: 29\n                                        }, _this)\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"/home/isolated/rakazone/rakazone-frontend/src/pages/Watch/[videoId].js\",\n                                    lineNumber: 136,\n                                    columnNumber: 25\n                                }, _this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: (_Watch_module_css__WEBPACK_IMPORTED_MODULE_7___default().desktop_video_other_details_item),\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                            className: \"material-icons-round \".concat((_Watch_module_css__WEBPACK_IMPORTED_MODULE_7___default().desktop_video_other_details_icons)),\n                                            children: \"question_answer\"\n                                        }, void 0, false, {\n                                            fileName: \"/home/isolated/rakazone/rakazone-frontend/src/pages/Watch/[videoId].js\",\n                                            lineNumber: 141,\n                                            columnNumber: 29\n                                        }, _this),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                            className: (_Watch_module_css__WEBPACK_IMPORTED_MODULE_7___default().desktop_video_other_details_text),\n                                            children: videoData.comments\n                                        }, void 0, false, {\n                                            fileName: \"/home/isolated/rakazone/rakazone-frontend/src/pages/Watch/[videoId].js\",\n                                            lineNumber: 142,\n                                            columnNumber: 29\n                                        }, _this)\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"/home/isolated/rakazone/rakazone-frontend/src/pages/Watch/[videoId].js\",\n                                    lineNumber: 140,\n                                    columnNumber: 25\n                                }, _this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: (_Watch_module_css__WEBPACK_IMPORTED_MODULE_7___default().desktop_video_other_details_item),\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                            className: \"material-icons-round \".concat((_Watch_module_css__WEBPACK_IMPORTED_MODULE_7___default().desktop_video_other_details_icons)),\n                                            children: \"share\"\n                                        }, void 0, false, {\n                                            fileName: \"/home/isolated/rakazone/rakazone-frontend/src/pages/Watch/[videoId].js\",\n                                            lineNumber: 145,\n                                            columnNumber: 29\n                                        }, _this),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                            className: (_Watch_module_css__WEBPACK_IMPORTED_MODULE_7___default().desktop_video_other_details_text),\n                                            children: \"Share\"\n                                        }, void 0, false, {\n                                            fileName: \"/home/isolated/rakazone/rakazone-frontend/src/pages/Watch/[videoId].js\",\n                                            lineNumber: 146,\n                                            columnNumber: 29\n                                        }, _this)\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"/home/isolated/rakazone/rakazone-frontend/src/pages/Watch/[videoId].js\",\n                                    lineNumber: 144,\n                                    columnNumber: 25\n                                }, _this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: (_Watch_module_css__WEBPACK_IMPORTED_MODULE_7___default().desktop_video_other_details_item),\n                                    onClick: function() {\n                                        return setShowDonateModal(true);\n                                    },\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                            className: \"material-icons-round \".concat((_Watch_module_css__WEBPACK_IMPORTED_MODULE_7___default().desktop_video_other_details_icons)),\n                                            children: \"attach_money\"\n                                        }, void 0, false, {\n                                            fileName: \"/home/isolated/rakazone/rakazone-frontend/src/pages/Watch/[videoId].js\",\n                                            lineNumber: 149,\n                                            columnNumber: 29\n                                        }, _this),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                            className: (_Watch_module_css__WEBPACK_IMPORTED_MODULE_7___default().desktop_video_other_details_text),\n                                            children: \"Thanks\"\n                                        }, void 0, false, {\n                                            fileName: \"/home/isolated/rakazone/rakazone-frontend/src/pages/Watch/[videoId].js\",\n                                            lineNumber: 150,\n                                            columnNumber: 29\n                                        }, _this)\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"/home/isolated/rakazone/rakazone-frontend/src/pages/Watch/[videoId].js\",\n                                    lineNumber: 148,\n                                    columnNumber: 25\n                                }, _this)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"/home/isolated/rakazone/rakazone-frontend/src/pages/Watch/[videoId].js\",\n                            lineNumber: 135,\n                            columnNumber: 21\n                        }, _this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"/home/isolated/rakazone/rakazone-frontend/src/pages/Watch/[videoId].js\",\n                    lineNumber: 124,\n                    columnNumber: 17\n                }, _this),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"divider-small\"\n                }, void 0, false, {\n                    fileName: \"/home/isolated/rakazone/rakazone-frontend/src/pages/Watch/[videoId].js\",\n                    lineNumber: 154,\n                    columnNumber: 17\n                }, _this),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: (_Watch_module_css__WEBPACK_IMPORTED_MODULE_7___default().desktop_video_description),\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"a\", {\n                            children: [\n                                \"\\uD83D\\uDCB2 UPI \\u2022 rakazonegaming@oksbi \",\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"br\", {}, void 0, false, {\n                                    fileName: \"/home/isolated/rakazone/rakazone-frontend/src/pages/Watch/[videoId].js\",\n                                    lineNumber: 157,\n                                    columnNumber: 54\n                                }, _this),\n                                \"\\uD83D\\uDCB2 Sponsor \\u2022 https://raka.zone/sponsor\",\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"br\", {}, void 0, false, {\n                                    fileName: \"/home/isolated/rakazone/rakazone-frontend/src/pages/Watch/[videoId].js\",\n                                    lineNumber: 159,\n                                    columnNumber: 25\n                                }, _this),\n                                \"\\uD83D\\uDCB2 Donation Via PayPal \\u2022 https://raka.zone/paypal\",\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"br\", {}, void 0, false, {\n                                    fileName: \"/home/isolated/rakazone/rakazone-frontend/src/pages/Watch/[videoId].js\",\n                                    lineNumber: 161,\n                                    columnNumber: 25\n                                }, _this),\n                                \"\\uD83D\\uDE4F Every Tip Is Appreciated\"\n                            ]\n                        }, void 0, true, {\n                            fileName: \"/home/isolated/rakazone/rakazone-frontend/src/pages/Watch/[videoId].js\",\n                            lineNumber: 156,\n                            columnNumber: 21\n                        }, _this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                            dangerouslySetInnerHTML: {\n                                __html: videoData.description\n                            }\n                        }, void 0, false, {\n                            fileName: \"/home/isolated/rakazone/rakazone-frontend/src/pages/Watch/[videoId].js\",\n                            lineNumber: 164,\n                            columnNumber: 21\n                        }, _this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"/home/isolated/rakazone/rakazone-frontend/src/pages/Watch/[videoId].js\",\n                    lineNumber: 155,\n                    columnNumber: 17\n                }, _this)\n            ]\n        }, void 0, true, {\n            fileName: \"/home/isolated/rakazone/rakazone-frontend/src/pages/Watch/[videoId].js\",\n            lineNumber: 123,\n            columnNumber: 13\n        }, _this)\n    }, void 0, false, {\n        fileName: \"/home/isolated/rakazone/rakazone-frontend/src/pages/Watch/[videoId].js\",\n        lineNumber: 122,\n        columnNumber: 9\n    }, _this);\n};\n_c2 = DesktopVideoDetails;\nvar _c, _c1, _c2;\n$RefreshReg$(_c, \"Watch\");\n$RefreshReg$(_c1, \"MobileVideoDetails\");\n$RefreshReg$(_c2, \"DesktopVideoDetails\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Pzc3NzciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGF4aW9zIGZyb20gXCJheGlvc1wiXG5pbXBvcnQgRG9uYXRlTW9kYWwgZnJvbSBcImNvbXBvbmVudHMvTW9kYWwvZG9uYXRlLm1vZGFsLmpzXCJcbmltcG9ydCBtb21lbnQgZnJvbSBcIm1vbWVudFwiXG5pbXBvcnQgSGVhZCBmcm9tIFwibmV4dC9oZWFkLmpzXCJcbmltcG9ydCB7IHVzZUVmZmVjdCwgdXNlU3RhdGUgfSBmcm9tIFwicmVhY3RcIlxuaW1wb3J0IHsgY29udmVydFRvSW50ZXJuYXRpb25hbEN1cnJlbmN5U3lzdGVtIH0gZnJvbSBcInV0aWwvZnVuY3Rpb25zLmpzXCJcbmltcG9ydCB7IHB1YmxpY1J1bnRpbWVDb25maWcgfSBmcm9tIFwiLi4vLi4vLi4vbmV4dC5jb25maWcuanNcIlxuaW1wb3J0IHsgVmlkZW9QbGF5ZXJEZXNrdG9wLCBWaWRlb1BsYXllck1vYmlsZSB9IGZyb20gXCIuLi8uLi9jb21wb25lbnRzL1ZpZGVvUGxheWVyL2luZGV4LmpzXCJcblxuLy9JUEhPTkUgOiBNb3ppbGxhLzUuMCAoaVBob25lOyBDUFUgaVBob25lIE9TIDE1XzUgbGlrZSBNYWMgT1MgWCkgQXBwbGVXZWJLaXQvNjA1LjEuMTUgKEtIVE1MLCBsaWtlIEdlY2tvKSBWZXJzaW9uLzE1LjUgTW9iaWxlLzE1RTE0OCBTYWZhcmkvNjA0LjFcbi8vIFNBRkFSSSBBUFBMRSBNMSA6IE1vemlsbGEvNS4wIChNYWNpbnRvc2g7IEludGVsIE1hYyBPUyBYIDEwXzE1XzcpIEFwcGxlV2ViS2l0LzYwNS4xLjE1IChLSFRNTCwgbGlrZSBHZWNrbykgVmVyc2lvbi8xNS41IFNhZmFyaS82MDUuMS4xNVxuaW1wb3J0IGNzcyBmcm9tIFwiLi9XYXRjaC5tb2R1bGUuY3NzXCJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFdhdGNoKHByb3BzKSB7XG4gICAgbGV0IHZpZGVvRGF0YSA9IHByb3BzLnZpZGVvRGF0YS5kYXRhXG4gICAgbGV0IHZpZGVvSWQgPSB2aWRlb0RhdGEudmlkZW9JZFxuICAgIGxldCBwdWJsaXNoZWRBdCA9IG1vbWVudC51bml4KHZpZGVvRGF0YS5wdWJsaXNoZWRBdClcbiAgICB2aWRlb0RhdGEudGl0bGUgPSB2aWRlb0RhdGEudGl0bGUubGVuZ3RoID4gNTAgPyB2aWRlb0RhdGEudGl0bGUuc3Vic3RyaW5nKDAsIDUwKSArIFwiLi4uXCIgOiB2aWRlb0RhdGEudGl0bGVcbiAgICB2aWRlb0RhdGEuYWdvID0gbW9tZW50KHB1Ymxpc2hlZEF0KS5mcm9tTm93KClcbiAgICB2aWRlb0RhdGEudmlld3MgPSBjb252ZXJ0VG9JbnRlcm5hdGlvbmFsQ3VycmVuY3lTeXN0ZW0odmlkZW9EYXRhLnZpZXdDb3VudClcbiAgICB2aWRlb0RhdGEubGlrZXMgPSBjb252ZXJ0VG9JbnRlcm5hdGlvbmFsQ3VycmVuY3lTeXN0ZW0odmlkZW9EYXRhLmxpa2VDb3VudClcbiAgICB2aWRlb0RhdGEuY29tbWVudHMgPSBjb252ZXJ0VG9JbnRlcm5hdGlvbmFsQ3VycmVuY3lTeXN0ZW0odmlkZW9EYXRhLmNvbW1lbnRDb3VudClcbiAgICB2aWRlb0RhdGEuZGVzY3JpcHRpb24gPSBgPHN0cm9uZz7wn5al77iPIFBDIFNwZWNzPC9zdHJvbmc+IDxici8+XG4gICAg4oCiIGk5IDk5MDBLICwgMzIgR0IgRERSNCBSQU0gLCBBU1VTIFJPRyBTdHJpeCAgWjM5MC1GLCBHUFUgUlRYIDMwODAgPGJyLz5cbiAgICDigKIgQ2FtZXJhIC0gTG9naXRlY2ggQy05MjIgPGJyLz5cbiAgICDigKIgTWljLSBTYW1zb24gYzAzdTxici8+XG4gICAg4oCiIEhlYWRzZXQgLSBib0F0IEltbW9ydGFsIElNMTMwMCBHYW1pbmc8YnIvPlxuICAgIOKAoiBLZXlib2FyZCAtIExvZ2l0ZWNoIEc2MTMgV2lyZWxlc3MgTWVjaGFuaWNhbCBLZXlib2FyZDxici8+XG4gICAg4oCiIE1vdXNlIC0gIExvZ2l0ZWNoIEczMDQgV2lyZWxlc3MgR2FtaW5nIE1vdXNlPGJyLz5cbiAgICDigKIgTW9uaXRvciAtIExHIFVsdHJhZ2VhciAyN0luY2g8YnIvPlxuICAgIDxici8+XG4gICAgPHN0cm9uZz7wn5KwIEJlbmVmaXRzIE9mIEJlaW5nIEEgU3BvbnNvciDwn5KwPC9zdHJvbmc+PGJyLz5cbiAgICA8YnIvPlxuICAgIOKAoiBHZXQncyBhIGN1c3RvbSBiYWRnZSAmIEVtb2ppJ3MgPGJyLz5cbiAgICDigKIgQ2FuIHBsYXkgd2l0aCBtZSBvbiBub24tc3ViIGdhbWVzPGJyLz5cbiAgICDigKIgQ2FuIGpvaW4gZGlzY29yZCB2b2ljZSBjaGFubmVsIG9uIG5vbi1zdWIgZ2FtZXM8YnIvPlxuICAgIOKAoiBQYXJ0aWNpcGF0ZSBpbiBTcG9uc29yJ3Mgb25seSBHaXZlYXdheSdzLjxici8+XG4gICAgPGJyLz5cbiAgICA8c3Ryb25nPkFib3V0IFJha2Fab25lIEdhbWluZyDwn5Gm8J+Puzwvc3Ryb25nPjxici8+XG4gICAgPGJyLz5cbiAgICDigKIgUmlzaGFiIEthcmFud2FsPGJyLz5cbiAgICDigKIgMjg8YnIvPlxuICAgIOKAoiBOZXcgRGVsaGksIEluZGlhPGJyLz5gXG5cbiAgICBjb25zdCBBZFZpZGVvU3JjID0gYGh0dHBzOi8va2V2aXYueHl6L2FwaS9kb3dubG9hZHMvU2FtcGxlQWQvcGxheWxpc3QubTN1OGBcblxuICAgIGNvbnN0IFtzaG93RG9uYXRlTW9kYWwsIHNldFNob3dEb25hdGVNb2RhbF0gPSB1c2VTdGF0ZShmYWxzZSlcbiAgICBjb25zdCBbaXNNb2JpbGUsIHNldElzTW9iaWxlXSA9IHVzZVN0YXRlKHByb3BzLmlzTW9iaWxlKVxuICAgIGNvbnN0IFtsb2FkaW5nLCBzZXRMb2FkaW5nXSA9IHVzZVN0YXRlKHRydWUpXG5cblxuICAgIGxldCBjb21wb25lbnQgPSB7XG4gICAgICAgIGRlc2t0b3A6IDxWaWRlb1BsYXllckRlc2t0b3AgdmlkZW9JZD17dmlkZW9JZH0gaXNJT1M9e3Byb3BzLmlzSU9TfSBhZFNyYz17QWRWaWRlb1NyY30gLz4sXG4gICAgICAgIG1vYmlsZTogPFZpZGVvUGxheWVyTW9iaWxlIHZpZGVvSWQ9e3ZpZGVvSWR9IGlzSU9TPXtwcm9wcy5pc0lPU30gYWRTcmM9e0FkVmlkZW9TcmN9IC8+LFxuICAgIH1cblxuICAgIHJldHVybiAoPD5cbiAgICAgICAgPEhlYWQ+XG4gICAgICAgICAgICA8dGl0bGU+e3ZpZGVvRGF0YS50aXRsZX08L3RpdGxlPlxuICAgICAgICA8L0hlYWQ+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY29udGFpbmVyLWRlZmF1bHRcIj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtjc3MucGxheWVyX3dyYXBwZXJ9Pntpc01vYmlsZSAhPT0gbnVsbCAmJiBpc01vYmlsZSA/IGNvbXBvbmVudC5tb2JpbGUgOiBjb21wb25lbnQuZGVza3RvcH08L2Rpdj5cbiAgICAgICAgICAgIHtpc01vYmlsZSA/IDxNb2JpbGVWaWRlb0RldGFpbHMgdmlkZW9EYXRhPXt2aWRlb0RhdGF9IHNldFNob3dEb25hdGVNb2RhbD17c2V0U2hvd0RvbmF0ZU1vZGFsfSAvPiA6IDxEZXNrdG9wVmlkZW9EZXRhaWxzIHZpZGVvRGF0YT17dmlkZW9EYXRhfSBzZXRTaG93RG9uYXRlTW9kYWw9e3NldFNob3dEb25hdGVNb2RhbH0gLz59XG4gICAgICAgICAgICB7PERvbmF0ZU1vZGFsIHNob3c9e3Nob3dEb25hdGVNb2RhbH0gb25DbG9zZT17KCkgPT4gc2V0U2hvd0RvbmF0ZU1vZGFsKGZhbHNlKX0gLz59XG4gICAgICAgIDwvZGl2PlxuICAgIDwvPlxuICAgIClcbn1cblxuY29uc3QgTW9iaWxlVmlkZW9EZXRhaWxzID0gKHsgdmlkZW9EYXRhLCBzZXRTaG93RG9uYXRlTW9kYWwgfSkgPT4ge1xuICAgIHJldHVybiAoPD5cblxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT17Y3NzLm1vYmlsZV92aWRlb19kZXRhaWxzfT5cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtjc3MubW9iaWxlX3ZpZGVvX2RldGFpbHNfd3JhcHBlcn0+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Nzcy5tb2JpbGVfdmlkZW9fZGV0YWlsc193cmFwcGVyX2xlZnR9PlxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17Y3NzLm1vYmlsZV92aWRlb19kZXRhaWxzX3dyYXBwZXJfbGVmdF90aXRsZX0+XG4gICAgICAgICAgICAgICAgICAgICAgICA8aDE+e3ZpZGVvRGF0YS50aXRsZX08L2gxPlxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Nzcy5tb2JpbGVfdmlkZW9fc3RhdHN9PlxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Nzcy5tb2JpbGVfdmlkZW9TdGF0c19pdGVtfT57dmlkZW9EYXRhLnZpZXdzfSBWaWV3czwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Nzcy5jb250ZW50X2Fib3V0X2RpdmlkZXJ9IC8+XG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17Y3NzLm1vYmlsZV92aWRlb1N0YXRzX2l0ZW19Pnt2aWRlb0RhdGEuYWdvfTwvZGl2PlxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Nzcy5tb2JpbGVfdmlkZW9fb3RoZXJfZGV0YWlsc30+XG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17Y3NzLm1vYmlsZV92aWRlb19vdGhlcl9kZXRhaWxzX2l0ZW19PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtgbWF0ZXJpYWwtaWNvbnMtcm91bmQgJHtjc3MubW9iaWxlX3ZpZGVvX290aGVyX2RldGFpbHNfaWNvbnN9YH0+dGh1bWJfdXA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17Y3NzLm1vYmlsZV92aWRlb19vdGhlcl9kZXRhaWxzX3RleHR9Pnt2aWRlb0RhdGEubGlrZXN9PC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtjc3MubW9iaWxlX3ZpZGVvX290aGVyX2RldGFpbHNfaXRlbX0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2BtYXRlcmlhbC1pY29ucy1yb3VuZCAke2Nzcy5tb2JpbGVfdmlkZW9fb3RoZXJfZGV0YWlsc19pY29uc31gfT5xdWVzdGlvbl9hbnN3ZXI8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17Y3NzLm1vYmlsZV92aWRlb19vdGhlcl9kZXRhaWxzX3RleHR9Pnt2aWRlb0RhdGEuY29tbWVudHN9PC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtjc3MubW9iaWxlX3ZpZGVvX290aGVyX2RldGFpbHNfaXRlbX0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2BtYXRlcmlhbC1pY29ucy1yb3VuZCAke2Nzcy5tb2JpbGVfdmlkZW9fb3RoZXJfZGV0YWlsc19pY29uc31gfT5zaGFyZTwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtjc3MubW9iaWxlX3ZpZGVvX290aGVyX2RldGFpbHNfdGV4dH0+U2hhcmU8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Nzcy5tb2JpbGVfdmlkZW9fb3RoZXJfZGV0YWlsc19pdGVtfSBvbkNsaWNrPXsoKSA9PiBzZXRTaG93RG9uYXRlTW9kYWwodHJ1ZSl9PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtgbWF0ZXJpYWwtaWNvbnMtcm91bmQgJHtjc3MubW9iaWxlX3ZpZGVvX290aGVyX2RldGFpbHNfaWNvbnN9YH0+YXR0YWNoX21vbmV5PC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Nzcy5tb2JpbGVfdmlkZW9fb3RoZXJfZGV0YWlsc190ZXh0fT5UaGFua3M8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e1wiZGl2aWRlclwifSAvPlxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17Y3NzLm1vYmlsZV92aWRlb19kZXNjcmlwdGlvbn0+XG4gICAgICAgICAgICAgICAgICAgICAgICA8YT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICDwn5KyIFVQSSDigKIgcmFrYXpvbmVnYW1pbmdAb2tzYmkgPGJyIC8+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAg8J+SsiBTcG9uc29yIOKAoiBodHRwczovL3Jha2Euem9uZS9zcG9uc29yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGJyIC8+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAg8J+SsiBEb25hdGlvbiBWaWEgUGF5UGFsIOKAoiBodHRwczovL3Jha2Euem9uZS9wYXlwYWxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YnIgLz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICDwn5mPIEV2ZXJ5IFRpcCBJcyBBcHByZWNpYXRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgPC9hPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHAgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw9e3sgX19odG1sOiB2aWRlb0RhdGEuZGVzY3JpcHRpb24gfX0+PC9wPlxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICA8Lz5cbiAgICApXG59XG5cbmNvbnN0IERlc2t0b3BWaWRlb0RldGFpbHMgPSAoeyB2aWRlb0RhdGEsIHNldFNob3dEb25hdGVNb2RhbCB9KSA9PiB7XG4gICAgcmV0dXJuIChcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Nzcy5kZXNrdG9wX3ZpZGVvX2RldGFpbHN9PlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Nzcy5kZXNrdG9wX3ZpZGVvX2RldGFpbHNfd3JhcHBlcl9tYWlufT5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17Y3NzLmRlc2t0b3BfdmlkZW9fZGV0YWlsc193cmFwcGVyfT5cbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Nzcy5kZXNrdG9wX2RldGFpbHNfbGVmdH0+XG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17Y3NzLmRlc2t0b3BfdmlkZW9fZGV0YWlsc193cmFwcGVyX3RpdGxlfT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YSBjbGFzc05hbWU9e2Nzcy5kZXNrdG9wX3ZpZGVvX3RpdGxlfT57dmlkZW9EYXRhLnRpdGxlfTwvYT5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Nzcy5kZXNrdG9wX3ZpZGVvX3N0YXRzfT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17Y3NzLmRlc2t0b3BfdmlkZW9TdGF0c19pdGVtfT57dmlkZW9EYXRhLnZpZXdzfSBWaWV3czwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtjc3MuY29udGVudF9hYm91dF9kaXZpZGVyfSAvPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtjc3MuZGVza3RvcF92aWRlb1N0YXRzX2l0ZW19Pnt2aWRlb0RhdGEuYWdvfTwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17Y3NzLmRlc2t0b3BfdmlkZW9fb3RoZXJfZGV0YWlsc30+XG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17Y3NzLmRlc2t0b3BfdmlkZW9fb3RoZXJfZGV0YWlsc19pdGVtfT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17YG1hdGVyaWFsLWljb25zLXJvdW5kICR7Y3NzLmRlc2t0b3BfdmlkZW9fb3RoZXJfZGV0YWlsc19pY29uc31gfT50aHVtYl91cDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtjc3MuZGVza3RvcF92aWRlb19vdGhlcl9kZXRhaWxzX3RleHR9Pnt2aWRlb0RhdGEubGlrZXN9PC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtjc3MuZGVza3RvcF92aWRlb19vdGhlcl9kZXRhaWxzX2l0ZW19PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtgbWF0ZXJpYWwtaWNvbnMtcm91bmQgJHtjc3MuZGVza3RvcF92aWRlb19vdGhlcl9kZXRhaWxzX2ljb25zfWB9PnF1ZXN0aW9uX2Fuc3dlcjwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtjc3MuZGVza3RvcF92aWRlb19vdGhlcl9kZXRhaWxzX3RleHR9Pnt2aWRlb0RhdGEuY29tbWVudHN9PC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtjc3MuZGVza3RvcF92aWRlb19vdGhlcl9kZXRhaWxzX2l0ZW19PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtgbWF0ZXJpYWwtaWNvbnMtcm91bmQgJHtjc3MuZGVza3RvcF92aWRlb19vdGhlcl9kZXRhaWxzX2ljb25zfWB9PnNoYXJlPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Nzcy5kZXNrdG9wX3ZpZGVvX290aGVyX2RldGFpbHNfdGV4dH0+U2hhcmU8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Nzcy5kZXNrdG9wX3ZpZGVvX290aGVyX2RldGFpbHNfaXRlbX0gb25DbGljaz17KCkgPT4gc2V0U2hvd0RvbmF0ZU1vZGFsKHRydWUpfT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17YG1hdGVyaWFsLWljb25zLXJvdW5kICR7Y3NzLmRlc2t0b3BfdmlkZW9fb3RoZXJfZGV0YWlsc19pY29uc31gfT5hdHRhY2hfbW9uZXk8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17Y3NzLmRlc2t0b3BfdmlkZW9fb3RoZXJfZGV0YWlsc190ZXh0fT5UaGFua3M8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17XCJkaXZpZGVyLXNtYWxsXCJ9IC8+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Nzcy5kZXNrdG9wX3ZpZGVvX2Rlc2NyaXB0aW9ufT5cbiAgICAgICAgICAgICAgICAgICAgPGE+XG4gICAgICAgICAgICAgICAgICAgICAgICDwn5KyIFVQSSDigKIgcmFrYXpvbmVnYW1pbmdAb2tzYmkgPGJyIC8+XG4gICAgICAgICAgICAgICAgICAgICAgICDwn5KyIFNwb25zb3Ig4oCiIGh0dHBzOi8vcmFrYS56b25lL3Nwb25zb3JcbiAgICAgICAgICAgICAgICAgICAgICAgIDxiciAvPlxuICAgICAgICAgICAgICAgICAgICAgICAg8J+SsiBEb25hdGlvbiBWaWEgUGF5UGFsIOKAoiBodHRwczovL3Jha2Euem9uZS9wYXlwYWxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxiciAvPlxuICAgICAgICAgICAgICAgICAgICAgICAg8J+ZjyBFdmVyeSBUaXAgSXMgQXBwcmVjaWF0ZWRcbiAgICAgICAgICAgICAgICAgICAgPC9hPlxuICAgICAgICAgICAgICAgICAgICA8cCBkYW5nZXJvdXNseVNldElubmVySFRNTD17eyBfX2h0bWw6IHZpZGVvRGF0YS5kZXNjcmlwdGlvbiB9fT48L3A+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgKVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0U2VydmVyU2lkZVByb3BzKGNvbnRleHQpIHtcbiAgICBjb25zdCBVQSA9IGNvbnRleHQucmVxLmhlYWRlcnNbXCJ1c2VyLWFnZW50XCJdXG4gICAgY29uc3QgaXNNb2JpbGUgPSBCb29sZWFuKFVBLm1hdGNoKC9BbmRyb2lkfEJsYWNrQmVycnl8aVBob25lfGlQYWR8aVBvZHxPcGVyYSBNaW5pfElFTW9iaWxlfFdQRGVza3RvcC9pKSlcbiAgICBjb25zdCBpc0lPUyA9IEJvb2xlYW4oVUEubWF0Y2goL2lQaG9uZS9pKSlcbiAgICBjb25zdCB7IHZpZGVvSWQgfSA9IGNvbnRleHQucXVlcnlcbiAgICBsZXQgdmlkZW9EYXRhID0gYXdhaXQgYXhpb3MuZ2V0KGAke3B1YmxpY1J1bnRpbWVDb25maWcuYXBpVXJsfXZpZGVvRGF0YT92aWRlb0lkPSR7dmlkZW9JZH1gLCB7IHdpdGhDcmVkZW50aWFsczogdHJ1ZSB9KS50aGVuKChyZXMpID0+IHJlcy5kYXRhKVxuICAgIHJldHVybiB7XG4gICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICB2aWRlb0RhdGEsXG4gICAgICAgICAgICBpc01vYmlsZTogaXNNb2JpbGUgPyB0cnVlIDogZmFsc2UsXG4gICAgICAgICAgICBpc0lPU1xuICAgICAgICB9LFxuICAgIH1cbn1cbiJdLCJuYW1lcyI6WyJEb25hdGVNb2RhbCIsIm1vbWVudCIsIkhlYWQiLCJ1c2VFZmZlY3QiLCJ1c2VTdGF0ZSIsImNvbnZlcnRUb0ludGVybmF0aW9uYWxDdXJyZW5jeVN5c3RlbSIsIlZpZGVvUGxheWVyRGVza3RvcCIsIlZpZGVvUGxheWVyTW9iaWxlIiwiY3NzIiwiV2F0Y2giLCJwcm9wcyIsInZpZGVvRGF0YSIsImRhdGEiLCJ2aWRlb0lkIiwicHVibGlzaGVkQXQiLCJ1bml4IiwidGl0bGUiLCJsZW5ndGgiLCJzdWJzdHJpbmciLCJhZ28iLCJmcm9tTm93Iiwidmlld3MiLCJ2aWV3Q291bnQiLCJsaWtlcyIsImxpa2VDb3VudCIsImNvbW1lbnRzIiwiY29tbWVudENvdW50IiwiZGVzY3JpcHRpb24iLCJBZFZpZGVvU3JjIiwic2hvd0RvbmF0ZU1vZGFsIiwic2V0U2hvd0RvbmF0ZU1vZGFsIiwiaXNNb2JpbGUiLCJzZXRJc01vYmlsZSIsImxvYWRpbmciLCJzZXRMb2FkaW5nIiwiY29tcG9uZW50IiwiZGVza3RvcCIsImlzSU9TIiwiYWRTcmMiLCJtb2JpbGUiLCJkaXYiLCJjbGFzc05hbWUiLCJwbGF5ZXJfd3JhcHBlciIsIk1vYmlsZVZpZGVvRGV0YWlscyIsIkRlc2t0b3BWaWRlb0RldGFpbHMiLCJzaG93Iiwib25DbG9zZSIsIm1vYmlsZV92aWRlb19kZXRhaWxzIiwibW9iaWxlX3ZpZGVvX2RldGFpbHNfd3JhcHBlciIsIm1vYmlsZV92aWRlb19kZXRhaWxzX3dyYXBwZXJfbGVmdCIsIm1vYmlsZV92aWRlb19kZXRhaWxzX3dyYXBwZXJfbGVmdF90aXRsZSIsImgxIiwibW9iaWxlX3ZpZGVvX3N0YXRzIiwibW9iaWxlX3ZpZGVvU3RhdHNfaXRlbSIsImNvbnRlbnRfYWJvdXRfZGl2aWRlciIsIm1vYmlsZV92aWRlb19vdGhlcl9kZXRhaWxzIiwibW9iaWxlX3ZpZGVvX290aGVyX2RldGFpbHNfaXRlbSIsIm1vYmlsZV92aWRlb19vdGhlcl9kZXRhaWxzX2ljb25zIiwibW9iaWxlX3ZpZGVvX290aGVyX2RldGFpbHNfdGV4dCIsIm9uQ2xpY2siLCJtb2JpbGVfdmlkZW9fZGVzY3JpcHRpb24iLCJhIiwiYnIiLCJwIiwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwiLCJfX2h0bWwiLCJkZXNrdG9wX3ZpZGVvX2RldGFpbHMiLCJkZXNrdG9wX3ZpZGVvX2RldGFpbHNfd3JhcHBlcl9tYWluIiwiZGVza3RvcF92aWRlb19kZXRhaWxzX3dyYXBwZXIiLCJkZXNrdG9wX2RldGFpbHNfbGVmdCIsImRlc2t0b3BfdmlkZW9fZGV0YWlsc193cmFwcGVyX3RpdGxlIiwiZGVza3RvcF92aWRlb190aXRsZSIsImRlc2t0b3BfdmlkZW9fc3RhdHMiLCJkZXNrdG9wX3ZpZGVvU3RhdHNfaXRlbSIsImRlc2t0b3BfdmlkZW9fb3RoZXJfZGV0YWlscyIsImRlc2t0b3BfdmlkZW9fb3RoZXJfZGV0YWlsc19pdGVtIiwiZGVza3RvcF92aWRlb19vdGhlcl9kZXRhaWxzX2ljb25zIiwiZGVza3RvcF92aWRlb19vdGhlcl9kZXRhaWxzX3RleHQiLCJkZXNrdG9wX3ZpZGVvX2Rlc2NyaXB0aW9uIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/pages/Watch/[videoId].js\n");

/***/ }),

/***/ "./src/util/functions.js":
/*!*******************************!*\
  !*** ./src/util/functions.js ***!
  \*******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"convertToInternationalCurrencySystem\": function() { return /* binding */ convertToInternationalCurrencySystem; },\n/* harmony export */   \"fetcher\": function() { return /* binding */ fetcher; },\n/* harmony export */   \"formatDuration\": function() { return /* binding */ formatDuration; },\n/* harmony export */   \"get_random\": function() { return /* binding */ get_random; },\n/* harmony export */   \"makeid\": function() { return /* binding */ makeid; }\n/* harmony export */ });\nfunction _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction _arrayWithoutHoles(arr) {\n    if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\nfunction _iterableToArray(iter) {\n    if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _nonIterableSpread() {\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _toConsumableArray(arr) {\n    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(n);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nvar convertToInternationalCurrencySystem = function(labelValue) {\n    // Nine Zeroes for Billions\n    if (typeof labelValue !== \"number\") return labelValue;\n    var value = Math.abs(Number(labelValue)) >= 1.0e9 ? (Math.abs(Number(labelValue)) / 1.0e9).toFixed(2) + \"B\" : Math.abs(Number(labelValue)) >= 1.0e6 ? (Math.abs(Number(labelValue)) / 1.0e6).toFixed(2) + \"M\" : Math.abs(Number(labelValue)) >= 1.0e3 ? (Math.abs(Number(labelValue)) / 1.0e3).toFixed(2) + \"K\" : Math.abs(Number(labelValue));\n    return value;\n};\nvar get_random = function(list) {\n    return list[Math.floor(Math.random() * list.length)];\n};\nvar fetcher = function() {\n    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n        args[_key] = arguments[_key];\n    }\n    return fetch.apply(void 0, _toConsumableArray(args)).then(function(res) {\n        return res.json();\n    });\n};\nfunction makeid(length) {\n    var result = \"\";\n    var characters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\n    var charactersLength = characters.length;\n    for(var i = 0; i < length; i++){\n        result += characters.charAt(Math.floor(Math.random() * charactersLength));\n    }\n    return result;\n}\nvar leadingZeroFormatter = new Intl.NumberFormat(undefined, {\n    minimumIntegerDigits: 2\n});\nfunction formatDuration(time) {\n    if (isNaN(time)) return \"00:00\";\n    var seconds = Math.floor(time % 60);\n    var minutes = Math.floor(time / 60) % 60;\n    var hours = Math.floor(time / 3600);\n    if (hours === 0) {\n        return \"\".concat(minutes, \":\").concat(leadingZeroFormatter.format(seconds));\n    } else {\n        return \"\".concat(hours, \":\").concat(leadingZeroFormatter.format(minutes), \":\").concat(leadingZeroFormatter.format(seconds));\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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SUFDMUMsSUFBTUksS0FBSyxHQUFHL0IsSUFBSSxDQUFDTSxLQUFLLENBQUNxQixJQUFJLEdBQUcsSUFBSSxDQUFDO0lBQ3JDLElBQUlJLEtBQUssS0FBSyxDQUFDLEVBQUU7UUFDYixPQUFPLEVBQUMsQ0FBYVYsTUFBb0MsQ0FBL0NTLE9BQU8sRUFBQyxHQUFDLENBQXVDLFFBQXJDVCxvQkFBb0IsQ0FBQ1csTUFBTSxDQUFDSCxPQUFPLENBQUMsQ0FBRTtLQUM5RCxNQUFNO1FBQ0gsT0FBTyxFQUFDLENBQVdSLE1BQW9DLENBQTdDVSxLQUFLLEVBQUMsR0FBQyxDQUF1QyxDQUFHVixNQUFvQyxDQUE1RUEsb0JBQW9CLENBQUNXLE1BQU0sQ0FBQ0YsT0FBTyxDQUFDLEVBQUMsR0FBQyxDQUF1QyxRQUFyQ1Qsb0JBQW9CLENBQUNXLE1BQU0sQ0FBQ0gsT0FBTyxDQUFDLENBQUU7S0FDcEc7Q0FFSiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvdXRpbC9mdW5jdGlvbnMuanM/MTkyNiJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgY29udmVydFRvSW50ZXJuYXRpb25hbEN1cnJlbmN5U3lzdGVtID0gKGxhYmVsVmFsdWUpID0+IHtcbiAgICAvLyBOaW5lIFplcm9lcyBmb3IgQmlsbGlvbnNcbiAgICBpZiAodHlwZW9mIGxhYmVsVmFsdWUgIT09IFwibnVtYmVyXCIpIHJldHVybiBsYWJlbFZhbHVlXG4gICAgbGV0IHZhbHVlID1cbiAgICAgICAgTWF0aC5hYnMoTnVtYmVyKGxhYmVsVmFsdWUpKSA+PSAxLjBlOVxuICAgICAgICAgICAgPyAoTWF0aC5hYnMoTnVtYmVyKGxhYmVsVmFsdWUpKSAvIDEuMGU5KS50b0ZpeGVkKDIpICsgXCJCXCJcbiAgICAgICAgICAgIDogLy8gU2l4IFplcm9lcyBmb3IgTWlsbGlvbnNcbiAgICAgICAgICAgIE1hdGguYWJzKE51bWJlcihsYWJlbFZhbHVlKSkgPj0gMS4wZTZcbiAgICAgICAgICAgICAgICA/IChNYXRoLmFicyhOdW1iZXIobGFiZWxWYWx1ZSkpIC8gMS4wZTYpLnRvRml4ZWQoMikgKyBcIk1cIlxuICAgICAgICAgICAgICAgIDogLy8gVGhyZWUgWmVyb2VzIGZvciBUaG91c2FuZHNcbiAgICAgICAgICAgICAgICBNYXRoLmFicyhOdW1iZXIobGFiZWxWYWx1ZSkpID49IDEuMGUzXG4gICAgICAgICAgICAgICAgICAgID8gKE1hdGguYWJzKE51bWJlcihsYWJlbFZhbHVlKSkgLyAxLjBlMykudG9GaXhlZCgyKSArIFwiS1wiXG4gICAgICAgICAgICAgICAgICAgIDogTWF0aC5hYnMoTnVtYmVyKGxhYmVsVmFsdWUpKVxuXG4gICAgcmV0dXJuIHZhbHVlXG59XG5cbmV4cG9ydCBjb25zdCBnZXRfcmFuZG9tID0gKGxpc3QpID0+IHtcbiAgICByZXR1cm4gbGlzdFtNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBsaXN0Lmxlbmd0aCldXG59XG5cbmV4cG9ydCBjb25zdCBmZXRjaGVyID0gKC4uLmFyZ3MpID0+IGZldGNoKC4uLmFyZ3MpLnRoZW4oKHJlcykgPT4gcmVzLmpzb24oKSlcblxuZXhwb3J0IGZ1bmN0aW9uIG1ha2VpZChsZW5ndGgpIHtcbiAgICB2YXIgcmVzdWx0ID0gXCJcIlxuICAgIHZhciBjaGFyYWN0ZXJzID0gXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OVwiXG4gICAgdmFyIGNoYXJhY3RlcnNMZW5ndGggPSBjaGFyYWN0ZXJzLmxlbmd0aFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzdWx0ICs9IGNoYXJhY3RlcnMuY2hhckF0KE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGNoYXJhY3RlcnNMZW5ndGgpKVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0XG59XG5cbmNvbnN0IGxlYWRpbmdaZXJvRm9ybWF0dGVyID0gbmV3IEludGwuTnVtYmVyRm9ybWF0KHVuZGVmaW5lZCwge1xuICAgIG1pbmltdW1JbnRlZ2VyRGlnaXRzOiAyLFxufSlcblxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdER1cmF0aW9uKHRpbWUpIHtcbiAgICBpZiAoaXNOYU4odGltZSkpIHJldHVybiBcIjAwOjAwXCJcbiAgICBjb25zdCBzZWNvbmRzID0gTWF0aC5mbG9vcih0aW1lICUgNjApXG4gICAgY29uc3QgbWludXRlcyA9IE1hdGguZmxvb3IodGltZSAvIDYwKSAlIDYwXG4gICAgY29uc3QgaG91cnMgPSBNYXRoLmZsb29yKHRpbWUgLyAzNjAwKVxuICAgIGlmIChob3VycyA9PT0gMCkge1xuICAgICAgICByZXR1cm4gYCR7bWludXRlc306JHtsZWFkaW5nWmVyb0Zvcm1hdHRlci5mb3JtYXQoc2Vjb25kcyl9YFxuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBgJHtob3Vyc306JHtsZWFkaW5nWmVyb0Zvcm1hdHRlci5mb3JtYXQobWludXRlcyl9OiR7bGVhZGluZ1plcm9Gb3JtYXR0ZXIuZm9ybWF0KHNlY29uZHMpfWBcbiAgICB9XG5cbn1cbiJdLCJuYW1lcyI6WyJjb252ZXJ0VG9JbnRlcm5hdGlvbmFsQ3VycmVuY3lTeXN0ZW0iLCJsYWJlbFZhbHVlIiwidmFsdWUiLCJNYXRoIiwiYWJzIiwiTnVtYmVyIiwidG9GaXhlZCIsImdldF9yYW5kb20iLCJsaXN0IiwiZmxvb3IiLCJyYW5kb20iLCJsZW5ndGgiLCJmZXRjaGVyIiwiYXJncyIsImZldGNoIiwidGhlbiIsInJlcyIsImpzb24iLCJtYWtlaWQiLCJyZXN1bHQiLCJjaGFyYWN0ZXJzIiwiY2hhcmFjdGVyc0xlbmd0aCIsImkiLCJjaGFyQXQiLCJsZWFkaW5nWmVyb0Zvcm1hdHRlciIsIkludGwiLCJOdW1iZXJGb3JtYXQiLCJ1bmRlZmluZWQiLCJtaW5pbXVtSW50ZWdlckRpZ2l0cyIsImZvcm1hdER1cmF0aW9uIiwidGltZSIsImlzTmFOIiwic2Vjb25kcyIsIm1pbnV0ZXMiLCJob3VycyIsImZvcm1hdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/util/functions.js\n");

/***/ }),

/***/ "./node_modules/next/head.js":
/*!***********************************!*\
  !*** ./node_modules/next/head.js ***!
  \***********************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./dist/shared/lib/head */ \"./node_modules/next/dist/shared/lib/head.js\")\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9oZWFkLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBLGlIQUFrRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9oZWFkLmpzPzg4NDkiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Rpc3Qvc2hhcmVkL2xpYi9oZWFkJylcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/head.js\n");

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ var __webpack_exec__ = function(moduleId) { return __webpack_require__(__webpack_require__.s = moduleId); }
/******/ __webpack_require__.O(0, ["pages/_app","main"], function() { return __webpack_exec__("./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=%2Fhome%2Fisolated%2Frakazone%2Frakazone-frontend%2Fsrc%2Fpages%2FWatch%2F%5BvideoId%5D.js&page=%2FWatch%2F%5BvideoId%5D!"); });
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);